(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (process){
/*global setImmediate: false, setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null) {
      previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        var called = false;
        return function() {
            if (called) throw new Error("Callback was already called.");
            called = true;
            fn.apply(root, arguments);
        }
    }

    //// cross-browser compatiblity functions ////

    var _each = function (arr, iterator) {
        if (arr.forEach) {
            return arr.forEach(iterator);
        }
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        if (typeof setImmediate === 'function') {
            async.nextTick = function (fn) {
                // not a direct alias for IE10 compatibility
                setImmediate(fn);
            };
            async.setImmediate = async.nextTick;
        }
        else {
            async.nextTick = function (fn) {
                setTimeout(fn, 0);
            };
            async.setImmediate = async.nextTick;
        }
    }
    else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== 'undefined') {
            async.setImmediate = setImmediate;
        }
        else {
            async.setImmediate = async.nextTick;
        }
    }

    async.each = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
            iterator(x, only_once(function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback(null);
                    }
                }
            }));
        });
    };
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback(null);
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
    };
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit) {

        return function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length || limit <= 0) {
                return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish () {
                if (completed >= arr.length) {
                    return callback();
                }

                while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                replenish();
                            }
                        }
                    });
                }
            })();
        };
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.each].concat(args));
        };
    };
    var doParallelLimit = function(limit, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.eachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (err, v) {
                results[x.index] = v;
                callback(err);
            });
        }, function (err) {
            callback(err, results);
        });
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
    };

    var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
    };

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        if (!keys.length) {
            return callback(null);
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            _each(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (_keys(results).length === keys.length) {
                callback(null, results);
                callback = function () {};
            }
        });

        _each(keys, function (k) {
            var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];
            var taskCallback = function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _each(_keys(results), function(rkey) {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[k] = args;
                    callback(err, safeResults);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor !== Array) {
          var err = new Error('First argument to waterfall must be an array of functions');
          return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.setImmediate(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            eachfn.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            eachfn.each(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.parallel = function (tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.eachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            if (test()) {
                async.doWhilst(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doUntil = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            if (!test()) {
                async.doUntil(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.queue = function (worker, concurrency) {
        if (concurrency === undefined) {
            concurrency = 1;
        }
        function _insert(q, data, pos, callback) {
          if(data.constructor !== Array) {
              data = [data];
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
              };

              if (pos) {
                q.tasks.unshift(item);
              } else {
                q.tasks.push(item);
              }

              if (q.saturated && q.tasks.length === concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
                if (workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if (q.empty && q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    var next = function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if (q.drain && q.tasks.length + workers === 0) {
                            q.drain();
                        }
                        q.process();
                    };
                    var cb = only_once(next);
                    worker(task.data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            }
        };
        return q;
    };

    async.cargo = function (worker, payload) {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
                if(data.constructor !== Array) {
                    data = [data];
                }
                _each(data, function(task) {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    if (cargo.saturated && tasks.length === payload) {
                        cargo.saturated();
                    }
                });
                async.setImmediate(cargo.process);
            },
            process: function process() {
                if (working) return;
                if (tasks.length === 0) {
                    if(cargo.drain) cargo.drain();
                    return;
                }

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0);

                var ds = _map(ts, function (task) {
                    return task.data;
                });

                if(cargo.empty) cargo.empty();
                working = true;
                worker(ds, function () {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data) {
                        if (data.callback) {
                            data.callback.apply(null, args);
                        }
                    });

                    process();
                });
            },
            length: function () {
                return tasks.length;
            },
            running: function () {
                return working;
            }
        };
        return cargo;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _each(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                callback.apply(null, memo[key]);
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

    async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.map(counter, iterator, callback);
    };

    async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
    };

    async.compose = function (/* functions... */) {
        var fns = Array.prototype.reverse.call(arguments);
        return function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([function () {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1);
                    cb(err, nextargs);
                }]))
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        };
    };

    var _applyEach = function (eachfn, fns /*args...*/) {
        var go = function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            return eachfn(fns, function (fn, cb) {
                fn.apply(that, args.concat([cb]));
            },
            callback);
        };
        if (arguments.length > 2) {
            var args = Array.prototype.slice.call(arguments, 2);
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
    async.applyEach = doParallel(_applyEach);
    async.applyEachSeries = doSeries(_applyEach);

    async.forever = function (fn, callback) {
        function next(err) {
            if (err) {
                if (callback) {
                    return callback(err);
                }
                throw err;
            }
            fn(next);
        }
        next();
    };

    // AMD / RequireJS
    if (typeof define !== 'undefined' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // Node.js
    else if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

}).call(this,require("/Users/blakeembrey/Projects/api-notebook/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"/Users/blakeembrey/Projects/api-notebook/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":10}],2:[function(require,module,exports){
/**
 * Backbone.Native
 *
 * For all details and documentation:
 * http://github.com/inkling/backbone.native
 *
 * Copyright 2013 Inkling Systems, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * The purpose of this library is to allow Backbone to work without needing to load jQuery or Zepto.
 * This file provides a basic jQuery-like implementation for Backbone, implementing the
 * minimum functionality for Backbone to function. We assume that Backbone applications using
 * this will not expect the standard jQuery API to work, and will instead use native JS functions.
 *
 * Keep in mind that due to the APIs in this, it will likely only work on recent browsers.
 *
 * Note:
 *  - Core Backbone only needs collections with single members, so that is all that has been
 *      supported in this library. It is expected that you will just use querySelectorAll instead.
 *      This will be most obvious if you make heavy use of 'view.$'.
 *  - Events delegated with selectors starting with '>' are not supported.
 *  - Due to 'currentTarget' being read-only on standard DOM events, we cannot make standard
 *      events behave identically to jQuery's events when delegation is used. The element matching
 *      the delegate selector is instead passed as the second argument to event handlers.
 *  - The '$.ajax' implementation is very simple and likely needs to be expanded to better support
 *      standard use-cases.
 *
 * Tested with Backbone v0.9.2 and 1.0.0.
 */
(function(){
    "use strict";

    // Regular expression to match an event name and/or a namespace.
    var namespaceRE = /^([^.]+)?(?:\.([^.]+))?$/;

    var matchesSelector = Element.prototype.matchesSelector || null;
    if (!matchesSelector){
        ['webkit', 'moz', 'o', 'ms'].forEach(function(prefix){
            var func = Element.prototype[prefix + 'MatchesSelector'];
            if (func) matchesSelector = func;
        });
    }

    // The element property to save the cache key on.
    var cacheKeyProp = 'backboneNativeKey' + Math.random();
    var id = 1;
    var handlers = {};
    var unusedKeys = [];

    /**
     * Get the event handlers for a given element, creating an empty set if one doesn't exist.
     *
     * To avoid constantly filling the handlers object with null values, we reuse old IDs that
     * have been created and then cleared.
     *
     * @param {Element} el The element to get handlers for.
     *
     * @return {Array} An array of handlers.
     */
    function handlersFor(el){
        if (!el[cacheKeyProp]){
            // Pick a new key, from the unused pool, or make a new one.
            el[cacheKeyProp] = unusedKeys.length === 0 ? ++id : unusedKeys.pop();
        }

        var cacheKey = el[cacheKeyProp];
        return handlers[cacheKey] || (handlers[cacheKey] = []);
    }

    /**
     * Clear the event handlers for a given element.
     *
     * @param {Element} el The element to clear.
     */
    function clearHandlers(el){
        var cacheKey = el[cacheKeyProp];
        if (handlers[cacheKey]){
            handlers[cacheKey] = null;
            el[cacheKeyProp] = null;
            unusedKeys.push(cacheKey);
        }
    }

    /**
     * Add event handlers to an element.
     *
     * @param {Element} parentElement The element to bind event handlers to.
     * @param {string} eventName The event to bind, e.g. 'click'.
     * @param {string} selector (Optional) The selector to match when an event propagates up.
     * @param {function(Event, Element)} callback The function to call when the event is fired.
     */
    function on(parentElement, eventName, selector, callback){
        // Adjust arguments if selector was not provided.
        if (typeof selector === 'function'){
            callback = selector;
            selector = null;
        }

        var parts = namespaceRE.exec(eventName);
        eventName = parts[1] || null;
        var namespace = parts[2] || null;

        if (!eventName) return;

        var handler = callback;
        var originalCallback = callback;
        if (selector){
            // Event delegation handler to match a selector for child element events.
            handler = function(event){
                for (var el = event.target; el && el !== parentElement; el = el.parentElement){
                    if (matchesSelector.call(el, selector)){
                        // jQuery does not include the second argument, but we have included it
                        // for simplicity because 'this' will likely be bound to the view inside
                        // the callback, and as noted above, we cannot override 'currentTarget'.
                        var result = originalCallback.call(el, event, el);
                        if (result === false){
                            event.stopPropagation();
                            event.preventDefault();
                        }
                        return result;
                    }
                }
            };
        } else {
            // Standard event handler bound directly to the element.
            handler = function(event){
                var result = originalCallback.call(parentElement, event, parentElement);
                if (result === false){
                    event.stopPropagation();
                    event.preventDefault();
                }
                return result;
            };
        }

        parentElement.addEventListener(eventName, handler, false);

        // Save event handler metadata so that the handler can be unbound later.
        handlersFor(parentElement).push({
            eventName: eventName,
            callback: callback,
            handler: handler,
            namespace: namespace,
            selector: selector
        });
    }

    /**
     * Remove an event handler from an element.
     *
     * @param {Element} parentElement The element to unbind event handlers from.
     * @param {string} eventName (Optional) The event to unbind, e.g. 'click'.
     * @param {string} selector (Optional) The selector to unbind.
     * @param {function(Event, Element)} callback (Optional) The function to unbind.
     */
    function off(parentElement, eventName, selector, callback){
        if (typeof selector === 'function'){
            callback = selector;
            selector = null;
        }

        var parts = namespaceRE.exec(eventName || '');
        eventName = parts[1];
        var namespace = parts[2];
        var handlers = handlersFor(parentElement) || [];

        if (!eventName && !namespace && !selector && !callback){
            // Fastpath to remove all handlers.
            handlers.forEach(function(item){
                parentElement.removeEventListener(item.eventName, item.handler, false);
            });
            clearHandlers(parentElement);
        } else {
            var matchedHandlers = handlers.filter(function(item){
                return ((!namespace || item.namespace === namespace) &&
                    (!eventName || item.eventName === eventName) &&
                    (!callback || item.callback === callback) &&
                    (!selector || item.selector === selector));
            });

            matchedHandlers.forEach(function(item){
                parentElement.removeEventListener(item.eventName, item.handler, false);

                handlers.splice(handlers.indexOf(item), 1);
            });

            if (handlers.length === 0) clearHandlers(parentElement);
        }
    }

    /**
     * Construct a new jQuery-style element representation.
     *
     * @param {string|Element|Window} element There are several different possible values for this
     *      argument:
     *      - {string} A snippet of HTML, if it starts with a '<', or a selector to find.
     *      - {Element} An existing element to wrap.
     *      - {Window} The window object to wrap.
     * @param {Element} context The context to search within, if a selector was given.
     *      Defaults to document.
     */
    function $(element, context){
        context = context || document;

        // Call as a constructor if it was used as a function.
        if (!(this instanceof $)) return new $(element, context);

        if (!element){
            this.length = 0;
        } else if (typeof element === 'string'){
            if (/^\s*</.test(element)){
                // Parse arbitrary HTML into an element.
                var div = document.createElement('div');
                div.innerHTML = element;
                this[0] = div.firstChild;
                div.removeChild(div.firstChild);
                this.length = 1;
            } else {
                this[0] = context.querySelector(element);
                this.length = 1;
            }
        } else {
            // This handles both the 'Element' and 'Window' case, as both support
            // event binding via 'addEventListener'.
            this[0] = element;
            this.length = 1;
        }
    }

    $.prototype = {
        /**
         * The following methods are used by Backbone, but only in code-paths for IE 6/7 support.
         * Since none of this will work for old IE anyway, they are not implemented, and
         * instead left for documentation purposes.
         *
         * Used in Backbone.History.prototype.start.
         */
        hide: null,
        appendTo: null,

        /**
         * Find is not supported to encourage the use of querySelector(All) as an alternative.
         *
         * e.g.
         * Instead of 'this.$(sel)', use 'this.el.querySelectorAll(sel)'.
         *
         * Used in Backbone.View.prototype.$, but not actually called internally.
         */
        find: null,

        /**
         * Add attributes to the element.
         *
         * Used in Backbone.View.prototype.make.
         *
         * @param {Object} attributes A set of attributes to apply to the element.
         *
         * @return {$} This instance.
         */
        attr: function(attrs){
            Object.keys(attrs).forEach(function(attr){
                switch (attr){
                    case 'html':
                        this[0].innerHTML = attrs[attr];
                        break;
                    case 'text':
                        this[0].textContent = attrs[attr];
                        break;
                    case 'class':
                        this[0].className = attrs[attr];
                        break;
                    default:
                        this[0].setAttribute(attr, attrs[attr]);
                        break;
                }
            }, this);
            return this;
        },

        /**
         * Set the HTML content of the element. Backbone does not use the no-argument version
         * to read innerHTML, so that has not been implemented.
         *
         * Used in Backbone.View.prototype.make.
         *
         * @param {string} html The HTML to set as the element content.
         *
         * @return {$} This instance.
         */
        html: function(html){
            this[0].innerHTML = html;
            return this;
        },

        /**
         * Remove an element from the DOM and remove all event handlers bound to it and
         * its child elements.
         *
         * Used in Backbone.View.prototype.remove.
         *
         * @return {$} This instance.
         */
        remove: function(){
            var el = this[0];
            if (el.parentElement) el.parentElement.removeChild(el);

            // Unbind all event handlers on the element and children.
            (function removeChildEvents(element){
                off(element);

                for (var i = 0, len = element.childNodes.length; i < len; i++){
                    if (element.childNodes[i].nodeType !== Node.TEXT_NODE){
                        removeChildEvents(element.childNodes[i]);
                    }
                }
            })(el);

            return this;
        },

        /**
         * Bind an event handler to this element.
         *
         * @param {string} eventName The event to bind, e.g. 'click'.
         * @param {string} selector (Optional) The selector to match when an event propagates up.
         * @param {function(Event, Element)} callback The function to call when the event is fired.
         */
        on: function(eventName, selector, callback){
            on(this[0], eventName, selector, callback);
            return this;
        },

        /**
         * Unbind an event handler to this element.
         *
         * @param {string} eventName (Optional) The event to unbind, e.g. 'click'.
         * @param {string} selector (Optional) The selector to unbind.
         * @param {function(Event, Element)} callback (Optional) The function to unbind.
         */
        off: function(eventName, selector, callback){
            off(this[0], eventName, selector, callback);
            return this;
        },

        // Backbone v0.9.2 support.
        bind: function(eventName, callback){
            return this.on(eventName, callback);
        },
        unbind: function(eventName, callback){
            return this.off(eventName, callback);
        },
        delegate: function(selector, eventName, callback){
            return this.on(eventName, selector, callback);
        },
        undelegate: function(selector, eventName, callback){
            return this.off(eventName, selector, callback);
        }
    };

    /**
     * Send an AJAX request.
     *
     * @param {Object} options The options to use for the connection:
     *      - {string} url The URL to connect to.
     *      - {string} type The type of request, e.g. 'GET', or 'POST'.
     *      - {string} dataType The type of data expected, 'json'.
     *      - {string} contentType The content-type of the data.
     *      - {string|object} data The content to send.
     *      - {function(XMLHttpRequest)} beforeSend A callback to call before sending.
     *      - {boolean} processData True if 'data' should be converted
     *          to a query string from an object.
     *      - {function({string|object}, {string}, {XMLHttpRequest})} success The success callback.
     *      - {function({XMLHttpRequest})} error The error callback.
     */
    $.ajax = function(options){
        options = options || {};
        var type = options.type || 'GET';
        var url = options.url;
        var processData = options.processData === undefined ? true : !!options.processData;

        // Process the data for sending.
        var data = options.data;
        if (processData && typeof data === 'object'){
            var params = Object.keys(data).map(function(prop){
                return encodeURIComponent(prop) + '=' + encodeURIComponent(data[prop]);
            });
            data = params.join('&');
        }

        // Data for GET and HEAD goes in the URL.
        if (data && (type === 'GET' || type === 'HEAD')){
            url += (url.indexOf('?') === -1 ? '?' : '&') + data;
            data = undefined;
        }

        var xhr = new XMLHttpRequest();
        xhr.open(type, url, true);

        if (options.contentType) xhr.setRequestHeader('Content-Type', options.contentType);
        if (options.beforeSend) options.beforeSend(xhr);

        xhr.onload = function(){
            var error = false;
            var content = xhr.responseText;

            // Parse the JSON before calling success.
            if (options.dataType === 'json'){
                try {
                    content = JSON.parse(content);
                } catch (e){
                    error = true
                }
            }

            if (!error && (xhr.status >= 200 && xhr.status < 300)){
                // The last two arguments only apply to v0.9.2.
                if (options.success) options.success(content, xhr.statusText, xhr);
            } else {
                // This signature is inconsistent with v0.9.2, but is correct for 1.0.0.
                if (options.error) options.error(xhr);
            }
        }.bind(this);

        xhr.onerror = xhr.onabort = function(){
            if (options.error) options.error(xhr);
        };

        xhr.send(data);

        return xhr;
    };

    // Expose on/off for external use with having to instantiate a wrapper.
    $.on = on;
    $.off = off;

    if(typeof exports !== 'undefined') {
      return module.exports = $;
    }

    var root = this;
    var originalBackboneNative = root.Backbone ? root.Backbone.Native : null;
    var original$ = root.$;
    if (root.Backbone) root.Backbone.Native = $;
    root.$ = $;

    $.noConflict = function(deep){
        root.$ = original$;
        if (deep) root.Backbone.Native = originalBackboneNative;
        return $;
    };

    if (root.Backbone){
        if (root.Backbone.setDomLibrary){ // v0.9.2
            root.Backbone.setDomLibrary($);
        } else { // v1.0.0
            root.Backbone.$ = $;
        }
    }
}).call(this);

},{}],3:[function(require,module,exports){
//     Backbone.js 1.1.0

//     (c) 2010-2011 Jeremy Ashkenas, DocumentCloud Inc.
//     (c) 2011-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org

(function(){

  // Initial Setup
  // -------------

  // Save a reference to the global object (`window` in the browser, `exports`
  // on the server).
  var root = this;

  // Save the previous value of the `Backbone` variable, so that it can be
  // restored later on, if `noConflict` is used.
  var previousBackbone = root.Backbone;

  // Create local references to array methods we'll want to use later.
  var array = [];
  var push = array.push;
  var slice = array.slice;
  var splice = array.splice;

  // The top-level namespace. All public Backbone classes and modules will
  // be attached to this. Exported for both the browser and the server.
  var Backbone;
  if (typeof exports !== 'undefined') {
    Backbone = exports;
  } else {
    Backbone = root.Backbone = {};
  }

  // Current version of the library. Keep in sync with `package.json`.
  Backbone.VERSION = '1.1.0';

  // Require Underscore, if we're on the server, and it's not already present.
  var _ = root._;
  if (!_ && (typeof require !== 'undefined')) _ = require('underscore');

  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
  // the `$` variable.
  Backbone.$ = root.jQuery || root.Zepto || root.ender || root.$;

  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
  // to its previous owner. Returns a reference to this Backbone object.
  Backbone.noConflict = function() {
    root.Backbone = previousBackbone;
    return this;
  };

  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
  // will fake `"PATCH"`, `"PUT"` and `"DELETE"` requests via the `_method` parameter and
  // set a `X-Http-Method-Override` header.
  Backbone.emulateHTTP = false;

  // Turn on `emulateJSON` to support legacy servers that can't deal with direct
  // `application/json` requests ... will encode the body as
  // `application/x-www-form-urlencoded` instead and will send the model in a
  // form param named `model`.
  Backbone.emulateJSON = false;

  // Backbone.Events
  // ---------------

  // A module that can be mixed in to *any object* in order to provide it with
  // custom events. You may bind with `on` or remove with `off` callback
  // functions to an event; `trigger`-ing an event fires all callbacks in
  // succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  var Events = Backbone.Events = {

    // Bind an event to a `callback` function. Passing `"all"` will bind
    // the callback to all events fired.
    on: function(name, callback, context) {
      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
      this._events || (this._events = {});
      var events = this._events[name] || (this._events[name] = []);
      events.push({callback: callback, context: context, ctx: context || this});
      return this;
    },

    // Bind an event to only be triggered a single time. After the first time
    // the callback is invoked, it will be removed.
    once: function(name, callback, context) {
      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
      var self = this;
      var once = _.once(function() {
        self.off(name, once);
        callback.apply(this, arguments);
      });
      once._callback = callback;
      return this.on(name, once, context);
    },

    // Remove one or many callbacks. If `context` is null, removes all
    // callbacks with that function. If `callback` is null, removes all
    // callbacks for the event. If `name` is null, removes all bound
    // callbacks for all events.
    off: function(name, callback, context) {
      var retain, ev, events, names, i, l, j, k;
      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
      if (!name && !callback && !context) {
        this._events = {};
        return this;
      }
      names = name ? [name] : _.keys(this._events);
      for (i = 0, l = names.length; i < l; i++) {
        name = names[i];
        if (events = this._events[name]) {
          this._events[name] = retain = [];
          if (callback || context) {
            for (j = 0, k = events.length; j < k; j++) {
              ev = events[j];
              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                  (context && context !== ev.context)) {
                retain.push(ev);
              }
            }
          }
          if (!retain.length) delete this._events[name];
        }
      }

      return this;
    },

    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    trigger: function(name) {
      if (!this._events) return this;
      var args = slice.call(arguments, 1);
      if (!eventsApi(this, 'trigger', name, args)) return this;
      var events = this._events[name];
      var allEvents = this._events.all;
      if (events) triggerEvents(events, args);
      if (allEvents) triggerEvents(allEvents, arguments);
      return this;
    },

    // Tell this object to stop listening to either specific events ... or
    // to every object it's currently listening to.
    stopListening: function(obj, name, callback) {
      var listeningTo = this._listeningTo;
      if (!listeningTo) return this;
      var remove = !name && !callback;
      if (!callback && typeof name === 'object') callback = this;
      if (obj) (listeningTo = {})[obj._listenId] = obj;
      for (var id in listeningTo) {
        obj = listeningTo[id];
        obj.off(name, callback, this);
        if (remove || _.isEmpty(obj._events)) delete this._listeningTo[id];
      }
      return this;
    }

  };

  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // Implement fancy features of the Events API such as multiple event
  // names `"change blur"` and jQuery-style event maps `{change: action}`
  // in terms of the existing API.
  var eventsApi = function(obj, action, name, rest) {
    if (!name) return true;

    // Handle event maps.
    if (typeof name === 'object') {
      for (var key in name) {
        obj[action].apply(obj, [key, name[key]].concat(rest));
      }
      return false;
    }

    // Handle space separated event names.
    if (eventSplitter.test(name)) {
      var names = name.split(eventSplitter);
      for (var i = 0, l = names.length; i < l; i++) {
        obj[action].apply(obj, [names[i]].concat(rest));
      }
      return false;
    }

    return true;
  };

  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function(events, args) {
    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
    switch (args.length) {
      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);
    }
  };

  var listenMethods = {listenTo: 'on', listenToOnce: 'once'};

  // Inversion-of-control versions of `on` and `once`. Tell *this* object to
  // listen to an event in another object ... keeping track of what it's
  // listening to.
  _.each(listenMethods, function(implementation, method) {
    Events[method] = function(obj, name, callback) {
      var listeningTo = this._listeningTo || (this._listeningTo = {});
      var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
      listeningTo[id] = obj;
      if (!callback && typeof name === 'object') callback = this;
      obj[implementation](name, callback, this);
      return this;
    };
  });

  // Aliases for backwards compatibility.
  Events.bind   = Events.on;
  Events.unbind = Events.off;

  // Allow the `Backbone` object to serve as a global event bus, for folks who
  // want global "pubsub" in a convenient place.
  _.extend(Backbone, Events);

  // Backbone.Model
  // --------------

  // Backbone **Models** are the basic data object in the framework --
  // frequently representing a row in a table in a database on your server.
  // A discrete chunk of data and a bunch of useful, related methods for
  // performing computations and transformations on that data.

  // Create a new model with the specified attributes. A client id (`cid`)
  // is automatically generated and assigned for you.
  var Model = Backbone.Model = function(attributes, options) {
    var attrs = attributes || {};
    options || (options = {});
    this.cid = _.uniqueId('c');
    this.attributes = {};
    if (options.collection) this.collection = options.collection;
    if (options.parse) attrs = this.parse(attrs, options) || {};
    attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
    this.set(attrs, options);
    this.changed = {};
    this.initialize.apply(this, arguments);
  };

  // Attach all inheritable methods to the Model prototype.
  _.extend(Model.prototype, Events, {

    // A hash of attributes whose current and previous value differ.
    changed: null,

    // The value returned during the last failed validation.
    validationError: null,

    // The default name for the JSON `id` attribute is `"id"`. MongoDB and
    // CouchDB users may want to set this to `"_id"`.
    idAttribute: 'id',

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Return a copy of the model's `attributes` object.
    toJSON: function(options) {
      return _.clone(this.attributes);
    },

    // Proxy `Backbone.sync` by default -- but override this if you need
    // custom syncing semantics for *this* particular model.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Get the value of an attribute.
    get: function(attr) {
      return this.attributes[attr];
    },

    // Get the HTML-escaped value of an attribute.
    escape: function(attr) {
      return _.escape(this.get(attr));
    },

    // Returns `true` if the attribute contains a value that is not null
    // or undefined.
    has: function(attr) {
      return this.get(attr) != null;
    },

    // Set a hash of model attributes on the object, firing `"change"`. This is
    // the core primitive operation of a model, updating the data and notifying
    // anyone who needs to know about the change in state. The heart of the beast.
    set: function(key, val, options) {
      var attr, attrs, unset, changes, silent, changing, prev, current;
      if (key == null) return this;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options || (options = {});

      // Run validation.
      if (!this._validate(attrs, options)) return false;

      // Extract attributes and options.
      unset           = options.unset;
      silent          = options.silent;
      changes         = [];
      changing        = this._changing;
      this._changing  = true;

      if (!changing) {
        this._previousAttributes = _.clone(this.attributes);
        this.changed = {};
      }
      current = this.attributes, prev = this._previousAttributes;

      // Check for changes of `id`.
      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];

      // For each `set` attribute, update or delete the current value.
      for (attr in attrs) {
        val = attrs[attr];
        if (!_.isEqual(current[attr], val)) changes.push(attr);
        if (!_.isEqual(prev[attr], val)) {
          this.changed[attr] = val;
        } else {
          delete this.changed[attr];
        }
        unset ? delete current[attr] : current[attr] = val;
      }

      // Trigger all relevant attribute changes.
      if (!silent) {
        if (changes.length) this._pending = true;
        for (var i = 0, l = changes.length; i < l; i++) {
          this.trigger('change:' + changes[i], this, current[changes[i]], options);
        }
      }

      // You might be wondering why there's a `while` loop here. Changes can
      // be recursively nested within `"change"` events.
      if (changing) return this;
      if (!silent) {
        while (this._pending) {
          this._pending = false;
          this.trigger('change', this, options);
        }
      }
      this._pending = false;
      this._changing = false;
      return this;
    },

    // Remove an attribute from the model, firing `"change"`. `unset` is a noop
    // if the attribute doesn't exist.
    unset: function(attr, options) {
      return this.set(attr, void 0, _.extend({}, options, {unset: true}));
    },

    // Clear all attributes on the model, firing `"change"`.
    clear: function(options) {
      var attrs = {};
      for (var key in this.attributes) attrs[key] = void 0;
      return this.set(attrs, _.extend({}, options, {unset: true}));
    },

    // Determine if the model has changed since the last `"change"` event.
    // If you specify an attribute name, determine if that attribute has changed.
    hasChanged: function(attr) {
      if (attr == null) return !_.isEmpty(this.changed);
      return _.has(this.changed, attr);
    },

    // Return an object containing all the attributes that have changed, or
    // false if there are no changed attributes. Useful for determining what
    // parts of a view need to be updated and/or what attributes need to be
    // persisted to the server. Unset attributes will be set to undefined.
    // You can also pass an attributes object to diff against the model,
    // determining if there *would be* a change.
    changedAttributes: function(diff) {
      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
      var val, changed = false;
      var old = this._changing ? this._previousAttributes : this.attributes;
      for (var attr in diff) {
        if (_.isEqual(old[attr], (val = diff[attr]))) continue;
        (changed || (changed = {}))[attr] = val;
      }
      return changed;
    },

    // Get the previous value of an attribute, recorded at the time the last
    // `"change"` event was fired.
    previous: function(attr) {
      if (attr == null || !this._previousAttributes) return null;
      return this._previousAttributes[attr];
    },

    // Get all of the attributes of the model at the time of the previous
    // `"change"` event.
    previousAttributes: function() {
      return _.clone(this._previousAttributes);
    },

    // Fetch the model from the server. If the server's representation of the
    // model differs from its current attributes, they will be overridden,
    // triggering a `"change"` event.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        if (!model.set(model.parse(resp, options), options)) return false;
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Set a hash of model attributes, and sync the model to the server.
    // If the server returns an attributes hash that differs, the model's
    // state will be `set` again.
    save: function(key, val, options) {
      var attrs, method, xhr, attributes = this.attributes;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (key == null || typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options = _.extend({validate: true}, options);

      // If we're not waiting and attributes exist, save acts as
      // `set(attr).save(null, opts)` with validation. Otherwise, check if
      // the model will be valid when the attributes, if any, are set.
      if (attrs && !options.wait) {
        if (!this.set(attrs, options)) return false;
      } else {
        if (!this._validate(attrs, options)) return false;
      }

      // Set temporary attributes if `{wait: true}`.
      if (attrs && options.wait) {
        this.attributes = _.extend({}, attributes, attrs);
      }

      // After a successful server-side save, the client is (optionally)
      // updated with the server-side state.
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        // Ensure attributes are restored during synchronous saves.
        model.attributes = attributes;
        var serverAttrs = model.parse(resp, options);
        if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
        if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
          return false;
        }
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);

      method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
      if (method === 'patch') options.attrs = attrs;
      xhr = this.sync(method, this, options);

      // Restore attributes.
      if (attrs && options.wait) this.attributes = attributes;

      return xhr;
    },

    // Destroy this model on the server if it was already persisted.
    // Optimistically removes the model from its collection, if it has one.
    // If `wait: true` is passed, waits for the server to respond before removal.
    destroy: function(options) {
      options = options ? _.clone(options) : {};
      var model = this;
      var success = options.success;

      var destroy = function() {
        model.trigger('destroy', model, model.collection, options);
      };

      options.success = function(resp) {
        if (options.wait || model.isNew()) destroy();
        if (success) success(model, resp, options);
        if (!model.isNew()) model.trigger('sync', model, resp, options);
      };

      if (this.isNew()) {
        options.success();
        return false;
      }
      wrapError(this, options);

      var xhr = this.sync('delete', this, options);
      if (!options.wait) destroy();
      return xhr;
    },

    // Default URL for the model's representation on the server -- if you're
    // using Backbone's restful methods, override this to change the endpoint
    // that will be called.
    url: function() {
      var base = _.result(this, 'urlRoot') || _.result(this.collection, 'url') || urlError();
      if (this.isNew()) return base;
      return base + (base.charAt(base.length - 1) === '/' ? '' : '/') + encodeURIComponent(this.id);
    },

    // **parse** converts a response into the hash of attributes to be `set` on
    // the model. The default implementation is just to pass the response along.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new model with identical attributes to this one.
    clone: function() {
      return new this.constructor(this.attributes);
    },

    // A model is new if it has never been saved to the server, and lacks an id.
    isNew: function() {
      return this.id == null;
    },

    // Check if the model is currently in a valid state.
    isValid: function(options) {
      return this._validate({}, _.extend(options || {}, { validate: true }));
    },

    // Run validation against the next complete set of model attributes,
    // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
    _validate: function(attrs, options) {
      if (!options.validate || !this.validate) return true;
      attrs = _.extend({}, this.attributes, attrs);
      var error = this.validationError = this.validate(attrs, options) || null;
      if (!error) return true;
      this.trigger('invalid', this, error, _.extend(options, {validationError: error}));
      return false;
    }

  });

  // Underscore methods that we want to implement on the Model.
  var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit'];

  // Mix in each Underscore method as a proxy to `Model#attributes`.
  _.each(modelMethods, function(method) {
    Model.prototype[method] = function() {
      var args = slice.call(arguments);
      args.unshift(this.attributes);
      return _[method].apply(_, args);
    };
  });

  // Backbone.Collection
  // -------------------

  // If models tend to represent a single row of data, a Backbone Collection is
  // more analagous to a table full of data ... or a small slice or page of that
  // table, or a collection of rows that belong together for a particular reason
  // -- all of the messages in this particular folder, all of the documents
  // belonging to this particular author, and so on. Collections maintain
  // indexes of their models, both in order, and for lookup by `id`.

  // Create a new **Collection**, perhaps to contain a specific type of `model`.
  // If a `comparator` is specified, the Collection will maintain
  // its models in sort order, as they're added and removed.
  var Collection = Backbone.Collection = function(models, options) {
    options || (options = {});
    if (options.model) this.model = options.model;
    if (options.comparator !== void 0) this.comparator = options.comparator;
    this._reset();
    this.initialize.apply(this, arguments);
    if (models) this.reset(models, _.extend({silent: true}, options));
  };

  // Default options for `Collection#set`.
  var setOptions = {add: true, remove: true, merge: true};
  var addOptions = {add: true, remove: false};

  // Define the Collection's inheritable methods.
  _.extend(Collection.prototype, Events, {

    // The default model for a collection is just a **Backbone.Model**.
    // This should be overridden in most cases.
    model: Model,

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // The JSON representation of a Collection is an array of the
    // models' attributes.
    toJSON: function(options) {
      return this.map(function(model){ return model.toJSON(options); });
    },

    // Proxy `Backbone.sync` by default.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Add a model, or list of models to the set.
    add: function(models, options) {
      return this.set(models, _.extend({merge: false}, options, addOptions));
    },

    // Remove a model, or a list of models from the set.
    remove: function(models, options) {
      var singular = !_.isArray(models);
      models = singular ? [models] : _.clone(models);
      options || (options = {});
      var i, l, index, model;
      for (i = 0, l = models.length; i < l; i++) {
        model = models[i] = this.get(models[i]);
        if (!model) continue;
        delete this._byId[model.id];
        delete this._byId[model.cid];
        index = this.indexOf(model);
        this.models.splice(index, 1);
        this.length--;
        if (!options.silent) {
          options.index = index;
          model.trigger('remove', model, this, options);
        }
        this._removeReference(model);
      }
      return singular ? models[0] : models;
    },

    // Update a collection by `set`-ing a new list of models, adding new ones,
    // removing models that are no longer present, and merging models that
    // already exist in the collection, as necessary. Similar to **Model#set**,
    // the core operation for updating the data contained by the collection.
    set: function(models, options) {
      options = _.defaults({}, options, setOptions);
      if (options.parse) models = this.parse(models, options);
      var singular = !_.isArray(models);
      models = singular ? (models ? [models] : []) : _.clone(models);
      var i, l, id, model, attrs, existing, sort;
      var at = options.at;
      var targetModel = this.model;
      var sortable = this.comparator && (at == null) && options.sort !== false;
      var sortAttr = _.isString(this.comparator) ? this.comparator : null;
      var toAdd = [], toRemove = [], modelMap = {};
      var add = options.add, merge = options.merge, remove = options.remove;
      var order = !sortable && add && remove ? [] : false;

      // Turn bare objects into model references, and prevent invalid models
      // from being added.
      for (i = 0, l = models.length; i < l; i++) {
        attrs = models[i];
        if (attrs instanceof Model) {
          id = model = attrs;
        } else {
          id = attrs[targetModel.prototype.idAttribute];
        }

        // If a duplicate is found, prevent it from being added and
        // optionally merge it into the existing model.
        if (existing = this.get(id)) {
          if (remove) modelMap[existing.cid] = true;
          if (merge) {
            attrs = attrs === model ? model.attributes : attrs;
            if (options.parse) attrs = existing.parse(attrs, options);
            existing.set(attrs, options);
            if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;
          }
          models[i] = existing;

        // If this is a new, valid model, push it to the `toAdd` list.
        } else if (add) {
          model = models[i] = this._prepareModel(attrs, options);
          if (!model) continue;
          toAdd.push(model);

          // Listen to added models' events, and index models for lookup by
          // `id` and by `cid`.
          model.on('all', this._onModelEvent, this);
          this._byId[model.cid] = model;
          if (model.id != null) this._byId[model.id] = model;
        }
        if (order) order.push(existing || model);
      }

      // Remove nonexistent models if appropriate.
      if (remove) {
        for (i = 0, l = this.length; i < l; ++i) {
          if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);
        }
        if (toRemove.length) this.remove(toRemove, options);
      }

      // See if sorting is needed, update `length` and splice in new models.
      if (toAdd.length || (order && order.length)) {
        if (sortable) sort = true;
        this.length += toAdd.length;
        if (at != null) {
          for (i = 0, l = toAdd.length; i < l; i++) {
            this.models.splice(at + i, 0, toAdd[i]);
          }
        } else {
          if (order) this.models.length = 0;
          var orderedModels = order || toAdd;
          for (i = 0, l = orderedModels.length; i < l; i++) {
            this.models.push(orderedModels[i]);
          }
        }
      }

      // Silently sort the collection if appropriate.
      if (sort) this.sort({silent: true});

      // Unless silenced, it's time to fire all appropriate add/sort events.
      if (!options.silent) {
        for (i = 0, l = toAdd.length; i < l; i++) {
          (model = toAdd[i]).trigger('add', model, this, options);
        }
        if (sort || (order && order.length)) this.trigger('sort', this, options);
      }
      
      // Return the added (or merged) model (or models).
      return singular ? models[0] : models;
    },

    // When you have more items than you want to add or remove individually,
    // you can reset the entire set with a new list of models, without firing
    // any granular `add` or `remove` events. Fires `reset` when finished.
    // Useful for bulk operations and optimizations.
    reset: function(models, options) {
      options || (options = {});
      for (var i = 0, l = this.models.length; i < l; i++) {
        this._removeReference(this.models[i]);
      }
      options.previousModels = this.models;
      this._reset();
      models = this.add(models, _.extend({silent: true}, options));
      if (!options.silent) this.trigger('reset', this, options);
      return models;
    },

    // Add a model to the end of the collection.
    push: function(model, options) {
      return this.add(model, _.extend({at: this.length}, options));
    },

    // Remove a model from the end of the collection.
    pop: function(options) {
      var model = this.at(this.length - 1);
      this.remove(model, options);
      return model;
    },

    // Add a model to the beginning of the collection.
    unshift: function(model, options) {
      return this.add(model, _.extend({at: 0}, options));
    },

    // Remove a model from the beginning of the collection.
    shift: function(options) {
      var model = this.at(0);
      this.remove(model, options);
      return model;
    },

    // Slice out a sub-array of models from the collection.
    slice: function() {
      return slice.apply(this.models, arguments);
    },

    // Get a model from the set by id.
    get: function(obj) {
      if (obj == null) return void 0;
      return this._byId[obj.id] || this._byId[obj.cid] || this._byId[obj];
    },

    // Get the model at the given index.
    at: function(index) {
      return this.models[index];
    },

    // Return models with matching attributes. Useful for simple cases of
    // `filter`.
    where: function(attrs, first) {
      if (_.isEmpty(attrs)) return first ? void 0 : [];
      return this[first ? 'find' : 'filter'](function(model) {
        for (var key in attrs) {
          if (attrs[key] !== model.get(key)) return false;
        }
        return true;
      });
    },

    // Return the first model with matching attributes. Useful for simple cases
    // of `find`.
    findWhere: function(attrs) {
      return this.where(attrs, true);
    },

    // Force the collection to re-sort itself. You don't need to call this under
    // normal circumstances, as the set will maintain sort order as each item
    // is added.
    sort: function(options) {
      if (!this.comparator) throw new Error('Cannot sort a set without a comparator');
      options || (options = {});

      // Run sort based on type of `comparator`.
      if (_.isString(this.comparator) || this.comparator.length === 1) {
        this.models = this.sortBy(this.comparator, this);
      } else {
        this.models.sort(_.bind(this.comparator, this));
      }

      if (!options.silent) this.trigger('sort', this, options);
      return this;
    },

    // Pluck an attribute from each model in the collection.
    pluck: function(attr) {
      return _.invoke(this.models, 'get', attr);
    },

    // Fetch the default set of models for this collection, resetting the
    // collection when they arrive. If `reset: true` is passed, the response
    // data will be passed through the `reset` method instead of `set`.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var success = options.success;
      var collection = this;
      options.success = function(resp) {
        var method = options.reset ? 'reset' : 'set';
        collection[method](resp, options);
        if (success) success(collection, resp, options);
        collection.trigger('sync', collection, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Create a new instance of a model in this collection. Add the model to the
    // collection immediately, unless `wait: true` is passed, in which case we
    // wait for the server to agree.
    create: function(model, options) {
      options = options ? _.clone(options) : {};
      if (!(model = this._prepareModel(model, options))) return false;
      if (!options.wait) this.add(model, options);
      var collection = this;
      var success = options.success;
      options.success = function(model, resp, options) {
        if (options.wait) collection.add(model, options);
        if (success) success(model, resp, options);
      };
      model.save(null, options);
      return model;
    },

    // **parse** converts a response into a list of models to be added to the
    // collection. The default implementation is just to pass it through.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new collection with an identical list of models as this one.
    clone: function() {
      return new this.constructor(this.models);
    },

    // Private method to reset all internal state. Called when the collection
    // is first initialized or reset.
    _reset: function() {
      this.length = 0;
      this.models = [];
      this._byId  = {};
    },

    // Prepare a hash of attributes (or other model) to be added to this
    // collection.
    _prepareModel: function(attrs, options) {
      if (attrs instanceof Model) {
        if (!attrs.collection) attrs.collection = this;
        return attrs;
      }
      options = options ? _.clone(options) : {};
      options.collection = this;
      var model = new this.model(attrs, options);
      if (!model.validationError) return model;
      this.trigger('invalid', this, model.validationError, options);
      return false;
    },

    // Internal method to sever a model's ties to a collection.
    _removeReference: function(model) {
      if (this === model.collection) delete model.collection;
      model.off('all', this._onModelEvent, this);
    },

    // Internal method called every time a model in the set fires an event.
    // Sets need to update their indexes when models change ids. All other
    // events simply proxy through. "add" and "remove" events that originate
    // in other collections are ignored.
    _onModelEvent: function(event, model, collection, options) {
      if ((event === 'add' || event === 'remove') && collection !== this) return;
      if (event === 'destroy') this.remove(model, options);
      if (model && event === 'change:' + model.idAttribute) {
        delete this._byId[model.previous(model.idAttribute)];
        if (model.id != null) this._byId[model.id] = model;
      }
      this.trigger.apply(this, arguments);
    }

  });

  // Underscore methods that we want to implement on the Collection.
  // 90% of the core usefulness of Backbone Collections is actually implemented
  // right here:
  var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',
    'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',
    'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',
    'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',
    'tail', 'drop', 'last', 'without', 'difference', 'indexOf', 'shuffle',
    'lastIndexOf', 'isEmpty', 'chain'];

  // Mix in each Underscore method as a proxy to `Collection#models`.
  _.each(methods, function(method) {
    Collection.prototype[method] = function() {
      var args = slice.call(arguments);
      args.unshift(this.models);
      return _[method].apply(_, args);
    };
  });

  // Underscore methods that take a property name as an argument.
  var attributeMethods = ['groupBy', 'countBy', 'sortBy'];

  // Use attributes instead of properties.
  _.each(attributeMethods, function(method) {
    Collection.prototype[method] = function(value, context) {
      var iterator = _.isFunction(value) ? value : function(model) {
        return model.get(value);
      };
      return _[method](this.models, iterator, context);
    };
  });

  // Backbone.View
  // -------------

  // Backbone Views are almost more convention than they are actual code. A View
  // is simply a JavaScript object that represents a logical chunk of UI in the
  // DOM. This might be a single item, an entire list, a sidebar or panel, or
  // even the surrounding frame which wraps your whole app. Defining a chunk of
  // UI as a **View** allows you to define your DOM events declaratively, without
  // having to worry about render order ... and makes it easy for the view to
  // react to specific changes in the state of your models.

  // Creating a Backbone.View creates its initial element outside of the DOM,
  // if an existing element is not provided...
  var View = Backbone.View = function(options) {
    this.cid = _.uniqueId('view');
    options || (options = {});
    _.extend(this, _.pick(options, viewOptions));
    this._ensureElement();
    this.initialize.apply(this, arguments);
    this.delegateEvents();
  };

  // Cached regex to split keys for `delegate`.
  var delegateEventSplitter = /^(\S+)\s*(.*)$/;

  // List of view options to be merged as properties.
  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

  // Set up all inheritable **Backbone.View** properties and methods.
  _.extend(View.prototype, Events, {

    // The default `tagName` of a View's element is `"div"`.
    tagName: 'div',

    // jQuery delegate for element lookup, scoped to DOM elements within the
    // current view. This should be preferred to global lookups where possible.
    $: function(selector) {
      return this.$el.find(selector);
    },

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // **render** is the core function that your view should override, in order
    // to populate its element (`this.el`), with the appropriate HTML. The
    // convention is for **render** to always return `this`.
    render: function() {
      return this;
    },

    // Remove this view by taking the element out of the DOM, and removing any
    // applicable Backbone.Events listeners.
    remove: function() {
      this.$el.remove();
      this.stopListening();
      return this;
    },

    // Change the view's element (`this.el` property), including event
    // re-delegation.
    setElement: function(element, delegate) {
      if (this.$el) this.undelegateEvents();
      this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);
      this.el = this.$el[0];
      if (delegate !== false) this.delegateEvents();
      return this;
    },

    // Set callbacks, where `this.events` is a hash of
    //
    // *{"event selector": "callback"}*
    //
    //     {
    //       'mousedown .title':  'edit',
    //       'click .button':     'save',
    //       'click .open':       function(e) { ... }
    //     }
    //
    // pairs. Callbacks will be bound to the view, with `this` set properly.
    // Uses event delegation for efficiency.
    // Omitting the selector binds the event to `this.el`.
    // This only works for delegate-able events: not `focus`, `blur`, and
    // not `change`, `submit`, and `reset` in Internet Explorer.
    delegateEvents: function(events) {
      if (!(events || (events = _.result(this, 'events')))) return this;
      this.undelegateEvents();
      for (var key in events) {
        var method = events[key];
        if (!_.isFunction(method)) method = this[events[key]];
        if (!method) continue;

        var match = key.match(delegateEventSplitter);
        var eventName = match[1], selector = match[2];
        method = _.bind(method, this);
        eventName += '.delegateEvents' + this.cid;
        if (selector === '') {
          this.$el.on(eventName, method);
        } else {
          this.$el.on(eventName, selector, method);
        }
      }
      return this;
    },

    // Clears all callbacks previously bound to the view with `delegateEvents`.
    // You usually don't need to use this, but may wish to if you have multiple
    // Backbone views attached to the same DOM element.
    undelegateEvents: function() {
      this.$el.off('.delegateEvents' + this.cid);
      return this;
    },

    // Ensure that the View has a DOM element to render into.
    // If `this.el` is a string, pass it through `$()`, take the first
    // matching element, and re-assign it to `el`. Otherwise, create
    // an element from the `id`, `className` and `tagName` properties.
    _ensureElement: function() {
      if (!this.el) {
        var attrs = _.extend({}, _.result(this, 'attributes'));
        if (this.id) attrs.id = _.result(this, 'id');
        if (this.className) attrs['class'] = _.result(this, 'className');
        var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);
        this.setElement($el, false);
      } else {
        this.setElement(_.result(this, 'el'), false);
      }
    }

  });

  // Backbone.sync
  // -------------

  // Override this function to change the manner in which Backbone persists
  // models to the server. You will be passed the type of request, and the
  // model in question. By default, makes a RESTful Ajax request
  // to the model's `url()`. Some possible customizations could be:
  //
  // * Use `setTimeout` to batch rapid-fire updates into a single request.
  // * Send up the models as XML instead of JSON.
  // * Persist models via WebSockets instead of Ajax.
  //
  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
  // as `POST`, with a `_method` parameter containing the true HTTP method,
  // as well as all requests with the body as `application/x-www-form-urlencoded`
  // instead of `application/json` with the model in a param named `model`.
  // Useful when interfacing with server-side languages like **PHP** that make
  // it difficult to read the body of `PUT` requests.
  Backbone.sync = function(method, model, options) {
    var type = methodMap[method];

    // Default options, unless specified.
    _.defaults(options || (options = {}), {
      emulateHTTP: Backbone.emulateHTTP,
      emulateJSON: Backbone.emulateJSON
    });

    // Default JSON-request options.
    var params = {type: type, dataType: 'json'};

    // Ensure that we have a URL.
    if (!options.url) {
      params.url = _.result(model, 'url') || urlError();
    }

    // Ensure that we have the appropriate request data.
    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
      params.contentType = 'application/json';
      params.data = JSON.stringify(options.attrs || model.toJSON(options));
    }

    // For older servers, emulate JSON by encoding the request into an HTML-form.
    if (options.emulateJSON) {
      params.contentType = 'application/x-www-form-urlencoded';
      params.data = params.data ? {model: params.data} : {};
    }

    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
    // And an `X-HTTP-Method-Override` header.
    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
      params.type = 'POST';
      if (options.emulateJSON) params.data._method = type;
      var beforeSend = options.beforeSend;
      options.beforeSend = function(xhr) {
        xhr.setRequestHeader('X-HTTP-Method-Override', type);
        if (beforeSend) return beforeSend.apply(this, arguments);
      };
    }

    // Don't process data on a non-GET request.
    if (params.type !== 'GET' && !options.emulateJSON) {
      params.processData = false;
    }

    // If we're sending a `PATCH` request, and we're in an old Internet Explorer
    // that still has ActiveX enabled by default, override jQuery to use that
    // for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.
    if (params.type === 'PATCH' && noXhrPatch) {
      params.xhr = function() {
        return new ActiveXObject("Microsoft.XMLHTTP");
      };
    }

    // Make the request, allowing the user to override any Ajax options.
    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
    model.trigger('request', model, xhr, options);
    return xhr;
  };

  var noXhrPatch = typeof window !== 'undefined' && !!window.ActiveXObject && !(window.XMLHttpRequest && (new XMLHttpRequest).dispatchEvent);

  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
  var methodMap = {
    'create': 'POST',
    'update': 'PUT',
    'patch':  'PATCH',
    'delete': 'DELETE',
    'read':   'GET'
  };

  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
  // Override this if you'd like to use a different library.
  Backbone.ajax = function() {
    return Backbone.$.ajax.apply(Backbone.$, arguments);
  };

  // Backbone.Router
  // ---------------

  // Routers map faux-URLs to actions, and fire events when routes are
  // matched. Creating a new one sets its `routes` hash, if not set statically.
  var Router = Backbone.Router = function(options) {
    options || (options = {});
    if (options.routes) this.routes = options.routes;
    this._bindRoutes();
    this.initialize.apply(this, arguments);
  };

  // Cached regular expressions for matching named param parts and splatted
  // parts of route strings.
  var optionalParam = /\((.*?)\)/g;
  var namedParam    = /(\(\?)?:\w+/g;
  var splatParam    = /\*\w+/g;
  var escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g;

  // Set up all inheritable **Backbone.Router** properties and methods.
  _.extend(Router.prototype, Events, {

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Manually bind a single named route to a callback. For example:
    //
    //     this.route('search/:query/p:num', 'search', function(query, num) {
    //       ...
    //     });
    //
    route: function(route, name, callback) {
      if (!_.isRegExp(route)) route = this._routeToRegExp(route);
      if (_.isFunction(name)) {
        callback = name;
        name = '';
      }
      if (!callback) callback = this[name];
      var router = this;
      Backbone.history.route(route, function(fragment) {
        var args = router._extractParameters(route, fragment);
        callback && callback.apply(router, args);
        router.trigger.apply(router, ['route:' + name].concat(args));
        router.trigger('route', name, args);
        Backbone.history.trigger('route', router, name, args);
      });
      return this;
    },

    // Simple proxy to `Backbone.history` to save a fragment into the history.
    navigate: function(fragment, options) {
      Backbone.history.navigate(fragment, options);
      return this;
    },

    // Bind all defined routes to `Backbone.history`. We have to reverse the
    // order of the routes here to support behavior where the most general
    // routes can be defined at the bottom of the route map.
    _bindRoutes: function() {
      if (!this.routes) return;
      this.routes = _.result(this, 'routes');
      var route, routes = _.keys(this.routes);
      while ((route = routes.pop()) != null) {
        this.route(route, this.routes[route]);
      }
    },

    // Convert a route string into a regular expression, suitable for matching
    // against the current location hash.
    _routeToRegExp: function(route) {
      route = route.replace(escapeRegExp, '\\$&')
                   .replace(optionalParam, '(?:$1)?')
                   .replace(namedParam, function(match, optional) {
                     return optional ? match : '([^\/]+)';
                   })
                   .replace(splatParam, '(.*?)');
      return new RegExp('^' + route + '$');
    },

    // Given a route, and a URL fragment that it matches, return the array of
    // extracted decoded parameters. Empty or unmatched parameters will be
    // treated as `null` to normalize cross-browser behavior.
    _extractParameters: function(route, fragment) {
      var params = route.exec(fragment).slice(1);
      return _.map(params, function(param) {
        return param ? decodeURIComponent(param) : null;
      });
    }

  });

  // Backbone.History
  // ----------------

  // Handles cross-browser history management, based on either
  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
  // and URL fragments. If the browser supports neither (old IE, natch),
  // falls back to polling.
  var History = Backbone.History = function() {
    this.handlers = [];
    _.bindAll(this, 'checkUrl');

    // Ensure that `History` can be used outside of the browser.
    if (typeof window !== 'undefined') {
      this.location = window.location;
      this.history = window.history;
    }
  };

  // Cached regex for stripping a leading hash/slash and trailing space.
  var routeStripper = /^[#\/]|\s+$/g;

  // Cached regex for stripping leading and trailing slashes.
  var rootStripper = /^\/+|\/+$/g;

  // Cached regex for detecting MSIE.
  var isExplorer = /msie [\w.]+/;

  // Cached regex for removing a trailing slash.
  var trailingSlash = /\/$/;

  // Cached regex for stripping urls of hash and query.
  var pathStripper = /[?#].*$/;

  // Has the history handling already been started?
  History.started = false;

  // Set up all inheritable **Backbone.History** properties and methods.
  _.extend(History.prototype, Events, {

    // The default interval to poll for hash changes, if necessary, is
    // twenty times a second.
    interval: 50,

    // Gets the true hash value. Cannot use location.hash directly due to bug
    // in Firefox where location.hash will always be decoded.
    getHash: function(window) {
      var match = (window || this).location.href.match(/#(.*)$/);
      return match ? match[1] : '';
    },

    // Get the cross-browser normalized URL fragment, either from the URL,
    // the hash, or the override.
    getFragment: function(fragment, forcePushState) {
      if (fragment == null) {
        if (this._hasPushState || !this._wantsHashChange || forcePushState) {
          fragment = this.location.pathname;
          var root = this.root.replace(trailingSlash, '');
          if (!fragment.indexOf(root)) fragment = fragment.slice(root.length);
        } else {
          fragment = this.getHash();
        }
      }
      return fragment.replace(routeStripper, '');
    },

    // Start the hash change handling, returning `true` if the current URL matches
    // an existing route, and `false` otherwise.
    start: function(options) {
      if (History.started) throw new Error("Backbone.history has already been started");
      History.started = true;

      // Figure out the initial configuration. Do we need an iframe?
      // Is pushState desired ... is it available?
      this.options          = _.extend({root: '/'}, this.options, options);
      this.root             = this.options.root;
      this._wantsHashChange = this.options.hashChange !== false;
      this._wantsPushState  = !!this.options.pushState;
      this._hasPushState    = !!(this.options.pushState && this.history && this.history.pushState);
      var fragment          = this.getFragment();
      var docMode           = document.documentMode;
      var oldIE             = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));

      // Normalize root to always include a leading and trailing slash.
      this.root = ('/' + this.root + '/').replace(rootStripper, '/');

      if (oldIE && this._wantsHashChange) {
        this.iframe = Backbone.$('<iframe src="javascript:0" tabindex="-1" />').hide().appendTo('body')[0].contentWindow;
        this.navigate(fragment);
      }

      // Depending on whether we're using pushState or hashes, and whether
      // 'onhashchange' is supported, determine how we check the URL state.
      if (this._hasPushState) {
        Backbone.$(window).on('popstate', this.checkUrl);
      } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {
        Backbone.$(window).on('hashchange', this.checkUrl);
      } else if (this._wantsHashChange) {
        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
      }

      // Determine if we need to change the base url, for a pushState link
      // opened by a non-pushState browser.
      this.fragment = fragment;
      var loc = this.location;
      var atRoot = loc.pathname.replace(/[^\/]$/, '$&/') === this.root;

      // Transition from hashChange to pushState or vice versa if both are
      // requested.
      if (this._wantsHashChange && this._wantsPushState) {

        // If we've started off with a route from a `pushState`-enabled
        // browser, but we're currently in a browser that doesn't support it...
        if (!this._hasPushState && !atRoot) {
          this.fragment = this.getFragment(null, true);
          this.location.replace(this.root + this.location.search + '#' + this.fragment);
          // Return immediately as browser will do redirect to new url
          return true;

        // Or if we've started out with a hash-based route, but we're currently
        // in a browser where it could be `pushState`-based instead...
        } else if (this._hasPushState && atRoot && loc.hash) {
          this.fragment = this.getHash().replace(routeStripper, '');
          this.history.replaceState({}, document.title, this.root + this.fragment + loc.search);
        }

      }

      if (!this.options.silent) return this.loadUrl();
    },

    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
    // but possibly useful for unit testing Routers.
    stop: function() {
      Backbone.$(window).off('popstate', this.checkUrl).off('hashchange', this.checkUrl);
      clearInterval(this._checkUrlInterval);
      History.started = false;
    },

    // Add a route to be tested when the fragment changes. Routes added later
    // may override previous routes.
    route: function(route, callback) {
      this.handlers.unshift({route: route, callback: callback});
    },

    // Checks the current URL to see if it has changed, and if it has,
    // calls `loadUrl`, normalizing across the hidden iframe.
    checkUrl: function(e) {
      var current = this.getFragment();
      if (current === this.fragment && this.iframe) {
        current = this.getFragment(this.getHash(this.iframe));
      }
      if (current === this.fragment) return false;
      if (this.iframe) this.navigate(current);
      this.loadUrl();
    },

    // Attempt to load the current URL fragment. If a route succeeds with a
    // match, returns `true`. If no defined routes matches the fragment,
    // returns `false`.
    loadUrl: function(fragment) {
      fragment = this.fragment = this.getFragment(fragment);
      return _.any(this.handlers, function(handler) {
        if (handler.route.test(fragment)) {
          handler.callback(fragment);
          return true;
        }
      });
    },

    // Save a fragment into the hash history, or replace the URL state if the
    // 'replace' option is passed. You are responsible for properly URL-encoding
    // the fragment in advance.
    //
    // The options object can contain `trigger: true` if you wish to have the
    // route callback be fired (not usually desirable), or `replace: true`, if
    // you wish to modify the current URL without adding an entry to the history.
    navigate: function(fragment, options) {
      if (!History.started) return false;
      if (!options || options === true) options = {trigger: !!options};

      var url = this.root + (fragment = this.getFragment(fragment || ''));

      // Strip the fragment of the query and hash for matching.
      fragment = fragment.replace(pathStripper, '');

      if (this.fragment === fragment) return;
      this.fragment = fragment;

      // Don't include a trailing slash on the root.
      if (fragment === '' && url !== '/') url = url.slice(0, -1);

      // If pushState is available, we use it to set the fragment as a real URL.
      if (this._hasPushState) {
        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

      // If hash changes haven't been explicitly disabled, update the hash
      // fragment to store history.
      } else if (this._wantsHashChange) {
        this._updateHash(this.location, fragment, options.replace);
        if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {
          // Opening and closing the iframe tricks IE7 and earlier to push a
          // history entry on hash-tag change.  When replace is true, we don't
          // want this.
          if(!options.replace) this.iframe.document.open().close();
          this._updateHash(this.iframe.location, fragment, options.replace);
        }

      // If you've told us that you explicitly don't want fallback hashchange-
      // based history, then `navigate` becomes a page refresh.
      } else {
        return this.location.assign(url);
      }
      if (options.trigger) return this.loadUrl(fragment);
    },

    // Update the hash location, either replacing the current entry, or adding
    // a new one to the browser history.
    _updateHash: function(location, fragment, replace) {
      if (replace) {
        var href = location.href.replace(/(javascript:|#).*$/, '');
        location.replace(href + '#' + fragment);
      } else {
        // Some browsers require that `hash` contains a leading #.
        location.hash = '#' + fragment;
      }
    }

  });

  // Create the default Backbone.history.
  Backbone.history = new History;

  // Helpers
  // -------

  // Helper function to correctly set up the prototype chain, for subclasses.
  // Similar to `goog.inherits`, but uses a hash of prototype properties and
  // class properties to be extended.
  var extend = function(protoProps, staticProps) {
    var parent = this;
    var child;

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent's constructor.
    if (protoProps && _.has(protoProps, 'constructor')) {
      child = protoProps.constructor;
    } else {
      child = function(){ return parent.apply(this, arguments); };
    }

    // Add static properties to the constructor function, if supplied.
    _.extend(child, parent, staticProps);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function.
    var Surrogate = function(){ this.constructor = child; };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate;

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) _.extend(child.prototype, protoProps);

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;
  };

  // Set up inheritance for the model, collection, router, view and history.
  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;

  // Throw an error when a URL is needed, and none is supplied.
  var urlError = function() {
    throw new Error('A "url" property or function must be specified');
  };

  // Wrap an optional error callback with a fallback error event.
  var wrapError = function(model, options) {
    var error = options.error;
    options.error = function(resp) {
      if (error) error(model, resp, options);
      model.trigger('error', model, resp, options);
    };
  };

}).call(this);

},{"underscore":49}],4:[function(require,module,exports){
var Buffer = require('buffer').Buffer;
var intSize = 4;
var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);
var chrsz = 8;

function toArray(buf, bigEndian) {
  if ((buf.length % intSize) !== 0) {
    var len = buf.length + (intSize - (buf.length % intSize));
    buf = Buffer.concat([buf, zeroBuffer], len);
  }

  var arr = [];
  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
  for (var i = 0; i < buf.length; i += intSize) {
    arr.push(fn.call(buf, i));
  }
  return arr;
}

function toBuffer(arr, size, bigEndian) {
  var buf = new Buffer(size);
  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
  for (var i = 0; i < arr.length; i++) {
    fn.call(buf, arr[i], i * 4, true);
  }
  return buf;
}

function hash(buf, fn, hashSize, bigEndian) {
  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
  return toBuffer(arr, hashSize, bigEndian);
}

module.exports = { hash: hash };

},{"buffer":11}],5:[function(require,module,exports){
var Buffer = require('buffer').Buffer
var sha = require('./sha')
var sha256 = require('./sha256')
var rng = require('./rng')
var md5 = require('./md5')

var algorithms = {
  sha1: sha,
  sha256: sha256,
  md5: md5
}

var blocksize = 64
var zeroBuffer = new Buffer(blocksize); zeroBuffer.fill(0)
function hmac(fn, key, data) {
  if(!Buffer.isBuffer(key)) key = new Buffer(key)
  if(!Buffer.isBuffer(data)) data = new Buffer(data)

  if(key.length > blocksize) {
    key = fn(key)
  } else if(key.length < blocksize) {
    key = Buffer.concat([key, zeroBuffer], blocksize)
  }

  var ipad = new Buffer(blocksize), opad = new Buffer(blocksize)
  for(var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  var hash = fn(Buffer.concat([ipad, data]))
  return fn(Buffer.concat([opad, hash]))
}

function hash(alg, key) {
  alg = alg || 'sha1'
  var fn = algorithms[alg]
  var bufs = []
  var length = 0
  if(!fn) error('algorithm:', alg, 'is not yet supported')
  return {
    update: function (data) {
      if(!Buffer.isBuffer(data)) data = new Buffer(data)
        
      bufs.push(data)
      length += data.length
      return this
    },
    digest: function (enc) {
      var buf = Buffer.concat(bufs)
      var r = key ? hmac(fn, key, buf) : fn(buf)
      bufs = null
      return enc ? r.toString(enc) : r
    }
  }
}

function error () {
  var m = [].slice.call(arguments).join(' ')
  throw new Error([
    m,
    'we accept pull requests',
    'http://github.com/dominictarr/crypto-browserify'
    ].join('\n'))
}

exports.createHash = function (alg) { return hash(alg) }
exports.createHmac = function (alg, key) { return hash(alg, key) }
exports.randomBytes = function(size, callback) {
  if (callback && callback.call) {
    try {
      callback.call(this, undefined, new Buffer(rng(size)))
    } catch (err) { callback(err) }
  } else {
    return new Buffer(rng(size))
  }
}

function each(a, f) {
  for(var i in a)
    f(a[i], i)
}

// the least I can do is make error messages for the rest of the node.js/crypto api.
each(['createCredentials'
, 'createCipher'
, 'createCipheriv'
, 'createDecipher'
, 'createDecipheriv'
, 'createSign'
, 'createVerify'
, 'createDiffieHellman'
, 'pbkdf2'], function (name) {
  exports[name] = function () {
    error('sorry,', name, 'is not implemented yet')
  }
})

},{"./md5":6,"./rng":7,"./sha":8,"./sha256":9,"buffer":11}],6:[function(require,module,exports){
/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

var helpers = require('./helpers');

/*
 * Perform a simple self-test to see if the VM is working
 */
function md5_vm_test()
{
  return hex_md5("abc") == "900150983cd24fb0d6963f7d28e17f72";
}

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length
 */
function core_md5(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);

}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

module.exports = function md5(buf) {
  return helpers.hash(buf, core_md5, 16);
};

},{"./helpers":4}],7:[function(require,module,exports){
// Original code adapted from Robert Kieffer.
// details at https://github.com/broofa/node-uuid
(function() {
  var _global = this;

  var mathRNG, whatwgRNG;

  // NOTE: Math.random() does not guarantee "cryptographic quality"
  mathRNG = function(size) {
    var bytes = new Array(size);
    var r;

    for (var i = 0, r; i < size; i++) {
      if ((i & 0x03) == 0) r = Math.random() * 0x100000000;
      bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return bytes;
  }

  if (_global.crypto && crypto.getRandomValues) {
    whatwgRNG = function(size) {
      var bytes = new Uint8Array(size);
      crypto.getRandomValues(bytes);
      return bytes;
    }
  }

  module.exports = whatwgRNG || mathRNG;

}())

},{}],8:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var helpers = require('./helpers');

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << (24 - len % 32);
  x[((len + 64 >> 9) << 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j < 80; j++)
    {
      if(j < 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t < 20) return (b & c) | ((~b) & d);
  if(t < 40) return b ^ c ^ d;
  if(t < 60) return (b & c) | (b & d) | (c & d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
         (t < 60) ? -1894007588 : -899497514;
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

module.exports = function sha1(buf) {
  return helpers.hash(buf, core_sha1, 20, true);
};

},{"./helpers":4}],9:[function(require,module,exports){

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var helpers = require('./helpers');

var safe_add = function(x, y) {
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
};

var S = function(X, n) {
  return (X >>> n) | (X << (32 - n));
};

var R = function(X, n) {
  return (X >>> n);
};

var Ch = function(x, y, z) {
  return ((x & y) ^ ((~x) & z));
};

var Maj = function(x, y, z) {
  return ((x & y) ^ (x & z) ^ (y & z));
};

var Sigma0256 = function(x) {
  return (S(x, 2) ^ S(x, 13) ^ S(x, 22));
};

var Sigma1256 = function(x) {
  return (S(x, 6) ^ S(x, 11) ^ S(x, 25));
};

var Gamma0256 = function(x) {
  return (S(x, 7) ^ S(x, 18) ^ R(x, 3));
};

var Gamma1256 = function(x) {
  return (S(x, 17) ^ S(x, 19) ^ R(x, 10));
};

var core_sha256 = function(m, l) {
  var K = new Array(0x428A2F98,0x71374491,0xB5C0FBCF,0xE9B5DBA5,0x3956C25B,0x59F111F1,0x923F82A4,0xAB1C5ED5,0xD807AA98,0x12835B01,0x243185BE,0x550C7DC3,0x72BE5D74,0x80DEB1FE,0x9BDC06A7,0xC19BF174,0xE49B69C1,0xEFBE4786,0xFC19DC6,0x240CA1CC,0x2DE92C6F,0x4A7484AA,0x5CB0A9DC,0x76F988DA,0x983E5152,0xA831C66D,0xB00327C8,0xBF597FC7,0xC6E00BF3,0xD5A79147,0x6CA6351,0x14292967,0x27B70A85,0x2E1B2138,0x4D2C6DFC,0x53380D13,0x650A7354,0x766A0ABB,0x81C2C92E,0x92722C85,0xA2BFE8A1,0xA81A664B,0xC24B8B70,0xC76C51A3,0xD192E819,0xD6990624,0xF40E3585,0x106AA070,0x19A4C116,0x1E376C08,0x2748774C,0x34B0BCB5,0x391C0CB3,0x4ED8AA4A,0x5B9CCA4F,0x682E6FF3,0x748F82EE,0x78A5636F,0x84C87814,0x8CC70208,0x90BEFFFA,0xA4506CEB,0xBEF9A3F7,0xC67178F2);
  var HASH = new Array(0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19);
    var W = new Array(64);
    var a, b, c, d, e, f, g, h, i, j;
    var T1, T2;
  /* append padding */
  m[l >> 5] |= 0x80 << (24 - l % 32);
  m[((l + 64 >> 9) << 4) + 15] = l;
  for (var i = 0; i < m.length; i += 16) {
    a = HASH[0]; b = HASH[1]; c = HASH[2]; d = HASH[3]; e = HASH[4]; f = HASH[5]; g = HASH[6]; h = HASH[7];
    for (var j = 0; j < 64; j++) {
      if (j < 16) {
        W[j] = m[j + i];
      } else {
        W[j] = safe_add(safe_add(safe_add(Gamma1256(W[j - 2]), W[j - 7]), Gamma0256(W[j - 15])), W[j - 16]);
      }
      T1 = safe_add(safe_add(safe_add(safe_add(h, Sigma1256(e)), Ch(e, f, g)), K[j]), W[j]);
      T2 = safe_add(Sigma0256(a), Maj(a, b, c));
      h = g; g = f; f = e; e = safe_add(d, T1); d = c; c = b; b = a; a = safe_add(T1, T2);
    }
    HASH[0] = safe_add(a, HASH[0]); HASH[1] = safe_add(b, HASH[1]); HASH[2] = safe_add(c, HASH[2]); HASH[3] = safe_add(d, HASH[3]);
    HASH[4] = safe_add(e, HASH[4]); HASH[5] = safe_add(f, HASH[5]); HASH[6] = safe_add(g, HASH[6]); HASH[7] = safe_add(h, HASH[7]);
  }
  return HASH;
};

module.exports = function sha256(buf) {
  return helpers.hash(buf, core_sha256, 32, true);
};

},{"./helpers":4}],10:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],11:[function(require,module,exports){
var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192

/**
 * If `Buffer._useTypedArrays`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (compatible down to IE6)
 */
Buffer._useTypedArrays = (function () {
   // Detect if browser supports Typed Arrays. Supported browsers are IE 10+,
   // Firefox 4+, Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+.
   if (typeof Uint8Array === 'undefined' || typeof ArrayBuffer === 'undefined')
      return false

  // Does the browser support adding properties to `Uint8Array` instances? If
  // not, then that's the same as no `Uint8Array` support. We need to be able to
  // add all the node Buffer API methods.
  // Relevant Firefox bug: https://bugzilla.mozilla.org/show_bug.cgi?id=695438
  try {
    var arr = new Uint8Array(0)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() &&
        typeof arr.subarray === 'function' // Chrome 9-10 lack `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Workaround: node's base64 implementation allows for non-padded strings
  // while base64-js does not.
  if (encoding === 'base64' && type === 'string') {
    subject = stringtrim(subject)
    while (subject.length % 4 !== 0) {
      subject = subject + '='
    }
  }

  // Find the length
  var length
  if (type === 'number')
    length = coerce(subject)
  else if (type === 'string')
    length = Buffer.byteLength(subject, encoding)
  else if (type === 'object')
    length = coerce(subject.length) // Assume object is an array
  else
    throw new Error('First argument needs to be a number, array or string.')

  var buf
  if (Buffer._useTypedArrays) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer._useTypedArrays && typeof Uint8Array === 'function' &&
      subject instanceof Uint8Array) {
    // Speed optimization -- use set if we're copying from a Uint8Array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    for (i = 0; i < length; i++) {
      if (Buffer.isBuffer(subject))
        buf[i] = subject.readUInt8(i)
      else
        buf[i] = subject[i]
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

// STATIC METHODS
// ==============

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.isBuffer = function (b) {
  return !!(b !== null && b !== undefined && b._isBuffer)
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'hex':
      ret = str.length / 2
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.concat = function (list, totalLength) {
  assert(isArray(list), 'Usage: Buffer.concat(list, [totalLength])\n' +
      'list should be an Array.')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (typeof totalLength !== 'number') {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

// BUFFER INSTANCE METHODS
// =======================

function _hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  assert(strLen % 2 === 0, 'Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    assert(!isNaN(byte), 'Invalid hex string')
    buf[offset + i] = byte
  }
  Buffer._charsWritten = i * 2
  return i
}

function _utf8Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function _asciiWrite (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function _binaryWrite (buf, string, offset, length) {
  return _asciiWrite(buf, string, offset, length)
}

function _base64Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  switch (encoding) {
    case 'hex':
      return _hexWrite(this, string, offset, length)
    case 'utf8':
    case 'utf-8':
    case 'ucs2': // TODO: No support for ucs2 or utf16le encodings yet
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return _utf8Write(this, string, offset, length)
    case 'ascii':
      return _asciiWrite(this, string, offset, length)
    case 'binary':
      return _binaryWrite(this, string, offset, length)
    case 'base64':
      return _base64Write(this, string, offset, length)
    default:
      throw new Error('Unknown encoding')
  }
}

Buffer.prototype.toString = function (encoding, start, end) {
  var self = this

  encoding = String(encoding || 'utf8').toLowerCase()
  start = Number(start) || 0
  end = (end !== undefined)
    ? Number(end)
    : end = self.length

  // Fastpath empty strings
  if (end === start)
    return ''

  switch (encoding) {
    case 'hex':
      return _hexSlice(self, start, end)
    case 'utf8':
    case 'utf-8':
    case 'ucs2': // TODO: No support for ucs2 or utf16le encodings yet
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return _utf8Slice(self, start, end)
    case 'ascii':
      return _asciiSlice(self, start, end)
    case 'binary':
      return _binarySlice(self, start, end)
    case 'base64':
      return _base64Slice(self, start, end)
    default:
      throw new Error('Unknown encoding')
  }
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  assert(end >= start, 'sourceEnd < sourceStart')
  assert(target_start >= 0 && target_start < target.length,
      'targetStart out of bounds')
  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')
  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  // copy!
  for (var i = 0; i < end - start; i++)
    target[i + target_start] = this[i + start]
}

function _base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function _utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function _asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++)
    ret += String.fromCharCode(buf[i])
  return ret
}

function _binarySlice (buf, start, end) {
  return _asciiSlice(buf, start, end)
}

function _hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

// http://nodejs.org/api/buffer.html#buffer_buf_slice_start_end
Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = clamp(start, len, 0)
  end = clamp(end, len, len)

  if (Buffer._useTypedArrays) {
    return augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  return this[offset]
}

function _readUInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    val = buf[offset]
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
  } else {
    val = buf[offset] << 8
    if (offset + 1 < len)
      val |= buf[offset + 1]
  }
  return val
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  return _readUInt16(this, offset, true, noAssert)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  return _readUInt16(this, offset, false, noAssert)
}

function _readUInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    if (offset + 2 < len)
      val = buf[offset + 2] << 16
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
    val |= buf[offset]
    if (offset + 3 < len)
      val = val + (buf[offset + 3] << 24 >>> 0)
  } else {
    if (offset + 1 < len)
      val = buf[offset + 1] << 16
    if (offset + 2 < len)
      val |= buf[offset + 2] << 8
    if (offset + 3 < len)
      val |= buf[offset + 3]
    val = val + (buf[offset] << 24 >>> 0)
  }
  return val
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  return _readUInt32(this, offset, true, noAssert)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  return _readUInt32(this, offset, false, noAssert)
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null,
        'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  var neg = this[offset] & 0x80
  if (neg)
    return (0xff - this[offset] + 1) * -1
  else
    return this[offset]
}

function _readInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt16(buf, offset, littleEndian, true)
  var neg = val & 0x8000
  if (neg)
    return (0xffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  return _readInt16(this, offset, true, noAssert)
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  return _readInt16(this, offset, false, noAssert)
}

function _readInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt32(buf, offset, littleEndian, true)
  var neg = val & 0x80000000
  if (neg)
    return (0xffffffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  return _readInt32(this, offset, true, noAssert)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  return _readInt32(this, offset, false, noAssert)
}

function _readFloat (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 23, 4)
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  return _readFloat(this, offset, true, noAssert)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  return _readFloat(this, offset, false, noAssert)
}

function _readDouble (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 52, 8)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  return _readDouble(this, offset, true, noAssert)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  return _readDouble(this, offset, false, noAssert)
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'trying to write beyond buffer length')
    verifuint(value, 0xff)
  }

  if (offset >= this.length) return

  this[offset] = value
}

function _writeUInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {
    buf[offset + i] =
        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
            (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, false, noAssert)
}

function _writeUInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffffffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {
    buf[offset + i] =
        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, false, noAssert)
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7f, -0x80)
  }

  if (offset >= this.length)
    return

  if (value >= 0)
    this.writeUInt8(value, offset, noAssert)
  else
    this.writeUInt8(0xff + value + 1, offset, noAssert)
}

function _writeInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fff, -0x8000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt16(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, false, noAssert)
}

function _writeInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fffffff, -0x80000000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt32(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, false, noAssert)
}

function _writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 23, 4)
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, false, noAssert)
}

function _writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 7 < buf.length,
        'Trying to write beyond buffer length')
    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 52, 8)
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, false, noAssert)
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (typeof value === 'string') {
    value = value.charCodeAt(0)
  }

  assert(typeof value === 'number' && !isNaN(value), 'value is not a number')
  assert(end >= start, 'end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  assert(start >= 0 && start < this.length, 'start out of bounds')
  assert(end >= 0 && end <= this.length, 'end out of bounds')

  for (var i = start; i < end; i++) {
    this[i] = value
  }
}

Buffer.prototype.inspect = function () {
  var out = []
  var len = this.length
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i])
    if (i === exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...'
      break
    }
  }
  return '<Buffer ' + out.join(' ') + '>'
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array === 'function') {
    if (Buffer._useTypedArrays) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1)
        buf[i] = this[i]
      return buf.buffer
    }
  } else {
    throw new Error('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

var BP = Buffer.prototype

/**
 * Augment the Uint8Array *instance* (not the class!) with Buffer methods
 */
function augment (arr) {
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

// slice(start, end)
function clamp (index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len
  if (index >= 0) return index
  index += len
  if (index >= 0) return index
  return 0
}

function coerce (length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length)
  return length < 0 ? 0 : length
}

function isArray (subject) {
  return (Array.isArray || function (subject) {
    return Object.prototype.toString.call(subject) === '[object Array]'
  })(subject)
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F)
      byteArray.push(str.charCodeAt(i))
    else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16))
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  var pos
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

/*
 * We have to make sure that the value is a valid integer. This means that it
 * is non-negative. It has no fractional component and that it does not
 * exceed the maximum allowed value.
 */
function verifuint (value, max) {
  assert(typeof value == 'number', 'cannot write a non-number as a number')
  assert(value >= 0,
      'specified a negative value for writing an unsigned value')
  assert(value <= max, 'value is larger than maximum value for type')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifsint(value, max, min) {
  assert(typeof value == 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifIEEE754(value, max, min) {
  assert(typeof value == 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
}

function assert (test, message) {
  if (!test) throw new Error(message || 'Failed assertion')
}

},{"base64-js":12,"ieee754":13}],12:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var ZERO   = '0'.charCodeAt(0)
	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	module.exports.toByteArray = b64ToByteArray
	module.exports.fromByteArray = uint8ToBase64
}())

},{}],13:[function(require,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],14:[function(require,module,exports){
(function (global){
/*! http://mths.be/punycode v1.2.4 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports;
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^ -~]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /\x2E|\u3002|\uFF0E|\uFF61/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		while (length--) {
			array[length] = fn(array[length]);
		}
		return array;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings.
	 * @private
	 * @param {String} domain The domain name.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		return map(string.split(regexSeparators), fn).join('.');
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <http://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols to a Punycode string of ASCII-only
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name to Unicode. Only the
	 * Punycoded parts of the domain name will be converted, i.e. it doesn't
	 * matter if you call it on a string that has already been converted to
	 * Unicode.
	 * @memberOf punycode
	 * @param {String} domain The Punycode domain name to convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(domain) {
		return mapDomain(domain, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name to Punycode. Only the
	 * non-ASCII parts of the domain name will be converted, i.e. it doesn't
	 * matter if you call it with a domain that's already in ASCII.
	 * @memberOf punycode
	 * @param {String} domain The domain name to convert, as a Unicode string.
	 * @returns {String} The Punycode representation of the given domain name.
	 */
	function toASCII(domain) {
		return mapDomain(domain, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.2.4',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <http://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],15:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],16:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return obj[k].map(function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],17:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":15,"./encode":16}],18:[function(require,module,exports){
/*jshint strict:true node:true es5:true onevar:true laxcomma:true laxbreak:true eqeqeq:true immed:true latedef:true*/
(function () {
  "use strict";

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var punycode = require('punycode');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '~', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(delims),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#']
      .concat(unwise).concat(autoEscape),
    nonAuthChars = ['/', '@', '?', '#'].concat(delims),
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-zA-Z0-9][a-z0-9A-Z_-]{0,62}$/,
    hostnamePartStart = /^([a-zA-Z0-9][a-z0-9A-Z_-]{0,62})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always have a path component.
    pathedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && typeof(url) === 'object' && url.href) return url;

  if (typeof url !== 'string') {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var out = {},
      rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    out.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      out.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {
    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    // don't enforce full RFC correctness, just be unstupid about it.

    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the first @ sign, unless some non-auth character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    var atSign = rest.indexOf('@');
    if (atSign !== -1) {
      var auth = rest.slice(0, atSign);

      // there *may be* an auth
      var hasAuth = true;
      for (var i = 0, l = nonAuthChars.length; i < l; i++) {
        if (auth.indexOf(nonAuthChars[i]) !== -1) {
          // not a valid auth.  Something like http://foo.com/bar@baz/
          hasAuth = false;
          break;
        }
      }

      if (hasAuth) {
        // pluck off the auth portion.
        out.auth = decodeURIComponent(auth);
        rest = rest.substr(atSign + 1);
      }
    }

    var firstNonHost = -1;
    for (var i = 0, l = nonHostChars.length; i < l; i++) {
      var index = rest.indexOf(nonHostChars[i]);
      if (index !== -1 &&
          (firstNonHost < 0 || index < firstNonHost)) firstNonHost = index;
    }

    if (firstNonHost !== -1) {
      out.host = rest.substr(0, firstNonHost);
      rest = rest.substr(firstNonHost);
    } else {
      out.host = rest;
      rest = '';
    }

    // pull out port.
    var p = parseHost(out.host);
    var keys = Object.keys(p);
    for (var i = 0, l = keys.length; i < l; i++) {
      var key = keys[i];
      out[key] = p[key];
    }

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    out.hostname = out.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = out.hostname[0] === '[' &&
        out.hostname[out.hostname.length - 1] === ']';

    // validate a little.
    if (out.hostname.length > hostnameMaxLen) {
      out.hostname = '';
    } else if (!ipv6Hostname) {
      var hostparts = out.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            out.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    // hostnames are always lower case.
    out.hostname = out.hostname.toLowerCase();

    if (!ipv6Hostname) {
      // IDNA Support: Returns a puny coded representation of "domain".
      // It only converts the part of the domain name that
      // has non ASCII characters. I.e. it dosent matter if
      // you call it with a domain that already is in ASCII.
      var domainArray = out.hostname.split('.');
      var newOut = [];
      for (var i = 0; i < domainArray.length; ++i) {
        var s = domainArray[i];
        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
            'xn--' + punycode.encode(s) : s);
      }
      out.hostname = newOut.join('.');
    }

    out.host = (out.hostname || '') +
        ((out.port) ? ':' + out.port : '');
    out.href += out.host;

    // strip [ and ] from the hostname
    if (ipv6Hostname) {
      out.hostname = out.hostname.substr(1, out.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    out.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    out.search = rest.substr(qm);
    out.query = rest.substr(qm + 1);
    if (parseQueryString) {
      out.query = querystring.parse(out.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    out.search = '';
    out.query = {};
  }
  if (rest) out.pathname = rest;
  if (slashedProtocol[proto] &&
      out.hostname && !out.pathname) {
    out.pathname = '/';
  }

  //to support http.request
  if (out.pathname || out.search) {
    out.path = (out.pathname ? out.pathname : '') +
               (out.search ? out.search : '');
  }

  // finally, reconstruct the href based on what has been validated.
  out.href = urlFormat(out);
  return out;
}

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (typeof(obj) === 'string') obj = urlParse(obj);

  var auth = obj.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = obj.protocol || '',
      pathname = obj.pathname || '',
      hash = obj.hash || '',
      host = false,
      query = '';

  if (obj.host !== undefined) {
    host = auth + obj.host;
  } else if (obj.hostname !== undefined) {
    host = auth + (obj.hostname.indexOf(':') === -1 ?
        obj.hostname :
        '[' + obj.hostname + ']');
    if (obj.port) {
      host += ':' + obj.port;
    }
  }

  if (obj.query && typeof obj.query === 'object' &&
      Object.keys(obj.query).length) {
    query = querystring.stringify(obj.query);
  }

  var search = obj.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (obj.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  return protocol + host + pathname + search + hash;
}

function urlResolve(source, relative) {
  return urlFormat(urlResolveObject(source, relative));
}

function urlResolveObject(source, relative) {
  if (!source) return relative;

  source = urlParse(urlFormat(source), false, true);
  relative = urlParse(urlFormat(relative), false, true);

  // hash is always overridden, no matter what.
  source.hash = relative.hash;

  if (relative.href === '') {
    source.href = urlFormat(source);
    return source;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    relative.protocol = source.protocol;
    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[relative.protocol] &&
        relative.hostname && !relative.pathname) {
      relative.path = relative.pathname = '/';
    }
    relative.href = urlFormat(relative);
    return relative;
  }

  if (relative.protocol && relative.protocol !== source.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      relative.href = urlFormat(relative);
      return relative;
    }
    source.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      relative.pathname = relPath.join('/');
    }
    source.pathname = relative.pathname;
    source.search = relative.search;
    source.query = relative.query;
    source.host = relative.host || '';
    source.auth = relative.auth;
    source.hostname = relative.hostname || relative.host;
    source.port = relative.port;
    //to support http.request
    if (source.pathname !== undefined || source.search !== undefined) {
      source.path = (source.pathname ? source.pathname : '') +
                    (source.search ? source.search : '');
    }
    source.slashes = source.slashes || relative.slashes;
    source.href = urlFormat(source);
    return source;
  }

  var isSourceAbs = (source.pathname && source.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host !== undefined ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (source.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = source.pathname && source.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = source.protocol &&
          !slashedProtocol[source.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // source.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {

    delete source.hostname;
    delete source.port;
    if (source.host) {
      if (srcPath[0] === '') srcPath[0] = source.host;
      else srcPath.unshift(source.host);
    }
    delete source.host;
    if (relative.protocol) {
      delete relative.hostname;
      delete relative.port;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      delete relative.host;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    source.host = (relative.host || relative.host === '') ?
                      relative.host : source.host;
    source.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : source.hostname;
    source.search = relative.search;
    source.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    source.search = relative.search;
    source.query = relative.query;
  } else if ('search' in relative) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      source.hostname = source.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = source.host && source.host.indexOf('@') > 0 ?
                       source.host.split('@') : false;
      if (authInHost) {
        source.auth = authInHost.shift();
        source.host = source.hostname = authInHost.shift();
      }
    }
    source.search = relative.search;
    source.query = relative.query;
    //to support http.request
    if (source.pathname !== undefined || source.search !== undefined) {
      source.path = (source.pathname ? source.pathname : '') +
                    (source.search ? source.search : '');
    }
    source.href = urlFormat(source);
    return source;
  }
  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    delete source.pathname;
    //to support http.request
    if (!source.search) {
      source.path = '/' + source.search;
    } else {
      delete source.path;
    }
    source.href = urlFormat(source);
    return source;
  }
  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (source.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    source.hostname = source.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = source.host && source.host.indexOf('@') > 0 ?
                     source.host.split('@') : false;
    if (authInHost) {
      source.auth = authInHost.shift();
      source.host = source.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (source.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  source.pathname = srcPath.join('/');
  //to support request.http
  if (source.pathname !== undefined || source.search !== undefined) {
    source.path = (source.pathname ? source.pathname : '') +
                  (source.search ? source.search : '');
  }
  source.auth = relative.auth || source.auth;
  source.slashes = source.slashes || relative.slashes;
  source.href = urlFormat(source);
  return source;
}

function parseHost(host) {
  var out = {};
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      out.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) out.hostname = host;
  return out;
}

}());

},{"punycode":14,"querystring":17}],19:[function(require,module,exports){
/**
 * Wraps a function with a security check that ensures the argument being
 * passed in is a string.
 *
 * @param  {Function} fn
 * @return {Function}
 */
var acceptString = function (fn) {
  return function (string) {
    if (typeof string !== 'string') {
      throw new TypeError('Changing case will only works on strings');
    }

    return fn.apply(null, arguments);
  };
};

/**
 * Sanitizes a passed in string with certain options. It accepts a replacement
 * function that should accept a string word parameter. It also accepts an
 * optional separator override to replace the separator character.
 *
 * @param  {String}   string
 * @param  {Function} replacement
 * @param  {Function|String} [separator]
 * @return {Array}
 */
var sanitizeString = function (string, replacement, separator) {
  var index = -1;

  return string
    .replace(/([a-z0-9])([A-Z])/g, '$1 $2')
    .replace(/([^a-zA-Z0-9]*)([a-zA-Z0-9]*)/g, function (_, $0, $1) {
      var prefix = $0;

      index += 1;

      if (prefix) {
        if (typeof separator === 'string') {
          prefix = separator;
        } else if (typeof separator === 'function') {
          prefix = separator($0, index, string);
        }
      }

      return prefix + replacement($1, index, string);
    });
};

/**
 * Exports object.
 *
 * @type {Object}
 */
var e = exports;

/**
 * Expose a mutable array of insignificant words that will not be title cased.
 *
 * @type {Array}
 */
e.insignificantWords = ['and'];

/**
 * Returns a boolean describing whether the string is all UPPERCASE or not.
 *
 * @param  {String} string
 * @return {Boolean}
 */
e.isUpperCase = acceptString(function (string) {
  return string === e.upperCase(string);
});

/**
 * Returns a boolean describing whether the string is all lowercase or not.
 *
 * @param  {String} string
 * @return {Boolean}
 */
e.isLowerCase = acceptString(function (string) {
  return string === e.lowerCase(string);
});

/**
 * Lowercase a passed in string.
 *
 * @param  {String} string
 * @return {String}
 */
e.lowerCase = acceptString(function (string) {
  return string.toLowerCase();
});

/**
 * Uppercase a passed in string.
 *
 * @param  {String} string
 * @return {String}
 */
e.upperCase = acceptString(function (string) {
  return string.toUpperCase();
});

/**
 * Uppercase the first character of a string.
 *
 * @param  {String} string
 * @return {String}
 */
e.upperCaseFirst = acceptString(function (string) {
  return e.upperCase(string.charAt(0)) + string.substr(1);
});

/**
 * Lowercase the first character of a string.
 *
 * @param  {String} string
 * @return {String}
 */
e.lowerCaseFirst = acceptString(function (string) {
  return e.lowerCase(string.charAt(0)) + string.substr(1);
});

/**
 * Title case a passed in string. Pass an optional boolean flag to title case
 * all words. Default behaviour is to skip insignicant words.
 *
 * @param  {String}  string
 * @param  {Boolean} significant
 * @return {String}
 */
e.titleCase = e.title = acceptString(function (string, significant) {
  return string
    // Remove prefixed whitespace.
    .replace(/^\s/, '')
    // Remove suffixed whitespace.
    .replace(/\s$/, '')
    // Turn all whitespace into a single space character.
    .replace(/\s+/g, ' ')
    // Replace word strings. Matches "W.H.O", "tests'", "test's", "test", etc.
    .replace(
      /(?:(?:[a-zA-Z]\.)+[a-zA-Z]|[a-zA-Z\'\-]+[a-zA-Z]*)/g,
      function (word, index) {
        // Uppercase "W.H.O"
        if (/(?:[a-zA-Z]\.)+[a-zA-Z]/g.test(word)) {
          return e.upperCase(word);
        }

        if (!significant && index > 0) {
          if (word.length < 3 || ~e.insignificantWords.indexOf(word)) {
            return e.lowerCase(word);
          }
        }

        return e.upperCaseFirst(e.lowerCase(word));
      })
    // Fix broken sentence formatting.
    .replace(/(\.\,\!\?\;)([a-zA-Z0-9]+) /g, '$1 $2');
});

/**
 * Sentence case a passed in string. E.g. "TestString" => "test string".
 *
 * @param  {String} string
 * @return {String}
 */
e.sentenceCase = e.sentence = acceptString(function (string) {
  return sanitizeString(string, e.lowerCase, ' ');
});

/**
 * Pascal case a passed in string. E.g. "test string" => "TestString".
 *
 * @param  {String} string
 * @return {String}
 */
e.pascalCase = e.pascal = acceptString(function (string) {
  return sanitizeString(string, function (word) {
    return e.upperCaseFirst(e.lowerCase(word));
  }, '');
});

/**
 * Camel case a passed in string. E.g. "test string" => "testString".
 *
 * @param  {String} string
 * @return {String}
 */
e.camelCase = e.camel = acceptString(function (string) {
  return e.lowerCaseFirst(e.pascalCase(string));
});

/**
 * Snake case a passed in string. E.g. "test string" => "test_string".
 *
 * @param  {String} string
 * @return {String}
 */
e.snakeCase = e.snake = acceptString(function (string) {
  return sanitizeString(string, e.lowerCase, '_');
});

/**
 * Param case a passed in string. E.g. "test string" => "test-string".
 *
 * @param  {String} string
 * @return {String}
 */
e.paramCase = e.param = acceptString(function (string) {
  return sanitizeString(string, e.lowerCase, '-');
});

/**
 * Dot case a passed in string. E.g. "test string" => "test.string".
 *
 * @param  {String} string
 * @return {String}
 */
e.dotCase = e.dot = acceptString(function (string) {
  return sanitizeString(string, e.lowerCase, '.');
});

/**
 * Path case a passed in string. E.g. "test string" => "test/string".
 *
 * @param  {String} string
 * @return {String}
 */
e.pathCase = e.path = acceptString(function (string) {
  return sanitizeString(string, e.lowerCase, '/');
});

/**
 * Constant case a passed in string. E.g. "test string" => "TEST_STRING".
 *
 * @param  {String} string
 * @return {String}
 */
e.constantCase = e.constant = acceptString(function (string) {
  return sanitizeString(string, e.upperCase, '_');
});

/**
 * Reverse the case of a string. E.g. "Test String" => "tEST sTRING".
 *
 * @param  {String} string
 * @return {String}
 */
e.switchCase = e.switch = acceptString(function (string) {
  return string.replace(/[a-zA-Z]/g, function (c) {
    var u = e.upperCase(c);
    return c === u ? e.lowerCase(c) : u;
  });
});

},{}],20:[function(require,module,exports){
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";

  var noOptions = {};
  var nonWS = /[^\s\u00a0]/;
  var Pos = CodeMirror.Pos;

  function firstNonWS(str) {
    var found = str.search(nonWS);
    return found == -1 ? 0 : found;
  }

  CodeMirror.commands.toggleComment = function(cm) {
    var minLine = Infinity, ranges = cm.listSelections(), mode = null;
    for (var i = ranges.length - 1; i >= 0; i--) {
      var from = ranges[i].from(), to = ranges[i].to();
      if (from.line >= minLine) continue;
      if (to.line >= minLine) to = Pos(minLine, 0);
      minLine = from.line;
      if (mode == null) {
        if (cm.uncomment(from, to)) mode = "un";
        else { cm.lineComment(from, to); mode = "line"; }
      } else if (mode == "un") {
        cm.uncomment(from, to);
      } else {
        cm.lineComment(from, to);
      }
    }
  };

  CodeMirror.defineExtension("lineComment", function(from, to, options) {
    if (!options) options = noOptions;
    var self = this, mode = self.getModeAt(from);
    var commentString = options.lineComment || mode.lineComment;
    if (!commentString) {
      if (options.blockCommentStart || mode.blockCommentStart) {
        options.fullLines = true;
        self.blockComment(from, to, options);
      }
      return;
    }
    var firstLine = self.getLine(from.line);
    if (firstLine == null) return;
    var end = Math.min(to.ch != 0 || to.line == from.line ? to.line + 1 : to.line, self.lastLine() + 1);
    var pad = options.padding == null ? " " : options.padding;
    var blankLines = options.commentBlankLines || from.line == to.line;

    self.operation(function() {
      if (options.indent) {
        var baseString = firstLine.slice(0, firstNonWS(firstLine));
        for (var i = from.line; i < end; ++i) {
          var line = self.getLine(i), cut = baseString.length;
          if (!blankLines && !nonWS.test(line)) continue;
          if (line.slice(0, cut) != baseString) cut = firstNonWS(line);
          self.replaceRange(baseString + commentString + pad, Pos(i, 0), Pos(i, cut));
        }
      } else {
        for (var i = from.line; i < end; ++i) {
          if (blankLines || nonWS.test(self.getLine(i)))
            self.replaceRange(commentString + pad, Pos(i, 0));
        }
      }
    });
  });

  CodeMirror.defineExtension("blockComment", function(from, to, options) {
    if (!options) options = noOptions;
    var self = this, mode = self.getModeAt(from);
    var startString = options.blockCommentStart || mode.blockCommentStart;
    var endString = options.blockCommentEnd || mode.blockCommentEnd;
    if (!startString || !endString) {
      if ((options.lineComment || mode.lineComment) && options.fullLines != false)
        self.lineComment(from, to, options);
      return;
    }

    var end = Math.min(to.line, self.lastLine());
    if (end != from.line && to.ch == 0 && nonWS.test(self.getLine(end))) --end;

    var pad = options.padding == null ? " " : options.padding;
    if (from.line > end) return;

    self.operation(function() {
      if (options.fullLines != false) {
        var lastLineHasText = nonWS.test(self.getLine(end));
        self.replaceRange(pad + endString, Pos(end));
        self.replaceRange(startString + pad, Pos(from.line, 0));
        var lead = options.blockCommentLead || mode.blockCommentLead;
        if (lead != null) for (var i = from.line + 1; i <= end; ++i)
          if (i != end || lastLineHasText)
            self.replaceRange(lead + pad, Pos(i, 0));
      } else {
        self.replaceRange(endString, to);
        self.replaceRange(startString, from);
      }
    });
  });

  CodeMirror.defineExtension("uncomment", function(from, to, options) {
    if (!options) options = noOptions;
    var self = this, mode = self.getModeAt(from);
    var end = Math.min(to.line, self.lastLine()), start = Math.min(from.line, end);

    // Try finding line comments
    var lineString = options.lineComment || mode.lineComment, lines = [];
    var pad = options.padding == null ? " " : options.padding, didSomething;
    lineComment: {
      if (!lineString) break lineComment;
      for (var i = start; i <= end; ++i) {
        var line = self.getLine(i);
        var found = line.indexOf(lineString);
        if (found > -1 && !/comment/.test(self.getTokenTypeAt(Pos(i, found + 1)))) found = -1;
        if (found == -1 && (i != end || i == start) && nonWS.test(line)) break lineComment;
        if (found > -1 && nonWS.test(line.slice(0, found))) break lineComment;
        lines.push(line);
      }
      self.operation(function() {
        for (var i = start; i <= end; ++i) {
          var line = lines[i - start];
          var pos = line.indexOf(lineString), endPos = pos + lineString.length;
          if (pos < 0) continue;
          if (line.slice(endPos, endPos + pad.length) == pad) endPos += pad.length;
          didSomething = true;
          self.replaceRange("", Pos(i, pos), Pos(i, endPos));
        }
      });
      if (didSomething) return true;
    }

    // Try block comments
    var startString = options.blockCommentStart || mode.blockCommentStart;
    var endString = options.blockCommentEnd || mode.blockCommentEnd;
    if (!startString || !endString) return false;
    var lead = options.blockCommentLead || mode.blockCommentLead;
    var startLine = self.getLine(start), endLine = end == start ? startLine : self.getLine(end);
    var open = startLine.indexOf(startString), close = endLine.lastIndexOf(endString);
    if (close == -1 && start != end) {
      endLine = self.getLine(--end);
      close = endLine.lastIndexOf(endString);
    }
    if (open == -1 || close == -1 ||
        !/comment/.test(self.getTokenTypeAt(Pos(start, open + 1))) ||
        !/comment/.test(self.getTokenTypeAt(Pos(end, close + 1))))
      return false;

    self.operation(function() {
      self.replaceRange("", Pos(end, close - (pad && endLine.slice(close - pad.length, close) == pad ? pad.length : 0)),
                        Pos(end, close + endString.length));
      var openEnd = open + startString.length;
      if (pad && startLine.slice(openEnd, openEnd + pad.length) == pad) openEnd += pad.length;
      self.replaceRange("", Pos(start, open), Pos(start, openEnd));
      if (lead) for (var i = start + 1; i <= end; ++i) {
        var line = self.getLine(i), found = line.indexOf(lead);
        if (found == -1 || nonWS.test(line.slice(0, found))) continue;
        var foundEnd = found + lead.length;
        if (pad && line.slice(foundEnd, foundEnd + pad.length) == pad) foundEnd += pad.length;
        self.replaceRange("", Pos(i, found), Pos(i, foundEnd));
      }
    });
    return true;
  });
});

},{"../../lib/codemirror":22}],21:[function(require,module,exports){
// Utility function that allows modes to be combined. The mode given
// as the base argument takes care of most of the normal mode
// functionality, but a second (typically simple) mode is used, which
// can override the style of text. Both modes get to parse all of the
// text, but when both assign a non-null style to a piece of code, the
// overlay wins, unless the combine argument was true, in which case
// the styles are combined.

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.overlayMode = function(base, overlay, combine) {
  return {
    startState: function() {
      return {
        base: CodeMirror.startState(base),
        overlay: CodeMirror.startState(overlay),
        basePos: 0, baseCur: null,
        overlayPos: 0, overlayCur: null,
        lineSeen: null
      };
    },
    copyState: function(state) {
      return {
        base: CodeMirror.copyState(base, state.base),
        overlay: CodeMirror.copyState(overlay, state.overlay),
        basePos: state.basePos, baseCur: null,
        overlayPos: state.overlayPos, overlayCur: null
      };
    },

    token: function(stream, state) {
      if (stream.sol() || stream.string != state.lineSeen ||
          Math.min(state.basePos, state.overlayPos) < stream.start) {
        state.lineSeen = stream.string;
        state.basePos = state.overlayPos = stream.start;
      }

      if (stream.start == state.basePos) {
        state.baseCur = base.token(stream, state.base);
        state.basePos = stream.pos;
      }
      if (stream.start == state.overlayPos) {
        stream.pos = stream.start;
        state.overlayCur = overlay.token(stream, state.overlay);
        state.overlayPos = stream.pos;
      }
      stream.pos = Math.min(state.basePos, state.overlayPos);

      if (state.overlayCur == null) return state.baseCur;
      if (state.baseCur != null && combine) return state.baseCur + " " + state.overlayCur;
      else return state.overlayCur;
    },

    indent: base.indent && function(state, textAfter) {
      return base.indent(state.base, textAfter);
    },
    electricChars: base.electricChars,

    innerMode: function(state) { return {state: state.base, mode: base}; },

    blankLine: function(state) {
      if (base.blankLine) base.blankLine(state.base);
      if (overlay.blankLine) overlay.blankLine(state.overlay);
    }
  };
};

});

},{"../../lib/codemirror":22}],22:[function(require,module,exports){
// This is CodeMirror (http://codemirror.net), a code editor
// implemented in JavaScript on top of the browser's DOM.
//
// You can find some technical background for some of the code below
// at http://marijnhaverbeke.nl/blog/#cm-internals .

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    module.exports = mod();
  else if (typeof define == "function" && define.amd) // AMD
    return define([], mod);
  else // Plain browser env
    this.CodeMirror = mod();
})(function() {
  "use strict";

  // BROWSER SNIFFING

  // Kludges for bugs and behavior differences that can't be feature
  // detected are enabled based on userAgent etc sniffing.

  var gecko = /gecko\/\d/i.test(navigator.userAgent);
  // ie_uptoN means Internet Explorer version N or lower
  var ie_upto10 = /MSIE \d/.test(navigator.userAgent);
  var ie_upto7 = ie_upto10 && (document.documentMode == null || document.documentMode < 8);
  var ie_upto8 = ie_upto10 && (document.documentMode == null || document.documentMode < 9);
  var ie_upto9 = ie_upto10 && (document.documentMode == null || document.documentMode < 10);
  var ie_11up = /Trident\/([7-9]|\d{2,})\./.test(navigator.userAgent);
  var ie = ie_upto10 || ie_11up;
  var webkit = /WebKit\//.test(navigator.userAgent);
  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(navigator.userAgent);
  var chrome = /Chrome\//.test(navigator.userAgent);
  var presto = /Opera\//.test(navigator.userAgent);
  var safari = /Apple Computer/.test(navigator.vendor);
  var khtml = /KHTML\//.test(navigator.userAgent);
  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(navigator.userAgent);
  var phantom = /PhantomJS/.test(navigator.userAgent);

  var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent);
  // This is woefully incomplete. Suggestions for alternative methods welcome.
  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent);
  var mac = ios || /Mac/.test(navigator.platform);
  var windows = /win/i.test(navigator.platform);

  var presto_version = presto && navigator.userAgent.match(/Version\/(\d*\.\d*)/);
  if (presto_version) presto_version = Number(presto_version[1]);
  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }
  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
  var captureRightClick = gecko || (ie && !ie_upto8);

  // Optimize some code when these features are not used.
  var sawReadOnlySpans = false, sawCollapsedSpans = false;

  // EDITOR CONSTRUCTOR

  // A CodeMirror instance represents an editor. This is the object
  // that user code is usually dealing with.

  function CodeMirror(place, options) {
    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);

    this.options = options = options || {};
    // Determine effective options based on given values and defaults.
    copyObj(defaults, options, false);
    setGuttersForLineNumbers(options);

    var doc = options.value;
    if (typeof doc == "string") doc = new Doc(doc, options.mode);
    this.doc = doc;

    var display = this.display = new Display(place, doc);
    display.wrapper.CodeMirror = this;
    updateGutters(this);
    themeChanged(this);
    if (options.lineWrapping)
      this.display.wrapper.className += " CodeMirror-wrap";
    if (options.autofocus && !mobile) focusInput(this);

    this.state = {
      keyMaps: [],  // stores maps added by addKeyMap
      overlays: [], // highlighting overlays, as added by addOverlay
      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
      overwrite: false, focused: false,
      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
      pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in readInput
      draggingText: false,
      highlight: new Delayed() // stores highlight worker timeout
    };

    // Override magic textarea content restore that IE sometimes does
    // on our hidden textarea on reload
    if (ie_upto10) setTimeout(bind(resetInput, this, true), 20);

    registerEventHandlers(this);

    var cm = this;
    runInOp(this, function() {
      cm.curOp.forceUpdate = true;
      attachDoc(cm, doc);

      if ((options.autofocus && !mobile) || activeElt() == display.input)
        setTimeout(bind(onFocus, cm), 20);
      else
        onBlur(cm);

      for (var opt in optionHandlers) if (optionHandlers.hasOwnProperty(opt))
        optionHandlers[opt](cm, options[opt], Init);
      for (var i = 0; i < initHooks.length; ++i) initHooks[i](cm);
    });
  }

  // DISPLAY CONSTRUCTOR

  // The display handles the DOM integration, both for input reading
  // and content drawing. It holds references to DOM nodes and
  // display-related state.

  function Display(place, doc) {
    var d = this;

    // The semihidden textarea that is focused when the editor is
    // focused, and receives input.
    var input = d.input = elt("textarea", null, null, "position: absolute; padding: 0; width: 1px; height: 1em; outline: none");
    // The textarea is kept positioned near the cursor to prevent the
    // fact that it'll be scrolled into view on input from scrolling
    // our fake cursor out of view. On webkit, when wrap=off, paste is
    // very slow. So make the area wide instead.
    if (webkit) input.style.width = "1000px";
    else input.setAttribute("wrap", "off");
    // If border: 0; -- iOS fails to open keyboard (issue #1287)
    if (ios) input.style.border = "1px solid black";
    input.setAttribute("autocorrect", "off"); input.setAttribute("autocapitalize", "off"); input.setAttribute("spellcheck", "false");

    // Wraps and hides input textarea
    d.inputDiv = elt("div", [input], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
    // The fake scrollbar elements.
    d.scrollbarH = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
    d.scrollbarV = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
    // Covers bottom-right square when both scrollbars are present.
    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
    // Covers bottom of gutter when coverGutterNextToScrollbar is on
    // and h scrollbar is present.
    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
    // Will contain the actual code, positioned to cover the viewport.
    d.lineDiv = elt("div", null, "CodeMirror-code");
    // Elements are added to these to represent selection and cursors.
    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
    d.cursorDiv = elt("div", null, "CodeMirror-cursors");
    // A visibility: hidden element used to find the size of things.
    d.measure = elt("div", null, "CodeMirror-measure");
    // When lines outside of the viewport are measured, they are drawn in this.
    d.lineMeasure = elt("div", null, "CodeMirror-measure");
    // Wraps everything that needs to exist inside the vertically-padded coordinate system
    d.lineSpace = elt("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
                      null, "position: relative; outline: none");
    // Moved around its parent to cover visible view.
    d.mover = elt("div", [elt("div", [d.lineSpace], "CodeMirror-lines")], null, "position: relative");
    // Set to the height of the document, allowing scrolling.
    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
    // Behavior of elts with overflow: auto and padding is
    // inconsistent across browsers. This is used to ensure the
    // scrollable area is big enough.
    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerCutOff + "px; width: 1px;");
    // Will contain the gutters, if any.
    d.gutters = elt("div", null, "CodeMirror-gutters");
    d.lineGutter = null;
    // Actual scrollable element.
    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
    d.scroller.setAttribute("tabIndex", "-1");
    // The element in which the editor lives.
    d.wrapper = elt("div", [d.inputDiv, d.scrollbarH, d.scrollbarV,
                            d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");

    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
    if (ie_upto7) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
    // Needed to hide big blue blinking cursor on Mobile Safari
    if (ios) input.style.width = "0px";
    if (!webkit) d.scroller.draggable = true;
    // Needed to handle Tab key in KHTML
    if (khtml) { d.inputDiv.style.height = "1px"; d.inputDiv.style.position = "absolute"; }
    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
    if (ie_upto7) d.scrollbarH.style.minHeight = d.scrollbarV.style.minWidth = "18px";

    if (place.appendChild) place.appendChild(d.wrapper);
    else place(d.wrapper);

    // Current rendered range (may be bigger than the view window).
    d.viewFrom = d.viewTo = doc.first;
    // Information about the rendered lines.
    d.view = [];
    // Holds info about a single rendered line when it was rendered
    // for measurement, while not in view.
    d.externalMeasured = null;
    // Empty space (in pixels) above the view
    d.viewOffset = 0;
    d.lastSizeC = 0;
    d.updateLineNumbers = null;

    // Used to only resize the line number gutter when necessary (when
    // the amount of lines crosses a boundary that makes its width change)
    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
    // See readInput and resetInput
    d.prevInput = "";
    // Set to true when a non-horizontal-scrolling line widget is
    // added. As an optimization, line widget aligning is skipped when
    // this is false.
    d.alignWidgets = false;
    // Flag that indicates whether we expect input to appear real soon
    // now (after some event like 'keypress' or 'input') and are
    // polling intensively.
    d.pollingFast = false;
    // Self-resetting timeout for the poller
    d.poll = new Delayed();

    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;

    // Tracks when resetInput has punted to just putting a short
    // string into the textarea instead of the full selection.
    d.inaccurateSelection = false;

    // Tracks the maximum line length so that the horizontal scrollbar
    // can be kept static when scrolling.
    d.maxLine = null;
    d.maxLineLength = 0;
    d.maxLineChanged = false;

    // Used for measuring wheel scrolling granularity
    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

    // True when shift is held down.
    d.shift = false;
  }

  // STATE UPDATES

  // Used to get the editor into a consistent state again when options change.

  function loadMode(cm) {
    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);
    resetModeState(cm);
  }

  function resetModeState(cm) {
    cm.doc.iter(function(line) {
      if (line.stateAfter) line.stateAfter = null;
      if (line.styles) line.styles = null;
    });
    cm.doc.frontier = cm.doc.first;
    startWorker(cm, 100);
    cm.state.modeGen++;
    if (cm.curOp) regChange(cm);
  }

  function wrappingChanged(cm) {
    if (cm.options.lineWrapping) {
      addClass(cm.display.wrapper, "CodeMirror-wrap");
      cm.display.sizer.style.minWidth = "";
    } else {
      rmClass(cm.display.wrapper, "CodeMirror-wrap");
      findMaxLine(cm);
    }
    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(function(){updateScrollbars(cm);}, 100);
  }

  // Returns a function that estimates the height of a line, to use as
  // first approximation until the line becomes visible (and is thus
  // properly measurable).
  function estimateHeight(cm) {
    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
    return function(line) {
      if (lineIsHidden(cm.doc, line)) return 0;

      var widgetsHeight = 0;
      if (line.widgets) for (var i = 0; i < line.widgets.length; i++) {
        if (line.widgets[i].height) widgetsHeight += line.widgets[i].height;
      }

      if (wrapping)
        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
      else
        return widgetsHeight + th;
    };
  }

  function estimateLineHeights(cm) {
    var doc = cm.doc, est = estimateHeight(cm);
    doc.iter(function(line) {
      var estHeight = est(line);
      if (estHeight != line.height) updateLineHeight(line, estHeight);
    });
  }

  function keyMapChanged(cm) {
    var map = keyMap[cm.options.keyMap], style = map.style;
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-keymap-\S+/g, "") +
      (style ? " cm-keymap-" + style : "");
  }

  function themeChanged(cm) {
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
      cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
    clearCaches(cm);
  }

  function guttersChanged(cm) {
    updateGutters(cm);
    regChange(cm);
    setTimeout(function(){alignHorizontally(cm);}, 20);
  }

  // Rebuild the gutter elements, ensure the margin to the left of the
  // code matches their width.
  function updateGutters(cm) {
    var gutters = cm.display.gutters, specs = cm.options.gutters;
    removeChildren(gutters);
    for (var i = 0; i < specs.length; ++i) {
      var gutterClass = specs[i];
      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
      if (gutterClass == "CodeMirror-linenumbers") {
        cm.display.lineGutter = gElt;
        gElt.style.width = (cm.display.lineNumWidth || 1) + "px";
      }
    }
    gutters.style.display = i ? "" : "none";
    updateGutterSpace(cm);
  }

  function updateGutterSpace(cm) {
    var width = cm.display.gutters.offsetWidth;
    cm.display.sizer.style.marginLeft = width + "px";
    cm.display.scrollbarH.style.left = cm.options.fixedGutter ? width + "px" : 0;
  }

  // Compute the character length of a line, taking into account
  // collapsed ranges (see markText) that might hide parts, and join
  // other lines onto it.
  function lineLength(line) {
    if (line.height == 0) return 0;
    var len = line.text.length, merged, cur = line;
    while (merged = collapsedSpanAtStart(cur)) {
      var found = merged.find(0, true);
      cur = found.from.line;
      len += found.from.ch - found.to.ch;
    }
    cur = line;
    while (merged = collapsedSpanAtEnd(cur)) {
      var found = merged.find(0, true);
      len -= cur.text.length - found.from.ch;
      cur = found.to.line;
      len += cur.text.length - found.to.ch;
    }
    return len;
  }

  // Find the longest line in the document.
  function findMaxLine(cm) {
    var d = cm.display, doc = cm.doc;
    d.maxLine = getLine(doc, doc.first);
    d.maxLineLength = lineLength(d.maxLine);
    d.maxLineChanged = true;
    doc.iter(function(line) {
      var len = lineLength(line);
      if (len > d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  }

  // Make sure the gutters options contains the element
  // "CodeMirror-linenumbers" when the lineNumbers option is true.
  function setGuttersForLineNumbers(options) {
    var found = indexOf(options.gutters, "CodeMirror-linenumbers");
    if (found == -1 && options.lineNumbers) {
      options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]);
    } else if (found > -1 && !options.lineNumbers) {
      options.gutters = options.gutters.slice(0);
      options.gutters.splice(found, 1);
    }
  }

  // SCROLLBARS

  // Prepare DOM reads needed to update the scrollbars. Done in one
  // shot to minimize update/measure roundtrips.
  function measureForScrollbars(cm) {
    var scroll = cm.display.scroller;
    return {
      clientHeight: scroll.clientHeight,
      barHeight: cm.display.scrollbarV.clientHeight,
      scrollWidth: scroll.scrollWidth, clientWidth: scroll.clientWidth,
      barWidth: cm.display.scrollbarH.clientWidth,
      docHeight: Math.round(cm.doc.height + paddingVert(cm.display))
    };
  }

  // Re-synchronize the fake scrollbars with the actual size of the
  // content.
  function updateScrollbars(cm, measure) {
    if (!measure) measure = measureForScrollbars(cm);
    var d = cm.display;
    var scrollHeight = measure.docHeight + scrollerCutOff;
    var needsH = measure.scrollWidth > measure.clientWidth;
    var needsV = scrollHeight > measure.clientHeight;
    if (needsV) {
      d.scrollbarV.style.display = "block";
      d.scrollbarV.style.bottom = needsH ? scrollbarWidth(d.measure) + "px" : "0";
      // A bug in IE8 can cause this value to be negative, so guard it.
      d.scrollbarV.firstChild.style.height =
        Math.max(0, scrollHeight - measure.clientHeight + (measure.barHeight || d.scrollbarV.clientHeight)) + "px";
    } else {
      d.scrollbarV.style.display = "";
      d.scrollbarV.firstChild.style.height = "0";
    }
    if (needsH) {
      d.scrollbarH.style.display = "block";
      d.scrollbarH.style.right = needsV ? scrollbarWidth(d.measure) + "px" : "0";
      d.scrollbarH.firstChild.style.width =
        (measure.scrollWidth - measure.clientWidth + (measure.barWidth || d.scrollbarH.clientWidth)) + "px";
    } else {
      d.scrollbarH.style.display = "";
      d.scrollbarH.firstChild.style.width = "0";
    }
    if (needsH && needsV) {
      d.scrollbarFiller.style.display = "block";
      d.scrollbarFiller.style.height = d.scrollbarFiller.style.width = scrollbarWidth(d.measure) + "px";
    } else d.scrollbarFiller.style.display = "";
    if (needsH && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
      d.gutterFiller.style.display = "block";
      d.gutterFiller.style.height = scrollbarWidth(d.measure) + "px";
      d.gutterFiller.style.width = d.gutters.offsetWidth + "px";
    } else d.gutterFiller.style.display = "";

    if (!cm.state.checkedOverlayScrollbar && measure.clientHeight > 0) {
      if (scrollbarWidth(d.measure) === 0) {
        var w = mac && !mac_geMountainLion ? "12px" : "18px";
        d.scrollbarV.style.minWidth = d.scrollbarH.style.minHeight = w;
        var barMouseDown = function(e) {
          if (e_target(e) != d.scrollbarV && e_target(e) != d.scrollbarH)
            operation(cm, onMouseDown)(e);
        };
        on(d.scrollbarV, "mousedown", barMouseDown);
        on(d.scrollbarH, "mousedown", barMouseDown);
      }
      cm.state.checkedOverlayScrollbar = true;
    }
  }

  // Compute the lines that are visible in a given viewport (defaults
  // the the current scroll position). viewPort may contain top,
  // height, and ensure (see op.scrollToPos) properties.
  function visibleLines(display, doc, viewPort) {
    var top = viewPort && viewPort.top != null ? viewPort.top : display.scroller.scrollTop;
    top = Math.floor(top - paddingTop(display));
    var bottom = viewPort && viewPort.bottom != null ? viewPort.bottom : top + display.wrapper.clientHeight;

    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
    // forces those lines into the viewport (if possible).
    if (viewPort && viewPort.ensure) {
      var ensureFrom = viewPort.ensure.from.line, ensureTo = viewPort.ensure.to.line;
      if (ensureFrom < from)
        return {from: ensureFrom,
                to: lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight)};
      if (Math.min(ensureTo, doc.lastLine()) >= to)
        return {from: lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight),
                to: ensureTo};
    }
    return {from: from, to: to};
  }

  // LINE NUMBERS

  // Re-align line numbers and gutter marks to compensate for
  // horizontal scrolling.
  function alignHorizontally(cm) {
    var display = cm.display, view = display.view;
    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;
    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    var gutterW = display.gutters.offsetWidth, left = comp + "px";
    for (var i = 0; i < view.length; i++) if (!view[i].hidden) {
      if (cm.options.fixedGutter && view[i].gutter)
        view[i].gutter.style.left = left;
      var align = view[i].alignable;
      if (align) for (var j = 0; j < align.length; j++)
        align[j].style.left = left;
    }
    if (cm.options.fixedGutter)
      display.gutters.style.left = (comp + gutterW) + "px";
  }

  // Used to ensure that the line number gutter is still the right
  // size for the current document size. Returns true when an update
  // is needed.
  function maybeUpdateLineNumberWidth(cm) {
    if (!cm.options.lineNumbers) return false;
    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
    if (last.length != display.lineNumChars) {
      var test = display.measure.appendChild(elt("div", [elt("div", last)],
                                                 "CodeMirror-linenumber CodeMirror-gutter-elt"));
      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = "";
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding);
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
      display.lineGutter.style.width = display.lineNumWidth + "px";
      updateGutterSpace(cm);
      return true;
    }
    return false;
  }

  function lineNumberFor(options, i) {
    return String(options.lineNumberFormatter(i + options.firstLineNumber));
  }

  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
  // but using getBoundingClientRect to get a sub-pixel-accurate
  // result.
  function compensateForHScroll(display) {
    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
  }

  // DISPLAY DRAWING

  // Updates the display, selection, and scrollbars, using the
  // information in display.view to find out which nodes are no longer
  // up-to-date. Tries to bail out early when no changes are needed,
  // unless forced is true.
  // Returns true if an actual update happened, false otherwise.
  function updateDisplay(cm, viewPort, forced) {
    var oldFrom = cm.display.viewFrom, oldTo = cm.display.viewTo, updated;
    var visible = visibleLines(cm.display, cm.doc, viewPort);
    for (var first = true;; first = false) {
      var oldWidth = cm.display.scroller.clientWidth;
      if (!updateDisplayInner(cm, visible, forced)) break;
      updated = true;

      // If the max line changed since it was last measured, measure it,
      // and ensure the document's width matches it.
      if (cm.display.maxLineChanged && !cm.options.lineWrapping)
        adjustContentWidth(cm);

      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      setDocumentHeight(cm, barMeasure);
      updateScrollbars(cm, barMeasure);
      if (webkit && cm.options.lineWrapping)
        checkForWebkitWidthBug(cm, barMeasure); // (Issue #2420)
      if (first && cm.options.lineWrapping && oldWidth != cm.display.scroller.clientWidth) {
        forced = true;
        continue;
      }
      forced = false;

      // Clip forced viewport to actual scrollable area.
      if (viewPort && viewPort.top != null)
        viewPort = {top: Math.min(barMeasure.docHeight - scrollerCutOff - barMeasure.clientHeight, viewPort.top)};
      // Updated line heights might result in the drawn area not
      // actually covering the viewport. Keep looping until it does.
      visible = visibleLines(cm.display, cm.doc, viewPort);
      if (visible.from >= cm.display.viewFrom && visible.to <= cm.display.viewTo)
        break;
    }

    cm.display.updateLineNumbers = null;
    if (updated) {
      signalLater(cm, "update", cm);
      if (cm.display.viewFrom != oldFrom || cm.display.viewTo != oldTo)
        signalLater(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
    }
    return updated;
  }

  // Does the actual updating of the line display. Bails out
  // (returning false) when there is nothing to be done and forced is
  // false.
  function updateDisplayInner(cm, visible, forced) {
    var display = cm.display, doc = cm.doc;
    if (!display.wrapper.offsetWidth) {
      resetView(cm);
      return;
    }

    // Bail out if the visible area is already rendered and nothing changed.
    if (!forced && visible.from >= display.viewFrom && visible.to <= display.viewTo &&
        countDirtyView(cm) == 0)
      return;

    if (maybeUpdateLineNumberWidth(cm))
      resetView(cm);
    var dims = getDimensions(cm);

    // Compute a suitable new viewport (from & to)
    var end = doc.first + doc.size;
    var from = Math.max(visible.from - cm.options.viewportMargin, doc.first);
    var to = Math.min(end, visible.to + cm.options.viewportMargin);
    if (display.viewFrom < from && from - display.viewFrom < 20) from = Math.max(doc.first, display.viewFrom);
    if (display.viewTo > to && display.viewTo - to < 20) to = Math.min(end, display.viewTo);
    if (sawCollapsedSpans) {
      from = visualLineNo(cm.doc, from);
      to = visualLineEndNo(cm.doc, to);
    }

    var different = from != display.viewFrom || to != display.viewTo ||
      display.lastSizeC != display.wrapper.clientHeight;
    adjustView(cm, from, to);

    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
    // Position the mover div to align with the current scroll position
    cm.display.mover.style.top = display.viewOffset + "px";

    var toUpdate = countDirtyView(cm);
    if (!different && toUpdate == 0 && !forced) return;

    // For big changes, we hide the enclosing element during the
    // update, since that speeds up the operations on most browsers.
    var focused = activeElt();
    if (toUpdate > 4) display.lineDiv.style.display = "none";
    patchDisplay(cm, display.updateLineNumbers, dims);
    if (toUpdate > 4) display.lineDiv.style.display = "";
    // There might have been a widget with a focused element that got
    // hidden or updated, if so re-focus it.
    if (focused && activeElt() != focused && focused.offsetHeight) focused.focus();

    // Prevent selection and cursors from interfering with the scroll
    // width.
    removeChildren(display.cursorDiv);
    removeChildren(display.selectionDiv);

    if (different) {
      display.lastSizeC = display.wrapper.clientHeight;
      startWorker(cm, 400);
    }

    updateHeightsInViewport(cm);

    return true;
  }

  function adjustContentWidth(cm) {
    var display = cm.display;
    var width = measureChar(cm, display.maxLine, display.maxLine.text.length).left;
    display.maxLineChanged = false;
    var minWidth = Math.max(0, width + 3);
    var maxScrollLeft = Math.max(0, display.sizer.offsetLeft + minWidth + scrollerCutOff - display.scroller.clientWidth);
    display.sizer.style.minWidth = minWidth + "px";
    if (maxScrollLeft < cm.doc.scrollLeft)
      setScrollLeft(cm, Math.min(display.scroller.scrollLeft, maxScrollLeft), true);
  }

  function setDocumentHeight(cm, measure) {
    cm.display.sizer.style.minHeight = cm.display.heightForcer.style.top = measure.docHeight + "px";
    cm.display.gutters.style.height = Math.max(measure.docHeight, measure.clientHeight - scrollerCutOff) + "px";
  }


  function checkForWebkitWidthBug(cm, measure) {
    // Work around Webkit bug where it sometimes reserves space for a
    // non-existing phantom scrollbar in the scroller (Issue #2420)
    if (cm.display.sizer.offsetWidth + cm.display.gutters.offsetWidth < cm.display.scroller.clientWidth - 1) {
      cm.display.sizer.style.minHeight = cm.display.heightForcer.style.top = "0px";
      cm.display.gutters.style.height = measure.docHeight + "px";
    }
  }

  // Read the actual heights of the rendered lines, and update their
  // stored heights to match.
  function updateHeightsInViewport(cm) {
    var display = cm.display;
    var prevBottom = display.lineDiv.offsetTop;
    for (var i = 0; i < display.view.length; i++) {
      var cur = display.view[i], height;
      if (cur.hidden) continue;
      if (ie_upto7) {
        var bot = cur.node.offsetTop + cur.node.offsetHeight;
        height = bot - prevBottom;
        prevBottom = bot;
      } else {
        var box = cur.node.getBoundingClientRect();
        height = box.bottom - box.top;
      }
      var diff = cur.line.height - height;
      if (height < 2) height = textHeight(display);
      if (diff > .001 || diff < -.001) {
        updateLineHeight(cur.line, height);
        updateWidgetHeight(cur.line);
        if (cur.rest) for (var j = 0; j < cur.rest.length; j++)
          updateWidgetHeight(cur.rest[j]);
      }
    }
  }

  // Read and store the height of line widgets associated with the
  // given line.
  function updateWidgetHeight(line) {
    if (line.widgets) for (var i = 0; i < line.widgets.length; ++i)
      line.widgets[i].height = line.widgets[i].node.offsetHeight;
  }

  // Do a bulk-read of the DOM positions and sizes needed to draw the
  // view, so that we don't interleave reading and writing to the DOM.
  function getDimensions(cm) {
    var d = cm.display, left = {}, width = {};
    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
      left[cm.options.gutters[i]] = n.offsetLeft;
      width[cm.options.gutters[i]] = n.offsetWidth;
    }
    return {fixedPos: compensateForHScroll(d),
            gutterTotalWidth: d.gutters.offsetWidth,
            gutterLeft: left,
            gutterWidth: width,
            wrapperWidth: d.wrapper.clientWidth};
  }

  // Sync the actual display DOM structure with display.view, removing
  // nodes for lines that are no longer in view, and creating the ones
  // that are not there yet, and updating the ones that are out of
  // date.
  function patchDisplay(cm, updateNumbersFrom, dims) {
    var display = cm.display, lineNumbers = cm.options.lineNumbers;
    var container = display.lineDiv, cur = container.firstChild;

    function rm(node) {
      var next = node.nextSibling;
      // Works around a throw-scroll bug in OS X Webkit
      if (webkit && mac && cm.display.currentWheelTarget == node)
        node.style.display = "none";
      else
        node.parentNode.removeChild(node);
      return next;
    }

    var view = display.view, lineN = display.viewFrom;
    // Loop over the elements in the view, syncing cur (the DOM nodes
    // in display.lineDiv) with the view as we go.
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (lineView.hidden) {
      } else if (!lineView.node) { // Not drawn yet
        var node = buildLineElement(cm, lineView, lineN, dims);
        container.insertBefore(node, cur);
      } else { // Already drawn
        while (cur != lineView.node) cur = rm(cur);
        var updateNumber = lineNumbers && updateNumbersFrom != null &&
          updateNumbersFrom <= lineN && lineView.lineNumber;
        if (lineView.changes) {
          if (indexOf(lineView.changes, "gutter") > -1) updateNumber = false;
          updateLineForChanges(cm, lineView, lineN, dims);
        }
        if (updateNumber) {
          removeChildren(lineView.lineNumber);
          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
        }
        cur = lineView.node.nextSibling;
      }
      lineN += lineView.size;
    }
    while (cur) cur = rm(cur);
  }

  // When an aspect of a line changes, a string is added to
  // lineView.changes. This updates the relevant part of the line's
  // DOM structure.
  function updateLineForChanges(cm, lineView, lineN, dims) {
    for (var j = 0; j < lineView.changes.length; j++) {
      var type = lineView.changes[j];
      if (type == "text") updateLineText(cm, lineView);
      else if (type == "gutter") updateLineGutter(cm, lineView, lineN, dims);
      else if (type == "class") updateLineClasses(lineView);
      else if (type == "widget") updateLineWidgets(lineView, dims);
    }
    lineView.changes = null;
  }

  // Lines with gutter elements, widgets or a background class need to
  // be wrapped, and have the extra elements added to the wrapper div
  function ensureLineWrapped(lineView) {
    if (lineView.node == lineView.text) {
      lineView.node = elt("div", null, null, "position: relative");
      if (lineView.text.parentNode)
        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
      lineView.node.appendChild(lineView.text);
      if (ie_upto7) lineView.node.style.zIndex = 2;
    }
    return lineView.node;
  }

  function updateLineBackground(lineView) {
    var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
    if (cls) cls += " CodeMirror-linebackground";
    if (lineView.background) {
      if (cls) lineView.background.className = cls;
      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }
    } else if (cls) {
      var wrap = ensureLineWrapped(lineView);
      lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
    }
  }

  // Wrapper around buildLineContent which will reuse the structure
  // in display.externalMeasured when possible.
  function getLineContent(cm, lineView) {
    var ext = cm.display.externalMeasured;
    if (ext && ext.line == lineView.line) {
      cm.display.externalMeasured = null;
      lineView.measure = ext.measure;
      return ext.built;
    }
    return buildLineContent(cm, lineView);
  }

  // Redraw the line's text. Interacts with the background and text
  // classes because the mode may output tokens that influence these
  // classes.
  function updateLineText(cm, lineView) {
    var cls = lineView.text.className;
    var built = getLineContent(cm, lineView);
    if (lineView.text == lineView.node) lineView.node = built.pre;
    lineView.text.parentNode.replaceChild(built.pre, lineView.text);
    lineView.text = built.pre;
    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
      lineView.bgClass = built.bgClass;
      lineView.textClass = built.textClass;
      updateLineClasses(lineView);
    } else if (cls) {
      lineView.text.className = cls;
    }
  }

  function updateLineClasses(lineView) {
    updateLineBackground(lineView);
    if (lineView.line.wrapClass)
      ensureLineWrapped(lineView).className = lineView.line.wrapClass;
    else if (lineView.node != lineView.text)
      lineView.node.className = "";
    var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
    lineView.text.className = textClass || "";
  }

  function updateLineGutter(cm, lineView, lineN, dims) {
    if (lineView.gutter) {
      lineView.node.removeChild(lineView.gutter);
      lineView.gutter = null;
    }
    var markers = lineView.line.gutterMarkers;
    if (cm.options.lineNumbers || markers) {
      var wrap = ensureLineWrapped(lineView);
      var gutterWrap = lineView.gutter =
        wrap.insertBefore(elt("div", null, "CodeMirror-gutter-wrapper", "position: absolute; left: " +
                              (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"),
                          lineView.text);
      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
        lineView.lineNumber = gutterWrap.appendChild(
          elt("div", lineNumberFor(cm.options, lineN),
              "CodeMirror-linenumber CodeMirror-gutter-elt",
              "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: "
              + cm.display.lineNumInnerWidth + "px"));
      if (markers) for (var k = 0; k < cm.options.gutters.length; ++k) {
        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
        if (found)
          gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " +
                                     dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
      }
    }
  }

  function updateLineWidgets(lineView, dims) {
    if (lineView.alignable) lineView.alignable = null;
    for (var node = lineView.node.firstChild, next; node; node = next) {
      var next = node.nextSibling;
      if (node.className == "CodeMirror-linewidget")
        lineView.node.removeChild(node);
    }
    insertLineWidgets(lineView, dims);
  }

  // Build a line's DOM representation from scratch
  function buildLineElement(cm, lineView, lineN, dims) {
    var built = getLineContent(cm, lineView);
    lineView.text = lineView.node = built.pre;
    if (built.bgClass) lineView.bgClass = built.bgClass;
    if (built.textClass) lineView.textClass = built.textClass;

    updateLineClasses(lineView);
    updateLineGutter(cm, lineView, lineN, dims);
    insertLineWidgets(lineView, dims);
    return lineView.node;
  }

  // A lineView may contain multiple logical lines (when merged by
  // collapsed spans). The widgets for all of them need to be drawn.
  function insertLineWidgets(lineView, dims) {
    insertLineWidgetsFor(lineView.line, lineView, dims, true);
    if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)
      insertLineWidgetsFor(lineView.rest[i], lineView, dims, false);
  }

  function insertLineWidgetsFor(line, lineView, dims, allowAbove) {
    if (!line.widgets) return;
    var wrap = ensureLineWrapped(lineView);
    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
      var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget");
      if (!widget.handleMouseEvents) node.ignoreEvents = true;
      positionLineWidget(widget, node, lineView, dims);
      if (allowAbove && widget.above)
        wrap.insertBefore(node, lineView.gutter || lineView.text);
      else
        wrap.appendChild(node);
      signalLater(widget, "redraw");
    }
  }

  function positionLineWidget(widget, node, lineView, dims) {
    if (widget.noHScroll) {
      (lineView.alignable || (lineView.alignable = [])).push(node);
      var width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + "px";
      if (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + "px";
      }
      node.style.width = width + "px";
    }
    if (widget.coverGutter) {
      node.style.zIndex = 5;
      node.style.position = "relative";
      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + "px";
    }
  }

  // POSITION OBJECT

  // A Pos instance represents a position within the text.
  var Pos = CodeMirror.Pos = function(line, ch) {
    if (!(this instanceof Pos)) return new Pos(line, ch);
    this.line = line; this.ch = ch;
  };

  // Compare two positions, return 0 if they are the same, a negative
  // number when a is less, and a positive number otherwise.
  var cmp = CodeMirror.cmpPos = function(a, b) { return a.line - b.line || a.ch - b.ch; };

  function copyPos(x) {return Pos(x.line, x.ch);}
  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a; }
  function minPos(a, b) { return cmp(a, b) < 0 ? a : b; }

  // SELECTION / CURSOR

  // Selection objects are immutable. A new one is created every time
  // the selection changes. A selection is one or more non-overlapping
  // (and non-touching) ranges, sorted, and an integer that indicates
  // which one is the primary selection (the one that's scrolled into
  // view, that getCursor returns, etc).
  function Selection(ranges, primIndex) {
    this.ranges = ranges;
    this.primIndex = primIndex;
  }

  Selection.prototype = {
    primary: function() { return this.ranges[this.primIndex]; },
    equals: function(other) {
      if (other == this) return true;
      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return false;
      for (var i = 0; i < this.ranges.length; i++) {
        var here = this.ranges[i], there = other.ranges[i];
        if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) return false;
      }
      return true;
    },
    deepCopy: function() {
      for (var out = [], i = 0; i < this.ranges.length; i++)
        out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));
      return new Selection(out, this.primIndex);
    },
    somethingSelected: function() {
      for (var i = 0; i < this.ranges.length; i++)
        if (!this.ranges[i].empty()) return true;
      return false;
    },
    contains: function(pos, end) {
      if (!end) end = pos;
      for (var i = 0; i < this.ranges.length; i++) {
        var range = this.ranges[i];
        if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
          return i;
      }
      return -1;
    }
  };

  function Range(anchor, head) {
    this.anchor = anchor; this.head = head;
  }

  Range.prototype = {
    from: function() { return minPos(this.anchor, this.head); },
    to: function() { return maxPos(this.anchor, this.head); },
    empty: function() {
      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
    }
  };

  // Take an unsorted, potentially overlapping set of ranges, and
  // build a selection out of it. 'Consumes' ranges array (modifying
  // it).
  function normalizeSelection(ranges, primIndex) {
    var prim = ranges[primIndex];
    ranges.sort(function(a, b) { return cmp(a.from(), b.from()); });
    primIndex = indexOf(ranges, prim);
    for (var i = 1; i < ranges.length; i++) {
      var cur = ranges[i], prev = ranges[i - 1];
      if (cmp(prev.to(), cur.from()) >= 0) {
        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
        if (i <= primIndex) --primIndex;
        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
      }
    }
    return new Selection(ranges, primIndex);
  }

  function simpleSelection(anchor, head) {
    return new Selection([new Range(anchor, head || anchor)], 0);
  }

  // Most of the external API clips given positions to make sure they
  // actually exist within the document.
  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}
  function clipPos(doc, pos) {
    if (pos.line < doc.first) return Pos(doc.first, 0);
    var last = doc.first + doc.size - 1;
    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);
    return clipToLen(pos, getLine(doc, pos.line).text.length);
  }
  function clipToLen(pos, linelen) {
    var ch = pos.ch;
    if (ch == null || ch > linelen) return Pos(pos.line, linelen);
    else if (ch < 0) return Pos(pos.line, 0);
    else return pos;
  }
  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}
  function clipPosArray(doc, array) {
    for (var out = [], i = 0; i < array.length; i++) out[i] = clipPos(doc, array[i]);
    return out;
  }

  // SELECTION UPDATES

  // The 'scroll' parameter given to many of these indicated whether
  // the new cursor position should be scrolled into view after
  // modifying the selection.

  // If shift is held or the extend flag is set, extends a range to
  // include a given position (and optionally a second position).
  // Otherwise, simply returns the range between the given positions.
  // Used for cursor motion and such.
  function extendRange(doc, range, head, other) {
    if (doc.cm && doc.cm.display.shift || doc.extend) {
      var anchor = range.anchor;
      if (other) {
        var posBefore = cmp(head, anchor) < 0;
        if (posBefore != (cmp(other, anchor) < 0)) {
          anchor = head;
          head = other;
        } else if (posBefore != (cmp(head, other) < 0)) {
          head = other;
        }
      }
      return new Range(anchor, head);
    } else {
      return new Range(other || head, head);
    }
  }

  // Extend the primary selection range, discard the rest.
  function extendSelection(doc, head, other, options) {
    setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);
  }

  // Extend all selections (pos is an array of selections with length
  // equal the number of selections)
  function extendSelections(doc, heads, options) {
    for (var out = [], i = 0; i < doc.sel.ranges.length; i++)
      out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);
    var newSel = normalizeSelection(out, doc.sel.primIndex);
    setSelection(doc, newSel, options);
  }

  // Updates a single range in the selection.
  function replaceOneSelection(doc, i, range, options) {
    var ranges = doc.sel.ranges.slice(0);
    ranges[i] = range;
    setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);
  }

  // Reset the selection to a single range.
  function setSimpleSelection(doc, anchor, head, options) {
    setSelection(doc, simpleSelection(anchor, head), options);
  }

  // Give beforeSelectionChange handlers a change to influence a
  // selection update.
  function filterSelectionChange(doc, sel) {
    var obj = {
      ranges: sel.ranges,
      update: function(ranges) {
        this.ranges = [];
        for (var i = 0; i < ranges.length; i++)
          this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
                                     clipPos(doc, ranges[i].head));
      }
    };
    signal(doc, "beforeSelectionChange", doc, obj);
    if (doc.cm) signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
    if (obj.ranges != sel.ranges) return normalizeSelection(obj.ranges, obj.ranges.length - 1);
    else return sel;
  }

  function setSelectionReplaceHistory(doc, sel, options) {
    var done = doc.history.done, last = lst(done);
    if (last && last.ranges) {
      done[done.length - 1] = sel;
      setSelectionNoUndo(doc, sel, options);
    } else {
      setSelection(doc, sel, options);
    }
  }

  // Set a new selection.
  function setSelection(doc, sel, options) {
    setSelectionNoUndo(doc, sel, options);
    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
  }

  function setSelectionNoUndo(doc, sel, options) {
    if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
      sel = filterSelectionChange(doc, sel);

    var bias = cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1;
    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

    if (!(options && options.scroll === false) && doc.cm)
      ensureCursorVisible(doc.cm);
  }

  function setSelectionInner(doc, sel) {
    if (sel.equals(doc.sel)) return;

    doc.sel = sel;

    if (doc.cm) {
      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;
      signalCursorActivity(doc.cm);
    }
    signalLater(doc, "cursorActivity", doc);
  }

  // Verify that the selection does not partially select any atomic
  // marked ranges.
  function reCheckSelection(doc) {
    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);
  }

  // Return a selection that does not partially select any atomic
  // ranges.
  function skipAtomicInSelection(doc, sel, bias, mayClear) {
    var out;
    for (var i = 0; i < sel.ranges.length; i++) {
      var range = sel.ranges[i];
      var newAnchor = skipAtomic(doc, range.anchor, bias, mayClear);
      var newHead = skipAtomic(doc, range.head, bias, mayClear);
      if (out || newAnchor != range.anchor || newHead != range.head) {
        if (!out) out = sel.ranges.slice(0, i);
        out[i] = new Range(newAnchor, newHead);
      }
    }
    return out ? normalizeSelection(out, sel.primIndex) : sel;
  }

  // Ensure a given position is not inside an atomic range.
  function skipAtomic(doc, pos, bias, mayClear) {
    var flipped = false, curPos = pos;
    var dir = bias || 1;
    doc.cantEdit = false;
    search: for (;;) {
      var line = getLine(doc, curPos.line);
      if (line.markedSpans) {
        for (var i = 0; i < line.markedSpans.length; ++i) {
          var sp = line.markedSpans[i], m = sp.marker;
          if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) &&
              (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {
            if (mayClear) {
              signal(m, "beforeCursorEnter");
              if (m.explicitlyCleared) {
                if (!line.markedSpans) break;
                else {--i; continue;}
              }
            }
            if (!m.atomic) continue;
            var newPos = m.find(dir < 0 ? -1 : 1);
            if (cmp(newPos, curPos) == 0) {
              newPos.ch += dir;
              if (newPos.ch < 0) {
                if (newPos.line > doc.first) newPos = clipPos(doc, Pos(newPos.line - 1));
                else newPos = null;
              } else if (newPos.ch > line.text.length) {
                if (newPos.line < doc.first + doc.size - 1) newPos = Pos(newPos.line + 1, 0);
                else newPos = null;
              }
              if (!newPos) {
                if (flipped) {
                  // Driven in a corner -- no valid cursor position found at all
                  // -- try again *with* clearing, if we didn't already
                  if (!mayClear) return skipAtomic(doc, pos, bias, true);
                  // Otherwise, turn off editing until further notice, and return the start of the doc
                  doc.cantEdit = true;
                  return Pos(doc.first, 0);
                }
                flipped = true; newPos = pos; dir = -dir;
              }
            }
            curPos = newPos;
            continue search;
          }
        }
      }
      return curPos;
    }
  }

  // SELECTION DRAWING

  // Redraw the selection and/or cursor
  function updateSelection(cm) {
    var display = cm.display, doc = cm.doc;
    var curFragment = document.createDocumentFragment();
    var selFragment = document.createDocumentFragment();

    for (var i = 0; i < doc.sel.ranges.length; i++) {
      var range = doc.sel.ranges[i];
      var collapsed = range.empty();
      if (collapsed || cm.options.showCursorWhenSelecting)
        drawSelectionCursor(cm, range, curFragment);
      if (!collapsed)
        drawSelectionRange(cm, range, selFragment);
    }

    // Move the hidden textarea near the cursor to prevent scrolling artifacts
    if (cm.options.moveInputWithCursor) {
      var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
      var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
      var top = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
                                     headPos.top + lineOff.top - wrapOff.top));
      var left = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
                                      headPos.left + lineOff.left - wrapOff.left));
      display.inputDiv.style.top = top + "px";
      display.inputDiv.style.left = left + "px";
    }

    removeChildrenAndAdd(display.cursorDiv, curFragment);
    removeChildrenAndAdd(display.selectionDiv, selFragment);
  }

  // Draws a cursor for the given range
  function drawSelectionCursor(cm, range, output) {
    var pos = cursorCoords(cm, range.head, "div");

    var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
    cursor.style.left = pos.left + "px";
    cursor.style.top = pos.top + "px";
    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

    if (pos.other) {
      // Secondary cursor, shown when on a 'jump' in bi-directional text
      var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
      otherCursor.style.display = "";
      otherCursor.style.left = pos.other.left + "px";
      otherCursor.style.top = pos.other.top + "px";
      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
    }
  }

  // Draws the given range as a highlighted selection
  function drawSelectionRange(cm, range, output) {
    var display = cm.display, doc = cm.doc;
    var fragment = document.createDocumentFragment();
    var padding = paddingH(cm.display), leftSide = padding.left, rightSide = display.lineSpace.offsetWidth - padding.right;

    function add(left, top, width, bottom) {
      if (top < 0) top = 0;
      top = Math.round(top);
      bottom = Math.round(bottom);
      fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left +
                               "px; top: " + top + "px; width: " + (width == null ? rightSide - left : width) +
                               "px; height: " + (bottom - top) + "px"));
    }

    function drawForLine(line, fromArg, toArg) {
      var lineObj = getLine(doc, line);
      var lineLen = lineObj.text.length;
      var start, end;
      function coords(ch, bias) {
        return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
      }

      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {
        var leftPos = coords(from, "left"), rightPos, left, right;
        if (from == to) {
          rightPos = leftPos;
          left = right = leftPos.left;
        } else {
          rightPos = coords(to - 1, "right");
          if (dir == "rtl") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }
          left = leftPos.left;
          right = rightPos.right;
        }
        if (fromArg == null && from == 0) left = leftSide;
        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part
          add(left, leftPos.top, null, leftPos.bottom);
          left = leftSide;
          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);
        }
        if (toArg == null && to == lineLen) right = rightSide;
        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)
          start = leftPos;
        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)
          end = rightPos;
        if (left < leftSide + 1) left = leftSide;
        add(left, rightPos.top, right - left, rightPos.bottom);
      });
      return {start: start, end: end};
    }

    var sFrom = range.from(), sTo = range.to();
    if (sFrom.line == sTo.line) {
      drawForLine(sFrom.line, sFrom.ch, sTo.ch);
    } else {
      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
      var singleVLine = visualLine(fromLine) == visualLine(toLine);
      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
      if (singleVLine) {
        if (leftEnd.top < rightStart.top - 2) {
          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
        } else {
          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
        }
      }
      if (leftEnd.bottom < rightStart.top)
        add(leftSide, leftEnd.bottom, null, rightStart.top);
    }

    output.appendChild(fragment);
  }

  // Cursor-blinking
  function restartBlink(cm) {
    if (!cm.state.focused) return;
    var display = cm.display;
    clearInterval(display.blinker);
    var on = true;
    display.cursorDiv.style.visibility = "";
    if (cm.options.cursorBlinkRate > 0)
      display.blinker = setInterval(function() {
        display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
      }, cm.options.cursorBlinkRate);
  }

  // HIGHLIGHT WORKER

  function startWorker(cm, time) {
    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)
      cm.state.highlight.set(time, bind(highlightWorker, cm));
  }

  function highlightWorker(cm) {
    var doc = cm.doc;
    if (doc.frontier < doc.first) doc.frontier = doc.first;
    if (doc.frontier >= cm.display.viewTo) return;
    var end = +new Date + cm.options.workTime;
    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));

    runInOp(cm, function() {
    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {
      if (doc.frontier >= cm.display.viewFrom) { // Visible
        var oldStyles = line.styles;
        var highlighted = highlightLine(cm, line, state, true);
        line.styles = highlighted.styles;
        if (highlighted.classes) line.styleClasses = highlighted.classes;
        else if (line.styleClasses) line.styleClasses = null;
        var ischange = !oldStyles || oldStyles.length != line.styles.length;
        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];
        if (ischange) regLineChange(cm, doc.frontier, "text");
        line.stateAfter = copyState(doc.mode, state);
      } else {
        processLine(cm, line.text, state);
        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
      }
      ++doc.frontier;
      if (+new Date > end) {
        startWorker(cm, cm.options.workDelay);
        return true;
      }
    });
    });
  }

  // Finds the line to start with when starting a parse. Tries to
  // find a line with a stateAfter, so that it can start with a
  // valid state. If that fails, it returns the line with the
  // smallest indentation, which tends to need the least context to
  // parse correctly.
  function findStartLine(cm, n, precise) {
    var minindent, minline, doc = cm.doc;
    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
    for (var search = n; search > lim; --search) {
      if (search <= doc.first) return doc.first;
      var line = getLine(doc, search - 1);
      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;
      var indented = countColumn(line.text, null, cm.options.tabSize);
      if (minline == null || minindent > indented) {
        minline = search - 1;
        minindent = indented;
      }
    }
    return minline;
  }

  function getStateBefore(cm, n, precise) {
    var doc = cm.doc, display = cm.display;
    if (!doc.mode.startState) return true;
    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;
    if (!state) state = startState(doc.mode);
    else state = copyState(doc.mode, state);
    doc.iter(pos, n, function(line) {
      processLine(cm, line.text, state);
      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;
      line.stateAfter = save ? copyState(doc.mode, state) : null;
      ++pos;
    });
    if (precise) doc.frontier = pos;
    return state;
  }

  // POSITION MEASUREMENT

  function paddingTop(display) {return display.lineSpace.offsetTop;}
  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}
  function paddingH(display) {
    if (display.cachedPaddingH) return display.cachedPaddingH;
    var e = removeChildrenAndAdd(display.measure, elt("pre", "x"));
    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};
    if (!isNaN(data.left) && !isNaN(data.right)) display.cachedPaddingH = data;
    return data;
  }

  // Ensure the lineView.wrapping.heights array is populated. This is
  // an array of bottom offsets for the lines that make up a drawn
  // line. When lineWrapping is on, there might be more than one
  // height.
  function ensureLineHeights(cm, lineView, rect) {
    var wrapping = cm.options.lineWrapping;
    var curWidth = wrapping && cm.display.scroller.clientWidth;
    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
      var heights = lineView.measure.heights = [];
      if (wrapping) {
        lineView.measure.width = curWidth;
        var rects = lineView.text.firstChild.getClientRects();
        for (var i = 0; i < rects.length - 1; i++) {
          var cur = rects[i], next = rects[i + 1];
          if (Math.abs(cur.bottom - next.bottom) > 2)
            heights.push((cur.bottom + next.top) / 2 - rect.top);
        }
      }
      heights.push(rect.bottom - rect.top);
    }
  }

  // Find a line map (mapping character offsets to text nodes) and a
  // measurement cache for the given line number. (A line view might
  // contain multiple lines when collapsed ranges are present.)
  function mapFromLineView(lineView, line, lineN) {
    if (lineView.line == line)
      return {map: lineView.measure.map, cache: lineView.measure.cache};
    for (var i = 0; i < lineView.rest.length; i++)
      if (lineView.rest[i] == line)
        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]};
    for (var i = 0; i < lineView.rest.length; i++)
      if (lineNo(lineView.rest[i]) > lineN)
        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i], before: true};
  }

  // Render a line into the hidden node display.externalMeasured. Used
  // when measurement is needed for a line that's not in the viewport.
  function updateExternalMeasurement(cm, line) {
    line = visualLine(line);
    var lineN = lineNo(line);
    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
    view.lineN = lineN;
    var built = view.built = buildLineContent(cm, view);
    view.text = built.pre;
    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
    return view;
  }

  // Get a {top, bottom, left, right} box (in line-local coordinates)
  // for a given character.
  function measureChar(cm, line, ch, bias) {
    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
  }

  // Find a line view that corresponds to the given line number.
  function findViewForLine(cm, lineN) {
    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
      return cm.display.view[findViewIndex(cm, lineN)];
    var ext = cm.display.externalMeasured;
    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
      return ext;
  }

  // Measurement can be split in two steps, the set-up work that
  // applies to the whole line, and the measurement of the actual
  // character. Functions like coordsChar, that need to do a lot of
  // measurements in a row, can thus ensure that the set-up work is
  // only done once.
  function prepareMeasureForLine(cm, line) {
    var lineN = lineNo(line);
    var view = findViewForLine(cm, lineN);
    if (view && !view.text)
      view = null;
    else if (view && view.changes)
      updateLineForChanges(cm, view, lineN, getDimensions(cm));
    if (!view)
      view = updateExternalMeasurement(cm, line);

    var info = mapFromLineView(view, line, lineN);
    return {
      line: line, view: view, rect: null,
      map: info.map, cache: info.cache, before: info.before,
      hasHeights: false
    };
  }

  // Given a prepared measurement object, measures the position of an
  // actual character (or fetches it from the cache).
  function measureCharPrepared(cm, prepared, ch, bias) {
    if (prepared.before) ch = -1;
    var key = ch + (bias || ""), found;
    if (prepared.cache.hasOwnProperty(key)) {
      found = prepared.cache[key];
    } else {
      if (!prepared.rect)
        prepared.rect = prepared.view.text.getBoundingClientRect();
      if (!prepared.hasHeights) {
        ensureLineHeights(cm, prepared.view, prepared.rect);
        prepared.hasHeights = true;
      }
      found = measureCharInner(cm, prepared, ch, bias);
      if (!found.bogus) prepared.cache[key] = found;
    }
    return {left: found.left, right: found.right, top: found.top, bottom: found.bottom};
  }

  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};

  function measureCharInner(cm, prepared, ch, bias) {
    var map = prepared.map;

    var node, start, end, collapse;
    // First, search the line map for the text node corresponding to,
    // or closest to, the target character.
    for (var i = 0; i < map.length; i += 3) {
      var mStart = map[i], mEnd = map[i + 1];
      if (ch < mStart) {
        start = 0; end = 1;
        collapse = "left";
      } else if (ch < mEnd) {
        start = ch - mStart;
        end = start + 1;
      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {
        end = mEnd - mStart;
        start = end - 1;
        if (ch >= mEnd) collapse = "right";
      }
      if (start != null) {
        node = map[i + 2];
        if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
          collapse = bias;
        if (bias == "left" && start == 0)
          while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {
            node = map[(i -= 3) + 2];
            collapse = "left";
          }
        if (bias == "right" && start == mEnd - mStart)
          while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {
            node = map[(i += 3) + 2];
            collapse = "right";
          }
        break;
      }
    }

    var rect;
    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
      while (start && isExtendingChar(prepared.line.text.charAt(mStart + start))) --start;
      while (mStart + end < mEnd && isExtendingChar(prepared.line.text.charAt(mStart + end))) ++end;
      if (ie_upto8 && start == 0 && end == mEnd - mStart) {
        rect = node.parentNode.getBoundingClientRect();
      } else if (ie && cm.options.lineWrapping) {
        var rects = range(node, start, end).getClientRects();
        if (rects.length)
          rect = rects[bias == "right" ? rects.length - 1 : 0];
        else
          rect = nullRect;
      } else {
        rect = range(node, start, end).getBoundingClientRect();
      }
    } else { // If it is a widget, simply get the box for the whole widget.
      if (start > 0) collapse = bias = "right";
      var rects;
      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
        rect = rects[bias == "right" ? rects.length - 1 : 0];
      else
        rect = node.getBoundingClientRect();
    }
    if (ie_upto8 && !start && (!rect || !rect.left && !rect.right)) {
      var rSpan = node.parentNode.getClientRects()[0];
      if (rSpan)
        rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom};
      else
        rect = nullRect;
    }

    var top, bot = (rect.bottom + rect.top) / 2 - prepared.rect.top;
    var heights = prepared.view.measure.heights;
    for (var i = 0; i < heights.length - 1; i++)
      if (bot < heights[i]) break;
    top = i ? heights[i - 1] : 0; bot = heights[i];
    var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
                  right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
                  top: top, bottom: bot};
    if (!rect.left && !rect.right) result.bogus = true;
    return result;
  }

  function clearLineMeasurementCacheFor(lineView) {
    if (lineView.measure) {
      lineView.measure.cache = {};
      lineView.measure.heights = null;
      if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)
        lineView.measure.caches[i] = {};
    }
  }

  function clearLineMeasurementCache(cm) {
    cm.display.externalMeasure = null;
    removeChildren(cm.display.lineMeasure);
    for (var i = 0; i < cm.display.view.length; i++)
      clearLineMeasurementCacheFor(cm.display.view[i]);
  }

  function clearCaches(cm) {
    clearLineMeasurementCache(cm);
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;
    cm.display.lineNumChars = null;
  }

  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }
  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }

  // Converts a {top, bottom, left, right} box from line-local
  // coordinates into another coordinate system. Context may be one of
  // "line", "div" (display.lineDiv), "local"/null (editor), or "page".
  function intoCoordSystem(cm, lineObj, rect, context) {
    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {
      var size = widgetHeight(lineObj.widgets[i]);
      rect.top += size; rect.bottom += size;
    }
    if (context == "line") return rect;
    if (!context) context = "local";
    var yOff = heightAtLine(lineObj);
    if (context == "local") yOff += paddingTop(cm.display);
    else yOff -= cm.display.viewOffset;
    if (context == "page" || context == "window") {
      var lOff = cm.display.lineSpace.getBoundingClientRect();
      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
      rect.left += xOff; rect.right += xOff;
    }
    rect.top += yOff; rect.bottom += yOff;
    return rect;
  }

  // Coverts a box from "div" coords to another coordinate system.
  // Context may be "window", "page", "div", or "local"/null.
  function fromCoordSystem(cm, coords, context) {
    if (context == "div") return coords;
    var left = coords.left, top = coords.top;
    // First move into "page" coordinate system
    if (context == "page") {
      left -= pageScrollX();
      top -= pageScrollY();
    } else if (context == "local" || !context) {
      var localBox = cm.display.sizer.getBoundingClientRect();
      left += localBox.left;
      top += localBox.top;
    }

    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};
  }

  function charCoords(cm, pos, context, lineObj, bias) {
    if (!lineObj) lineObj = getLine(cm.doc, pos.line);
    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
  }

  // Returns a box for a given cursor position, which may have an
  // 'other' property containing the position of the secondary cursor
  // on a bidi boundary.
  function cursorCoords(cm, pos, context, lineObj, preparedMeasure) {
    lineObj = lineObj || getLine(cm.doc, pos.line);
    if (!preparedMeasure) preparedMeasure = prepareMeasureForLine(cm, lineObj);
    function get(ch, right) {
      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left");
      if (right) m.left = m.right; else m.right = m.left;
      return intoCoordSystem(cm, lineObj, m, context);
    }
    function getBidi(ch, partPos) {
      var part = order[partPos], right = part.level % 2;
      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {
        part = order[--partPos];
        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);
        right = true;
      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {
        part = order[++partPos];
        ch = bidiLeft(part) - part.level % 2;
        right = false;
      }
      if (right && ch == part.to && ch > part.from) return get(ch - 1);
      return get(ch, right);
    }
    var order = getOrder(lineObj), ch = pos.ch;
    if (!order) return get(ch);
    var partPos = getBidiPartAt(order, ch);
    var val = getBidi(ch, partPos);
    if (bidiOther != null) val.other = getBidi(ch, bidiOther);
    return val;
  }

  // Used to cheaply estimate the coordinates for a position. Used for
  // intermediate scroll updates.
  function estimateCoords(cm, pos) {
    var left = 0, pos = clipPos(cm.doc, pos);
    if (!cm.options.lineWrapping) left = charWidth(cm.display) * pos.ch;
    var lineObj = getLine(cm.doc, pos.line);
    var top = heightAtLine(lineObj) + paddingTop(cm.display);
    return {left: left, right: left, top: top, bottom: top + lineObj.height};
  }

  // Positions returned by coordsChar contain some extra information.
  // xRel is the relative x position of the input coordinates compared
  // to the found position (so xRel > 0 means the coordinates are to
  // the right of the character position, for example). When outside
  // is true, that means the coordinates lie outside the line's
  // vertical range.
  function PosWithInfo(line, ch, outside, xRel) {
    var pos = Pos(line, ch);
    pos.xRel = xRel;
    if (outside) pos.outside = true;
    return pos;
  }

  // Compute the character position closest to the given coordinates.
  // Input must be lineSpace-local ("div" coordinate system).
  function coordsChar(cm, x, y) {
    var doc = cm.doc;
    y += cm.display.viewOffset;
    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);
    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
    if (lineN > last)
      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);
    if (x < 0) x = 0;

    var lineObj = getLine(doc, lineN);
    for (;;) {
      var found = coordsCharInner(cm, lineObj, lineN, x, y);
      var merged = collapsedSpanAtEnd(lineObj);
      var mergedPos = merged && merged.find(0, true);
      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))
        lineN = lineNo(lineObj = mergedPos.to.line);
      else
        return found;
    }
  }

  function coordsCharInner(cm, lineObj, lineNo, x, y) {
    var innerOff = y - heightAtLine(lineObj);
    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;
    var preparedMeasure = prepareMeasureForLine(cm, lineObj);

    function getX(ch) {
      var sp = cursorCoords(cm, Pos(lineNo, ch), "line", lineObj, preparedMeasure);
      wrongLine = true;
      if (innerOff > sp.bottom) return sp.left - adjust;
      else if (innerOff < sp.top) return sp.left + adjust;
      else wrongLine = false;
      return sp.left;
    }

    var bidi = getOrder(lineObj), dist = lineObj.text.length;
    var from = lineLeft(lineObj), to = lineRight(lineObj);
    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;

    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);
    // Do a binary search between these bounds.
    for (;;) {
      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {
        var ch = x < fromX || x - fromX <= toX - x ? from : to;
        var xDiff = x - (ch == from ? fromX : toX);
        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;
        var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside,
                              xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);
        return pos;
      }
      var step = Math.ceil(dist / 2), middle = from + step;
      if (bidi) {
        middle = from;
        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);
      }
      var middleX = getX(middle);
      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}
      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}
    }
  }

  var measureText;
  // Compute the default text height.
  function textHeight(display) {
    if (display.cachedTextHeight != null) return display.cachedTextHeight;
    if (measureText == null) {
      measureText = elt("pre");
      // Measure a bunch of lines, for browsers that compute
      // fractional heights.
      for (var i = 0; i < 49; ++i) {
        measureText.appendChild(document.createTextNode("x"));
        measureText.appendChild(elt("br"));
      }
      measureText.appendChild(document.createTextNode("x"));
    }
    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;
    if (height > 3) display.cachedTextHeight = height;
    removeChildren(display.measure);
    return height || 1;
  }

  // Compute the default character width.
  function charWidth(display) {
    if (display.cachedCharWidth != null) return display.cachedCharWidth;
    var anchor = elt("span", "xxxxxxxxxx");
    var pre = elt("pre", [anchor]);
    removeChildrenAndAdd(display.measure, pre);
    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
    if (width > 2) display.cachedCharWidth = width;
    return width || 10;
  }

  // OPERATIONS

  // Operations are used to wrap a series of changes to the editor
  // state in such a way that each change won't have to update the
  // cursor and display (which would be awkward, slow, and
  // error-prone). Instead, display updates are batched and then all
  // combined and executed at once.

  var nextOpId = 0;
  // Start a new operation.
  function startOperation(cm) {
    cm.curOp = {
      viewChanged: false,      // Flag that indicates that lines might need to be redrawn
      startHeight: cm.doc.height, // Used to detect need to update scrollbar
      forceUpdate: false,      // Used to force a redraw
      updateInput: null,       // Whether to reset the input textarea
      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
      changeObjs: null,        // Accumulated changes, for firing change events
      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
      selectionChanged: false, // Whether the selection needs to be redrawn
      updateMaxLine: false,    // Set when the widest line needs to be determined anew
      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
      scrollToPos: null,       // Used to scroll to a specific position
      id: ++nextOpId           // Unique ID
    };
    if (!delayedCallbackDepth++) delayedCallbacks = [];
  }

  // Finish an operation, updating the display and signalling delayed events
  function endOperation(cm) {
    var op = cm.curOp, doc = cm.doc, display = cm.display;
    cm.curOp = null;

    if (op.updateMaxLine) findMaxLine(cm);

    // If it looks like an update might be needed, call updateDisplay
    if (op.viewChanged || op.forceUpdate || op.scrollTop != null ||
        op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
                           op.scrollToPos.to.line >= display.viewTo) ||
        display.maxLineChanged && cm.options.lineWrapping) {
      var updated = updateDisplay(cm, {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);
      if (cm.display.scroller.offsetHeight) cm.doc.scrollTop = cm.display.scroller.scrollTop;
    }
    // If no update was run, but the selection changed, redraw that.
    if (!updated && op.selectionChanged) updateSelection(cm);
    if (!updated && op.startHeight != cm.doc.height) updateScrollbars(cm);

    // Propagate the scroll position to the actual DOM scroller
    if (op.scrollTop != null && display.scroller.scrollTop != op.scrollTop) {
      var top = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));
      display.scroller.scrollTop = display.scrollbarV.scrollTop = doc.scrollTop = top;
    }
    if (op.scrollLeft != null && display.scroller.scrollLeft != op.scrollLeft) {
      var left = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, op.scrollLeft));
      display.scroller.scrollLeft = display.scrollbarH.scrollLeft = doc.scrollLeft = left;
      alignHorizontally(cm);
    }
    // If we need to scroll a specific position into view, do so.
    if (op.scrollToPos) {
      var coords = scrollPosIntoView(cm, clipPos(cm.doc, op.scrollToPos.from),
                                     clipPos(cm.doc, op.scrollToPos.to), op.scrollToPos.margin);
      if (op.scrollToPos.isCursor && cm.state.focused) maybeScrollWindow(cm, coords);
    }

    if (op.selectionChanged) restartBlink(cm);

    if (cm.state.focused && op.updateInput)
      resetInput(cm, op.typing);

    // Fire events for markers that are hidden/unidden by editing or
    // undoing
    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
    if (hidden) for (var i = 0; i < hidden.length; ++i)
      if (!hidden[i].lines.length) signal(hidden[i], "hide");
    if (unhidden) for (var i = 0; i < unhidden.length; ++i)
      if (unhidden[i].lines.length) signal(unhidden[i], "unhide");

    var delayed;
    if (!--delayedCallbackDepth) {
      delayed = delayedCallbacks;
      delayedCallbacks = null;
    }
    // Fire change events, and delayed event handlers
    if (op.changeObjs)
      signal(cm, "changes", cm, op.changeObjs);
    if (delayed) for (var i = 0; i < delayed.length; ++i) delayed[i]();
    if (op.cursorActivityHandlers)
      for (var i = 0; i < op.cursorActivityHandlers.length; i++)
        op.cursorActivityHandlers[i](cm);
  }

  // Run the given function in an operation
  function runInOp(cm, f) {
    if (cm.curOp) return f();
    startOperation(cm);
    try { return f(); }
    finally { endOperation(cm); }
  }
  // Wraps a function in an operation. Returns the wrapped function.
  function operation(cm, f) {
    return function() {
      if (cm.curOp) return f.apply(cm, arguments);
      startOperation(cm);
      try { return f.apply(cm, arguments); }
      finally { endOperation(cm); }
    };
  }
  // Used to add methods to editor and doc instances, wrapping them in
  // operations.
  function methodOp(f) {
    return function() {
      if (this.curOp) return f.apply(this, arguments);
      startOperation(this);
      try { return f.apply(this, arguments); }
      finally { endOperation(this); }
    };
  }
  function docMethodOp(f) {
    return function() {
      var cm = this.cm;
      if (!cm || cm.curOp) return f.apply(this, arguments);
      startOperation(cm);
      try { return f.apply(this, arguments); }
      finally { endOperation(cm); }
    };
  }

  // VIEW TRACKING

  // These objects are used to represent the visible (currently drawn)
  // part of the document. A LineView may correspond to multiple
  // logical lines, if those are connected by collapsed ranges.
  function LineView(doc, line, lineN) {
    // The starting line
    this.line = line;
    // Continuing lines, if any
    this.rest = visualLineContinued(line);
    // Number of logical lines in this visual line
    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
    this.node = this.text = null;
    this.hidden = lineIsHidden(doc, line);
  }

  // Create a range of LineView objects for the given lines.
  function buildViewArray(cm, from, to) {
    var array = [], nextPos;
    for (var pos = from; pos < to; pos = nextPos) {
      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
      nextPos = pos + view.size;
      array.push(view);
    }
    return array;
  }

  // Updates the display.view data structure for a given change to the
  // document. From and to are in pre-change coordinates. Lendiff is
  // the amount of lines added or subtracted by the change. This is
  // used for changes that span multiple lines, or change the way
  // lines are divided into visual lines. regLineChange (below)
  // registers single-line changes.
  function regChange(cm, from, to, lendiff) {
    if (from == null) from = cm.doc.first;
    if (to == null) to = cm.doc.first + cm.doc.size;
    if (!lendiff) lendiff = 0;

    var display = cm.display;
    if (lendiff && to < display.viewTo &&
        (display.updateLineNumbers == null || display.updateLineNumbers > from))
      display.updateLineNumbers = from;

    cm.curOp.viewChanged = true;

    if (from >= display.viewTo) { // Change after
      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
        resetView(cm);
    } else if (to <= display.viewFrom) { // Change before
      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
        resetView(cm);
      } else {
        display.viewFrom += lendiff;
        display.viewTo += lendiff;
      }
    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
      resetView(cm);
    } else if (from <= display.viewFrom) { // Top overlap
      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cut) {
        display.view = display.view.slice(cut.index);
        display.viewFrom = cut.lineN;
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    } else if (to >= display.viewTo) { // Bottom overlap
      var cut = viewCuttingPoint(cm, from, from, -1);
      if (cut) {
        display.view = display.view.slice(0, cut.index);
        display.viewTo = cut.lineN;
      } else {
        resetView(cm);
      }
    } else { // Gap in the middle
      var cutTop = viewCuttingPoint(cm, from, from, -1);
      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cutTop && cutBot) {
        display.view = display.view.slice(0, cutTop.index)
          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
          .concat(display.view.slice(cutBot.index));
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    }

    var ext = display.externalMeasured;
    if (ext) {
      if (to < ext.lineN)
        ext.lineN += lendiff;
      else if (from < ext.lineN + ext.size)
        display.externalMeasured = null;
    }
  }

  // Register a change to a single line. Type must be one of "text",
  // "gutter", "class", "widget"
  function regLineChange(cm, line, type) {
    cm.curOp.viewChanged = true;
    var display = cm.display, ext = cm.display.externalMeasured;
    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
      display.externalMeasured = null;

    if (line < display.viewFrom || line >= display.viewTo) return;
    var lineView = display.view[findViewIndex(cm, line)];
    if (lineView.node == null) return;
    var arr = lineView.changes || (lineView.changes = []);
    if (indexOf(arr, type) == -1) arr.push(type);
  }

  // Clear the view.
  function resetView(cm) {
    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
    cm.display.view = [];
    cm.display.viewOffset = 0;
  }

  // Find the view element corresponding to a given line. Return null
  // when the line isn't visible.
  function findViewIndex(cm, n) {
    if (n >= cm.display.viewTo) return null;
    n -= cm.display.viewFrom;
    if (n < 0) return null;
    var view = cm.display.view;
    for (var i = 0; i < view.length; i++) {
      n -= view[i].size;
      if (n < 0) return i;
    }
  }

  function viewCuttingPoint(cm, oldN, newN, dir) {
    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
    if (!sawCollapsedSpans) return {index: index, lineN: newN};
    for (var i = 0, n = cm.display.viewFrom; i < index; i++)
      n += view[i].size;
    if (n != oldN) {
      if (dir > 0) {
        if (index == view.length - 1) return null;
        diff = (n + view[index].size) - oldN;
        index++;
      } else {
        diff = n - oldN;
      }
      oldN += diff; newN += diff;
    }
    while (visualLineNo(cm.doc, newN) != newN) {
      if (index == (dir < 0 ? 0 : view.length - 1)) return null;
      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
      index += dir;
    }
    return {index: index, lineN: newN};
  }

  // Force the view to cover a given range, adding empty view element
  // or clipping off existing ones as needed.
  function adjustView(cm, from, to) {
    var display = cm.display, view = display.view;
    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
      display.view = buildViewArray(cm, from, to);
      display.viewFrom = from;
    } else {
      if (display.viewFrom > from)
        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
      else if (display.viewFrom < from)
        display.view = display.view.slice(findViewIndex(cm, from));
      display.viewFrom = from;
      if (display.viewTo < to)
        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
      else if (display.viewTo > to)
        display.view = display.view.slice(0, findViewIndex(cm, to));
    }
    display.viewTo = to;
  }

  // Count the number of lines in the view whose DOM representation is
  // out of date (or nonexistent).
  function countDirtyView(cm) {
    var view = cm.display.view, dirty = 0;
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (!lineView.hidden && (!lineView.node || lineView.changes)) ++dirty;
    }
    return dirty;
  }

  // INPUT HANDLING

  // Poll for input changes, using the normal rate of polling. This
  // runs as long as the editor is focused.
  function slowPoll(cm) {
    if (cm.display.pollingFast) return;
    cm.display.poll.set(cm.options.pollInterval, function() {
      readInput(cm);
      if (cm.state.focused) slowPoll(cm);
    });
  }

  // When an event has just come in that is likely to add or change
  // something in the input textarea, we poll faster, to ensure that
  // the change appears on the screen quickly.
  function fastPoll(cm) {
    var missed = false;
    cm.display.pollingFast = true;
    function p() {
      var changed = readInput(cm);
      if (!changed && !missed) {missed = true; cm.display.poll.set(60, p);}
      else {cm.display.pollingFast = false; slowPoll(cm);}
    }
    cm.display.poll.set(20, p);
  }

  // Read input from the textarea, and update the document to match.
  // When something is selected, it is present in the textarea, and
  // selected (unless it is huge, in which case a placeholder is
  // used). When nothing is selected, the cursor sits after previously
  // seen text (can be empty), which is stored in prevInput (we must
  // not reset the textarea when typing, because that breaks IME).
  function readInput(cm) {
    var input = cm.display.input, prevInput = cm.display.prevInput, doc = cm.doc;
    // Since this is called a *lot*, try to bail out as cheaply as
    // possible when it is clear that nothing happened. hasSelection
    // will be the case when there is a lot of text in the textarea,
    // in which case reading its value would be expensive.
    if (!cm.state.focused || (hasSelection(input) && !prevInput) || isReadOnly(cm) || cm.options.disableInput)
      return false;
    // See paste handler for more on the fakedLastChar kludge
    if (cm.state.pasteIncoming && cm.state.fakedLastChar) {
      input.value = input.value.substring(0, input.value.length - 1);
      cm.state.fakedLastChar = false;
    }
    var text = input.value;
    // If nothing changed, bail.
    if (text == prevInput && !cm.somethingSelected()) return false;
    // Work around nonsensical selection resetting in IE9/10
    if (ie && !ie_upto8 && cm.display.inputHasSelection === text) {
      resetInput(cm);
      return false;
    }

    var withOp = !cm.curOp;
    if (withOp) startOperation(cm);
    cm.display.shift = false;

    // Find the part of the input that is actually new
    var same = 0, l = Math.min(prevInput.length, text.length);
    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;
    var inserted = text.slice(same), textLines = splitLines(inserted);

    // When pasing N lines into N selections, insert one line per selection
    var multiPaste = cm.state.pasteIncoming && textLines.length > 1 && doc.sel.ranges.length == textLines.length;

    // Normal behavior is to insert the new text into every selection
    for (var i = doc.sel.ranges.length - 1; i >= 0; i--) {
      var range = doc.sel.ranges[i];
      var from = range.from(), to = range.to();
      // Handle deletion
      if (same < prevInput.length)
        from = Pos(from.line, from.ch - (prevInput.length - same));
      // Handle overwrite
      else if (cm.state.overwrite && range.empty() && !cm.state.pasteIncoming)
        to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));
      var updateInput = cm.curOp.updateInput;
      var changeEvent = {from: from, to: to, text: multiPaste ? [textLines[i]] : textLines,
                         origin: cm.state.pasteIncoming ? "paste" : cm.state.cutIncoming ? "cut" : "+input"};
      makeChange(cm.doc, changeEvent);
      signalLater(cm, "inputRead", cm, changeEvent);
      // When an 'electric' character is inserted, immediately trigger a reindent
      if (inserted && !cm.state.pasteIncoming && cm.options.electricChars &&
          cm.options.smartIndent && range.head.ch < 100 &&
          (!i || doc.sel.ranges[i - 1].head.line != range.head.line)) {
        var mode = cm.getModeAt(range.head);
        if (mode.electricChars) {
          for (var j = 0; j < mode.electricChars.length; j++)
            if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
              indentLine(cm, range.head.line, "smart");
              break;
            }
        } else if (mode.electricInput) {
          var end = changeEnd(changeEvent);
          if (mode.electricInput.test(getLine(doc, end.line).text.slice(0, end.ch)))
            indentLine(cm, range.head.line, "smart");
        }
      }
    }
    ensureCursorVisible(cm);
    cm.curOp.updateInput = updateInput;
    cm.curOp.typing = true;

    // Don't leave long text in the textarea, since it makes further polling slow
    if (text.length > 1000 || text.indexOf("\n") > -1) input.value = cm.display.prevInput = "";
    else cm.display.prevInput = text;
    if (withOp) endOperation(cm);
    cm.state.pasteIncoming = cm.state.cutIncoming = false;
    return true;
  }

  // Reset the input to correspond to the selection (or to be empty,
  // when not typing and nothing is selected)
  function resetInput(cm, typing) {
    var minimal, selected, doc = cm.doc;
    if (cm.somethingSelected()) {
      cm.display.prevInput = "";
      var range = doc.sel.primary();
      minimal = hasCopyEvent &&
        (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000);
      var content = minimal ? "-" : selected || cm.getSelection();
      cm.display.input.value = content;
      if (cm.state.focused) selectInput(cm.display.input);
      if (ie && !ie_upto8) cm.display.inputHasSelection = content;
    } else if (!typing) {
      cm.display.prevInput = cm.display.input.value = "";
      if (ie && !ie_upto8) cm.display.inputHasSelection = null;
    }
    cm.display.inaccurateSelection = minimal;
  }

  function focusInput(cm) {
    if (cm.options.readOnly != "nocursor" && (!mobile || activeElt() != cm.display.input))
      cm.display.input.focus();
  }

  function ensureFocus(cm) {
    if (!cm.state.focused) { focusInput(cm); onFocus(cm); }
  }

  function isReadOnly(cm) {
    return cm.options.readOnly || cm.doc.cantEdit;
  }

  // EVENT HANDLERS

  // Attach the necessary event handlers when initializing the editor
  function registerEventHandlers(cm) {
    var d = cm.display;
    on(d.scroller, "mousedown", operation(cm, onMouseDown));
    // Older IE's will not fire a second mousedown for a double click
    if (ie_upto10)
      on(d.scroller, "dblclick", operation(cm, function(e) {
        if (signalDOMEvent(cm, e)) return;
        var pos = posFromMouse(cm, e);
        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;
        e_preventDefault(e);
        var word = findWordAt(cm.doc, pos);
        extendSelection(cm.doc, word.anchor, word.head);
      }));
    else
      on(d.scroller, "dblclick", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });
    // Prevent normal selection in the editor (we handle our own)
    on(d.lineSpace, "selectstart", function(e) {
      if (!eventInWidget(d, e)) e_preventDefault(e);
    });
    // Some browsers fire contextmenu *after* opening the menu, at
    // which point we can't mess with it anymore. Context menu is
    // handled in onMouseDown for these browsers.
    if (!captureRightClick) on(d.scroller, "contextmenu", function(e) {onContextMenu(cm, e);});

    // Sync scrolling between fake scrollbars and real scrollable
    // area, ensure viewport is updated when scrolling.
    on(d.scroller, "scroll", function() {
      if (d.scroller.clientHeight) {
        setScrollTop(cm, d.scroller.scrollTop);
        setScrollLeft(cm, d.scroller.scrollLeft, true);
        signal(cm, "scroll", cm);
      }
    });
    on(d.scrollbarV, "scroll", function() {
      if (d.scroller.clientHeight) setScrollTop(cm, d.scrollbarV.scrollTop);
    });
    on(d.scrollbarH, "scroll", function() {
      if (d.scroller.clientHeight) setScrollLeft(cm, d.scrollbarH.scrollLeft);
    });

    // Listen to wheel events in order to try and update the viewport on time.
    on(d.scroller, "mousewheel", function(e){onScrollWheel(cm, e);});
    on(d.scroller, "DOMMouseScroll", function(e){onScrollWheel(cm, e);});

    // Prevent clicks in the scrollbars from killing focus
    function reFocus() { if (cm.state.focused) setTimeout(bind(focusInput, cm), 0); }
    on(d.scrollbarH, "mousedown", reFocus);
    on(d.scrollbarV, "mousedown", reFocus);
    // Prevent wrapper from ever scrolling
    on(d.wrapper, "scroll", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });

    // When the window resizes, we need to refresh active editors.
    var resizeTimer;
    function onResize() {
      if (resizeTimer == null) resizeTimer = setTimeout(function() {
        resizeTimer = null;
        // Might be a text scaling operation, clear size caches.
        d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = knownScrollbarWidth = null;
        cm.setSize();
      }, 100);
    }
    on(window, "resize", onResize);
    // The above handler holds on to the editor and its data
    // structures. Here we poll to unregister it when the editor is no
    // longer in the document, so that it can be garbage-collected.
    function unregister() {
      if (contains(document.body, d.wrapper)) setTimeout(unregister, 5000);
      else off(window, "resize", onResize);
    }
    setTimeout(unregister, 5000);

    on(d.input, "keyup", operation(cm, onKeyUp));
    on(d.input, "input", function() {
      if (ie && !ie_upto8 && cm.display.inputHasSelection) cm.display.inputHasSelection = null;
      fastPoll(cm);
    });
    on(d.input, "keydown", operation(cm, onKeyDown));
    on(d.input, "keypress", operation(cm, onKeyPress));
    on(d.input, "focus", bind(onFocus, cm));
    on(d.input, "blur", bind(onBlur, cm));

    function drag_(e) {
      if (!signalDOMEvent(cm, e)) e_stop(e);
    }
    if (cm.options.dragDrop) {
      on(d.scroller, "dragstart", function(e){onDragStart(cm, e);});
      on(d.scroller, "dragenter", drag_);
      on(d.scroller, "dragover", drag_);
      on(d.scroller, "drop", operation(cm, onDrop));
    }
    on(d.scroller, "paste", function(e) {
      if (eventInWidget(d, e)) return;
      cm.state.pasteIncoming = true;
      focusInput(cm);
      fastPoll(cm);
    });
    on(d.input, "paste", function() {
      // Workaround for webkit bug https://bugs.webkit.org/show_bug.cgi?id=90206
      // Add a char to the end of textarea before paste occur so that
      // selection doesn't span to the end of textarea.
      if (webkit && !cm.state.fakedLastChar && !(new Date - cm.state.lastMiddleDown < 200)) {
        var start = d.input.selectionStart, end = d.input.selectionEnd;
        d.input.value += "$";
        d.input.selectionStart = start;
        d.input.selectionEnd = end;
        cm.state.fakedLastChar = true;
      }
      cm.state.pasteIncoming = true;
      fastPoll(cm);
    });

    function prepareCopyCut(e) {
      if (cm.somethingSelected()) {
        if (d.inaccurateSelection) {
          d.prevInput = "";
          d.inaccurateSelection = false;
          d.input.value = cm.getSelection();
          selectInput(d.input);
        }
      } else {
        var text = "", ranges = [];
        for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
          var line = cm.doc.sel.ranges[i].head.line;
          var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};
          ranges.push(lineRange);
          text += cm.getRange(lineRange.anchor, lineRange.head);
        }
        if (e.type == "cut") {
          cm.setSelections(ranges, null, sel_dontScroll);
        } else {
          d.prevInput = "";
          d.input.value = text;
          selectInput(d.input);
        }
      }
      if (e.type == "cut") cm.state.cutIncoming = true;
    }
    on(d.input, "cut", prepareCopyCut);
    on(d.input, "copy", prepareCopyCut);

    // Needed to handle Tab key in KHTML
    if (khtml) on(d.sizer, "mouseup", function() {
      if (activeElt() == d.input) d.input.blur();
      focusInput(cm);
    });
  }

  // MOUSE EVENTS

  // Return true when the given mouse event happened in a widget
  function eventInWidget(display, e) {
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
      if (!n || n.ignoreEvents || n.parentNode == display.sizer && n != display.mover) return true;
    }
  }

  // Given a mouse event, find the corresponding position. If liberal
  // is false, it checks whether a gutter or scrollbar was clicked,
  // and returns null if it was. forRect is used by rectangular
  // selections, and tries to estimate a character position even for
  // coordinates beyond the right of the text.
  function posFromMouse(cm, e, liberal, forRect) {
    var display = cm.display;
    if (!liberal) {
      var target = e_target(e);
      if (target == display.scrollbarH || target == display.scrollbarV ||
          target == display.scrollbarFiller || target == display.gutterFiller) return null;
    }
    var x, y, space = display.lineSpace.getBoundingClientRect();
    // Fails unpredictably on IE[67] when mouse is dragged around quickly.
    try { x = e.clientX - space.left; y = e.clientY - space.top; }
    catch (e) { return null; }
    var coords = coordsChar(cm, x, y), line;
    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
    }
    return coords;
  }

  // A mouse down can be a single click, double click, triple click,
  // start of selection drag, start of text drag, new cursor
  // (ctrl-click), rectangle drag (alt-drag), or xwin
  // middle-click-paste. Or it might be a click on something we should
  // not interfere with, such as a scrollbar or widget.
  function onMouseDown(e) {
    if (signalDOMEvent(this, e)) return;
    var cm = this, display = cm.display;
    display.shift = e.shiftKey;

    if (eventInWidget(display, e)) {
      if (!webkit) {
        // Briefly turn off draggability, to allow widgets to do
        // normal dragging things.
        display.scroller.draggable = false;
        setTimeout(function(){display.scroller.draggable = true;}, 100);
      }
      return;
    }
    if (clickInGutter(cm, e)) return;
    var start = posFromMouse(cm, e);
    window.focus();

    switch (e_button(e)) {
    case 1:
      if (start)
        leftButtonDown(cm, e, start);
      else if (e_target(e) == display.scroller)
        e_preventDefault(e);
      break;
    case 2:
      if (webkit) cm.state.lastMiddleDown = +new Date;
      if (start) extendSelection(cm.doc, start);
      setTimeout(bind(focusInput, cm), 20);
      e_preventDefault(e);
      break;
    case 3:
      if (captureRightClick) onContextMenu(cm, e);
      break;
    }
  }

  var lastClick, lastDoubleClick;
  function leftButtonDown(cm, e, start) {
    setTimeout(bind(ensureFocus, cm), 0);

    var now = +new Date, type;
    if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {
      type = "triple";
    } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {
      type = "double";
      lastDoubleClick = {time: now, pos: start};
    } else {
      type = "single";
      lastClick = {time: now, pos: start};
    }

    var sel = cm.doc.sel, addNew = mac ? e.metaKey : e.ctrlKey;
    if (cm.options.dragDrop && dragAndDrop && !addNew && !isReadOnly(cm) &&
        type == "single" && sel.contains(start) > -1 && sel.somethingSelected())
      leftButtonStartDrag(cm, e, start);
    else
      leftButtonSelect(cm, e, start, type, addNew);
  }

  // Start a text drag. When it ends, see if any dragging actually
  // happen, and treat as a click if it didn't.
  function leftButtonStartDrag(cm, e, start) {
    var display = cm.display;
    var dragEnd = operation(cm, function(e2) {
      if (webkit) display.scroller.draggable = false;
      cm.state.draggingText = false;
      off(document, "mouseup", dragEnd);
      off(display.scroller, "drop", dragEnd);
      if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
        e_preventDefault(e2);
        extendSelection(cm.doc, start);
        focusInput(cm);
        // Work around unexplainable focus problem in IE9 (#2127)
        if (ie_upto10 && !ie_upto8)
          setTimeout(function() {document.body.focus(); focusInput(cm);}, 20);
      }
    });
    // Let the drag handler handle this.
    if (webkit) display.scroller.draggable = true;
    cm.state.draggingText = dragEnd;
    // IE's approach to draggable
    if (display.scroller.dragDrop) display.scroller.dragDrop();
    on(document, "mouseup", dragEnd);
    on(display.scroller, "drop", dragEnd);
  }

  // Normal selection, as opposed to text dragging.
  function leftButtonSelect(cm, e, start, type, addNew) {
    var display = cm.display, doc = cm.doc;
    e_preventDefault(e);

    var ourRange, ourIndex, startSel = doc.sel;
    if (addNew && !e.shiftKey) {
      ourIndex = doc.sel.contains(start);
      if (ourIndex > -1)
        ourRange = doc.sel.ranges[ourIndex];
      else
        ourRange = new Range(start, start);
    } else {
      ourRange = doc.sel.primary();
    }

    if (e.altKey) {
      type = "rect";
      if (!addNew) ourRange = new Range(start, start);
      start = posFromMouse(cm, e, true, true);
      ourIndex = -1;
    } else if (type == "double") {
      var word = findWordAt(doc, start);
      if (cm.display.shift || doc.extend)
        ourRange = extendRange(doc, ourRange, word.anchor, word.head);
      else
        ourRange = word;
    } else if (type == "triple") {
      var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));
      if (cm.display.shift || doc.extend)
        ourRange = extendRange(doc, ourRange, line.anchor, line.head);
      else
        ourRange = line;
    } else {
      ourRange = extendRange(doc, ourRange, start);
    }

    if (!addNew) {
      ourIndex = 0;
      setSelection(doc, new Selection([ourRange], 0), sel_mouse);
      startSel = doc.sel;
    } else if (ourIndex > -1) {
      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
    } else {
      ourIndex = doc.sel.ranges.length;
      setSelection(doc, normalizeSelection(doc.sel.ranges.concat([ourRange]), ourIndex),
                   {scroll: false, origin: "*mouse"});
    }

    var lastPos = start;
    function extendTo(pos) {
      if (cmp(lastPos, pos) == 0) return;
      lastPos = pos;

      if (type == "rect") {
        var ranges = [], tabSize = cm.options.tabSize;
        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
             line <= end; line++) {
          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
          if (left == right)
            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
          else if (text.length > leftPos)
            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
        }
        if (!ranges.length) ranges.push(new Range(start, start));
        setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex), sel_mouse);
      } else {
        var oldRange = ourRange;
        var anchor = oldRange.anchor, head = pos;
        if (type != "single") {
          if (type == "double")
            var range = findWordAt(doc, pos);
          else
            var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));
          if (cmp(range.anchor, anchor) > 0) {
            head = range.head;
            anchor = minPos(oldRange.from(), range.anchor);
          } else {
            head = range.anchor;
            anchor = maxPos(oldRange.to(), range.head);
          }
        }
        var ranges = startSel.ranges.slice(0);
        ranges[ourIndex] = new Range(clipPos(doc, anchor), head);
        setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);
      }
    }

    var editorSize = display.wrapper.getBoundingClientRect();
    // Used to ensure timeout re-tries don't fire when another extend
    // happened in the meantime (clearTimeout isn't reliable -- at
    // least on Chrome, the timeouts still happen even when cleared,
    // if the clear happens after their scheduled firing time).
    var counter = 0;

    function extend(e) {
      var curCount = ++counter;
      var cur = posFromMouse(cm, e, true, type == "rect");
      if (!cur) return;
      if (cmp(cur, lastPos) != 0) {
        ensureFocus(cm);
        extendTo(cur);
        var visible = visibleLines(display, doc);
        if (cur.line >= visible.to || cur.line < visible.from)
          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);
      } else {
        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
        if (outside) setTimeout(operation(cm, function() {
          if (counter != curCount) return;
          display.scroller.scrollTop += outside;
          extend(e);
        }), 50);
      }
    }

    function done(e) {
      counter = Infinity;
      e_preventDefault(e);
      focusInput(cm);
      off(document, "mousemove", move);
      off(document, "mouseup", up);
      doc.history.lastSelOrigin = null;
    }

    var move = operation(cm, function(e) {
      if ((ie && !ie_upto9) ?  !e.buttons : !e_button(e)) done(e);
      else extend(e);
    });
    var up = operation(cm, done);
    on(document, "mousemove", move);
    on(document, "mouseup", up);
  }

  // Determines whether an event happened in the gutter, and fires the
  // handlers for the corresponding event.
  function gutterEvent(cm, e, type, prevent, signalfn) {
    try { var mX = e.clientX, mY = e.clientY; }
    catch(e) { return false; }
    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return false;
    if (prevent) e_preventDefault(e);

    var display = cm.display;
    var lineBox = display.lineDiv.getBoundingClientRect();

    if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);
    mY -= lineBox.top - display.viewOffset;

    for (var i = 0; i < cm.options.gutters.length; ++i) {
      var g = display.gutters.childNodes[i];
      if (g && g.getBoundingClientRect().right >= mX) {
        var line = lineAtHeight(cm.doc, mY);
        var gutter = cm.options.gutters[i];
        signalfn(cm, type, cm, line, gutter, e);
        return e_defaultPrevented(e);
      }
    }
  }

  function clickInGutter(cm, e) {
    return gutterEvent(cm, e, "gutterClick", true, signalLater);
  }

  // Kludge to work around strange IE behavior where it'll sometimes
  // re-fire a series of drag-related events right after the drop (#1551)
  var lastDrop = 0;

  function onDrop(e) {
    var cm = this;
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
      return;
    e_preventDefault(e);
    if (ie) lastDrop = +new Date;
    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
    if (!pos || isReadOnly(cm)) return;
    // Might be a file drop, in which case we simply extract the text
    // and insert it.
    if (files && files.length && window.FileReader && window.File) {
      var n = files.length, text = Array(n), read = 0;
      var loadFile = function(file, i) {
        var reader = new FileReader;
        reader.onload = operation(cm, function() {
          text[i] = reader.result;
          if (++read == n) {
            pos = clipPos(cm.doc, pos);
            var change = {from: pos, to: pos, text: splitLines(text.join("\n")), origin: "paste"};
            makeChange(cm.doc, change);
            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
          }
        });
        reader.readAsText(file);
      };
      for (var i = 0; i < n; ++i) loadFile(files[i], i);
    } else { // Normal drop
      // Don't do a replace if the drop happened inside of the selected text.
      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
        cm.state.draggingText(e);
        // Ensure the editor is re-focused
        setTimeout(bind(focusInput, cm), 20);
        return;
      }
      try {
        var text = e.dataTransfer.getData("Text");
        if (text) {
          var selected = cm.state.draggingText && cm.listSelections();
          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
          if (selected) for (var i = 0; i < selected.length; ++i)
            replaceRange(cm.doc, "", selected[i].anchor, selected[i].head, "drag");
          cm.replaceSelection(text, "around", "paste");
          focusInput(cm);
        }
      }
      catch(e){}
    }
  }

  function onDragStart(cm, e) {
    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;

    e.dataTransfer.setData("Text", cm.getSelection());

    // Use dummy image instead of default browsers image.
    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
    if (e.dataTransfer.setDragImage && !safari) {
      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
      if (presto) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img);
        // Force a relayout, or Opera won't use our image for some obscure reason
        img._top = img.offsetTop;
      }
      e.dataTransfer.setDragImage(img, 0, 0);
      if (presto) img.parentNode.removeChild(img);
    }
  }

  // SCROLL EVENTS

  // Sync the scrollable area and scrollbars, ensure the viewport
  // covers the visible area.
  function setScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2) return;
    cm.doc.scrollTop = val;
    if (!gecko) updateDisplay(cm, {top: val});
    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;
    if (cm.display.scrollbarV.scrollTop != val) cm.display.scrollbarV.scrollTop = val;
    if (gecko) updateDisplay(cm);
    startWorker(cm, 100);
  }
  // Sync scroller and scrollbar, ensure the gutter elements are
  // aligned.
  function setScrollLeft(cm, val, isScroller) {
    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;
    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
    cm.doc.scrollLeft = val;
    alignHorizontally(cm);
    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;
    if (cm.display.scrollbarH.scrollLeft != val) cm.display.scrollbarH.scrollLeft = val;
  }

  // Since the delta values reported on mouse wheel events are
  // unstandardized between browsers and even browser versions, and
  // generally horribly unpredictable, this code starts by measuring
  // the scroll effect that the first few mouse wheel events have,
  // and, from that, detects the way it can convert deltas to pixel
  // offsets afterwards.
  //
  // The reason we want to know the amount a wheel event will scroll
  // is that it gives us a chance to update the display before the
  // actual scrolling happens, reducing flickering.

  var wheelSamples = 0, wheelPixelsPerUnit = null;
  // Fill in a browser-detected starting value on browsers where we
  // know one. These don't have to be accurate -- the result of them
  // being wrong would just be a slight flicker on the first wheel
  // scroll (if it is large enough).
  if (ie) wheelPixelsPerUnit = -.53;
  else if (gecko) wheelPixelsPerUnit = 15;
  else if (chrome) wheelPixelsPerUnit = -.7;
  else if (safari) wheelPixelsPerUnit = -1/3;

  function onScrollWheel(cm, e) {
    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;
    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;
    else if (dy == null) dy = e.wheelDelta;

    var display = cm.display, scroll = display.scroller;
    // Quit if there's nothing to scroll here
    if (!(dx && scroll.scrollWidth > scroll.clientWidth ||
          dy && scroll.scrollHeight > scroll.clientHeight)) return;

    // Webkit browsers on OS X abort momentum scrolls when the target
    // of the scroll event is removed from the scrollable element.
    // This hack (see related code in patchDisplay) makes sure the
    // element is kept around.
    if (dy && mac && webkit) {
      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
        for (var i = 0; i < view.length; i++) {
          if (view[i].node == cur) {
            cm.display.currentWheelTarget = cur;
            break outer;
          }
        }
      }
    }

    // On some browsers, horizontal scrolling will cause redraws to
    // happen before the gutter has been realigned, causing it to
    // wriggle around in a most unseemly way. When we have an
    // estimated pixels/delta value, we just handle horizontal
    // scrolling entirely here. It'll be slightly off from native, but
    // better than glitching out.
    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
      if (dy)
        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));
      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));
      e_preventDefault(e);
      display.wheelStartX = null; // Abort measurement, if in progress
      return;
    }

    // 'Project' the visible viewport to cover the area that is being
    // scrolled into view (if we know enough to estimate it).
    if (dy && wheelPixelsPerUnit != null) {
      var pixels = dy * wheelPixelsPerUnit;
      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
      if (pixels < 0) top = Math.max(0, top + pixels - 50);
      else bot = Math.min(cm.doc.height, bot + pixels + 50);
      updateDisplay(cm, {top: top, bottom: bot});
    }

    if (wheelSamples < 20) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx; display.wheelDY = dy;
        setTimeout(function() {
          if (display.wheelStartX == null) return;
          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
            (movedX && display.wheelDX && movedX / display.wheelDX);
          display.wheelStartX = display.wheelStartY = null;
          if (!sample) return;
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx; display.wheelDY += dy;
      }
    }
  }

  // KEY EVENTS

  // Run a handler that was bound to a key.
  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == "string") {
      bound = commands[bound];
      if (!bound) return false;
    }
    // Ensure previous input has been read, so that the handler sees a
    // consistent view of the document
    if (cm.display.pollingFast && readInput(cm)) cm.display.pollingFast = false;
    var prevShift = cm.display.shift, done = false;
    try {
      if (isReadOnly(cm)) cm.state.suppressEdits = true;
      if (dropShift) cm.display.shift = false;
      done = bound(cm) != Pass;
    } finally {
      cm.display.shift = prevShift;
      cm.state.suppressEdits = false;
    }
    return done;
  }

  // Collect the currently active keymaps.
  function allKeyMaps(cm) {
    var maps = cm.state.keyMaps.slice(0);
    if (cm.options.extraKeys) maps.push(cm.options.extraKeys);
    maps.push(cm.options.keyMap);
    return maps;
  }

  var maybeTransition;
  // Handle a key from the keydown event.
  function handleKeyBinding(cm, e) {
    // Handle automatic keymap transitions
    var startMap = getKeyMap(cm.options.keyMap), next = startMap.auto;
    clearTimeout(maybeTransition);
    if (next && !isModifierKey(e)) maybeTransition = setTimeout(function() {
      if (getKeyMap(cm.options.keyMap) == startMap) {
        cm.options.keyMap = (next.call ? next.call(null, cm) : next);
        keyMapChanged(cm);
      }
    }, 50);

    var name = keyName(e, true), handled = false;
    if (!name) return false;
    var keymaps = allKeyMaps(cm);

    if (e.shiftKey) {
      // First try to resolve full name (including 'Shift-'). Failing
      // that, see if there is a cursor-motion command (starting with
      // 'go') bound to the keyname without 'Shift-'.
      handled = lookupKey("Shift-" + name, keymaps, function(b) {return doHandleBinding(cm, b, true);})
             || lookupKey(name, keymaps, function(b) {
                  if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
                    return doHandleBinding(cm, b);
                });
    } else {
      handled = lookupKey(name, keymaps, function(b) { return doHandleBinding(cm, b); });
    }

    if (handled) {
      e_preventDefault(e);
      restartBlink(cm);
      signalLater(cm, "keyHandled", cm, name, e);
    }
    return handled;
  }

  // Handle a key from the keypress event
  function handleCharBinding(cm, e, ch) {
    var handled = lookupKey("'" + ch + "'", allKeyMaps(cm),
                            function(b) { return doHandleBinding(cm, b, true); });
    if (handled) {
      e_preventDefault(e);
      restartBlink(cm);
      signalLater(cm, "keyHandled", cm, "'" + ch + "'", e);
    }
    return handled;
  }

  var lastStoppedKey = null;
  function onKeyDown(e) {
    var cm = this;
    ensureFocus(cm);
    if (signalDOMEvent(cm, e)) return;
    // IE does strange things with escape.
    if (ie_upto10 && e.keyCode == 27) e.returnValue = false;
    var code = e.keyCode;
    cm.display.shift = code == 16 || e.shiftKey;
    var handled = handleKeyBinding(cm, e);
    if (presto) {
      lastStoppedKey = handled ? code : null;
      // Opera has no cut event... we try to at least catch the key combo
      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
        cm.replaceSelection("", null, "cut");
    }

    // Turn mouse into crosshair when Alt is held on Mac.
    if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
      showCrossHair(cm);
  }

  function showCrossHair(cm) {
    var lineDiv = cm.display.lineDiv;
    addClass(lineDiv, "CodeMirror-crosshair");

    function up(e) {
      if (e.keyCode == 18 || !e.altKey) {
        rmClass(lineDiv, "CodeMirror-crosshair");
        off(document, "keyup", up);
        off(document, "mouseover", up);
      }
    }
    on(document, "keyup", up);
    on(document, "mouseover", up);
  }

  function onKeyUp(e) {
    if (signalDOMEvent(this, e)) return;
    if (e.keyCode == 16) this.doc.sel.shift = false;
  }

  function onKeyPress(e) {
    var cm = this;
    if (signalDOMEvent(cm, e)) return;
    var keyCode = e.keyCode, charCode = e.charCode;
    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}
    if (((presto && (!e.which || e.which < 10)) || khtml) && handleKeyBinding(cm, e)) return;
    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
    if (handleCharBinding(cm, e, ch)) return;
    if (ie && !ie_upto8) cm.display.inputHasSelection = null;
    fastPoll(cm);
  }

  // FOCUS/BLUR EVENTS

  function onFocus(cm) {
    if (cm.options.readOnly == "nocursor") return;
    if (!cm.state.focused) {
      signal(cm, "focus", cm);
      cm.state.focused = true;
      addClass(cm.display.wrapper, "CodeMirror-focused");
      // The prevInput test prevents this from firing when a context
      // menu is closed (since the resetInput would kill the
      // select-all detection hack)
      if (!cm.curOp && cm.display.selForContextMenu == cm.doc.sel) {
        resetInput(cm);
        if (webkit) setTimeout(bind(resetInput, cm, true), 0); // Issue #1730
      }
    }
    slowPoll(cm);
    restartBlink(cm);
  }
  function onBlur(cm) {
    if (cm.state.focused) {
      signal(cm, "blur", cm);
      cm.state.focused = false;
      rmClass(cm.display.wrapper, "CodeMirror-focused");
    }
    clearInterval(cm.display.blinker);
    setTimeout(function() {if (!cm.state.focused) cm.display.shift = false;}, 150);
  }

  // CONTEXT MENU HANDLING

  var detectingSelectAll;
  // To make the context menu work, we need to briefly unhide the
  // textarea (making it as unobtrusive as possible) to let the
  // right-click take effect on it.
  function onContextMenu(cm, e) {
    if (signalDOMEvent(cm, e, "contextmenu")) return;
    var display = cm.display;
    if (eventInWidget(display, e) || contextMenuInGutter(cm, e)) return;

    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
    if (!pos || presto) return; // Opera is difficult.

    // Reset the current text selection only if the click is done outside of the selection
    // and 'resetSelectionOnContextMenu' option is true.
    var reset = cm.options.resetSelectionOnContextMenu;
    if (reset && cm.doc.sel.contains(pos) == -1)
      operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);

    var oldCSS = display.input.style.cssText;
    display.inputDiv.style.position = "absolute";
    display.input.style.cssText = "position: fixed; width: 30px; height: 30px; top: " + (e.clientY - 5) +
      "px; left: " + (e.clientX - 5) + "px; z-index: 1000; background: " +
      (ie ? "rgba(255, 255, 255, .05)" : "transparent") +
      "; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
    focusInput(cm);
    resetInput(cm);
    // Adds "Select all" to context menu in FF
    if (!cm.somethingSelected()) display.input.value = display.prevInput = " ";
    display.selForContextMenu = cm.doc.sel;

    // Select-all will be greyed out if there's nothing to select, so
    // this adds a zero-width space so that we can later check whether
    // it got selected.
    function prepareSelectAllHack() {
      if (display.input.selectionStart != null) {
        var selected = cm.somethingSelected();
        var extval = display.input.value = "\u200b" + (selected ? display.input.value : "");
        display.prevInput = selected ? "" : "\u200b";
        display.input.selectionStart = 1; display.input.selectionEnd = extval.length;
      }
    }
    function rehide() {
      display.inputDiv.style.position = "relative";
      display.input.style.cssText = oldCSS;
      if (ie_upto8) display.scrollbarV.scrollTop = display.scroller.scrollTop = scrollPos;
      slowPoll(cm);

      // Try to detect the user choosing select-all
      if (display.input.selectionStart != null) {
        if (!ie || ie_upto8) prepareSelectAllHack();
        clearTimeout(detectingSelectAll);
        var i = 0, poll = function() {
          if (display.selForContextMenu == cm.doc.sel && display.input.selectionStart == 0)
            operation(cm, commands.selectAll)(cm);
          else if (i++ < 10) detectingSelectAll = setTimeout(poll, 500);
          else resetInput(cm);
        };
        detectingSelectAll = setTimeout(poll, 200);
      }
    }

    if (ie && !ie_upto8) prepareSelectAllHack();
    if (captureRightClick) {
      e_stop(e);
      var mouseup = function() {
        off(window, "mouseup", mouseup);
        setTimeout(rehide, 20);
      };
      on(window, "mouseup", mouseup);
    } else {
      setTimeout(rehide, 50);
    }
  }

  function contextMenuInGutter(cm, e) {
    if (!hasHandler(cm, "gutterContextMenu")) return false;
    return gutterEvent(cm, e, "gutterContextMenu", false, signal);
  }

  // UPDATING

  // Compute the position of the end of a change (its 'to' property
  // refers to the pre-change end).
  var changeEnd = CodeMirror.changeEnd = function(change) {
    if (!change.text) return change.to;
    return Pos(change.from.line + change.text.length - 1,
               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
  };

  // Adjust a position to refer to the post-change position of the
  // same text, or the end of the change if the change covers it.
  function adjustForChange(pos, change) {
    if (cmp(pos, change.from) < 0) return pos;
    if (cmp(pos, change.to) <= 0) return changeEnd(change);

    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
    if (pos.line == change.to.line) ch += changeEnd(change).ch - change.to.ch;
    return Pos(line, ch);
  }

  function computeSelAfterChange(doc, change) {
    var out = [];
    for (var i = 0; i < doc.sel.ranges.length; i++) {
      var range = doc.sel.ranges[i];
      out.push(new Range(adjustForChange(range.anchor, change),
                         adjustForChange(range.head, change)));
    }
    return normalizeSelection(out, doc.sel.primIndex);
  }

  function offsetPos(pos, old, nw) {
    if (pos.line == old.line)
      return Pos(nw.line, pos.ch - old.ch + nw.ch);
    else
      return Pos(nw.line + (pos.line - old.line), pos.ch);
  }

  // Used by replaceSelections to allow moving the selection to the
  // start or around the replaced test. Hint may be "start" or "around".
  function computeReplacedSel(doc, changes, hint) {
    var out = [];
    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
    for (var i = 0; i < changes.length; i++) {
      var change = changes[i];
      var from = offsetPos(change.from, oldPrev, newPrev);
      var to = offsetPos(changeEnd(change), oldPrev, newPrev);
      oldPrev = change.to;
      newPrev = to;
      if (hint == "around") {
        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
        out[i] = new Range(inv ? to : from, inv ? from : to);
      } else {
        out[i] = new Range(from, from);
      }
    }
    return new Selection(out, doc.sel.primIndex);
  }

  // Allow "beforeChange" event handlers to influence a change
  function filterChange(doc, change, update) {
    var obj = {
      canceled: false,
      from: change.from,
      to: change.to,
      text: change.text,
      origin: change.origin,
      cancel: function() { this.canceled = true; }
    };
    if (update) obj.update = function(from, to, text, origin) {
      if (from) this.from = clipPos(doc, from);
      if (to) this.to = clipPos(doc, to);
      if (text) this.text = text;
      if (origin !== undefined) this.origin = origin;
    };
    signal(doc, "beforeChange", doc, obj);
    if (doc.cm) signal(doc.cm, "beforeChange", doc.cm, obj);

    if (obj.canceled) return null;
    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};
  }

  // Apply a change to a document, and add it to the document's
  // history, and propagating it to all linked documents.
  function makeChange(doc, change, ignoreReadOnly) {
    if (doc.cm) {
      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
      if (doc.cm.state.suppressEdits) return;
    }

    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
      change = filterChange(doc, change, true);
      if (!change) return;
    }

    // Possibly split or suppress the update based on the presence
    // of read-only spans in its range.
    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
    if (split) {
      for (var i = split.length - 1; i >= 0; --i)
        makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text});
    } else {
      makeChangeInner(doc, change);
    }
  }

  function makeChangeInner(doc, change) {
    if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) return;
    var selAfter = computeSelAfterChange(doc, change);
    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
    var rebased = [];

    linkedDocs(doc, function(doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }
      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
    });
  }

  // Revert a change stored in a document's history.
  function makeChangeFromHistory(doc, type, allowSelectionOnly) {
    if (doc.cm && doc.cm.state.suppressEdits) return;

    var hist = doc.history, event, selAfter = doc.sel;
    var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;

    // Verify that there is a useable event (so that ctrl-z won't
    // needlessly clear selection events)
    for (var i = 0; i < source.length; i++) {
      event = source[i];
      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
        break;
    }
    if (i == source.length) return;
    hist.lastOrigin = hist.lastSelOrigin = null;

    for (;;) {
      event = source.pop();
      if (event.ranges) {
        pushSelectionToHistory(event, dest);
        if (allowSelectionOnly && !event.equals(doc.sel)) {
          setSelection(doc, event, {clearRedo: false});
          return;
        }
        selAfter = event;
      }
      else break;
    }

    // Build up a reverse change object to add to the opposite history
    // stack (redo when undoing, and vice versa).
    var antiChanges = [];
    pushSelectionToHistory(selAfter, dest);
    dest.push({changes: antiChanges, generation: hist.generation});
    hist.generation = event.generation || ++hist.maxGeneration;

    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

    for (var i = event.changes.length - 1; i >= 0; --i) {
      var change = event.changes[i];
      change.origin = type;
      if (filter && !filterChange(doc, change, false)) {
        source.length = 0;
        return;
      }

      antiChanges.push(historyChangeFromChange(doc, change));

      var after = i ? computeSelAfterChange(doc, change, null) : lst(source);
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
      if (doc.cm) ensureCursorVisible(doc.cm);
      var rebased = [];

      // Propagate to the linked documents
      linkedDocs(doc, function(doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }
        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
      });
    }
  }

  // Sub-views need their line numbers shifted when text is added
  // above or below them in the parent document.
  function shiftDoc(doc, distance) {
    doc.first += distance;
    doc.sel = new Selection(map(doc.sel.ranges, function(range) {
      return new Range(Pos(range.anchor.line + distance, range.anchor.ch),
                       Pos(range.head.line + distance, range.head.ch));
    }), doc.sel.primIndex);
    if (doc.cm) regChange(doc.cm, doc.first, doc.first - distance, distance);
  }

  // More lower-level change function, handling only a single document
  // (not linked ones).
  function makeChangeSingleDoc(doc, change, selAfter, spans) {
    if (doc.cm && !doc.cm.curOp)
      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);

    if (change.to.line < doc.first) {
      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
      return;
    }
    if (change.from.line > doc.lastLine()) return;

    // Clip the change to the size of this doc
    if (change.from.line < doc.first) {
      var shift = change.text.length - 1 - (doc.first - change.from.line);
      shiftDoc(doc, shift);
      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
                text: [lst(change.text)], origin: change.origin};
    }
    var last = doc.lastLine();
    if (change.to.line > last) {
      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
                text: [change.text[0]], origin: change.origin};
    }

    change.removed = getBetween(doc, change.from, change.to);

    if (!selAfter) selAfter = computeSelAfterChange(doc, change, null);
    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans);
    else updateDoc(doc, change, spans);
    setSelectionNoUndo(doc, selAfter, sel_dontScroll);
  }

  // Handle the interaction of a change to a document with the editor
  // that this document is part of.
  function makeChangeSingleDocInEditor(cm, change, spans) {
    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;

    var recomputeMaxLength = false, checkWidthStart = from.line;
    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
      doc.iter(checkWidthStart, to.line + 1, function(line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true;
        }
      });
    }

    if (doc.sel.contains(change.from, change.to) > -1)
      signalCursorActivity(cm);

    updateDoc(doc, change, spans, estimateHeight(cm));

    if (!cm.options.lineWrapping) {
      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {
        var len = lineLength(line);
        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });
      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;
    }

    // Adjust frontier, schedule worker
    doc.frontier = Math.min(doc.frontier, from.line);
    startWorker(cm, 400);

    var lendiff = change.text.length - (to.line - from.line) - 1;
    // Remember that these lines changed, for updating the display
    if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
      regLineChange(cm, from.line, "text");
    else
      regChange(cm, from.line, to.line + 1, lendiff);

    var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
    if (changeHandler || changesHandler) {
      var obj = {
        from: from, to: to,
        text: change.text,
        removed: change.removed,
        origin: change.origin
      };
      if (changeHandler) signalLater(cm, "change", cm, obj);
      if (changesHandler) (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
    }
  }

  function replaceRange(doc, code, from, to, origin) {
    if (!to) to = from;
    if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }
    if (typeof code == "string") code = splitLines(code);
    makeChange(doc, {from: from, to: to, text: code, origin: origin});
  }

  // SCROLLING THINGS INTO VIEW

  // If an editor sits on the top or bottom of the window, partially
  // scrolled out of view, this ensures that the cursor is visible.
  function maybeScrollWindow(cm, coords) {
    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
    if (coords.top + box.top < 0) doScroll = true;
    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;
    if (doScroll != null && !phantom) {
      var scrollNode = elt("div", "\u200b", null, "position: absolute; top: " +
                           (coords.top - display.viewOffset - paddingTop(cm.display)) + "px; height: " +
                           (coords.bottom - coords.top + scrollerCutOff) + "px; left: " +
                           coords.left + "px; width: 2px;");
      cm.display.lineSpace.appendChild(scrollNode);
      scrollNode.scrollIntoView(doScroll);
      cm.display.lineSpace.removeChild(scrollNode);
    }
  }

  // Scroll a given position into view (immediately), verifying that
  // it actually became visible (as line heights are accurately
  // measured, the position of something may 'drift' during drawing).
  function scrollPosIntoView(cm, pos, end, margin) {
    if (margin == null) margin = 0;
    for (;;) {
      var changed = false, coords = cursorCoords(cm, pos);
      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),
                                         Math.min(coords.top, endCoords.top) - margin,
                                         Math.max(coords.left, endCoords.left),
                                         Math.max(coords.bottom, endCoords.bottom) + margin);
      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
      if (scrollPos.scrollTop != null) {
        setScrollTop(cm, scrollPos.scrollTop);
        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;
      }
      if (!changed) return coords;
    }
  }

  // Scroll a given set of coordinates into view (immediately).
  function scrollIntoView(cm, x1, y1, x2, y2) {
    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);
    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);
  }

  // Calculate a new scroll position needed to scroll the given
  // rectangle into view. Returns an object with scrollTop and
  // scrollLeft properties. When these are undefined, the
  // vertical/horizontal position does not need to be adjusted.
  function calculateScrollPos(cm, x1, y1, x2, y2) {
    var display = cm.display, snapMargin = textHeight(cm.display);
    if (y1 < 0) y1 = 0;
    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
    var screen = display.scroller.clientHeight - scrollerCutOff, result = {};
    var docBottom = cm.doc.height + paddingVert(display);
    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;
    if (y1 < screentop) {
      result.scrollTop = atTop ? 0 : y1;
    } else if (y2 > screentop + screen) {
      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);
      if (newTop != screentop) result.scrollTop = newTop;
    }

    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
    var screenw = display.scroller.clientWidth - scrollerCutOff;
    x1 += display.gutters.offsetWidth; x2 += display.gutters.offsetWidth;
    var gutterw = display.gutters.offsetWidth;
    var atLeft = x1 < gutterw + 10;
    if (x1 < screenleft + gutterw || atLeft) {
      if (atLeft) x1 = 0;
      result.scrollLeft = Math.max(0, x1 - 10 - gutterw);
    } else if (x2 > screenw + screenleft - 3) {
      result.scrollLeft = x2 + 10 - screenw;
    }
    return result;
  }

  // Store a relative adjustment to the scroll position in the current
  // operation (to be applied when the operation finishes).
  function addToScrollPos(cm, left, top) {
    if (left != null || top != null) resolveScrollToPos(cm);
    if (left != null)
      cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;
    if (top != null)
      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
  }

  // Make sure that at the end of the operation the current cursor is
  // shown.
  function ensureCursorVisible(cm) {
    resolveScrollToPos(cm);
    var cur = cm.getCursor(), from = cur, to = cur;
    if (!cm.options.lineWrapping) {
      from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;
      to = Pos(cur.line, cur.ch + 1);
    }
    cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true};
  }

  // When an operation has its scrollToPos property set, and another
  // scroll action is applied before the end of the operation, this
  // 'simulates' scrolling that position into view in a cheap way, so
  // that the effect of intermediate scroll commands is not ignored.
  function resolveScrollToPos(cm) {
    var range = cm.curOp.scrollToPos;
    if (range) {
      cm.curOp.scrollToPos = null;
      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);
      var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),
                                    Math.min(from.top, to.top) - range.margin,
                                    Math.max(from.right, to.right),
                                    Math.max(from.bottom, to.bottom) + range.margin);
      cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);
    }
  }

  // API UTILITIES

  // Indent the given line. The how parameter can be "smart",
  // "add"/null, "subtract", or "prev". When aggressive is false
  // (typically set to true for forced single-line indents), empty
  // lines are not indented, and places where the mode returns Pass
  // are left alone.
  function indentLine(cm, n, how, aggressive) {
    var doc = cm.doc, state;
    if (how == null) how = "add";
    if (how == "smart") {
      // Fall back to "prev" when the mode doesn't have an indentation
      // method.
      if (!cm.doc.mode.indent) how = "prev";
      else state = getStateBefore(cm, n);
    }

    var tabSize = cm.options.tabSize;
    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
    if (line.stateAfter) line.stateAfter = null;
    var curSpaceString = line.text.match(/^\s*/)[0], indentation;
    if (!aggressive && !/\S/.test(line.text)) {
      indentation = 0;
      how = "not";
    } else if (how == "smart") {
      indentation = cm.doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      if (indentation == Pass) {
        if (!aggressive) return;
        how = "prev";
      }
    }
    if (how == "prev") {
      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);
      else indentation = 0;
    } else if (how == "add") {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == "subtract") {
      indentation = curSpace - cm.options.indentUnit;
    } else if (typeof how == "number") {
      indentation = curSpace + how;
    }
    indentation = Math.max(0, indentation);

    var indentString = "", pos = 0;
    if (cm.options.indentWithTabs)
      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";}
    if (pos < indentation) indentString += spaceStr(indentation - pos);

    if (indentString != curSpaceString) {
      replaceRange(cm.doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
    } else {
      // Ensure that, if the cursor was in the whitespace at the start
      // of the line, it is moved to the end of that space.
      for (var i = 0; i < doc.sel.ranges.length; i++) {
        var range = doc.sel.ranges[i];
        if (range.head.line == n && range.head.ch < curSpaceString.length) {
          var pos = Pos(n, curSpaceString.length);
          replaceOneSelection(doc, i, new Range(pos, pos));
          break;
        }
      }
    }
    line.stateAfter = null;
  }

  // Utility for applying a change to a line by handle or number,
  // returning the number and optionally registering the line as
  // changed.
  function changeLine(cm, handle, changeType, op) {
    var no = handle, line = handle, doc = cm.doc;
    if (typeof handle == "number") line = getLine(doc, clipLine(doc, handle));
    else no = lineNo(handle);
    if (no == null) return null;
    if (op(line, no)) regLineChange(cm, no, changeType);
    return line;
  }

  // Helper for deleting text near the selection(s), used to implement
  // backspace, delete, and similar functionality.
  function deleteNearSelection(cm, compute) {
    var ranges = cm.doc.sel.ranges, kill = [];
    // Build up a set of ranges to kill first, merging overlapping
    // ranges.
    for (var i = 0; i < ranges.length; i++) {
      var toKill = compute(ranges[i]);
      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
        var replaced = kill.pop();
        if (cmp(replaced.from, toKill.from) < 0) {
          toKill.from = replaced.from;
          break;
        }
      }
      kill.push(toKill);
    }
    // Next, remove those actual ranges.
    runInOp(cm, function() {
      for (var i = kill.length - 1; i >= 0; i--)
        replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete");
      ensureCursorVisible(cm);
    });
  }

  // Used for horizontal relative motion. Dir is -1 or 1 (left or
  // right), unit can be "char", "column" (like char, but doesn't
  // cross line boundaries), "word" (across next word), or "group" (to
  // the start of next group of word or non-word-non-whitespace
  // chars). The visually param controls whether, in right-to-left
  // text, direction 1 means to move towards the next index in the
  // string, or towards the character to the right of the current
  // position. The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosH(doc, pos, dir, unit, visually) {
    var line = pos.line, ch = pos.ch, origDir = dir;
    var lineObj = getLine(doc, line);
    var possible = true;
    function findNextLine() {
      var l = line + dir;
      if (l < doc.first || l >= doc.first + doc.size) return (possible = false);
      line = l;
      return lineObj = getLine(doc, l);
    }
    function moveOnce(boundToLine) {
      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);
      if (next == null) {
        if (!boundToLine && findNextLine()) {
          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);
          else ch = dir < 0 ? lineObj.text.length : 0;
        } else return (possible = false);
      } else ch = next;
      return true;
    }

    if (unit == "char") moveOnce();
    else if (unit == "column") moveOnce(true);
    else if (unit == "word" || unit == "group") {
      var sawType = null, group = unit == "group";
      for (var first = true;; first = false) {
        if (dir < 0 && !moveOnce(!first)) break;
        var cur = lineObj.text.charAt(ch) || "\n";
        var type = isWordChar(cur) ? "w"
          : group && cur == "\n" ? "n"
          : !group || /\s/.test(cur) ? null
          : "p";
        if (group && !first && !type) type = "s";
        if (sawType && sawType != type) {
          if (dir < 0) {dir = 1; moveOnce();}
          break;
        }

        if (type) sawType = type;
        if (dir > 0 && !moveOnce(!first)) break;
      }
    }
    var result = skipAtomic(doc, Pos(line, ch), origDir, true);
    if (!possible) result.hitSide = true;
    return result;
  }

  // For relative vertical movement. Dir may be -1 or 1. Unit can be
  // "page" or "line". The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosV(cm, pos, dir, unit) {
    var doc = cm.doc, x = pos.left, y;
    if (unit == "page") {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));
    } else if (unit == "line") {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }
    for (;;) {
      var target = coordsChar(cm, x, y);
      if (!target.outside) break;
      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }
      y += dir * 5;
    }
    return target;
  }

  // Find the word at the given position (as returned by coordsChar).
  function findWordAt(doc, pos) {
    var line = getLine(doc, pos.line).text;
    var start = pos.ch, end = pos.ch;
    if (line) {
      if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;
      var startChar = line.charAt(start);
      var check = isWordChar(startChar) ? isWordChar
        : /\s/.test(startChar) ? function(ch) {return /\s/.test(ch);}
        : function(ch) {return !/\s/.test(ch) && !isWordChar(ch);};
      while (start > 0 && check(line.charAt(start - 1))) --start;
      while (end < line.length && check(line.charAt(end))) ++end;
    }
    return new Range(Pos(pos.line, start), Pos(pos.line, end));
  }

  // EDITOR METHODS

  // The publicly visible API. Note that methodOp(f) means
  // 'wrap f in an operation, performed on its `this` parameter'.

  // This is not the complete set of editor methods. Most of the
  // methods defined on the Doc type are also injected into
  // CodeMirror.prototype, for backwards compatibility and
  // convenience.

  CodeMirror.prototype = {
    constructor: CodeMirror,
    focus: function(){window.focus(); focusInput(this); fastPoll(this);},

    setOption: function(option, value) {
      var options = this.options, old = options[option];
      if (options[option] == value && option != "mode") return;
      options[option] = value;
      if (optionHandlers.hasOwnProperty(option))
        operation(this, optionHandlers[option])(this, value, old);
    },

    getOption: function(option) {return this.options[option];},
    getDoc: function() {return this.doc;},

    addKeyMap: function(map, bottom) {
      this.state.keyMaps[bottom ? "push" : "unshift"](map);
    },
    removeKeyMap: function(map) {
      var maps = this.state.keyMaps;
      for (var i = 0; i < maps.length; ++i)
        if (maps[i] == map || (typeof maps[i] != "string" && maps[i].name == map)) {
          maps.splice(i, 1);
          return true;
        }
    },

    addOverlay: methodOp(function(spec, options) {
      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
      if (mode.startState) throw new Error("Overlays may not be stateful.");
      this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque});
      this.state.modeGen++;
      regChange(this);
    }),
    removeOverlay: methodOp(function(spec) {
      var overlays = this.state.overlays;
      for (var i = 0; i < overlays.length; ++i) {
        var cur = overlays[i].modeSpec;
        if (cur == spec || typeof spec == "string" && cur.name == spec) {
          overlays.splice(i, 1);
          this.state.modeGen++;
          regChange(this);
          return;
        }
      }
    }),

    indentLine: methodOp(function(n, dir, aggressive) {
      if (typeof dir != "string" && typeof dir != "number") {
        if (dir == null) dir = this.options.smartIndent ? "smart" : "prev";
        else dir = dir ? "add" : "subtract";
      }
      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);
    }),
    indentSelection: methodOp(function(how) {
      var ranges = this.doc.sel.ranges, end = -1;
      for (var i = 0; i < ranges.length; i++) {
        var range = ranges[i];
        if (!range.empty()) {
          var start = Math.max(end, range.from().line);
          var to = range.to();
          end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
          for (var j = start; j < end; ++j)
            indentLine(this, j, how);
        } else if (range.head.line > end) {
          indentLine(this, range.head.line, how, true);
          end = range.head.line;
          if (i == this.doc.sel.primIndex) ensureCursorVisible(this);
        }
      }
    }),

    // Fetch the parser token for a given character. Useful for hacks
    // that want to inspect the mode state (say, for completion).
    getTokenAt: function(pos, precise) {
      var doc = this.doc;
      pos = clipPos(doc, pos);
      var state = getStateBefore(this, pos.line, precise), mode = this.doc.mode;
      var line = getLine(doc, pos.line);
      var stream = new StringStream(line.text, this.options.tabSize);
      while (stream.pos < pos.ch && !stream.eol()) {
        stream.start = stream.pos;
        var style = readToken(mode, stream, state);
      }
      return {start: stream.start,
              end: stream.pos,
              string: stream.current(),
              type: style || null,
              state: state};
    },

    getTokenTypeAt: function(pos) {
      pos = clipPos(this.doc, pos);
      var styles = getLineStyles(this, getLine(this.doc, pos.line));
      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
      var type;
      if (ch == 0) type = styles[2];
      else for (;;) {
        var mid = (before + after) >> 1;
        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;
        else if (styles[mid * 2 + 1] < ch) before = mid + 1;
        else { type = styles[mid * 2 + 2]; break; }
      }
      var cut = type ? type.indexOf("cm-overlay ") : -1;
      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
    },

    getModeAt: function(pos) {
      var mode = this.doc.mode;
      if (!mode.innerMode) return mode;
      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
    },

    getHelper: function(pos, type) {
      return this.getHelpers(pos, type)[0];
    },

    getHelpers: function(pos, type) {
      var found = [];
      if (!helpers.hasOwnProperty(type)) return helpers;
      var help = helpers[type], mode = this.getModeAt(pos);
      if (typeof mode[type] == "string") {
        if (help[mode[type]]) found.push(help[mode[type]]);
      } else if (mode[type]) {
        for (var i = 0; i < mode[type].length; i++) {
          var val = help[mode[type][i]];
          if (val) found.push(val);
        }
      } else if (mode.helperType && help[mode.helperType]) {
        found.push(help[mode.helperType]);
      } else if (help[mode.name]) {
        found.push(help[mode.name]);
      }
      for (var i = 0; i < help._global.length; i++) {
        var cur = help._global[i];
        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)
          found.push(cur.val);
      }
      return found;
    },

    getStateAfter: function(line, precise) {
      var doc = this.doc;
      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
      return getStateBefore(this, line + 1, precise);
    },

    cursorCoords: function(start, mode) {
      var pos, range = this.doc.sel.primary();
      if (start == null) pos = range.head;
      else if (typeof start == "object") pos = clipPos(this.doc, start);
      else pos = start ? range.from() : range.to();
      return cursorCoords(this, pos, mode || "page");
    },

    charCoords: function(pos, mode) {
      return charCoords(this, clipPos(this.doc, pos), mode || "page");
    },

    coordsChar: function(coords, mode) {
      coords = fromCoordSystem(this, coords, mode || "page");
      return coordsChar(this, coords.left, coords.top);
    },

    lineAtHeight: function(height, mode) {
      height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
      return lineAtHeight(this.doc, height + this.display.viewOffset);
    },
    heightAtLine: function(line, mode) {
      var end = false, last = this.doc.first + this.doc.size - 1;
      if (line < this.doc.first) line = this.doc.first;
      else if (line > last) { line = last; end = true; }
      var lineObj = getLine(this.doc, line);
      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page").top +
        (end ? this.doc.height - heightAtLine(lineObj) : 0);
    },

    defaultTextHeight: function() { return textHeight(this.display); },
    defaultCharWidth: function() { return charWidth(this.display); },

    setGutterMarker: methodOp(function(line, gutterID, value) {
      return changeLine(this, line, "gutter", function(line) {
        var markers = line.gutterMarkers || (line.gutterMarkers = {});
        markers[gutterID] = value;
        if (!value && isEmpty(markers)) line.gutterMarkers = null;
        return true;
      });
    }),

    clearGutter: methodOp(function(gutterID) {
      var cm = this, doc = cm.doc, i = doc.first;
      doc.iter(function(line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          line.gutterMarkers[gutterID] = null;
          regLineChange(cm, i, "gutter");
          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;
        }
        ++i;
      });
    }),

    addLineClass: methodOp(function(handle, where, cls) {
      return changeLine(this, handle, "class", function(line) {
        var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : "wrapClass";
        if (!line[prop]) line[prop] = cls;
        else if (new RegExp("(?:^|\\s)" + cls + "(?:$|\\s)").test(line[prop])) return false;
        else line[prop] += " " + cls;
        return true;
      });
    }),

    removeLineClass: methodOp(function(handle, where, cls) {
      return changeLine(this, handle, "class", function(line) {
        var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : "wrapClass";
        var cur = line[prop];
        if (!cur) return false;
        else if (cls == null) line[prop] = null;
        else {
          var found = cur.match(new RegExp("(?:^|\\s+)" + cls + "(?:$|\\s+)"));
          if (!found) return false;
          var end = found.index + found[0].length;
          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
        }
        return true;
      });
    }),

    addLineWidget: methodOp(function(handle, node, options) {
      return addLineWidget(this, handle, node, options);
    }),

    removeLineWidget: function(widget) { widget.clear(); },

    lineInfo: function(line) {
      if (typeof line == "number") {
        if (!isLine(this.doc, line)) return null;
        var n = line;
        line = getLine(this.doc, line);
        if (!line) return null;
      } else {
        var n = lineNo(line);
        if (n == null) return null;
      }
      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
              widgets: line.widgets};
    },

    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo};},

    addWidget: function(pos, node, scroll, vert, horiz) {
      var display = this.display;
      pos = cursorCoords(this, clipPos(this.doc, pos));
      var top = pos.bottom, left = pos.left;
      node.style.position = "absolute";
      display.sizer.appendChild(node);
      if (vert == "over") {
        top = pos.top;
      } else if (vert == "above" || vert == "near") {
        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
        // Default to positioning above (if specified and possible); otherwise default to positioning below
        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
          top = pos.top - node.offsetHeight;
        else if (pos.bottom + node.offsetHeight <= vspace)
          top = pos.bottom;
        if (left + node.offsetWidth > hspace)
          left = hspace - node.offsetWidth;
      }
      node.style.top = top + "px";
      node.style.left = node.style.right = "";
      if (horiz == "right") {
        left = display.sizer.clientWidth - node.offsetWidth;
        node.style.right = "0px";
      } else {
        if (horiz == "left") left = 0;
        else if (horiz == "middle") left = (display.sizer.clientWidth - node.offsetWidth) / 2;
        node.style.left = left + "px";
      }
      if (scroll)
        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);
    },

    triggerOnKeyDown: methodOp(onKeyDown),
    triggerOnKeyPress: methodOp(onKeyPress),
    triggerOnKeyUp: methodOp(onKeyUp),

    execCommand: function(cmd) {
      if (commands.hasOwnProperty(cmd))
        return commands[cmd](this);
    },

    findPosH: function(from, amount, unit, visually) {
      var dir = 1;
      if (amount < 0) { dir = -1; amount = -amount; }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        cur = findPosH(this.doc, cur, dir, unit, visually);
        if (cur.hitSide) break;
      }
      return cur;
    },

    moveH: methodOp(function(dir, unit) {
      var cm = this;
      cm.extendSelectionsBy(function(range) {
        if (cm.display.shift || cm.doc.extend || range.empty())
          return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);
        else
          return dir < 0 ? range.from() : range.to();
      }, sel_move);
    }),

    deleteH: methodOp(function(dir, unit) {
      var sel = this.doc.sel, doc = this.doc;
      if (sel.somethingSelected())
        doc.replaceSelection("", null, "+delete");
      else
        deleteNearSelection(this, function(range) {
          var other = findPosH(doc, range.head, dir, unit, false);
          return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other};
        });
    }),

    findPosV: function(from, amount, unit, goalColumn) {
      var dir = 1, x = goalColumn;
      if (amount < 0) { dir = -1; amount = -amount; }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        var coords = cursorCoords(this, cur, "div");
        if (x == null) x = coords.left;
        else coords.left = x;
        cur = findPosV(this, coords, dir, unit);
        if (cur.hitSide) break;
      }
      return cur;
    },

    moveV: methodOp(function(dir, unit) {
      var cm = this, doc = this.doc, goals = [];
      var collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();
      doc.extendSelectionsBy(function(range) {
        if (collapse)
          return dir < 0 ? range.from() : range.to();
        var headPos = cursorCoords(cm, range.head, "div");
        if (range.goalColumn != null) headPos.left = range.goalColumn;
        goals.push(headPos.left);
        var pos = findPosV(cm, headPos, dir, unit);
        if (unit == "page" && range == doc.sel.primary())
          addToScrollPos(cm, null, charCoords(cm, pos, "div").top - headPos.top);
        return pos;
      }, sel_move);
      if (goals.length) for (var i = 0; i < doc.sel.ranges.length; i++)
        doc.sel.ranges[i].goalColumn = goals[i];
    }),

    toggleOverwrite: function(value) {
      if (value != null && value == this.state.overwrite) return;
      if (this.state.overwrite = !this.state.overwrite)
        addClass(this.display.cursorDiv, "CodeMirror-overwrite");
      else
        rmClass(this.display.cursorDiv, "CodeMirror-overwrite");

      signal(this, "overwriteToggle", this, this.state.overwrite);
    },
    hasFocus: function() { return activeElt() == this.display.input; },

    scrollTo: methodOp(function(x, y) {
      if (x != null || y != null) resolveScrollToPos(this);
      if (x != null) this.curOp.scrollLeft = x;
      if (y != null) this.curOp.scrollTop = y;
    }),
    getScrollInfo: function() {
      var scroller = this.display.scroller, co = scrollerCutOff;
      return {left: scroller.scrollLeft, top: scroller.scrollTop,
              height: scroller.scrollHeight - co, width: scroller.scrollWidth - co,
              clientHeight: scroller.clientHeight - co, clientWidth: scroller.clientWidth - co};
    },

    scrollIntoView: methodOp(function(range, margin) {
      if (range == null) {
        range = {from: this.doc.sel.primary().head, to: null};
        if (margin == null) margin = this.options.cursorScrollMargin;
      } else if (typeof range == "number") {
        range = {from: Pos(range, 0), to: null};
      } else if (range.from == null) {
        range = {from: range, to: null};
      }
      if (!range.to) range.to = range.from;
      range.margin = margin || 0;

      if (range.from.line != null) {
        resolveScrollToPos(this);
        this.curOp.scrollToPos = range;
      } else {
        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),
                                      Math.min(range.from.top, range.to.top) - range.margin,
                                      Math.max(range.from.right, range.to.right),
                                      Math.max(range.from.bottom, range.to.bottom) + range.margin);
        this.scrollTo(sPos.scrollLeft, sPos.scrollTop);
      }
    }),

    setSize: methodOp(function(width, height) {
      function interpret(val) {
        return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
      }
      if (width != null) this.display.wrapper.style.width = interpret(width);
      if (height != null) this.display.wrapper.style.height = interpret(height);
      if (this.options.lineWrapping) clearLineMeasurementCache(this);
      this.curOp.forceUpdate = true;
      signal(this, "refresh", this);
    }),

    operation: function(f){return runInOp(this, f);},

    refresh: methodOp(function() {
      var oldHeight = this.display.cachedTextHeight;
      regChange(this);
      this.curOp.forceUpdate = true;
      clearCaches(this);
      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);
      updateGutterSpace(this);
      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)
        estimateLineHeights(this);
      signal(this, "refresh", this);
    }),

    swapDoc: methodOp(function(doc) {
      var old = this.doc;
      old.cm = null;
      attachDoc(this, doc);
      clearCaches(this);
      resetInput(this);
      this.scrollTo(doc.scrollLeft, doc.scrollTop);
      signalLater(this, "swapDoc", this, old);
      return old;
    }),

    getInputField: function(){return this.display.input;},
    getWrapperElement: function(){return this.display.wrapper;},
    getScrollerElement: function(){return this.display.scroller;},
    getGutterElement: function(){return this.display.gutters;}
  };
  eventMixin(CodeMirror);

  // OPTION DEFAULTS

  // The default configuration options.
  var defaults = CodeMirror.defaults = {};
  // Functions to run when options are changed.
  var optionHandlers = CodeMirror.optionHandlers = {};

  function option(name, deflt, handle, notOnInit) {
    CodeMirror.defaults[name] = deflt;
    if (handle) optionHandlers[name] =
      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;
  }

  // Passed to option handlers when there is no old value.
  var Init = CodeMirror.Init = {toString: function(){return "CodeMirror.Init";}};

  // These two are, on init, called from the constructor because they
  // have to be initialized before the editor can start at all.
  option("value", "", function(cm, val) {
    cm.setValue(val);
  }, true);
  option("mode", null, function(cm, val) {
    cm.doc.modeOption = val;
    loadMode(cm);
  }, true);

  option("indentUnit", 2, loadMode, true);
  option("indentWithTabs", false);
  option("smartIndent", true);
  option("tabSize", 4, function(cm) {
    resetModeState(cm);
    clearCaches(cm);
    regChange(cm);
  }, true);
  option("specialChars", /[\t\u0000-\u0019\u00ad\u200b\u2028\u2029\ufeff]/g, function(cm, val) {
    cm.options.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
    cm.refresh();
  }, true);
  option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);
  option("electricChars", true);
  option("rtlMoveVisually", !windows);
  option("wholeLineUpdateBefore", true);

  option("theme", "default", function(cm) {
    themeChanged(cm);
    guttersChanged(cm);
  }, true);
  option("keyMap", "default", keyMapChanged);
  option("extraKeys", null);

  option("lineWrapping", false, wrappingChanged, true);
  option("gutters", [], function(cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option("fixedGutter", true, function(cm, val) {
    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
    cm.refresh();
  }, true);
  option("coverGutterNextToScrollbar", false, updateScrollbars, true);
  option("lineNumbers", false, function(cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option("firstLineNumber", 1, guttersChanged, true);
  option("lineNumberFormatter", function(integer) {return integer;}, guttersChanged, true);
  option("showCursorWhenSelecting", false, updateSelection, true);

  option("resetSelectionOnContextMenu", true);

  option("readOnly", false, function(cm, val) {
    if (val == "nocursor") {
      onBlur(cm);
      cm.display.input.blur();
      cm.display.disabled = true;
    } else {
      cm.display.disabled = false;
      if (!val) resetInput(cm);
    }
  });
  option("disableInput", false, function(cm, val) {if (!val) resetInput(cm);}, true);
  option("dragDrop", true);

  option("cursorBlinkRate", 530);
  option("cursorScrollMargin", 0);
  option("cursorHeight", 1);
  option("workTime", 100);
  option("workDelay", 100);
  option("flattenSpans", true, resetModeState, true);
  option("addModeClass", false, resetModeState, true);
  option("pollInterval", 100);
  option("undoDepth", 200, function(cm, val){cm.doc.history.undoDepth = val;});
  option("historyEventDelay", 1250);
  option("viewportMargin", 10, function(cm){cm.refresh();}, true);
  option("maxHighlightLength", 10000, resetModeState, true);
  option("moveInputWithCursor", true, function(cm, val) {
    if (!val) cm.display.inputDiv.style.top = cm.display.inputDiv.style.left = 0;
  });

  option("tabindex", null, function(cm, val) {
    cm.display.input.tabIndex = val || "";
  });
  option("autofocus", null);

  // MODE DEFINITION AND QUERYING

  // Known modes, by name and by MIME
  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  CodeMirror.defineMode = function(name, mode) {
    if (!CodeMirror.defaults.mode && name != "null") CodeMirror.defaults.mode = name;
    if (arguments.length > 2) {
      mode.dependencies = [];
      for (var i = 2; i < arguments.length; ++i) mode.dependencies.push(arguments[i]);
    }
    modes[name] = mode;
  };

  CodeMirror.defineMIME = function(mime, spec) {
    mimeModes[mime] = spec;
  };

  // Given a MIME type, a {name, ...options} config object, or a name
  // string, return a mode config object.
  CodeMirror.resolveMode = function(spec) {
    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
      spec = mimeModes[spec];
    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
      var found = mimeModes[spec.name];
      if (typeof found == "string") found = {name: found};
      spec = createObj(found, spec);
      spec.name = found.name;
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
      return CodeMirror.resolveMode("application/xml");
    }
    if (typeof spec == "string") return {name: spec};
    else return spec || {name: "null"};
  };

  // Given a mode spec (anything that resolveMode accepts), find and
  // initialize an actual mode object.
  CodeMirror.getMode = function(options, spec) {
    var spec = CodeMirror.resolveMode(spec);
    var mfactory = modes[spec.name];
    if (!mfactory) return CodeMirror.getMode(options, "text/plain");
    var modeObj = mfactory(options, spec);
    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];
      for (var prop in exts) {
        if (!exts.hasOwnProperty(prop)) continue;
        if (modeObj.hasOwnProperty(prop)) modeObj["_" + prop] = modeObj[prop];
        modeObj[prop] = exts[prop];
      }
    }
    modeObj.name = spec.name;
    if (spec.helperType) modeObj.helperType = spec.helperType;
    if (spec.modeProps) for (var prop in spec.modeProps)
      modeObj[prop] = spec.modeProps[prop];

    return modeObj;
  };

  // Minimal default mode.
  CodeMirror.defineMode("null", function() {
    return {token: function(stream) {stream.skipToEnd();}};
  });
  CodeMirror.defineMIME("text/plain", "null");

  // This can be used to attach properties to mode objects from
  // outside the actual mode definition.
  var modeExtensions = CodeMirror.modeExtensions = {};
  CodeMirror.extendMode = function(mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
    copyObj(properties, exts);
  };

  // EXTENSIONS

  CodeMirror.defineExtension = function(name, func) {
    CodeMirror.prototype[name] = func;
  };
  CodeMirror.defineDocExtension = function(name, func) {
    Doc.prototype[name] = func;
  };
  CodeMirror.defineOption = option;

  var initHooks = [];
  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};

  var helpers = CodeMirror.helpers = {};
  CodeMirror.registerHelper = function(type, name, value) {
    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};
    helpers[type][name] = value;
  };
  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
    CodeMirror.registerHelper(type, name, value);
    helpers[type]._global.push({pred: predicate, val: value});
  };

  // MODE STATE HANDLING

  // Utility functions for working with state. Exported because nested
  // modes need to do this for their inner modes.

  var copyState = CodeMirror.copyState = function(mode, state) {
    if (state === true) return state;
    if (mode.copyState) return mode.copyState(state);
    var nstate = {};
    for (var n in state) {
      var val = state[n];
      if (val instanceof Array) val = val.concat([]);
      nstate[n] = val;
    }
    return nstate;
  };

  var startState = CodeMirror.startState = function(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true;
  };

  // Given a mode and a state (for that mode), find the inner mode and
  // state at the position that the state refers to.
  CodeMirror.innerMode = function(mode, state) {
    while (mode.innerMode) {
      var info = mode.innerMode(state);
      if (!info || info.mode == mode) break;
      state = info.state;
      mode = info.mode;
    }
    return info || {mode: mode, state: state};
  };

  // STANDARD COMMANDS

  // Commands are parameter-less actions that can be performed on an
  // editor, mostly used for keybindings.
  var commands = CodeMirror.commands = {
    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);},
    singleSelection: function(cm) {
      cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
    },
    killLine: function(cm) {
      deleteNearSelection(cm, function(range) {
        if (range.empty()) {
          var len = getLine(cm.doc, range.head.line).text.length;
          if (range.head.ch == len && range.head.line < cm.lastLine())
            return {from: range.head, to: Pos(range.head.line + 1, 0)};
          else
            return {from: range.head, to: Pos(range.head.line, len)};
        } else {
          return {from: range.from(), to: range.to()};
        }
      });
    },
    deleteLine: function(cm) {
      deleteNearSelection(cm, function(range) {
        return {from: Pos(range.from().line, 0),
                to: clipPos(cm.doc, Pos(range.to().line + 1, 0))};
      });
    },
    delLineLeft: function(cm) {
      deleteNearSelection(cm, function(range) {
        return {from: Pos(range.from().line, 0), to: range.from()};
      });
    },
    undo: function(cm) {cm.undo();},
    redo: function(cm) {cm.redo();},
    undoSelection: function(cm) {cm.undoSelection();},
    redoSelection: function(cm) {cm.redoSelection();},
    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},
    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},
    goLineStart: function(cm) {
      cm.extendSelectionsBy(function(range) { return lineStart(cm, range.head.line); }, sel_move);
    },
    goLineStartSmart: function(cm) {
      cm.extendSelectionsBy(function(range) {
        var start = lineStart(cm, range.head.line);
        var line = cm.getLineHandle(start.line);
        var order = getOrder(line);
        if (!order || order[0].level == 0) {
          var firstNonWS = Math.max(0, line.text.search(/\S/));
          var inWS = range.head.line == start.line && range.head.ch <= firstNonWS && range.head.ch;
          return Pos(start.line, inWS ? 0 : firstNonWS);
        }
        return start;
      }, sel_move);
    },
    goLineEnd: function(cm) {
      cm.extendSelectionsBy(function(range) { return lineEnd(cm, range.head.line); }, sel_move);
    },
    goLineRight: function(cm) {
      cm.extendSelectionsBy(function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
      }, sel_move);
    },
    goLineLeft: function(cm) {
      cm.extendSelectionsBy(function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        return cm.coordsChar({left: 0, top: top}, "div");
      }, sel_move);
    },
    goLineUp: function(cm) {cm.moveV(-1, "line");},
    goLineDown: function(cm) {cm.moveV(1, "line");},
    goPageUp: function(cm) {cm.moveV(-1, "page");},
    goPageDown: function(cm) {cm.moveV(1, "page");},
    goCharLeft: function(cm) {cm.moveH(-1, "char");},
    goCharRight: function(cm) {cm.moveH(1, "char");},
    goColumnLeft: function(cm) {cm.moveH(-1, "column");},
    goColumnRight: function(cm) {cm.moveH(1, "column");},
    goWordLeft: function(cm) {cm.moveH(-1, "word");},
    goGroupRight: function(cm) {cm.moveH(1, "group");},
    goGroupLeft: function(cm) {cm.moveH(-1, "group");},
    goWordRight: function(cm) {cm.moveH(1, "word");},
    delCharBefore: function(cm) {cm.deleteH(-1, "char");},
    delCharAfter: function(cm) {cm.deleteH(1, "char");},
    delWordBefore: function(cm) {cm.deleteH(-1, "word");},
    delWordAfter: function(cm) {cm.deleteH(1, "word");},
    delGroupBefore: function(cm) {cm.deleteH(-1, "group");},
    delGroupAfter: function(cm) {cm.deleteH(1, "group");},
    indentAuto: function(cm) {cm.indentSelection("smart");},
    indentMore: function(cm) {cm.indentSelection("add");},
    indentLess: function(cm) {cm.indentSelection("subtract");},
    insertTab: function(cm) {cm.replaceSelection("\t");},
    insertSoftTab: function(cm) {
      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
      for (var i = 0; i < ranges.length; i++) {
        var pos = ranges[i].from();
        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
        spaces.push(new Array(tabSize - col % tabSize + 1).join(" "));
      }
      cm.replaceSelections(spaces);
    },
    defaultTab: function(cm) {
      if (cm.somethingSelected()) cm.indentSelection("add");
      else cm.execCommand("insertTab");
    },
    transposeChars: function(cm) {
      runInOp(cm, function() {
        var ranges = cm.listSelections();
        for (var i = 0; i < ranges.length; i++) {
          var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
          if (cur.ch > 0 && cur.ch < line.length - 1)
            cm.replaceRange(line.charAt(cur.ch) + line.charAt(cur.ch - 1),
                            Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1));
        }
      });
    },
    newlineAndIndent: function(cm) {
      runInOp(cm, function() {
        var len = cm.listSelections().length;
        for (var i = 0; i < len; i++) {
          var range = cm.listSelections()[i];
          cm.replaceRange("\n", range.anchor, range.head, "+input");
          cm.indentLine(range.from().line + 1, null, true);
          ensureCursorVisible(cm);
        }
      });
    },
    toggleOverwrite: function(cm) {cm.toggleOverwrite();}
  };

  // STANDARD KEYMAPS

  var keyMap = CodeMirror.keyMap = {};
  keyMap.basic = {
    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
    "Tab": "defaultTab", "Shift-Tab": "indentAuto",
    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
    "Esc": "singleSelection"
  };
  // Note that the save and find-related commands aren't defined by
  // default. User code or addons can define them. Unknown commands
  // are simply ignored.
  keyMap.pcDefault = {
    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
    "Ctrl-Home": "goDocStart", "Ctrl-Up": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Down": "goDocEnd",
    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
    "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
    fallthrough: "basic"
  };
  keyMap.macDefault = {
    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
    "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineStart", "Cmd-Right": "goLineEnd", "Alt-Backspace": "delGroupBefore",
    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delLineLeft",
    "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection",
    fallthrough: ["basic", "emacsy"]
  };
  // Very basic readline/emacs-style bindings, which are standard on Mac.
  keyMap.emacsy = {
    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
    "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
    "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
    "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars"
  };
  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;

  // KEYMAP DISPATCH

  function getKeyMap(val) {
    if (typeof val == "string") return keyMap[val];
    else return val;
  }

  // Given an array of keymaps and a key name, call handle on any
  // bindings found, until that returns a truthy value, at which point
  // we consider the key handled. Implements things like binding a key
  // to false stopping further handling and keymap fallthrough.
  var lookupKey = CodeMirror.lookupKey = function(name, maps, handle) {
    function lookup(map) {
      map = getKeyMap(map);
      var found = map[name];
      if (found === false) return "stop";
      if (found != null && handle(found)) return true;
      if (map.nofallthrough) return "stop";

      var fallthrough = map.fallthrough;
      if (fallthrough == null) return false;
      if (Object.prototype.toString.call(fallthrough) != "[object Array]")
        return lookup(fallthrough);
      for (var i = 0; i < fallthrough.length; ++i) {
        var done = lookup(fallthrough[i]);
        if (done) return done;
      }
      return false;
    }

    for (var i = 0; i < maps.length; ++i) {
      var done = lookup(maps[i]);
      if (done) return done != "stop";
    }
  };

  // Modifier key presses don't count as 'real' key presses for the
  // purpose of keymap fallthrough.
  var isModifierKey = CodeMirror.isModifierKey = function(event) {
    var name = keyNames[event.keyCode];
    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
  };

  // Look up the name of a key as indicated by an event object.
  var keyName = CodeMirror.keyName = function(event, noShift) {
    if (presto && event.keyCode == 34 && event["char"]) return false;
    var name = keyNames[event.keyCode];
    if (name == null || event.altGraphKey) return false;
    if (event.altKey) name = "Alt-" + name;
    if (flipCtrlCmd ? event.metaKey : event.ctrlKey) name = "Ctrl-" + name;
    if (flipCtrlCmd ? event.ctrlKey : event.metaKey) name = "Cmd-" + name;
    if (!noShift && event.shiftKey) name = "Shift-" + name;
    return name;
  };

  // FROMTEXTAREA

  CodeMirror.fromTextArea = function(textarea, options) {
    if (!options) options = {};
    options.value = textarea.value;
    if (!options.tabindex && textarea.tabindex)
      options.tabindex = textarea.tabindex;
    if (!options.placeholder && textarea.placeholder)
      options.placeholder = textarea.placeholder;
    // Set autofocus to true if this textarea is focused, or if it has
    // autofocus and no other element is focused.
    if (options.autofocus == null) {
      var hasFocus = activeElt();
      options.autofocus = hasFocus == textarea ||
        textarea.getAttribute("autofocus") != null && hasFocus == document.body;
    }

    function save() {textarea.value = cm.getValue();}
    if (textarea.form) {
      on(textarea.form, "submit", save);
      // Deplorable hack to make the submit method do the right thing.
      if (!options.leaveSubmitMethodAlone) {
        var form = textarea.form, realSubmit = form.submit;
        try {
          var wrappedSubmit = form.submit = function() {
            save();
            form.submit = realSubmit;
            form.submit();
            form.submit = wrappedSubmit;
          };
        } catch(e) {}
      }
    }

    textarea.style.display = "none";
    var cm = CodeMirror(function(node) {
      textarea.parentNode.insertBefore(node, textarea.nextSibling);
    }, options);
    cm.save = save;
    cm.getTextArea = function() { return textarea; };
    cm.toTextArea = function() {
      save();
      textarea.parentNode.removeChild(cm.getWrapperElement());
      textarea.style.display = "";
      if (textarea.form) {
        off(textarea.form, "submit", save);
        if (typeof textarea.form.submit == "function")
          textarea.form.submit = realSubmit;
      }
    };
    return cm;
  };

  // STRING STREAM

  // Fed to the mode parsers, provides helper functions to make
  // parsers more succinct.

  var StringStream = CodeMirror.StringStream = function(string, tabSize) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
    this.lineStart = 0;
  };

  StringStream.prototype = {
    eol: function() {return this.pos >= this.string.length;},
    sol: function() {return this.pos == this.lineStart;},
    peek: function() {return this.string.charAt(this.pos) || undefined;},
    next: function() {
      if (this.pos < this.string.length)
        return this.string.charAt(this.pos++);
    },
    eat: function(match) {
      var ch = this.string.charAt(this.pos);
      if (typeof match == "string") var ok = ch == match;
      else var ok = ch && (match.test ? match.test(ch) : match(ch));
      if (ok) {++this.pos; return ch;}
    },
    eatWhile: function(match) {
      var start = this.pos;
      while (this.eat(match)){}
      return this.pos > start;
    },
    eatSpace: function() {
      var start = this.pos;
      while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;
      return this.pos > start;
    },
    skipToEnd: function() {this.pos = this.string.length;},
    skipTo: function(ch) {
      var found = this.string.indexOf(ch, this.pos);
      if (found > -1) {this.pos = found; return true;}
    },
    backUp: function(n) {this.pos -= n;},
    column: function() {
      if (this.lastColumnPos < this.start) {
        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
        this.lastColumnPos = this.start;
      }
      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    },
    indentation: function() {
      return countColumn(this.string, null, this.tabSize) -
        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    },
    match: function(pattern, consume, caseInsensitive) {
      if (typeof pattern == "string") {
        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};
        var substr = this.string.substr(this.pos, pattern.length);
        if (cased(substr) == cased(pattern)) {
          if (consume !== false) this.pos += pattern.length;
          return true;
        }
      } else {
        var match = this.string.slice(this.pos).match(pattern);
        if (match && match.index > 0) return null;
        if (match && consume !== false) this.pos += match[0].length;
        return match;
      }
    },
    current: function(){return this.string.slice(this.start, this.pos);},
    hideFirstChars: function(n, inner) {
      this.lineStart += n;
      try { return inner(); }
      finally { this.lineStart -= n; }
    }
  };

  // TEXTMARKERS

  // Created with markText and setBookmark methods. A TextMarker is a
  // handle that can be used to clear or find a marked position in the
  // document. Line objects hold arrays (markedSpans) containing
  // {from, to, marker} object pointing to such marker objects, and
  // indicating that such a marker is present on that line. Multiple
  // lines may point to the same marker when it spans across lines.
  // The spans will have null for their from/to properties when the
  // marker continues beyond the start/end of the line. Markers have
  // links back to the lines they currently touch.

  var TextMarker = CodeMirror.TextMarker = function(doc, type) {
    this.lines = [];
    this.type = type;
    this.doc = doc;
  };
  eventMixin(TextMarker);

  // Clear the marker.
  TextMarker.prototype.clear = function() {
    if (this.explicitlyCleared) return;
    var cm = this.doc.cm, withOp = cm && !cm.curOp;
    if (withOp) startOperation(cm);
    if (hasHandler(this, "clear")) {
      var found = this.find();
      if (found) signalLater(this, "clear", found.from, found.to);
    }
    var min = null, max = null;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (cm && !this.collapsed) regLineChange(cm, lineNo(line), "text");
      else if (cm) {
        if (span.to != null) max = lineNo(line);
        if (span.from != null) min = lineNo(line);
      }
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)
        updateLineHeight(line, textHeight(cm.display));
    }
    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {
      var visual = visualLine(this.lines[i]), len = lineLength(visual);
      if (len > cm.display.maxLineLength) {
        cm.display.maxLine = visual;
        cm.display.maxLineLength = len;
        cm.display.maxLineChanged = true;
      }
    }

    if (min != null && cm && this.collapsed) regChange(cm, min, max + 1);
    this.lines.length = 0;
    this.explicitlyCleared = true;
    if (this.atomic && this.doc.cantEdit) {
      this.doc.cantEdit = false;
      if (cm) reCheckSelection(cm.doc);
    }
    if (cm) signalLater(cm, "markerCleared", cm, this);
    if (withOp) endOperation(cm);
    if (this.parent) this.parent.clear();
  };

  // Find the position of the marker in the document. Returns a {from,
  // to} object by default. Side can be passed to get a specific side
  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
  // Pos objects returned contain a line object, rather than a line
  // number (used to prevent looking up the same line twice).
  TextMarker.prototype.find = function(side, lineObj) {
    if (side == null && this.type == "bookmark") side = 1;
    var from, to;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (span.from != null) {
        from = Pos(lineObj ? line : lineNo(line), span.from);
        if (side == -1) return from;
      }
      if (span.to != null) {
        to = Pos(lineObj ? line : lineNo(line), span.to);
        if (side == 1) return to;
      }
    }
    return from && {from: from, to: to};
  };

  // Signals that the marker's widget changed, and surrounding layout
  // should be recomputed.
  TextMarker.prototype.changed = function() {
    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
    if (!pos || !cm) return;
    runInOp(cm, function() {
      var line = pos.line, lineN = lineNo(pos.line);
      var view = findViewForLine(cm, lineN);
      if (view) {
        clearLineMeasurementCacheFor(view);
        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
      }
      cm.curOp.updateMaxLine = true;
      if (!lineIsHidden(widget.doc, line) && widget.height != null) {
        var oldHeight = widget.height;
        widget.height = null;
        var dHeight = widgetHeight(widget) - oldHeight;
        if (dHeight)
          updateLineHeight(line, line.height + dHeight);
      }
    });
  };

  TextMarker.prototype.attachLine = function(line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
    }
    this.lines.push(line);
  };
  TextMarker.prototype.detachLine = function(line) {
    this.lines.splice(indexOf(this.lines, line), 1);
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };

  // Collapsed markers have unique ids, in order to be able to order
  // them, which is needed for uniquely determining an outer marker
  // when they overlap (they may nest, but not partially overlap).
  var nextMarkerId = 0;

  // Create a marker, wire it up to the right lines, and
  function markText(doc, from, to, options, type) {
    // Shared markers (across linked documents) are handled separately
    // (markTextShared will call out to this again, once per
    // document).
    if (options && options.shared) return markTextShared(doc, from, to, options, type);
    // Ensure we are in an operation.
    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);

    var marker = new TextMarker(doc, type), diff = cmp(from, to);
    if (options) copyObj(options, marker, false);
    // Don't connect empty markers unless clearWhenEmpty is false
    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
      return marker;
    if (marker.replacedWith) {
      // Showing up as a widget implies collapsed (widget replaces text)
      marker.collapsed = true;
      marker.widgetNode = elt("span", [marker.replacedWith], "CodeMirror-widget");
      if (!options.handleMouseEvents) marker.widgetNode.ignoreEvents = true;
      if (options.insertLeft) marker.widgetNode.insertLeft = true;
    }
    if (marker.collapsed) {
      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
        throw new Error("Inserting collapsed marker partially overlapping an existing one");
      sawCollapsedSpans = true;
    }

    if (marker.addToHistory)
      addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN);

    var curLine = from.line, cm = doc.cm, updateMaxLine;
    doc.iter(curLine, to.line + 1, function(line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
        updateMaxLine = true;
      if (marker.collapsed && curLine != from.line) updateLineHeight(line, 0);
      addMarkedSpan(line, new MarkedSpan(marker,
                                         curLine == from.line ? from.ch : null,
                                         curLine == to.line ? to.ch : null));
      ++curLine;
    });
    // lineIsHidden depends on the presence of the spans, so needs a second pass
    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {
      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);
    });

    if (marker.clearOnEnter) on(marker, "beforeCursorEnter", function() { marker.clear(); });

    if (marker.readOnly) {
      sawReadOnlySpans = true;
      if (doc.history.done.length || doc.history.undone.length)
        doc.clearHistory();
    }
    if (marker.collapsed) {
      marker.id = ++nextMarkerId;
      marker.atomic = true;
    }
    if (cm) {
      // Sync editor state
      if (updateMaxLine) cm.curOp.updateMaxLine = true;
      if (marker.collapsed)
        regChange(cm, from.line, to.line + 1);
      else if (marker.className || marker.title || marker.startStyle || marker.endStyle)
        for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, "text");
      if (marker.atomic) reCheckSelection(cm.doc);
      signalLater(cm, "markerAdded", cm, marker);
    }
    return marker;
  }

  // SHARED TEXTMARKERS

  // A shared marker spans multiple linked documents. It is
  // implemented as a meta-marker-object controlling multiple normal
  // markers.
  var SharedTextMarker = CodeMirror.SharedTextMarker = function(markers, primary) {
    this.markers = markers;
    this.primary = primary;
    for (var i = 0; i < markers.length; ++i)
      markers[i].parent = this;
  };
  eventMixin(SharedTextMarker);

  SharedTextMarker.prototype.clear = function() {
    if (this.explicitlyCleared) return;
    this.explicitlyCleared = true;
    for (var i = 0; i < this.markers.length; ++i)
      this.markers[i].clear();
    signalLater(this, "clear");
  };
  SharedTextMarker.prototype.find = function(side, lineObj) {
    return this.primary.find(side, lineObj);
  };

  function markTextShared(doc, from, to, options, type) {
    options = copyObj(options);
    options.shared = false;
    var markers = [markText(doc, from, to, options, type)], primary = markers[0];
    var widget = options.widgetNode;
    linkedDocs(doc, function(doc) {
      if (widget) options.widgetNode = widget.cloneNode(true);
      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
      for (var i = 0; i < doc.linked.length; ++i)
        if (doc.linked[i].isParent) return;
      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary);
  }

  function findSharedMarkers(doc) {
    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())),
                         function(m) { return m.parent; });
  }

  function copySharedMarkers(doc, markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i], pos = marker.find();
      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
      if (cmp(mFrom, mTo)) {
        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
        marker.markers.push(subMark);
        subMark.parent = marker;
      }
    }
  }

  function detachSharedMarkers(markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i], linked = [marker.primary.doc];;
      linkedDocs(marker.primary.doc, function(d) { linked.push(d); });
      for (var j = 0; j < marker.markers.length; j++) {
        var subMarker = marker.markers[j];
        if (indexOf(linked, subMarker.doc) == -1) {
          subMarker.parent = null;
          marker.markers.splice(j--, 1);
        }
      }
    }
  }

  // TEXTMARKER SPANS

  function MarkedSpan(marker, from, to) {
    this.marker = marker;
    this.from = from; this.to = to;
  }

  // Search an array of spans for a span matching the given marker.
  function getMarkedSpanFor(spans, marker) {
    if (spans) for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.marker == marker) return span;
    }
  }
  // Remove a span from an array, returning undefined if no spans are
  // left (we don't store arrays for lines without spans).
  function removeMarkedSpan(spans, span) {
    for (var r, i = 0; i < spans.length; ++i)
      if (spans[i] != span) (r || (r = [])).push(spans[i]);
    return r;
  }
  // Add a span to a line.
  function addMarkedSpan(line, span) {
    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
    span.marker.attachLine(line);
  }

  // Used for the algorithm that adjusts markers for a change in the
  // document. These functions cut an array of spans at a given
  // character position, returning an array of remaining chunks (or
  // undefined if nothing remains).
  function markedSpansBefore(old, startCh, isInsert) {
    if (old) for (var i = 0, nw; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
      if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
        (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
      }
    }
    return nw;
  }
  function markedSpansAfter(old, endCh, isInsert) {
    if (old) for (var i = 0, nw; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
      if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
        (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
                                              span.to == null ? null : span.to - endCh));
      }
    }
    return nw;
  }

  // Given a change object, compute the new set of marker spans that
  // cover the line in which the change took place. Removes spans
  // entirely within the change, reconnects spans belonging to the
  // same marker that appear on both sides of the change, and cuts off
  // spans partially within the change. Returns an array of span
  // arrays with one element for each line in (after) the change.
  function stretchSpansOverChange(doc, change) {
    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
    if (!oldFirst && !oldLast) return null;

    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
    // Get the spans that 'stick out' on both sides
    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert);

    // Next, merge those two ends
    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
    if (first) {
      // Fix up .to properties of first
      for (var i = 0; i < first.length; ++i) {
        var span = first[i];
        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);
          if (!found) span.to = startCh;
          else if (sameLine) span.to = found.to == null ? null : found.to + offset;
        }
      }
    }
    if (last) {
      // Fix up .from in last (or move them into first in case of sameLine)
      for (var i = 0; i < last.length; ++i) {
        var span = last[i];
        if (span.to != null) span.to += offset;
        if (span.from == null) {
          var found = getMarkedSpanFor(first, span.marker);
          if (!found) {
            span.from = offset;
            if (sameLine) (first || (first = [])).push(span);
          }
        } else {
          span.from += offset;
          if (sameLine) (first || (first = [])).push(span);
        }
      }
    }
    // Make sure we didn't create any zero-length spans
    if (first) first = clearEmptySpans(first);
    if (last && last != first) last = clearEmptySpans(last);

    var newMarkers = [first];
    if (!sameLine) {
      // Fill gap with whole-line-spans
      var gap = change.text.length - 2, gapMarkers;
      if (gap > 0 && first)
        for (var i = 0; i < first.length; ++i)
          if (first[i].to == null)
            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));
      for (var i = 0; i < gap; ++i)
        newMarkers.push(gapMarkers);
      newMarkers.push(last);
    }
    return newMarkers;
  }

  // Remove spans that are empty and don't have a clearWhenEmpty
  // option of false.
  function clearEmptySpans(spans) {
    for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
        spans.splice(i--, 1);
    }
    if (!spans.length) return null;
    return spans;
  }

  // Used for un/re-doing changes from the history. Combines the
  // result of computing the existing spans with the set of spans that
  // existed in the history (so that deleting around a span and then
  // undoing brings back the span).
  function mergeOldSpans(doc, change) {
    var old = getOldSpans(doc, change);
    var stretched = stretchSpansOverChange(doc, change);
    if (!old) return stretched;
    if (!stretched) return old;

    for (var i = 0; i < old.length; ++i) {
      var oldCur = old[i], stretchCur = stretched[i];
      if (oldCur && stretchCur) {
        spans: for (var j = 0; j < stretchCur.length; ++j) {
          var span = stretchCur[j];
          for (var k = 0; k < oldCur.length; ++k)
            if (oldCur[k].marker == span.marker) continue spans;
          oldCur.push(span);
        }
      } else if (stretchCur) {
        old[i] = stretchCur;
      }
    }
    return old;
  }

  // Used to 'clip' out readOnly ranges when making a change.
  function removeReadOnlyRanges(doc, from, to) {
    var markers = null;
    doc.iter(from.line, to.line + 1, function(line) {
      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {
        var mark = line.markedSpans[i].marker;
        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
          (markers || (markers = [])).push(mark);
      }
    });
    if (!markers) return null;
    var parts = [{from: from, to: to}];
    for (var i = 0; i < markers.length; ++i) {
      var mk = markers[i], m = mk.find(0);
      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];
        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) continue;
        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
          newParts.push({from: p.from, to: m.from});
        if (dto > 0 || !mk.inclusiveRight && !dto)
          newParts.push({from: m.to, to: p.to});
        parts.splice.apply(parts, newParts);
        j += newParts.length - 1;
      }
    }
    return parts;
  }

  // Connect or disconnect spans from a line.
  function detachMarkedSpans(line) {
    var spans = line.markedSpans;
    if (!spans) return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.detachLine(line);
    line.markedSpans = null;
  }
  function attachMarkedSpans(line, spans) {
    if (!spans) return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.attachLine(line);
    line.markedSpans = spans;
  }

  // Helpers used when computing which overlapping collapsed span
  // counts as the larger one.
  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }
  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }

  // Returns a number indicating which of two overlapping collapsed
  // spans is larger (and thus includes the other). Falls back to
  // comparing ids when the spans cover exactly the same range.
  function compareCollapsedMarkers(a, b) {
    var lenDiff = a.lines.length - b.lines.length;
    if (lenDiff != 0) return lenDiff;
    var aPos = a.find(), bPos = b.find();
    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
    if (fromCmp) return -fromCmp;
    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
    if (toCmp) return toCmp;
    return b.id - a.id;
  }

  // Find out whether a line ends or starts in a collapsed span. If
  // so, return the marker for that span.
  function collapsedSpanAtSide(line, start) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) for (var sp, i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
          (!found || compareCollapsedMarkers(found, sp.marker) < 0))
        found = sp.marker;
    }
    return found;
  }
  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }
  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }

  // Test whether there exists a collapsed span that partially
  // overlaps (covers the start or end, but not both) of a new span.
  // Such overlap is not allowed.
  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
    var line = getLine(doc, lineNo);
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) for (var i = 0; i < sps.length; ++i) {
      var sp = sps[i];
      if (!sp.marker.collapsed) continue;
      var found = sp.marker.find(0);
      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;
      if (fromCmp <= 0 && (cmp(found.to, from) || extraRight(sp.marker) - extraLeft(marker)) > 0 ||
          fromCmp >= 0 && (cmp(found.from, to) || extraLeft(sp.marker) - extraRight(marker)) < 0)
        return true;
    }
  }

  // A visual line is a line as drawn on the screen. Folding, for
  // example, can cause multiple logical lines to appear on the same
  // visual line. This finds the start of the visual line that the
  // given line is part of (usually that is the line itself).
  function visualLine(line) {
    var merged;
    while (merged = collapsedSpanAtStart(line))
      line = merged.find(-1, true).line;
    return line;
  }

  // Returns an array of logical lines that continue the visual line
  // started by the argument, or undefined if there are no such lines.
  function visualLineContinued(line) {
    var merged, lines;
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
      (lines || (lines = [])).push(line);
    }
    return lines;
  }

  // Get the line number of the start of the visual line that the
  // given line number is part of.
  function visualLineNo(doc, lineN) {
    var line = getLine(doc, lineN), vis = visualLine(line);
    if (line == vis) return lineN;
    return lineNo(vis);
  }
  // Get the line number of the start of the next visual line after
  // the given line.
  function visualLineEndNo(doc, lineN) {
    if (lineN > doc.lastLine()) return lineN;
    var line = getLine(doc, lineN), merged;
    if (!lineIsHidden(doc, line)) return lineN;
    while (merged = collapsedSpanAtEnd(line))
      line = merged.find(1, true).line;
    return lineNo(line) + 1;
  }

  // Compute whether a line is hidden. Lines count as hidden when they
  // are part of a visual line that starts with another line, or when
  // they are entirely covered by collapsed, non-widget span.
  function lineIsHidden(doc, line) {
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) for (var sp, i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (!sp.marker.collapsed) continue;
      if (sp.from == null) return true;
      if (sp.marker.widgetNode) continue;
      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
        return true;
    }
  }
  function lineIsHiddenInner(doc, line, span) {
    if (span.to == null) {
      var end = span.marker.find(1, true);
      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
    }
    if (span.marker.inclusiveRight && span.to == line.text.length)
      return true;
    for (var sp, i = 0; i < line.markedSpans.length; ++i) {
      sp = line.markedSpans[i];
      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
          (sp.to == null || sp.to != span.from) &&
          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
          lineIsHiddenInner(doc, line, sp)) return true;
    }
  }

  // LINE WIDGETS

  // Line widgets are block elements displayed above or below a line.

  var LineWidget = CodeMirror.LineWidget = function(cm, node, options) {
    if (options) for (var opt in options) if (options.hasOwnProperty(opt))
      this[opt] = options[opt];
    this.cm = cm;
    this.node = node;
  };
  eventMixin(LineWidget);

  function adjustScrollWhenAboveVisible(cm, line, diff) {
    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
      addToScrollPos(cm, null, diff);
  }

  LineWidget.prototype.clear = function() {
    var cm = this.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
    if (no == null || !ws) return;
    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);
    if (!ws.length) line.widgets = null;
    var height = widgetHeight(this);
    runInOp(cm, function() {
      adjustScrollWhenAboveVisible(cm, line, -height);
      regLineChange(cm, no, "widget");
      updateLineHeight(line, Math.max(0, line.height - height));
    });
  };
  LineWidget.prototype.changed = function() {
    var oldH = this.height, cm = this.cm, line = this.line;
    this.height = null;
    var diff = widgetHeight(this) - oldH;
    if (!diff) return;
    runInOp(cm, function() {
      cm.curOp.forceUpdate = true;
      adjustScrollWhenAboveVisible(cm, line, diff);
      updateLineHeight(line, line.height + diff);
    });
  };

  function widgetHeight(widget) {
    if (widget.height != null) return widget.height;
    if (!contains(document.body, widget.node))
      removeChildrenAndAdd(widget.cm.display.measure, elt("div", [widget.node], null, "position: relative"));
    return widget.height = widget.node.offsetHeight;
  }

  function addLineWidget(cm, handle, node, options) {
    var widget = new LineWidget(cm, node, options);
    if (widget.noHScroll) cm.display.alignWidgets = true;
    changeLine(cm, handle, "widget", function(line) {
      var widgets = line.widgets || (line.widgets = []);
      if (widget.insertAt == null) widgets.push(widget);
      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);
      widget.line = line;
      if (!lineIsHidden(cm.doc, line)) {
        var aboveVisible = heightAtLine(line) < cm.doc.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));
        if (aboveVisible) addToScrollPos(cm, null, widget.height);
        cm.curOp.forceUpdate = true;
      }
      return true;
    });
    return widget;
  }

  // LINE DATA STRUCTURE

  // Line objects. These hold state related to a line, including
  // highlighting info (the styles array).
  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {
    this.text = text;
    attachMarkedSpans(this, markedSpans);
    this.height = estimateHeight ? estimateHeight(this) : 1;
  };
  eventMixin(Line);
  Line.prototype.lineNo = function() { return lineNo(this); };

  // Change the content (text, markers) of a line. Automatically
  // invalidates cached information and tries to re-estimate the
  // line's height.
  function updateLine(line, text, markedSpans, estimateHeight) {
    line.text = text;
    if (line.stateAfter) line.stateAfter = null;
    if (line.styles) line.styles = null;
    if (line.order != null) line.order = null;
    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight ? estimateHeight(line) : 1;
    if (estHeight != line.height) updateLineHeight(line, estHeight);
  }

  // Detach a line from the document tree and its markers.
  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  }

  function extractLineClasses(type, output) {
    if (type) for (;;) {
      var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
      if (!lineClass) break;
      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
      var prop = lineClass[1] ? "bgClass" : "textClass";
      if (output[prop] == null)
        output[prop] = lineClass[2];
      else if (!(new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)")).test(output[prop]))
        output[prop] += " " + lineClass[2];
    }
    return type;
  }

  function callBlankLine(mode, state) {
    if (mode.blankLine) return mode.blankLine(state);
    if (!mode.innerMode) return;
    var inner = CodeMirror.innerMode(mode, state);
    if (inner.mode.blankLine) return inner.mode.blankLine(inner.state);
  }

  function readToken(mode, stream, state) {
    var style = mode.token(stream, state);
    if (stream.pos <= stream.start)
      throw new Error("Mode " + mode.name + " failed to advance stream.");
    return style;
  }

  // Run the given mode's parser over a line, calling f for each token.
  function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {
    var flattenSpans = mode.flattenSpans;
    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;
    var curStart = 0, curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize), style;
    if (text == "") extractLineClasses(callBlankLine(mode, state), lineClasses);
    while (!stream.eol()) {
      if (stream.pos > cm.options.maxHighlightLength) {
        flattenSpans = false;
        if (forceToEnd) processLine(cm, text, state, stream.pos);
        stream.pos = text.length;
        style = null;
      } else {
        style = extractLineClasses(readToken(mode, stream, state), lineClasses);
      }
      if (cm.options.addModeClass) {
        var mName = CodeMirror.innerMode(mode, state).mode.name;
        if (mName) style = "m-" + (style ? mName + " " + style : mName);
      }
      if (!flattenSpans || curStyle != style) {
        if (curStart < stream.start) f(stream.start, curStyle);
        curStart = stream.start; curStyle = style;
      }
      stream.start = stream.pos;
    }
    while (curStart < stream.pos) {
      // Webkit seems to refuse to render text nodes longer than 57444 characters
      var pos = Math.min(stream.pos, curStart + 50000);
      f(pos, curStyle);
      curStart = pos;
    }
  }

  // Compute a style array (an array starting with a mode generation
  // -- for invalidation -- followed by pairs of end positions and
  // style strings), which is used to highlight the tokens on the
  // line.
  function highlightLine(cm, line, state, forceToEnd) {
    // A styles array always starts with a number identifying the
    // mode/overlays that it is based on (for easy invalidation).
    var st = [cm.state.modeGen], lineClasses = {};
    // Compute the base array of styles
    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {
      st.push(end, style);
    }, lineClasses, forceToEnd);

    // Run overlays, adjust style array.
    for (var o = 0; o < cm.state.overlays.length; ++o) {
      var overlay = cm.state.overlays[o], i = 1, at = 0;
      runMode(cm, line.text, overlay.mode, true, function(end, style) {
        var start = i;
        // Ensure there's a token end at the current position, and that i points at it
        while (at < end) {
          var i_end = st[i];
          if (i_end > end)
            st.splice(i, 1, end, st[i+1], i_end);
          i += 2;
          at = Math.min(end, i_end);
        }
        if (!style) return;
        if (overlay.opaque) {
          st.splice(start, i - start, end, "cm-overlay " + style);
          i = start + 2;
        } else {
          for (; start < i; start += 2) {
            var cur = st[start+1];
            st[start+1] = (cur ? cur + " " : "") + "cm-overlay " + style;
          }
        }
      }, lineClasses);
    }

    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null};
  }

  function getLineStyles(cm, line) {
    if (!line.styles || line.styles[0] != cm.state.modeGen) {
      var result = highlightLine(cm, line, line.stateAfter = getStateBefore(cm, lineNo(line)));
      line.styles = result.styles;
      if (result.classes) line.styleClasses = result.classes;
      else if (line.styleClasses) line.styleClasses = null;
    }
    return line.styles;
  }

  // Lightweight form of highlight -- proceed over this line and
  // update state, but don't save a style array. Used for lines that
  // aren't currently visible.
  function processLine(cm, text, state, startAt) {
    var mode = cm.doc.mode;
    var stream = new StringStream(text, cm.options.tabSize);
    stream.start = stream.pos = startAt || 0;
    if (text == "") callBlankLine(mode, state);
    while (!stream.eol() && stream.pos <= cm.options.maxHighlightLength) {
      readToken(mode, stream, state);
      stream.start = stream.pos;
    }
  }

  // Convert a style as returned by a mode (either null, or a string
  // containing one or more styles) to a CSS style. This is cached,
  // and also looks for line-wide styles.
  var styleToClassCache = {}, styleToClassCacheWithMode = {};
  function interpretTokenStyle(style, options) {
    if (!style || /^\s*$/.test(style)) return null;
    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
    return cache[style] ||
      (cache[style] = style.replace(/\S+/g, "cm-$&"));
  }

  // Render the DOM representation of the text of a line. Also builds
  // up a 'line map', which points at the DOM nodes that represent
  // specific stretches of text, and is used by the measuring code.
  // The returned object contains the DOM node, this map, and
  // information about line-wide styles that were set by the mode.
  function buildLineContent(cm, lineView) {
    // The padding-right forces the element to have a 'border', which
    // is needed on Webkit to be able to get line-level bounding
    // rectangles for it (in measureChar).
    var content = elt("span", null, null, webkit ? "padding-right: .1px" : null);
    var builder = {pre: elt("pre", [content]), content: content, col: 0, pos: 0, cm: cm};
    lineView.measure = {};

    // Iterate over the logical lines that make up this visual line.
    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
      var line = i ? lineView.rest[i - 1] : lineView.line, order;
      builder.pos = 0;
      builder.addToken = buildToken;
      // Optionally wire in some hacks into the token-rendering
      // algorithm, to deal with browser quirks.
      if ((ie || webkit) && cm.getOption("lineWrapping"))
        builder.addToken = buildTokenSplitSpaces(builder.addToken);
      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))
        builder.addToken = buildTokenBadBidi(builder.addToken, order);
      builder.map = [];
      insertLineContent(line, builder, getLineStyles(cm, line));
      if (line.styleClasses) {
        if (line.styleClasses.bgClass)
          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
        if (line.styleClasses.textClass)
          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
      }

      // Ensure at least a single node is present, for measuring.
      if (builder.map.length == 0)
        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));

      // Store the map and a cache object for the current logical line
      if (i == 0) {
        lineView.measure.map = builder.map;
        lineView.measure.cache = {};
      } else {
        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
        (lineView.measure.caches || (lineView.measure.caches = [])).push({});
      }
    }

    signal(cm, "renderLine", cm, lineView.line, builder.pre);
    return builder;
  }

  function defaultSpecialCharPlaceholder(ch) {
    var token = elt("span", "\u2022", "cm-invalidchar");
    token.title = "\\u" + ch.charCodeAt(0).toString(16);
    return token;
  }

  // Build up the DOM representation for a single token, and add it to
  // the line map. Takes care to render special characters separately.
  function buildToken(builder, text, style, startStyle, endStyle, title) {
    if (!text) return;
    var special = builder.cm.options.specialChars, mustWrap = false;
    if (!special.test(text)) {
      builder.col += text.length;
      var content = document.createTextNode(text);
      builder.map.push(builder.pos, builder.pos + text.length, content);
      if (ie_upto8) mustWrap = true;
      builder.pos += text.length;
    } else {
      var content = document.createDocumentFragment(), pos = 0;
      while (true) {
        special.lastIndex = pos;
        var m = special.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;
        if (skipped) {
          var txt = document.createTextNode(text.slice(pos, pos + skipped));
          if (ie_upto8) content.appendChild(elt("span", [txt]));
          else content.appendChild(txt);
          builder.map.push(builder.pos, builder.pos + skipped, txt);
          builder.col += skipped;
          builder.pos += skipped;
        }
        if (!m) break;
        pos += skipped + 1;
        if (m[0] == "\t") {
          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
          var txt = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
          builder.col += tabWidth;
        } else {
          var txt = builder.cm.options.specialCharPlaceholder(m[0]);
          if (ie_upto8) content.appendChild(elt("span", [txt]));
          else content.appendChild(txt);
          builder.col += 1;
        }
        builder.map.push(builder.pos, builder.pos + 1, txt);
        builder.pos++;
      }
    }
    if (style || startStyle || endStyle || mustWrap) {
      var fullStyle = style || "";
      if (startStyle) fullStyle += startStyle;
      if (endStyle) fullStyle += endStyle;
      var token = elt("span", [content], fullStyle);
      if (title) token.title = title;
      return builder.content.appendChild(token);
    }
    builder.content.appendChild(content);
  }

  function buildTokenSplitSpaces(inner) {
    function split(old) {
      var out = " ";
      for (var i = 0; i < old.length - 2; ++i) out += i % 2 ? " " : "\u00a0";
      out += " ";
      return out;
    }
    return function(builder, text, style, startStyle, endStyle, title) {
      inner(builder, text.replace(/ {3,}/g, split), style, startStyle, endStyle, title);
    };
  }

  // Work around nonsense dimensions being reported for stretches of
  // right-to-left text.
  function buildTokenBadBidi(inner, order) {
    return function(builder, text, style, startStyle, endStyle, title) {
      style = style ? style + " cm-force-border" : "cm-force-border";
      var start = builder.pos, end = start + text.length;
      for (;;) {
        // Find the part that overlaps with the start of this text
        for (var i = 0; i < order.length; i++) {
          var part = order[i];
          if (part.to > start && part.from <= start) break;
        }
        if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title);
        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title);
        startStyle = null;
        text = text.slice(part.to - start);
        start = part.to;
      }
    };
  }

  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
    var widget = !ignoreWidget && marker.widgetNode;
    if (widget) {
      builder.map.push(builder.pos, builder.pos + size, widget);
      builder.content.appendChild(widget);
    }
    builder.pos += size;
  }

  // Outputs a number of spans to make up a line, taking highlighting
  // and marked text into account.
  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans, allText = line.text, at = 0;
    if (!spans) {
      for (var i = 1; i < styles.length; i+=2)
        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder.cm.options));
      return;
    }

    var len = allText.length, pos = 0, i = 1, text = "", style;
    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;
    for (;;) {
      if (nextChange == pos) { // Update current marker set
        spanStyle = spanEndStyle = spanStartStyle = title = "";
        collapsed = null; nextChange = Infinity;
        var foundBookmarks = [];
        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j], m = sp.marker;
          if (sp.from <= pos && (sp.to == null || sp.to > pos)) {
            if (sp.to != null && nextChange > sp.to) { nextChange = sp.to; spanEndStyle = ""; }
            if (m.className) spanStyle += " " + m.className;
            if (m.startStyle && sp.from == pos) spanStartStyle += " " + m.startStyle;
            if (m.endStyle && sp.to == nextChange) spanEndStyle += " " + m.endStyle;
            if (m.title && !title) title = m.title;
            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
              collapsed = sp;
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
          if (m.type == "bookmark" && sp.from == pos && m.widgetNode) foundBookmarks.push(m);
        }
        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
                             collapsed.marker, collapsed.from == null);
          if (collapsed.to == null) return;
        }
        if (!collapsed && foundBookmarks.length) for (var j = 0; j < foundBookmarks.length; ++j)
          buildCollapsedSpan(builder, 0, foundBookmarks[j]);
      }
      if (pos >= len) break;

      var upto = Math.min(len, nextChange);
      while (true) {
        if (text) {
          var end = pos + text.length;
          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title);
          }
          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}
          pos = end;
          spanStartStyle = "";
        }
        text = allText.slice(at, at = styles[i++]);
        style = interpretTokenStyle(styles[i++], builder.cm.options);
      }
    }
  }

  // DOCUMENT DATA STRUCTURE

  // By default, updates that start and end at the beginning of a line
  // are treated specially, in order to make the association of line
  // widgets and marker elements with the text behave more intuitive.
  function isWholeLineUpdate(doc, change) {
    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
      (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
  }

  // Perform a change on the document data structure.
  function updateDoc(doc, change, markedSpans, estimateHeight) {
    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}
    function update(line, text, spans) {
      updateLine(line, text, spans, estimateHeight);
      signalLater(line, "change", line, change);
    }

    var from = change.from, to = change.to, text = change.text;
    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;

    // Adjust the line structure
    if (isWholeLineUpdate(doc, change)) {
      // This is a whole-line replace. Treated specially to make
      // sure line objects move the way they are supposed to.
      for (var i = 0, added = []; i < text.length - 1; ++i)
        added.push(new Line(text[i], spansFor(i), estimateHeight));
      update(lastLine, lastLine.text, lastSpans);
      if (nlines) doc.remove(from.line, nlines);
      if (added.length) doc.insert(from.line, added);
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } else {
        for (var added = [], i = 1; i < text.length - 1; ++i)
          added.push(new Line(text[i], spansFor(i), estimateHeight));
        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        doc.insert(from.line + 1, added);
      }
    } else if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
      doc.remove(from.line + 1, nlines);
    } else {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      for (var i = 1, added = []; i < text.length - 1; ++i)
        added.push(new Line(text[i], spansFor(i), estimateHeight));
      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);
      doc.insert(from.line + 1, added);
    }

    signalLater(doc, "change", doc, change);
  }

  // The document is represented as a BTree consisting of leaves, with
  // chunk of lines in them, and branches, with up to ten leaves or
  // other branch nodes below them. The top node is always a branch
  // node, and is the document object itself (meaning it has
  // additional methods and properties).
  //
  // All nodes have parent links. The tree is used both to go from
  // line numbers to line objects, and to go from objects to numbers.
  // It also indexes by height, and is used to convert between height
  // and line object, and to find the total height of the document.
  //
  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

  function LeafChunk(lines) {
    this.lines = lines;
    this.parent = null;
    for (var i = 0, height = 0; i < lines.length; ++i) {
      lines[i].parent = this;
      height += lines[i].height;
    }
    this.height = height;
  }

  LeafChunk.prototype = {
    chunkSize: function() { return this.lines.length; },
    // Remove the n lines at offset 'at'.
    removeInner: function(at, n) {
      for (var i = at, e = at + n; i < e; ++i) {
        var line = this.lines[i];
        this.height -= line.height;
        cleanUpLine(line);
        signalLater(line, "delete");
      }
      this.lines.splice(at, n);
    },
    // Helper used to collapse a small branch into a single leaf.
    collapse: function(lines) {
      lines.push.apply(lines, this.lines);
    },
    // Insert the given array of lines at offset 'at', count them as
    // having the given height.
    insertInner: function(at, lines, height) {
      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
      for (var i = 0; i < lines.length; ++i) lines[i].parent = this;
    },
    // Used to iterate over a part of the tree.
    iterN: function(at, n, op) {
      for (var e = at + n; at < e; ++at)
        if (op(this.lines[at])) return true;
    }
  };

  function BranchChunk(children) {
    this.children = children;
    var size = 0, height = 0;
    for (var i = 0; i < children.length; ++i) {
      var ch = children[i];
      size += ch.chunkSize(); height += ch.height;
      ch.parent = this;
    }
    this.size = size;
    this.height = height;
    this.parent = null;
  }

  BranchChunk.prototype = {
    chunkSize: function() { return this.size; },
    removeInner: function(at, n) {
      this.size -= n;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var rm = Math.min(n, sz - at), oldHeight = child.height;
          child.removeInner(at, rm);
          this.height -= oldHeight - child.height;
          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }
          if ((n -= rm) == 0) break;
          at = 0;
        } else at -= sz;
      }
      // If the result is smaller than 25 lines, ensure that it is a
      // single leaf node.
      if (this.size - n < 25 &&
          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },
    collapse: function(lines) {
      for (var i = 0; i < this.children.length; ++i) this.children[i].collapse(lines);
    },
    insertInner: function(at, lines, height) {
      this.size += lines.length;
      this.height += height;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at <= sz) {
          child.insertInner(at, lines, height);
          if (child.lines && child.lines.length > 50) {
            while (child.lines.length > 50) {
              var spilled = child.lines.splice(child.lines.length - 25, 25);
              var newleaf = new LeafChunk(spilled);
              child.height -= newleaf.height;
              this.children.splice(i + 1, 0, newleaf);
              newleaf.parent = this;
            }
            this.maybeSpill();
          }
          break;
        }
        at -= sz;
      }
    },
    // When a node has grown, check whether it should be split.
    maybeSpill: function() {
      if (this.children.length <= 10) return;
      var me = this;
      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);
        if (!me.parent) { // Become the parent node
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [copy, sibling];
          me = copy;
        } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }
        sibling.parent = me.parent;
      } while (me.children.length > 10);
      me.parent.maybeSpill();
    },
    iterN: function(at, n, op) {
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var used = Math.min(n, sz - at);
          if (child.iterN(at, used, op)) return true;
          if ((n -= used) == 0) break;
          at = 0;
        } else at -= sz;
      }
    }
  };

  var nextDocId = 0;
  var Doc = CodeMirror.Doc = function(text, mode, firstLine) {
    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine);
    if (firstLine == null) firstLine = 0;

    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
    this.first = firstLine;
    this.scrollTop = this.scrollLeft = 0;
    this.cantEdit = false;
    this.cleanGeneration = 1;
    this.frontier = firstLine;
    var start = Pos(firstLine, 0);
    this.sel = simpleSelection(start);
    this.history = new History(null);
    this.id = ++nextDocId;
    this.modeOption = mode;

    if (typeof text == "string") text = splitLines(text);
    updateDoc(this, {from: start, to: start, text: text});
    setSelection(this, simpleSelection(start), sel_dontScroll);
  };

  Doc.prototype = createObj(BranchChunk.prototype, {
    constructor: Doc,
    // Iterate over the document. Supports two forms -- with only one
    // argument, it calls that for each line in the document. With
    // three, it iterates over the range given by the first two (with
    // the second being non-inclusive).
    iter: function(from, to, op) {
      if (op) this.iterN(from - this.first, to - from, op);
      else this.iterN(this.first, this.first + this.size, from);
    },

    // Non-public interface for adding and removing lines.
    insert: function(at, lines) {
      var height = 0;
      for (var i = 0; i < lines.length; ++i) height += lines[i].height;
      this.insertInner(at - this.first, lines, height);
    },
    remove: function(at, n) { this.removeInner(at - this.first, n); },

    // From here, the methods are part of the public interface. Most
    // are also available from CodeMirror (editor) instances.

    getValue: function(lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);
      if (lineSep === false) return lines;
      return lines.join(lineSep || "\n");
    },
    setValue: docMethodOp(function(code) {
      var top = Pos(this.first, 0), last = this.first + this.size - 1;
      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
                        text: splitLines(code), origin: "setValue"}, true);
      setSelection(this, simpleSelection(top));
    }),
    replaceRange: function(code, from, to, origin) {
      from = clipPos(this, from);
      to = to ? clipPos(this, to) : from;
      replaceRange(this, code, from, to, origin);
    },
    getRange: function(from, to, lineSep) {
      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
      if (lineSep === false) return lines;
      return lines.join(lineSep || "\n");
    },

    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},

    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},
    getLineNumber: function(line) {return lineNo(line);},

    getLineHandleVisualStart: function(line) {
      if (typeof line == "number") line = getLine(this, line);
      return visualLine(line);
    },

    lineCount: function() {return this.size;},
    firstLine: function() {return this.first;},
    lastLine: function() {return this.first + this.size - 1;},

    clipPos: function(pos) {return clipPos(this, pos);},

    getCursor: function(start) {
      var range = this.sel.primary(), pos;
      if (start == null || start == "head") pos = range.head;
      else if (start == "anchor") pos = range.anchor;
      else if (start == "end" || start == "to" || start === false) pos = range.to();
      else pos = range.from();
      return pos;
    },
    listSelections: function() { return this.sel.ranges; },
    somethingSelected: function() {return this.sel.somethingSelected();},

    setCursor: docMethodOp(function(line, ch, options) {
      setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
    }),
    setSelection: docMethodOp(function(anchor, head, options) {
      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
    }),
    extendSelection: docMethodOp(function(head, other, options) {
      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
    }),
    extendSelections: docMethodOp(function(heads, options) {
      extendSelections(this, clipPosArray(this, heads, options));
    }),
    extendSelectionsBy: docMethodOp(function(f, options) {
      extendSelections(this, map(this.sel.ranges, f), options);
    }),
    setSelections: docMethodOp(function(ranges, primary, options) {
      if (!ranges.length) return;
      for (var i = 0, out = []; i < ranges.length; i++)
        out[i] = new Range(clipPos(this, ranges[i].anchor),
                           clipPos(this, ranges[i].head));
      if (primary == null) primary = Math.min(ranges.length - 1, this.sel.primIndex);
      setSelection(this, normalizeSelection(out, primary), options);
    }),
    addSelection: docMethodOp(function(anchor, head, options) {
      var ranges = this.sel.ranges.slice(0);
      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
      setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);
    }),

    getSelection: function(lineSep) {
      var ranges = this.sel.ranges, lines;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
        lines = lines ? lines.concat(sel) : sel;
      }
      if (lineSep === false) return lines;
      else return lines.join(lineSep || "\n");
    },
    getSelections: function(lineSep) {
      var parts = [], ranges = this.sel.ranges;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
        if (lineSep !== false) sel = sel.join(lineSep || "\n");
        parts[i] = sel;
      }
      return parts;
    },
    replaceSelection: function(code, collapse, origin) {
      var dup = [];
      for (var i = 0; i < this.sel.ranges.length; i++)
        dup[i] = code;
      this.replaceSelections(dup, collapse, origin || "+input");
    },
    replaceSelections: docMethodOp(function(code, collapse, origin) {
      var changes = [], sel = this.sel;
      for (var i = 0; i < sel.ranges.length; i++) {
        var range = sel.ranges[i];
        changes[i] = {from: range.from(), to: range.to(), text: splitLines(code[i]), origin: origin};
      }
      var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
      for (var i = changes.length - 1; i >= 0; i--)
        makeChange(this, changes[i]);
      if (newSel) setSelectionReplaceHistory(this, newSel);
      else if (this.cm) ensureCursorVisible(this.cm);
    }),
    undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),
    redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),
    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),
    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),

    setExtending: function(val) {this.extend = val;},
    getExtending: function() {return this.extend;},

    historySize: function() {
      var hist = this.history, done = 0, undone = 0;
      for (var i = 0; i < hist.done.length; i++) if (!hist.done[i].ranges) ++done;
      for (var i = 0; i < hist.undone.length; i++) if (!hist.undone[i].ranges) ++undone;
      return {undo: done, redo: undone};
    },
    clearHistory: function() {this.history = new History(this.history.maxGeneration);},

    markClean: function() {
      this.cleanGeneration = this.changeGeneration(true);
    },
    changeGeneration: function(forceSplit) {
      if (forceSplit)
        this.history.lastOp = this.history.lastOrigin = null;
      return this.history.generation;
    },
    isClean: function (gen) {
      return this.history.generation == (gen || this.cleanGeneration);
    },

    getHistory: function() {
      return {done: copyHistoryArray(this.history.done),
              undone: copyHistoryArray(this.history.undone)};
    },
    setHistory: function(histData) {
      var hist = this.history = new History(this.history.maxGeneration);
      hist.done = copyHistoryArray(histData.done.slice(0), null, true);
      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
    },

    markText: function(from, to, options) {
      return markText(this, clipPos(this, from), clipPos(this, to), options, "range");
    },
    setBookmark: function(pos, options) {
      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
                      insertLeft: options && options.insertLeft,
                      clearWhenEmpty: false, shared: options && options.shared};
      pos = clipPos(this, pos);
      return markText(this, pos, pos, realOpts, "bookmark");
    },
    findMarksAt: function(pos) {
      pos = clipPos(this, pos);
      var markers = [], spans = getLine(this, pos.line).markedSpans;
      if (spans) for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if ((span.from == null || span.from <= pos.ch) &&
            (span.to == null || span.to >= pos.ch))
          markers.push(span.marker.parent || span.marker);
      }
      return markers;
    },
    findMarks: function(from, to, filter) {
      from = clipPos(this, from); to = clipPos(this, to);
      var found = [], lineNo = from.line;
      this.iter(from.line, to.line + 1, function(line) {
        var spans = line.markedSpans;
        if (spans) for (var i = 0; i < spans.length; i++) {
          var span = spans[i];
          if (!(lineNo == from.line && from.ch > span.to ||
                span.from == null && lineNo != from.line||
                lineNo == to.line && span.from > to.ch) &&
              (!filter || filter(span.marker)))
            found.push(span.marker.parent || span.marker);
        }
        ++lineNo;
      });
      return found;
    },
    getAllMarks: function() {
      var markers = [];
      this.iter(function(line) {
        var sps = line.markedSpans;
        if (sps) for (var i = 0; i < sps.length; ++i)
          if (sps[i].from != null) markers.push(sps[i].marker);
      });
      return markers;
    },

    posFromIndex: function(off) {
      var ch, lineNo = this.first;
      this.iter(function(line) {
        var sz = line.text.length + 1;
        if (sz > off) { ch = off; return true; }
        off -= sz;
        ++lineNo;
      });
      return clipPos(this, Pos(lineNo, ch));
    },
    indexFromPos: function (coords) {
      coords = clipPos(this, coords);
      var index = coords.ch;
      if (coords.line < this.first || coords.ch < 0) return 0;
      this.iter(this.first, coords.line, function (line) {
        index += line.text.length + 1;
      });
      return index;
    },

    copy: function(copyHistory) {
      var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first);
      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
      doc.sel = this.sel;
      doc.extend = false;
      if (copyHistory) {
        doc.history.undoDepth = this.history.undoDepth;
        doc.setHistory(this.getHistory());
      }
      return doc;
    },

    linkedDoc: function(options) {
      if (!options) options = {};
      var from = this.first, to = this.first + this.size;
      if (options.from != null && options.from > from) from = options.from;
      if (options.to != null && options.to < to) to = options.to;
      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from);
      if (options.sharedHist) copy.history = this.history;
      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
      copySharedMarkers(copy, findSharedMarkers(this));
      return copy;
    },
    unlinkDoc: function(other) {
      if (other instanceof CodeMirror) other = other.doc;
      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {
        var link = this.linked[i];
        if (link.doc != other) continue;
        this.linked.splice(i, 1);
        other.unlinkDoc(this);
        detachSharedMarkers(findSharedMarkers(this));
        break;
      }
      // If the histories were shared, split them again
      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);
        other.history = new History(null);
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function(f) {linkedDocs(this, f);},

    getMode: function() {return this.mode;},
    getEditor: function() {return this.cm;}
  });

  // Public alias.
  Doc.prototype.eachLine = Doc.prototype.iter;

  // Set up methods on CodeMirror's prototype to redirect to the editor's document.
  var dontDelegate = "iter insert remove copy getEditor".split(" ");
  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
    CodeMirror.prototype[prop] = (function(method) {
      return function() {return method.apply(this.doc, arguments);};
    })(Doc.prototype[prop]);

  eventMixin(Doc);

  // Call f for all linked documents.
  function linkedDocs(doc, f, sharedHistOnly) {
    function propagate(doc, skip, sharedHist) {
      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {
        var rel = doc.linked[i];
        if (rel.doc == skip) continue;
        var shared = sharedHist && rel.sharedHist;
        if (sharedHistOnly && !shared) continue;
        f(rel.doc, shared);
        propagate(rel.doc, doc, shared);
      }
    }
    propagate(doc, null, true);
  }

  // Attach a document to an editor.
  function attachDoc(cm, doc) {
    if (doc.cm) throw new Error("This document is already in use.");
    cm.doc = doc;
    doc.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    if (!cm.options.lineWrapping) findMaxLine(cm);
    cm.options.mode = doc.modeOption;
    regChange(cm);
  }

  // LINE UTILITIES

  // Find the line object corresponding to the given line number.
  function getLine(doc, n) {
    n -= doc.first;
    if (n < 0 || n >= doc.size) throw new Error("There is no line " + (n + doc.first) + " in the document.");
    for (var chunk = doc; !chunk.lines;) {
      for (var i = 0;; ++i) {
        var child = chunk.children[i], sz = child.chunkSize();
        if (n < sz) { chunk = child; break; }
        n -= sz;
      }
    }
    return chunk.lines[n];
  }

  // Get the part of a document between two positions, as an array of
  // strings.
  function getBetween(doc, start, end) {
    var out = [], n = start.line;
    doc.iter(start.line, end.line + 1, function(line) {
      var text = line.text;
      if (n == end.line) text = text.slice(0, end.ch);
      if (n == start.line) text = text.slice(start.ch);
      out.push(text);
      ++n;
    });
    return out;
  }
  // Get the lines between from and to, as array of strings.
  function getLines(doc, from, to) {
    var out = [];
    doc.iter(from, to, function(line) { out.push(line.text); });
    return out;
  }

  // Update the height of a line, propagating the height change
  // upwards to parent nodes.
  function updateLineHeight(line, height) {
    var diff = height - line.height;
    if (diff) for (var n = line; n; n = n.parent) n.height += diff;
  }

  // Given a line object, find its line number by walking up through
  // its parent links.
  function lineNo(line) {
    if (line.parent == null) return null;
    var cur = line.parent, no = indexOf(cur.lines, line);
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i = 0;; ++i) {
        if (chunk.children[i] == cur) break;
        no += chunk.children[i].chunkSize();
      }
    }
    return no + cur.first;
  }

  // Find the line at the given vertical position, using the height
  // information in the document tree.
  function lineAtHeight(chunk, h) {
    var n = chunk.first;
    outer: do {
      for (var i = 0; i < chunk.children.length; ++i) {
        var child = chunk.children[i], ch = child.height;
        if (h < ch) { chunk = child; continue outer; }
        h -= ch;
        n += child.chunkSize();
      }
      return n;
    } while (!chunk.lines);
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i], lh = line.height;
      if (h < lh) break;
      h -= lh;
    }
    return n + i;
  }


  // Find the height above the given line.
  function heightAtLine(lineObj) {
    lineObj = visualLine(lineObj);

    var h = 0, chunk = lineObj.parent;
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i];
      if (line == lineObj) break;
      else h += line.height;
    }
    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i = 0; i < p.children.length; ++i) {
        var cur = p.children[i];
        if (cur == chunk) break;
        else h += cur.height;
      }
    }
    return h;
  }

  // Get the bidi ordering for the given line (and cache it). Returns
  // false for lines that are fully left-to-right, and an array of
  // BidiSpan objects otherwise.
  function getOrder(line) {
    var order = line.order;
    if (order == null) order = line.order = bidiOrdering(line.text);
    return order;
  }

  // HISTORY

  function History(startGen) {
    // Arrays of change events and selections. Doing something adds an
    // event to done and clears undo. Undoing moves events from done
    // to undone, redoing moves them in the other direction.
    this.done = []; this.undone = [];
    this.undoDepth = Infinity;
    // Used to track when changes can be merged into a single undo
    // event
    this.lastModTime = this.lastSelTime = 0;
    this.lastOp = null;
    this.lastOrigin = this.lastSelOrigin = null;
    // Used by the isClean() method
    this.generation = this.maxGeneration = startGen || 1;
  }

  // Create a history change event from an updateDoc-style change
  // object.
  function historyChangeFromChange(doc, change) {
    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);
    return histChange;
  }

  // Pop all selection events off the end of a history array. Stop at
  // a change event.
  function clearSelectionEvents(array) {
    while (array.length) {
      var last = lst(array);
      if (last.ranges) array.pop();
      else break;
    }
  }

  // Find the top change event in the history. Pop off selection
  // events that are in the way.
  function lastChangeEvent(hist, force) {
    if (force) {
      clearSelectionEvents(hist.done);
      return lst(hist.done);
    } else if (hist.done.length && !lst(hist.done).ranges) {
      return lst(hist.done);
    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
      hist.done.pop();
      return lst(hist.done);
    }
  }

  // Register a change in the history. Merges changes that are within
  // a single operation, ore are close together with an origin that
  // allows merging (starting with "+") into a single event.
  function addChangeToHistory(doc, change, selAfter, opId) {
    var hist = doc.history;
    hist.undone.length = 0;
    var time = +new Date, cur;

    if ((hist.lastOp == opId ||
         hist.lastOrigin == change.origin && change.origin &&
         ((change.origin.charAt(0) == "+" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||
          change.origin.charAt(0) == "*")) &&
        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
      // Merge this change into the last event
      var last = lst(cur.changes);
      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
        // Optimized case for simple insertion -- don't want to add
        // new changesets for every character typed
        last.to = changeEnd(change);
      } else {
        // Add new sub-event
        cur.changes.push(historyChangeFromChange(doc, change));
      }
    } else {
      // Can not be merged, start a new event.
      var before = lst(hist.done);
      if (!before || !before.ranges)
        pushSelectionToHistory(doc.sel, hist.done);
      cur = {changes: [historyChangeFromChange(doc, change)],
             generation: hist.generation};
      hist.done.push(cur);
      while (hist.done.length > hist.undoDepth) {
        hist.done.shift();
        if (!hist.done[0].ranges) hist.done.shift();
      }
    }
    hist.done.push(selAfter);
    hist.generation = ++hist.maxGeneration;
    hist.lastModTime = hist.lastSelTime = time;
    hist.lastOp = opId;
    hist.lastOrigin = hist.lastSelOrigin = change.origin;

    if (!last) signal(doc, "historyAdded");
  }

  function selectionEventCanBeMerged(doc, origin, prev, sel) {
    var ch = origin.charAt(0);
    return ch == "*" ||
      ch == "+" &&
      prev.ranges.length == sel.ranges.length &&
      prev.somethingSelected() == sel.somethingSelected() &&
      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
  }

  // Called whenever the selection changes, sets the new selection as
  // the pending selection in the history, and pushes the old pending
  // selection into the 'done' array when it was significantly
  // different (in number of selected ranges, emptiness, or time).
  function addSelectionToHistory(doc, sel, opId, options) {
    var hist = doc.history, origin = options && options.origin;

    // A new event is started when the previous origin does not match
    // the current, or the origins don't allow matching. Origins
    // starting with * are always merged, those starting with + are
    // merged when similar and close together in time.
    if (opId == hist.lastOp ||
        (origin && hist.lastSelOrigin == origin &&
         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
      hist.done[hist.done.length - 1] = sel;
    else
      pushSelectionToHistory(sel, hist.done);

    hist.lastSelTime = +new Date;
    hist.lastSelOrigin = origin;
    hist.lastOp = opId;
    if (options && options.clearRedo !== false)
      clearSelectionEvents(hist.undone);
  }

  function pushSelectionToHistory(sel, dest) {
    var top = lst(dest);
    if (!(top && top.ranges && top.equals(sel)))
      dest.push(sel);
  }

  // Used to store marked span information in the history.
  function attachLocalSpans(doc, change, from, to) {
    var existing = change["spans_" + doc.id], n = 0;
    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {
      if (line.markedSpans)
        (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;
      ++n;
    });
  }

  // When un/re-doing restores text containing marked spans, those
  // that have been explicitly cleared should not be restored.
  function removeClearedSpans(spans) {
    if (!spans) return null;
    for (var i = 0, out; i < spans.length; ++i) {
      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }
      else if (out) out.push(spans[i]);
    }
    return !out ? spans : out.length ? out : null;
  }

  // Retrieve and filter the old marked spans stored in a change event.
  function getOldSpans(doc, change) {
    var found = change["spans_" + doc.id];
    if (!found) return null;
    for (var i = 0, nw = []; i < change.text.length; ++i)
      nw.push(removeClearedSpans(found[i]));
    return nw;
  }

  // Used both to provide a JSON-safe object in .getHistory, and, when
  // detaching a document, to split the history in two
  function copyHistoryArray(events, newGroup, instantiateSel) {
    for (var i = 0, copy = []; i < events.length; ++i) {
      var event = events[i];
      if (event.ranges) {
        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
        continue;
      }
      var changes = event.changes, newChanges = [];
      copy.push({changes: newChanges});
      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j], m;
        newChanges.push({from: change.from, to: change.to, text: change.text});
        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\d+)$/)) {
          if (indexOf(newGroup, Number(m[1])) > -1) {
            lst(newChanges)[prop] = change[prop];
            delete change[prop];
          }
        }
      }
    }
    return copy;
  }

  // Rebasing/resetting history to deal with externally-sourced changes

  function rebaseHistSelSingle(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  }

  // Tries to rebase an array of history events given a change in the
  // document. If the change touches the same lines as the event, the
  // event, and everything 'behind' it, is discarded. If the change is
  // before the event, the event's positions are updated. Uses a
  // copy-on-write scheme for the positions, to avoid having to
  // reallocate them all on every rebase, but also avoid problems with
  // shared position objects being unsafely updated.
  function rebaseHistArray(array, from, to, diff) {
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i], ok = true;
      if (sub.ranges) {
        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }
        for (var j = 0; j < sub.ranges.length; j++) {
          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
        }
        continue;
      }
      for (var j = 0; j < sub.changes.length; ++j) {
        var cur = sub.changes[j];
        if (to < cur.from.line) {
          cur.from = Pos(cur.from.line + diff, cur.from.ch);
          cur.to = Pos(cur.to.line + diff, cur.to.ch);
        } else if (from <= cur.to.line) {
          ok = false;
          break;
        }
      }
      if (!ok) {
        array.splice(0, i + 1);
        i = 0;
      }
    }
  }

  function rebaseHist(hist, change) {
    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  }

  // EVENT UTILITIES

  // Due to the fact that we still support jurassic IE versions, some
  // compatibility wrappers are needed.

  var e_preventDefault = CodeMirror.e_preventDefault = function(e) {
    if (e.preventDefault) e.preventDefault();
    else e.returnValue = false;
  };
  var e_stopPropagation = CodeMirror.e_stopPropagation = function(e) {
    if (e.stopPropagation) e.stopPropagation();
    else e.cancelBubble = true;
  };
  function e_defaultPrevented(e) {
    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
  }
  var e_stop = CodeMirror.e_stop = function(e) {e_preventDefault(e); e_stopPropagation(e);};

  function e_target(e) {return e.target || e.srcElement;}
  function e_button(e) {
    var b = e.which;
    if (b == null) {
      if (e.button & 1) b = 1;
      else if (e.button & 2) b = 3;
      else if (e.button & 4) b = 2;
    }
    if (mac && e.ctrlKey && b == 1) b = 3;
    return b;
  }

  // EVENT HANDLING

  // Lightweight event framework. on/off also work on DOM nodes,
  // registering native DOM handlers.

  var on = CodeMirror.on = function(emitter, type, f) {
    if (emitter.addEventListener)
      emitter.addEventListener(type, f, false);
    else if (emitter.attachEvent)
      emitter.attachEvent("on" + type, f);
    else {
      var map = emitter._handlers || (emitter._handlers = {});
      var arr = map[type] || (map[type] = []);
      arr.push(f);
    }
  };

  var off = CodeMirror.off = function(emitter, type, f) {
    if (emitter.removeEventListener)
      emitter.removeEventListener(type, f, false);
    else if (emitter.detachEvent)
      emitter.detachEvent("on" + type, f);
    else {
      var arr = emitter._handlers && emitter._handlers[type];
      if (!arr) return;
      for (var i = 0; i < arr.length; ++i)
        if (arr[i] == f) { arr.splice(i, 1); break; }
    }
  };

  var signal = CodeMirror.signal = function(emitter, type /*, values...*/) {
    var arr = emitter._handlers && emitter._handlers[type];
    if (!arr) return;
    var args = Array.prototype.slice.call(arguments, 2);
    for (var i = 0; i < arr.length; ++i) arr[i].apply(null, args);
  };

  // Often, we want to signal events at a point where we are in the
  // middle of some work, but don't want the handler to start calling
  // other methods on the editor, which might be in an inconsistent
  // state or simply not expect any other events to happen.
  // signalLater looks whether there are any handlers, and schedules
  // them to be executed when the last operation ends, or, if no
  // operation is active, when a timeout fires.
  var delayedCallbacks, delayedCallbackDepth = 0;
  function signalLater(emitter, type /*, values...*/) {
    var arr = emitter._handlers && emitter._handlers[type];
    if (!arr) return;
    var args = Array.prototype.slice.call(arguments, 2);
    if (!delayedCallbacks) {
      ++delayedCallbackDepth;
      delayedCallbacks = [];
      setTimeout(fireDelayed, 0);
    }
    function bnd(f) {return function(){f.apply(null, args);};};
    for (var i = 0; i < arr.length; ++i)
      delayedCallbacks.push(bnd(arr[i]));
  }

  function fireDelayed() {
    --delayedCallbackDepth;
    var delayed = delayedCallbacks;
    delayedCallbacks = null;
    for (var i = 0; i < delayed.length; ++i) delayed[i]();
  }

  // The DOM events that CodeMirror handles can be overridden by
  // registering a (non-DOM) handler on the editor for the event name,
  // and preventDefault-ing the event in that handler.
  function signalDOMEvent(cm, e, override) {
    signal(cm, override || e.type, cm, e);
    return e_defaultPrevented(e) || e.codemirrorIgnore;
  }

  function signalCursorActivity(cm) {
    var arr = cm._handlers && cm._handlers.cursorActivity;
    if (!arr) return;
    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
    for (var i = 0; i < arr.length; ++i) if (indexOf(set, arr[i]) == -1)
      set.push(arr[i]);
  }

  function hasHandler(emitter, type) {
    var arr = emitter._handlers && emitter._handlers[type];
    return arr && arr.length > 0;
  }

  // Add on and off methods to a constructor's prototype, to make
  // registering events on such objects more convenient.
  function eventMixin(ctor) {
    ctor.prototype.on = function(type, f) {on(this, type, f);};
    ctor.prototype.off = function(type, f) {off(this, type, f);};
  }

  // MISC UTILITIES

  // Number of pixels added to scroller and sizer to hide scrollbar
  var scrollerCutOff = 30;

  // Returned or thrown by various protocols to signal 'I'm not
  // handling this'.
  var Pass = CodeMirror.Pass = {toString: function(){return "CodeMirror.Pass";}};

  // Reused option objects for setSelection & friends
  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: "*mouse"}, sel_move = {origin: "+move"};

  function Delayed() {this.id = null;}
  Delayed.prototype.set = function(ms, f) {
    clearTimeout(this.id);
    this.id = setTimeout(f, ms);
  };

  // Counts the column offset in a string, taking tabs into account.
  // Used mostly to find indentation.
  var countColumn = CodeMirror.countColumn = function(string, end, tabSize, startIndex, startValue) {
    if (end == null) {
      end = string.search(/[^\s\u00a0]/);
      if (end == -1) end = string.length;
    }
    for (var i = startIndex || 0, n = startValue || 0;;) {
      var nextTab = string.indexOf("\t", i);
      if (nextTab < 0 || nextTab >= end)
        return n + (end - i);
      n += nextTab - i;
      n += tabSize - (n % tabSize);
      i = nextTab + 1;
    }
  };

  // The inverse of countColumn -- find the offset that corresponds to
  // a particular column.
  function findColumn(string, goal, tabSize) {
    for (var pos = 0, col = 0;;) {
      var nextTab = string.indexOf("\t", pos);
      if (nextTab == -1) nextTab = string.length;
      var skipped = nextTab - pos;
      if (nextTab == string.length || col + skipped >= goal)
        return pos + Math.min(skipped, goal - col);
      col += nextTab - pos;
      col += tabSize - (col % tabSize);
      pos = nextTab + 1;
      if (col >= goal) return pos;
    }
  }

  var spaceStrs = [""];
  function spaceStr(n) {
    while (spaceStrs.length <= n)
      spaceStrs.push(lst(spaceStrs) + " ");
    return spaceStrs[n];
  }

  function lst(arr) { return arr[arr.length-1]; }

  var selectInput = function(node) { node.select(); };
  if (ios) // Mobile Safari apparently has a bug where select() is broken.
    selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; };
  else if (ie) // Suppress mysterious IE10 errors
    selectInput = function(node) { try { node.select(); } catch(_e) {} };

  function indexOf(array, elt) {
    for (var i = 0; i < array.length; ++i)
      if (array[i] == elt) return i;
    return -1;
  }
  if ([].indexOf) indexOf = function(array, elt) { return array.indexOf(elt); };
  function map(array, f) {
    var out = [];
    for (var i = 0; i < array.length; i++) out[i] = f(array[i], i);
    return out;
  }
  if ([].map) map = function(array, f) { return array.map(f); };

  function createObj(base, props) {
    var inst;
    if (Object.create) {
      inst = Object.create(base);
    } else {
      var ctor = function() {};
      ctor.prototype = base;
      inst = new ctor();
    }
    if (props) copyObj(props, inst);
    return inst;
  };

  function copyObj(obj, target, overwrite) {
    if (!target) target = {};
    for (var prop in obj)
      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
        target[prop] = obj[prop];
    return target;
  }

  function bind(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function(){return f.apply(null, args);};
  }

  var nonASCIISingleCaseWordChar = /[\u00df\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  var isWordChar = CodeMirror.isWordChar = function(ch) {
    return /\w/.test(ch) || ch > "\x80" &&
      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
  };

  function isEmpty(obj) {
    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;
    return true;
  }

  // Extending unicode characters. A series of a non-extending char +
  // any number of extending chars is treated as a single unit as far
  // as editing and measuring is concerned. This is not fully correct,
  // since some scripts/fonts/browsers also treat other configurations
  // of code points as a group.
  var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch); }

  // DOM UTILITIES

  function elt(tag, content, className, style) {
    var e = document.createElement(tag);
    if (className) e.className = className;
    if (style) e.style.cssText = style;
    if (typeof content == "string") e.appendChild(document.createTextNode(content));
    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);
    return e;
  }

  var range;
  if (document.createRange) range = function(node, start, end) {
    var r = document.createRange();
    r.setEnd(node, end);
    r.setStart(node, start);
    return r;
  };
  else range = function(node, start, end) {
    var r = document.body.createTextRange();
    r.moveToElementText(node.parentNode);
    r.collapse(true);
    r.moveEnd("character", end);
    r.moveStart("character", start);
    return r;
  };

  function removeChildren(e) {
    for (var count = e.childNodes.length; count > 0; --count)
      e.removeChild(e.firstChild);
    return e;
  }

  function removeChildrenAndAdd(parent, e) {
    return removeChildren(parent).appendChild(e);
  }

  function contains(parent, child) {
    if (parent.contains)
      return parent.contains(child);
    while (child = child.parentNode)
      if (child == parent) return true;
  }

  function activeElt() { return document.activeElement; }
  // Older versions of IE throws unspecified error when touching
  // document.activeElement in some cases (during loading, in iframe)
  if (ie_upto10) activeElt = function() {
    try { return document.activeElement; }
    catch(e) { return document.body; }
  };

  function classTest(cls) { return new RegExp("\\b" + cls + "\\b\\s*"); }
  function rmClass(node, cls) {
    var test = classTest(cls);
    if (test.test(node.className)) node.className = node.className.replace(test, "");
  }
  function addClass(node, cls) {
    if (!classTest(cls).test(node.className)) node.className += " " + cls;
  }
  function joinClasses(a, b) {
    var as = a.split(" ");
    for (var i = 0; i < as.length; i++)
      if (as[i] && !classTest(as[i]).test(b)) b += " " + as[i];
    return b;
  }

  // FEATURE DETECTION

  // Detect drag-and-drop
  var dragAndDrop = function() {
    // There is *some* kind of drag-and-drop support in IE6-8, but I
    // couldn't get it to work yet.
    if (ie_upto8) return false;
    var div = elt('div');
    return "draggable" in div || "dragDrop" in div;
  }();

  var knownScrollbarWidth;
  function scrollbarWidth(measure) {
    if (knownScrollbarWidth != null) return knownScrollbarWidth;
    var test = elt("div", null, null, "width: 50px; height: 50px; overflow-x: scroll");
    removeChildrenAndAdd(measure, test);
    if (test.offsetWidth)
      knownScrollbarWidth = test.offsetHeight - test.clientHeight;
    return knownScrollbarWidth || 0;
  }

  var zwspSupported;
  function zeroWidthElement(measure) {
    if (zwspSupported == null) {
      var test = elt("span", "\u200b");
      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
      if (measure.firstChild.offsetHeight != 0)
        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !ie_upto7;
    }
    if (zwspSupported) return elt("span", "\u200b");
    else return elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
  }

  // Feature-detect IE's crummy client rect reporting for bidi text
  var badBidiRects;
  function hasBadBidiRects(measure) {
    if (badBidiRects != null) return badBidiRects;
    var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
    var r0 = range(txt, 0, 1).getBoundingClientRect();
    if (r0.left == r0.right) return false;
    var r1 = range(txt, 1, 2).getBoundingClientRect();
    return badBidiRects = (r1.right - r0.right < 3);
  }

  // See if "".split is the broken IE version, if so, provide an
  // alternative way to split lines.
  var splitLines = CodeMirror.splitLines = "\n\nb".split(/\n/).length != 3 ? function(string) {
    var pos = 0, result = [], l = string.length;
    while (pos <= l) {
      var nl = string.indexOf("\n", pos);
      if (nl == -1) nl = string.length;
      var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
      var rt = line.indexOf("\r");
      if (rt != -1) {
        result.push(line.slice(0, rt));
        pos += rt + 1;
      } else {
        result.push(line);
        pos = nl + 1;
      }
    }
    return result;
  } : function(string){return string.split(/\r\n?|\n/);};

  var hasSelection = window.getSelection ? function(te) {
    try { return te.selectionStart != te.selectionEnd; }
    catch(e) { return false; }
  } : function(te) {
    try {var range = te.ownerDocument.selection.createRange();}
    catch(e) {}
    if (!range || range.parentElement() != te) return false;
    return range.compareEndPoints("StartToEnd", range) != 0;
  };

  var hasCopyEvent = (function() {
    var e = elt("div");
    if ("oncopy" in e) return true;
    e.setAttribute("oncopy", "return;");
    return typeof e.oncopy == "function";
  })();

  // KEY NAMES

  var keyNames = {3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
                  19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
                  36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
                  46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod", 107: "=", 109: "-", 127: "Delete",
                  173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
                  221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
                  63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"};
  CodeMirror.keyNames = keyNames;
  (function() {
    // Number keys
    for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);
    // Alphabetic keys
    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);
    // Function keys
    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = "F" + i;
  })();

  // BIDI HELPERS

  function iterateBidiSections(order, from, to, f) {
    if (!order) return f(from, to, "ltr");
    var found = false;
    for (var i = 0; i < order.length; ++i) {
      var part = order[i];
      if (part.from < to && part.to > from || from == to && part.to == from) {
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr");
        found = true;
      }
    }
    if (!found) f(from, to, "ltr");
  }

  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }
  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }

  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }
  function lineRight(line) {
    var order = getOrder(line);
    if (!order) return line.text.length;
    return bidiRight(lst(order));
  }

  function lineStart(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLine(line);
    if (visual != line) lineN = lineNo(visual);
    var order = getOrder(visual);
    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);
    return Pos(lineN, ch);
  }
  function lineEnd(cm, lineN) {
    var merged, line = getLine(cm.doc, lineN);
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
      lineN = null;
    }
    var order = getOrder(line);
    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);
    return Pos(lineN == null ? lineNo(line) : lineN, ch);
  }

  function compareBidiLevel(order, a, b) {
    var linedir = order[0].level;
    if (a == linedir) return true;
    if (b == linedir) return false;
    return a < b;
  }
  var bidiOther;
  function getBidiPartAt(order, pos) {
    bidiOther = null;
    for (var i = 0, found; i < order.length; ++i) {
      var cur = order[i];
      if (cur.from < pos && cur.to > pos) return i;
      if ((cur.from == pos || cur.to == pos)) {
        if (found == null) {
          found = i;
        } else if (compareBidiLevel(order, cur.level, order[found].level)) {
          if (cur.from != cur.to) bidiOther = found;
          return i;
        } else {
          if (cur.from != cur.to) bidiOther = i;
          return found;
        }
      }
    }
    return found;
  }

  function moveInLine(line, pos, dir, byUnit) {
    if (!byUnit) return pos + dir;
    do pos += dir;
    while (pos > 0 && isExtendingChar(line.text.charAt(pos)));
    return pos;
  }

  // This is needed in order to move 'visually' through bi-directional
  // text -- i.e., pressing left should make the cursor go left, even
  // when in RTL text. The tricky part is the 'jumps', where RTL and
  // LTR text touch each other. This often requires the cursor offset
  // to move more than one unit, in order to visually move one unit.
  function moveVisually(line, start, dir, byUnit) {
    var bidi = getOrder(line);
    if (!bidi) return moveLogically(line, start, dir, byUnit);
    var pos = getBidiPartAt(bidi, start), part = bidi[pos];
    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);

    for (;;) {
      if (target > part.from && target < part.to) return target;
      if (target == part.from || target == part.to) {
        if (getBidiPartAt(bidi, target) == pos) return target;
        part = bidi[pos += dir];
        return (dir > 0) == part.level % 2 ? part.to : part.from;
      } else {
        part = bidi[pos += dir];
        if (!part) return null;
        if ((dir > 0) == part.level % 2)
          target = moveInLine(line, part.to, -1, byUnit);
        else
          target = moveInLine(line, part.from, 1, byUnit);
      }
    }
  }

  function moveLogically(line, start, dir, byUnit) {
    var target = start + dir;
    if (byUnit) while (target > 0 && isExtendingChar(line.text.charAt(target))) target += dir;
    return target < 0 || target > line.text.length ? null : target;
  }

  // Bidirectional ordering algorithm
  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
  // that this (partially) implements.

  // One-char codes used for character types:
  // L (L):   Left-to-Right
  // R (R):   Right-to-Left
  // r (AL):  Right-to-Left Arabic
  // 1 (EN):  European Number
  // + (ES):  European Number Separator
  // % (ET):  European Number Terminator
  // n (AN):  Arabic Number
  // , (CS):  Common Number Separator
  // m (NSM): Non-Spacing Mark
  // b (BN):  Boundary Neutral
  // s (B):   Paragraph Separator
  // t (S):   Segment Separator
  // w (WS):  Whitespace
  // N (ON):  Other Neutrals

  // Returns null if characters are ordered as they appear
  // (left-to-right), or an array of sections ({from, to, level}
  // objects) in the order in which they occur visually.
  var bidiOrdering = (function() {
    // Character types for codepoints 0 to 0xff
    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
    // Character types for codepoints 0x600 to 0x6ff
    var arabicTypes = "rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm";
    function charType(code) {
      if (code <= 0xf7) return lowTypes.charAt(code);
      else if (0x590 <= code && code <= 0x5f4) return "R";
      else if (0x600 <= code && code <= 0x6ed) return arabicTypes.charAt(code - 0x600);
      else if (0x6ee <= code && code <= 0x8ac) return "r";
      else if (0x2000 <= code && code <= 0x200b) return "w";
      else if (code == 0x200c) return "b";
      else return "L";
    }

    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
    // Browsers seem to always treat the boundaries of block elements as being L.
    var outerType = "L";

    function BidiSpan(level, from, to) {
      this.level = level;
      this.from = from; this.to = to;
    }

    return function(str) {
      if (!bidiRE.test(str)) return false;
      var len = str.length, types = [];
      for (var i = 0, type; i < len; ++i)
        types.push(type = charType(str.charCodeAt(i)));

      // W1. Examine each non-spacing mark (NSM) in the level run, and
      // change the type of the NSM to the type of the previous
      // character. If the NSM is at the start of the level run, it will
      // get the type of sor.
      for (var i = 0, prev = outerType; i < len; ++i) {
        var type = types[i];
        if (type == "m") types[i] = prev;
        else prev = type;
      }

      // W2. Search backwards from each instance of a European number
      // until the first strong type (R, L, AL, or sor) is found. If an
      // AL is found, change the type of the European number to Arabic
      // number.
      // W3. Change all ALs to R.
      for (var i = 0, cur = outerType; i < len; ++i) {
        var type = types[i];
        if (type == "1" && cur == "r") types[i] = "n";
        else if (isStrong.test(type)) { cur = type; if (type == "r") types[i] = "R"; }
      }

      // W4. A single European separator between two European numbers
      // changes to a European number. A single common separator between
      // two numbers of the same type changes to that type.
      for (var i = 1, prev = types[0]; i < len - 1; ++i) {
        var type = types[i];
        if (type == "+" && prev == "1" && types[i+1] == "1") types[i] = "1";
        else if (type == "," && prev == types[i+1] &&
                 (prev == "1" || prev == "n")) types[i] = prev;
        prev = type;
      }

      // W5. A sequence of European terminators adjacent to European
      // numbers changes to all European numbers.
      // W6. Otherwise, separators and terminators change to Other
      // Neutral.
      for (var i = 0; i < len; ++i) {
        var type = types[i];
        if (type == ",") types[i] = "N";
        else if (type == "%") {
          for (var end = i + 1; end < len && types[end] == "%"; ++end) {}
          var replace = (i && types[i-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
          for (var j = i; j < end; ++j) types[j] = replace;
          i = end - 1;
        }
      }

      // W7. Search backwards from each instance of a European number
      // until the first strong type (R, L, or sor) is found. If an L is
      // found, then change the type of the European number to L.
      for (var i = 0, cur = outerType; i < len; ++i) {
        var type = types[i];
        if (cur == "L" && type == "1") types[i] = "L";
        else if (isStrong.test(type)) cur = type;
      }

      // N1. A sequence of neutrals takes the direction of the
      // surrounding strong text if the text on both sides has the same
      // direction. European and Arabic numbers act as if they were R in
      // terms of their influence on neutrals. Start-of-level-run (sor)
      // and end-of-level-run (eor) are used at level run boundaries.
      // N2. Any remaining neutrals take the embedding direction.
      for (var i = 0; i < len; ++i) {
        if (isNeutral.test(types[i])) {
          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}
          var before = (i ? types[i-1] : outerType) == "L";
          var after = (end < len ? types[end] : outerType) == "L";
          var replace = before || after ? "L" : "R";
          for (var j = i; j < end; ++j) types[j] = replace;
          i = end - 1;
        }
      }

      // Here we depart from the documented algorithm, in order to avoid
      // building up an actual levels array. Since there are only three
      // levels (0, 1, 2) in an implementation that doesn't take
      // explicit embedding into account, we can build up the order on
      // the fly, without following the level-based algorithm.
      var order = [], m;
      for (var i = 0; i < len;) {
        if (countsAsLeft.test(types[i])) {
          var start = i;
          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}
          order.push(new BidiSpan(0, start, i));
        } else {
          var pos = i, at = order.length;
          for (++i; i < len && types[i] != "L"; ++i) {}
          for (var j = pos; j < i;) {
            if (countsAsNum.test(types[j])) {
              if (pos < j) order.splice(at, 0, new BidiSpan(1, pos, j));
              var nstart = j;
              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}
              order.splice(at, 0, new BidiSpan(2, nstart, j));
              pos = j;
            } else ++j;
          }
          if (pos < i) order.splice(at, 0, new BidiSpan(1, pos, i));
        }
      }
      if (order[0].level == 1 && (m = str.match(/^\s+/))) {
        order[0].from = m[0].length;
        order.unshift(new BidiSpan(0, 0, m[0].length));
      }
      if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
        lst(order).to -= m[0].length;
        order.push(new BidiSpan(0, len - m[0].length, len));
      }
      if (order[0].level != lst(order).level)
        order.push(new BidiSpan(order[0].level, len, len));

      return order;
    };
  })();

  // THE END

  CodeMirror.version = "4.1.0";

  return CodeMirror;
});

},{}],23:[function(require,module,exports){
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("clike", function(config, parserConfig) {
  var indentUnit = config.indentUnit,
      statementIndentUnit = parserConfig.statementIndentUnit || indentUnit,
      dontAlignCalls = parserConfig.dontAlignCalls,
      keywords = parserConfig.keywords || {},
      builtin = parserConfig.builtin || {},
      blockKeywords = parserConfig.blockKeywords || {},
      atoms = parserConfig.atoms || {},
      hooks = parserConfig.hooks || {},
      multiLineStrings = parserConfig.multiLineStrings;
  var isOperatorChar = /[+\-*&%=<>!?|\/]/;

  var curPunc;

  function tokenBase(stream, state) {
    var ch = stream.next();
    if (hooks[ch]) {
      var result = hooks[ch](stream, state);
      if (result !== false) return result;
    }
    if (ch == '"' || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    }
    if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
      curPunc = ch;
      return null;
    }
    if (/\d/.test(ch)) {
      stream.eatWhile(/[\w\.]/);
      return "number";
    }
    if (ch == "/") {
      if (stream.eat("*")) {
        state.tokenize = tokenComment;
        return tokenComment(stream, state);
      }
      if (stream.eat("/")) {
        stream.skipToEnd();
        return "comment";
      }
    }
    if (isOperatorChar.test(ch)) {
      stream.eatWhile(isOperatorChar);
      return "operator";
    }
    stream.eatWhile(/[\w\$_]/);
    var cur = stream.current();
    if (keywords.propertyIsEnumerable(cur)) {
      if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
      return "keyword";
    }
    if (builtin.propertyIsEnumerable(cur)) {
      if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
      return "builtin";
    }
    if (atoms.propertyIsEnumerable(cur)) return "atom";
    return "variable";
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, next, end = false;
      while ((next = stream.next()) != null) {
        if (next == quote && !escaped) {end = true; break;}
        escaped = !escaped && next == "\\";
      }
      if (end || !(escaped || multiLineStrings))
        state.tokenize = null;
      return "string";
    };
  }

  function tokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" && maybeEnd) {
        state.tokenize = null;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return "comment";
  }

  function Context(indented, column, type, align, prev) {
    this.indented = indented;
    this.column = column;
    this.type = type;
    this.align = align;
    this.prev = prev;
  }
  function pushContext(state, col, type) {
    var indent = state.indented;
    if (state.context && state.context.type == "statement")
      indent = state.context.indented;
    return state.context = new Context(indent, col, type, null, state.context);
  }
  function popContext(state) {
    var t = state.context.type;
    if (t == ")" || t == "]" || t == "}")
      state.indented = state.context.indented;
    return state.context = state.context.prev;
  }

  // Interface

  return {
    startState: function(basecolumn) {
      return {
        tokenize: null,
        context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),
        indented: 0,
        startOfLine: true
      };
    },

    token: function(stream, state) {
      var ctx = state.context;
      if (stream.sol()) {
        if (ctx.align == null) ctx.align = false;
        state.indented = stream.indentation();
        state.startOfLine = true;
      }
      if (stream.eatSpace()) return null;
      curPunc = null;
      var style = (state.tokenize || tokenBase)(stream, state);
      if (style == "comment" || style == "meta") return style;
      if (ctx.align == null) ctx.align = true;

      if ((curPunc == ";" || curPunc == ":" || curPunc == ",") && ctx.type == "statement") popContext(state);
      else if (curPunc == "{") pushContext(state, stream.column(), "}");
      else if (curPunc == "[") pushContext(state, stream.column(), "]");
      else if (curPunc == "(") pushContext(state, stream.column(), ")");
      else if (curPunc == "}") {
        while (ctx.type == "statement") ctx = popContext(state);
        if (ctx.type == "}") ctx = popContext(state);
        while (ctx.type == "statement") ctx = popContext(state);
      }
      else if (curPunc == ctx.type) popContext(state);
      else if (((ctx.type == "}" || ctx.type == "top") && curPunc != ';') || (ctx.type == "statement" && curPunc == "newstatement"))
        pushContext(state, stream.column(), "statement");
      state.startOfLine = false;
      return style;
    },

    indent: function(state, textAfter) {
      if (state.tokenize != tokenBase && state.tokenize != null) return CodeMirror.Pass;
      var ctx = state.context, firstChar = textAfter && textAfter.charAt(0);
      if (ctx.type == "statement" && firstChar == "}") ctx = ctx.prev;
      var closing = firstChar == ctx.type;
      if (ctx.type == "statement") return ctx.indented + (firstChar == "{" ? 0 : statementIndentUnit);
      else if (ctx.align && (!dontAlignCalls || ctx.type != ")")) return ctx.column + (closing ? 0 : 1);
      else if (ctx.type == ")" && !closing) return ctx.indented + statementIndentUnit;
      else return ctx.indented + (closing ? 0 : indentUnit);
    },

    electricChars: "{}",
    blockCommentStart: "/*",
    blockCommentEnd: "*/",
    lineComment: "//",
    fold: "brace"
  };
});

  function words(str) {
    var obj = {}, words = str.split(" ");
    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
    return obj;
  }
  var cKeywords = "auto if break int case long char register continue return default short do sizeof " +
    "double static else struct entry switch extern typedef float union for unsigned " +
    "goto while enum void const signed volatile";

  function cppHook(stream, state) {
    if (!state.startOfLine) return false;
    for (;;) {
      if (stream.skipTo("\\")) {
        stream.next();
        if (stream.eol()) {
          state.tokenize = cppHook;
          break;
        }
      } else {
        stream.skipToEnd();
        state.tokenize = null;
        break;
      }
    }
    return "meta";
  }

  function cpp11StringHook(stream, state) {
    stream.backUp(1);
    // Raw strings.
    if (stream.match(/(R|u8R|uR|UR|LR)/)) {
      var match = stream.match(/"(.{0,16})\(/);
      if (!match) {
        return false;
      }
      state.cpp11RawStringDelim = match[1];
      state.tokenize = tokenRawString;
      return tokenRawString(stream, state);
    }
    // Unicode strings/chars.
    if (stream.match(/(u8|u|U|L)/)) {
      if (stream.match(/["']/, /* eat */ false)) {
        return "string";
      }
      return false;
    }
    // Ignore this hook.
    stream.next();
    return false;
  }

  // C#-style strings where "" escapes a quote.
  function tokenAtString(stream, state) {
    var next;
    while ((next = stream.next()) != null) {
      if (next == '"' && !stream.eat('"')) {
        state.tokenize = null;
        break;
      }
    }
    return "string";
  }

  // C++11 raw string literal is <prefix>"<delim>( anything )<delim>", where
  // <delim> can be a string up to 16 characters long.
  function tokenRawString(stream, state) {
    var closingSequence = new RegExp(".*?\\)" + state.cpp11RawStringDelim + '"');
    var match = stream.match(closingSequence);
    if (match) {
      state.tokenize = null;
    } else {
      stream.skipToEnd();
    }
    return "string";
  }

  function def(mimes, mode) {
    if (typeof mimes == "string") mimes = [mimes];
    var words = [];
    function add(obj) {
      if (obj) for (var prop in obj) if (obj.hasOwnProperty(prop))
        words.push(prop);
    }
    add(mode.keywords);
    add(mode.builtin);
    add(mode.atoms);
    if (words.length) {
      mode.helperType = mimes[0];
      CodeMirror.registerHelper("hintWords", mimes[0], words);
    }

    for (var i = 0; i < mimes.length; ++i)
      CodeMirror.defineMIME(mimes[i], mode);
  }

  def(["text/x-csrc", "text/x-c", "text/x-chdr"], {
    name: "clike",
    keywords: words(cKeywords),
    blockKeywords: words("case do else for if switch while struct"),
    atoms: words("null"),
    hooks: {"#": cppHook},
    modeProps: {fold: ["brace", "include"]}
  });

  def(["text/x-c++src", "text/x-c++hdr"], {
    name: "clike",
    keywords: words(cKeywords + " asm dynamic_cast namespace reinterpret_cast try bool explicit new " +
                    "static_cast typeid catch operator template typename class friend private " +
                    "this using const_cast inline public throw virtual delete mutable protected " +
                    "wchar_t alignas alignof constexpr decltype nullptr noexcept thread_local final " +
                    "static_assert override"),
    blockKeywords: words("catch class do else finally for if struct switch try while"),
    atoms: words("true false null"),
    hooks: {
      "#": cppHook,
      "u": cpp11StringHook,
      "U": cpp11StringHook,
      "L": cpp11StringHook,
      "R": cpp11StringHook
    },
    modeProps: {fold: ["brace", "include"]}
  });
  def("text/x-java", {
    name: "clike",
    keywords: words("abstract assert boolean break byte case catch char class const continue default " +
                    "do double else enum extends final finally float for goto if implements import " +
                    "instanceof int interface long native new package private protected public " +
                    "return short static strictfp super switch synchronized this throw throws transient " +
                    "try void volatile while"),
    blockKeywords: words("catch class do else finally for if switch try while"),
    atoms: words("true false null"),
    hooks: {
      "@": function(stream) {
        stream.eatWhile(/[\w\$_]/);
        return "meta";
      }
    },
    modeProps: {fold: ["brace", "import"]}
  });
  def("text/x-csharp", {
    name: "clike",
    keywords: words("abstract as base break case catch checked class const continue" +
                    " default delegate do else enum event explicit extern finally fixed for" +
                    " foreach goto if implicit in interface internal is lock namespace new" +
                    " operator out override params private protected public readonly ref return sealed" +
                    " sizeof stackalloc static struct switch this throw try typeof unchecked" +
                    " unsafe using virtual void volatile while add alias ascending descending dynamic from get" +
                    " global group into join let orderby partial remove select set value var yield"),
    blockKeywords: words("catch class do else finally for foreach if struct switch try while"),
    builtin: words("Boolean Byte Char DateTime DateTimeOffset Decimal Double" +
                    " Guid Int16 Int32 Int64 Object SByte Single String TimeSpan UInt16 UInt32" +
                    " UInt64 bool byte char decimal double short int long object"  +
                    " sbyte float string ushort uint ulong"),
    atoms: words("true false null"),
    hooks: {
      "@": function(stream, state) {
        if (stream.eat('"')) {
          state.tokenize = tokenAtString;
          return tokenAtString(stream, state);
        }
        stream.eatWhile(/[\w\$_]/);
        return "meta";
      }
    }
  });
  def("text/x-scala", {
    name: "clike",
    keywords: words(

      /* scala */
      "abstract case catch class def do else extends false final finally for forSome if " +
      "implicit import lazy match new null object override package private protected return " +
      "sealed super this throw trait try trye type val var while with yield _ : = => <- <: " +
      "<% >: # @ " +

      /* package scala */
      "assert assume require print println printf readLine readBoolean readByte readShort " +
      "readChar readInt readLong readFloat readDouble " +

      "AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either " +
      "Enumeration Equiv Error Exception Fractional Function IndexedSeq Integral Iterable " +
      "Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering " +
      "Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder " +
      "StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector :: #:: " +

      /* package java.lang */
      "Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable " +
      "Compiler Double Exception Float Integer Long Math Number Object Package Pair Process " +
      "Runtime Runnable SecurityManager Short StackTraceElement StrictMath String " +
      "StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"


    ),
    blockKeywords: words("catch class do else finally for forSome if match switch try while"),
    atoms: words("true false null"),
    hooks: {
      "@": function(stream) {
        stream.eatWhile(/[\w\$_]/);
        return "meta";
      }
    }
  });
  def(["x-shader/x-vertex", "x-shader/x-fragment"], {
    name: "clike",
    keywords: words("float int bool void " +
                    "vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 " +
                    "mat2 mat3 mat4 " +
                    "sampler1D sampler2D sampler3D samplerCube " +
                    "sampler1DShadow sampler2DShadow" +
                    "const attribute uniform varying " +
                    "break continue discard return " +
                    "for while do if else struct " +
                    "in out inout"),
    blockKeywords: words("for while do if else struct"),
    builtin: words("radians degrees sin cos tan asin acos atan " +
                    "pow exp log exp2 sqrt inversesqrt " +
                    "abs sign floor ceil fract mod min max clamp mix step smootstep " +
                    "length distance dot cross normalize ftransform faceforward " +
                    "reflect refract matrixCompMult " +
                    "lessThan lessThanEqual greaterThan greaterThanEqual " +
                    "equal notEqual any all not " +
                    "texture1D texture1DProj texture1DLod texture1DProjLod " +
                    "texture2D texture2DProj texture2DLod texture2DProjLod " +
                    "texture3D texture3DProj texture3DLod texture3DProjLod " +
                    "textureCube textureCubeLod " +
                    "shadow1D shadow2D shadow1DProj shadow2DProj " +
                    "shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod " +
                    "dFdx dFdy fwidth " +
                    "noise1 noise2 noise3 noise4"),
    atoms: words("true false " +
                "gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex " +
                "gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 " +
                "gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 " +
                "gl_FogCoord " +
                "gl_Position gl_PointSize gl_ClipVertex " +
                "gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor " +
                "gl_TexCoord gl_FogFragCoord " +
                "gl_FragCoord gl_FrontFacing " +
                "gl_FragColor gl_FragData gl_FragDepth " +
                "gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix " +
                "gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse " +
                "gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse " +
                "gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose " +
                "gl_ProjectionMatrixInverseTranspose " +
                "gl_ModelViewProjectionMatrixInverseTranspose " +
                "gl_TextureMatrixInverseTranspose " +
                "gl_NormalScale gl_DepthRange gl_ClipPlane " +
                "gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel " +
                "gl_FrontLightModelProduct gl_BackLightModelProduct " +
                "gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ " +
                "gl_FogParameters " +
                "gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords " +
                "gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats " +
                "gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits " +
                "gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits " +
                "gl_MaxDrawBuffers"),
    hooks: {"#": cppHook},
    modeProps: {fold: ["brace", "include"]}
  });

});

},{"../../lib/codemirror":22}],24:[function(require,module,exports){
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("css", function(config, parserConfig) {
  if (!parserConfig.propertyKeywords) parserConfig = CodeMirror.resolveMode("text/css");

  var indentUnit = config.indentUnit,
      tokenHooks = parserConfig.tokenHooks,
      mediaTypes = parserConfig.mediaTypes || {},
      mediaFeatures = parserConfig.mediaFeatures || {},
      propertyKeywords = parserConfig.propertyKeywords || {},
      nonStandardPropertyKeywords = parserConfig.nonStandardPropertyKeywords || {},
      colorKeywords = parserConfig.colorKeywords || {},
      valueKeywords = parserConfig.valueKeywords || {},
      fontProperties = parserConfig.fontProperties || {},
      allowNested = parserConfig.allowNested;

  var type, override;
  function ret(style, tp) { type = tp; return style; }

  // Tokenizers

  function tokenBase(stream, state) {
    var ch = stream.next();
    if (tokenHooks[ch]) {
      var result = tokenHooks[ch](stream, state);
      if (result !== false) return result;
    }
    if (ch == "@") {
      stream.eatWhile(/[\w\\\-]/);
      return ret("def", stream.current());
    } else if (ch == "=" || (ch == "~" || ch == "|") && stream.eat("=")) {
      return ret(null, "compare");
    } else if (ch == "\"" || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    } else if (ch == "#") {
      stream.eatWhile(/[\w\\\-]/);
      return ret("atom", "hash");
    } else if (ch == "!") {
      stream.match(/^\s*\w*/);
      return ret("keyword", "important");
    } else if (/\d/.test(ch) || ch == "." && stream.eat(/\d/)) {
      stream.eatWhile(/[\w.%]/);
      return ret("number", "unit");
    } else if (ch === "-") {
      if (/[\d.]/.test(stream.peek())) {
        stream.eatWhile(/[\w.%]/);
        return ret("number", "unit");
      } else if (stream.match(/^[^-]+-/)) {
        return ret("meta", "meta");
      }
    } else if (/[,+>*\/]/.test(ch)) {
      return ret(null, "select-op");
    } else if (ch == "." && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {
      return ret("qualifier", "qualifier");
    } else if (/[:;{}\[\]\(\)]/.test(ch)) {
      return ret(null, ch);
    } else if (ch == "u" && stream.match("rl(")) {
      stream.backUp(1);
      state.tokenize = tokenParenthesized;
      return ret("property", "word");
    } else if (/[\w\\\-]/.test(ch)) {
      stream.eatWhile(/[\w\\\-]/);
      return ret("property", "word");
    } else {
      return ret(null, null);
    }
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, ch;
      while ((ch = stream.next()) != null) {
        if (ch == quote && !escaped) {
          if (quote == ")") stream.backUp(1);
          break;
        }
        escaped = !escaped && ch == "\\";
      }
      if (ch == quote || !escaped && quote != ")") state.tokenize = null;
      return ret("string", "string");
    };
  }

  function tokenParenthesized(stream, state) {
    stream.next(); // Must be '('
    if (!stream.match(/\s*[\"\')]/, false))
      state.tokenize = tokenString(")");
    else
      state.tokenize = null;
    return ret(null, "(");
  }

  // Context management

  function Context(type, indent, prev) {
    this.type = type;
    this.indent = indent;
    this.prev = prev;
  }

  function pushContext(state, stream, type) {
    state.context = new Context(type, stream.indentation() + indentUnit, state.context);
    return type;
  }

  function popContext(state) {
    state.context = state.context.prev;
    return state.context.type;
  }

  function pass(type, stream, state) {
    return states[state.context.type](type, stream, state);
  }
  function popAndPass(type, stream, state, n) {
    for (var i = n || 1; i > 0; i--)
      state.context = state.context.prev;
    return pass(type, stream, state);
  }

  // Parser

  function wordAsValue(stream) {
    var word = stream.current().toLowerCase();
    if (valueKeywords.hasOwnProperty(word))
      override = "atom";
    else if (colorKeywords.hasOwnProperty(word))
      override = "keyword";
    else
      override = "variable";
  }

  var states = {};

  states.top = function(type, stream, state) {
    if (type == "{") {
      return pushContext(state, stream, "block");
    } else if (type == "}" && state.context.prev) {
      return popContext(state);
    } else if (type == "@media") {
      return pushContext(state, stream, "media");
    } else if (type == "@font-face") {
      return "font_face_before";
    } else if (/^@(-(moz|ms|o|webkit)-)?keyframes$/.test(type)) {
      return "keyframes";
    } else if (type && type.charAt(0) == "@") {
      return pushContext(state, stream, "at");
    } else if (type == "hash") {
      override = "builtin";
    } else if (type == "word") {
      override = "tag";
    } else if (type == "variable-definition") {
      return "maybeprop";
    } else if (type == "interpolation") {
      return pushContext(state, stream, "interpolation");
    } else if (type == ":") {
      return "pseudo";
    } else if (allowNested && type == "(") {
      return pushContext(state, stream, "params");
    }
    return state.context.type;
  };

  states.block = function(type, stream, state) {
    if (type == "word") {
      var word = stream.current().toLowerCase();
      if (propertyKeywords.hasOwnProperty(word)) {
        override = "property";
        return "maybeprop";
      } else if (nonStandardPropertyKeywords.hasOwnProperty(word)) {
        override = "string-2";
        return "maybeprop";
      } else if (allowNested) {
        override = stream.match(/^\s*:/, false) ? "property" : "tag";
        return "block";
      } else {
        override += " error";
        return "maybeprop";
      }
    } else if (type == "meta") {
      return "block";
    } else if (!allowNested && (type == "hash" || type == "qualifier")) {
      override = "error";
      return "block";
    } else {
      return states.top(type, stream, state);
    }
  };

  states.maybeprop = function(type, stream, state) {
    if (type == ":") return pushContext(state, stream, "prop");
    return pass(type, stream, state);
  };

  states.prop = function(type, stream, state) {
    if (type == ";") return popContext(state);
    if (type == "{" && allowNested) return pushContext(state, stream, "propBlock");
    if (type == "}" || type == "{") return popAndPass(type, stream, state);
    if (type == "(") return pushContext(state, stream, "parens");

    if (type == "hash" && !/^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/.test(stream.current())) {
      override += " error";
    } else if (type == "word") {
      wordAsValue(stream);
    } else if (type == "interpolation") {
      return pushContext(state, stream, "interpolation");
    }
    return "prop";
  };

  states.propBlock = function(type, _stream, state) {
    if (type == "}") return popContext(state);
    if (type == "word") { override = "property"; return "maybeprop"; }
    return state.context.type;
  };

  states.parens = function(type, stream, state) {
    if (type == "{" || type == "}") return popAndPass(type, stream, state);
    if (type == ")") return popContext(state);
    return "parens";
  };

  states.pseudo = function(type, stream, state) {
    if (type == "word") {
      override = "variable-3";
      return state.context.type;
    }
    return pass(type, stream, state);
  };

  states.media = function(type, stream, state) {
    if (type == "(") return pushContext(state, stream, "media_parens");
    if (type == "}") return popAndPass(type, stream, state);
    if (type == "{") return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top");

    if (type == "word") {
      var word = stream.current().toLowerCase();
      if (word == "only" || word == "not" || word == "and")
        override = "keyword";
      else if (mediaTypes.hasOwnProperty(word))
        override = "attribute";
      else if (mediaFeatures.hasOwnProperty(word))
        override = "property";
      else
        override = "error";
    }
    return state.context.type;
  };

  states.media_parens = function(type, stream, state) {
    if (type == ")") return popContext(state);
    if (type == "{" || type == "}") return popAndPass(type, stream, state, 2);
    return states.media(type, stream, state);
  };

  states.font_face_before = function(type, stream, state) {
    if (type == "{")
      return pushContext(state, stream, "font_face");
    return pass(type, stream, state);
  };

  states.font_face = function(type, stream, state) {
    if (type == "}") return popContext(state);
    if (type == "word") {
      if (!fontProperties.hasOwnProperty(stream.current().toLowerCase()))
        override = "error";
      else
        override = "property";
      return "maybeprop";
    }
    return "font_face";
  };

  states.keyframes = function(type, stream, state) {
    if (type == "word") { override = "variable"; return "keyframes"; }
    if (type == "{") return pushContext(state, stream, "top");
    return pass(type, stream, state);
  };

  states.at = function(type, stream, state) {
    if (type == ";") return popContext(state);
    if (type == "{" || type == "}") return popAndPass(type, stream, state);
    if (type == "word") override = "tag";
    else if (type == "hash") override = "builtin";
    return "at";
  };

  states.interpolation = function(type, stream, state) {
    if (type == "}") return popContext(state);
    if (type == "{" || type == ";") return popAndPass(type, stream, state);
    if (type != "variable") override = "error";
    return "interpolation";
  };

  states.params = function(type, stream, state) {
    if (type == ")") return popContext(state);
    if (type == "{" || type == "}") return popAndPass(type, stream, state);
    if (type == "word") wordAsValue(stream);
    return "params";
  };

  return {
    startState: function(base) {
      return {tokenize: null,
              state: "top",
              context: new Context("top", base || 0, null)};
    },

    token: function(stream, state) {
      if (!state.tokenize && stream.eatSpace()) return null;
      var style = (state.tokenize || tokenBase)(stream, state);
      if (style && typeof style == "object") {
        type = style[1];
        style = style[0];
      }
      override = style;
      state.state = states[state.state](type, stream, state);
      return override;
    },

    indent: function(state, textAfter) {
      var cx = state.context, ch = textAfter && textAfter.charAt(0);
      var indent = cx.indent;
      if (cx.type == "prop" && ch == "}") cx = cx.prev;
      if (cx.prev &&
          (ch == "}" && (cx.type == "block" || cx.type == "top" || cx.type == "interpolation" || cx.type == "font_face") ||
           ch == ")" && (cx.type == "parens" || cx.type == "params" || cx.type == "media_parens") ||
           ch == "{" && (cx.type == "at" || cx.type == "media"))) {
        indent = cx.indent - indentUnit;
        cx = cx.prev;
      }
      return indent;
    },

    electricChars: "}",
    blockCommentStart: "/*",
    blockCommentEnd: "*/",
    fold: "brace"
  };
});

  function keySet(array) {
    var keys = {};
    for (var i = 0; i < array.length; ++i) {
      keys[array[i]] = true;
    }
    return keys;
  }

  var mediaTypes_ = [
    "all", "aural", "braille", "handheld", "print", "projection", "screen",
    "tty", "tv", "embossed"
  ], mediaTypes = keySet(mediaTypes_);

  var mediaFeatures_ = [
    "width", "min-width", "max-width", "height", "min-height", "max-height",
    "device-width", "min-device-width", "max-device-width", "device-height",
    "min-device-height", "max-device-height", "aspect-ratio",
    "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio",
    "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color",
    "max-color", "color-index", "min-color-index", "max-color-index",
    "monochrome", "min-monochrome", "max-monochrome", "resolution",
    "min-resolution", "max-resolution", "scan", "grid"
  ], mediaFeatures = keySet(mediaFeatures_);

  var propertyKeywords_ = [
    "align-content", "align-items", "align-self", "alignment-adjust",
    "alignment-baseline", "anchor-point", "animation", "animation-delay",
    "animation-direction", "animation-duration", "animation-fill-mode",
    "animation-iteration-count", "animation-name", "animation-play-state",
    "animation-timing-function", "appearance", "azimuth", "backface-visibility",
    "background", "background-attachment", "background-clip", "background-color",
    "background-image", "background-origin", "background-position",
    "background-repeat", "background-size", "baseline-shift", "binding",
    "bleed", "bookmark-label", "bookmark-level", "bookmark-state",
    "bookmark-target", "border", "border-bottom", "border-bottom-color",
    "border-bottom-left-radius", "border-bottom-right-radius",
    "border-bottom-style", "border-bottom-width", "border-collapse",
    "border-color", "border-image", "border-image-outset",
    "border-image-repeat", "border-image-slice", "border-image-source",
    "border-image-width", "border-left", "border-left-color",
    "border-left-style", "border-left-width", "border-radius", "border-right",
    "border-right-color", "border-right-style", "border-right-width",
    "border-spacing", "border-style", "border-top", "border-top-color",
    "border-top-left-radius", "border-top-right-radius", "border-top-style",
    "border-top-width", "border-width", "bottom", "box-decoration-break",
    "box-shadow", "box-sizing", "break-after", "break-before", "break-inside",
    "caption-side", "clear", "clip", "color", "color-profile", "column-count",
    "column-fill", "column-gap", "column-rule", "column-rule-color",
    "column-rule-style", "column-rule-width", "column-span", "column-width",
    "columns", "content", "counter-increment", "counter-reset", "crop", "cue",
    "cue-after", "cue-before", "cursor", "direction", "display",
    "dominant-baseline", "drop-initial-after-adjust",
    "drop-initial-after-align", "drop-initial-before-adjust",
    "drop-initial-before-align", "drop-initial-size", "drop-initial-value",
    "elevation", "empty-cells", "fit", "fit-position", "flex", "flex-basis",
    "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap",
    "float", "float-offset", "flow-from", "flow-into", "font", "font-feature-settings",
    "font-family", "font-kerning", "font-language-override", "font-size", "font-size-adjust",
    "font-stretch", "font-style", "font-synthesis", "font-variant",
    "font-variant-alternates", "font-variant-caps", "font-variant-east-asian",
    "font-variant-ligatures", "font-variant-numeric", "font-variant-position",
    "font-weight", "grid", "grid-area", "grid-auto-columns", "grid-auto-flow",
    "grid-auto-position", "grid-auto-rows", "grid-column", "grid-column-end",
    "grid-column-start", "grid-row", "grid-row-end", "grid-row-start",
    "grid-template", "grid-template-areas", "grid-template-columns",
    "grid-template-rows", "hanging-punctuation", "height", "hyphens",
    "icon", "image-orientation", "image-rendering", "image-resolution",
    "inline-box-align", "justify-content", "left", "letter-spacing",
    "line-break", "line-height", "line-stacking", "line-stacking-ruby",
    "line-stacking-shift", "line-stacking-strategy", "list-style",
    "list-style-image", "list-style-position", "list-style-type", "margin",
    "margin-bottom", "margin-left", "margin-right", "margin-top",
    "marker-offset", "marks", "marquee-direction", "marquee-loop",
    "marquee-play-count", "marquee-speed", "marquee-style", "max-height",
    "max-width", "min-height", "min-width", "move-to", "nav-down", "nav-index",
    "nav-left", "nav-right", "nav-up", "opacity", "order", "orphans", "outline",
    "outline-color", "outline-offset", "outline-style", "outline-width",
    "overflow", "overflow-style", "overflow-wrap", "overflow-x", "overflow-y",
    "padding", "padding-bottom", "padding-left", "padding-right", "padding-top",
    "page", "page-break-after", "page-break-before", "page-break-inside",
    "page-policy", "pause", "pause-after", "pause-before", "perspective",
    "perspective-origin", "pitch", "pitch-range", "play-during", "position",
    "presentation-level", "punctuation-trim", "quotes", "region-break-after",
    "region-break-before", "region-break-inside", "region-fragment",
    "rendering-intent", "resize", "rest", "rest-after", "rest-before", "richness",
    "right", "rotation", "rotation-point", "ruby-align", "ruby-overhang",
    "ruby-position", "ruby-span", "shape-inside", "shape-outside", "size",
    "speak", "speak-as", "speak-header",
    "speak-numeral", "speak-punctuation", "speech-rate", "stress", "string-set",
    "tab-size", "table-layout", "target", "target-name", "target-new",
    "target-position", "text-align", "text-align-last", "text-decoration",
    "text-decoration-color", "text-decoration-line", "text-decoration-skip",
    "text-decoration-style", "text-emphasis", "text-emphasis-color",
    "text-emphasis-position", "text-emphasis-style", "text-height",
    "text-indent", "text-justify", "text-outline", "text-overflow", "text-shadow",
    "text-size-adjust", "text-space-collapse", "text-transform", "text-underline-position",
    "text-wrap", "top", "transform", "transform-origin", "transform-style",
    "transition", "transition-delay", "transition-duration",
    "transition-property", "transition-timing-function", "unicode-bidi",
    "vertical-align", "visibility", "voice-balance", "voice-duration",
    "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress",
    "voice-volume", "volume", "white-space", "widows", "width", "word-break",
    "word-spacing", "word-wrap", "z-index",
    // SVG-specific
    "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color",
    "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events",
    "color-interpolation", "color-interpolation-filters",
    "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering",
    "marker", "marker-end", "marker-mid", "marker-start", "shape-rendering", "stroke",
    "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin",
    "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering",
    "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal",
    "glyph-orientation-vertical", "text-anchor", "writing-mode"
  ], propertyKeywords = keySet(propertyKeywords_);

  var nonStandardPropertyKeywords = [
    "scrollbar-arrow-color", "scrollbar-base-color", "scrollbar-dark-shadow-color",
    "scrollbar-face-color", "scrollbar-highlight-color", "scrollbar-shadow-color",
    "scrollbar-3d-light-color", "scrollbar-track-color", "shape-inside",
    "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button",
    "searchfield-results-decoration", "zoom"
  ], nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords);

  var colorKeywords_ = [
    "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige",
    "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown",
    "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue",
    "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod",
    "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen",
    "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen",
    "darkslateblue", "darkslategray", "darkturquoise", "darkviolet",
    "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick",
    "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite",
    "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew",
    "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender",
    "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral",
    "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink",
    "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray",
    "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta",
    "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple",
    "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise",
    "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin",
    "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered",
    "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred",
    "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue",
    "purple", "red", "rosybrown", "royalblue", "saddlebrown", "salmon",
    "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue",
    "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan",
    "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white",
    "whitesmoke", "yellow", "yellowgreen"
  ], colorKeywords = keySet(colorKeywords_);

  var valueKeywords_ = [
    "above", "absolute", "activeborder", "activecaption", "afar",
    "after-white-space", "ahead", "alias", "all", "all-scroll", "alternate",
    "always", "amharic", "amharic-abegede", "antialiased", "appworkspace",
    "arabic-indic", "armenian", "asterisks", "auto", "avoid", "avoid-column", "avoid-page",
    "avoid-region", "background", "backwards", "baseline", "below", "bidi-override", "binary",
    "bengali", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box",
    "both", "bottom", "break", "break-all", "break-word", "button", "button-bevel",
    "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "cambodian",
    "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret",
    "cell", "center", "checkbox", "circle", "cjk-earthly-branch",
    "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote",
    "col-resize", "collapse", "column", "compact", "condensed", "contain", "content",
    "content-box", "context-menu", "continuous", "copy", "cover", "crop",
    "cross", "crosshair", "currentcolor", "cursive", "dashed", "decimal",
    "decimal-leading-zero", "default", "default-button", "destination-atop",
    "destination-in", "destination-out", "destination-over", "devanagari",
    "disc", "discard", "document", "dot-dash", "dot-dot-dash", "dotted",
    "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out",
    "element", "ellipse", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede",
    "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er",
    "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er",
    "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et",
    "ethiopic-halehame-gez", "ethiopic-halehame-om-et",
    "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et",
    "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et",
    "ethiopic-halehame-tig", "ew-resize", "expanded", "extra-condensed",
    "extra-expanded", "fantasy", "fast", "fill", "fixed", "flat", "footnotes",
    "forwards", "from", "geometricPrecision", "georgian", "graytext", "groove",
    "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hebrew",
    "help", "hidden", "hide", "higher", "highlight", "highlighttext",
    "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "icon", "ignore",
    "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite",
    "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis",
    "inline-block", "inline-table", "inset", "inside", "intrinsic", "invert",
    "italic", "justify", "kannada", "katakana", "katakana-iroha", "keep-all", "khmer",
    "landscape", "lao", "large", "larger", "left", "level", "lighter",
    "line-through", "linear", "lines", "list-item", "listbox", "listitem",
    "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian",
    "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian",
    "lower-roman", "lowercase", "ltr", "malayalam", "match",
    "media-controls-background", "media-current-time-display",
    "media-fullscreen-button", "media-mute-button", "media-play-button",
    "media-return-to-realtime-button", "media-rewind-button",
    "media-seek-back-button", "media-seek-forward-button", "media-slider",
    "media-sliderthumb", "media-time-remaining-display", "media-volume-slider",
    "media-volume-slider-container", "media-volume-sliderthumb", "medium",
    "menu", "menulist", "menulist-button", "menulist-text",
    "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic",
    "mix", "mongolian", "monospace", "move", "multiple", "myanmar", "n-resize",
    "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop",
    "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap",
    "ns-resize", "nw-resize", "nwse-resize", "oblique", "octal", "open-quote",
    "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset",
    "outside", "outside-shape", "overlay", "overline", "padding", "padding-box",
    "painted", "page", "paused", "persian", "plus-darker", "plus-lighter", "pointer",
    "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d", "progress", "push-button",
    "radio", "read-only", "read-write", "read-write-plaintext-only", "rectangle", "region",
    "relative", "repeat", "repeat-x", "repeat-y", "reset", "reverse", "rgb", "rgba",
    "ridge", "right", "round", "row-resize", "rtl", "run-in", "running",
    "s-resize", "sans-serif", "scroll", "scrollbar", "se-resize", "searchfield",
    "searchfield-cancel-button", "searchfield-decoration",
    "searchfield-results-button", "searchfield-results-decoration",
    "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama",
    "single", "skip-white-space", "slide", "slider-horizontal",
    "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow",
    "small", "small-caps", "small-caption", "smaller", "solid", "somali",
    "source-atop", "source-in", "source-out", "source-over", "space", "square",
    "square-button", "start", "static", "status-bar", "stretch", "stroke",
    "sub", "subpixel-antialiased", "super", "sw-resize", "table",
    "table-caption", "table-cell", "table-column", "table-column-group",
    "table-footer-group", "table-header-group", "table-row", "table-row-group",
    "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai",
    "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight",
    "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er",
    "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top",
    "transparent", "ultra-condensed", "ultra-expanded", "underline", "up",
    "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal",
    "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url",
    "vertical", "vertical-text", "visible", "visibleFill", "visiblePainted",
    "visibleStroke", "visual", "w-resize", "wait", "wave", "wider",
    "window", "windowframe", "windowtext", "x-large", "x-small", "xor",
    "xx-large", "xx-small"
  ], valueKeywords = keySet(valueKeywords_);

  var fontProperties_ = [
    "font-family", "src", "unicode-range", "font-variant", "font-feature-settings",
    "font-stretch", "font-weight", "font-style"
  ], fontProperties = keySet(fontProperties_);

  var allWords = mediaTypes_.concat(mediaFeatures_).concat(propertyKeywords_)
    .concat(nonStandardPropertyKeywords).concat(colorKeywords_).concat(valueKeywords_);
  CodeMirror.registerHelper("hintWords", "css", allWords);

  function tokenCComment(stream, state) {
    var maybeEnd = false, ch;
    while ((ch = stream.next()) != null) {
      if (maybeEnd && ch == "/") {
        state.tokenize = null;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return ["comment", "comment"];
  }

  function tokenSGMLComment(stream, state) {
    if (stream.skipTo("-->")) {
      stream.match("-->");
      state.tokenize = null;
    } else {
      stream.skipToEnd();
    }
    return ["comment", "comment"];
  }

  CodeMirror.defineMIME("text/css", {
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    fontProperties: fontProperties,
    tokenHooks: {
      "<": function(stream, state) {
        if (!stream.match("!--")) return false;
        state.tokenize = tokenSGMLComment;
        return tokenSGMLComment(stream, state);
      },
      "/": function(stream, state) {
        if (!stream.eat("*")) return false;
        state.tokenize = tokenCComment;
        return tokenCComment(stream, state);
      }
    },
    name: "css"
  });

  CodeMirror.defineMIME("text/x-scss", {
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    fontProperties: fontProperties,
    allowNested: true,
    tokenHooks: {
      "/": function(stream, state) {
        if (stream.eat("/")) {
          stream.skipToEnd();
          return ["comment", "comment"];
        } else if (stream.eat("*")) {
          state.tokenize = tokenCComment;
          return tokenCComment(stream, state);
        } else {
          return ["operator", "operator"];
        }
      },
      ":": function(stream) {
        if (stream.match(/\s*{/))
          return [null, "{"];
        return false;
      },
      "$": function(stream) {
        stream.match(/^[\w-]+/);
        if (stream.match(/^\s*:/, false))
          return ["variable-2", "variable-definition"];
        return ["variable-2", "variable"];
      },
      "#": function(stream) {
        if (!stream.eat("{")) return false;
        return [null, "interpolation"];
      }
    },
    name: "css",
    helperType: "scss"
  });

  CodeMirror.defineMIME("text/x-less", {
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    fontProperties: fontProperties,
    allowNested: true,
    tokenHooks: {
      "/": function(stream, state) {
        if (stream.eat("/")) {
          stream.skipToEnd();
          return ["comment", "comment"];
        } else if (stream.eat("*")) {
          state.tokenize = tokenCComment;
          return tokenCComment(stream, state);
        } else {
          return ["operator", "operator"];
        }
      },
      "@": function(stream) {
        if (stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\b/, false)) return false;
        stream.eatWhile(/[\w\\\-]/);
        if (stream.match(/^\s*:/, false))
          return ["variable-2", "variable-definition"];
        return ["variable-2", "variable"];
      },
      "&": function() {
        return ["atom", "atom"];
      }
    },
    name: "css",
    helperType: "less"
  });

});

},{"../../lib/codemirror":22}],25:[function(require,module,exports){
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"), require("../markdown/markdown"), require("../../addon/mode/overlay"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror", "../markdown/markdown", "../../addon/mode/overlay"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("gfm", function(config, modeConfig) {
  var codeDepth = 0;
  function blankLine(state) {
    state.code = false;
    return null;
  }
  var gfmOverlay = {
    startState: function() {
      return {
        code: false,
        codeBlock: false,
        ateSpace: false
      };
    },
    copyState: function(s) {
      return {
        code: s.code,
        codeBlock: s.codeBlock,
        ateSpace: s.ateSpace
      };
    },
    token: function(stream, state) {
      // Hack to prevent formatting override inside code blocks (block and inline)
      if (state.codeBlock) {
        if (stream.match(/^```/)) {
          state.codeBlock = false;
          return null;
        }
        stream.skipToEnd();
        return null;
      }
      if (stream.sol()) {
        state.code = false;
      }
      if (stream.sol() && stream.match(/^```/)) {
        stream.skipToEnd();
        state.codeBlock = true;
        return null;
      }
      // If this block is changed, it may need to be updated in Markdown mode
      if (stream.peek() === '`') {
        stream.next();
        var before = stream.pos;
        stream.eatWhile('`');
        var difference = 1 + stream.pos - before;
        if (!state.code) {
          codeDepth = difference;
          state.code = true;
        } else {
          if (difference === codeDepth) { // Must be exact
            state.code = false;
          }
        }
        return null;
      } else if (state.code) {
        stream.next();
        return null;
      }
      // Check if space. If so, links can be formatted later on
      if (stream.eatSpace()) {
        state.ateSpace = true;
        return null;
      }
      if (stream.sol() || state.ateSpace) {
        state.ateSpace = false;
        if(stream.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+@)?(?:[a-f0-9]{7,40}\b)/)) {
          // User/Project@SHA
          // User@SHA
          // SHA
          return "link";
        } else if (stream.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+)?#[0-9]+\b/)) {
          // User/Project#Num
          // User#Num
          // #Num
          return "link";
        }
      }
      if (stream.match(/^((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]|\([^\s()<>]*\))+(?:\([^\s()<>]*\)|[^\s`!()\[\]{};:'".,<>?]))/i) &&
         stream.string.slice(stream.start - 2, stream.start) != "](") {
        // URLs
        // Taken from http://daringfireball.net/2010/07/improved_regex_for_matching_urls
        // And then (issue #1160) simplified to make it not crash the Chrome Regexp engine
        return "link";
      }
      stream.next();
      return null;
    },
    blankLine: blankLine
  };

  var markdownConfig = {
    underscoresBreakWords: false,
    taskLists: true,
    fencedCodeBlocks: true
  };
  for (var attr in modeConfig) {
    markdownConfig[attr] = modeConfig[attr];
  }
  markdownConfig.name = "markdown";
  CodeMirror.defineMIME("gfmBase", markdownConfig);
  return CodeMirror.overlayMode(CodeMirror.getMode(config, "gfmBase"), gfmOverlay);
}, "markdown");

});

},{"../../addon/mode/overlay":21,"../../lib/codemirror":22,"../markdown/markdown":28}],26:[function(require,module,exports){
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"), require("../xml/xml"), require("../javascript/javascript"), require("../css/css"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror", "../xml/xml", "../javascript/javascript", "../css/css"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("htmlmixed", function(config, parserConfig) {
  var htmlMode = CodeMirror.getMode(config, {name: "xml",
                                             htmlMode: true,
                                             multilineTagIndentFactor: parserConfig.multilineTagIndentFactor,
                                             multilineTagIndentPastTag: parserConfig.multilineTagIndentPastTag});
  var cssMode = CodeMirror.getMode(config, "css");

  var scriptTypes = [], scriptTypesConf = parserConfig && parserConfig.scriptTypes;
  scriptTypes.push({matches: /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^$/i,
                    mode: CodeMirror.getMode(config, "javascript")});
  if (scriptTypesConf) for (var i = 0; i < scriptTypesConf.length; ++i) {
    var conf = scriptTypesConf[i];
    scriptTypes.push({matches: conf.matches, mode: conf.mode && CodeMirror.getMode(config, conf.mode)});
  }
  scriptTypes.push({matches: /./,
                    mode: CodeMirror.getMode(config, "text/plain")});

  function html(stream, state) {
    var tagName = state.htmlState.tagName;
    var style = htmlMode.token(stream, state.htmlState);
    if (tagName == "script" && /\btag\b/.test(style) && stream.current() == ">") {
      // Script block: mode to change to depends on type attribute
      var scriptType = stream.string.slice(Math.max(0, stream.pos - 100), stream.pos).match(/\btype\s*=\s*("[^"]+"|'[^']+'|\S+)[^<]*$/i);
      scriptType = scriptType ? scriptType[1] : "";
      if (scriptType && /[\"\']/.test(scriptType.charAt(0))) scriptType = scriptType.slice(1, scriptType.length - 1);
      for (var i = 0; i < scriptTypes.length; ++i) {
        var tp = scriptTypes[i];
        if (typeof tp.matches == "string" ? scriptType == tp.matches : tp.matches.test(scriptType)) {
          if (tp.mode) {
            state.token = script;
            state.localMode = tp.mode;
            state.localState = tp.mode.startState && tp.mode.startState(htmlMode.indent(state.htmlState, ""));
          }
          break;
        }
      }
    } else if (tagName == "style" && /\btag\b/.test(style) && stream.current() == ">") {
      state.token = css;
      state.localMode = cssMode;
      state.localState = cssMode.startState(htmlMode.indent(state.htmlState, ""));
    }
    return style;
  }
  function maybeBackup(stream, pat, style) {
    var cur = stream.current();
    var close = cur.search(pat), m;
    if (close > -1) stream.backUp(cur.length - close);
    else if (m = cur.match(/<\/?$/)) {
      stream.backUp(cur.length);
      if (!stream.match(pat, false)) stream.match(cur);
    }
    return style;
  }
  function script(stream, state) {
    if (stream.match(/^<\/\s*script\s*>/i, false)) {
      state.token = html;
      state.localState = state.localMode = null;
      return html(stream, state);
    }
    return maybeBackup(stream, /<\/\s*script\s*>/,
                       state.localMode.token(stream, state.localState));
  }
  function css(stream, state) {
    if (stream.match(/^<\/\s*style\s*>/i, false)) {
      state.token = html;
      state.localState = state.localMode = null;
      return html(stream, state);
    }
    return maybeBackup(stream, /<\/\s*style\s*>/,
                       cssMode.token(stream, state.localState));
  }

  return {
    startState: function() {
      var state = htmlMode.startState();
      return {token: html, localMode: null, localState: null, htmlState: state};
    },

    copyState: function(state) {
      if (state.localState)
        var local = CodeMirror.copyState(state.localMode, state.localState);
      return {token: state.token, localMode: state.localMode, localState: local,
              htmlState: CodeMirror.copyState(htmlMode, state.htmlState)};
    },

    token: function(stream, state) {
      return state.token(stream, state);
    },

    indent: function(state, textAfter) {
      if (!state.localMode || /^\s*<\//.test(textAfter))
        return htmlMode.indent(state.htmlState, textAfter);
      else if (state.localMode.indent)
        return state.localMode.indent(state.localState, textAfter);
      else
        return CodeMirror.Pass;
    },

    innerMode: function(state) {
      return {state: state.localState || state.htmlState, mode: state.localMode || htmlMode};
    }
  };
}, "xml", "javascript", "css");

CodeMirror.defineMIME("text/html", "htmlmixed");

});

},{"../../lib/codemirror":22,"../css/css":24,"../javascript/javascript":27,"../xml/xml":29}],27:[function(require,module,exports){
// TODO actually recognize syntax of TypeScript constructs

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("javascript", function(config, parserConfig) {
  var indentUnit = config.indentUnit;
  var statementIndent = parserConfig.statementIndent;
  var jsonldMode = parserConfig.jsonld;
  var jsonMode = parserConfig.json || jsonldMode;
  var isTS = parserConfig.typescript;

  // Tokenizer

  var keywords = function(){
    function kw(type) {return {type: type, style: "keyword"};}
    var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c");
    var operator = kw("operator"), atom = {type: "atom", style: "atom"};

    var jsKeywords = {
      "if": kw("if"), "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,
      "return": C, "break": C, "continue": C, "new": C, "delete": C, "throw": C, "debugger": C,
      "var": kw("var"), "const": kw("var"), "let": kw("var"),
      "function": kw("function"), "catch": kw("catch"),
      "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),
      "in": operator, "typeof": operator, "instanceof": operator,
      "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom,
      "this": kw("this"), "module": kw("module"), "class": kw("class"), "super": kw("atom"),
      "yield": C, "export": kw("export"), "import": kw("import"), "extends": C
    };

    // Extend the 'normal' keywords with the TypeScript language extensions
    if (isTS) {
      var type = {type: "variable", style: "variable-3"};
      var tsKeywords = {
        // object-like things
        "interface": kw("interface"),
        "extends": kw("extends"),
        "constructor": kw("constructor"),

        // scope modifiers
        "public": kw("public"),
        "private": kw("private"),
        "protected": kw("protected"),
        "static": kw("static"),

        // types
        "string": type, "number": type, "bool": type, "any": type
      };

      for (var attr in tsKeywords) {
        jsKeywords[attr] = tsKeywords[attr];
      }
    }

    return jsKeywords;
  }();

  var isOperatorChar = /[+\-*&%=<>!?|~^]/;
  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;

  function readRegexp(stream) {
    var escaped = false, next, inSet = false;
    while ((next = stream.next()) != null) {
      if (!escaped) {
        if (next == "/" && !inSet) return;
        if (next == "[") inSet = true;
        else if (inSet && next == "]") inSet = false;
      }
      escaped = !escaped && next == "\\";
    }
  }

  // Used as scratch variables to communicate multiple values without
  // consing up tons of objects.
  var type, content;
  function ret(tp, style, cont) {
    type = tp; content = cont;
    return style;
  }
  function tokenBase(stream, state) {
    var ch = stream.next();
    if (ch == '"' || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    } else if (ch == "." && stream.match(/^\d+(?:[eE][+\-]?\d+)?/)) {
      return ret("number", "number");
    } else if (ch == "." && stream.match("..")) {
      return ret("spread", "meta");
    } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
      return ret(ch);
    } else if (ch == "=" && stream.eat(">")) {
      return ret("=>", "operator");
    } else if (ch == "0" && stream.eat(/x/i)) {
      stream.eatWhile(/[\da-f]/i);
      return ret("number", "number");
    } else if (/\d/.test(ch)) {
      stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/);
      return ret("number", "number");
    } else if (ch == "/") {
      if (stream.eat("*")) {
        state.tokenize = tokenComment;
        return tokenComment(stream, state);
      } else if (stream.eat("/")) {
        stream.skipToEnd();
        return ret("comment", "comment");
      } else if (state.lastType == "operator" || state.lastType == "keyword c" ||
               state.lastType == "sof" || /^[\[{}\(,;:]$/.test(state.lastType)) {
        readRegexp(stream);
        stream.eatWhile(/[gimy]/); // 'y' is "sticky" option in Mozilla
        return ret("regexp", "string-2");
      } else {
        stream.eatWhile(isOperatorChar);
        return ret("operator", "operator", stream.current());
      }
    } else if (ch == "`") {
      state.tokenize = tokenQuasi;
      return tokenQuasi(stream, state);
    } else if (ch == "#") {
      stream.skipToEnd();
      return ret("error", "error");
    } else if (isOperatorChar.test(ch)) {
      stream.eatWhile(isOperatorChar);
      return ret("operator", "operator", stream.current());
    } else {
      stream.eatWhile(/[\w\$_]/);
      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];
      return (known && state.lastType != ".") ? ret(known.type, known.style, word) :
                     ret("variable", "variable", word);
    }
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, next;
      if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)){
        state.tokenize = tokenBase;
        return ret("jsonld-keyword", "meta");
      }
      while ((next = stream.next()) != null) {
        if (next == quote && !escaped) break;
        escaped = !escaped && next == "\\";
      }
      if (!escaped) state.tokenize = tokenBase;
      return ret("string", "string");
    };
  }

  function tokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" && maybeEnd) {
        state.tokenize = tokenBase;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return ret("comment", "comment");
  }

  function tokenQuasi(stream, state) {
    var escaped = false, next;
    while ((next = stream.next()) != null) {
      if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
        state.tokenize = tokenBase;
        break;
      }
      escaped = !escaped && next == "\\";
    }
    return ret("quasi", "string-2", stream.current());
  }

  var brackets = "([{}])";
  // This is a crude lookahead trick to try and notice that we're
  // parsing the argument patterns for a fat-arrow function before we
  // actually hit the arrow token. It only works if the arrow is on
  // the same line as the arguments and there's no strange noise
  // (comments) in between. Fallback is to only notice when we hit the
  // arrow, and not declare the arguments as locals for the arrow
  // body.
  function findFatArrow(stream, state) {
    if (state.fatArrowAt) state.fatArrowAt = null;
    var arrow = stream.string.indexOf("=>", stream.start);
    if (arrow < 0) return;

    var depth = 0, sawSomething = false;
    for (var pos = arrow - 1; pos >= 0; --pos) {
      var ch = stream.string.charAt(pos);
      var bracket = brackets.indexOf(ch);
      if (bracket >= 0 && bracket < 3) {
        if (!depth) { ++pos; break; }
        if (--depth == 0) break;
      } else if (bracket >= 3 && bracket < 6) {
        ++depth;
      } else if (/[$\w]/.test(ch)) {
        sawSomething = true;
      } else if (sawSomething && !depth) {
        ++pos;
        break;
      }
    }
    if (sawSomething && !depth) state.fatArrowAt = pos;
  }

  // Parser

  var atomicTypes = {"atom": true, "number": true, "variable": true, "string": true, "regexp": true, "this": true, "jsonld-keyword": true};

  function JSLexical(indented, column, type, align, prev, info) {
    this.indented = indented;
    this.column = column;
    this.type = type;
    this.prev = prev;
    this.info = info;
    if (align != null) this.align = align;
  }

  function inScope(state, varname) {
    for (var v = state.localVars; v; v = v.next)
      if (v.name == varname) return true;
    for (var cx = state.context; cx; cx = cx.prev) {
      for (var v = cx.vars; v; v = v.next)
        if (v.name == varname) return true;
    }
  }

  function parseJS(state, style, type, content, stream) {
    var cc = state.cc;
    // Communicate our context to the combinators.
    // (Less wasteful than consing up a hundred closures on every call.)
    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc;

    if (!state.lexical.hasOwnProperty("align"))
      state.lexical.align = true;

    while(true) {
      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
      if (combinator(type, content)) {
        while(cc.length && cc[cc.length - 1].lex)
          cc.pop()();
        if (cx.marked) return cx.marked;
        if (type == "variable" && inScope(state, content)) return "variable-2";
        return style;
      }
    }
  }

  // Combinator utils

  var cx = {state: null, column: null, marked: null, cc: null};
  function pass() {
    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
  }
  function cont() {
    pass.apply(null, arguments);
    return true;
  }
  function register(varname) {
    function inList(list) {
      for (var v = list; v; v = v.next)
        if (v.name == varname) return true;
      return false;
    }
    var state = cx.state;
    if (state.context) {
      cx.marked = "def";
      if (inList(state.localVars)) return;
      state.localVars = {name: varname, next: state.localVars};
    } else {
      if (inList(state.globalVars)) return;
      if (parserConfig.globalVars)
        state.globalVars = {name: varname, next: state.globalVars};
    }
  }

  // Combinators

  var defaultVars = {name: "this", next: {name: "arguments"}};
  function pushcontext() {
    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};
    cx.state.localVars = defaultVars;
  }
  function popcontext() {
    cx.state.localVars = cx.state.context.vars;
    cx.state.context = cx.state.context.prev;
  }
  function pushlex(type, info) {
    var result = function() {
      var state = cx.state, indent = state.indented;
      if (state.lexical.type == "stat") indent = state.lexical.indented;
      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
    };
    result.lex = true;
    return result;
  }
  function poplex() {
    var state = cx.state;
    if (state.lexical.prev) {
      if (state.lexical.type == ")")
        state.indented = state.lexical.indented;
      state.lexical = state.lexical.prev;
    }
  }
  poplex.lex = true;

  function expect(wanted) {
    function exp(type) {
      if (type == wanted) return cont();
      else if (wanted == ";") return pass();
      else return cont(exp);
    };
    return exp;
  }

  function statement(type, value) {
    if (type == "var") return cont(pushlex("vardef", value.length), vardef, expect(";"), poplex);
    if (type == "keyword a") return cont(pushlex("form"), expression, statement, poplex);
    if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
    if (type == "{") return cont(pushlex("}"), block, poplex);
    if (type == ";") return cont();
    if (type == "if") {
      if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex)
        cx.state.cc.pop()();
      return cont(pushlex("form"), expression, statement, poplex, maybeelse);
    }
    if (type == "function") return cont(functiondef);
    if (type == "for") return cont(pushlex("form"), forspec, statement, poplex);
    if (type == "variable") return cont(pushlex("stat"), maybelabel);
    if (type == "switch") return cont(pushlex("form"), expression, pushlex("}", "switch"), expect("{"),
                                      block, poplex, poplex);
    if (type == "case") return cont(expression, expect(":"));
    if (type == "default") return cont(expect(":"));
    if (type == "catch") return cont(pushlex("form"), pushcontext, expect("("), funarg, expect(")"),
                                     statement, poplex, popcontext);
    if (type == "module") return cont(pushlex("form"), pushcontext, afterModule, popcontext, poplex);
    if (type == "class") return cont(pushlex("form"), className, objlit, poplex);
    if (type == "export") return cont(pushlex("form"), afterExport, poplex);
    if (type == "import") return cont(pushlex("form"), afterImport, poplex);
    return pass(pushlex("stat"), expression, expect(";"), poplex);
  }
  function expression(type) {
    return expressionInner(type, false);
  }
  function expressionNoComma(type) {
    return expressionInner(type, true);
  }
  function expressionInner(type, noComma) {
    if (cx.state.fatArrowAt == cx.stream.start) {
      var body = noComma ? arrowBodyNoComma : arrowBody;
      if (type == "(") return cont(pushcontext, pushlex(")"), commasep(pattern, ")"), poplex, expect("=>"), body, popcontext);
      else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);
    }

    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);
    if (type == "function") return cont(functiondef, maybeop);
    if (type == "keyword c") return cont(noComma ? maybeexpressionNoComma : maybeexpression);
    if (type == "(") return cont(pushlex(")"), maybeexpression, comprehension, expect(")"), poplex, maybeop);
    if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);
    if (type == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
    if (type == "{") return contCommasep(objprop, "}", null, maybeop);
    if (type == "quasi") { return pass(quasi, maybeop); }
    return cont();
  }
  function maybeexpression(type) {
    if (type.match(/[;\}\)\],]/)) return pass();
    return pass(expression);
  }
  function maybeexpressionNoComma(type) {
    if (type.match(/[;\}\)\],]/)) return pass();
    return pass(expressionNoComma);
  }

  function maybeoperatorComma(type, value) {
    if (type == ",") return cont(expression);
    return maybeoperatorNoComma(type, value, false);
  }
  function maybeoperatorNoComma(type, value, noComma) {
    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
    var expr = noComma == false ? expression : expressionNoComma;
    if (value == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
    if (type == "operator") {
      if (/\+\+|--/.test(value)) return cont(me);
      if (value == "?") return cont(expression, expect(":"), expr);
      return cont(expr);
    }
    if (type == "quasi") { return pass(quasi, me); }
    if (type == ";") return;
    if (type == "(") return contCommasep(expressionNoComma, ")", "call", me);
    if (type == ".") return cont(property, me);
    if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
  }
  function quasi(type, value) {
    if (type != "quasi") return pass();
    if (value.slice(value.length - 2) != "${") return cont(quasi);
    return cont(expression, continueQuasi);
  }
  function continueQuasi(type) {
    if (type == "}") {
      cx.marked = "string-2";
      cx.state.tokenize = tokenQuasi;
      return cont(quasi);
    }
  }
  function arrowBody(type) {
    findFatArrow(cx.stream, cx.state);
    if (type == "{") return pass(statement);
    return pass(expression);
  }
  function arrowBodyNoComma(type) {
    findFatArrow(cx.stream, cx.state);
    if (type == "{") return pass(statement);
    return pass(expressionNoComma);
  }
  function maybelabel(type) {
    if (type == ":") return cont(poplex, statement);
    return pass(maybeoperatorComma, expect(";"), poplex);
  }
  function property(type) {
    if (type == "variable") {cx.marked = "property"; return cont();}
  }
  function objprop(type, value) {
    if (type == "variable") {
      cx.marked = "property";
      if (value == "get" || value == "set") return cont(getterSetter);
    } else if (type == "number" || type == "string") {
      cx.marked = jsonldMode ? "property" : (type + " property");
    } else if (type == "[") {
      return cont(expression, expect("]"), afterprop);
    }
    if (atomicTypes.hasOwnProperty(type)) return cont(afterprop);
  }
  function getterSetter(type) {
    if (type != "variable") return pass(afterprop);
    cx.marked = "property";
    return cont(functiondef);
  }
  function afterprop(type) {
    if (type == ":") return cont(expressionNoComma);
    if (type == "(") return pass(functiondef);
  }
  function commasep(what, end) {
    function proceed(type) {
      if (type == ",") {
        var lex = cx.state.lexical;
        if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
        return cont(what, proceed);
      }
      if (type == end) return cont();
      return cont(expect(end));
    }
    return function(type) {
      if (type == end) return cont();
      return pass(what, proceed);
    };
  }
  function contCommasep(what, end, info) {
    for (var i = 3; i < arguments.length; i++)
      cx.cc.push(arguments[i]);
    return cont(pushlex(end, info), commasep(what, end), poplex);
  }
  function block(type) {
    if (type == "}") return cont();
    return pass(statement, block);
  }
  function maybetype(type) {
    if (isTS && type == ":") return cont(typedef);
  }
  function typedef(type) {
    if (type == "variable"){cx.marked = "variable-3"; return cont();}
  }
  function vardef() {
    return pass(pattern, maybetype, maybeAssign, vardefCont);
  }
  function pattern(type, value) {
    if (type == "variable") { register(value); return cont(); }
    if (type == "[") return contCommasep(pattern, "]");
    if (type == "{") return contCommasep(proppattern, "}");
  }
  function proppattern(type, value) {
    if (type == "variable" && !cx.stream.match(/^\s*:/, false)) {
      register(value);
      return cont(maybeAssign);
    }
    if (type == "variable") cx.marked = "property";
    return cont(expect(":"), pattern, maybeAssign);
  }
  function maybeAssign(_type, value) {
    if (value == "=") return cont(expressionNoComma);
  }
  function vardefCont(type) {
    if (type == ",") return cont(vardef);
  }
  function maybeelse(type, value) {
    if (type == "keyword b" && value == "else") return cont(pushlex("form", "else"), statement, poplex);
  }
  function forspec(type) {
    if (type == "(") return cont(pushlex(")"), forspec1, expect(")"), poplex);
  }
  function forspec1(type) {
    if (type == "var") return cont(vardef, expect(";"), forspec2);
    if (type == ";") return cont(forspec2);
    if (type == "variable") return cont(formaybeinof);
    return pass(expression, expect(";"), forspec2);
  }
  function formaybeinof(_type, value) {
    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }
    return cont(maybeoperatorComma, forspec2);
  }
  function forspec2(type, value) {
    if (type == ";") return cont(forspec3);
    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }
    return pass(expression, expect(";"), forspec3);
  }
  function forspec3(type) {
    if (type != ")") cont(expression);
  }
  function functiondef(type, value) {
    if (value == "*") {cx.marked = "keyword"; return cont(functiondef);}
    if (type == "variable") {register(value); return cont(functiondef);}
    if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, statement, popcontext);
  }
  function funarg(type) {
    if (type == "spread") return cont(funarg);
    return pass(pattern, maybetype);
  }
  function className(type, value) {
    if (type == "variable") {register(value); return cont(classNameAfter);}
  }
  function classNameAfter(_type, value) {
    if (value == "extends") return cont(expression);
  }
  function objlit(type) {
    if (type == "{") return contCommasep(objprop, "}");
  }
  function afterModule(type, value) {
    if (type == "string") return cont(statement);
    if (type == "variable") { register(value); return cont(maybeFrom); }
  }
  function afterExport(_type, value) {
    if (value == "*") { cx.marked = "keyword"; return cont(maybeFrom, expect(";")); }
    if (value == "default") { cx.marked = "keyword"; return cont(expression, expect(";")); }
    return pass(statement);
  }
  function afterImport(type) {
    if (type == "string") return cont();
    return pass(importSpec, maybeFrom);
  }
  function importSpec(type, value) {
    if (type == "{") return contCommasep(importSpec, "}");
    if (type == "variable") register(value);
    return cont();
  }
  function maybeFrom(_type, value) {
    if (value == "from") { cx.marked = "keyword"; return cont(expression); }
  }
  function arrayLiteral(type) {
    if (type == "]") return cont();
    return pass(expressionNoComma, maybeArrayComprehension);
  }
  function maybeArrayComprehension(type) {
    if (type == "for") return pass(comprehension, expect("]"));
    if (type == ",") return cont(commasep(expressionNoComma, "]"));
    return pass(commasep(expressionNoComma, "]"));
  }
  function comprehension(type) {
    if (type == "for") return cont(forspec, comprehension);
    if (type == "if") return cont(expression, comprehension);
  }

  // Interface

  return {
    startState: function(basecolumn) {
      var state = {
        tokenize: tokenBase,
        lastType: "sof",
        cc: [],
        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
        localVars: parserConfig.localVars,
        context: parserConfig.localVars && {vars: parserConfig.localVars},
        indented: 0
      };
      if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
        state.globalVars = parserConfig.globalVars;
      return state;
    },

    token: function(stream, state) {
      if (stream.sol()) {
        if (!state.lexical.hasOwnProperty("align"))
          state.lexical.align = false;
        state.indented = stream.indentation();
        findFatArrow(stream, state);
      }
      if (state.tokenize != tokenComment && stream.eatSpace()) return null;
      var style = state.tokenize(stream, state);
      if (type == "comment") return style;
      state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
      return parseJS(state, style, type, content, stream);
    },

    indent: function(state, textAfter) {
      if (state.tokenize == tokenComment) return CodeMirror.Pass;
      if (state.tokenize != tokenBase) return 0;
      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;
      // Kludge to prevent 'maybelse' from blocking lexical scope pops
      if (!/^\s*else\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {
        var c = state.cc[i];
        if (c == poplex) lexical = lexical.prev;
        else if (c != maybeelse) break;
      }
      if (lexical.type == "stat" && firstChar == "}") lexical = lexical.prev;
      if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
        lexical = lexical.prev;
      var type = lexical.type, closing = firstChar == type;

      if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info + 1 : 0);
      else if (type == "form" && firstChar == "{") return lexical.indented;
      else if (type == "form") return lexical.indented + indentUnit;
      else if (type == "stat")
        return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? statementIndent || indentUnit : 0);
      else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
        return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
      else if (lexical.align) return lexical.column + (closing ? 0 : 1);
      else return lexical.indented + (closing ? 0 : indentUnit);
    },

    electricChars: ":{}",
    blockCommentStart: jsonMode ? null : "/*",
    blockCommentEnd: jsonMode ? null : "*/",
    lineComment: jsonMode ? null : "//",
    fold: "brace",

    helperType: jsonMode ? "json" : "javascript",
    jsonldMode: jsonldMode,
    jsonMode: jsonMode
  };
});

CodeMirror.defineMIME("text/javascript", "javascript");
CodeMirror.defineMIME("text/ecmascript", "javascript");
CodeMirror.defineMIME("application/javascript", "javascript");
CodeMirror.defineMIME("application/ecmascript", "javascript");
CodeMirror.defineMIME("application/json", {name: "javascript", json: true});
CodeMirror.defineMIME("application/x-json", {name: "javascript", json: true});
CodeMirror.defineMIME("application/ld+json", {name: "javascript", jsonld: true});
CodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });
CodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });

});

},{"../../lib/codemirror":22}],28:[function(require,module,exports){
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror", require("../xml/xml")));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror", "../xml/xml"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("markdown", function(cmCfg, modeCfg) {

  var htmlFound = CodeMirror.modes.hasOwnProperty("xml");
  var htmlMode = CodeMirror.getMode(cmCfg, htmlFound ? {name: "xml", htmlMode: true} : "text/plain");
  var aliases = {
    html: "htmlmixed",
    js: "javascript",
    json: "application/json",
    c: "text/x-csrc",
    "c++": "text/x-c++src",
    java: "text/x-java",
    csharp: "text/x-csharp",
    "c#": "text/x-csharp",
    scala: "text/x-scala"
  };

  var getMode = (function () {
    var i, modes = {}, mimes = {}, mime;

    var list = [];
    for (var m in CodeMirror.modes)
      if (CodeMirror.modes.propertyIsEnumerable(m)) list.push(m);
    for (i = 0; i < list.length; i++) {
      modes[list[i]] = list[i];
    }
    var mimesList = [];
    for (var m in CodeMirror.mimeModes)
      if (CodeMirror.mimeModes.propertyIsEnumerable(m))
        mimesList.push({mime: m, mode: CodeMirror.mimeModes[m]});
    for (i = 0; i < mimesList.length; i++) {
      mime = mimesList[i].mime;
      mimes[mime] = mimesList[i].mime;
    }

    for (var a in aliases) {
      if (aliases[a] in modes || aliases[a] in mimes)
        modes[a] = aliases[a];
    }

    return function (lang) {
      return modes[lang] ? CodeMirror.getMode(cmCfg, modes[lang]) : null;
    };
  }());

  // Should characters that affect highlighting be highlighted separate?
  // Does not include characters that will be output (such as `1.` and `-` for lists)
  if (modeCfg.highlightFormatting === undefined)
    modeCfg.highlightFormatting = false;

  // Maximum number of nested blockquotes. Set to 0 for infinite nesting.
  // Excess `>` will emit `error` token.
  if (modeCfg.maxBlockquoteDepth === undefined)
    modeCfg.maxBlockquoteDepth = 0;

  // Should underscores in words open/close em/strong?
  if (modeCfg.underscoresBreakWords === undefined)
    modeCfg.underscoresBreakWords = true;

  // Turn on fenced code blocks? ("```" to start/end)
  if (modeCfg.fencedCodeBlocks === undefined) modeCfg.fencedCodeBlocks = false;

  // Turn on task lists? ("- [ ] " and "- [x] ")
  if (modeCfg.taskLists === undefined) modeCfg.taskLists = false;

  var codeDepth = 0;

  var header   = 'header'
  ,   code     = 'comment'
  ,   quote    = 'quote'
  ,   list1    = 'variable-2'
  ,   list2    = 'variable-3'
  ,   list3    = 'keyword'
  ,   hr       = 'hr'
  ,   image    = 'tag'
  ,   formatting = 'formatting'
  ,   linkinline = 'link'
  ,   linkemail = 'link'
  ,   linktext = 'link'
  ,   linkhref = 'string'
  ,   em       = 'em'
  ,   strong   = 'strong';

  var hrRE = /^([*\-=_])(?:\s*\1){2,}\s*$/
  ,   ulRE = /^[*\-+]\s+/
  ,   olRE = /^[0-9]+\.\s+/
  ,   taskListRE = /^\[(x| )\](?=\s)/ // Must follow ulRE or olRE
  ,   atxHeaderRE = /^#+/
  ,   setextHeaderRE = /^(?:\={1,}|-{1,})$/
  ,   textRE = /^[^#!\[\]*_\\<>` "'(]+/;

  function switchInline(stream, state, f) {
    state.f = state.inline = f;
    return f(stream, state);
  }

  function switchBlock(stream, state, f) {
    state.f = state.block = f;
    return f(stream, state);
  }


  // Blocks

  function blankLine(state) {
    // Reset linkTitle state
    state.linkTitle = false;
    // Reset EM state
    state.em = false;
    // Reset STRONG state
    state.strong = false;
    // Reset state.quote
    state.quote = 0;
    if (!htmlFound && state.f == htmlBlock) {
      state.f = inlineNormal;
      state.block = blockNormal;
    }
    // Reset state.trailingSpace
    state.trailingSpace = 0;
    state.trailingSpaceNewLine = false;
    // Mark this line as blank
    state.thisLineHasContent = false;
    return null;
  }

  function blockNormal(stream, state) {

    var sol = stream.sol();

    var prevLineIsList = (state.list !== false);
    if (state.list !== false && state.indentationDiff >= 0) { // Continued list
      if (state.indentationDiff < 4) { // Only adjust indentation if *not* a code block
        state.indentation -= state.indentationDiff;
      }
      state.list = null;
    } else if (state.list !== false && state.indentation > 0) {
      state.list = null;
      state.listDepth = Math.floor(state.indentation / 4);
    } else if (state.list !== false) { // No longer a list
      state.list = false;
      state.listDepth = 0;
    }

    var match = null;
    if (state.indentationDiff >= 4) {
      state.indentation -= 4;
      stream.skipToEnd();
      return code;
    } else if (stream.eatSpace()) {
      return null;
    } else if (match = stream.match(atxHeaderRE)) {
      state.header = match[0].length <= 6 ? match[0].length : 6;
      if (modeCfg.highlightFormatting) state.formatting = "header";
      state.f = state.inline;
      return getType(state);
    } else if (state.prevLineHasContent && (match = stream.match(setextHeaderRE))) {
      state.header = match[0].charAt(0) == '=' ? 1 : 2;
      if (modeCfg.highlightFormatting) state.formatting = "header";
      state.f = state.inline;
      return getType(state);
    } else if (stream.eat('>')) {
      state.indentation++;
      state.quote = sol ? 1 : state.quote + 1;
      if (modeCfg.highlightFormatting) state.formatting = "quote";
      stream.eatSpace();
      return getType(state);
    } else if (stream.peek() === '[') {
      return switchInline(stream, state, footnoteLink);
    } else if (stream.match(hrRE, true)) {
      return hr;
    } else if ((!state.prevLineHasContent || prevLineIsList) && (stream.match(ulRE, false) || stream.match(olRE, false))) {
      var listType = null;
      if (stream.match(ulRE, true)) {
        listType = 'ul';
      } else {
        stream.match(olRE, true);
        listType = 'ol';
      }
      state.indentation += 4;
      state.list = true;
      state.listDepth++;
      if (modeCfg.taskLists && stream.match(taskListRE, false)) {
        state.taskList = true;
      }
      state.f = state.inline;
      if (modeCfg.highlightFormatting) state.formatting = ["list", "list-" + listType];
      return getType(state);
    } else if (modeCfg.fencedCodeBlocks && stream.match(/^```([\w+#]*)/, true)) {
      // try switching mode
      state.localMode = getMode(RegExp.$1);
      if (state.localMode) state.localState = state.localMode.startState();
      switchBlock(stream, state, local);
      if (modeCfg.highlightFormatting) state.formatting = "code-block";
      state.code = true;
      return getType(state);
    }

    return switchInline(stream, state, state.inline);
  }

  function htmlBlock(stream, state) {
    var style = htmlMode.token(stream, state.htmlState);
    if ((htmlFound && !state.htmlState.tagName && !state.htmlState.context) ||
        (state.md_inside && stream.current().indexOf(">") > -1)) {
      state.f = inlineNormal;
      state.block = blockNormal;
      state.htmlState = null;
    }
    return style;
  }

  function local(stream, state) {
    if (stream.sol() && stream.match(/^```/, true)) {
      state.localMode = state.localState = null;
      state.f = inlineNormal;
      state.block = blockNormal;
      if (modeCfg.highlightFormatting) state.formatting = "code-block";
      state.code = true;
      var returnType = getType(state);
      state.code = false;
      return returnType;
    } else if (state.localMode) {
      return state.localMode.token(stream, state.localState);
    } else {
      stream.skipToEnd();
      return code;
    }
  }

  // Inline
  function getType(state) {
    var styles = [];

    if (state.formatting) {
      styles.push(formatting);

      if (typeof state.formatting === "string") state.formatting = [state.formatting];

      for (var i = 0; i < state.formatting.length; i++) {
        styles.push(formatting + "-" + state.formatting[i]);

        if (state.formatting[i] === "header") {
          styles.push(formatting + "-" + state.formatting[i] + "-" + state.header);
        }

        // Add `formatting-quote` and `formatting-quote-#` for blockquotes
        // Add `error` instead if the maximum blockquote nesting depth is passed
        if (state.formatting[i] === "quote") {
          if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {
            styles.push(formatting + "-" + state.formatting[i] + "-" + state.quote);
          } else {
            styles.push("error");
          }
        }
      }
    }

    if (state.taskOpen) {
      styles.push("meta");
      return styles.length ? styles.join(' ') : null;
    }
    if (state.taskClosed) {
      styles.push("property");
      return styles.length ? styles.join(' ') : null;
    }

    if (state.linkHref) {
      styles.push(linkhref);
      return styles.length ? styles.join(' ') : null;
    }

    if (state.strong) { styles.push(strong); }
    if (state.em) { styles.push(em); }

    if (state.linkText) { styles.push(linktext); }

    if (state.code) { styles.push(code); }

    if (state.header) { styles.push(header); styles.push(header + "-" + state.header); }

    if (state.quote) {
      styles.push(quote);

      // Add `quote-#` where the maximum for `#` is modeCfg.maxBlockquoteDepth
      if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {
        styles.push(quote + "-" + state.quote);
      } else {
        styles.push(quote + "-" + modeCfg.maxBlockquoteDepth);
      }
    }

    if (state.list !== false) {
      var listMod = (state.listDepth - 1) % 3;
      if (!listMod) {
        styles.push(list1);
      } else if (listMod === 1) {
        styles.push(list2);
      } else {
        styles.push(list3);
      }
    }

    if (state.trailingSpaceNewLine) {
      styles.push("trailing-space-new-line");
    } else if (state.trailingSpace) {
      styles.push("trailing-space-" + (state.trailingSpace % 2 ? "a" : "b"));
    }

    return styles.length ? styles.join(' ') : null;
  }

  function handleText(stream, state) {
    if (stream.match(textRE, true)) {
      return getType(state);
    }
    return undefined;
  }

  function inlineNormal(stream, state) {
    var style = state.text(stream, state);
    if (typeof style !== 'undefined')
      return style;

    if (state.list) { // List marker (*, +, -, 1., etc)
      state.list = null;
      return getType(state);
    }

    if (state.taskList) {
      var taskOpen = stream.match(taskListRE, true)[1] !== "x";
      if (taskOpen) state.taskOpen = true;
      else state.taskClosed = true;
      if (modeCfg.highlightFormatting) state.formatting = "task";
      state.taskList = false;
      return getType(state);
    }

    state.taskOpen = false;
    state.taskClosed = false;

    if (state.header && stream.match(/^#+$/, true)) {
      if (modeCfg.highlightFormatting) state.formatting = "header";
      return getType(state);
    }

    // Get sol() value now, before character is consumed
    var sol = stream.sol();

    var ch = stream.next();

    if (state.escape) {
      state.escape = false;
      return getType(state);
    }

    if (ch === '\\') {
      if (modeCfg.highlightFormatting) state.formatting = "escape";
      state.escape = true;
      return getType(state);
    }

    // Matches link titles present on next line
    if (state.linkTitle) {
      state.linkTitle = false;
      var matchCh = ch;
      if (ch === '(') {
        matchCh = ')';
      }
      matchCh = (matchCh+'').replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
      var regex = '^\\s*(?:[^' + matchCh + '\\\\]+|\\\\\\\\|\\\\.)' + matchCh;
      if (stream.match(new RegExp(regex), true)) {
        return linkhref;
      }
    }

    // If this block is changed, it may need to be updated in GFM mode
    if (ch === '`') {
      var previousFormatting = state.formatting;
      if (modeCfg.highlightFormatting) state.formatting = "code";
      var t = getType(state);
      var before = stream.pos;
      stream.eatWhile('`');
      var difference = 1 + stream.pos - before;
      if (!state.code) {
        codeDepth = difference;
        state.code = true;
        return getType(state);
      } else {
        if (difference === codeDepth) { // Must be exact
          state.code = false;
          return t;
        }
        state.formatting = previousFormatting;
        return getType(state);
      }
    } else if (state.code) {
      return getType(state);
    }

    if (ch === '!' && stream.match(/\[[^\]]*\] ?(?:\(|\[)/, false)) {
      stream.match(/\[[^\]]*\]/);
      state.inline = state.f = linkHref;
      return image;
    }

    if (ch === '[' && stream.match(/.*\](\(| ?\[)/, false)) {
      state.linkText = true;
      if (modeCfg.highlightFormatting) state.formatting = "link";
      return getType(state);
    }

    if (ch === ']' && state.linkText) {
      if (modeCfg.highlightFormatting) state.formatting = "link";
      var type = getType(state);
      state.linkText = false;
      state.inline = state.f = linkHref;
      return type;
    }

    if (ch === '<' && stream.match(/^(https?|ftps?):\/\/(?:[^\\>]|\\.)+>/, false)) {
      state.f = state.inline = linkInline;
      if (modeCfg.highlightFormatting) state.formatting = "link";
      var type = getType(state);
      if (type){
        type += " ";
      } else {
        type = "";
      }
      return type + linkinline;
    }

    if (ch === '<' && stream.match(/^[^> \\]+@(?:[^\\>]|\\.)+>/, false)) {
      state.f = state.inline = linkInline;
      if (modeCfg.highlightFormatting) state.formatting = "link";
      var type = getType(state);
      if (type){
        type += " ";
      } else {
        type = "";
      }
      return type + linkemail;
    }

    if (ch === '<' && stream.match(/^\w/, false)) {
      if (stream.string.indexOf(">") != -1) {
        var atts = stream.string.substring(1,stream.string.indexOf(">"));
        if (/markdown\s*=\s*('|"){0,1}1('|"){0,1}/.test(atts)) {
          state.md_inside = true;
        }
      }
      stream.backUp(1);
      state.htmlState = CodeMirror.startState(htmlMode);
      return switchBlock(stream, state, htmlBlock);
    }

    if (ch === '<' && stream.match(/^\/\w*?>/)) {
      state.md_inside = false;
      return "tag";
    }

    var ignoreUnderscore = false;
    if (!modeCfg.underscoresBreakWords) {
      if (ch === '_' && stream.peek() !== '_' && stream.match(/(\w)/, false)) {
        var prevPos = stream.pos - 2;
        if (prevPos >= 0) {
          var prevCh = stream.string.charAt(prevPos);
          if (prevCh !== '_' && prevCh.match(/(\w)/, false)) {
            ignoreUnderscore = true;
          }
        }
      }
    }
    if (ch === '*' || (ch === '_' && !ignoreUnderscore)) {
      if (sol && stream.peek() === ' ') {
        // Do nothing, surrounded by newline and space
      } else if (state.strong === ch && stream.eat(ch)) { // Remove STRONG
        if (modeCfg.highlightFormatting) state.formatting = "strong";
        var t = getType(state);
        state.strong = false;
        return t;
      } else if (!state.strong && stream.eat(ch)) { // Add STRONG
        state.strong = ch;
        if (modeCfg.highlightFormatting) state.formatting = "strong";
        return getType(state);
      } else if (state.em === ch) { // Remove EM
        if (modeCfg.highlightFormatting) state.formatting = "em";
        var t = getType(state);
        state.em = false;
        return t;
      } else if (!state.em) { // Add EM
        state.em = ch;
        if (modeCfg.highlightFormatting) state.formatting = "em";
        return getType(state);
      }
    } else if (ch === ' ') {
      if (stream.eat('*') || stream.eat('_')) { // Probably surrounded by spaces
        if (stream.peek() === ' ') { // Surrounded by spaces, ignore
          return getType(state);
        } else { // Not surrounded by spaces, back up pointer
          stream.backUp(1);
        }
      }
    }

    if (ch === ' ') {
      if (stream.match(/ +$/, false)) {
        state.trailingSpace++;
      } else if (state.trailingSpace) {
        state.trailingSpaceNewLine = true;
      }
    }

    return getType(state);
  }

  function linkInline(stream, state) {
    var ch = stream.next();

    if (ch === ">") {
      state.f = state.inline = inlineNormal;
      if (modeCfg.highlightFormatting) state.formatting = "link";
      var type = getType(state);
      if (type){
        type += " ";
      } else {
        type = "";
      }
      return type + linkinline;
    }

    stream.match(/^[^>]+/, true);

    return linkinline;
  }

  function linkHref(stream, state) {
    // Check if space, and return NULL if so (to avoid marking the space)
    if(stream.eatSpace()){
      return null;
    }
    var ch = stream.next();
    if (ch === '(' || ch === '[') {
      state.f = state.inline = getLinkHrefInside(ch === "(" ? ")" : "]");
      if (modeCfg.highlightFormatting) state.formatting = "link-string";
      state.linkHref = true;
      return getType(state);
    }
    return 'error';
  }

  function getLinkHrefInside(endChar) {
    return function(stream, state) {
      var ch = stream.next();

      if (ch === endChar) {
        state.f = state.inline = inlineNormal;
        if (modeCfg.highlightFormatting) state.formatting = "link-string";
        var returnState = getType(state);
        state.linkHref = false;
        return returnState;
      }

      if (stream.match(inlineRE(endChar), true)) {
        stream.backUp(1);
      }

      state.linkHref = true;
      return getType(state);
    };
  }

  function footnoteLink(stream, state) {
    if (stream.match(/^[^\]]*\]:/, false)) {
      state.f = footnoteLinkInside;
      stream.next(); // Consume [
      if (modeCfg.highlightFormatting) state.formatting = "link";
      state.linkText = true;
      return getType(state);
    }
    return switchInline(stream, state, inlineNormal);
  }

  function footnoteLinkInside(stream, state) {
    if (stream.match(/^\]:/, true)) {
      state.f = state.inline = footnoteUrl;
      if (modeCfg.highlightFormatting) state.formatting = "link";
      var returnType = getType(state);
      state.linkText = false;
      return returnType;
    }

    stream.match(/^[^\]]+/, true);

    return linktext;
  }

  function footnoteUrl(stream, state) {
    // Check if space, and return NULL if so (to avoid marking the space)
    if(stream.eatSpace()){
      return null;
    }
    // Match URL
    stream.match(/^[^\s]+/, true);
    // Check for link title
    if (stream.peek() === undefined) { // End of line, set flag to check next line
      state.linkTitle = true;
    } else { // More content on line, check if link title
      stream.match(/^(?:\s+(?:"(?:[^"\\]|\\\\|\\.)+"|'(?:[^'\\]|\\\\|\\.)+'|\((?:[^)\\]|\\\\|\\.)+\)))?/, true);
    }
    state.f = state.inline = inlineNormal;
    return linkhref;
  }

  var savedInlineRE = [];
  function inlineRE(endChar) {
    if (!savedInlineRE[endChar]) {
      // Escape endChar for RegExp (taken from http://stackoverflow.com/a/494122/526741)
      endChar = (endChar+'').replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
      // Match any non-endChar, escaped character, as well as the closing
      // endChar.
      savedInlineRE[endChar] = new RegExp('^(?:[^\\\\]|\\\\.)*?(' + endChar + ')');
    }
    return savedInlineRE[endChar];
  }

  var mode = {
    startState: function() {
      return {
        f: blockNormal,

        prevLineHasContent: false,
        thisLineHasContent: false,

        block: blockNormal,
        htmlState: null,
        indentation: 0,

        inline: inlineNormal,
        text: handleText,

        escape: false,
        formatting: false,
        linkText: false,
        linkHref: false,
        linkTitle: false,
        em: false,
        strong: false,
        header: 0,
        taskList: false,
        list: false,
        listDepth: 0,
        quote: 0,
        trailingSpace: 0,
        trailingSpaceNewLine: false
      };
    },

    copyState: function(s) {
      return {
        f: s.f,

        prevLineHasContent: s.prevLineHasContent,
        thisLineHasContent: s.thisLineHasContent,

        block: s.block,
        htmlState: s.htmlState && CodeMirror.copyState(htmlMode, s.htmlState),
        indentation: s.indentation,

        localMode: s.localMode,
        localState: s.localMode ? CodeMirror.copyState(s.localMode, s.localState) : null,

        inline: s.inline,
        text: s.text,
        escape: false,
        formatting: false,
        linkTitle: s.linkTitle,
        em: s.em,
        strong: s.strong,
        header: s.header,
        taskList: s.taskList,
        list: s.list,
        listDepth: s.listDepth,
        quote: s.quote,
        trailingSpace: s.trailingSpace,
        trailingSpaceNewLine: s.trailingSpaceNewLine,
        md_inside: s.md_inside
      };
    },

    token: function(stream, state) {

      // Reset state.formatting
      state.formatting = false;

      if (stream.sol()) {
        var forceBlankLine = stream.match(/^\s*$/, true) || state.header;

        // Reset state.header
        state.header = 0;

        if (forceBlankLine) {
          state.prevLineHasContent = false;
          blankLine(state);
          return this.token(stream, state);
        } else {
          state.prevLineHasContent = state.thisLineHasContent;
          state.thisLineHasContent = true;
        }

        // Reset state.escape
        state.escape = false;

        // Reset state.taskList
        state.taskList = false;

        // Reset state.code
        state.code = false;

        // Reset state.trailingSpace
        state.trailingSpace = 0;
        state.trailingSpaceNewLine = false;

        state.f = state.block;
        var indentation = stream.match(/^\s*/, true)[0].replace(/\t/g, '    ').length;
        var difference = Math.floor((indentation - state.indentation) / 4) * 4;
        if (difference > 4) difference = 4;
        var adjustedIndentation = state.indentation + difference;
        state.indentationDiff = adjustedIndentation - state.indentation;
        state.indentation = adjustedIndentation;
        if (indentation > 0) return null;
      }
      var result = state.f(stream, state);
      if (stream.start == stream.pos) return this.token(stream, state);
      else return result;
    },

    innerMode: function(state) {
      if (state.block == htmlBlock) return {state: state.htmlState, mode: htmlMode};
      if (state.localState) return {state: state.localState, mode: state.localMode};
      return {state: state, mode: mode};
    },

    blankLine: blankLine,

    getType: getType,

    fold: "markdown"
  };
  return mode;
}, "xml");

CodeMirror.defineMIME("text/x-markdown", "markdown");

});

},{"../../lib/codemirror":22,"../xml/xml":29}],29:[function(require,module,exports){
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("xml", function(config, parserConfig) {
  var indentUnit = config.indentUnit;
  var multilineTagIndentFactor = parserConfig.multilineTagIndentFactor || 1;
  var multilineTagIndentPastTag = parserConfig.multilineTagIndentPastTag;
  if (multilineTagIndentPastTag == null) multilineTagIndentPastTag = true;

  var Kludges = parserConfig.htmlMode ? {
    autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,
                      'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,
                      'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,
                      'track': true, 'wbr': true},
    implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,
                       'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,
                       'th': true, 'tr': true},
    contextGrabbers: {
      'dd': {'dd': true, 'dt': true},
      'dt': {'dd': true, 'dt': true},
      'li': {'li': true},
      'option': {'option': true, 'optgroup': true},
      'optgroup': {'optgroup': true},
      'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,
            'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,
            'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,
            'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,
            'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},
      'rp': {'rp': true, 'rt': true},
      'rt': {'rp': true, 'rt': true},
      'tbody': {'tbody': true, 'tfoot': true},
      'td': {'td': true, 'th': true},
      'tfoot': {'tbody': true},
      'th': {'td': true, 'th': true},
      'thead': {'tbody': true, 'tfoot': true},
      'tr': {'tr': true}
    },
    doNotIndent: {"pre": true},
    allowUnquoted: true,
    allowMissing: true,
    caseFold: true
  } : {
    autoSelfClosers: {},
    implicitlyClosed: {},
    contextGrabbers: {},
    doNotIndent: {},
    allowUnquoted: false,
    allowMissing: false,
    caseFold: false
  };
  var alignCDATA = parserConfig.alignCDATA;

  // Return variables for tokenizers
  var type, setStyle;

  function inText(stream, state) {
    function chain(parser) {
      state.tokenize = parser;
      return parser(stream, state);
    }

    var ch = stream.next();
    if (ch == "<") {
      if (stream.eat("!")) {
        if (stream.eat("[")) {
          if (stream.match("CDATA[")) return chain(inBlock("atom", "]]>"));
          else return null;
        } else if (stream.match("--")) {
          return chain(inBlock("comment", "-->"));
        } else if (stream.match("DOCTYPE", true, true)) {
          stream.eatWhile(/[\w\._\-]/);
          return chain(doctype(1));
        } else {
          return null;
        }
      } else if (stream.eat("?")) {
        stream.eatWhile(/[\w\._\-]/);
        state.tokenize = inBlock("meta", "?>");
        return "meta";
      } else {
        type = stream.eat("/") ? "closeTag" : "openTag";
        state.tokenize = inTag;
        return "tag bracket";
      }
    } else if (ch == "&") {
      var ok;
      if (stream.eat("#")) {
        if (stream.eat("x")) {
          ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";");
        } else {
          ok = stream.eatWhile(/[\d]/) && stream.eat(";");
        }
      } else {
        ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat(";");
      }
      return ok ? "atom" : "error";
    } else {
      stream.eatWhile(/[^&<]/);
      return null;
    }
  }

  function inTag(stream, state) {
    var ch = stream.next();
    if (ch == ">" || (ch == "/" && stream.eat(">"))) {
      state.tokenize = inText;
      type = ch == ">" ? "endTag" : "selfcloseTag";
      return "tag bracket";
    } else if (ch == "=") {
      type = "equals";
      return null;
    } else if (ch == "<") {
      state.tokenize = inText;
      state.state = baseState;
      state.tagName = state.tagStart = null;
      var next = state.tokenize(stream, state);
      return next ? next + " error" : "error";
    } else if (/[\'\"]/.test(ch)) {
      state.tokenize = inAttribute(ch);
      state.stringStartCol = stream.column();
      return state.tokenize(stream, state);
    } else {
      stream.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/);
      return "word";
    }
  }

  function inAttribute(quote) {
    var closure = function(stream, state) {
      while (!stream.eol()) {
        if (stream.next() == quote) {
          state.tokenize = inTag;
          break;
        }
      }
      return "string";
    };
    closure.isInAttribute = true;
    return closure;
  }

  function inBlock(style, terminator) {
    return function(stream, state) {
      while (!stream.eol()) {
        if (stream.match(terminator)) {
          state.tokenize = inText;
          break;
        }
        stream.next();
      }
      return style;
    };
  }
  function doctype(depth) {
    return function(stream, state) {
      var ch;
      while ((ch = stream.next()) != null) {
        if (ch == "<") {
          state.tokenize = doctype(depth + 1);
          return state.tokenize(stream, state);
        } else if (ch == ">") {
          if (depth == 1) {
            state.tokenize = inText;
            break;
          } else {
            state.tokenize = doctype(depth - 1);
            return state.tokenize(stream, state);
          }
        }
      }
      return "meta";
    };
  }

  function Context(state, tagName, startOfLine) {
    this.prev = state.context;
    this.tagName = tagName;
    this.indent = state.indented;
    this.startOfLine = startOfLine;
    if (Kludges.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))
      this.noIndent = true;
  }
  function popContext(state) {
    if (state.context) state.context = state.context.prev;
  }
  function maybePopContext(state, nextTagName) {
    var parentTagName;
    while (true) {
      if (!state.context) {
        return;
      }
      parentTagName = state.context.tagName;
      if (!Kludges.contextGrabbers.hasOwnProperty(parentTagName) ||
          !Kludges.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {
        return;
      }
      popContext(state);
    }
  }

  function baseState(type, stream, state) {
    if (type == "openTag") {
      state.tagStart = stream.column();
      return tagNameState;
    } else if (type == "closeTag") {
      return closeTagNameState;
    } else {
      return baseState;
    }
  }
  function tagNameState(type, stream, state) {
    if (type == "word") {
      state.tagName = stream.current();
      setStyle = "tag";
      return attrState;
    } else {
      setStyle = "error";
      return tagNameState;
    }
  }
  function closeTagNameState(type, stream, state) {
    if (type == "word") {
      var tagName = stream.current();
      if (state.context && state.context.tagName != tagName &&
          Kludges.implicitlyClosed.hasOwnProperty(state.context.tagName))
        popContext(state);
      if (state.context && state.context.tagName == tagName) {
        setStyle = "tag";
        return closeState;
      } else {
        setStyle = "tag error";
        return closeStateErr;
      }
    } else {
      setStyle = "error";
      return closeStateErr;
    }
  }

  function closeState(type, _stream, state) {
    if (type != "endTag") {
      setStyle = "error";
      return closeState;
    }
    popContext(state);
    return baseState;
  }
  function closeStateErr(type, stream, state) {
    setStyle = "error";
    return closeState(type, stream, state);
  }

  function attrState(type, _stream, state) {
    if (type == "word") {
      setStyle = "attribute";
      return attrEqState;
    } else if (type == "endTag" || type == "selfcloseTag") {
      var tagName = state.tagName, tagStart = state.tagStart;
      state.tagName = state.tagStart = null;
      if (type == "selfcloseTag" ||
          Kludges.autoSelfClosers.hasOwnProperty(tagName)) {
        maybePopContext(state, tagName);
      } else {
        maybePopContext(state, tagName);
        state.context = new Context(state, tagName, tagStart == state.indented);
      }
      return baseState;
    }
    setStyle = "error";
    return attrState;
  }
  function attrEqState(type, stream, state) {
    if (type == "equals") return attrValueState;
    if (!Kludges.allowMissing) setStyle = "error";
    return attrState(type, stream, state);
  }
  function attrValueState(type, stream, state) {
    if (type == "string") return attrContinuedState;
    if (type == "word" && Kludges.allowUnquoted) {setStyle = "string"; return attrState;}
    setStyle = "error";
    return attrState(type, stream, state);
  }
  function attrContinuedState(type, stream, state) {
    if (type == "string") return attrContinuedState;
    return attrState(type, stream, state);
  }

  return {
    startState: function() {
      return {tokenize: inText,
              state: baseState,
              indented: 0,
              tagName: null, tagStart: null,
              context: null};
    },

    token: function(stream, state) {
      if (!state.tagName && stream.sol())
        state.indented = stream.indentation();

      if (stream.eatSpace()) return null;
      type = null;
      var style = state.tokenize(stream, state);
      if ((style || type) && style != "comment") {
        setStyle = null;
        state.state = state.state(type || style, stream, state);
        if (setStyle)
          style = setStyle == "error" ? style + " error" : setStyle;
      }
      return style;
    },

    indent: function(state, textAfter, fullLine) {
      var context = state.context;
      // Indent multi-line strings (e.g. css).
      if (state.tokenize.isInAttribute) {
        if (state.tagStart == state.indented)
          return state.stringStartCol + 1;
        else
          return state.indented + indentUnit;
      }
      if (context && context.noIndent) return CodeMirror.Pass;
      if (state.tokenize != inTag && state.tokenize != inText)
        return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
      // Indent the starts of attribute names.
      if (state.tagName) {
        if (multilineTagIndentPastTag)
          return state.tagStart + state.tagName.length + 2;
        else
          return state.tagStart + indentUnit * multilineTagIndentFactor;
      }
      if (alignCDATA && /<!\[CDATA\[/.test(textAfter)) return 0;
      var tagAfter = textAfter && /^<(\/)?([\w_:\.-]*)/.exec(textAfter);
      if (tagAfter && tagAfter[1]) { // Closing tag spotted
        while (context) {
          if (context.tagName == tagAfter[2]) {
            context = context.prev;
            break;
          } else if (Kludges.implicitlyClosed.hasOwnProperty(context.tagName)) {
            context = context.prev;
          } else {
            break;
          }
        }
      } else if (tagAfter) { // Opening tag spotted
        while (context) {
          var grabbers = Kludges.contextGrabbers[context.tagName];
          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))
            context = context.prev;
          else
            break;
        }
      }
      while (context && !context.startOfLine)
        context = context.prev;
      if (context) return context.indent + indentUnit;
      else return 0;
    },

    electricInput: /<\/[\s\w:]+>$/,
    blockCommentStart: "<!--",
    blockCommentEnd: "-->",

    configuration: parserConfig.htmlMode ? "html" : "xml",
    helperType: parserConfig.htmlMode ? "html" : "xml"
  };
});

CodeMirror.defineMIME("text/xml", "xml");
CodeMirror.defineMIME("application/xml", "xml");
if (!CodeMirror.mimeModes.hasOwnProperty("text/html"))
  CodeMirror.defineMIME("text/html", {name: "xml", htmlMode: true});

});

},{"../../lib/codemirror":22}],30:[function(require,module,exports){
var hbsBase               = require('handlebars/dist/cjs/handlebars/base');
var Utils                 = require('./utils');
var HandlebarsEnvironment = hbsBase.HandlebarsEnvironment;

/**
 * Extend Handlebars base object with custom functionality.
 *
 * @type {Object}
 */
var base = module.exports = Utils.create(hbsBase);

/**
 * Wrap old-style Handlebars helpers with the updated object syntax return.
 *
 * @param  {Function} helper
 * @return {Function}
 */
var wrapOldHelper = function (helper) {
  return function () {
    var result = helper.apply(this, arguments);

    // Need a special handler for the `with` helper which won't always execute.
    return result == null ? result : result.value;
  };
};

/**
 * Register DOMBars helpers on the passed in DOMBars instance.
 *
 * @param {Object} instance
 */
var registerDefaultHelpers = function (instance) {
  /**
   * The handlebars `each` helper is incompatibable with DOMBars, since it
   * assumes string concatination (as opposed to document fragments).
   *
   * @param  {Object} context
   * @param  {Object} options
   * @return {Node}
   */
  instance.registerHelper('each', function (context, options) {
    var fn       = options.fn;
    var inverse  = options.inverse;
    var fragment = document.createDocumentFragment();
    var i        = 0;
    var data;

    if (typeof context === 'function') {
      context = context.call(this);
    }

    if (options.data) {
      data = Utils.create(options.data);
    }

    if (typeof context === 'object') {
      var len = context.length;

      if (len === +len) {
        for (; i < len; i++) {
          data.index = i;
          data.first = (i === 0);
          data.last  = (i === len - 1);

          fragment.appendChild(fn(context[i], { data: data }).value);
        }
      } else {
        for (var key in context) {
          if (Object.prototype.hasOwnProperty.call(context, key)) {
            i += 1;

            data.key   = key;
            data.index = i;
            data.first = (i === 0);

            fragment.appendChild(fn(context[key], { data: data }).value);
          }
        }
      }
    }

    if (i === 0) {
      return inverse(this).value;
    }

    return fragment;
  });

  // Register updated Handlebars helpers.
  instance.registerHelper({
    'if':                 wrapOldHelper(instance.helpers.if),
    'with':               wrapOldHelper(instance.helpers.with),
    'blockHelperMissing': wrapOldHelper(instance.helpers.blockHelperMissing)
  });
};

/**
 * Create a custom DOMBars environment to match HandlebarsEnvironment.
 */
var DOMBarsEnvironment = base.DOMBarsEnvironment = function () {
  HandlebarsEnvironment.apply(this, arguments);
  registerDefaultHelpers(this);
};

/**
 * Extend the HandlebarsEnvironment prototype.
 *
 * @type {Object}
 */
var envPrototype = DOMBarsEnvironment.prototype = Utils.create(
  HandlebarsEnvironment.prototype
);

/**
 * Alias some useful functionality that is expected to be exposed on the root
 * object.
 */
envPrototype.createFrame       = hbsBase.createFrame;
envPrototype.REVISION_CHANGES  = hbsBase.REVISION_CHANGES;
envPrototype.COMPILER_REVISION = hbsBase.COMPILER_REVISION;

/**
 * The basic getter function. Override this with something else based on your
 * project. For example, Backbone.js models.
 *
 * @param  {Object} object
 * @param  {String} property
 * @return {*}
 */
envPrototype.get = function (object, property) {
  return object[property];
};

/**
 * Noop functions for subscribe and unsubscribe. Override with custom
 * functionality.
 */
envPrototype.subscribe = envPrototype.unsubscribe = function () {};

},{"./utils":36,"handlebars/dist/cjs/handlebars/base":37}],31:[function(require,module,exports){
module.exports = require('handlebars/dist/cjs/handlebars/exception').default;

},{"handlebars/dist/cjs/handlebars/exception":38}],32:[function(require,module,exports){
(function (global){
/**
 * Return the current timestamp integer.
 *
 * @return {Number}
 */
var currentTime = global.Date.now || (function () {
  var Constuctor = global.Date;

  return function () {
    return new Constuctor().getTime();
  };
})();

/**
 * Keep local references to the timeout functions. This stops utilities like
 * Sinon.js from breaking the implementation.
 *
 * @type {Function}
 */
var setTimer   = global.setTimeout;
var clearTimer = global.clearTimeout;

/**
 * Fallback animation frame implementation.
 *
 * @return {Function}
 */
var fallback = function () {
  var prev = currentTime();

  return function (fn) {
    var curr = currentTime();
    var ms   = Math.max(0, 16 - (curr - prev));
    var req  = setTimer(fn, ms);

    prev = curr;

    return req;
  };
};

/**
 * Expose `requestAnimationFrame`.
 *
 * @type {Function}
 */
exports = module.exports = global.requestAnimationFrame ||
  global.webkitRequestAnimationFrame ||
  global.mozRequestAnimationFrame ||
  global.msRequestAnimationFrame ||
  global.oRequestAnimationFrame ||
  fallback();

/**
 * Cancel the animation frame.
 *
 * @type {Function}
 */
var cancel = global.cancelAnimationFrame ||
  global.webkitCancelAnimationFrame ||
  global.mozCancelAnimationFrame ||
  global.msCancelAnimationFrame ||
  global.oCancelAnimationFrame ||
  clearTimer;

/**
 * Cancel an animation frame.
 *
 * @param {Number} id
 */
exports.cancel = function (id) {
  cancel.call(global, id);
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],33:[function(require,module,exports){
var hbsVM = require('handlebars/dist/cjs/handlebars/runtime');
var Utils = require('./utils');
var raf   = require('./raf');

/**
 * Keep a map of attributes that need to update the corresponding properties.
 *
 * @type {Object}
 */
var attrProps = {
  INPUT: {
    value:   'value',
    checked: 'checked'
  },
  OPTION: {
    selected: 'selected'
  }
};

/**
 * Iterate over a subscriptions object, calling a function with the object
 * property details and a unique callback function.
 *
 * @param {Array}    subscriptions
 * @param {Function} fn
 * @param {Function} callback
 */
var iterateSubscriptions = function (subscriptions, fn, context) {
  for (var id in subscriptions) {
    for (var property in subscriptions[id]) {
      fn.call(context, subscriptions[id][property], property, id);
    }
  }
};

/**
 * Create a new subsciption instance. This functionality is tightly coupled to
 * DOMBars program execution.
 *
 * @param {Function} fn
 * @param {Function} update
 * @param {Object}   container
 * @param {Object}   env
 */
var Subscription = function (fn, update, container, env) {
  // Alias passed in variables for later access.
  this._fn        = fn;
  this._update    = update;
  this._container = container;
  this._env       = env;

  // Assign every subscription instance a unique id. This helps with linking
  // between parent and child subscription instances.
  this.cid             = 'c' + Utils.uniqueId();
  this.children        = {};
  this.subscriptions   = {};
  this.unsubscriptions = [];

  // Create statically bound function instances for public consumption.
  this.boundUpdate         = Utils.bind(this.update, this);
  this.boundUnsubscription = Utils.bind(this.unsubscription, this);
};

/**
 * Expose the internal susbcribe functionality for the container.
 *
 * @param {Object} object
 * @param {String} property
 * @param {String} id
 */
Subscription.prototype.subscribe = function (object, property, id) {
  (this.subscriptions[id] || (this.subscriptions[id] = {}))[property] = object;
};

/**
 * Pass a custom unsubscription function that will execute when we unsubscribe.
 *
 * @param {Function} fn
 */
Subscription.prototype.unsubscription = function (fn) {
  Utils.isFunction(fn) && this.unsubscriptions.push(fn);
};

/**
 * Unsubscribe from a subcriptions object.
 *
 * @param {Object} subscriptions
 */
Subscription.prototype._unsubscribe = function (subscriptions) {
  iterateSubscriptions(subscriptions, function (object, property, id) {
    delete subscriptions[id][property];
    this._env.unsubscribe(object, property, this.boundUpdate);
  }, this);
};

/**
 * Iterate over an array of unsubscriptions.
 *
 * @param {Array} unsubscriptions
 */
Subscription.prototype._unsubscription = function (unsubscriptions) {
  for (var i = 0; i < unsubscriptions.length; i++) {
    unsubscriptions[i]();
  }
};

/**
 * Unsubscribe everything from the current instance.
 */
Subscription.prototype.unsubscribe = function () {
  if (this._unsubscribed) { return; }

  this._unsubscribe(this.subscriptions);
  this._unsubscription(this.unsubscriptions);

  // Delete any reference to this subscription from the parent.
  if (this.parent) {
    delete this.parent.children[this.cid];
    delete this.parent;
  }

  // Cancel any currently executing functions. We also need to set an
  // unsubscribed flag in case the function is still available somewhere and
  // called after unsubscription has occured.
  VM.exec.cancel(this._execId);
  this._unsubscribed = true;
  this._unsubscribeChildren();

  // Remove unwanted lingering references.
  delete this.children;
  delete this.subscriptions;
  delete this.unsubscriptions;
  delete this._fn;
  delete this._env;
  delete this._update;
  delete this._container;
  delete this.boundUpdate;
  delete this.boundUnsubscription;
};

/**
 * Unsubscribe the current instance children.
 */
Subscription.prototype._unsubscribeChildren = function () {
  for (var child in this.children) {
    this.children[child].unsubscribe();
  }
};

/**
 * Execute the subscription function.
 *
 * @return {*}
 */
Subscription.prototype.execute = function () {
  var parent = this._container.subscription;

  // If we have an existing subscription, link the subscriptions together.
  if (parent && !parent._unsubscribed) {
    this.parent = this._container.subscription;
    this.parent.children[this.cid] = this;
  }

  // Alias the current subscriptions object for diffing after execution.
  this._subscriptions = this.subscriptions;
  this._unsubscription(this.unsubscriptions);

  // Reset the subscriptions and unsubscriptions objects before execution.
  this.subscriptions   = {};
  this.unsubscriptions = [];

  this._container.subscription = this;
  var result = this._fn.apply(this, arguments);
  this._container.subscription = this.parent;

  // The current subscriptions object needs to be compared against the previous
  // subscriptions and any diffences fixed.
  var current  = this.subscriptions;
  var previous = this._subscriptions;

  // Iterate over the new subscriptions object. Check every key in the object
  // against the previous subscriptions. If it exists in the previous object,
  // it means we are already subscribed. Otherwise we need to subscribe to
  // the new property.
  iterateSubscriptions(current, function (object, property, id) {
    if (previous[id] && previous[id][property]) {
      return delete previous[id][property];
    }

    this._env.subscribe(object, property, this.boundUpdate);
  }, this);

  // Iterate over all remaining previous subscriptions and unsubscribe them.
  delete this._subscriptions;
  this._unsubscribe(previous);

  return result;
};

/**
 * Update the susbcription instance with changes.
 *
 * @return {Boolean}
 */
Subscription.prototype.update = function () {
  if (this._triggered || this._unsubscribed) {
    return false;
  }

  this._unsubscribeChildren();

  this._execId = VM.exec(Utils.bind(function () {
    delete this._triggered;
    this._update(this.execute());
  }, this));

  return this._triggered = true;
};

/**
 * Extend the Handlebars runtime environment with DOM specific helpers.
 *
 * @type {Object}
 */
var VM = module.exports = Utils.create(hbsVM);

/**
 * Bind a function to the animation frame.
 *
 * @param  {Function} fn
 * @return {Number}
 */
VM.exec = function (fn) {
  return raf(fn);
};

/**
 * Cancel an execution.
 *
 * @param {Number} id
 */
VM.exec.cancel = function (id) {
  return raf.cancel(id);
};

/**
 * Create an element from a tag name.
 *
 * @param  {String} tagName
 * @param  {Object} env
 * @return {Node}
 */
VM.createElement = function (tagName) {
  return document.createElement(tagName);
};

/**
 * Copy all the data from one element to another and replace in place.
 *
 * @param  {Node}   node
 * @param  {String} tagName
 * @param  {Object} env
 * @return {Node}
 */
VM.setTagName = function (node, tagName) {
  var newNode = VM.createElement(tagName);

  // Move all child elements to the new node.
  while (node.firstChild) {
    newNode.appendChild(node.firstChild);
  }

  // Copy all the attributes to the new node.
  for (var i = 0; i < node.attributes.length; i++) {
    var attribute = node.attributes[i];
    VM.setAttribute(newNode, attribute.name, attribute.value);
  }

  // Replace the node position in the place.
  node.parentNode.replaceChild(newNode, node);

  return newNode;
};

/**
 * Remove an attribute from an element.
 *
 * @param {Node}   el
 * @param {String} name
 * @param {Object} env
 */
VM.removeAttribute = function (el, name) {
  if (!el.hasAttribute(name)) { return; }

  el.removeAttribute(name);

  // Unset the DOM property when the attribute is removed.
  if (attrProps[el.tagName] && attrProps[el.tagName][name]) {
    el[attrProps[el.tagName][name]] = null;
  }
};

/**
 * Set an attribute value on an element.
 *
 * @param {Node}   el
 * @param {String} name
 * @param {*}      value
 * @param {Object} env
 */
VM.setAttribute = function (el, name, value) {
  if (value === false) {
    return VM.removeAttribute(el, name);
  }

  // Set the attribute value to the name when the value is `true`.
  el.setAttribute(name, value === true ? name : value);

  // Update the DOM property when the attribute changes.
  if (attrProps[el.tagName] && attrProps[el.tagName][name]) {
    el[attrProps[el.tagName][name]] = value;
  }
};

/**
 * Create a comment node based on text contents.
 *
 * @param  {String} contents
 * @param  {Object} env
 * @return {Node}
 */
VM.createComment = function (comment) {
  return document.createComment(comment);
};

/**
 * Generate an executable template from a template spec.
 *
 * @param  {Object}   templateSpec
 * @return {Function}
 */
VM.template = function (templateSpec, env) {
  /**
   * Subscriber to function in the DOMBars execution instance.
   *
   * @param  {Function} fn
   * @param  {Function} create
   * @param  {Function} update
   * @return {Object}
   */
  var subscribe = function (fn, create, update) {
    var subscriber = new Subscription(fn, update, container, env);

    // Immediately alias the starting value.
    subscriber.value = subscriber.execute();
    Utils.isFunction(create) && (subscriber.value = create(subscriber.value));

    return subscriber;
  };

  /**
   * Wrap a function with a sanitized public subscriber object.
   *
   * @param  {Function} fn
   * @return {Function}
   */
  var wrapProgram = function (fn) {
    var wrapper = function () {
      var subscriber = new Subscription(fn, null, container, env);

      return {
        value:       subscriber.execute.apply(subscriber, arguments),
        unsubscribe: Utils.bind(subscriber.unsubscribe, subscriber)
      };
    };

    // Extend the wrapper function with properties of the passed in function.
    Utils.extend(wrapper, fn);

    return wrapper;
  };

  /**
   * The container object holds all the functions used by the template spec.
   *
   * @type {Object}
   */
  var container = {
    invokePartial:    VM.invokePartial,
    programs:         [],
    noop:             VM.noop,
    partial:          Utils.partial,
    wrapProgram:      wrapProgram,
    escapeExpression: Utils.escapeExpression,
    programWithDepth: VM.programWithDepth
  };

  /**
   * Render and subscribe a single DOM node using a custom creation function.
   *
   * @param  {Function} fn
   * @param  {Function} create
   * @return {Node}
   */
  var subscribeNode = function (fn, create) {
    return subscribe(fn, function (value) {
      return Utils.trackNode(create(value));
    }, function (value) {
      this.value.replace(create(value));
    }).value.fragment;
  };

  /**
   * Create an element and subscribe to any changes. This method requires a
   * callback function for any element changes since you can't change a tag
   * name in place.
   *
   * @param  {Function} fn
   * @param  {Function} cb
   * @return {Element}
   */
  container.createElement = function (fn, cb) {
    return subscribe(fn, function (value) {
      return VM.createElement(value, env);
    }, function (value) {
      cb(this.value = VM.setTagName(this.value, value, env));
    }).value;
  };

  /**
   * Append an element to the end of another element.
   *
   * @param {Node} parent
   * @param {Node} child
   */
  container.appendChild = function (parent, child) {
    child && parent.appendChild(child);
  };

  /**
   * Set an elements attribute. We accept the current element a function
   * because when a tag name changes we will lose reference to the actively
   * rendered element.
   *
   * @param {Function} currentEl
   * @param {Function} nameFn
   * @param {Function} valueFn
   */
  container.setAttribute = function (currentEl, nameFn, valueFn) {
    var attrName = subscribe(nameFn, null, function (value) {
      VM.removeAttribute(currentEl(), this.value);
      VM.setAttribute(currentEl(), this.value = value, attrValue.value);
    });

    var attrValue = subscribe(valueFn, null, function (value) {
      VM.setAttribute(currentEl(), attrName.value, this.value = value);
    });

    return VM.setAttribute(currentEl(), attrName.value, attrValue.value);
  };

  /**
   * Create a DOM element and subscribe to any changes.
   *
   * @param  {Function} fn
   * @return {Node}
   */
  container.createDOM = function (fn) {
    return subscribeNode(fn, Utils.domifyExpression);
  };

  /**
   * Create a text node and subscribe to any changes.
   *
   * @param  {Function} fn
   * @return {Text}
   */
  container.createText = function (fn) {
    return subscribeNode(fn, Utils.textifyExpression);
  };

  /**
   * Create a comment node and subscribe to any changes.
   *
   * @param  {Function} fn
   * @return {Comment}
   */
  container.createComment = function (fn) {
    return subscribe(fn, function (value) {
      return VM.createComment(value);
    }, function (value) {
      this.value.textContent = value;
    }).value;
  };

  /**
   * Create and return a program singleton based on index.
   *
   * @param  {Number}   i
   * @param  {Function} fn
   * @param  {Object}   data
   * @return {Function}
   */
  container.program = function (i, fn, data) {
    var programWrapper = container.programs[i];

    if (data) {
      return VM.program(i, fn, data);
    }

    if (!programWrapper) {
      return container.programs[i] = VM.program(i, fn);
    }

    return programWrapper;
  };

  /**
   * Merge two objects into a single object.
   *
   * @param  {Object} param
   * @param  {Object} common
   * @return {Object}
   */
  container.merge = function (param, common) {
    var ret = param || common;

    if (param && common && (param !== common)) {
      ret = {};
      Utils.extend(ret, common);
      Utils.extend(ret, param);
    }

    return ret;
  };

  /**
   * Get a property from an object. Passes in the object id (depth) to make it
   * much faster to do comparisons between new and old subscriptions.
   *
   * @param  {Object} object
   * @param  {String} property
   * @param  {String} id
   * @return {*}
   */
  container.get = function (object, property, id) {
    container.subscription.subscribe(object, property, id);
    return env.get(object, property);
  };

  /**
   * Return the compiled JavaScript function for execution.
   *
   * @param  {Object} context
   * @param  {Object} options
   * @return {Node}
   */
  return wrapProgram(function (context, options) {
    options = options || {};

    var namespace = options.partial ? options : env;
    var helpers;
    var partials;

    if (!options.partial) {
      helpers  = options.helpers;
      partials = options.partials;
    }

    var result = templateSpec.call(
      container,
      namespace,
      context,
      helpers,
      partials,
      options.data
    );

    if (!options.partial) {
      env.VM.checkRevision(container.compilerInfo);
    }

    return result;
  });
};

},{"./raf":32,"./utils":36,"handlebars/dist/cjs/handlebars/runtime":39}],34:[function(require,module,exports){
module.exports = require('handlebars/dist/cjs/handlebars/safe-string').default;

},{"handlebars/dist/cjs/handlebars/safe-string":40}],35:[function(require,module,exports){
var TrackNode = module.exports = function (node) {
  this.fragment = document.createDocumentFragment();

  // Instantly append a before and after tracking node.
  this.before = this.fragment.appendChild(document.createTextNode(''));
  this.after  = this.fragment.appendChild(document.createTextNode(''));

  // Append the passed in node to the current fragment.
  node && this.appendChild(node);
};

/**
 * Append a node to the current tracking fragment.
 *
 * @param  {Node} node
 * @return {this}
 */
TrackNode.prototype.appendChild = function (node) {
  this.after.parentNode && this.after.parentNode.insertBefore(node, this.after);

  return this;
};

/**
 * Prepend a node to the current tracking fragment.
 *
 * @param  {Node} node
 * @return {this}
 */
TrackNode.prototype.prependChild = function (node) {
  this.before.parentNode.insertBefore(node, this.before.nextSibling);

  return this;
};

/**
 * Remove all elements between the two tracking nodes.
 *
 * @param  {Node} node
 * @return {this}
 */
TrackNode.prototype.empty = function () {
  while (this.before.nextSibling && this.before.nextSibling !== this.after) {
    this.before.parentNode.removeChild(this.before.nextSibling);
  }

  return this;
};

/**
 * Remove the the elements from the DOM.
 *
 * @param  {Node} node
 * @return {this}
 */
TrackNode.prototype.remove = function () {
  while (this.before.nextSibling && this.before.nextSibling !== this.after) {
    this.fragment.appendChild(this.before.nextSibling);
  }

  // Pull the two reference nodes out of the DOM and into the fragment.
  this.fragment.appendChild(this.after);
  this.fragment.insertBefore(this.before, this.fragment.firstChild);

  return this;
};

/**
 * Replace the contents of the tracking node with new contents.
 *
 * @param  {Node} node
 * @return {this}
 */
TrackNode.prototype.replace = function (node) {
  return this.empty().appendChild(node);
};

},{}],36:[function(require,module,exports){
var hbsUtils   = require('handlebars/dist/cjs/handlebars/utils');
var uniqueId   = 0;
var TrackNode  = require('./track-node');
var SafeString = require('./safe-string');
var __slice    = Array.prototype.slice;

/**
 * Simple way to subclass an object, with support for older browsers.
 *
 * @return {Object}
 */
var create = Object.create || (function () {
  var F = function () {};

  return function (o) {
    F.prototype = o;
    var obj = new F();
    F.prototype = null;
    return obj;
  };
})();

/**
 * Extend Handlebars utilities with DOM functionality.
 *
 * @type {Object}
 */
var Utils = module.exports = create(hbsUtils);

/**
 * Return a unique id.
 *
 * @return {Number}
 */
Utils.uniqueId = function () {
  return uniqueId++;
};

/**
 * Create a function that accepts an unlimited number of arguments as the last
 * argument.
 *
 * @param  {Function} fn
 * @return {Function}
 */
Utils.variadic = function (fn) {
  var count = Math.max(fn.length - 1, 0);

  return function () {
    var args = __slice.call(arguments, 0, count);

    // Enforce the array length, in case we didn't have enough arguments.
    args.length = count;
    args.push(__slice.call(arguments, count));

    return fn.apply(this, args);
  };
};

/**
 * Simple partial application function.
 *
 * @param  {Function} fn
 * @param  {*}        ...
 * @return {Function}
 */
Utils.partial = Utils.variadic(function (fn, args) {
  return Utils.variadic(function (called) {
    return fn.apply(this, args.concat(called));
  });
});

/**
 * Bind a function to a certain context.
 *
 * @param  {Function} fn
 * @param  {Object}   context
 * @param  {*}        ...
 * @return {Function}
 */
Utils.bind = Utils.variadic(function (fn, context, args) {
  return Utils.variadic(function (called) {
    return fn.apply(context, args.concat(called));
  });
});

/**
 * Expose the create function.
 *
 * @type {Function}
 */
Utils.create = create;

/**
 * Check whether an object is actually a DOM node.
 *
 * @param  {*}       element
 * @return {Boolean}
 */
Utils.isNode = function (element) {
  return element instanceof Node;
};

/**
 * Track a node instance anywhere it goes in the DOM.
 *
 * @param  {Node}      node
 * @return {TrackNode}
 */
Utils.trackNode = function (node) {
  return new TrackNode(node);
};

/**
 * Transform a string into arbitrary DOM nodes.
 *
 * @param  {String} string
 * @return {Node}
 */
Utils.domifyExpression = function (string) {
  // If we passed in a safe string, get the actual value.
  if (string instanceof SafeString) {
    string = string.string;
  }

  // No need to coerce a node.
  if (Utils.isNode(string)) {
    return string;
  }

  var div = document.createElement('div');
  div.innerHTML = string;

  if (div.childNodes.length === 1) {
    return div.removeChild(div.childNodes[0]);
  }

  var fragment = document.createDocumentFragment();

  while (div.firstChild) {
    fragment.appendChild(div.firstChild);
  }

  return fragment;
};

/**
 * Transform a string into a DOM text node for appending to the template.
 *
 * @param  {String} string
 * @return {Text}
 */
Utils.textifyExpression = function (string) {
  if (string instanceof SafeString) {
    return Utils.domifyExpression(string.string);
  }

  // Catch when the string is actually a DOM node and turn it into a string.
  if (Utils.isNode(string)) {
    // Already a text node, just return it immediately.
    if (string.nodeType === 3) {
      return string;
    }

    if (typeof string.outerHTML === 'string') {
      return document.createTextNode(string.outerHTML);
    }

    var div = document.createElement('div');
    div.appendChild(string.cloneNode(true));
    return document.createTextNode(div.innerHTML);
  }

  return document.createTextNode(string == null ? '' : string);
};

},{"./safe-string":34,"./track-node":35,"handlebars/dist/cjs/handlebars/utils":41}],37:[function(require,module,exports){
"use strict";
var Utils = require("./utils");
var Exception = require("./exception")["default"];

var VERSION = "1.3.0";
exports.VERSION = VERSION;var COMPILER_REVISION = 4;
exports.COMPILER_REVISION = COMPILER_REVISION;
var REVISION_CHANGES = {
  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
  2: '== 1.0.0-rc.3',
  3: '== 1.0.0-rc.4',
  4: '>= 1.0.0'
};
exports.REVISION_CHANGES = REVISION_CHANGES;
var isArray = Utils.isArray,
    isFunction = Utils.isFunction,
    toString = Utils.toString,
    objectType = '[object Object]';

function HandlebarsEnvironment(helpers, partials) {
  this.helpers = helpers || {};
  this.partials = partials || {};

  registerDefaultHelpers(this);
}

exports.HandlebarsEnvironment = HandlebarsEnvironment;HandlebarsEnvironment.prototype = {
  constructor: HandlebarsEnvironment,

  logger: logger,
  log: log,

  registerHelper: function(name, fn, inverse) {
    if (toString.call(name) === objectType) {
      if (inverse || fn) { throw new Exception('Arg not supported with multiple helpers'); }
      Utils.extend(this.helpers, name);
    } else {
      if (inverse) { fn.not = inverse; }
      this.helpers[name] = fn;
    }
  },

  registerPartial: function(name, str) {
    if (toString.call(name) === objectType) {
      Utils.extend(this.partials,  name);
    } else {
      this.partials[name] = str;
    }
  }
};

function registerDefaultHelpers(instance) {
  instance.registerHelper('helperMissing', function(arg) {
    if(arguments.length === 2) {
      return undefined;
    } else {
      throw new Exception("Missing helper: '" + arg + "'");
    }
  });

  instance.registerHelper('blockHelperMissing', function(context, options) {
    var inverse = options.inverse || function() {}, fn = options.fn;

    if (isFunction(context)) { context = context.call(this); }

    if(context === true) {
      return fn(this);
    } else if(context === false || context == null) {
      return inverse(this);
    } else if (isArray(context)) {
      if(context.length > 0) {
        return instance.helpers.each(context, options);
      } else {
        return inverse(this);
      }
    } else {
      return fn(context);
    }
  });

  instance.registerHelper('each', function(context, options) {
    var fn = options.fn, inverse = options.inverse;
    var i = 0, ret = "", data;

    if (isFunction(context)) { context = context.call(this); }

    if (options.data) {
      data = createFrame(options.data);
    }

    if(context && typeof context === 'object') {
      if (isArray(context)) {
        for(var j = context.length; i<j; i++) {
          if (data) {
            data.index = i;
            data.first = (i === 0);
            data.last  = (i === (context.length-1));
          }
          ret = ret + fn(context[i], { data: data });
        }
      } else {
        for(var key in context) {
          if(context.hasOwnProperty(key)) {
            if(data) { 
              data.key = key; 
              data.index = i;
              data.first = (i === 0);
            }
            ret = ret + fn(context[key], {data: data});
            i++;
          }
        }
      }
    }

    if(i === 0){
      ret = inverse(this);
    }

    return ret;
  });

  instance.registerHelper('if', function(conditional, options) {
    if (isFunction(conditional)) { conditional = conditional.call(this); }

    // Default behavior is to render the positive path if the value is truthy and not empty.
    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
    if ((!options.hash.includeZero && !conditional) || Utils.isEmpty(conditional)) {
      return options.inverse(this);
    } else {
      return options.fn(this);
    }
  });

  instance.registerHelper('unless', function(conditional, options) {
    return instance.helpers['if'].call(this, conditional, {fn: options.inverse, inverse: options.fn, hash: options.hash});
  });

  instance.registerHelper('with', function(context, options) {
    if (isFunction(context)) { context = context.call(this); }

    if (!Utils.isEmpty(context)) return options.fn(context);
  });

  instance.registerHelper('log', function(context, options) {
    var level = options.data && options.data.level != null ? parseInt(options.data.level, 10) : 1;
    instance.log(level, context);
  });
}

var logger = {
  methodMap: { 0: 'debug', 1: 'info', 2: 'warn', 3: 'error' },

  // State enum
  DEBUG: 0,
  INFO: 1,
  WARN: 2,
  ERROR: 3,
  level: 3,

  // can be overridden in the host environment
  log: function(level, obj) {
    if (logger.level <= level) {
      var method = logger.methodMap[level];
      if (typeof console !== 'undefined' && console[method]) {
        console[method].call(console, obj);
      }
    }
  }
};
exports.logger = logger;
function log(level, obj) { logger.log(level, obj); }

exports.log = log;var createFrame = function(object) {
  var obj = {};
  Utils.extend(obj, object);
  return obj;
};
exports.createFrame = createFrame;
},{"./exception":38,"./utils":41}],38:[function(require,module,exports){
"use strict";

var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

function Exception(message, node) {
  var line;
  if (node && node.firstLine) {
    line = node.firstLine;

    message += ' - ' + line + ':' + node.firstColumn;
  }

  var tmp = Error.prototype.constructor.call(this, message);

  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
  for (var idx = 0; idx < errorProps.length; idx++) {
    this[errorProps[idx]] = tmp[errorProps[idx]];
  }

  if (line) {
    this.lineNumber = line;
    this.column = node.firstColumn;
  }
}

Exception.prototype = new Error();

exports["default"] = Exception;
},{}],39:[function(require,module,exports){
"use strict";
var Utils = require("./utils");
var Exception = require("./exception")["default"];
var COMPILER_REVISION = require("./base").COMPILER_REVISION;
var REVISION_CHANGES = require("./base").REVISION_CHANGES;

function checkRevision(compilerInfo) {
  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
      currentRevision = COMPILER_REVISION;

  if (compilerRevision !== currentRevision) {
    if (compilerRevision < currentRevision) {
      var runtimeVersions = REVISION_CHANGES[currentRevision],
          compilerVersions = REVISION_CHANGES[compilerRevision];
      throw new Exception("Template was precompiled with an older version of Handlebars than the current runtime. "+
            "Please update your precompiler to a newer version ("+runtimeVersions+") or downgrade your runtime to an older version ("+compilerVersions+").");
    } else {
      // Use the embedded version info since the runtime doesn't know about this revision yet
      throw new Exception("Template was precompiled with a newer version of Handlebars than the current runtime. "+
            "Please update your runtime to a newer version ("+compilerInfo[1]+").");
    }
  }
}

exports.checkRevision = checkRevision;// TODO: Remove this line and break up compilePartial

function template(templateSpec, env) {
  if (!env) {
    throw new Exception("No environment passed to template");
  }

  // Note: Using env.VM references rather than local var references throughout this section to allow
  // for external users to override these as psuedo-supported APIs.
  var invokePartialWrapper = function(partial, name, context, helpers, partials, data) {
    var result = env.VM.invokePartial.apply(this, arguments);
    if (result != null) { return result; }

    if (env.compile) {
      var options = { helpers: helpers, partials: partials, data: data };
      partials[name] = env.compile(partial, { data: data !== undefined }, env);
      return partials[name](context, options);
    } else {
      throw new Exception("The partial " + name + " could not be compiled when running in runtime-only mode");
    }
  };

  // Just add water
  var container = {
    escapeExpression: Utils.escapeExpression,
    invokePartial: invokePartialWrapper,
    programs: [],
    program: function(i, fn, data) {
      var programWrapper = this.programs[i];
      if(data) {
        programWrapper = program(i, fn, data);
      } else if (!programWrapper) {
        programWrapper = this.programs[i] = program(i, fn);
      }
      return programWrapper;
    },
    merge: function(param, common) {
      var ret = param || common;

      if (param && common && (param !== common)) {
        ret = {};
        Utils.extend(ret, common);
        Utils.extend(ret, param);
      }
      return ret;
    },
    programWithDepth: env.VM.programWithDepth,
    noop: env.VM.noop,
    compilerInfo: null
  };

  return function(context, options) {
    options = options || {};
    var namespace = options.partial ? options : env,
        helpers,
        partials;

    if (!options.partial) {
      helpers = options.helpers;
      partials = options.partials;
    }
    var result = templateSpec.call(
          container,
          namespace, context,
          helpers,
          partials,
          options.data);

    if (!options.partial) {
      env.VM.checkRevision(container.compilerInfo);
    }

    return result;
  };
}

exports.template = template;function programWithDepth(i, fn, data /*, $depth */) {
  var args = Array.prototype.slice.call(arguments, 3);

  var prog = function(context, options) {
    options = options || {};

    return fn.apply(this, [context, options.data || data].concat(args));
  };
  prog.program = i;
  prog.depth = args.length;
  return prog;
}

exports.programWithDepth = programWithDepth;function program(i, fn, data) {
  var prog = function(context, options) {
    options = options || {};

    return fn(context, options.data || data);
  };
  prog.program = i;
  prog.depth = 0;
  return prog;
}

exports.program = program;function invokePartial(partial, name, context, helpers, partials, data) {
  var options = { partial: true, helpers: helpers, partials: partials, data: data };

  if(partial === undefined) {
    throw new Exception("The partial " + name + " could not be found");
  } else if(partial instanceof Function) {
    return partial(context, options);
  }
}

exports.invokePartial = invokePartial;function noop() { return ""; }

exports.noop = noop;
},{"./base":37,"./exception":38,"./utils":41}],40:[function(require,module,exports){
"use strict";
// Build out our basic SafeString type
function SafeString(string) {
  this.string = string;
}

SafeString.prototype.toString = function() {
  return "" + this.string;
};

exports["default"] = SafeString;
},{}],41:[function(require,module,exports){
"use strict";
/*jshint -W004 */
var SafeString = require("./safe-string")["default"];

var escape = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#x27;",
  "`": "&#x60;"
};

var badChars = /[&<>"'`]/g;
var possible = /[&<>"'`]/;

function escapeChar(chr) {
  return escape[chr] || "&amp;";
}

function extend(obj, value) {
  for(var key in value) {
    if(Object.prototype.hasOwnProperty.call(value, key)) {
      obj[key] = value[key];
    }
  }
}

exports.extend = extend;var toString = Object.prototype.toString;
exports.toString = toString;
// Sourced from lodash
// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
var isFunction = function(value) {
  return typeof value === 'function';
};
// fallback for older versions of Chrome and Safari
if (isFunction(/x/)) {
  isFunction = function(value) {
    return typeof value === 'function' && toString.call(value) === '[object Function]';
  };
}
var isFunction;
exports.isFunction = isFunction;
var isArray = Array.isArray || function(value) {
  return (value && typeof value === 'object') ? toString.call(value) === '[object Array]' : false;
};
exports.isArray = isArray;

function escapeExpression(string) {
  // don't escape SafeStrings, since they're already safe
  if (string instanceof SafeString) {
    return string.toString();
  } else if (!string && string !== 0) {
    return "";
  }

  // Force a string conversion as this will be done by the append regardless and
  // the regex test will do this transparently behind the scenes, causing issues if
  // an object's to string has escaped characters in it.
  string = "" + string;

  if(!possible.test(string)) { return string; }
  return string.replace(badChars, escapeChar);
}

exports.escapeExpression = escapeExpression;function isEmpty(value) {
  if (!value && value !== 0) {
    return true;
  } else if (isArray(value) && value.length === 0) {
    return true;
  } else {
    return false;
  }
}

exports.isEmpty = isEmpty;
},{"./safe-string":40}],42:[function(require,module,exports){
var base       = require('./lib/base');
var SafeString = require('./lib/safe-string');
var Exception  = require('./lib/exception');
var Utils      = require('./lib/utils');
var runtime    = require('./lib/runtime');

module.exports = (function create () {
  var db = new base.DOMBarsEnvironment();

  Utils.extend(db, base);
  db.VM         = runtime;
  db.Utils      = Utils;
  db.create     = create;
  db.Exception  = Exception;
  db.SafeString = SafeString;

  db.template = function (spec) {
    return runtime.template(spec, db);
  };

  return db;
})();

},{"./lib/base":30,"./lib/exception":31,"./lib/runtime":33,"./lib/safe-string":34,"./lib/utils":36}],43:[function(require,module,exports){

/**
 * Expose `parse`.
 */

module.exports = parse;

/**
 * Wrap map from jquery.
 */

var map = {
  legend: [1, '<fieldset>', '</fieldset>'],
  tr: [2, '<table><tbody>', '</tbody></table>'],
  col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
  _default: [0, '', '']
};

map.td =
map.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

map.option =
map.optgroup = [1, '<select multiple="multiple">', '</select>'];

map.thead =
map.tbody =
map.colgroup =
map.caption =
map.tfoot = [1, '<table>', '</table>'];

map.text =
map.circle =
map.ellipse =
map.line =
map.path =
map.polygon =
map.polyline =
map.rect = [1, '<svg xmlns="http://www.w3.org/2000/svg" version="1.1">','</svg>'];

/**
 * Parse `html` and return the children.
 *
 * @param {String} html
 * @return {Array}
 * @api private
 */

function parse(html) {
  if ('string' != typeof html) throw new TypeError('String expected');
  
  // tag name
  var m = /<([\w:]+)/.exec(html);
  if (!m) return document.createTextNode(html);

  html = html.replace(/^\s+|\s+$/g, ''); // Remove leading/trailing whitespace

  var tag = m[1];

  // body support
  if (tag == 'body') {
    var el = document.createElement('html');
    el.innerHTML = html;
    return el.removeChild(el.lastChild);
  }

  // wrap map
  var wrap = map[tag] || map._default;
  var depth = wrap[0];
  var prefix = wrap[1];
  var suffix = wrap[2];
  var el = document.createElement('div');
  el.innerHTML = prefix + html + suffix;
  while (depth--) el = el.lastChild;

  // one element
  if (el.firstChild == el.lastChild) {
    return el.removeChild(el.firstChild);
  }

  // several elements
  var fragment = document.createDocumentFragment();
  while (el.firstChild) {
    fragment.appendChild(el.removeChild(el.firstChild));
  }

  return fragment;
}

},{}],44:[function(require,module,exports){
(function (global){
"WeakMap" in this || (function (module) {"use strict";

  //!(C) WebReflection - Mit Style License
  // size and performances oriented polyfill for ES6
  // WeakMap, Map, and Set
  // compatible with node.js, Rhino, any browser
  // does not implement default vaule during wm.get()
  // since ES.next won't probably do that
  // use wm.has(o) ? wm.get(o) : d3fault; instead

  // WeakMap(void):WeakMap
  function WeakMap() {

    // private references holders
    var
      keys = [],
      values = []
    ;

    // returns freshly new created
    // instanceof WeakMap in any case
    return create(WeakMapPrototype, {
      // WeakMap#delete(key:void*):boolean
      "delete": {value: bind.call(sharedDel, NULL, TRUE, keys, values)},
      //:was WeakMap#get(key:void*[, d3fault:void*]):void*
      // WeakMap#get(key:void*):void*
      get:      {value: bind.call(sharedGet, NULL, TRUE, keys, values)},
      // WeakMap#has(key:void*):boolean
      has:      {value: bind.call(sharedHas, NULL, TRUE, keys, values)},
      // WeakMap#set(key:void*, value:void*):void
      set:      {value: bind.call(sharedSet, NULL, TRUE, keys, values)}
    });

  }

  // Map(void):Map
  function Map() {

    // private references holders
    var
      keys = [],
      values = []
    ;

    // returns freshly new created
    // instanceof WeakMap in any case
    return create(MapPrototype, {
      // Map#delete(key:void*):boolean
      "delete": {value: bind.call(sharedDel, NULL, FALSE, keys, values)},
      //:was Map#get(key:void*[, d3fault:void*]):void*
      // Map#get(key:void*):void*
      get:      {value: bind.call(sharedGet, NULL, FALSE, keys, values)},
      // Map#has(key:void*):boolean
      has:      {value: bind.call(sharedHas, NULL, FALSE, keys, values)},
      // Map#set(key:void*, value:void*):void
      set:      {value: bind.call(sharedSet, NULL, FALSE, keys, values)}
      /*,
      // Map#size(void):number === Mozilla only so far
      size:     {value: bind.call(sharedSize, NULL, keys)},
      // Map#keys(void):Array === not in specs
      keys:     {value: boundSlice(keys)},
      // Map#values(void):Array === not in specs
      values:   {value: boundSlice(values)},
      // Map#iterate(callback:Function, context:void*):void ==> callback.call(context, key, value, index) === not in specs
      iterate:  {value: bind.call(sharedIterate, NULL, FALSE, keys, values)}
      //*/
    });

  }

  // Set(void):Set
  /**
   * to be really honest, I would rather pollute Array.prototype
   * in order to have Set like behavior
   * Object.defineProperties(Array.prototype, {
   *   add: {value: function add(value) {
   *     return -1 < this.indexOf(value) && !!this.push(value);
   *   }}
   *   has: {value: function has(value) {
   *     return -1 < this.indexOf(value);
   *   }}
   *   delete: {value: function delete(value) {
   *     var i = this.indexOf(value);
   *     return -1 < i && !!this.splice(i, 1);
   *   }}
   * });
   * ... anyway ...
   */
  function Set() {
    var
      keys = [],  // placeholder used simply to recycle functions
      values = [],// real storage
      has = bind.call(sharedHas, NULL, FALSE, values, keys)
    ;
    return create(SetPrototype, {
      // Set#delete(value:void*):boolean
      "delete": {value: bind.call(sharedDel, NULL, FALSE, values, keys)},
      // Set#has(value:void*):boolean
      has:      {value: has},
      // Set#add(value:void*):boolean
      add:      {value: bind.call(Set_add, NULL, FALSE, has, values)}
      /*,
      // Map#size(void):number === Mozilla only
      size:     {value: bind.call(sharedSize, NULL, values)},
      // Set#values(void):Array === not in specs
      values:   {value: boundSlice(values)},
      // Set#iterate(callback:Function, context:void*):void ==> callback.call(context, value, index) === not in specs
      iterate:  {value: bind.call(Set_iterate, NULL, FALSE, NULL, values)}
      //*/
    });
  }

  // common shared method recycled for all shims through bind
  function sharedDel(objectOnly, keys, values, key) {
    if (sharedHas(objectOnly, keys, values, key)) {
      keys.splice(i, 1);
      values.splice(i, 1);
    }
    // Aurora here does it while Canary doesn't
    return -1 < i;
  }

  function sharedGet(objectOnly, keys, values, key/*, d3fault*/) {
    return sharedHas(objectOnly, keys, values, key) ? values[i] : undefined; //d3fault;
  }

  function sharedHas(objectOnly, keys, values, key) {
    if (objectOnly && key !== Object(key))
      throw new TypeError("not a non-null object")
    ;
    i = betterIndexOf.call(keys, key);
    return -1 < i;
  }

  function sharedSet(objectOnly, keys, values, key, value) {
    /* return */sharedHas(objectOnly, keys, values, key) ?
      values[i] = value
      :
      values[keys.push(key) - 1] = value
    ;
  }

  /* keys, values, and iterate related methods
  function boundSlice(values) {
    return function () {
      return slice.call(values);
    };
  }

  function sharedSize(keys) {
    return keys.length;
  }

  function sharedIterate(objectOnly, keys, values, callback, context) {
    for (var
      k = slice.call(keys), v = slice.call(values),
      i = 0, length = k.length;
      i < length; callback.call(context, k[i], v[i], i++)
    );
  }

  function Set_iterate(objectOnly, keys, values, callback, context) {
    for (var
      v = slice.call(values),
      i = 0, length = v.length;
      i < length; callback.call(context, v[i], i++)
    );
  }
  //*/

  // Set#add recycled through bind per each instanceof Set
  function Set_add(objectOnly, has, values, value) {
    /*return */(!has(value) && !!values.push(value));
  }

  // a more reliable indexOf
  function betterIndexOf(value) {
    if (value != value || value === 0) {
      for (i = this.length; i-- && !is(this[i], value););
    } else {
      i = indexOf.call(this, value);
    }
    return i;
  }

  // need for an empty constructor ...
  function Constructor(){}  // GC'ed if !!Object.create
  // ... so that new WeakMapInstance and new WeakMap
  // produces both an instanceof WeakMap

  var
    // shortcuts and ...
    NULL = null, TRUE = true, FALSE = false,
    notInNode = module == "undefined",
    window = notInNode ? this : global,
    module = notInNode ? {} : exports,
    Object = window.Object,
    WeakMapPrototype = WeakMap.prototype,
    MapPrototype = Map.prototype,
    SetPrototype = Set.prototype,
    defineProperty = Object.defineProperty,
    slice = [].slice,

    // Object.is(a, b) shim
    is = Object.is || function (a, b) {
      return a === b ?
        a !== 0 || 1 / a == 1 / b :
        a != a && b != b
      ;
    },

    // partial polyfill for this aim only
    bind = WeakMap.bind || function bind(context, objectOnly, keys, values) {
      // partial fast ad-hoc Function#bind polyfill if not available
      var callback = this;
      return function bound(key, value) {
        return callback.call(context, objectOnly, keys, values, key, value);
      };
    },

    create = Object.create || function create(proto, descriptor) {
      // partial ad-hoc Object.create shim if not available
      Constructor.prototype = proto;
      var object = new Constructor, key;
      for (key in descriptor) {
        object[key] = descriptor[key].value;
      }
      return object;
    },

    indexOf = [].indexOf || function indexOf(value) {
      // partial fast Array#indexOf polyfill if not available
      for (i = this.length; i-- && this[i] !== value;);
      return i;
    },

    undefined,
    i // recycle ALL the variables !
  ;

  // ~indexOf.call([NaN], NaN) as future possible feature detection

  // used to follow FF behavior where WeakMap.prototype is a WeakMap itself
  WeakMap.prototype = WeakMapPrototype = WeakMap();
  Map.prototype = MapPrototype = Map();
  Set.prototype = SetPrototype = Set();

  // assign it to the global context
  // if already there, e.g. in node, export native
  window.WeakMap = module.WeakMap = window.WeakMap || WeakMap;
  window.Map = module.Map = window.Map || Map;
  window.Set = module.Set = window.Set || Set;

  /* probably not needed, add a slash to ensure non configurable and non writable
  if (defineProperty) {
    defineProperty(window, "WeakMap", {value: WeakMap});
    defineProperty(window, "Map", {value: Map});
    defineProperty(window, "Set", {value: Set});
  }
  //*/

  // that's pretty much it

}.call(
  this,
  typeof exports
));
}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],45:[function(require,module,exports){
/*! Kamino v0.0.1 | http://github.com/Cyril-sf/kamino.js | Copyright 2012, Kit Cambridge | http://kit.mit-license.org */
(function(window) {
  // Convenience aliases.
  var getClass = {}.toString, isProperty, forEach, undef;

  Kamino = {};
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = Kamino;
    }
    exports.Kamino = Kamino;
  } else {
    window['Kamino'] = Kamino;
  }

  Kamino.VERSION = '0.1.0';

  KaminoException = function() {
    this.name = "KaminoException";
    this.number = 25;
    this.message = "Uncaught Error: DATA_CLONE_ERR: Kamino Exception 25";
  };

  // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
  var isExtended = new Date(-3509827334573292);
  try {
    // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
    // results for certain dates in Opera >= 10.53.
    isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() == 1 &&
      // Safari < 2.0.2 stores the internal millisecond time value correctly,
      // but clips the values returned by the date methods to the range of
      // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
      isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
  } catch (exception) {}

  // IE <= 7 doesn't support accessing string characters using square
  // bracket notation. IE 8 only supports this for primitives.
  var charIndexBuggy = "A"[0] != "A";

  // Define additional utility methods if the `Date` methods are buggy.
  if (!isExtended) {
    var floor = Math.floor;
    // A mapping between the months of the year and the number of days between
    // January 1st and the first of the respective month.
    var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
    // Internal: Calculates the number of days between the Unix epoch and the
    // first day of the given month.
    var getDay = function (year, month) {
      return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
    };
  }

  // Internal: Determines if a property is a direct property of the given
  // object. Delegates to the native `Object#hasOwnProperty` method.
  if (!(isProperty = {}.hasOwnProperty)) {
    isProperty = function (property) {
      var members = {}, constructor;
      if ((members.__proto__ = null, members.__proto__ = {
        // The *proto* property cannot be set multiple times in recent
        // versions of Firefox and SeaMonkey.
        "toString": 1
      }, members).toString != getClass) {
        // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
        // supports the mutable *proto* property.
        isProperty = function (property) {
          // Capture and break the object's prototype chain (see section 8.6.2
          // of the ES 5.1 spec). The parenthesized expression prevents an
          // unsafe transformation by the Closure Compiler.
          var original = this.__proto__, result = property in (this.__proto__ = null, this);
          // Restore the original prototype chain.
          this.__proto__ = original;
          return result;
        };
      } else {
        // Capture a reference to the top-level `Object` constructor.
        constructor = members.constructor;
        // Use the `constructor` property to simulate `Object#hasOwnProperty` in
        // other environments.
        isProperty = function (property) {
          var parent = (this.constructor || constructor).prototype;
          return property in this && !(property in parent && this[property] === parent[property]);
        };
      }
      members = null;
      return isProperty.call(this, property);
    };
  }

  // Internal: Normalizes the `for...in` iteration algorithm across
  // environments. Each enumerated key is yielded to a `callback` function.
  forEach = function (object, callback) {
    var size = 0, Properties, members, property, forEach;

    // Tests for bugs in the current environment's `for...in` algorithm. The
    // `valueOf` property inherits the non-enumerable flag from
    // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
    (Properties = function () {
      this.valueOf = 0;
    }).prototype.valueOf = 0;

    // Iterate over a new instance of the `Properties` class.
    members = new Properties();
    for (property in members) {
      // Ignore all properties inherited from `Object.prototype`.
      if (isProperty.call(members, property)) {
        size++;
      }
    }
    Properties = members = null;

    // Normalize the iteration algorithm.
    if (!size) {
      // A list of non-enumerable properties inherited from `Object.prototype`.
      members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
      // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
      // properties.
      forEach = function (object, callback) {
        var isFunction = getClass.call(object) == "[object Function]", property, length;
        for (property in object) {
          // Gecko <= 1.0 enumerates the `prototype` property of functions under
          // certain conditions; IE does not.
          if (!(isFunction && property == "prototype") && isProperty.call(object, property)) {
            callback(property);
          }
        }
        // Manually invoke the callback for each non-enumerable property.
        for (length = members.length; property = members[--length]; isProperty.call(object, property) && callback(property));
      };
    } else if (size == 2) {
      // Safari <= 2.0.4 enumerates shadowed properties twice.
      forEach = function (object, callback) {
        // Create a set of iterated properties.
        var members = {}, isFunction = getClass.call(object) == "[object Function]", property;
        for (property in object) {
          // Store each property name to prevent double enumeration. The
          // `prototype` property of functions is not enumerated due to cross-
          // environment inconsistencies.
          if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
            callback(property);
          }
        }
      };
    } else {
      // No bugs detected; use the standard `for...in` algorithm.
      forEach = function (object, callback) {
        var isFunction = getClass.call(object) == "[object Function]", property, isConstructor;
        for (property in object) {
          if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
            callback(property);
          }
        }
        // Manually invoke the callback for the `constructor` property due to
        // cross-environment inconsistencies.
        if (isConstructor || isProperty.call(object, (property = "constructor"))) {
          callback(property);
        }
      };
    }
    return forEach(object, callback);
  };

  // Public: Serializes a JavaScript `value` as a string. The optional
  // `filter` argument may specify either a function that alters how object and
  // array members are serialized, or an array of strings and numbers that
  // indicates which properties should be serialized. The optional `width`
  // argument may be either a string or number that specifies the indentation
  // level of the output.

  // Internal: A map of control characters and their escaped equivalents.
  var Escapes = {
    "\\": "\\\\",
    '"': '\\"',
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "\t": "\\t"
  };

  // Internal: Converts `value` into a zero-padded string such that its
  // length is at least equal to `width`. The `width` must be <= 6.
  var toPaddedString = function (width, value) {
    // The `|| 0` expression is necessary to work around a bug in
    // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
    return ("000000" + (value || 0)).slice(-width);
  };

  // Internal: Double-quotes a string `value`, replacing all ASCII control
  // characters (characters with code unit values between 0 and 31) with
  // their escaped equivalents. This is an implementation of the
  // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
  var quote = function (value) {
    var result = '"', index = 0, symbol;
    for (; symbol = value.charAt(index); index++) {
      // Escape the reverse solidus, double quote, backspace, form feed, line
      // feed, carriage return, and tab characters.
      result += '\\"\b\f\n\r\t'.indexOf(symbol) > -1 ? Escapes[symbol] :
        // If the character is a control character, append its Unicode escape
        // sequence; otherwise, append the character as-is.
        (Escapes[symbol] = symbol < " " ? "\\u00" + toPaddedString(2, symbol.charCodeAt(0).toString(16)) : symbol);
    }
    return result + '"';
  };

  // Internal: detects if an object is a DOM element.
  // http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object
  var isElement = function(o) {
    return (
      typeof HTMLElement === "object" ? o instanceof HTMLElement : //DOM2
      o && typeof o === "object" && o.nodeType === 1 && typeof o.nodeName==="string"
    );
  };

  // Internal: Recursively serializes an object. Implements the
  // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
  var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
    var value = object[property], originalClassName, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, any, result,
        regExpSource, regExpModifiers = "";
    if( value instanceof Error || value instanceof Function) {
      throw new KaminoException();
    }
    if( isElement( value ) ) {
      throw new KaminoException();
    }
    if (typeof value == "object" && value) {
      originalClassName = getClass.call(value);
      if (originalClassName == "[object Date]" && !isProperty.call(value, "toJSON")) {
        if (value > -1 / 0 && value < 1 / 0) {
          value = value.toUTCString().replace("GMT", "UTC");
        } else {
          value = null;
        }
      } else if (typeof value.toJSON == "function" && ((originalClassName != "[object Number]" && originalClassName != "[object String]" && originalClassName != "[object Array]") || isProperty.call(value, "toJSON"))) {
        // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
        // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
        // ignores all `toJSON` methods on these objects unless they are
        // defined directly on an instance.
        value = value.toJSON(property);
      }
    }
    if (callback) {
      // If a replacement function was provided, call it to obtain the value
      // for serialization.
      value = callback.call(object, property, value);
    }
    if (value === null) {
      return "null";
    }
    if (value === undefined) {
      return undefined;
    }
    className = getClass.call(value);
    if (className == "[object Boolean]") {
      // Booleans are represented literally.
      return "" + value;
    } else if (className == "[object Number]") {
      // Kamino numbers must be finite. `Infinity` and `NaN` are serialized as
      // `"null"`.
      if( value === Number.POSITIVE_INFINITY ) {
        return "Infinity";
      } else if( value === Number.NEGATIVE_INFINITY ) {
        return "NInfinity";
      } else if( isNaN( value ) ) {
        return "NaN";
      }
      return "" + value;
    } else if (className == "[object RegExp]") {
      // Strings are double-quoted and escaped.
      regExpSource = value.source;
      regExpModifiers += value.ignoreCase ? "i" : "";
      regExpModifiers += value.global ? "g" : "";
      regExpModifiers += value.multiline ? "m" : "";

      regExpSource = quote(charIndexBuggy ? regExpSource.split("") : regExpSource);
      regExpModifiers = quote(charIndexBuggy ? regExpModifiers.split("") : regExpModifiers);

      // Adds the RegExp prefix.
      value = '^' + regExpSource + regExpModifiers;

      return value;
    } else if (className == "[object String]") {
      // Strings are double-quoted and escaped.
      value = quote(charIndexBuggy ? value.split("") : value);

      if( originalClassName == "[object Date]") {
        // Adds the Date prefix.
        value = '%' + value;
      }

      return value;
    }
    // Recursively serialize objects and arrays.
    if (typeof value == "object") {
      // Check for cyclic structures. This is a linear search; performance
      // is inversely proportional to the number of unique nested objects.
      for (length = stack.length; length--;) {
        if (stack[length] === value) {
          return "&" + length;
        }
      }
      // Add the object to the stack of traversed objects.
      stack.push(value);
      results = [];
      // Save the current indentation level and indent one additional level.
      prefix = indentation;
      indentation += whitespace;
      if (className == "[object Array]") {
        // Recursively serialize array elements.
        for (index = 0, length = value.length; index < length; any || (any = true), index++) {
          element = serialize(index, value, callback, properties, whitespace, indentation, stack);
          results.push(element === undef ? "null" : element);
        }
        result = any ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
      } else {
        // Recursively serialize object members. Members are selected from
        // either a user-specified list of property names, or the object
        // itself.
        forEach(properties || value, function (property) {
          var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
          if (element !== undef) {
            // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
            // is not the empty string, let `member` {quote(property) + ":"}
            // be the concatenation of `member` and the `space` character."
            // The "`space` character" refers to the literal space
            // character, not the `space` {width} argument provided to
            // `JSON.stringify`.
            results.push(quote(charIndexBuggy ? property.split("") : property) + ":" + (whitespace ? " " : "") + element);
          }
          any || (any = true);
        });
        result = any ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
      }
      return result;
    }
  };

  // Public: `Kamino.stringify`. See ES 5.1 section 15.12.3.
  Kamino.stringify = function (source, filter, width) {
    var whitespace, callback, properties;
    if (typeof filter == "function" || typeof filter == "object" && filter) {
      if (getClass.call(filter) == "[object Function]") {
        callback = filter;
      } else if (getClass.call(filter) == "[object Array]") {
        // Convert the property names array into a makeshift set.
        properties = {};
        for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((getClass.call(value) == "[object String]" || getClass.call(value) == "[object Number]") && (properties[value] = 1)));
      }
    }
    if (width) {
      if (getClass.call(width) == "[object Number]") {
        // Convert the `width` to an integer and create a string containing
        // `width` number of space characters.
        if ((width -= width % 1) > 0) {
          for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
        }
      } else if (getClass.call(width) == "[object String]") {
        whitespace = width.length <= 10 ? width : width.slice(0, 10);
      }
    }
    // Opera <= 7.54u2 discards the values associated with empty string keys
    // (`""`) only if they are used directly within an object member list
    // (e.g., `!("" in { "": 1})`).
    return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
  };

  // Public: Parses a source string.
  var fromCharCode = String.fromCharCode;

  // Internal: A map of escaped control characters and their unescaped
  // equivalents.
  var Unescapes = {
    "\\": "\\",
    '"': '"',
    "/": "/",
    "b": "\b",
    "t": "\t",
    "n": "\n",
    "f": "\f",
    "r": "\r"
  };

  // Internal: Stores the parser state.
  var Index, Source, stack;

  // Internal: Resets the parser state and throws a `SyntaxError`.
  var abort = function() {
    Index = Source = null;
    throw SyntaxError();
  };

  var parseString = function(prefix) {
    prefix = prefix || "";
    var source = Source, length = source.length, value, symbol, begin, position;
    // Advance to the next character and parse a Kamino string at the
    // current position. String tokens are prefixed with the sentinel
    // `@` character to distinguish them from punctuators.
    for (value = prefix, Index++; Index < length;) {
      symbol = source[Index];
      if (symbol < " ") {
        // Unescaped ASCII control characters are not permitted.
        abort();
      } else if (symbol == "\\") {
        // Parse escaped Kamino control characters, `"`, `\`, `/`, and
        // Unicode escape sequences.
        symbol = source[++Index];
        if ('\\"/btnfr'.indexOf(symbol) > -1) {
          // Revive escaped control characters.
          value += Unescapes[symbol];
          Index++;
        } else if (symbol == "u") {
          // Advance to the first character of the escape sequence.
          begin = ++Index;
          // Validate the Unicode escape sequence.
          for (position = Index + 4; Index < position; Index++) {
            symbol = source[Index];
            // A valid sequence comprises four hexdigits that form a
            // single hexadecimal value.
            if (!(symbol >= "0" && symbol <= "9" || symbol >= "a" && symbol <= "f" || symbol >= "A" && symbol <= "F")) {
              // Invalid Unicode escape sequence.
              abort();
            }
          }
          // Revive the escaped character.
          value += fromCharCode("0x" + source.slice(begin, Index));
        } else {
          // Invalid escape sequence.
          abort();
        }
      } else {
        if (symbol == '"') {
          // An unescaped double-quote character marks the end of the
          // string.
          break;
        }
        // Append the original character as-is.
        value += symbol;
        Index++;
      }
    }
    if (source[Index] == '"') {
      Index++;
      // Return the revived string.
      return value;
    }
    // Unterminated string.
    abort();
  };

  // Internal: Returns the next token, or `"$"` if the parser has reached
  // the end of the source string. A token may be a string, number, `null`
  // literal, `NaN` literal or Boolean literal.
  var lex = function () {
    var source = Source, length = source.length, symbol, value, begin, position, sign,
        dateString, regExpSource, regExpModifiers;
    while (Index < length) {
      symbol = source[Index];
      if ("\t\r\n ".indexOf(symbol) > -1) {
        // Skip whitespace tokens, including tabs, carriage returns, line
        // feeds, and space characters.
        Index++;
      } else if ("{}[]:,".indexOf(symbol) > -1) {
        // Parse a punctuator token at the current position.
        Index++;
        return symbol;
      } else if (symbol == '"') {
        // Parse strings.
        return parseString("@");
      } else if (symbol == '%') {
        // Parse dates.
        Index++;
        symbol = source[Index];
        if(symbol == '"') {
          dateString = parseString();
          return new Date( dateString );
        }
        abort();
      } else if (symbol == '^') {
        // Parse regular expressions.
        Index++;
        symbol = source[Index];
        if(symbol == '"') {
          regExpSource = parseString();

          symbol = source[Index];
          if(symbol == '"') {
            regExpModifiers = parseString();

            return new RegExp( regExpSource, regExpModifiers );
          }
        }
        abort();
      } else if (symbol == '&') {
        // Parse object references.
        Index++;
        symbol = source[Index];
        if (symbol >= "0" && symbol <= "9") {
          Index++;
          return stack[symbol];
        }
        abort();
      } else {
        // Parse numbers and literals.
        begin = Index;
        // Advance the scanner's position past the sign, if one is
        // specified.
        if (symbol == "-") {
          sign = true;
          symbol = source[++Index];
        }
        // Parse an integer or floating-point value.
        if (symbol >= "0" && symbol <= "9") {
          // Leading zeroes are interpreted as octal literals.
          if (symbol == "0" && (symbol = source[Index + 1], symbol >= "0" && symbol <= "9")) {
            // Illegal octal literal.
            abort();
          }
          sign = false;
          // Parse the integer component.
          for (; Index < length && (symbol = source[Index], symbol >= "0" && symbol <= "9"); Index++);
          // Floats cannot contain a leading decimal point; however, this
          // case is already accounted for by the parser.
          if (source[Index] == ".") {
            position = ++Index;
            // Parse the decimal component.
            for (; position < length && (symbol = source[position], symbol >= "0" && symbol <= "9"); position++);
            if (position == Index) {
              // Illegal trailing decimal.
              abort();
            }
            Index = position;
          }
          // Parse exponents.
          symbol = source[Index];
          if (symbol == "e" || symbol == "E") {
            // Skip past the sign following the exponent, if one is
            // specified.
            symbol = source[++Index];
            if (symbol == "+" || symbol == "-") {
              Index++;
            }
            // Parse the exponential component.
            for (position = Index; position < length && (symbol = source[position], symbol >= "0" && symbol <= "9"); position++);
            if (position == Index) {
              // Illegal empty exponent.
              abort();
            }
            Index = position;
          }
          // Coerce the parsed value to a JavaScript number.
          return +source.slice(begin, Index);
        }
        // A negative sign may only precede numbers.
        if (sign) {
          abort();
        }
        // `true`, `false`, `Infinity`, `-Infinity`, `NaN` and `null` literals.
        if (source.slice(Index, Index + 4) == "true") {
          Index += 4;
          return true;
        } else if (source.slice(Index, Index + 5) == "false") {
          Index += 5;
          return false;
        } else if (source.slice(Index, Index + 8) == "Infinity") {
          Index += 8;
          return Infinity;
        } else if (source.slice(Index, Index + 9) == "NInfinity") {
          Index += 9;
          return -Infinity;
        } else if (source.slice(Index, Index + 3) == "NaN") {
          Index += 3;
          return NaN;
        } else if (source.slice(Index, Index + 4) == "null") {
          Index += 4;
          return null;
        }
        // Unrecognized token.
        abort();
      }
    }
    // Return the sentinel `$` character if the parser has reached the end
    // of the source string.
    return "$";
  };

  // Internal: Parses a Kamino `value` token.
  var get = function (value) {
    var results, any, key;
    if (value == "$") {
      // Unexpected end of input.
      abort();
    }
    if (typeof value == "string") {
      if (value[0] == "@") {
        // Remove the sentinel `@` character.
        return value.slice(1);
      }
      // Parse object and array literals.
      if (value == "[") {
        // Parses a Kamino array, returning a new JavaScript array.
        results = [];
        stack[stack.length] = results;
        for (;; any || (any = true)) {
          value = lex();
          // A closing square bracket marks the end of the array literal.
          if (value == "]") {
            break;
          }
          // If the array literal contains elements, the current token
          // should be a comma separating the previous element from the
          // next.
          if (any) {
            if (value == ",") {
              value = lex();
              if (value == "]") {
                // Unexpected trailing `,` in array literal.
                abort();
              }
            } else {
              // A `,` must separate each array element.
              abort();
            }
          }
          // Elisions and leading commas are not permitted.
          if (value == ",") {
            abort();
          }
          results.push(get(typeof value == "string" && charIndexBuggy ? value.split("") : value));
        }
        return results;
      } else if (value == "{") {
        // Parses a Kamino object, returning a new JavaScript object.
        results = {};
        stack[stack.length] = results;
        for (;; any || (any = true)) {
          value = lex();
          // A closing curly brace marks the end of the object literal.
          if (value == "}") {
            break;
          }
          // If the object literal contains members, the current token
          // should be a comma separator.
          if (any) {
            if (value == ",") {
              value = lex();
              if (value == "}") {
                // Unexpected trailing `,` in object literal.
                abort();
              }
            } else {
              // A `,` must separate each object member.
              abort();
            }
          }
          // Leading commas are not permitted, object property names must be
          // double-quoted strings, and a `:` must separate each property
          // name and value.
          if (value == "," || typeof value != "string" || value[0] != "@" || lex() != ":") {
            abort();
          }
          var result = lex();
          results[value.slice(1)] = get(typeof result == "string" && charIndexBuggy ? result.split("") : result);
        }
        return results;
      }
      // Unexpected token encountered.
      abort();
    }
    return value;
  };

  // Internal: Updates a traversed object member.
  var update = function(source, property, callback) {
    var element = walk(source, property, callback);
    if (element === undef) {
      delete source[property];
    } else {
      source[property] = element;
    }
  };

  // Internal: Recursively traverses a parsed Kamino object, invoking the
  // `callback` function for each value. This is an implementation of the
  // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
  var walk = function (source, property, callback) {
    var value = source[property], length;
    if (typeof value == "object" && value) {
      if (getClass.call(value) == "[object Array]") {
        for (length = value.length; length--;) {
          update(value, length, callback);
        }
      } else {
        // `forEach` can't be used to traverse an array in Opera <= 8.54,
        // as `Object#hasOwnProperty` returns `false` for array indices
        // (e.g., `![1, 2, 3].hasOwnProperty("0")`).
        forEach(value, function (property) {
          update(value, property, callback);
        });
      }
    }
    return callback.call(source, property, value);
  };

  // Public: `Kamino.parse`. See ES 5.1 section 15.12.2.
  Kamino.parse = function (source, callback) {
    var result, value;
    Index = 0;
    Source = "" + source;
    stack = [];
    if (charIndexBuggy) {
      Source = source.split("");
    }
    result = get(lex());
    // If a Kamino string contains multiple tokens, it is invalid.
    if (lex() != "$") {
      abort();
    }
    // Reset the parser state.
    Index = Source = null;
    return callback && getClass.call(callback) == "[object Function]" ? walk((value = {}, value[""] = result, value), "", callback) : result;
  };

  Kamino.clone = function(source) {
    return Kamino.parse( Kamino.stringify(source) );
  };
})(this);

},{}],46:[function(require,module,exports){
(function (global){
/**
 * marked - a markdown parser
 * Copyright (c) 2011-2013, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/chjj/marked
 */

;(function() {

/**
 * Block-Level Grammar
 */

var block = {
  newline: /^\n+/,
  code: /^( {4}[^\n]+\n*)+/,
  fences: noop,
  hr: /^( *[-*_]){3,} *(?:\n+|$)/,
  heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
  nptable: noop,
  lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
  blockquote: /^( *>[^\n]+(\n[^\n]+)*\n*)+/,
  list: /^( *)(bull) [\s\S]+?(?:hr|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
  html: /^ *(?:comment|closed|closing) *(?:\n{2,}|\s*$)/,
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,
  table: noop,
  paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,
  text: /^[^\n]+/
};

block.bullet = /(?:[*+-]|\d+\.)/;
block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
block.item = replace(block.item, 'gm')
  (/bull/g, block.bullet)
  ();

block.list = replace(block.list)
  (/bull/g, block.bullet)
  ('hr', /\n+(?=(?: *[-*_]){3,} *(?:\n+|$))/)
  ();

block._tag = '(?!(?:'
  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'
  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'
  + '|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|@)\\b';

block.html = replace(block.html)
  ('comment', /<!--[\s\S]*?-->/)
  ('closed', /<(tag)[\s\S]+?<\/\1>/)
  ('closing', /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)
  (/tag/g, block._tag)
  ();

block.paragraph = replace(block.paragraph)
  ('hr', block.hr)
  ('heading', block.heading)
  ('lheading', block.lheading)
  ('blockquote', block.blockquote)
  ('tag', '<' + block._tag)
  ('def', block.def)
  ();

/**
 * Normal Block Grammar
 */

block.normal = merge({}, block);

/**
 * GFM Block Grammar
 */

block.gfm = merge({}, block.normal, {
  fences: /^ *(`{3,}|~{3,}) *(\S+)? *\n([\s\S]+?)\s*\1 *(?:\n+|$)/,
  paragraph: /^/
});

block.gfm.paragraph = replace(block.paragraph)
  ('(?!', '(?!'
    + block.gfm.fences.source.replace('\\1', '\\2') + '|'
    + block.list.source.replace('\\1', '\\3') + '|')
  ();

/**
 * GFM + Tables Block Grammar
 */

block.tables = merge({}, block.gfm, {
  nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
  table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/
});

/**
 * Block Lexer
 */

function Lexer(options) {
  this.tokens = [];
  this.tokens.links = {};
  this.options = options || marked.defaults;
  this.rules = block.normal;

  if (this.options.gfm) {
    if (this.options.tables) {
      this.rules = block.tables;
    } else {
      this.rules = block.gfm;
    }
  }
}

/**
 * Expose Block Rules
 */

Lexer.rules = block;

/**
 * Static Lex Method
 */

Lexer.lex = function(src, options) {
  var lexer = new Lexer(options);
  return lexer.lex(src);
};

/**
 * Preprocessing
 */

Lexer.prototype.lex = function(src) {
  src = src
    .replace(/\r\n|\r/g, '\n')
    .replace(/\t/g, '    ')
    .replace(/\u00a0/g, ' ')
    .replace(/\u2424/g, '\n');

  return this.token(src, true);
};

/**
 * Lexing
 */

Lexer.prototype.token = function(src, top) {
  var src = src.replace(/^ +$/gm, '')
    , next
    , loose
    , cap
    , bull
    , b
    , item
    , space
    , i
    , l;

  while (src) {
    // newline
    if (cap = this.rules.newline.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[0].length > 1) {
        this.tokens.push({
          type: 'space'
        });
      }
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      cap = cap[0].replace(/^ {4}/gm, '');
      this.tokens.push({
        type: 'code',
        text: !this.options.pedantic
          ? cap.replace(/\n+$/, '')
          : cap
      });
      continue;
    }

    // fences (gfm)
    if (cap = this.rules.fences.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'code',
        lang: cap[2],
        text: cap[3]
      });
      continue;
    }

    // heading
    if (cap = this.rules.heading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[1].length,
        text: cap[2]
      });
      continue;
    }

    // table no leading pipe (gfm)
    if (top && (cap = this.rules.nptable.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i].split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // lheading
    if (cap = this.rules.lheading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[2] === '=' ? 1 : 2,
        text: cap[1]
      });
      continue;
    }

    // hr
    if (cap = this.rules.hr.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'hr'
      });
      continue;
    }

    // blockquote
    if (cap = this.rules.blockquote.exec(src)) {
      src = src.substring(cap[0].length);

      this.tokens.push({
        type: 'blockquote_start'
      });

      cap = cap[0].replace(/^ *> ?/gm, '');

      // Pass `top` to keep the current
      // "toplevel" state. This is exactly
      // how markdown.pl works.
      this.token(cap, top);

      this.tokens.push({
        type: 'blockquote_end'
      });

      continue;
    }

    // list
    if (cap = this.rules.list.exec(src)) {
      src = src.substring(cap[0].length);
      bull = cap[2];

      this.tokens.push({
        type: 'list_start',
        ordered: bull.length > 1
      });

      // Get each top-level item.
      cap = cap[0].match(this.rules.item);

      next = false;
      l = cap.length;
      i = 0;

      for (; i < l; i++) {
        item = cap[i];

        // Remove the list item's bullet
        // so it is seen as the next token.
        space = item.length;
        item = item.replace(/^ *([*+-]|\d+\.) +/, '');

        // Outdent whatever the
        // list item contains. Hacky.
        if (~item.indexOf('\n ')) {
          space -= item.length;
          item = !this.options.pedantic
            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
            : item.replace(/^ {1,4}/gm, '');
        }

        // Determine whether the next list item belongs here.
        // Backpedal if it does not belong in this list.
        if (this.options.smartLists && i !== l - 1) {
          b = block.bullet.exec(cap[i + 1])[0];
          if (bull !== b && !(bull.length > 1 && b.length > 1)) {
            src = cap.slice(i + 1).join('\n') + src;
            i = l - 1;
          }
        }

        // Determine whether item is loose or not.
        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
        // for discount behavior.
        loose = next || /\n\n(?!\s*$)/.test(item);
        if (i !== l - 1) {
          next = item.charAt(item.length - 1) === '\n';
          if (!loose) loose = next;
        }

        this.tokens.push({
          type: loose
            ? 'loose_item_start'
            : 'list_item_start'
        });

        // Recurse.
        this.token(item, false);

        this.tokens.push({
          type: 'list_item_end'
        });
      }

      this.tokens.push({
        type: 'list_end'
      });

      continue;
    }

    // html
    if (cap = this.rules.html.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: this.options.sanitize
          ? 'paragraph'
          : 'html',
        pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',
        text: cap[0]
      });
      continue;
    }

    // def
    if (top && (cap = this.rules.def.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.links[cap[1].toLowerCase()] = {
        href: cap[2],
        title: cap[3]
      };
      continue;
    }

    // table (gfm)
    if (top && (cap = this.rules.table.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/(?: *\| *)?\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i]
          .replace(/^ *\| *| *\| *$/g, '')
          .split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // top-level paragraph
    if (top && (cap = this.rules.paragraph.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'paragraph',
        text: cap[1].charAt(cap[1].length - 1) === '\n'
          ? cap[1].slice(0, -1)
          : cap[1]
      });
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      // Top-level should never reach here.
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'text',
        text: cap[0]
      });
      continue;
    }

    if (src) {
      throw new
        Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return this.tokens;
};

/**
 * Inline-Level Grammar
 */

var inline = {
  escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
  autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
  url: noop,
  tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,
  link: /^!?\[(inside)\]\(href\)/,
  reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
  nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
  strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
  em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
  code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,
  br: /^ {2,}\n(?!\s*$)/,
  del: noop,
  text: /^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/
};

inline._inside = /(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/;
inline._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;

inline.link = replace(inline.link)
  ('inside', inline._inside)
  ('href', inline._href)
  ();

inline.reflink = replace(inline.reflink)
  ('inside', inline._inside)
  ();

/**
 * Normal Inline Grammar
 */

inline.normal = merge({}, inline);

/**
 * Pedantic Inline Grammar
 */

inline.pedantic = merge({}, inline.normal, {
  strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
  em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
});

/**
 * GFM Inline Grammar
 */

inline.gfm = merge({}, inline.normal, {
  escape: replace(inline.escape)('])', '~|])')(),
  url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,
  del: /^~~(?=\S)([\s\S]*?\S)~~/,
  text: replace(inline.text)
    (']|', '~]|')
    ('|', '|https?://|')
    ()
});

/**
 * GFM + Line Breaks Inline Grammar
 */

inline.breaks = merge({}, inline.gfm, {
  br: replace(inline.br)('{2,}', '*')(),
  text: replace(inline.gfm.text)('{2,}', '*')()
});

/**
 * Inline Lexer & Compiler
 */

function InlineLexer(links, options) {
  this.options = options || marked.defaults;
  this.links = links;
  this.rules = inline.normal;
  this.renderer = this.options.renderer || new Renderer;

  if (!this.links) {
    throw new
      Error('Tokens array requires a `links` property.');
  }

  if (this.options.gfm) {
    if (this.options.breaks) {
      this.rules = inline.breaks;
    } else {
      this.rules = inline.gfm;
    }
  } else if (this.options.pedantic) {
    this.rules = inline.pedantic;
  }
}

/**
 * Expose Inline Rules
 */

InlineLexer.rules = inline;

/**
 * Static Lexing/Compiling Method
 */

InlineLexer.output = function(src, links, options) {
  var inline = new InlineLexer(links, options);
  return inline.output(src);
};

/**
 * Lexing/Compiling
 */

InlineLexer.prototype.output = function(src) {
  var out = ''
    , link
    , text
    , href
    , cap;

  while (src) {
    // escape
    if (cap = this.rules.escape.exec(src)) {
      src = src.substring(cap[0].length);
      out += cap[1];
      continue;
    }

    // autolink
    if (cap = this.rules.autolink.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[2] === '@') {
        text = cap[1].charAt(6) === ':'
          ? this.mangle(cap[1].substring(7))
          : this.mangle(cap[1]);
        href = this.mangle('mailto:') + text;
      } else {
        text = escape(cap[1]);
        href = text;
      }
      out += this.renderer.link(href, null, text);
      continue;
    }

    // url (gfm)
    if (cap = this.rules.url.exec(src)) {
      src = src.substring(cap[0].length);
      text = escape(cap[1]);
      href = text;
      out += this.renderer.link(href, null, text);
      continue;
    }

    // tag
    if (cap = this.rules.tag.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.options.sanitize
        ? escape(cap[0])
        : cap[0];
      continue;
    }

    // link
    if (cap = this.rules.link.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.outputLink(cap, {
        href: cap[2],
        title: cap[3]
      });
      continue;
    }

    // reflink, nolink
    if ((cap = this.rules.reflink.exec(src))
        || (cap = this.rules.nolink.exec(src))) {
      src = src.substring(cap[0].length);
      link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
      link = this.links[link.toLowerCase()];
      if (!link || !link.href) {
        out += cap[0].charAt(0);
        src = cap[0].substring(1) + src;
        continue;
      }
      out += this.outputLink(cap, link);
      continue;
    }

    // strong
    if (cap = this.rules.strong.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.strong(this.output(cap[2] || cap[1]));
      continue;
    }

    // em
    if (cap = this.rules.em.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.em(this.output(cap[2] || cap[1]));
      continue;
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.codespan(escape(cap[2], true));
      continue;
    }

    // br
    if (cap = this.rules.br.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.br();
      continue;
    }

    // del (gfm)
    if (cap = this.rules.del.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.del(this.output(cap[1]));
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      src = src.substring(cap[0].length);
      out += escape(this.smartypants(cap[0]));
      continue;
    }

    if (src) {
      throw new
        Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return out;
};

/**
 * Compile Link
 */

InlineLexer.prototype.outputLink = function(cap, link) {
  var href = escape(link.href)
    , title = link.title ? escape(link.title) : null;

  return cap[0].charAt(0) !== '!'
    ? this.renderer.link(href, title, this.output(cap[1]))
    : this.renderer.image(href, title, escape(cap[1]));
};

/**
 * Smartypants Transformations
 */

InlineLexer.prototype.smartypants = function(text) {
  if (!this.options.smartypants) return text;
  return text
    // em-dashes
    .replace(/--/g, '\u2014')
    // opening singles
    .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
    // closing singles & apostrophes
    .replace(/'/g, '\u2019')
    // opening doubles
    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
    // closing doubles
    .replace(/"/g, '\u201d')
    // ellipses
    .replace(/\.{3}/g, '\u2026');
};

/**
 * Mangle Links
 */

InlineLexer.prototype.mangle = function(text) {
  var out = ''
    , l = text.length
    , i = 0
    , ch;

  for (; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = 'x' + ch.toString(16);
    }
    out += '&#' + ch + ';';
  }

  return out;
};

/**
 * Renderer
 */

function Renderer() {}

Renderer.prototype.code = function(code, lang, escaped, options) {
  options = options || {};

  if (options.highlight) {
    var out = options.highlight(code, lang);
    if (out != null && out !== code) {
      escaped = true;
      code = out;
    }
  }

  if (!lang) {
    return '<pre><code>'
      + (escaped ? code : escape(code, true))
      + '\n</code></pre>';
  }

  return '<pre><code class="'
    + options.langPrefix
    + lang
    + '">'
    + (escaped ? code : escape(code))
    + '\n</code></pre>\n';
};

Renderer.prototype.blockquote = function(quote) {
  return '<blockquote>\n' + quote + '</blockquote>\n';
};

Renderer.prototype.html = function(html) {
  return html;
};

Renderer.prototype.heading = function(text, level, raw, options) {
  return '<h'
    + level
    + ' id="'
    + options.headerPrefix
    + raw.toLowerCase().replace(/[^\w]+/g, '-')
    + '">'
    + text
    + '</h'
    + level
    + '>\n';
};

Renderer.prototype.hr = function() {
  return '<hr>\n';
};

Renderer.prototype.list = function(body, ordered) {
  var type = ordered ? 'ol' : 'ul';
  return '<' + type + '>\n' + body + '</' + type + '>\n';
};

Renderer.prototype.listitem = function(text) {
  return '<li>' + text + '</li>\n';
};

Renderer.prototype.paragraph = function(text) {
  return '<p>' + text + '</p>\n';
};

Renderer.prototype.table = function(header, body) {
  return '<table>\n'
    + '<thead>\n'
    + header
    + '</thead>\n'
    + '<tbody>\n'
    + body
    + '</tbody>\n'
    + '</table>\n';
};

Renderer.prototype.tablerow = function(content) {
  return '<tr>\n' + content + '</tr>\n';
};

Renderer.prototype.tablecell = function(content, flags) {
  var type = flags.header ? 'th' : 'td';
  var tag = flags.align
    ? '<' + type + ' style="text-align:' + flags.align + '">'
    : '<' + type + '>';
  return tag + content + '</' + type + '>\n';
};

// span level renderer
Renderer.prototype.strong = function(text) {
  return '<strong>' + text + '</strong>';
};

Renderer.prototype.em = function(text) {
  return '<em>' + text + '</em>';
};

Renderer.prototype.codespan = function(text) {
  return '<code>' + text + '</code>';
};

Renderer.prototype.br = function() {
  return '<br>';
};

Renderer.prototype.del = function(text) {
  return '<del>' + text + '</del>';
};

Renderer.prototype.link = function(href, title, text) {
  var out = '<a href="' + href + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += '>' + text + '</a>';
  return out;
};

Renderer.prototype.image = function(href, title, text) {
  var out = '<img src="' + href + '" alt="' + text + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += '>';
  return out;
};

/**
 * Parsing & Compiling
 */

function Parser(options) {
  this.tokens = [];
  this.token = null;
  this.options = options || marked.defaults;
  this.options.renderer = this.options.renderer || new Renderer;
  this.renderer = this.options.renderer;
}

/**
 * Static Parse Method
 */

Parser.parse = function(src, options, renderer) {
  var parser = new Parser(options, renderer);
  return parser.parse(src);
};

/**
 * Parse Loop
 */

Parser.prototype.parse = function(src) {
  this.inline = new InlineLexer(src.links, this.options, this.renderer);
  this.tokens = src.reverse();

  var out = '';
  while (this.next()) {
    out += this.tok();
  }

  return out;
};

/**
 * Next Token
 */

Parser.prototype.next = function() {
  return this.token = this.tokens.pop();
};

/**
 * Preview Next Token
 */

Parser.prototype.peek = function() {
  return this.tokens[this.tokens.length - 1] || 0;
};

/**
 * Parse Text Tokens
 */

Parser.prototype.parseText = function() {
  var body = this.token.text;

  while (this.peek().type === 'text') {
    body += '\n' + this.next().text;
  }

  return this.inline.output(body);
};

/**
 * Parse Current Token
 */

Parser.prototype.tok = function() {
  switch (this.token.type) {
    case 'space': {
      return '';
    }
    case 'hr': {
      return this.renderer.hr();
    }
    case 'heading': {
      return this.renderer.heading(
        this.inline.output(this.token.text),
        this.token.depth,
        this.token.text,
        this.options
      );
    }
    case 'code': {
      return this.renderer.code(this.token.text,
        this.token.lang,
        this.token.escaped,
        this.options);
    }
    case 'table': {
      var header = ''
        , body = ''
        , i
        , row
        , cell
        , flags
        , j;

      // header
      cell = '';
      for (i = 0; i < this.token.header.length; i++) {
        flags = { header: true, align: this.token.align[i] };
        cell += this.renderer.tablecell(
          this.inline.output(this.token.header[i]),
          { header: true, align: this.token.align[i] }
        );
      }
      header += this.renderer.tablerow(cell);

      for (i = 0; i < this.token.cells.length; i++) {
        row = this.token.cells[i];

        cell = '';
        for (j = 0; j < row.length; j++) {
          cell += this.renderer.tablecell(
            this.inline.output(row[j]),
            { header: false, align: this.token.align[j] }
          );
        }

        body += this.renderer.tablerow(cell);
      }
      return this.renderer.table(header, body);
    }
    case 'blockquote_start': {
      var body = '';

      while (this.next().type !== 'blockquote_end') {
        body += this.tok();
      }

      return this.renderer.blockquote(body);
    }
    case 'list_start': {
      var body = ''
        , ordered = this.token.ordered;

      while (this.next().type !== 'list_end') {
        body += this.tok();
      }

      return this.renderer.list(body, ordered);
    }
    case 'list_item_start': {
      var body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.token.type === 'text'
          ? this.parseText()
          : this.tok();
      }

      return this.renderer.listitem(body);
    }
    case 'loose_item_start': {
      var body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.tok();
      }

      return this.renderer.listitem(body);
    }
    case 'html': {
      var html = !this.token.pre && !this.options.pedantic
        ? this.inline.output(this.token.text)
        : this.token.text;
      return this.renderer.html(html);
    }
    case 'paragraph': {
      return this.renderer.paragraph(this.inline.output(this.token.text));
    }
    case 'text': {
      return this.renderer.paragraph(this.parseText());
    }
  }
};

/**
 * Helpers
 */

function escape(html, encode) {
  return html
    .replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function replace(regex, opt) {
  regex = regex.source;
  opt = opt || '';
  return function self(name, val) {
    if (!name) return new RegExp(regex, opt);
    val = val.source || val;
    val = val.replace(/(^|[^\[])\^/g, '$1');
    regex = regex.replace(name, val);
    return self;
  };
}

function noop() {}
noop.exec = noop;

function merge(obj) {
  var i = 1
    , target
    , key;

  for (; i < arguments.length; i++) {
    target = arguments[i];
    for (key in target) {
      if (Object.prototype.hasOwnProperty.call(target, key)) {
        obj[key] = target[key];
      }
    }
  }

  return obj;
}


/**
 * Marked
 */

function marked(src, opt, callback) {
  if (callback || typeof opt === 'function') {
    if (!callback) {
      callback = opt;
      opt = null;
    }

    opt = merge({}, marked.defaults, opt || {});

    var highlight = opt.highlight
      , tokens
      , pending
      , i = 0;

    try {
      tokens = Lexer.lex(src, opt)
    } catch (e) {
      return callback(e);
    }

    pending = tokens.length;

    var done = function() {
      var out, err;

      try {
        out = Parser.parse(tokens, opt);
      } catch (e) {
        err = e;
      }

      opt.highlight = highlight;

      return err
        ? callback(err)
        : callback(null, out);
    };

    if (!highlight || highlight.length < 3) {
      return done();
    }

    delete opt.highlight;

    if (!pending) return done();

    for (; i < tokens.length; i++) {
      (function(token) {
        if (token.type !== 'code') {
          return --pending || done();
        }
        return highlight(token.text, token.lang, function(err, code) {
          if (code == null || code === token.text) {
            return --pending || done();
          }
          token.text = code;
          token.escaped = true;
          --pending || done();
        });
      })(tokens[i]);
    }

    return;
  }
  try {
    if (opt) opt = merge({}, marked.defaults, opt);
    return Parser.parse(Lexer.lex(src, opt), opt);
  } catch (e) {
    e.message += '\nPlease report this to https://github.com/chjj/marked.';
    if ((opt || marked.defaults).silent) {
      return '<p>An error occured:</p><pre>'
        + escape(e.message + '', true)
        + '</pre>';
    }
    throw e;
  }
}

/**
 * Options
 */

marked.options =
marked.setOptions = function(opt) {
  merge(marked.defaults, opt);
  return marked;
};

marked.defaults = {
  gfm: true,
  tables: true,
  breaks: false,
  pedantic: false,
  sanitize: false,
  smartLists: false,
  silent: false,
  highlight: null,
  langPrefix: 'lang-',
  smartypants: false,
  headerPrefix: '',
  renderer: new Renderer
};

/**
 * Expose
 */

marked.Parser = Parser;
marked.parser = Parser.parse;

marked.Renderer = Renderer;

marked.Lexer = Lexer;
marked.lexer = Lexer.lex;

marked.InlineLexer = InlineLexer;
marked.inlineLexer = InlineLexer.output;

marked.parse = marked;

if (typeof exports === 'object') {
  module.exports = marked;
} else if (typeof define === 'function' && define.amd) {
  define(function() { return marked; });
} else {
  this.marked = marked;
}

}).call(function() {
  return this || (typeof window !== 'undefined' ? window : global);
}());

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],47:[function(require,module,exports){
/**
 * Object#toString() ref for stringify().
 */

var toString = Object.prototype.toString;

/**
 * Object#hasOwnProperty ref
 */

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * Array#indexOf shim.
 */

var indexOf = typeof Array.prototype.indexOf === 'function'
  ? function(arr, el) { return arr.indexOf(el); }
  : function(arr, el) {
      for (var i = 0; i < arr.length; i++) {
        if (arr[i] === el) return i;
      }
      return -1;
    };

/**
 * Array.isArray shim.
 */

var isArray = Array.isArray || function(arr) {
  return toString.call(arr) == '[object Array]';
};

/**
 * Object.keys shim.
 */

var objectKeys = Object.keys || function(obj) {
  var ret = [];
  for (var key in obj) {
    if (obj.hasOwnProperty(key)) {
      ret.push(key);
    }
  }
  return ret;
};

/**
 * Array#forEach shim.
 */

var forEach = typeof Array.prototype.forEach === 'function'
  ? function(arr, fn) { return arr.forEach(fn); }
  : function(arr, fn) {
      for (var i = 0; i < arr.length; i++) fn(arr[i]);
    };

/**
 * Array#reduce shim.
 */

var reduce = function(arr, fn, initial) {
  if (typeof arr.reduce === 'function') return arr.reduce(fn, initial);
  var res = initial;
  for (var i = 0; i < arr.length; i++) res = fn(res, arr[i]);
  return res;
};

/**
 * Cache non-integer test regexp.
 */

var isint = /^[0-9]+$/;

function promote(parent, key) {
  if (parent[key].length == 0) return parent[key] = {}
  var t = {};
  for (var i in parent[key]) {
    if (hasOwnProperty.call(parent[key], i)) {
      t[i] = parent[key][i];
    }
  }
  parent[key] = t;
  return t;
}

function parse(parts, parent, key, val) {
  var part = parts.shift();
  
  // illegal
  if (Object.getOwnPropertyDescriptor(Object.prototype, key)) return;
  
  // end
  if (!part) {
    if (isArray(parent[key])) {
      parent[key].push(val);
    } else if ('object' == typeof parent[key]) {
      parent[key] = val;
    } else if ('undefined' == typeof parent[key]) {
      parent[key] = val;
    } else {
      parent[key] = [parent[key], val];
    }
    // array
  } else {
    var obj = parent[key] = parent[key] || [];
    if (']' == part) {
      if (isArray(obj)) {
        if ('' != val) obj.push(val);
      } else if ('object' == typeof obj) {
        obj[objectKeys(obj).length] = val;
      } else {
        obj = parent[key] = [parent[key], val];
      }
      // prop
    } else if (~indexOf(part, ']')) {
      part = part.substr(0, part.length - 1);
      if (!isint.test(part) && isArray(obj)) obj = promote(parent, key);
      parse(parts, obj, part, val);
      // key
    } else {
      if (!isint.test(part) && isArray(obj)) obj = promote(parent, key);
      parse(parts, obj, part, val);
    }
  }
}

/**
 * Merge parent key/val pair.
 */

function merge(parent, key, val){
  if (~indexOf(key, ']')) {
    var parts = key.split('[')
      , len = parts.length
      , last = len - 1;
    parse(parts, parent, 'base', val);
    // optimize
  } else {
    if (!isint.test(key) && isArray(parent.base)) {
      var t = {};
      for (var k in parent.base) t[k] = parent.base[k];
      parent.base = t;
    }
    set(parent.base, key, val);
  }

  return parent;
}

/**
 * Compact sparse arrays.
 */

function compact(obj) {
  if ('object' != typeof obj) return obj;

  if (isArray(obj)) {
    var ret = [];

    for (var i in obj) {
      if (hasOwnProperty.call(obj, i)) {
        ret.push(obj[i]);
      }
    }

    return ret;
  }

  for (var key in obj) {
    obj[key] = compact(obj[key]);
  }

  return obj;
}

/**
 * Parse the given obj.
 */

function parseObject(obj){
  var ret = { base: {} };

  forEach(objectKeys(obj), function(name){
    merge(ret, name, obj[name]);
  });

  return compact(ret.base);
}

/**
 * Parse the given str.
 */

function parseString(str){
  var ret = reduce(String(str).split('&'), function(ret, pair){
    var eql = indexOf(pair, '=')
      , brace = lastBraceInKey(pair)
      , key = pair.substr(0, brace || eql)
      , val = pair.substr(brace || eql, pair.length)
      , val = val.substr(indexOf(val, '=') + 1, val.length);

    // ?foo
    if ('' == key) key = pair, val = '';
    if ('' == key) return ret;

    return merge(ret, decode(key), decode(val));
  }, { base: {} }).base;

  return compact(ret);
}

/**
 * Parse the given query `str` or `obj`, returning an object.
 *
 * @param {String} str | {Object} obj
 * @return {Object}
 * @api public
 */

exports.parse = function(str){
  if (null == str || '' == str) return {};
  return 'object' == typeof str
    ? parseObject(str)
    : parseString(str);
};

/**
 * Turn the given `obj` into a query string
 *
 * @param {Object} obj
 * @return {String}
 * @api public
 */

var stringify = exports.stringify = function(obj, prefix) {
  if (isArray(obj)) {
    return stringifyArray(obj, prefix);
  } else if ('[object Object]' == toString.call(obj)) {
    return stringifyObject(obj, prefix);
  } else if ('string' == typeof obj) {
    return stringifyString(obj, prefix);
  } else {
    return prefix + '=' + encodeURIComponent(String(obj));
  }
};

/**
 * Stringify the given `str`.
 *
 * @param {String} str
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyString(str, prefix) {
  if (!prefix) throw new TypeError('stringify expects an object');
  return prefix + '=' + encodeURIComponent(str);
}

/**
 * Stringify the given `arr`.
 *
 * @param {Array} arr
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyArray(arr, prefix) {
  var ret = [];
  if (!prefix) throw new TypeError('stringify expects an object');
  for (var i = 0; i < arr.length; i++) {
    ret.push(stringify(arr[i], prefix + '[' + i + ']'));
  }
  return ret.join('&');
}

/**
 * Stringify the given `obj`.
 *
 * @param {Object} obj
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyObject(obj, prefix) {
  var ret = []
    , keys = objectKeys(obj)
    , key;

  for (var i = 0, len = keys.length; i < len; ++i) {
    key = keys[i];
    if ('' == key) continue;
    if (null == obj[key]) {
      ret.push(encodeURIComponent(key) + '=');
    } else {
      ret.push(stringify(obj[key], prefix
        ? prefix + '[' + encodeURIComponent(key) + ']'
        : encodeURIComponent(key)));
    }
  }

  return ret.join('&');
}

/**
 * Set `obj`'s `key` to `val` respecting
 * the weird and wonderful syntax of a qs,
 * where "foo=bar&foo=baz" becomes an array.
 *
 * @param {Object} obj
 * @param {String} key
 * @param {String} val
 * @api private
 */

function set(obj, key, val) {
  var v = obj[key];
  if (Object.getOwnPropertyDescriptor(Object.prototype, key)) return;
  if (undefined === v) {
    obj[key] = val;
  } else if (isArray(v)) {
    v.push(val);
  } else {
    obj[key] = [v, val];
  }
}

/**
 * Locate last brace in `str` within the key.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function lastBraceInKey(str) {
  var len = str.length
    , brace
    , c;
  for (var i = 0; i < len; ++i) {
    c = str[i];
    if (']' == c) brace = false;
    if ('[' == c) brace = true;
    if ('=' == c && !brace) return i;
  }
}

/**
 * Decode `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

function decode(str) {
  try {
    return decodeURIComponent(str.replace(/\+/g, ' '));
  } catch (err) {
    return str;
  }
}

},{}],48:[function(require,module,exports){
(function (global){
;(function(win){
	var store = {},
		doc = win.document,
		localStorageName = 'localStorage',
		storage

	store.disabled = false
	store.set = function(key, value) {}
	store.get = function(key) {}
	store.remove = function(key) {}
	store.clear = function() {}
	store.transact = function(key, defaultVal, transactionFn) {
		var val = store.get(key)
		if (transactionFn == null) {
			transactionFn = defaultVal
			defaultVal = null
		}
		if (typeof val == 'undefined') { val = defaultVal || {} }
		transactionFn(val)
		store.set(key, val)
	}
	store.getAll = function() {}
	store.forEach = function() {}

	store.serialize = function(value) {
		return JSON.stringify(value)
	}
	store.deserialize = function(value) {
		if (typeof value != 'string') { return undefined }
		try { return JSON.parse(value) }
		catch(e) { return value || undefined }
	}

	// Functions to encapsulate questionable FireFox 3.6.13 behavior
	// when about.config::dom.storage.enabled === false
	// See https://github.com/marcuswestin/store.js/issues#issue/13
	function isLocalStorageNameSupported() {
		try { return (localStorageName in win && win[localStorageName]) }
		catch(err) { return false }
	}

	if (isLocalStorageNameSupported()) {
		storage = win[localStorageName]
		store.set = function(key, val) {
			if (val === undefined) { return store.remove(key) }
			storage.setItem(key, store.serialize(val))
			return val
		}
		store.get = function(key) { return store.deserialize(storage.getItem(key)) }
		store.remove = function(key) { storage.removeItem(key) }
		store.clear = function() { storage.clear() }
		store.getAll = function() {
			var ret = {}
			store.forEach(function(key, val) {
				ret[key] = val
			})
			return ret
		}
		store.forEach = function(callback) {
			for (var i=0; i<storage.length; i++) {
				var key = storage.key(i)
				callback(key, store.get(key))
			}
		}
	} else if (doc.documentElement.addBehavior) {
		var storageOwner,
			storageContainer
		// Since #userData storage applies only to specific paths, we need to
		// somehow link our data to a specific path.  We choose /favicon.ico
		// as a pretty safe option, since all browsers already make a request to
		// this URL anyway and being a 404 will not hurt us here.  We wrap an
		// iframe pointing to the favicon in an ActiveXObject(htmlfile) object
		// (see: http://msdn.microsoft.com/en-us/library/aa752574(v=VS.85).aspx)
		// since the iframe access rules appear to allow direct access and
		// manipulation of the document element, even for a 404 page.  This
		// document can be used instead of the current document (which would
		// have been limited to the current path) to perform #userData storage.
		try {
			storageContainer = new ActiveXObject('htmlfile')
			storageContainer.open()
			storageContainer.write('<s' + 'cript>document.w=window</s' + 'cript><iframe src="/favicon.ico"></iframe>')
			storageContainer.close()
			storageOwner = storageContainer.w.frames[0].document
			storage = storageOwner.createElement('div')
		} catch(e) {
			// somehow ActiveXObject instantiation failed (perhaps some special
			// security settings or otherwse), fall back to per-path storage
			storage = doc.createElement('div')
			storageOwner = doc.body
		}
		function withIEStorage(storeFunction) {
			return function() {
				var args = Array.prototype.slice.call(arguments, 0)
				args.unshift(storage)
				// See http://msdn.microsoft.com/en-us/library/ms531081(v=VS.85).aspx
				// and http://msdn.microsoft.com/en-us/library/ms531424(v=VS.85).aspx
				storageOwner.appendChild(storage)
				storage.addBehavior('#default#userData')
				storage.load(localStorageName)
				var result = storeFunction.apply(store, args)
				storageOwner.removeChild(storage)
				return result
			}
		}

		// In IE7, keys may not contain special chars. See all of https://github.com/marcuswestin/store.js/issues/40
		var forbiddenCharsRegex = new RegExp("[!\"#$%&'()*+,/\\\\:;<=>?@[\\]^`{|}~]", "g")
		function ieKeyFix(key) {
			return key.replace(forbiddenCharsRegex, '___')
		}
		store.set = withIEStorage(function(storage, key, val) {
			key = ieKeyFix(key)
			if (val === undefined) { return store.remove(key) }
			storage.setAttribute(key, store.serialize(val))
			storage.save(localStorageName)
			return val
		})
		store.get = withIEStorage(function(storage, key) {
			key = ieKeyFix(key)
			return store.deserialize(storage.getAttribute(key))
		})
		store.remove = withIEStorage(function(storage, key) {
			key = ieKeyFix(key)
			storage.removeAttribute(key)
			storage.save(localStorageName)
		})
		store.clear = withIEStorage(function(storage) {
			var attributes = storage.XMLDocument.documentElement.attributes
			storage.load(localStorageName)
			for (var i=0, attr; attr=attributes[i]; i++) {
				storage.removeAttribute(attr.name)
			}
			storage.save(localStorageName)
		})
		store.getAll = function(storage) {
			var ret = {}
			store.forEach(function(key, val) {
				ret[key] = val
			})
			return ret
		}
		store.forEach = withIEStorage(function(storage, callback) {
			var attributes = storage.XMLDocument.documentElement.attributes
			for (var i=0, attr; attr=attributes[i]; ++i) {
				callback(attr.name, store.deserialize(storage.getAttribute(attr.name)))
			}
		})
	}

	try {
		var testKey = '__storejs__'
		store.set(testKey, testKey)
		if (store.get(testKey) != testKey) { store.disabled = true }
		store.remove(testKey)
	} catch(e) {
		store.disabled = true
	}
	store.enabled = !store.disabled
	
	if (typeof module != 'undefined' && module.exports) { module.exports = store }
	else if (typeof define === 'function' && define.amd) { define(store) }
	else { win.store = store }
	
})(this.window || global);

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],49:[function(require,module,exports){
//     Underscore.js 1.6.0
//     http://underscorejs.org
//     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    concat           = ArrayProto.concat,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.6.0';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return obj;
    if (obj.length === +obj.length) {
      for (var i = 0, length = obj.length; i < length; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      var keys = _.keys(obj);
      for (var i = 0, length = keys.length; i < length; i++) {
        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
      }
    }
    return obj;
  };

  // Return the results of applying the iterator to each element.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    _.each(obj, function(value, index, list) {
      results.push(iterator.call(context, value, index, list));
    });
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    _.each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    _.each(obj, function(value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var result;
    _.some(obj, function(value, index, list) {
      if (predicate.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    if (obj == null) return results;
    _.each(obj, function(value, index, list) {
      if (predicate.call(context, value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(predicate), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate || (predicate = _.identity);
    var result = true;
    if (obj == null) return result;
    _.each(obj, function(value, index, list) {
      if (!(result = result && predicate.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate || (predicate = _.identity);
    var result = false;
    if (obj == null) return result;
    _.each(obj, function(value, index, list) {
      if (result || (result = predicate.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (obj.length === +obj.length) return _.indexOf(obj, target) >= 0;
    return _.some(obj, function(value) {
      return value === target;
    });
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matches(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matches(attrs));
  };

  // Return the maximum element or (element-based computation).
  _.max = function(obj, iterator, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (!iterator && _.isArray(obj)) {
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      _.each(obj, function(value, index, list) {
        computed = iterator ? iterator.call(context, value, index, list) : value;
        if (computed > lastComputed) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (!iterator && _.isArray(obj)) {
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      _.each(obj, function(value, index, list) {
        computed = iterator ? iterator.call(context, value, index, list) : value;
        if (computed < lastComputed) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle an array, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    _.each(obj, function(value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (obj.length !== +obj.length) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function(value, context) {
    if (value == null) return _.identity;
    if (!_.isFunction(value)) return _.property(value);
    if (!context) return value;
    return function() {
      return value.apply(context, arguments);
    };
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, iterator, context) {
    iterator = lookupIterator(iterator, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iterator(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iterator, context) {
      var result = {};
      iterator = lookupIterator(iterator, context);
      _.each(obj, function(value, index) {
        var key = iterator(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    _.has(result, key) ? result[key].push(value) : result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    _.has(result, key) ? result[key]++ : result[key] = 1;
  });

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator, context) {
    iterator = lookupIterator(iterator, context);
    var value = iterator(obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >>> 1;
      iterator(array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n == null) || guard) return array[0];
    if (n < 0) return [];
    return slice.call(array, 0, n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n == null) || guard) return array[array.length - 1];
    return slice.call(array, Math.max(array.length - n, 0));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, (n == null) || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, output) {
    if (shallow && _.every(input, _.isArray)) {
      return concat.apply(output, input);
    }
    for (var i = 0, length = input.length; i < length; i++) {
      var value = input[i];
      if (!_.isArray(value) && !_.isArguments(value)) {
        if (!strict) output.push(value);
      } else if (shallow) {
        push.apply(output, value);
      } else {
        flatten(value, shallow, strict, output);
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Split an array into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = lookupIterator(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator, context) {
    if (array == null) return [];
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var result = [];
    var seen = [];
    for (var i = 0, length = array.length; i < length; i++) {
      var value = array[i];
      if (iterator) value = iterator.call(context, value, i, array);
      if (isSorted ? (!i || seen !== value) : !_.contains(seen, value)) {
        if (isSorted) seen = value;
        else seen.push(value);
        result.push(array[i]);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true, []));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    if (array == null) return [];
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = array.length; i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(slice.call(arguments, 1), true, true, []);
    return _.filter(array, function(value){ return !_.contains(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var length = _.max(_.pluck(arguments, 'length').concat(0));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(arguments, '' + i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, length = list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, length = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    for (; i < length; i++) if (array[i] === item) return i;
    return -1;
  };

  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var i = from == null ? array.length : from;
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(length);

    while(idx < length) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    var args, bound;
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      ctor.prototype = null;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    return function() {
      var position = 0;
      var args = boundArgs.slice();
      for (var i = 0, length = args.length; i < length; i++) {
        if (args[i] === _) args[i] = arguments[position++];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return func.apply(this, args);
    };
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0) throw new Error('bindAll must be passed function names');
    _.each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    options || (options = {});
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
        context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last > 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) {
        timeout = setTimeout(later, wait);
      }
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = new Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = new Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    if (!_.isObject(obj)) return obj;
    _.each(slice.call(arguments, 1), function(source) {
      for (var prop in source) {
        obj[prop] = source[prop];
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj, iterator, context) {
    var result = {};
    if (_.isFunction(iterator)) {
      for (var key in obj) {
        var value = obj[key];
        if (iterator.call(context, value, key, obj)) result[key] = value;
      }
    } else {
      var keys = concat.apply([], slice.call(arguments, 1));
      for (var i = 0, length = keys.length; i < length; i++) {
        var key = keys[i];
        if (key in obj) result[key] = obj[key];
      }
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iterator, context) {
    var keys;
    if (_.isFunction(iterator)) {
      iterator = _.negate(iterator);
    } else {
      keys = _.map(concat.apply([], slice.call(arguments, 1)), String);
      iterator = function(value, key) { return !_.contains(keys, key); };
    }
    return _.pick(obj, iterator, context);
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    if (!_.isObject(obj)) return obj;
    _.each(slice.call(arguments, 1), function(source) {
      for (var prop in source) {
        if (obj[prop] === void 0) obj[prop] = source[prop];
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    // Objects with different constructors are not equivalent, but `Object`s
    // from different frames are.
    var aCtor, aHasCtor, bCtor, bHasCtor;

    try {
      aCtor = a.constructor;
      aHasCtor = 'constructor' in a;
    } catch (e) {}

    try {
      bCtor = b.constructor;
      bHasCtor = 'constructor' in b;
    } catch (e) {}

    if (aCtor !== bCtor && aHasCtor && bHasCtor &&
      !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
        _.isFunction(bCtor) && (bCtor instanceof bCtor))) {
      return false;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj) || _.isArguments(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Optimize `isFunction` if appropriate.
  if (typeof (/./) !== 'function') {
    _.isFunction = function(obj) {
      return typeof obj === 'function';
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj != +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = function(key) {
    return function(obj) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of `key:value` pairs.
  _.matches = function(attrs) {
    return function(obj) {
      if (obj == null) return _.isEmpty(attrs);
      if (obj === attrs) return true;
      for (var key in attrs) if (attrs[key] !== obj[key]) return false;
      return true;
    }
  };

  // Run a function **n** times.
  _.times = function(n, iterator, context) {
    var accum = Array(Math.max(0, n));
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() { return new Date().getTime(); };

  // List of HTML entities for escaping.
  var entityMap = {
    escape: {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;'
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  // Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
  };

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  _.each(['escape', 'unescape'], function(method) {
    _[method] = function(string) {
      if (string == null) return '';
      return ('' + string).replace(entityRegexes[method], function(match) {
        return entityMap[method][match];
      });
    };
  });

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return void 0;
    var value = object[property];
    return _.isFunction(value) ? object[property]() : value;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + "return __p;\n";

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    // Start chaining a wrapped Underscore object.
    chain: function() {
      this._chain = true;
      return this;
    },

    // Extracts the result from a wrapped and chained object.
    value: function() {
      return this._wrapped;
    }

  });

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}).call(this);

},{}],50:[function(require,module,exports){
require('./overflow-scroll');

},{"./overflow-scroll":51}],51:[function(require,module,exports){
var Backbone = require('backbone');

/**
 * Scroll an element vertically based on a wheel event object.
 *
 * @param {Object}  e
 * @param {Element} el
 * @param {Boolean} block
 */
var scrollVertical = function (e, el, block) {
  if (!block) {
    // Hasn't scrolled up or down.
    if (e.deltaY === 0) {
      return;
    }

    // Attempting to scroll up.
    if (e.deltaY < 0 && el.scrollTop === 0) {
      return;
    }

    // Attempting to scroll down.
    if (e.deltaY > 0 && el.scrollTop === el.scrollHeight - el.clientHeight) {
      return;
    }
  }

  e.preventDefault();
  el.scrollTop += e.deltaY;
};

/**
 * Scroll an element horizontally based on a wheel event object.
 *
 * @param {Object}  e
 * @param {Element} el
 * @param {Boolean} block
 */
var scrollHorizontal = function (e, el, block) {
  if (!block) {
    // Hasn't scrolled left or right.
    if (e.deltaX === 0) {
      return;
    }

    // Attempting to scroll left.
    if (e.deltaX < 0 && el.scrollLeft === 0) {
      return;
    }

    // Attempting to scroll right.
    if (e.deltaX > 0 && el.scrollLeft === el.scrollWidth - el.clientWidth) {
      return;
    }
  }

  e.preventDefault();
  el.scrollLeft += e.deltaX;
};

/**
 * Bind to the entire document and just listen for a data attribute.
 */
Backbone.$(document)
  .on('wheel', '[data-overflow-scroll]', function (e, el) {
    var block = !!el.getAttribute('data-overflow-scroll');

    scrollVertical(e, el, block);
    scrollHorizontal(e, el, block);
  });

},{"backbone":3}],52:[function(require,module,exports){
// Shim Backbone with the functionality from Backbone.native
var Backbone = require('backbone');
Backbone.$   = require('backbone.native');

// ES6 Feature Shim.
require('es6-collections');

// Require all CodeMirror functionality.
require('codemirror/addon/mode/overlay');
require('codemirror/addon/comment/comment');
require('codemirror/mode/gfm/gfm');
require('codemirror/mode/markdown/markdown');
require('codemirror/mode/css/css');
require('codemirror/mode/xml/xml');
require('codemirror/mode/clike/clike');
require('codemirror/mode/htmlmixed/htmlmixed');
require('codemirror/mode/javascript/javascript');

// Bootstrap core functionality.
require('./dom');
require('./plugins');

},{"./dom":50,"./plugins":61,"backbone":3,"backbone.native":2,"codemirror/addon/comment/comment":20,"codemirror/addon/mode/overlay":21,"codemirror/mode/clike/clike":23,"codemirror/mode/css/css":24,"codemirror/mode/gfm/gfm":25,"codemirror/mode/htmlmixed/htmlmixed":26,"codemirror/mode/javascript/javascript":27,"codemirror/mode/markdown/markdown":28,"codemirror/mode/xml/xml":29,"es6-collections":44}],53:[function(require,module,exports){
var _          = require('underscore');
var middleware = require('../../state/middleware');

var AJAX_TIMEOUT = 20000;

/**
 * Send an ajax request and return the xhr request back to the final listener.
 *
 * @param  {Object}   options
 * @param  {Function} next
 */
middleware.register('ajax', function (options, next) {
  var url     = options.url;
  var method  = options.method || 'GET';
  var xhr     = options.xhr = new XMLHttpRequest();
  var async   = options.async !== false;
  var timeout = +options.timeout || AJAX_TIMEOUT;
  var ajaxTimeout;

  /**
   * Wraps callback functions to remove xhr data.
   *
   * @param  {Function} fn
   * @return {Function}
   */
  var complete = function (fn) {
    return function () {
      window.clearTimeout(ajaxTimeout);

      // Remove references to unused functions.
      xhr.onload = xhr.onerror = xhr.onabort = null;

      return fn.apply(this, arguments);
    };
  };

  xhr.open(method, url, async);

  // Sets all request headers before we make the request.
  _.each(options.headers, function (value, header) {
    xhr.setRequestHeader(header, value);
  });

  // Enable hooking into the ajax request before we send it.
  if (options.beforeSend) {
    options.beforeSend(xhr);
  }

  // Successful callback.
  xhr.onload = complete(function () {
    return next(null, xhr);
  });

  // Failure callback.
  xhr.onerror = xhr.onabort = complete(function () {
    return next(new Error(xhr.statusText || 'Ajax request aborted'), xhr);
  });

  // Set a request timeout. Modern browsers can set a `timeout` property
  // which works the same, but we'll use a timeout for consistency.
  if (async) {
    ajaxTimeout = window.setTimeout(complete(function () {
      xhr.abort();

      // Calls the `next` function with the timeout details.
      return next(
        new Error('Ajax timeout of ' + timeout + 'ms exceeded'), xhr
      );
    }), timeout);
  }

  xhr.send(options.data);
});

},{"../../state/middleware":109,"underscore":49}],54:[function(require,module,exports){
/* global App */
var _           = require('underscore');
var async       = require('async');
var loadScript  = require('../../lib/browser/load-script');
var state       = require('../../state/state');
var config      = require('../../state/config');
var messages    = require('../../state/messages');
var middleware  = require('../../state/middleware');
var PostMessage = require('../../lib/post-message');

/**
 * Alias any optional global variables passed in.
 *
 * @param {Object}   options
 * @param {Function} next
 */
middleware.register('application:start', function (options, next) {
  _.each(options.alias || {}, function (value, key) {
    window[key] = value;
  });

  return next();
});

/**
 * Execute arbitrary passed in scripts.
 *
 * @param {Object}   options
 * @param {Function} next
 */
middleware.register('application:start', function (options, next) {
  try {
    /* jshint evil: true */
    window.eval(options.exec || '');
  } catch (e) {
    return next(e);
  }

  return next();
});

/**
 * Load all injected script options.
 *
 * @param {Object}   options
 * @param {Function} next
 */
middleware.register('application:start', function (options, next) {
  return async.each(options.inject || [], loadScript, next);
});

/**
 * Update the config object with the optional passed in config.
 *
 * @param {Object}   options
 * @param {Function} next
 */
middleware.register('application:start', function (options, next) {
  middleware.trigger(
    'application:config',
    _.extend({}, options.config),
    function (err, options) {
      if (err) {
        return next(err);
      }

      // Set certain properties before others to avoid ordering issues.
      config.set('embedded',       !!options.embedded);
      config.set('authentication', options.authentication !== false);
      config.set(_.omit(options, ['embedded', 'authentication']));

      return next();
    }
  );
});

/**
 * The first middleware for application start has to be the parent frame set up.
 *
 * @param {Object}   options
 * @param {Function} next
 */
middleware.register('application:start', function (options, next) {
  // Skip middleware execution if we are the parent frame.
  if (window === window.parent) { return next(); }

  var postMessage = App.postMessage = new PostMessage(window.parent);

  /**
   * Listen for changes in the document height and resize the parent frame.
   */
  state.on('change:documentHeight', function (_, height) {
    postMessage.trigger('height', height);
  });

  /**
   * Listen for any changes to the configuration url and update the base
   * element. This is required for correctly opening links in the parent frame.
   */
  postMessage.listenTo(config, 'change:url', (function () {
    var headEl = document.head || document.getElementsByTagName('head')[0];
    var baseEl = document.getElementsByTagName('base')[0];

    return function (_, url) {
      if (baseEl) { baseEl.parentNode.removeChild(baseEl); }

      baseEl = document.createElement('base');
      baseEl.setAttribute('href',   url);
      baseEl.setAttribute('target', '_parent');
      headEl.appendChild(baseEl);
    };
  })());

  /**
   * Listen to the parent frame to be ready and pass its config options.
   */
  postMessage.on('ready', function (parentOptions) {
    _.extend(options, parentOptions);
    return next();
  });

  /**
   * Run arbitrary code inside the frame by passed an evil string in.
   */
  postMessage.on('exec', function (evil) {
    /* jshint evil: true */
    postMessage.trigger('exec', window.eval(evil));
  });

  /**
   * Listen to any configuration changes.
   */
  postMessage.on('config', function () {
    config.set.apply(config, arguments);
  });

  /**
   * Trigger cross-frame messages easily.
   */
  postMessage.on('message', function () {
    messages.trigger.apply(messages, arguments);
  });

  /**
   * Trigger changes on the config object to the parent frame. This is
   * incredibly useful for helping the parent frame with integration.
   */
  postMessage.listenTo(config, 'all', function (name) {
    if (name.substr(0, 7) !== 'change:') { return; }

    var option = name.substr(7);
    postMessage.trigger('config', option, config.get(option));
  });

  /**
   * Trigger a ready event to the parent frame. This allows the frame to now
   * send all its config options without risk of losing data.
   */
  postMessage.trigger('ready');
});

/**
 * Check whether the browser supports core JavaScript ES5 APIs needed for the
 * notebook to function.
 *
 * @param {Object}   app
 * @param {Function} next
 */
middleware.register('application:start', function (app, next) {
  if (
    window.addEventListener && Object.getOwnPropertyNames &&
    Object.getPrototypeOf && Object.getOwnPropertyDescriptor
  ) {
    return next();
  }

  middleware.trigger('ui:modal', {
    title: 'Unsupported Browser',
    content: '<p>Your browser is out of date. Please consider upgrading to ' +
      'get the full experience of this application. <a target="_blank" ' +
      'href="http://browsehappy.com/">You can find a list of up-to-date ' +
      'browsers here.</a></p><div class="text-center">' +
      '<button class="btn btn-primary" data-dismiss>Close</button></div>'
  }, next);
});

},{"../../lib/browser/load-script":72,"../../lib/post-message":96,"../../state/config":107,"../../state/messages":108,"../../state/middleware":109,"../../state/state":111,"async":1,"underscore":49}],55:[function(require,module,exports){
(function (Buffer){
var _          = require('underscore');
var middleware = require('../../../state/middleware');

/**
 * Authenticate using basic auth.
 *
 * @param {Object}   options
 * @param {Function} next
 * @param {Function} done
 */
middleware.register('authenticate', function (options, next, done) {
  if (options.type !== 'Basic Authentication') {
    return next();
  }

  if (!_.isString(options.username) || !_.isString(options.password)) {
    return next(new TypeError('Username and password must be defined'));
  }

  return done(null, _.pick(options, 'username', 'password'));
});

/**
 * Trigger an ajax request using basic auth configuration options.
 *
 * @param {Object}   data
 * @param {Function} next
 */
middleware.register('ajax:basicAuth', function (data, next) {
  // Check we have a basic auth object before mixing in our credentials.
  if (_.isObject(data.basicAuth)) {
    data.headers = _.extend({
      'Authorization': 'Basic ' + new Buffer(
        data.basicAuth.username + ':' + data.basicAuth.password
      ).toString('base64')
    }, data.headers);
  }

  return middleware.trigger('ajax', data, next);
});

}).call(this,require("buffer").Buffer)
},{"../../../state/middleware":109,"buffer":11,"underscore":49}],56:[function(require,module,exports){
require('./basic');
require('./oauth1');
require('./oauth2');

},{"./basic":55,"./oauth1":58,"./oauth2":59}],57:[function(require,module,exports){
var _          = require('underscore');
var Backbone   = require('backbone');
var middleware = require('../../../../state/middleware');

/**
 * Keep track of open popup windows so we only have one open at a time.
 *
 * @type {Object}
 */
var openPopup, openModal, closeInterval;

/**
 * Closes previously opened windows and modals.
 */
var closeAll = function () {
  if (openPopup) { openPopup.close(); }
  if (openModal) { openModal.close(); }

  openPopup = null;
  openModal = null;

  window.clearInterval(closeInterval);
};

/**
 * Pop open an authentication window. It adds some additional safe guards such
 * as catching blocked popup windows, listening for window closes, simplified
 * window positioning, etc.
 *
 * @return {Object} Execute `close` when the window is safe to cleared.
 */
module.exports = function (url, options, cb) {
  var width     = Math.min(720, window.screen.availWidth);
  var height    = Math.min(480, window.screen.availHeight);
  var top       = Math.min(100, (window.screen.availHeight - height) / 2);
  var left      = (window.screen.availWidth - width) / 2;
  var completed = false;

  /**
   * Close all the open modals and popups.
   *
   * @param  {Error}    err
   * @return {Function}
   */
  var done = function (err) {
    closeAll();
    return cb(err);
  };

  // Close previously open popup windows and modals.
  closeAll();

  var modalOptions = _.extend({
    title: 'Request API Permission',
    content: [
      '<p>',
      'Please grant access to this application to make an API request.',
      '</p>',
      '<p>',
      'Click the "Authenticate" button to approve the use of your credentials.',
      'You can revoke these permissions at any time.',
      '</p>',
    ].join('\n'),
    btnText: 'Authenticate',
    show: function (modal) {
      openModal = modal;

      // Open a popup window when the authentication button is pressed.
      Backbone.$(modal.el).on('click', '[data-authenticate]', function () {
        openPopup = window.open(
          url, '', [
            'top=' + top,
            'left=' + left,
            'width=' + width,
            'height=' + height,
            'scrollbars=1'
          ].join(',')
        );

        if (typeof openPopup !== 'object') {
          openPopup = null;
          return done(new Error('Popup window blocked'));
        }

        // Catch window closes before authentication is complete.
        closeInterval = window.setInterval(function () {
          if (openPopup.closed) {
            openPopup = null;
            return done(new Error('Popup window closed'));
          }
        }, 400);
      });
    }
  }, options.modal);


  modalOptions.content += [
    '<div class="text-center">',
    '<button class="btn btn-primary" data-authenticate>',
    modalOptions.btnText,
    '</button>',
    '</div>'
  ].join('\n');

  middleware.trigger('ui:modal', modalOptions, function () {
    openModal = null;
    return !completed && done(new Error('Modal closed without authenticating'));
  });

  return {
    close: function () {
      // Set completed to true so we won't cause an error callback.
      completed = true;

      // Remove any references to open modals and windows.
      return closeAll();
    }
  };
};

},{"../../../../state/middleware":109,"backbone":3,"underscore":49}],58:[function(require,module,exports){
(function (global){
/* global App */
var _           = require('underscore');
var qs          = require('qs');
var url         = require('url');
var crypto      = require('crypto');
var authWindow  = require('./lib/auth-window');
var middleware  = require('../../../state/middleware');

/**
 * Set the default redirection url.
 *
 * @type {String}
 */
var REDIRECT_URI = url.resolve(
  global.location.href, {"url":"https://mulesoft.github.io/api-notebook/","title":"API Notebook","oauthCallback":"/authenticate/oauth.html"}.oauthCallback
);

/**
 * Simple constant for the url encoded content type.
 *
 * @type {String}
 */
var URL_ENCODED = 'application/x-www-form-urlencoded';

/**
 * Default ports of different protocols.
 *
 * @type {Object}
 */
var defaultPorts = {
  'http:':  '80',
  'https:': '443'
};

/**
 * Return the current timestamp in seconds since January 1, 1970 00:00:00 GMT.
 *
 * @return {Number}
 */
var getTimestamp = function () {
  return Math.floor(Date.now() / 1000);
};

/**
 * Encode a string according to RFC3986.
 *
 * @param  {String} str
 * @return {String}
 */
var encodeData = function (str) {
  if (str == null) {
    return '';
  }

  return encodeURIComponent(str)
    .replace(/\'/g, '%27')
    .replace(/\(/g, '%28')
    .replace(/\)/g, '%29')
    .replace(/\*/g, '%2A')
    .replace(/\!/g, '%21');
};

/**
 * Normalize the url for including with the hashed signature.
 *
 * @param  {Object} uri
 * @return {String}
 */
var normalizeUrl = function (uri) {
  var port = '';

  if (uri.port && defaultPorts[uri.protocol] !== uri.port) {
    port = ':' + uri.port;
  }

  return uri.protocol + '//' + uri.hostname + port + uri.pathname;
};

/**
 * Sort query string parameters (represented as an array of arrays) by name and
 * then value.
 *
 * @param  {Array} argPairs
 * @return {Array}
 */
var sortRequestParams = function (argPairs) {
  return argPairs.sort(function (a, b) {
    if (a[0] === b[0]) {
      return a[1] < b[1] ? -1 : 1;
    }

    return a[0] < b[0] ? -1 : 1;
  });
};

/**
 * Transform an object of key, value pairs to an array of arrays.
 *
 * @param  {Object} obj
 * @return {Array}
 */
var paramsToArray = function (obj) {
  return _.pairs(obj);
};

/**
 * Transform an array of parameters (in nested array form) to a query string.
 *
 * @param  {Array}  array
 * @return {String}
 */
var arrayToParams = function (array) {
  return _.map(array, function (args) {
    return encodeData(args[0]) + '=' + encodeData(args[1]);
  }).join('&');
};

/**
 * Create the base signature string for hashing.
 *
 * @param  {Object} data
 * @return {String}
 */
var createSignatureBase = function (params, data) {
  return [
    data.method.toUpperCase(),
    encodeData(normalizeUrl(data.url)),
    encodeData(arrayToParams(params))
  ].join('&');
};

/**
 * Generate a signature string combining the base signature with consumer
 * secrets.
 *
 * @param  {String} base
 * @param  {Object} data
 * @return {String}
 */
var createSignature = function (base, options) {
  var key = [
    encodeData(options.consumerSecret), encodeData(options.oauthTokenSecret)
  ].join('&');

  var hash = key;

  if (options.signatureMethod === 'HMAC-SHA1') {
    hash = crypto.createHmac('sha1', key).update(base).digest('base64');
  }

  return hash;
};

/**
 * Generate a signature from the AJAX data.
 *
 * @param  {Array}  params
 * @param  {Object} data
 * @return {String}
 */
var getSignature = function (params, data) {
  var signatureBase = createSignatureBase(params, data);
  return createSignature(signatureBase, data.oauth1);
};

/**
 * Generate a random nonce string.
 *
 * @return {String}
 */
var getNonce = function () {
  var chars = [
    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
    'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D',
    'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', '1', '2', '3', '4', '5', '6', '7',
    '8', '9'
  ];

  var nonce = '';

  for (var i = 0; i < 32; i++) {
    nonce += _.sample(chars);
  }

  return nonce;
};

/**
 * Prepare ordered OAuth parameters based on the provided data.
 *
 * @param  {Object} data
 * @return {Array}
 */
var prepareParameters = function (data) {
  var params = paramsToArray(_.extend({
    'oauth_timestamp':        getTimestamp(),
    'oauth_nonce':            getNonce(),
    'oauth_version':          '1.0',
    'oauth_signature_method': data.oauth1.signatureMethod,
    'oauth_consumer_key':     data.oauth1.consumerKey
  }, data.url.query));

  // Attach the token query parameter if we have one.
  if (data.oauth1.oauthToken) {
    params.push(['oauth_token', data.oauth1.oauthToken]);
  }

  if (data.oauth1.oauthCallback) {
    params.push(['oauth_callback', data.oauth1.oauthCallback]);
  }

  var contentType = _.find(_.pairs(data.headers), function (header) {
    return header[0].toLowerCase() === 'content-type';
  });

  if (!contentType) {
    contentType = data.headers['Content-Type'] = URL_ENCODED;
  } else {
    contentType = contentType[1];
  }

  if (contentType === URL_ENCODED) {
    if (_.isString(data.data)) {
      data.data = qs.parse(data.data);
    }

    if (_.isObject(data.data)) {
      var body = paramsToArray(data.data);
      data.data = arrayToParams(body);
      params.push.apply(params, body);
    }
  }

  var sortedParams = sortRequestParams(params);

  sortedParams.push(
    ['oauth_signature', encodeData(getSignature(sortedParams, data))]
  );

  return sortedParams;
};

/**
 * Check whether the parameters name is a valid OAuth parameter.
 *
 * @param  {String}  param
 * @return {Boolean}
 */
var isParamAnOAuthParameter = function (param) {
  return (/^oauth_/).test(param);
};

/**
 * Generate the Authorization header from an order parameter array.
 *
 * @param  {Object} data
 * @param  {Array}  params
 * @return {String}
 */
var buildAuthorizationHeaders = function (data, params) {
  return 'OAuth realm="' + normalizeUrl(data.url) + '",' +
    _.chain(params).filter(function (param) {
      return isParamAnOAuthParameter(param[0]);
    }).map(function (param) {
      return param[0] + '="' + param[1] + '"';
    }).value().join(',');
};

/**
 * Send a request to get the initial OAuth request tokens.
 *
 * @param {String}   url
 * @param {Function} done
 */
var getRequestToken = function (options, done) {
  return App.middleware.trigger('ajax:oauth1', {
    url:    options.requestTokenUri,
    method: 'POST',
    oauth1: _.extend({
      oauthCallback: options.redirectUri
    }, options),
    headers: {
      'Content-Type': URL_ENCODED
    }
  }, function (err, xhr) {
    if (err) { return done(err); }

    if (xhr.status !== 200) {
      return done(new Error(xhr.responseText || 'Invalid Request'));
    }

    var content = qs.parse(xhr.responseText);

    return done(null, {
      oauthToken:       content.oauth_token,
      oauthTokenSecret: content.oauth_token_secret
    });
  });
};

/**
 * Get the final access token by passing in the request options and the token
 * verifier.
 *
 * @param {Object}   options
 * @param {String}   verifier
 * @param {Function} done
 */
var getAccessToken = function (options, verifier, done) {
  return App.middleware.trigger('ajax:oauth1', {
    url:    options.tokenCredentialsUri,
    method: 'POST',
    oauth1: options,
    headers: {
      'Content-Type': URL_ENCODED
    },
    data: qs.stringify({
      'oauth_verifier': verifier
    })
  }, function (err, xhr) {
    if (err) { return done(err); }

    var response = qs.parse(xhr.responseText);

    var data = {
      response:         response,
      oauthToken:       response.oauth_token,
      oauthTokenSecret: response.oauth_token_secret
    };

    // Delete data that has been pulled off the response object to avoid
    // duplication.
    delete response.oauth_token;
    delete response.oauth_token_secret;

    if (!_.keys(data.response).length) {
      delete data.response;
    }

    return done(null, data);
  });
};

/**
 * Trigger the full OAuth1 authentication flow.
 *
 * @param {Object}   options
 * @param {Function} done
 */
var oauth1Flow = function (options, done) {
  if (!_.isString(options.consumerKey)) {
    return done(new TypeError('"consumerKey" expected'));
  }

  if (!_.isString(options.consumerSecret)) {
    return done(new TypeError('"consumerSecret" expected'));
  }

  if (!_.isString(options.requestTokenUri)) {
    return done(new TypeError('"requestTokenUri" expected'));
  }

  if (!_.isString(options.authorizationUri)) {
    return done(new TypeError('"authorizationUri" expected'));
  }

  if (!_.isString(options.tokenCredentialsUri)) {
    return done(new TypeError('"tokenCredentialsUri" expected'));
  }

  return getRequestToken(options, function (err, data) {
    if (err) { return done(err); }

    var popup = authWindow(options.authorizationUri + '?' + qs.stringify({
      'oauth_token': data.oauthToken
    }), options, done);

    global.authenticateOAuth = function (href) {
      popup.close();
      delete global.authenticateOAuth;

      if (href.substr(0, options.redirectUri.length) !== options.redirectUri) {
        return done(new Error('Invalid redirect uri'));
      }

      var response = url.parse(href, true).query;

      if (response.oauth_token !== data.oauthToken) {
        return done(new Error('Invalid OAuth token response'));
      }

      return getAccessToken(_.extend({
        oauthToken: response.oauth_token
      }, options), response.oauth_verifier, done);
    };
  });
};

/**
 * Trigger authentication via OAuth1.0(A) in the browser.
 *
 * @param {Object}   options
 * @param {Function} next
 * @param {Function} done
 */
middleware.register('authenticate', function (options, next, done) {
  if (options.type === 'OAuth 1.0') {
    return oauth1Flow(_.extend({
      redirectUri: REDIRECT_URI
    }, options), done);
  }

  return next();
});

/**
 * Allow a new ajax flow for OAuth1-based URLs. Accepts an `oauth1` property
 * on the data object in the format that is returned from the middleware.
 *
 * @param {Object}   data
 * @param {Function} next
 */
middleware.register('ajax:oauth1', function (data, next) {
  // Check we have an oauth1 object for attempting to mixin keys.
  if (_.isObject(data.oauth1)) {
    if (!data.oauth1.signatureMethod) {
      data.oauth1.signatureMethod = 'HMAC-SHA1';
    }

    // Parse the url for augmenting the query string parameters. Needed in
    // multiple places throughout the flow, so we can minimize the number of
    // parses by doing it once at the start.
    data.url = url.parse(data.url, true);

    // Delete parameters specific to re-adding the query string, since we need
    // to regenerate the query string without OAuth params.
    delete data.url.href;
    delete data.url.path;
    delete data.url.search;

    var orderedParams = prepareParameters(data);
    var authorization = buildAuthorizationHeaders(data, orderedParams);

    data.headers.Authorization = authorization;

    data.url.query = arrayToParams(
      _.filter(paramsToArray(data.url.query), function (param) {
        return !isParamAnOAuthParameter(param[0]);
      })
    );

    // Reattach the query string if we have one available.
    if (data.url.query) {
      data.url.search = '?' + data.url.query;
      data.url.path   = data.url.pathname + data.url.search;
    }

    data.url = url.format(data.url);
  }

  return middleware.trigger('ajax', data, next);
});

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../state/middleware":109,"./lib/auth-window":57,"crypto":5,"qs":47,"underscore":49,"url":18}],59:[function(require,module,exports){
(function (global){
/* global App */
var _           = require('underscore');
var qs          = require('qs');
var url         = require('url');
var authWindow  = require('./lib/auth-window');
var middleware  = require('../../../state/middleware');

/**
 * Set the default redirection url.
 *
 * @type {String}
 */
var REDIRECT_URI = url.resolve(
  global.location.href, {"url":"https://mulesoft.github.io/api-notebook/","title":"API Notebook","oauthCallback":"/authenticate/oauth.html"}.oauthCallback
);

/**
 * An array containing the supported grant types in preferred order.
 *
 * @type {Array}
 */
var SUPPORTED_GRANTS = ['token', 'code'];

/**
 * Format error response types to regular strings for displaying the clients.
 * Reference: http://tools.ietf.org/html/rfc6749#section-4.1.2.1
 *
 * @type {Object}
 */
var ERROR_RESPONSES = {
  'invalid_request': [
    'The request is missing a required parameter, includes an',
    'invalid parameter value, includes a parameter more than',
    'once, or is otherwise malformed.'
  ].join(' '),
  'invalid_client': [
    'Client authentication failed (e.g., unknown client, no',
    'client authentication included, or unsupported',
    'authentication method).'
  ].join(' '),
  'invalid_grant': [
    'The provided authorization grant (e.g., authorization',
    'code, resource owner credentials) or refresh token is',
    'invalid, expired, revoked, does not match the redirection',
    'URI used in the authorization request, or was issued to',
    'another client.'
  ].join(' '),
  'unauthorized_client': [
    'The client is not authorized to request an authorization',
    'code using this method.'
  ].join(' '),
  'unsupported_grant_type': [
    'The authorization grant type is not supported by the',
    'authorization server.'
  ].join(' '),
  'access_denied': [
    'The resource owner or authorization server denied the request.'
  ].join(' '),
  'unsupported_response_type': [
    'The authorization server does not support obtaining',
    'an authorization code using this method.'
  ].join(' '),
  'invalid_scope': [
    'The requested scope is invalid, unknown, or malformed.'
  ].join(' '),
  'server_error': [
    'The authorization server encountered an unexpected',
    'condition that prevented it from fulfilling the request.',
    '(This error code is needed because a 500 Internal Server',
    'Error HTTP status code cannot be returned to the client',
    'via an HTTP redirect.)'
  ].join(' '),
  'temporarily_unavailable': [
    'The authorization server is currently unable to handle',
    'the request due to a temporary overloading or maintenance',
    'of the server.'
  ].join(' ')
};

/**
 * Return the formatted error string.
 *
 * @param  {Object} data
 * @return {String}
 */
var erroredResponse = function (data) {
  return ERROR_RESPONSES[data.error] || data.error || data.error_message;
};

/**
 * Fix passed in options objects.
 *
 * @param  {Object} options
 * @return {Object}
 */
var sanitizeOptions = function (options) {
  // Extend an default options object.
  var opts = _.extend({
    redirectUri: REDIRECT_URI
  }, options);

  // Fix up reference to the `scopes` array.
  opts.scope = opts.scope || opts.scopes;

  if (_.isArray(opts.scope)) {
    opts.scope = opts.scope.join(' ');
  }

  // Remove unused `scopes` property.
  delete opts.scopes;

  return opts;
};

/**
 * Validate an OAuth2 response object.
 *
 * @param {Object}   response
 * @param {Function} done
 */
var authResponse = function (options, response, done) {
  if (erroredResponse(response)) {
    return done(new Error(erroredResponse(response)));
  }

  var data = {
    scope: response.scope || options.scope,
    response: _.omit(response, [
      'access_token', 'refresh_token', 'token_type', 'expires_in', 'scope',
      'state', 'error', 'error_description', 'error_uri'
    ]),
    accessToken: response.access_token
  };

  // Omit the response object altogether if no response is available.
  if (!_.keys(data.response).length) {
    delete data.response;
  }

  if (response.token_type) {
    data.tokenType = response.token_type;
  }

  if (+response.expires_in) {
    data.expires = Date.now() + (response.expires_in * 1000);
  }

  if (response.refresh_token) {
    data.refreshToken = response.refresh_token;
  }

  return done(null, data);
};

/**
 * Trigger the client-side implicit OAuth2 flow.
 * Reference: http://tools.ietf.org/html/rfc6749#section-4.2
 *
 * @param {Object}   options
 * @param {Function} done
 */
var oauth2TokenFlow = function (options, done) {
  if (!_.isString(options.clientId)) {
    return done(new TypeError('"clientId" expected'));
  }

  if (!_.isString(options.authorizationUri)) {
    return done(new TypeError('"authorizationUri" expected'));
  }

  var state = ('' + Math.random()).substr(2);
  var popup = authWindow(options.authorizationUri + '?' + qs.stringify({
    'state':         state,
    'scope':         options.scope,
    'client_id':     options.clientId,
    'redirect_uri':  options.redirectUri,
    'response_type': 'token'
  }), options, done);

  global.authenticateOAuth = function (href) {
    popup.close();
    delete global.authenticateOAuth;

    var uri      = url.parse(href, true);
    var response = _.extend(qs.parse((uri.hash || '').substr(1)), uri.query);

    if (href.substr(0, options.redirectUri.length) !== options.redirectUri) {
      return done(new Error('Invalid redirect uri'));
    }

    if (response.state !== state) {
      return done(new Error('State mismatch'));
    }

    // Pass the response off for validation. At least Instagram has a bug where
    // the state is being passed back as part of the query string instead of the
    // hash, so we merge both options together.
    return authResponse(options, response, done);
  };
};

/**
 * Trigger the full server-side OAuth2 flow.
 * Reference: http://tools.ietf.org/html/rfc6749#section-4.1
 *
 * @param {Object}   options
 * @param {Function} done
 */
var oAuth2CodeFlow = function (options, done) {
  if (!_.isString(options.clientId)) {
    return done(new TypeError('"clientId" expected'));
  }

  if (!_.isString(options.clientSecret)) {
    return done(new TypeError('"clientSecret" expected'));
  }

  if (!_.isString(options.accessTokenUri)) {
    return done(new TypeError('"accessTokenUri" expected'));
  }

  if (!_.isString(options.authorizationUri)) {
    return done(new TypeError('"authorizationUri" expected'));
  }

  var state = ('' + Math.random()).substr(2);
  var popup = authWindow(options.authorizationUri + '?' + qs.stringify({
    'state':         state,
    'scope':         options.scope,
    'client_id':     options.clientId,
    'redirect_uri':  options.redirectUri,
    'response_type': 'code'
  }), options, done);

  /**
   * Assigns a global variable that the oauth authentication window should
   * be able to access and send the callback data.
   */
  global.authenticateOAuth = function (href) {
    popup.close();
    delete global.authenticateOAuth;

    // Parse the url and prepare to do an POST request to get the access token.
    var query = url.parse(href, true).query;

    if (href.substr(0, options.redirectUri.length) !== options.redirectUri) {
      return done(new Error('Invalid redirect uri'));
    }

    if (erroredResponse(query)) {
      return done(new Error(erroredResponse(query)));
    }

    if (query.state !== state) {
      return done(new Error('State mismatch'));
    }

    if (!query.code) {
      return done(new Error('Response code missing'));
    }

    App.middleware.trigger('ajax', {
      url: options.accessTokenUri,
      method: 'POST',
      headers: {
        'Accept':       'application/json',
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      data: qs.stringify({
        'code':          query.code,
        'grant_type':    'authorization_code',
        'redirect_uri':  options.redirectUri,
        'client_id':     options.clientId,
        'client_secret': options.clientSecret
      })
    }, function (err, xhr) {
      if (err) { return done(err); }

      return authResponse(options, JSON.parse(xhr.responseText), done);
    });
  };
};

/**
 * Map authentication methods to a function.
 *
 * @type {Object}
 */
var authenticate = {
  code:  oAuth2CodeFlow,
  token: oauth2TokenFlow
};

/**
 * Trigger authentication via OAuth2.0 in the browser. Valid data properties:
 *
 *   `accessTokenUri`      - "https://www.example.com/oauth2/token"
 *   `authorizationUri`    - "https://www.example.com/oauth2/authorize"
 *   `clientId`            - EXAMPLE_CLIENT_ID
 *   `clientSecret`        - EXAMPLE_CLIENT_SECRET
 *   `authorizationGrants` - ["code"]
 *   `scopes`              - ["user", "read", "write"]
 *
 * @param {Object}   options
 * @param {Function} next
 * @param {Function} done
 */
middleware.register('authenticate', function (options, next, done) {
  if (options.type !== 'OAuth 2.0') {
    return next();
  }

  // Sanitize authorization grants to an array.
  if (_.isString(options.authorizationGrants)) {
    options.authorizationGrants = [options.authorizationGrants];
  }

  // Use insection to get the accepted grant types in the order of the
  // supported grant types (which are ordered by preference).
  var grantType = _.intersection(
    SUPPORTED_GRANTS, options.authorizationGrants
  )[0];

  if (!grantType) {
    return done(new Error(
      'Unsupported OAuth2 Grant Flow. Supported flows include ' +
      SUPPORTED_GRANTS.join(', ')
    ));
  }

  return authenticate[grantType](sanitizeOptions(options), done);
});

/**
 * Allow a new ajax flow for OAuth2-based URLs. Accepts an `oauth2` property
 * on the data object in the format that is returned from the middleware.
 *
 * @param {Object}   data
 * @param {Function} next
 */
middleware.register('ajax:oauth2', function (data, next) {
  // Check that we have an access token to use for the request and mix it in.
  if (_.isObject(data.oauth2) && data.oauth2.accessToken) {
    if (data.oauth2.tokenType === 'bearer') {
      data.headers = _.extend({
        'Authorization': 'Bearer ' + data.oauth2.accessToken
      }, data.headers);
    } else {
      // Add the access token to the request query.
      var uri = url.parse(data.url, true);
      uri.query.access_token = data.oauth2.accessToken;
      delete uri.search;

      // Update ajax data headers and url.
      data.url = url.format(uri);
      data.headers = _.extend({
        'Pragma':        'no-store',
        'Cache-Control': 'no-store'
      }, data.headers);
    }
  }

  return middleware.trigger('ajax', data, next);
});

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../state/middleware":109,"./lib/auth-window":57,"qs":47,"underscore":49,"url":18}],60:[function(require,module,exports){
var _          = require('underscore');
var middleware = require('../../state/middleware');
var isInScope  = require('../../lib/codemirror/is-in-scope');

/**
 * Reserved keyword list (http://mdn.io/reserved)
 *
 * @type {Object}
 */
var KEYWORDS = _.object(_.map(
  ('break case catch continue debugger default delete do else ' +
  'false finally for function if in instanceof new null return switch this ' +
  'throw true try typeof var void while with').split(' '),
  function (keyword) {
    return [keyword, {
      value: keyword,
      type: 'keyword'
    }];
  }
));

/**
 * CodeMirror provides access to inline variables defined within the notebook
 * using nested objects to represent each scope level in the editor. This will
 * squash the variables to a single level.
 *
 * @param  {Object} scope
 * @return {Object}
 */
var varsToObject = function (scope, info) {
  var obj = {};

  while (scope && scope.name) {
    obj[scope.name] = info || true;
    scope = scope.next;
  }

  return obj;
};

/**
 * Checks if the variable name is valid.
 *
 * @param  {String}  name
 * @return {Boolean}
 */
var isValidVariableName = function (name) {
  return (/^[a-zA-Z_$][0-9a-zA-Z_$]*$/).test(name);
};

/**
 * Sadly we need to do some additional processing for primitive types and ensure
 * they will use the primitive prototype from the correct global context. This
 * is because primitives lose their prototypes when brought through iframes,
 * regardless of the origin.
 *
 * @param  {*}      object
 * @param  {Object} global
 * @return {Object}
 */
var mapObject = function (object, global) {
  // Sadly we need to do some additional help for primitives since the
  // prototype is lost between the iframe and main frame.
  if (typeof object === 'string') {
    return global.String.prototype;
  }

  if (typeof object === 'number') {
    return global.Number.prototype;
  }

  if (typeof object === 'boolean') {
    return global.Boolean.prototype;
  }

  return object;
};

/**
 * Returns a flat object of all valid JavaScript literal property names.
 *
 * @param  {Object} obj
 * @param  {Object} global
 * @return {Object}
 */
var getPropertyNames = function (context, global) {
  // Create with a null prototype, otherwise we have issues trying to set the
  // `__proto__` key.
  var props = Object.create(null);
  var obj   = context;

  /**
   * Adds the property to the property names object. Skips any property names
   * that aren't valid JavaScript literals since completion should not display
   * invalid JavaScript suggestions.
   *
   * @param {String} property
   */
  var addProp = function (property) {
    if (!isValidVariableName(property)) { return; }

    var prop = props[property] = {};

    // Checking typeof on the `window` prototype in Firefox 26 causes an error
    // to be thrown: "Illegal operation on WrappedNative prototype object".
    try {
      // Lookup from the current context object to avoid failures in Firefox.
      prop.type = typeof context[property];
    } catch (e) {}

    prop.value = property;
  };

  // Sanitize the object to a type that we can grab keys from. If it still isn't
  // an object after being sanitized, break before we try to get keys.
  if (!_.isObject(obj = mapObject(obj, global))) {
    return props;
  }

  do {
    _.each(global.Object.getOwnPropertyNames(obj), addProp);
  } while (obj = global.Object.getPrototypeOf(obj));

  return props;
};

/**
 * Completes the completion variable suggestions.
 *
 * @param {Object}   data
 * @param {Function} next
 */
middleware.register('completion:variable', function (data, next) {
  var token = data.token;

  // Collect properties from the global environment first.
  _.extend(data.results, getPropertyNames(data.context, data.window));

  // Extend the results with global variables.
  _.extend(data.results, varsToObject(token.state.globalVars));

  // Extend the results with arguments from the local function context.
  _.extend(data.results, varsToObject(token.state.localVars, {
    type: 'argument'
  }));

  // Extend the variables object with each context level
  var context = token.state.context;
  while (context) {
    _.extend(data.results, varsToObject(context.vars));
    context = context.prev;
  }

  // Finally, extend over the top with keywords.
  _.extend(data.results, KEYWORDS);

  // Override the `arguments` definition (but only if we have one).
  if (data.results.arguments) {
    data.results.arguments = {
      type: 'object'
    };
  }

  return next();
});

/**
 * Augments the property completion data with all property names.
 *
 * @param {Object}   data
 * @param {Function} next
 */
middleware.register('completion:property', function (data, next) {
  _.extend(data.results, getPropertyNames(data.context, data.window));
  return next();
});

/**
 * Corrects the completion lookup context. Looks up variables/properties in
 * the global scope and coerces other types detected by CodeMirror (such as
 * strings and numbers) into the correct representation.
 *
 * Important: Needs to use the `global` property when recreating objects so
 * that middleware will continue to get the correct context. Otherwise you
 * will be switching global contexts to the main frame and there will be
 * discrepancies.
 *
 * @param {Object}   data
 * @param {Function} next
 * @param {Function} done
 */
middleware.register('completion:context', function (data, next, done) {
  var token  = data.token;
  var type   = token.type;
  var string = token.string;

  if (type === 'variable') {
    // Check if the current variable is a global or an argument.
    data.context = isInScope(token, string) ? null : data.context[string];
    return done();
  }

  if (type === 'property') {
    data.context = mapObject(data.context, data.window);
    data.context = data.context[string];
    return done();
  }

  if (type === 'array') {
    data.context = new data.window.Array();
    return done();
  }

  if (type === 'string') {
    data.context = data.window.String(string.slice(1, -1));
    return done();
  }

  if (type === 'number') {
    data.context = data.window.Number(string);
    return done();
  }

  if (type === 'string-2') {
    var parts = token.string.split('/');
    data.context = new data.window.RegExp(
      parts[1].replace('\\', '\\\\'), parts[2]
    );
    return done();
  }

  if (type === 'atom') {
    if (string === 'true' || string === 'false') {
      data.context = data.window.Boolean(string);
    } else if (string === 'null') {
      data.context = null;
    } else if (string === 'undefined') {
      data.context = undefined;
    }

    return done();
  }

  data.context = null;
  return done();
});

/**
 * Filter autocompletion suggestions. Checks the given suggestion is actually
 * the start of the current token.
 *
 * @param {Object}   data
 * @param {Function} next
 * @param {Function} done
 */
middleware.register('completion:filter', function (data, next, done) {
  var value  = data.result.value;
  var string = data.token.string;
  var length = value.length >= string.length;

  return done(null, length && value.substr(0, string.length) === string);
});

},{"../../lib/codemirror/is-in-scope":75,"../../state/middleware":109,"underscore":49}],61:[function(require,module,exports){
var _          = require('underscore');
var Backbone   = require('backbone');
var middleware = require('../../state/middleware');
var CodeMirror = require('codemirror');

require('./ui');
require('./ajax');
require('./sandbox');
require('./completion');
require('./result-cell');
require('./persistence');
require('./application');
require('./authentication');

// Trigger middleware for keydown events.
Backbone.$(document).on('keydown', function (e) {
  var keyName = CodeMirror.keyName(e, e.which === 16);

  middleware.trigger('keydown:' + keyName, {
    preventDefault: _.bind(e.preventDefault, e)
  });
});

},{"../../state/middleware":109,"./ajax":53,"./application":54,"./authentication":56,"./completion":60,"./persistence":62,"./result-cell":63,"./sandbox":64,"./ui":65,"backbone":3,"codemirror":22,"underscore":49}],62:[function(require,module,exports){
var _          = require('underscore');
var config     = require('../../state/config');
var middleware = require('../../state/middleware');

var OPEN_CODE_BLOCK     = '```javascript';
var CLOSE_CODE_BLOCK    = '```';
var META_DATA_DELIMITER = '---';

/**
 * Set the default content into the config object.
 */
config.set('defaultContent', [
  OPEN_CODE_BLOCK,
  '',
  CLOSE_CODE_BLOCK
].join('\n'));

/**
 * Serialize the notebook to a string based format.
 *
 * @param {Object}   data
 * @param {Function} next
 * @param {Function} done
 */
middleware.register('persistence:serialize', function (data, next, done) {
  var hasContent = false;

  // Prepend the front matter.
  data.content = [
    META_DATA_DELIMITER,
    _.map(data.meta, function (value, key) {
      return key + ': ' + value;
    }).join('\n'),
    META_DATA_DELIMITER
  ].join('\n');

  // Split the markdown content from the front matter.
  data.content += '\n\n';

  // Appends the notebook content as Markdown.
  data.content += _.chain(data.cells)
    .slice()
    .reverse()
    .filter(function (cell) {
      if (!hasContent && !/^\s*$/.test(cell.value)) {
        hasContent = true;
      }

      return hasContent;
    })
    .reverse()
    .map(function (cell) {
      if (cell.type === 'text') { return cell.value; }
      // Wrap code cells as a JavaScript code block for Markdown
      return [OPEN_CODE_BLOCK, cell.value, CLOSE_CODE_BLOCK].join('\n');
    }).value().join('\n\n');

  return done();
});

/**
 * Desserialize the notebook from a string into an array of cell data.
 *
 * @param {Object}   data
 * @param {Function} next
 * @param {Function} done
 */
middleware.register('persistence:deserialize', function (data, next, done) {
  var preambleRegExp = new RegExp([
    '^',
    META_DATA_DELIMITER,
    '\\n([\\S\\s]+)\\n',
    META_DATA_DELIMITER,
    '\\n'
  ].join(''));

  // Replace potential meta data with nothing and parse it separately.
  var content = data.content.replace(preambleRegExp, function (content, body) {
    // Split each line of the metadata and set on the `data` export object.
    _.each(body.split('\n'), function (meta) {
      var parts = meta.split(': ');

      // Ignore the line if we don't have a `title: data` combination.
      if (parts.length === 2) {
        data.meta[parts[0]] = parts[1];
      }
    });

    return '';
  });

  data.cells = _.chain(content.split('\n')).reduce(function (cells, line) {
    var cell = cells[cells.length - 1];

    // An open code block will return a new code cell.
    if (line === OPEN_CODE_BLOCK) {
      cells.push({
        type:  'code',
        value: ''
      });

      return cells;
    }

    // If we hit a closing code block and we are a code cell, return a fresh
    // text cell.
    if (cell.type === 'code' && line === CLOSE_CODE_BLOCK) {
      cells.push({
        type:  'text',
        value: ''
      });

      return cells;
    }

    // Otherwise we can just append to the cell content and return the cell.
    cell.value += line + '\n';
    return cells;
  }, [{
    type:  'text',
    value: ''
  }]).filter(function (cell, index, notebook) {
    cell.value = cell.value.slice(
      // Text cells will start with a new line.
      cell.type === 'text' && cell.value.charAt(0) === '\n' ? 1  : 0,
      // Text cells will have a trailing new line (if they aren't the last
      // cell in the whole notebook).
      cell.type === 'text' && index !== notebook.length - 1 ? -2 : -1
    );

    // Removes empty text cells.
    return !(cell.type === 'text' && cell.value === '');
  }).value();

  return done();
});

/**
 * Default middleware that loads the initial notebook as a single code cell.
 *
 * @param {Object}   data
 * @param {Function} next
 * @param {Function} done
 */
middleware.register('persistence:load', function (data, next, done) {
  data.id      = null;
  data.content = config.get('defaultContent');

  return done();
});

/**
 * Add a "(cloned)" marker to cloned notebook titles.
 *
 * @param {Object}   data
 * @param {Function} next
 */
middleware.register('persistence:clone', function (data, next) {
  data.meta.title += ' (cloned)';

  return next();
});

/**
 * Update the persistence meta data when we attempt to save.
 */
middleware.register('persistence:save', function (data, next) {
  _.extend(data.meta, {
    site:               config.get('url'),
    apiNotebookVersion: {"name":"api-notebook","version":"1.1.25","description":"Executable JavaScript environment for running API examples.","private":true,"browserify":{"transform":["dombarsify","envify-config"]},"dependencies":{"async":"0.2.9","backbone":"1.1.0","backbone.native":"1.0.0","change-case":"1.0.6","codemirror":"4.1.0","config":"0.4.33","css-component":"0.0.2","domify":"1.2.1","es6-collections":"0.2.0","escape-regexp":"0.0.1","foreach":"2.0.4","kamino":"git://github.com/tildeio/kamino.js#v0.0.2","load-script":"0.0.2","marked":"0.3.0","mime-component":"0.0.1","normalize-css":"2.3.0","qs":"0.6.6","raml-parser":"0.8.7","store":"1.3.14","underscore":"1.6.0","uritemplate":"0.3.4"},"devDependencies":{"brfs":"~0.2.1","browserify":"3.28.0","chai":"~1.9.0","dombars":"~0.5.2","dombarsify":"~0.0.3","envify-config":"~0.0.1","grunt":"~0.4.2","grunt-browserify":"~1.3.0","grunt-cli":"~0.1.11","grunt-contrib-clean":"~0.5.0","grunt-contrib-connect":"~0.6.0","grunt-contrib-copy":"~0.5.0","grunt-contrib-jshint":"~0.8.0","grunt-contrib-stylus":"~0.12.0","grunt-contrib-watch":"~0.5.3","grunt-newer":"~0.6.0","grunt-shell":"~0.7.0","load-grunt-tasks":"~0.3.0","mocha":"~1.17.1","mocha-phantomjs":"~3.3.0","request":"~2.34.0","sinon":"~1.7.3","sinon-chai":"~2.5.0","uglifyify":"~1.2.1"},"scripts":{"build":"./node_modules/.bin/grunt build","test":"./node_modules/.bin/grunt test","start":"node server"},"repository":{"type":"git","url":"git://github.com/mulesoft/api-notebook.git"},"bugs":{"url":"https://github.com/mulesoft/api-notebook/issues"},"author":"Formidable Labs","license":"BSD","readmeFilename":"README.md"}.version
  });

  return next();
});

},{"../../state/config":107,"../../state/middleware":109,"underscore":49}],63:[function(require,module,exports){
var _              = require('underscore');
var typeOf         = require('../../lib/type');
var Inspector      = require('../../views/inspector');
var ErrorInspector = require('../../views/error-inspector');
var middleware     = require('../../state/middleware');

/**
 * Render the result cell contents.
 *
 * @param  {Object}   data
 * @param  {Function} next
 * @param  {Function} done
 */
middleware.register('result:render', function (data, next, done) {
  var options = {
    window:  data.window,
    inspect: data.inspect
  };

  var inspector;

  if (!data.isError) {
    inspector = new Inspector(options);
  } else {
    inspector = new ErrorInspector(options);
  }

  inspector.render().appendTo(data.el);

  // Opens the inspector automatically when the type is an object.
  var type = typeOf(data.inspect);

  if (type === 'object' || type === 'array') {
    inspector.open();
  }

  return done(null, _.bind(inspector.remove, inspector));
});

},{"../../lib/type":102,"../../state/middleware":109,"../../views/error-inspector":119,"../../views/inspector":120,"underscore":49}],64:[function(require,module,exports){
(function (process){
var loadScript = require('../../lib/browser/load-script');
var middleware = require('../../state/middleware');

var ASYNC_TIMEOUT = 2000;
var PROXY_URL     = {}.proxy && {}.proxy.url;

/**
 * Set the some additional context variables.
 *
 * @param {Object}   context
 * @param {Function} next
 */
middleware.register('sandbox:context', function (context, next) {
  // Unfortunately it isn't as easy as this since we have scoping issues with
  // the wrong window object. It would load the script in the wrong window.
  context.load    = function (/* src, done */) {};
  context.async   = function () {};
  context.timeout = function () {};

  return next();
});

/**
 * Sets up the pre-execution plugin.
 *
 * @param {Object}   data
 * @param {Function} next
 * @param {Function} done
 */
middleware.register('sandbox:execute', function (data, next, done) {
  /* global App */
  var code    = 'with (window.console._notebookApi) {\n' + data.code + '\n}';
  var async   = false;
  var exec    = {};
  var context = data.context;
  var fallback;

  // Provides additional context under the `console` object. This works in the
  // same fashion as how Chrome's console is implemented, and has the benefit
  // of any context variables not wiping out `window` variables (they will
  // just be shadowed using `with`).
  data.window.console = data.window.console || {};
  data.window.console._notebookApi = context;

  /**
   * Completed code cell execution and removes left over content.
   *
   * @param {Error}  err
   * @param {Object} data
   */
  var complete = function (err, response) {
    window.clearTimeout(fallback);
    delete App._executeWindow;
    delete App._executeContext;
    delete data.window.console._notebookApi;
    return done(err, response);
  };

  /**
   * Pass in a timeout function that can be used to reset the async timer.
   *
   * @param {Number} ms
   */
  var timeout = context.timeout = function (ms) {
    var timeout = +ms;

    // Clears the old timeout before setting the new one.
    window.clearTimeout(fallback);

    // Break immediately if the timeout is an unknown number.
    if (isNaN(timeout) || timeout < 0) {
      return complete(new Error('Cannot use timeout of ' + ms + 'ms'));
    }

    // Add a fallback catch in case we are using the `async` function accidently
    // or not handling some edge case. This idea comes from `Mocha` async tests,
    // but we change the timeout by using `timeout = Infinity`.
    if (isFinite(timeout)) {
      fallback = window.setTimeout(function () {
        return complete(
          new Error('Timeout of ' + timeout + 'ms exceeded'), exec
        );
      }, timeout);
    }
  };

  /**
   * Call the async function within a code cell to trigger async mode. It will
   * return a function that should be used to end the async execution.
   *
   * @return {Function}
   */
  context.async = function () {
    // Sets the async flag to true so we don't trigger the callback immediately.
    async = true;

    // Return a function that can be executed to end the async operation inside
    // the cell. This is handy for all sorts of things, like ajax requests.
    return function (err, result) {
      // Passes iteration off to the middleware since it already caters for
      // async execution like this. This function accepts two parameters, like
      // a normal async callback, but instead off passing it directly off to
      // `done`, we need to transform it into the data format the result
      // cell understands and pass `null` as the error since we don't have an
      // execution error in this context (it came from the sandbox).
      exec.result  = err || result;
      exec.isError = !!err;
      return complete(null, exec);
    };
  };

  /* jshint evil: true */
  data.window.eval([
    'console._notebookApi.load = function (src, done) {',
    '  console._notebookApi.timeout(Infinity);', // Increase AJAX timeout.
    '  if (!/^https?:\\/\\//.test(src)) {',
    '    src = ' + (PROXY_URL ? '"' + PROXY_URL + '/" + ' : '') + 'src',
    '  }',
    '  return (' + loadScript + ')(src, done || console._notebookApi.async());',
    '};'
  ].join('\n'));

  // Uses an asynchronous callback to clear the any possible stack trace
  // that would include implementation logic.
  process.nextTick(function () {
    App._executeWindow  = data.window;
    App._executeContext = context;

    // Sets up the initial timeout.
    timeout(ASYNC_TIMEOUT);

    try {
      /* jshint evil: true */
      exec.result  = data.window.eval(code);
      exec.isError = false;
    } catch (error) {
      exec.result  = error;
      exec.isError = true;
    } finally {
      // If the execution is not asynchronous or an error has been thrown,
      // trigger completion of the cell execution.
      if (!async || exec.isError) {
        return complete(null, exec);
      }
    }
  });
});

}).call(this,require("/Users/blakeembrey/Projects/api-notebook/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"../../lib/browser/load-script":72,"../../state/middleware":109,"/Users/blakeembrey/Projects/api-notebook/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":10}],65:[function(require,module,exports){
var _          = require('underscore');
var domify     = require('domify');
var Backbone   = require('backbone');
var middleware = require('../../state/middleware');

/**
 * Generate the HTML for a modal popup.
 *
 * @type {Function}
 */
var template = _.template([
  '<div class="modal" tabindex="-1">',
  '<div class="modal-dialog">',
  '<div class="modal-content">',
  '<% if (title) { %>',
  '<div class="modal-header">',
  '<button class="modal-close" data-dismiss>&times;</button>',
  '<h4 class="modal-title"><%- title %></h4>',
  '</div>',
  '<% } %>',
  '<div class="modal-body">',
  '<%= content %>',
  '</div>',
  '</div>',
  '</div>',
  '</div>'
].join('\n'));

/**
 * Simple middleware handler for opening modal windows. It should proceed to
 * the next function in the execution stack when the modal window is closed.
 *
 * @param {Object}   options
 * @param {Function} next
 * @param {Function} done
 */
middleware.register('ui:modal', function (options, next, done) {
  // Allow asynchronous template loads based on content type and number of
  // function arguments.
  var async = false;
  var templateOptions = {
    title:   options.title,
    content: options.content
  };

  // Check if content is a function. If it is, just execute it or put the modal
  // into async mode.
  if (_.isFunction(options.content)) {
    if (!options.content.length) {
      templateOptions.content = options.content();
    } else {
      async = true;
      templateOptions.content = [
        '<div class="text-center">',
        '<i class="icon-arrows-cw animate-spin"></i>',
        '</div>'
      ].join('\n');
    }
  }

  // Render the modal with a close function.
  var modal = {
    el: domify(template(templateOptions)),
    close: function (err) {
      modal.closed = true;
      middleware.deregister('keydown:Esc', escMiddleware);
      document.body.removeChild(modal.el);
      document.body.classList.remove('modal-visible');
      return done(err);
    },
    closed: false
  };

  // Hook into the esc key and remove the modal.
  var escMiddleware = function (event, next, done) {
    modal.close();
    return done();
  };

  // Trigger the async function callback and render the modal body.
  if (async) {
    options.content(function (err, content) {
      if (err) {
        modal.close();
        return done(err);
      }

      modal.el.querySelector('.modal-body').innerHTML = content;
    });
  }

  document.body.appendChild(modal.el);
  document.body.classList.add('modal-visible');

  // Focus the current modal to make tabbing easier.
  modal.el.focus();

  middleware.register('keydown:Esc', escMiddleware);
  Backbone.$(modal.el)
    .on('click', function (e) {
      if (e.target !== modal.el) { return; }

      return modal.close();
    })
    .on('click', '[data-dismiss]', _.bind(modal.close, null, null));

  // Execute the after render function which can be used to attach more
  // functionality to the modal.
  return _.isFunction(options.show) && options.show(modal);
});

/**
 * Extends the modal middleware for providing a confirmation dialog window.
 *
 * @param {Object}   data
 * @param {Function} next
 * @param {Function} done
 */
middleware.register('ui:confirm', function (data, next, done) {
  var confirmed = false;

  return middleware.trigger('ui:modal', {
    title: data.title,
    content: data.content,
    show: function (modal) {
      Backbone.$(modal.el).on('click', '[data-confirm]', function () {
        confirmed = true;
        return modal.close();
      });

      modal.el.querySelector('.modal-body').appendChild(domify(
        '<div class="btn-list text-center">' +
        '<button class="btn btn-secondary" data-dismiss>Cancel</button>' +
        '<button class="btn btn-primary" data-confirm>OK</button>' +
        '</div>'
      ));

      modal.el.querySelector('[data-confirm]').focus();
    }
  }, function (err) {
    return done(err, confirmed);
  });
});

/**
 * Notify the user of something.
 *
 * @param {Object}   data
 * @param {Function} next
 */
middleware.register('ui:notify', function (data, next) {
  var title = '';

  if (data.title) {
    title = [
      '<p class="modal-headline">',
      '<strong>' + _.escape(data.title) + '</strong>',
      '</p>'
    ].join('\n');
  }

  return middleware.trigger('ui:modal', {
    content: [
      title + '<p>' + _.escape(data.message) + '</p>',
      '<div class="text-center">',
      '<button class="btn btn-primary" data-dismiss>OK</button>',
      '</div>'
    ].join('\n'),
    show: function (modal) {
      modal.el.className += ' modal-notify';
      modal.el.querySelector('.btn').focus();
    }
  }, next);
});

},{"../../state/middleware":109,"backbone":3,"domify":43,"underscore":49}],66:[function(require,module,exports){
var _        = require('underscore');
var Backbone = require('backbone');

/**
 * Holds all the notebook cell contents.
 *
 * @return {Object}
 */
var Notebook = module.exports = Backbone.Collection.extend({
  model: require('../models/cell'),
  comparator: function (model) {
    if (!model.view || !model.view.el.parentNode) { return this.length; }
    // Sorting the collection based on positions in the DOM
    return _.indexOf(model.view.el.parentNode.childNodes, model.view.el);
  }
});

/**
 * Return the next model in the collection.
 *
 * @param  {Object} model
 * @return {Object}
 */
Notebook.prototype.getNext = function (model) {
  var index = this.indexOf(model);
  // Catch not found indexes, where adding one would result in the first model.
  return index > -1 ? this.at(index + 1) : undefined;
};

/**
 * Return the previous model in the collection.
 *
 * @param  {Object} model
 * @return {Object}
 */
Notebook.prototype.getPrev = function (model) {
  return this.at(this.indexOf(model) - 1);
};

/**
 * Return the next code cell in the collection.
 *
 * @param  {Object} model
 * @return {Object}
 */
Notebook.prototype.getNextCode = function (model) {
  while (model = this.getNext(model)) {
    if (model.get('type') === 'code') {
      return model;
    }
  }
};

/**
 * Return the previous code cell in the collection.
 *
 * @param  {Object} model
 * @return {Object}
 */
Notebook.prototype.getPrevCode = function (model) {
  while (model = this.getPrev(model)) {
    if (model.get('type') === 'code') {
      return model;
    }
  }
};

/**
 * Get the index of the model iterating over only code cells.
 *
 * @param  {Object} model
 * @return {Number}
 */
Notebook.prototype.codeIndexOf = function (model) {
  return _.indexOf(this.filter(function (model) {
    return model.get('type') === 'code';
  }), model);
};

},{"../models/cell":103,"backbone":3,"underscore":49}],67:[function(require,module,exports){
var Backbone = require('backbone');

/**
 * A Backbone Collection designed to keep track of all notebooks, allowing
 * us to hit the network as infrequently as possible.
 *
 * @type {Function}
 */
var PersistenceItems = module.exports = Backbone.Collection.extend({
  model: require('../models/persistence-item')
});

/**
 * Here we register to have Backbone keep this collection sorted for us.
 *
 * @param  {PersistenceItem} a
 * @param  {PersistenceItem} b
 * @return {Number}
 */
PersistenceItems.prototype.comparator = function (a, b) {
  return +a.get('updatedAt') > +b.get('updatedAt') ? -1 : 1;
};

},{"../models/persistence-item":106,"backbone":3}],68:[function(require,module,exports){
(function (process){
require('./bootstrap');

/**
 * The main application is aliased to the `window` for external access.
 *
 * @type {Function}
 */
var App = module.exports = window.App = {};

App.Library = {
  qs:         require('qs'),
  url:        require('url'),
  async:      require('async'),
  domify:     require('domify'),
  marked:     require('marked'),
  Backbone:   require('backbone'),
  DOMBars:    require('./lib/dombars'),
  changeCase: require('change-case')
};

App._        = App.Library._ = require('underscore');
App.nextTick = process.nextTick;

// Exposes configuration details globally
App.state       = require('./state/state');
App.store       = require('./state/store');
App.config      = require('./state/config');
App.messages    = require('./state/messages');
App.middleware  = require('./state/middleware');
App.persistence = require('./state/persistence');
App.Sandbox     = require('./lib/sandbox');
App.PostMessage = require('./lib/post-message');


// Exposes CodeMirror to the world with our custom mods.
App.CodeMirror = {
  Editor:            require('codemirror'),
  Completion:        require('./lib/completion'),
  sandboxCompletion: require('./lib/sandbox-completion')
};

// Expose all application views.
App.View = {
  App:            require('./views/app'),
  View:           require('./views/view'),
  Notebook:       require('./views/notebook'),
  EditNotebook:   require('./views/edit-notebook'),
  Inspector:      require('./views/inspector'),
  ErrorInspector: require('./views/error-inspector'),
  CodeCell:       require('./views/code-cell'),
  TextCell:       require('./views/text-cell'),
  EditorCell:     require('./views/editor-cell'),
  ResultCell:     require('./views/result-cell'),
  CellButtons:    require('./views/cell-buttons'),
  CellControls:   require('./views/cell-controls')
};

// Expose application models.
App.Model = {
  Cell:     require('./models/cell'),
  Meta:     require('./models/meta'),
  Notebook: require('./models/notebook')
};

// Expose application collections.
App.Collection = {
  Cells: require('./collections/cells')
};

/**
 * Define a custom start method so that the application can bind middleware and
 * prepare state before we actually append the notebook which relies on some of
 * the middleware being available.
 *
 * @param {Function|Element} el
 * @param {Object}           [config]
 * @param {Function}         done
 */
App.start = function (el /*, options */, done) {
  var options = {};

  if (typeof done === 'object') {
    options = arguments[1];
    done    = arguments[2];
  }

  return App.middleware.trigger('application:start', options, function (err) {
    if (err) {
      return done && done(err);
    }

    var app = new App.View.App().render().appendTo(el);

    // Send a `rendered` event back to the parent frame when we are embedded.
    if (App.postMessage) {
      App.postMessage.trigger('rendered');
    }

    return App.middleware.trigger('application:ready', app, done);
  });
};

}).call(this,require("/Users/blakeembrey/Projects/api-notebook/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"./bootstrap":52,"./collections/cells":66,"./lib/completion":85,"./lib/dombars":93,"./lib/post-message":96,"./lib/sandbox":100,"./lib/sandbox-completion":99,"./models/cell":103,"./models/meta":104,"./models/notebook":105,"./state/config":107,"./state/messages":108,"./state/middleware":109,"./state/persistence":110,"./state/state":111,"./state/store":112,"./views/app":113,"./views/cell-buttons":114,"./views/cell-controls":115,"./views/code-cell":116,"./views/edit-notebook":117,"./views/editor-cell":118,"./views/error-inspector":119,"./views/inspector":120,"./views/notebook":123,"./views/result-cell":124,"./views/text-cell":127,"./views/view":128,"/Users/blakeembrey/Projects/api-notebook/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":10,"async":1,"backbone":3,"change-case":19,"codemirror":22,"domify":43,"marked":46,"qs":47,"underscore":49,"url":18}],69:[function(require,module,exports){
/**
 * Execute a function and return it back directly after execution.
 *
 * @param  {Function} fn
 * @return {Function}
 */
module.exports = function (fn, context) {
  return fn.call(context), fn;
};

},{}],70:[function(require,module,exports){
exports.mac = /Mac/.test(navigator.platform);

},{}],71:[function(require,module,exports){
/**
 * Inserts a DOM node after another node.
 *
 * @param  {Node} el
 * @param  {Node} before
 * @return {Node}
 */
module.exports = function (el, before) {
  return before.parentNode.insertBefore(el, before.nextSibling);
};

},{}],72:[function(require,module,exports){
/**
 * Loads a script into the document. All functionality must be inlined since
 * it will be evaled into the sandbox context.
 *
 * @param  {String}   src
 * @param  {Function} done
 * @return {Node}
 */
module.exports = function (src, done) {
  var head   = document.head || document.getElementsByTagName('head')[0];
  var script = document.createElement('script');

  script.src     = src;
  script.async   = true;
  script.type    = 'text/javascript';
  script.charset = 'utf8';

  if (done) {
    // If there is no `onload` property to listen to, fall back to listening to
    // state changes in IE.
    if ('onload' in script) {
      script.onload = function () {
        this.onerror = this.onload = null;
        return done();
      };

      script.onerror = function () {
        this.onerror = this.onload = null;
        return done(new Error('Failed to load ' + src));
      };
    } else {
      script.onreadystatechange = function () {
        if (this.readyState !== 'complete') { return; }
        this.onreadystatechange = null;
        // There is no way to catch load errors in IE8.
        return done();
      };
    }
  }

  return head.appendChild(script);
};

},{}],73:[function(require,module,exports){
var _          = require('underscore');
var getToken   = require('./get-token');
var CodeMirror = require('codemirror');

/**
 * Grabs and corrects the grabbed token. Useful really only for sanitising a
 * `.` as a property. This helps when we need to do completion on the initial
 * `.` that is types.
 *
 * @param  {CodeMirror} cm
 * @param  {Object}     pos
 * @return {Object}
 */
module.exports = function (cm, pos) {
  var token = getToken(cm, pos);

  token.state = CodeMirror.innerMode(cm.getMode(), token.state).state;

  if (token.string === '.') {
    _.extend(token, {
      start:  token.end,
      end:    token.end,
      string: '',
      type:   'property'
    });

    // Increment token position.
    token.pos.ch = token.start;
  }

  return token;
};

},{"./get-token":74,"codemirror":22,"underscore":49}],74:[function(require,module,exports){
var _ = require('underscore');

/**
 * Returns the token at a given position. Augments the token object with
 * the token start position.
 *
 * @param  {CodeMirror}     cm
 * @param  {CodeMirror.Pos} pos
 * @return {Object}
 */
module.exports = function (cm, pos) {
  var token = cm.getTokenAt(pos);

  // Extend the base token with its position in the editor. This is essential to
  // recursively traverse DOM tokens.
  _.extend(token, {
    pos: _.extend({}, pos, {
      ch: token.start
    })
  });

  return token;
};

},{"underscore":49}],75:[function(require,module,exports){
var varsHasValue = require('./vars-has-value');

/**
 * Check if a value is in the token scope.
 *
 * @param  {Object}  token
 * @param  {String}  value
 * @return {Boolean}
 */
module.exports = function (token, value) {
  var context    = token.state.context;
  var localVars  = token.state.localVars;
  var globalVars = token.state.globalVars;

  if (varsHasValue(localVars, value) || varsHasValue(globalVars, value)) {
    return true;
  }

  while (context) {
    if (varsHasValue(context.vars, value)) {
      return true;
    }

    context = context.prev;
  }

  return false;
};

},{"./vars-has-value":79}],76:[function(require,module,exports){
var _            = require('underscore');
var getToken     = require('./get-token');
var middleware   = require('../../state/middleware');
var tokenHelpers = require('./token-helpers');

/**
 * An map of possible function types.
 *
 * @type {Object}
 */
var FUNCTION_TYPES = {
  variable: true,
  property: true
};

/**
 * Collect data for displaying a tooltip. Passes an falsy value to the callback
 * to represent no data available to display.
 *
 * @param  {CodeMirror} cm
 * @param  {Object}     options
 * @param  {Function}   done
 */
module.exports = function (cm, options, done) {
  // Don't show the tooltip when we have have data selected.
  if (cm.doc.somethingSelected()) {
    return done();
  }

  var cur   = cm.getCursor();
  var token = getToken(cm, cur);
  var bracket;

  while (token) {
    bracket = tokenHelpers.getPrevBracket(cm, token);
    token   = bracket && tokenHelpers.eatEmptyAndMove(cm, bracket);

    if (!token || FUNCTION_TYPES[token.type]) {
      break;
    }
  }

  if (!token) {
    return done();
  }

  return tokenHelpers.getProperty(cm, token, options, function (err, data) {
    if (err || !_.isFunction(data.context)) {
      return done(err);
    }

    // When the context is a function, retrieve the relevant documentation.
    middleware.trigger('completion:describe', data, function (err, describe) {
      return done(err, _.extend(data, {
        description: describe,
        to:          cur,
        token:       bracket,
        from:        bracket.pos
      }));
    }, true);
  });
};

},{"../../state/middleware":109,"./get-token":74,"./token-helpers":78,"underscore":49}],77:[function(require,module,exports){
var _            = require('underscore');
var Pos          = require('codemirror').Pos;
var middleware   = require('../../state/middleware');
var tokenHelpers = require('./token-helpers');
var correctToken = require('./correct-token');

/**
 * Proxy the return objects for the property and variable middleware and turn
 * it into something actionable for the widget display.
 *
 * @param  {Function} done
 * @return {Function}
 */
var completeResults = function (done) {
  return function (err, data) {
    // Sorts the keys and maps to an object that the widget can understand.
    var results = _.map(_.keys(data.results), function (key) {
      if (!_.isObject(data.results[key])) {
        return {
          title: key,
          value: key
        };
      }

      return {
        title: key,
        type:  data.results[key].type,
        value: data.results[key].value || key
      };
    }).sort(function (a, b) {
      return a.title > b.title ? 1 : -1;
    });

    return done(err, {
      context: data.context,
      results: results
    });
  };
};

/**
 * Complete variable completion suggestions.
 *
 * @param  {CodeMirror} cm
 * @param  {Object}     token
 * @param  {Object}     options
 * @param  {Function}   done
 */
var completeVariable = function (cm, token, options, done) {
  // Trigger the completion middleware to run
  middleware.trigger('completion:variable', _.extend({
    token:   token,
    editor:  cm,
    context: options.window,
    results: {}
  }, options), completeResults(done));
};

/**
 * Provides completion suggestions for a property.
 *
 * @param  {CodeMirror} cm
 * @param  {Object}     token
 * @param  {Object}     options
 * @param  {Function}   done
 */
var completeProperty = function (cm, token, options, done) {
  tokenHelpers.getPropertyObject(cm, token, options, function (err, data) {
    middleware.trigger('completion:property', _.extend({
      results: {}
    }, data), completeResults(done));
  });
};

/**
 * Trigger the completion module by passing in the current CodeMirror instance.
 *
 * @param  {CodeMirror} cm
 * @param  {Object}     options
 * @param  {Function}   done
 */
module.exports = function (cm, options, done) {
  var cur   = cm.getCursor();
  var token = correctToken(cm, cur);
  var type  = token.type;

  var cb = function (err, completion) {
    completion = completion || {};

    return done(err, {
      token:   token,
      context: completion.context,
      results: completion.results,
      to:      new Pos(cur.line, token.end),
      from:    new Pos(cur.line, token.start)
    });
  };

  if (type === 'keyword' || type === 'variable') {
    return completeVariable(cm, token, options, cb);
  }

  if (type === 'property') {
    return completeProperty(cm, token, options, cb);
  }

  return done();
};

},{"../../state/middleware":109,"./correct-token":73,"./token-helpers":78,"codemirror":22,"underscore":49}],78:[function(require,module,exports){
var _          = require('underscore');
var async      = require('async');
var getToken   = require('./get-token');
var middleware = require('../../state/middleware');

/**
 * Check whether the token is a possible accessor token (can read a result).
 *
 * @param  {Object}  token
 * @return {Boolean}
 */
var canAccess = function (token) {
  if (!_.contains([null, 'keyword', 'invalid', 'comment'], token.type)) {
    return true;
  }

  return token.type === null && _.contains([')', ']'], token.string);
};

/**
 * Returns the closest previous opening bracket token to the passed in token.
 *
 * @param  {CodeMirror} cm
 * @param  {Object}     token
 * @return {Object}
 */
exports.getPrevBracket = function (cm, token) {
  var level = 0;

  do {
    if (token.string === '(') {
      if (level === 0) {
        return token;
      }

      level--;
    } else if (token.string === ')') {
      level++;
    }
  } while (token = exports.getPrevToken(cm, token));

  return token;
};

/**
 * Resolves tokens properly before use.
 *
 * @param {CodeMirror} cm
 * @param {Array}      tokens
 * @param {Object}     options
 * @param {Function}   done
 */
exports.resolveTokens = function (cm, tokens, options, done) {
  async.map(tokens, function (token, cb) {
    // Dynamic property calculations are run inline before we resolve the whole
    // object.
    if (token.type === 'dynamic-property') {
      return exports.propertyLookup(
        cm,
        token.tokens,
        options,
        function (err, data) {
          if (err) {  return cb(err); }

          var string;

          try {
            string = '' + data.context;
          } catch (e) {
            return cb(new Error('Property resolution is impossible'));
          }

          // Remove the tokens lookup array.
          delete token.tokens;

          // Returns a valid token for the rest of the resolution.
          return cb(err, _.extend(token, {
            type:   'property',
            string: string
          }));
        }
      );
    }

    return cb(null, token);
  }, done);
};

/**
 * Run property lookup middleware. *Please note: This assumes resolved tokens.*
 *
 * @param {CodeMirror} cm
 * @param {Array}      tokens
 * @param {Object}     options
 * @param {Function}   done
 */
var doPropertyLookup = function (cm, tokens, options, done) {
  var prevContext = options.context;

  middleware.trigger('completion:context', _.extend({
    token:   tokens.pop(),
    context: options.window,
    editor:  cm
  }, options), function again (err, data) {
    var token = data.token;

    // Break the context lookup.
    if (err) { return done(err, null); }

    // Update the parent context property.
    data.parent = prevContext;

    // Function context lookups occur after the property lookup.
    if (token && token.isFunction) {
      // Check that the property is also a function, otherwise we should
      // skip it and leave it up to the user to work out.
      if (!_.isFunction(data.context)) {
        data.token   = null;
        data.context = null;
        return again(err, data);
      }

      return middleware.trigger('completion:function', _.extend({
        name:          token.string,
        isConstructor: !!token.isConstructor
      }, data), function (err, context) {
        data.token   = tokens.pop();
        data.context = prevContext = context;

        // Immediately invoked functions should skip the context processing
        // step. It's also possible that this token was the last to process.
        if (data.token && data.token.type !== 'immed') {
          return middleware.trigger('completion:context', data, again);
        }

        return again(err, data);
      }, true);
    }

    if (tokens.length && data.context != null) {
      data.token  = tokens.pop();
      prevContext = data.context;
      return middleware.trigger('completion:context', data, again);
    }

    return done(null, data);
  });
};

/**
 * Resolve the property lookup tokens.
 *
 * @param {CodeMirror} cm
 * @param {Array}      tokens
 * @param {Object}     options
 * @param {Function}   done
 */
exports.propertyLookup = function (cm, tokens, options, done) {
  // No tokens exist, which means we are doing a lookup at the global level.
  if (!tokens.length) {
    return done(new Error('Completion not available for object properties'));
  }

  var invalid = _.some(tokens, function (token) {
    return token.type === 'invalid';
  });

  // If any invalid tokens exist, fail completion.
  if (invalid) {
    return done(new Error('Completion is not possible'));
  }

  // Run the property lookup functionality.
  exports.resolveTokens(cm, tokens, options, function (err, tokens) {
    if (err) { return done(err); }

    return doPropertyLookup(cm, tokens, options, done);
  });
};

/**
 * Verifies whether a given token is whitespace or not.
 *
 * @param  {Object}  token
 * @return {Boolean}
 */
exports.isWhitespaceToken = function (token) {
  return token.type === null && /^\s*$/.test(token.string);
};

/**
 * Retrieve the previous token in the editor, taking into account new lines.
 *
 * @param  {CodeMirror} cm
 * @param  {Object}     token
 * @return {Object}
 */
exports.getPrevToken = function (cm, token) {
  // Get the last token of the previous line. If we are at the beginning of the
  // editor already, return `null`.
  if (token.pos.ch === 0) {
    if (token.pos.line > 0) {
      return getToken(cm, {
        ch:   Infinity,
        line: token.pos.line - 1
      });
    } else {
      return null;
    }
  }

  return getToken(cm, token.pos);
};

/**
 * Check if the token is empty (not useful to parsing).
 *
 * @param  {Object}  token
 * @return {Boolean}
 */
exports.isEmptyToken = function (token) {
  return exports.isWhitespaceToken(token) || token.type === 'comment';
};

/**
 * Returns the current token position, removing potential whitespace tokens.
 *
 * @param  {CodeMirror} cm
 * @param  {Object}     token
 * @return {Object}
 */
exports.eatEmpty = function (cm, token) {
  while (token && exports.isEmptyToken(token)) {
    token = exports.getPrevToken(cm, token);
  }

  return token;
};

/**
 * Similar to `eatEmpty`, but also takes moves the current token position.
 *
 * @param  {CodeMirror} cm
 * @param  {Object}     token
 * @return {Object}
 */
exports.eatEmptyAndMove = function (cm, token) {
  // No token, break.
  if (!token) { return token; }

  return exports.eatEmpty(cm, exports.getPrevToken(cm, token));
};

/**
 * Gets the property context for completing a property by looping through each
 * of the context tokens. Provides some additional help by moving primitives to
 * their prototype objects so it can continue autocompletion.
 *
 * @param {CodeMirror} cm
 * @param {Object}     token
 * @param {Object}     options
 * @param {Function}   done
 */
exports.getPropertyObject = function (cm, token, options, done) {
  // Defer to the `getProperty` function.
  return exports.getProperty(
    cm, exports.eatEmptyAndMove(cm, token), options, done
  );
};

/**
 * Get the exact value of a token.
 *
 * @param {CodeMirror} cm
 * @param {Object}     token
 * @param {Object}     options
 * @param {Function}   done
 */
exports.getProperty = function (cm, token, options, done) {
  return exports.propertyLookup(
    cm, exports.getPropertyPath(cm, token), options, done
  );
};

/**
 * Get the full property path to a property token.
 *
 * @param  {CodeMirror} cm
 * @param  {Object}     token
 * @return {Array}
 */
exports.getPropertyPath = function (cm, token) {
  var context = [];

  /**
   * Mix in to with a token indicate an invalid/unexpected token.
   *
   * @type {Object}
   */
  var invalidToken = {
    type: 'invalid',
    string: null
  };

  /**
   * Eats the current token and any whitespace.
   *
   * @param  {Object} token
   * @return {Object}
   */
  var eatToken = function (token) {
    return exports.eatEmptyAndMove(cm, token);
  };

  /**
   * Resolves regular property notation.
   *
   * @param  {Object} token
   * @return {Object}
   */
  var resolveToken = function (token) {
    context.push(token);
    return eatToken(token);
  };

  /**
   * Resolves square bracket notation.
   *
   * @param  {Object} token
   * @return {Object}
   */
  var resolveDynamicProperty = function (token) {
    var level = 1;
    var prev  = token;

    while (level > 0 && (token = exports.getPrevToken(cm, token))) {
      if (token.string === ']') {
        level++;
      } else if (token.string === '[') {
        level--;
      }
    }

    // Keep track of the open token to confirm the location in the bracket
    // resolution.
    var startToken = token;
    token = eatToken(token);

    // Resolve the contents of the brackets as a text string.
    var string = cm.doc.getRange({
      ch:   startToken.start,
      line: startToken.pos.line
    }, {
      ch:   prev.end,
      line: prev.pos.line
    });

    // Only kick into bracket notation mode when the preceding token is a
    // property, variable, string, etc. Only things you can't use it on are
    // `undefined` and `null` (and syntax, of course).
    if (token && canAccess(token)) {
      if (eatToken(prev).string === '[') {
        context.push(_.extend(token, invalidToken));
        return token;
      }

      var subContext = exports.getPropertyPath(cm, eatToken(prev));
      var startPos   = eatToken(subContext[subContext.length - 1]).start;

      // Ensures that the only tokens being resolved can be done statically.
      if (startPos === startToken.start) {
        context.push(_.extend(prev, {
          start:  subContext[subContext.length - 1].start,
          end:    subContext[0].end,
          string: string,
          tokens: subContext,
          state:  prev.state,
          type:   'dynamic-property'
        }));
      } else {
        context.push(_.extend(token, invalidToken));
      }

      return token;
    }

    if (!token || token.type === null) {
      context.push({
        start:  startToken.start,
        end:    prev.end,
        string: string,
        state:  prev.state,
        type:   'array'
      });
    }

    return token;
  };

  /**
   * Resolves the closing parenthesis to a possible function or context change.
   *
   * @param  {[type]} token [description]
   * @return {[type]}       [description]
   */
  var resolvePossibleFunction = function (token) {
    var level = 1;
    var prev  = token;

    // While still in parens *and not at the beginning of the editor*
    while (level > 0 && (token = exports.getPrevToken(cm, token))) {
      if (token.string === ')') {
        level++;
      } else if (token.string === '(') {
        level--;
      }
    }

    // No support for resolving across multiple lines.. yet.
    if (level > 0) {
      context.push(_.extend(token || {}, invalidToken));
      return token;
    }

    token = eatToken(token);

    // Resolves as a function argument.
    if (token && canAccess(token)) {
      // If the previous token was a function (E.g. the closing paren) it must
      // be an immediately invoked property.
      if (prev.isFunction) {
        context.push(_.extend(prev, {
          type:       'immed',
          string:     null,
          isFunction: true
        }));
      }

      token.isFunction = true;
      return token;
    }

    // Set `token` to be the token inside the parens and start working from
    // that instead.
    if (!token || token.type === null) {
      var subContext = exports.getPropertyPath(cm, eatToken(prev));

      // The context could be being invoked as a function.
      if (prev.isFunction && subContext.length) {
        subContext[0].isFunction = true;
      }

      // Ensure that the subcontext has correctly set the `new` flag.
      if (subContext.hasNew && subContext.length) {
        subContext[0].isFunction    = true;
        subContext[0].isConstructor = true;
      }

      context.push.apply(context, subContext);
      return false;
    }

    return eatToken(token);
  };

  while (token && (token.string === '.' || canAccess(token))) {
    // Skip over period notation.
    if (token.type === null && token.string === '.') {
      token = eatToken(token);
    }

    // Special case variable tokens since we don't want the context to continue
    // completing after we hit the beginning of the chain.
    if (token.type === 'variable') {
      token = resolveToken(token);
      break;
    }

    // Attempt to resolve a dynmaic property or array literal.
    if (token.string === ']') {
      token = resolveDynamicProperty(token);
      continue;
    }

    // Attempt to resolve a function invokation, simply using parenthesis to
    // enclose a property/variable, using the parenthesis with `new`, etc.
    if (token.string === ')') {
      token = resolvePossibleFunction(token);
      continue;
    }

    // Resolve any other property that allows access as normal.
    if (canAccess(token)) {
      token = resolveToken(token);
      continue;
    }

    // If we made it to this point, the token is invalid.
    token = _.extend(token, invalidToken);
    context.push(token);
    break;
  }

  // Using the new keyword doesn't actually require parens to invoke, so we need
  // to do a quick special case check here.
  if (token && token.type === 'keyword' && token.string === 'new') {
    context.hasNew = true;

    // Try to set the first function to be the constructor function. The
    // context array is in reverse, so we need to iterate accordingly.
    var length = context.length;

    while (length--) {
      // Remove the global context `hasNew` flag and set the found function
      // to be a constructor.
      if (context[length].isFunction) {
        delete context.hasNew;
        context[length].isConstructor = true;

        // Break before setting any other context properties.
        break;
      }
    }
  }

  return context;
};

},{"../../state/middleware":109,"./get-token":74,"async":1,"underscore":49}],79:[function(require,module,exports){
/**
 * Check if the scope chain contains a specific value.
 *
 * @param  {Object}  scope
 * @param  {String}  value
 * @return {Boolean}
 */
module.exports = function (scope, value) {
  while (scope) {
    if (scope.name === value) {
      return true;
    }

    scope = scope.next;
  }

  return false;
};

},{}],80:[function(require,module,exports){
var _            = require('underscore');
var getToken     = require('../codemirror/get-token');
var tokenHelpers = require('../codemirror/token-helpers');
var messages     = require('../../state/messages');
var formatDocs   = require('./format-documentation');

/**
 * An map of possible function types.
 *
 * @type {Object}
 */
var FUNCTION_TYPES = {
  variable: true,
  property: true
};

/**
 * Check if a token is before another token.
 *
 * @param  {Object}  pos
 * @param  {Object}  before
 * @return {Boolean}
 */
var isTokenBefore = function (pos, before) {
  if (pos.line < before.line) {
    return true;
  }

  if (pos.line === before.line && pos.ch < before.ch) {
    return true;
  }

  return false;
};

/**
 * Render a new argument documentation.
 *
 * @param  {Completion}   completion
 * @param  {Object}       data
 * @return {ArgumentDocs}
 */
var ArgumentDocs = module.exports = function (completion, data) {
  this.data       = data;
  this.completion = completion;

  var params        = this.params = [];
  var cm            = this.completion.cm;
  var curLine       = this.curLine = cm.getCursor().line;
  var documentation = this.documentation = document.createElement('div');
  var type          = data.description['!type'];
  var result        = data.description['!return'];
  var title         = documentation.appendChild(document.createElement('div'));

  title.className         = 'CodeMirror-documentation-title';
  documentation.className = 'CodeMirror-documentation';

  // Get the function name as the variable preceding the opening bracket.
  var fnName = this.fnName = tokenHelpers.eatEmpty(
    cm, getToken(cm, this.data.from)
  ).string;

  // Append a text node with the correct token string.
  title.appendChild(document.createTextNode(fnName + '('));

  _.each(/^fn\((.*)\)/.exec(type)[1].split(', '), function (arg, index, args) {
    var param = document.createElement('span');
    param.appendChild(document.createTextNode(arg));

    params.push(param);
    title.appendChild(param);

    if (index < args.length - 1) {
      title.appendChild(document.createTextNode(', '));
    }
  });

  title.appendChild(document.createTextNode(')'));

  if (result) {
    title.appendChild(document.createTextNode(' -> ' + result));
  }

  // Append a static container for documentation.
  this.description = documentation.appendChild(document.createElement('div'));
  this.description.className = 'CodeMirror-documentation-description';

  // Attach the widget below the current line.
  this.widget = cm.addLineWidget(curLine, documentation);

  this.update();
};

/**
 * Show the documentation for a specific argument.
 *
 * @param {Number} index
 */
ArgumentDocs.prototype.select = function (index) {
  var prefix   = 'CodeMirror-documentation-description-';
  var argument = this.data.description['!args'][index];
  var cm       = this.completion.cm;
  var curLine  = cm.getCursor().line;

  // Make it follow the selected line.
  if (curLine !== this.curLine) {
    this.removeWidget();
    this.widget  = cm.addLineWidget(curLine, this.documentation);
    this.curLine = curLine;
  }

  // Avoiding reselecting the same argument.
  if (this.currentArgument === index) { return; }

  // Set the correct argument to active.
  _.each(this.params, function (param, position) {
    param.classList[index === position ? 'add' : 'remove'](
      'CodeMirror-documentation-argument-active'
    );
  });

  // Empty the description element before appending new docs.
  this.description.innerHTML = '';
  this.currentArgument       = index;

  if (!argument) {
    this.widget.changed();
    return messages.trigger('resize');
  }

  // Map the documentation to the description rendering.
  var docs = _.object(_.map(formatDocs(argument), function (docs, type) {
    if (type === 'url') {
      docs = '<a href="' + docs + '" target="_blank">Read more</a>';
    }

    return [type, '<div class="' + prefix + type + '">' + docs + '</div>'];
  }));

  this.description.innerHTML += docs.type || '';
  this.description.innerHTML += docs.doc  || '';
  this.description.innerHTML += docs.url  || '';

  this.widget.changed();
  return messages.trigger('resize');
};

/**
 * Update the argument documentation position.
 */
ArgumentDocs.prototype.update = function () {
  var cm = this.completion.cm;

  // Remove the documentation when multiple characters are selected.
  if (cm.doc.somethingSelected()) {
    return this.remove();
  }

  var cur        = this.data.to = cm.getCursor();
  var from       = this.data.from;
  var token      = getToken(cm, cur);
  var index      = 0;
  var curCount   = 0;
  var roundLevel = 0;
  var curlyLevel = 0;

  // Remove the documentation if we are stating before the opening bracket.
  if (isTokenBefore(token.pos, from)) {
    return this.remove();
  }

  // Iterate over every new block and track our argument index. If we hit
  // a new function inside the current arguments, remove the current widget.
  while (!isTokenBefore(token.pos, from)) {
    if (token.type === null) {
      if (token.string === '(') {
        roundLevel++;

        // If we have a resolved round level, it would have just completed
        // bracket notation which can contain commas.
        if (roundLevel > -1) {
          // Make sure we don't reset on the real opening bracket.
          if (!(token.pos.ch === from.ch && token.pos.line === from.line)) {
            index -= curCount;
            curCount = 0;
          }
        }

        // Check if the previous token is a function type.
        var prev  = tokenHelpers.eatEmptyAndMove(cm, token);
        var match = token.start === from.ch && token.pos.line === from.line;

        if (roundLevel > 0 && FUNCTION_TYPES[prev.type] && !match) {
          return this.remove();
        }
      } else if (token.string === ')') {
        roundLevel--;

        if (roundLevel < -1) {
          index -= curCount;
          curCount = 0;
        } else if (roundLevel === -1) {
          curCount = 0;
        }
      } else if (token.string === '{') {
        curlyLevel++;

        if (curlyLevel > -1) {
          index -= curCount;
          curCount = 0;
        }
      } else if (token.string === '}') {
        curlyLevel--;

        if (curlyLevel < -1) {
          index -= curCount;
          curCount = 0;
        } else if (curlyLevel === -1) {
          curCount = 0;
        }
      } else if (token.string === ',') {
        index++;
        curCount++;
      }
    }

    token = tokenHelpers.eatEmptyAndMove(cm, token);
  }

  // If there is no block level, we are no longer inside the arguments.
  if (roundLevel < 1) {
    return this.remove();
  }

  this.select(index);
};

/**
 * Remove the widget from the editor.
 */
ArgumentDocs.prototype.removeWidget = function () {
  if (this.widget) {
    this.widget.clear();
    messages.trigger('resize');
    delete this.widget;
  }
};

/**
 * Remove the argument documentation from the editor.
 */
ArgumentDocs.prototype.remove = function () {
  this.removeWidget();
  delete this.documentation;
  delete this.completion.documentation;
};

},{"../../state/messages":108,"../codemirror/get-token":74,"../codemirror/token-helpers":78,"./format-documentation":81,"underscore":49}],81:[function(require,module,exports){
var marked = require('marked');

/**
 * Format the standard description object for rendering in the browser.
 *
 * @param  {Object} description
 * @param  {String} variable
 * @return {Object}
 */
module.exports = function (description, variable) {
  var formatted = {};

  if (description['!doc']) {
    formatted.doc = marked(description['!doc'], {
      gfm: true,
      tables: true,
      sanitize: true,
      smartLists: true
    });
  }

  if (description['!url']) {
    formatted.url = description['!url'];
  }

  if (description['!type']) {
    formatted.type = description['!type'];

    if (variable && /^fn\(/.test(formatted.type)) {
      formatted.type = variable + formatted.type.substr(2);
    }
  }

  return formatted;
};

},{"marked":46}],82:[function(require,module,exports){
var _        = require('underscore');
var Backbone = require('backbone');

/**
 * Generates a ghost text widget that is used to render Chrome-style completion.
 *
 * @param  {Object} widget
 * @param  {Object} data
 * @param  {String} text
 * @return {Ghost}
 */
var Ghost = module.exports = function (widget, result) {
  this.cm     = widget.completion.cm;
  this.result = result;
  this.widget = widget;

  var that      = this;
  var text      = '';
  var data      = widget.data;
  var substring = this.result.value.substr(0, data.to.ch - data.from.ch);

  if (substring === data.token.string) {
    text = this.result.value.substr(data.to.ch - data.from.ch);
  }

  // Don't create the ghost element if there is no text to display. It makes
  // for a janky UI where keys are blocked thanks to the ghost shortcuts.
  if (!text) { return; }

  this.cm.addKeyMap(this.keyMap = {
    'Tab':   function () { that.accept(); },
    'Right': function () { that.accept(); }
  });

  // Creates the ghost element to be styled.
  var ghostHint = document.createElement('span');
  ghostHint.className = 'CodeMirror-hint-ghost';
  ghostHint.appendChild(document.createTextNode(text));

  // Abuse the bookmark feature of CodeMirror to achieve the desired completion
  // effect without modifying source code.
  this.ghost = this.cm.setBookmark(data.to, {
    widget:     ghostHint,
    insertLeft: true
  });
};

/**
 * Extend the ghost with events.
 */
_.extend(Ghost.prototype, Backbone.Events);

/**
 * Accept the display ghost text.
 */
Ghost.prototype.accept = function () {
  this.trigger('accept', this.result);
};

/**
 * Remove the ghost suggestion.
 */
Ghost.prototype.remove = function () {
  if (this.ghost) {
    this.ghost.clear();
  }

  if (this.keyMap) {
    this.cm.removeKeyMap(this.keyMap);
  }

  delete this.text;
  delete this.ghost;
  delete this.widget.ghost;
};

},{"backbone":3,"underscore":49}],83:[function(require,module,exports){
var _        = require('underscore');
var Backbone = require('backbone');
var state    = require('../../state/state');
var format   = require('./format-documentation');

/**
 * Create a floating documentation widget next to the current hint widget.
 *
 * @constructor
 * @param  {Hints}    hints
 * @param  {Object}   description
 * @return {HintDocs}
 */
var HintDocs = module.exports = function (hints, description) {
  this.hints = hints;

  var prefix  = 'CodeMirror-hint-documentation-';
  var fnName  = hints.results[hints.currentHint].value;
  var tooltip = this.tooltip = document.createElement('div');

  // Map the documentation to the tooltip rendering.
  var docs = _.object(_.map(format(description, fnName), function (docs, type) {
    if (type === 'url') {
      docs = '<a href="' + docs + '" target="_blank">Read more</a>';
    }

    return [type, '<div class="' + prefix + type + '">' + docs + '</div>'];
  }));

  tooltip.className = 'CodeMirror-hint-documentation';
  tooltip.setAttribute('data-overflow-scroll', 'true');

  // Append each part of the documentation.
  tooltip.innerHTML += docs.type || '';
  tooltip.innerHTML += docs.doc  || '';
  tooltip.innerHTML += docs.url  || '';

  document.body.appendChild(tooltip);

  this.reposition();
  this.listenTo(hints, 'reposition', this.reposition, this);
};

/**
 * Extend the documentation tooltip with events.
 */
_.extend(HintDocs.prototype, Backbone.Events);

/**
 * Reposition the documentation tooltip beside the hints menu.
 */
HintDocs.prototype.reposition = function () {
  var hints     = this.hints.hints;
  var box       = hints.getBoundingClientRect();
  var tooltip   = this.tooltip;
  var margin    = parseInt(window.getComputedStyle(tooltip).marginTop, 10);
  var winWidth  = state.get('viewportWidth');
  var docHeight = state.get('documentHeight');

  tooltip.style.top    = hints.offsetTop - margin + 'px';
  tooltip.style.left   = box.right + 'px';
  tooltip.style.right  = 'auto';
  tooltip.style.bottom = 'auto';

  if (winWidth - box.right < box.left) {
    tooltip.style.left  = 'auto';
    tooltip.style.right = winWidth - box.left + 'px';
  }

  if (hints.className.indexOf('CodeMirror-hints-top') > -1) {
    var bottom = docHeight - window.scrollY - box.bottom - margin;

    tooltip.style.top    = 'auto';
    tooltip.style.bottom = bottom + 'px';
  }

  this.trigger('reposition');
};

/**
 * Remove the hint documentation from the DOM.
 */
HintDocs.prototype.remove = function () {
  this.stopListening();
  document.body.removeChild(this.tooltip);
  delete this.tooltip;
  delete this.hints.documentation;
};

},{"../../state/state":111,"./format-documentation":81,"backbone":3,"underscore":49}],84:[function(require,module,exports){
var _          = require('underscore');
var Backbone   = require('backbone');
var state      = require('../../state/state');
var middleware = require('../../state/middleware');
var HintDocs   = require('./hint-documentation');

/**
 * Create a hints popover.
 *
 * @param  {Widget} widget
 * @param  {Array}  results
 * @return {Hints}
 */
var Hints = module.exports = function (widget, results) {
  var that  = this;
  var cm    = this.cm    = widget.completion.cm;
  var hints = this.hints = document.createElement('ul');
  var data  = this.data  = widget.data;
  var text  = cm.getRange(data.from, data.to);

  this.widget = widget;

  _.each(this.results = results, function (result, index) {
    var el     = hints.appendChild(document.createElement('li'));
    var hintEl = document.createElement('span');
    var indexOf;

    el.hintId        = index;
    el.className     = 'CodeMirror-hint';
    hintEl.className = 'CodeMirror-hint-text';

    if ((indexOf = result.title.indexOf(text)) > -1) {
      var prefix  = result.title.substr(0, indexOf);
      var match   = result.title.substr(indexOf, text.length);
      var suffix  = result.title.substr(indexOf + text.length);
      var matchEl = document.createElement('span');

      matchEl.className   = 'CodeMirror-hint-match';
      matchEl.textContent = match;

      hintEl.appendChild(document.createTextNode(prefix));
      hintEl.appendChild(matchEl);
      hintEl.appendChild(document.createTextNode(suffix));
    } else {
      hintEl.textContent = result.title;
    }

    el.appendChild(hintEl);

    if (result.type) {
      var typeEl = document.createElement('span');
      typeEl.className   = 'CodeMirror-hint-type';
      typeEl.textContent = result.type;

      el.appendChild(typeEl);
    }
  });

  hints.className = 'CodeMirror-hints';
  hints.setAttribute('data-overflow-scroll', 'true');
  document.body.appendChild(hints);

  cm.addKeyMap(this.keyMap = {
    'Up':     function () { that.select(that.currentHint - 1); },
    'Down':   function () { that.select(that.currentHint + 1); },
    'Home':   function () { that.select(0); },
    'End':    function () { that.select(-1); },
    'Enter':  function () { that.accept(that.currentHint); },
    'PageUp': function () {
      that.select(that.currentHint - that.screenAmount(), true);
    },
    'PageDown': function () {
      that.select(that.currentHint + that.screenAmount(), true);
    }
  });

  Backbone.$(hints)
    .on('click', 'li', function (e, target) {
      if (isNaN(target.hintId)) {
        return;
      }

      that.accept(target.hintId);
    })
    .on('mousedown', function () {
      window.setTimeout(function () { cm.focus(); }, 20);
    });

  this.listenTo(state, 'change:viewportWidth',  this.reposition);
  this.listenTo(state, 'change:viewportHeight', this.reposition);
  this.listenTo(state, 'change:documentWidth',  this.reposition);
  this.listenTo(state, 'change:documentHeight', this.reposition);

  this.select(0);
  this.reposition();
};

/**
 * Inherit events from Backbone.
 */
_.extend(Hints.prototype, Backbone.Events);

/**
 * Accept a hint result.
 *
 * @param {Number} index
 */
Hints.prototype.accept = function (index) {
  this.trigger('accept', this.results[index]);
};

/**
 * Select a hint option.
 *
 * @param {Number}  index
 * @param {Boolean} noWrap
 */
Hints.prototype.select = function (index, noWrap) {
  var that  = this;
  var data  = this.data;
  var total = this.hints.childNodes.length;

  // Convert the index to the closest number usable number.
  index = index % total;

  // Avoid wrapping around the menu.
  if (noWrap && (index < 0 || index > total)) {
    return;
  }

  // When we have a negative number, we need to subtract it from the bottom
  // of the hints menu. This gives us the looping around effect.
  if (index < 0) {
    index = total + index;
  }

  // Avoid resetting the currently selected hint.
  if (this.currentHint === index) {
    return;
  }

  // Remove the old active hint if we have a selected hint id.
  if (!isNaN(this.currentHint)) {
    this.removeDocumentation();

    var old = this.hints.childNodes[this.currentHint];
    old.className = old.className.replace(' CodeMirror-hint-active', '');
  }

  // Add the class to the new active hint
  var node = this.hints.childNodes[this.currentHint = index];
  node.className += ' CodeMirror-hint-active';

  var result = this.results[this.currentHint];

  this.trigger('select', result);

  if (node.offsetTop < this.hints.scrollTop) {
    this.hints.scrollTop = node.offsetTop - 3;
  } else {
    var totalOffset = node.offsetTop + node.offsetHeight;
    if (totalOffset > this.hints.scrollTop + this.hints.clientHeight) {
      this.hints.scrollTop = totalOffset - this.hints.clientHeight + 3;
    }
  }

  middleware.trigger(
    'completion:describe',
    _.extend({}, this.widget.completion.options, {
      parent: data.context,
      context: null,
      token: _.extend({}, data.token, {
        string: result.value
      })
    }),
    function (err, describe) {
      // Avoid attaching obscure documentation.
      if (err || !describe || (!describe['!type'] && !describe['!doc'])) {
        return;
      }

      that.documentation = new HintDocs(that, describe);
    },
    true
  );
};

/**
 * Update the hint positioning.
 */
Hints.prototype.reposition = function () {
  var cm      = this.cm;
  var pos     = cm.cursorCoords(this.data.from, 'window');
  var hints   = this.hints;
  var margin  = parseInt(window.getComputedStyle(hints).marginTop, 10);
  var scrollY = window.scrollY;
  var scrollX = window.scrollX;

  hints.className    = hints.className.replace(' CodeMirror-hints-top', '');
  hints.style.top    = scrollY + pos.bottom - margin + 'px';
  hints.style.left   = scrollX + pos.left - margin + 'px';
  hints.style.right  = 'auto';
  hints.style.bottom = 'auto';
  hints.style.width  = 'auto';
  hints.style.height = 'auto';

  var box       = hints.getBoundingClientRect();
  var winWidth  = state.get('viewportWidth');
  var winHeight = state.get('viewportHeight');
  var docWidth  = state.get('documentWidth');
  var docHeight = state.get('documentHeight');
  var height    = box.bottom - box.top;

  if (pos.top > winHeight - pos.bottom - margin) {
    hints.className += ' CodeMirror-hints-top';

    if (height + margin > pos.top) {
      hints.style.height = pos.top - margin + 'px';
    }

    hints.style.top    = 'auto';
    hints.style.bottom = docHeight - pos.top - scrollY - margin + 'px';
  } else if (height + margin > winHeight - pos.bottom) {
    hints.style.height = winHeight - pos.bottom - margin + 'px';
  }

  if (box.right + margin > winWidth) {
    hints.style.left  = 'auto';
    hints.style.right = docWidth - scrollX - winWidth + 'px';
  }

  this.trigger('reposition');
};

/**
 * Return the number of hints the current menu is displaying.
 *
 * @return {Number}
 */
Hints.prototype.screenAmount = function () {
  var amount = this.hints.clientHeight / this.hints.firstChild.offsetHeight;
  return Math.max(Math.floor(amount), 1);
};

/**
 * Remove the documentation widget from the DOM.
 */
Hints.prototype.removeDocumentation = function () {
  if (this.documentation) {
    this.documentation.remove();
  }
};

/**
 * Remove the hints menu.
 */
Hints.prototype.remove = function () {
  this.removeDocumentation();
  this.stopListening();
  this.cm.removeKeyMap(this.keyMap);
  document.body.removeChild(this.hints);
  delete this.hints;
  delete this.keyMap;
  delete this.widget.hints;
};

},{"../../state/middleware":109,"../../state/state":111,"./hint-documentation":83,"backbone":3,"underscore":49}],85:[function(require,module,exports){
var Widget         = require('./widget');
var ArgumentDocs   = require('./argument-documentation');
var loadArguments  = require('../codemirror/sandbox-arguments');
var loadCompletion = require('../codemirror/sandbox-completion');

var CLOSE_REGEXP = /[^$_a-zA-Z0-9]/;

/**
 * Create a completion instance for a CodeMirror editor.
 *
 * @constructor
 * @param  {CodeMirror} cm
 * @param  {Object}     options
 * @return {Completion}
 */
var Completion = module.exports = function (cm, options) {
  var that          = this;
  var closeOnCursor = true;
  var closeOnBlur;

  this.cm      = cm;
  this.options = options || {};

  this.cm.state.completionActive = this;

  /**
   * Close the currently open widget when we exit the editor.
   */
  this.onBlur = function () {
    closeOnBlur = window.setTimeout(function () {
      that.removeWidget();
      that.removeArgumentDocumentation();
    }, 20);
  };

  /**
   * On editor focus, we clear the current blur timeout.
   */
  this.onFocus = function () {
    // Timeout documentation display to avoid incorrect cursor positioning.
    setTimeout(function () {
      if (!that.documentation) {
        that.showArgumentDocumentation();
      }
    }, 10);

    window.clearTimeout(closeOnBlur);
  };

  /**
   * Change events are where all the action happens.
   * @param  {CodeMirror} cm
   * @param  {Object}     event
   */
  this.onChange = function (cm, event) {
    closeOnCursor = false;

    // Only update the display when we are inserting or deleting characters
    if (!event.origin || event.origin.charAt(0) !== '+') {
      return that.removeWidget();
    }

    var remove  = event.origin === '+delete';
    var text    = event[remove ? 'removed' : 'text'].join('\n');
    var line    = cm.getLine(event.from.line);
    var curPos  = event.from.ch + (remove ? -1 : 0);
    var curChar = line.charAt(curPos);

    // Checks whether any of the characters are a close character. If they are,
    // close the widget and remove from the DOM. However, we should also close
    // the widget when there is no previous character.
    if (!curChar || CLOSE_REGEXP.test(curChar) || CLOSE_REGEXP.test(text)) {
      that.removeWidget();
    } else if (curPos > 0 && CLOSE_REGEXP.test(line.charAt(curPos - 1))) {
      that.removeWidget();
    }

    var nextChar = line.charAt(curPos + 1);

    // If completion is currently active, trigger a refresh event (filter the
    // current suggestions using updated character position information).
    // Otherwise, we need to show a fresh widget.
    if (that.widget) {
      that.widget.update();
    } else if (!nextChar || CLOSE_REGEXP.test(nextChar)) {
      that.showWidget();
    }
  };

  /**
   * Cursor activity should close the widget, except for when the activity is
   * actually the result of some text input.
   *
   * @param  {CodeMirror} cm
   */
  this.onCursorActivity = function (cm) {
    // Cursor activity is getting triggered when we don't have focus.
    if (!cm.hasFocus() || cm.getOption('readOnly')) { return; }

    // If we already have active documentation visible, trigger an update. The
    // documentation may decide it's no longer relevant and remove itself.
    if (that.documentation) {
      that.documentation.update();
    }

    // If there is currently no documentation rendered, attempt to display it.
    if (!that.documentation) {
      that.showArgumentDocumentation();
    }

    // Destroy the completion widget when we move the cursor away from the
    // current typing position. It's not relevant where it moved to since it'll
    // be invalid either way.
    if (closeOnCursor) {
      return that.removeWidget();
    }

    closeOnCursor = true;
  };

  this.cm.on('blur',           this.onBlur);
  this.cm.on('focus',          this.onFocus);
  this.cm.on('change',         this.onChange);
  this.cm.on('cursorActivity', this.onCursorActivity);
};

/**
 * Show a scrollable completion widget.
 */
Completion.prototype.showWidget = function () {
  var that = this;

  loadCompletion(this.cm, this.options, function (err, data) {
    that.removeWidget();

    return data && (that.widget = new Widget(that, data));
  });
};

/**
 * Removes the currently display widget.
 */
Completion.prototype.removeWidget = function () {
  return this.widget && this.widget.remove();
};

/**
 * Show an overlay tooltip with relevant documentation.
 */
Completion.prototype.showArgumentDocumentation = function () {
  var that = this;

  loadArguments(this.cm, this.options, function (err, data) {
    that.removeArgumentDocumentation();

    return data && (that.documentation = new ArgumentDocs(that, data));
  });
};

/**
 * Remove the overlay toolip.
 */
Completion.prototype.removeArgumentDocumentation = function () {
  return this.documentation && this.documentation.remove();
};

/**
 * Remove the completion widget.
 */
Completion.prototype.remove = function () {
  this.removeWidget();
  this.removeArgumentDocumentation();
  delete this.cm.state.completionActive;
  this.cm.off('blur',           this.onBlur);
  this.cm.off('focus',          this.onFocus);
  this.cm.off('change',         this.onChange);
  this.cm.off('cursorActivity', this.onCursorActivity);
};

},{"../codemirror/sandbox-arguments":76,"../codemirror/sandbox-completion":77,"./argument-documentation":80,"./widget":86}],86:[function(require,module,exports){
var _            = require('underscore');
var async        = require('async');
var Backbone     = require('backbone');
var Hints        = require('./hints');
var Ghost        = require('./ghost');
var middleware   = require('../../state/middleware');
var CodeMirror   = require('codemirror');
var correctToken = require('../codemirror/correct-token');

/**
 * Render a completion widget.
 *
 * @param  {Completion} completion
 * @param  {Object}     data
 * @return {Widget}
 */
var Widget = module.exports = function (completion, data) {
  var that = this;

  this.data       = data;
  this.completion = completion;

  CodeMirror.signal(completion.cm, 'startCompletion', completion.cm);

  completion.cm.addKeyMap(this.keyMap = {
    'Esc': function () { that.remove(); }
  });

  this.update();
};

/**
 * Extend the widget prototype with events.
 */
_.extend(Widget.prototype, Backbone.Events);

/**
 * Update the completion menu.
 */
Widget.prototype.update = function () {
  if (!this.data.results) { return; }

  var that    = this;
  var cm      = this.completion.cm;
  var results = this.data.results;

  this.removeHints();
  this.removeGhost();

  // Update the data positions.
  this.data.to    = cm.getCursor();
  this.data.token = correctToken(cm, this.data.to);

  async.filter(results, _.bind(this.filter, this), function (results) {
    that.removeHints();
    that.removeGhost();
    CodeMirror.signal(cm, 'refreshCompletion', cm, results);

    // Avoid rendering the hints menu when there is nothing to display.
    if (results.length < 2) {
      return results.length === 1 ? that.select(results[0]) : false;
    }

    that.hints = new Hints(that, results);

    that.select(results[0]);
    that.listenTo(that.hints, 'accept', that.accept, that);
    that.listenTo(that.hints, 'select', that.select, that);
  });
};

/**
 * Accepts a result as the completion result.
 *
 * @param {Object} result
 */
Widget.prototype.accept = function (result) {
  this.completion.cm.replaceRange(result.value, this.data.from, this.data.to);
  this.remove();
};

/**
 * Select a result from the hints menu to display.
 *
 * @param {Object} result
 */
Widget.prototype.select = function (result) {
  this.removeGhost();
  this.ghost = new Ghost(this, result);
  this.listenTo(this.ghost, 'accept', this.accept);
};

/**
 * Check whether a result should be filtered from the display.
 *
 * @param {String}   result
 * @param {Function} done
 */
Widget.prototype.filter = function (result, done) {
  middleware.trigger('completion:filter', {
    token:   this.data.token,
    result:  result,
    context: this.data.context
  }, function (err, filter) {
    if (err) {
      throw err;
    }

    return done(filter);
  });
};

/**
 * Remove the hints menu from the editor.
 */
Widget.prototype.removeHints = function () {
  if (this.hints) {
    this.stopListening(this.hints);
    this.hints.remove();
  }
};

/**
 * Remove the current ghost from the display.
 */
Widget.prototype.removeGhost = function () {
  if (this.ghost) {
    this.stopListening(this.ghost);
    this.ghost.remove();
  }
};

/**
 * Remove the current widget from the editor.
 */
Widget.prototype.remove = function () {
  this.removeHints();
  this.removeGhost();

  this.completion.cm.removeKeyMap(this.keyMap);

  delete this.keyMap;
  delete this.completion.widget;
  CodeMirror.signal(this.completion.cm, 'endCompletion', this.completion.cm);
};

},{"../../state/middleware":109,"../codemirror/correct-token":73,"./ghost":82,"./hints":84,"async":1,"backbone":3,"codemirror":22,"underscore":49}],87:[function(require,module,exports){
var _     = require('underscore');
var isMac = require('../lib/browser/about').mac;

exports.code   = [];
exports.text   = [];
exports.editor = [];

// Used for mapping key names to their fancier visual output.
var keyMap = {
  'Up':   '',
  'Down': ''
};

// Additional keymap for Mac users.
if (isMac) {
  keyMap.Alt = 'Opt';
}

/**
 * Join a number of keyboard arguments together.
 *
 * @param  {String} ...
 * @return {String}
 */
var join = function (keys) {
  return keys.join('-');
};

/**
 * Join a number of keyboard arguments together, passing it through a key
 * formatter for cleaner output.
 *
 * @param  {String} ...
 * @return {String}
 */
var format = function (keys) {
  return _.map(keys, function (key) {
    return (key in keyMap ? keyMap[key] : key);
  }).join('-');
};

/**
 * Augments a basic options map to be fully compatible with the output.
 *
 * @param  {Object} options
 * @return {Object}
 */
var define = function (options) {
  var defined = {};

  defined.label       = options.label;
  defined.shortcut    = options.shortcut;
  defined.command     = options.command;
  defined.description = options.description;

  if (options.keyMap) {
    defined.keyMap =  join(options.keyMap);
    defined.keyCode = format(options.keyMap);
  }

  return defined;
};

/**
 * Define a shortcut for editor cells.
 *
 * @param {Object} options
 */
var defineEditorShortcut = function (options) {
  exports.editor.push(define(options));
};

/**
 * Define a shortcut for code cells.
 *
 * @param {Object} options
 */
var defineCodeShortcut = function (options) {
  exports.code.push(define(options));
};

defineEditorShortcut({
  label: 'Move Up',
  command: 'moveUp',
  keyMap: [isMac ? 'Cmd' : 'Ctrl', 'Alt', 'Up'],
  description: 'Move cell up one position'
});

defineEditorShortcut({
  label: 'Move Down',
  command: 'moveDown',
  keyMap: [isMac ? 'Cmd' : 'Ctrl', 'Alt', 'Down'],
  description: 'Move cell down one position'
});

defineEditorShortcut({
  label: 'Switch Mode',
  command: 'switch',
  keyMap: [isMac ? 'Cmd' : 'Ctrl', 'Alt', 'B'],
  description: 'Change cell type (text/code)'
});

defineEditorShortcut({
  label: 'Make Copy',
  command: 'clone',
  keyMap: ['Ctrl', 'Alt', 'C'],
  description: 'Copy cell'
});

defineEditorShortcut({
  label: 'Delete',
  command: 'delete',
  keyMap: [isMac ? 'Cmd' : 'Ctrl', 'Backspace'],
  description: 'Delete cell'
});

defineEditorShortcut({
  label: 'New Cell',
  command: 'appendNew',
  keyMap: ['Ctrl', 'Alt', 'N'],
  description: 'Append a new code cell'
});

defineEditorShortcut({
  label: 'New Line Below',
  command: 'newLineBelow',
  keyMap: [isMac ? 'Cmd' : 'Ctrl', 'Enter'],
  description: 'Insert a new line below the current line'
});

defineEditorShortcut({
  label: 'Toggle Comment',
  command: 'toggleComment',
  keyMap: [isMac ? 'Cmd' : 'Ctrl', '/'],
  description: 'Toggle comments on the current line'
});

defineEditorShortcut({
  label: 'Browse Up',
  command: 'browseUp',
  keyMap: ['Up'],
  description: 'Natigate up to the previous line'
});

defineEditorShortcut({
  label: 'Browse Down',
  command: 'browseDown',
  keyMap: ['Down'],
  description: 'Navigate down to the next line'
});

defineCodeShortcut({
  label: 'Execute',
  command: 'execute',
  keyMap: ['Enter'],
  description: 'Execute the code cell contents'
});

defineCodeShortcut({
  label: 'New Line',
  command: 'newLine',
  keyMap: ['Shift', 'Enter'],
  description: 'Insert a new line'
});

},{"../lib/browser/about":70,"underscore":49}],88:[function(require,module,exports){
var _ = require('underscore');

/**
 * Convert a DOM element into a Backbone listener compatible object.
 *
 * @param  {Element} el
 * @return {Object}
 */
module.exports = function (el) {
  var listeners = [];

  var listener = {
    on: function (event, fn, context) {
      var cb = _.bind(fn, context);

      if (el) {
        el.addEventListener(event, cb, false);
      }

      listeners.push({
        event:   event,
        fn:      fn,
        cb:      cb,
        context: context
      });
    },
    once: function (event, fn, context) {
      var cb = function () {
        listener.off(event, cb, context);
        return fn.apply(context, arguments);
      };

      return listener.on(event, cb, context);
    },
    off: function (event, fn, context) {
      listeners = _.filter(listeners, function (listener) {
        var fns      = (!fn      || fn      === listener.fn);
        var events   = (!event   || event   === listener.event);
        var contexts = (!context || context === listener.context);

        // Check each of the arguments match and remove the listener.
        if (fns && events && contexts) {
          if (el) {
            el.removeEventListener(listener.event, listener.cb);
          }

          return true;
        }
      });
    }
  };

  return listener;
};

},{"underscore":49}],89:[function(require,module,exports){
var _       = require('underscore');
var DOMBars = require('dombars/runtime');

/**
 * Render a Backbone collection inside a DOMBars views.
 *
 * @param  {Object} collection
 * @param  {Object} options
 * @return {Node}
 */
DOMBars.registerHelper('collection', function (collection, options) {
  var element   = DOMBars.Utils.trackNode();
  var templates = {};

  if (!collection || arguments.length < 2) {
    return element;
  }

  /**
   * Render a model using the helper function. Cache the rendered child nodes
   * and returned fragment for removal.
   *
   * @param  {Object} model
   * @return {Node}
   */
  var render = function (model) {
    var child = templates[model.cid] = options.fn(model);

    // Wrap the node value in a tracking node.
    return child.value = DOMBars.Utils.trackNode(child.value);
  };

  /**
   * Append a new model directly to the current element.
   *
   * @param {Object} model
   */
  var add = function (model) {
    element.appendChild(render(model).fragment);
  };

  /**
   * Sort DOM nodes by removing from the DOM and re-adding in sorted order.
   */
  var sort = function () {
    _.each(templates, function (template) {
      return template.value.remove();
    });

    collection.each(function (model) {
      element.appendChild(templates[model.cid].value.fragment);
    });
  };

  /**
   * Destroy a template from existence.
   *
   * @param {String} cid
   */
  var destroy = function (cid) {
    templates[cid].unsubscribe();
    templates[cid].value.remove();
    delete templates[cid];
  };

  /**
   * Remove nodes from the DOM.
   *
   * @param {Object} model
   */
  var remove = function (model) {
    return destroy(model.cid);
  };

  /**
   * Remove all DOM nodes from the DOM.
   *
   * @return {[type]} [description]
   */
  var reset = function () {
    _.each(templates, function (template, key) {
      return destroy(key);
    });
  };

  options.unsubscribe(function () {
    collection.off('add',    add);
    collection.off('sort',   sort);
    collection.off('reset',  reset);
    collection.off('remove', remove);
  });

  collection.on('add',    add);
  collection.on('sort',   sort);
  collection.on('reset',  reset);
  collection.on('remove', remove);

  collection.each(add);

  return element.fragment;
});

},{"dombars/runtime":42,"underscore":49}],90:[function(require,module,exports){
var DOMBars = require('dombars/runtime');

/**
 * Check whether all values in an array are equal.
 *
 * @param  {Array}   array
 * @return {Boolean}
 */
var isEqual = function (array) {
  for (var i = 1; i < array.length; i++) {
    if (array[0] !== array[i]) {
      return false;
    }
  }

  return true;
};

/**
 * Register as the equal helper.
 *
 * @return {*}
 */
DOMBars.registerHelper('equal', function (/* ...args, options */) {
  var args    = Array.prototype.slice.call(arguments);
  var options = args.pop();

  if (!options.fn) {
    return isEqual(args);
  }

  if (isEqual(args)) {
    return options.fn(this).value;
  }

  return options.inverse(this).value;
});

/**
 * Register the opposite not equal functionality.
 *
 * @return {*}
 */
DOMBars.registerHelper('unlessEqual', function (/* ...args, options */) {
  var options = arguments[arguments.length - 1];

  var args = Array.prototype.slice.call(arguments, 0, -1).concat({
    fn:      options.inverse,
    inverse: options.fn,
    hash:    options.hash
  });

  return DOMBars.helpers.equal.apply(this, args);
});

},{"dombars/runtime":42}],91:[function(require,module,exports){
var _         = require('underscore');
var DOMBars   = require('dombars/runtime');
var hbsIf     = DOMBars.helpers.if;
var hbsUnless = DOMBars.helpers.unless;

/**
 * Overload the Handlebars if helper to accept multiple arguments.
 */
DOMBars.registerHelper('if', function (/* ...args, options */) {
  var args    = Array.prototype.slice.call(arguments, 0, -1);
  var options = arguments[arguments.length - 1];
  var check   = _.every(args, function (value) { return value; });

  return hbsIf.call(this, check, options);
});

/**
 * Overload the unless helper to accept multiple arguments.
 */
DOMBars.registerHelper('unless', function (/* ...args, options */) {
  var args    = Array.prototype.slice.call(arguments, 0, -1);
  var options = arguments[arguments.length - 1];
  var check   = _.every(args, function (value) { return value; });

  return hbsUnless.call(this, check, options);
});

/**
 * Create an `any` helper that will run any time any of the arguments are true.
 */
DOMBars.registerHelper('any', function (/* ...args, options */) {
  var args    = Array.prototype.slice.call(arguments, 0, -1);
  var options = arguments[arguments.length - 1];
  var check   = _.any(args, function (value) { return value; });

  return hbsIf.call(this, check, options);
});

},{"dombars/runtime":42,"underscore":49}],92:[function(require,module,exports){
var DOMBars = require('dombars/runtime');

/**
 * Register to DOMBars as the view helper.
 *
 * @param  {Backbone.View} view
 * @return {Node}
 */
DOMBars.registerHelper('view', function (view, options) {
  if (!view) { return document.createDocumentFragment(); }

  options.unsubscribe(function () {
    return view.remove();
  });

  return new DOMBars.SafeString(view.render().el);
});

},{"dombars/runtime":42}],93:[function(require,module,exports){
var DOMBars  = module.exports = require('dombars/runtime');
var _        = require('underscore');
var Backbone = require('backbone');

/**
 * Register a custom get method for Backbone views.
 *
 * @param  {Object} obj
 * @param  {String} property
 * @return {*}
 */
DOMBars.get = function (obj, property) {
  if (obj instanceof Backbone.Model) {
    return obj.get(property);
  }

  return obj[property];
};

/**
 * Provide a subscription method for handling Backbone models.
 *
 * @param {Object}   obj
 * @param {String}   property
 * @param {Function} fn
 */
DOMBars.subscribe = function (obj, property, fn) {
  if (!(obj instanceof Backbone.Model)) { return; }

  obj.on('change:' + property, fn);
};

/**
 * Provide an unsubscribe method for removing Backbone model listeners.
 *
 * @param {Object}   obj
 * @param {String}   property
 * @param {Function} fn
 */
DOMBars.unsubscribe = function (obj, property, fn) {
  if (!(obj instanceof Backbone.Model)) { return; }

  obj.off('change:' + property, fn);
};

/**
 * Add a utility function for merging multiple templates together.
 *
 * @return {Function}
 */
DOMBars.Utils.mergeTemplates = function (/* ...templates */) {
  if (arguments.length < 2) {
    return arguments[0];
  }

  var args = _.toArray(arguments);

  return function (context, options) {
    var result = {};

    // Set the value to be a document fragment.
    result.value = document.createDocumentFragment();

    // Iterate over each of the templates and track the returned child.
    var templates = _.map(args, function (template) {
      return template(context, options);
    });

    // Add an unsubscribe method the will delegate to each of the templates.
    result.unsubscribe = function () {
      _.each(templates, function (template) {
        template.unsubscribe();
      });
    };

    // Append all the templates to the document fragment.
    _.each(templates, function (template) {
      if (!template.value) { return; }

      result.value.appendChild(template.value);
    });

    return result;
  };
};

/**
 * Register DOMBars helpers.
 */
require('./helpers/if');
require('./helpers/view');
require('./helpers/equal');
require('./helpers/collection');

},{"./helpers/collection":89,"./helpers/equal":90,"./helpers/if":91,"./helpers/view":92,"backbone":3,"dombars/runtime":42,"underscore":49}],94:[function(require,module,exports){
/**
 * Accepts an array of strings that represent a reference to a value on an
 * object. Supports passing an optional setter, to set the value.
 *
 * @param  {Object} object
 * @param  {Array}  path
 * @param  {*}      [setter]
 * @return {*}
 */
module.exports = function (object, path, setter) {
  var isSetter = arguments.length > 2;

  for (var i = 0; i < path.length; i++) {
    var prop = path[i];

    if (isSetter) {
      if (i === path.length - 1) {
        object[prop] = setter;
      } else if (!(prop in object)) {
        object[prop] = {};
      }
    }

    object = object[prop];
  }

  // Return the updated object reference.
  return object;
};

},{}],95:[function(require,module,exports){
var middleware = require('../state/middleware');

/**
 * Function for displaying errors that occur to the user.
 *
 * @param {Error} err
 */
module.exports = function (title) {
  return function (err) {
    if (!err) { return; }

    return middleware.trigger('ui:notify', {
      title: title,
      message: err.message
    });
  };
};

},{"../state/middleware":109}],96:[function(require,module,exports){
(function (global){
var _      = require('underscore');
var Events = require('backbone').Events;
var Kamino = require('kamino');

/**
 * Set up event messaging with an external frame.
 *
 * @param  {Object} parentFrame
 * @return {PostMessage}
 */
var PostMessage = module.exports = function (parentFrame) {
  if (!('postMessage' in parentFrame)) {
    throw new Error('Need an instance of another frame to communicate.');
  }

  this.parentFrame = parentFrame;

  global.addEventListener('message', _.bind(function (e) {
    if (e.source !== parentFrame) { return; }

    if (this.origin && this.origin !== 'null') {
      this.origin = e.origin;
    }

    this._frameEvent = e;
    // Messages being passed by the parent window should always be in an array
    this.trigger.apply(this, Kamino.parse(e.data));
  }, this), false);
};

_.extend(PostMessage.prototype, Events);

/**
 * Trigger an event on the through the frame.
 *
 * @param  {String} name
 * @param  {*}      ...
 * @return {PostMessage}
 */
PostMessage.prototype.trigger = function (/* name , ...args */) {
  // If we have a frame event, use `trigger` normally and trigger the event
  // for local event listeners.
  if (this._frameEvent) {
    delete this._frameEvent;
    return Events.trigger.apply(this, arguments);
  }

  this.parentFrame.postMessage(
    Kamino.stringify(_.toArray(arguments)),
    this.origin || '*'
  );

  return this;
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"backbone":3,"kamino":45,"underscore":49}],97:[function(require,module,exports){
module.exports={
  "!name": "browser",
  "location": {
    "assign": {
      "!type": "fn(url: string)",
      "!url": "https://developer.mozilla.org/en/docs/DOM/window.location",
      "!doc": "Load the document at the provided URL."
    },
    "replace": {
      "!type": "fn(url: string)",
      "!url": "https://developer.mozilla.org/en/docs/DOM/window.location",
      "!doc": "Replace the current document with the one at the provided URL. The difference from the assign() method is that after using replace() the current page will not be saved in session history, meaning the user won't be able to use the Back button to navigate to it."
    },
    "reload": {
      "!type": "fn()",
      "!url": "https://developer.mozilla.org/en/docs/DOM/window.location",
      "!doc": "Reload the document from the current URL. forceget is a boolean, which, when it is true, causes the page to always be reloaded from the server. If it is false or not specified, the browser may reload the page from its cache."
    },
    "origin": {
      "!type": "string",
      "!url": "https://developer.mozilla.org/en/docs/DOM/window.location",
      "!doc": "The origin of the URL."
    },
    "hash": {
      "!type": "string",
      "!url": "https://developer.mozilla.org/en/docs/DOM/window.location",
      "!doc": "The part of the URL that follows the # symbol, including the # symbol."
    },
    "search": {
      "!type": "string",
      "!url": "https://developer.mozilla.org/en/docs/DOM/window.location",
      "!doc": "The part of the URL that follows the ? symbol, including the ? symbol."
    },
    "pathname": {
      "!type": "string",
      "!url": "https://developer.mozilla.org/en/docs/DOM/window.location",
      "!doc": "The path (relative to the host)."
    },
    "port": {
      "!type": "string",
      "!url": "https://developer.mozilla.org/en/docs/DOM/window.location",
      "!doc": "The port number of the URL."
    },
    "hostname": {
      "!type": "string",
      "!url": "https://developer.mozilla.org/en/docs/DOM/window.location",
      "!doc": "The host name (without the port number or square brackets)."
    },
    "host": {
      "!type": "string",
      "!url": "https://developer.mozilla.org/en/docs/DOM/window.location",
      "!doc": "The host name and port number."
    },
    "protocol": {
      "!type": "string",
      "!url": "https://developer.mozilla.org/en/docs/DOM/window.location",
      "!doc": "The protocol of the URL."
    },
    "href": {
      "!type": "string",
      "!url": "https://developer.mozilla.org/en/docs/DOM/window.location",
      "!doc": "The entire URL."
    },
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.location",
    "!doc": "Returns a location object with information about the current location of the document. Assigning to the location property changes the current page to the new address."
  },
  "Node": {
    "!type": "fn()",
    "prototype": {
      "parentElement": {
        "!type": "+Element",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.parentElement",
        "!doc": "Returns the DOM node's parent Element, or null if the node either has no parent, or its parent isn't a DOM Element."
      },
      "textContent": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.textContent",
        "!doc": "Gets or sets the text content of a node and its descendants."
      },
      "baseURI": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.baseURI",
        "!doc": "The absolute base URI of a node or null if unable to obtain an absolute URI."
      },
      "localName": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.localName",
        "!doc": "Returns the local part of the qualified name of this node."
      },
      "prefix": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.prefix",
        "!doc": "Returns the namespace prefix of the specified node, or null if no prefix is specified. This property is read only."
      },
      "namespaceURI": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.namespaceURI",
        "!doc": "The namespace URI of the node, or null if the node is not in a namespace (read-only). When the node is a document, it returns the XML namespace for the current document."
      },
      "ownerDocument": {
        "!type": "+Document",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.ownerDocument",
        "!doc": "The ownerDocument property returns the top-level document object for this node."
      },
      "attributes": {
        "!type": "+NamedNodeMap",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.attributes",
        "!doc": "A collection of all attribute nodes registered to the specified node. It is a NamedNodeMap,not an Array, so it has no Array methods and the Attr nodes' indexes may differ among browsers."
      },
      "nextSibling": {
        "!type": "+Element",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.nextSibling",
        "!doc": "Returns the node immediately following the specified one in its parent's childNodes list, or null if the specified node is the last node in that list."
      },
      "previousSibling": {
        "!type": "+Element",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.previousSibling",
        "!doc": "Returns the node immediately preceding the specified one in its parent's childNodes list, null if the specified node is the first in that list."
      },
      "lastChild": {
        "!type": "+Element",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.lastChild",
        "!doc": "Returns the last child of a node."
      },
      "firstChild": {
        "!type": "+Element",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.firstChild",
        "!doc": "Returns the node's first child in the tree, or null if the node is childless. If the node is a Document, it returns the first node in the list of its direct children."
      },
      "childNodes": {
        "!type": "+NodeList",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.childNodes",
        "!doc": "Returns a collection of child nodes of the given element."
      },
      "parentNode": {
        "!type": "+Element",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.parentNode",
        "!doc": "Returns the parent of the specified node in the DOM tree."
      },
      "nodeType": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.nodeType",
        "!doc": "Returns an integer code representing the type of the node."
      },
      "nodeValue": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.nodeValue",
        "!doc": "Returns or sets the value of the current node."
      },
      "nodeName": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.nodeName",
        "!doc": "Returns the name of the current node as a string."
      },
      "tagName": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.nodeName",
        "!doc": "Returns the name of the current node as a string."
      },
      "insertBefore": {
        "!type": "fn(newElt: +Element, before: +Element) -> +Element",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.insertBefore",
        "!doc": "Inserts the specified node before a reference element as a child of the current node."
      },
      "replaceChild": {
        "!type": "fn(newElt: +Element, oldElt: +Element) -> +Element",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.replaceChild",
        "!doc": "Replaces one child node of the specified element with another."
      },
      "removeChild": {
        "!type": "fn(oldElt: +Element) -> +Element",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.removeChild",
        "!doc": "Removes a child node from the DOM. Returns removed node."
      },
      "appendChild": {
        "!type": "fn(newElt: +Element) -> +Element",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.appendChild",
        "!doc": "Adds a node to the end of the list of children of a specified parent node. If the node already exists it is removed from current parent node, then added to new parent node."
      },
      "hasChildNodes": {
        "!type": "fn() -> bool",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.hasChildNodes",
        "!doc": "Returns a Boolean value indicating whether the current Node has child nodes or not."
      },
      "cloneNode": {
        "!type": "fn(deep: bool) -> +Element",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.cloneNode",
        "!doc": "Returns a duplicate of the node on which this method was called."
      },
      "normalize": {
        "!type": "fn()",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.normalize",
        "!doc": "Puts the specified node and all of its subtree into a \"normalized\" form. In a normalized subtree, no text nodes in the subtree are empty and there are no adjacent text nodes."
      },
      "isSupported": {
        "!type": "fn(features: string, version: number) -> bool",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.isSupported",
        "!doc": "Tests whether the DOM implementation implements a specific feature and that feature is supported by this node."
      },
      "hasAttributes": {
        "!type": "fn() -> bool",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.hasAttributes",
        "!doc": "Returns a boolean value of true or false, indicating if the current element has any attributes or not."
      },
      "lookupPrefix": {
        "!type": "fn(uri: string) -> string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.lookupPrefix",
        "!doc": "Returns the prefix for a given namespaceURI if present, and null if not. When multiple prefixes are possible, the result is implementation-dependent."
      },
      "isDefaultNamespace": {
        "!type": "fn(uri: string) -> bool",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.isDefaultNamespace",
        "!doc": "Accepts a namespace URI as an argument and returns true if the namespace is the default namespace on the given node or false if not."
      },
      "lookupNamespaceURI": {
        "!type": "fn(uri: string) -> string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.lookupNamespaceURI",
        "!doc": "Takes a prefix and returns the namespaceURI associated with it on the given node if found (and null if not). Supplying null for the prefix will return the default namespace."
      },
      "addEventListener": {
        "!type": "fn(type: string, listener: fn(e: +Event), capture: bool)",
        "!url": "https://developer.mozilla.org/en/docs/DOM/EventTarget.addEventListener",
        "!doc": "Registers a single event listener on a single target. The event target may be a single element in a document, the document itself, a window, or an XMLHttpRequest."
      },
      "removeEventListener": {
        "!type": "fn(type: string, listener: fn(), capture: bool)",
        "!url": "https://developer.mozilla.org/en/docs/DOM/EventTarget.removeEventListener",
        "!doc": "Allows the removal of event listeners from the event target."
      },
      "isSameNode": {
        "!type": "fn(other: +Node) -> bool",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.isSameNode",
        "!doc": "Tests whether two nodes are the same, that is they reference the same object."
      },
      "isEqualNode": {
        "!type": "fn(other: +Node) -> bool",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.isEqualNode",
        "!doc": "Tests whether two nodes are equal."
      },
      "compareDocumentPosition": {
        "!type": "fn(other: +Node) -> number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.compareDocumentPosition",
        "!doc": "Compares the position of the current node against another node in any other document."
      },
      "contains": {
        "!type": "fn(other: +Node) -> bool",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.contains",
        "!doc": "Indicates whether a node is a descendent of a given node."
      },
      "dispatchEvent": {
        "!type": "fn(event: +Event) -> bool",
        "!url": "https://developer.mozilla.org/en/docs/DOM/EventTarget.dispatchEvent",
        "!doc": "Dispatches an event into the event system. The event is subject to the same capturing and bubbling behavior as directly dispatched events."
      },
      "ELEMENT_NODE": "number",
      "ATTRIBUTE_NODE": "number",
      "TEXT_NODE": "number",
      "CDATA_SECTION_NODE": "number",
      "ENTITY_REFERENCE_NODE": "number",
      "ENTITY_NODE": "number",
      "PROCESSING_INSTRUCTION_NODE": "number",
      "COMMENT_NODE": "number",
      "DOCUMENT_NODE": "number",
      "DOCUMENT_TYPE_NODE": "number",
      "DOCUMENT_FRAGMENT_NODE": "number",
      "NOTATION_NODE": "number",
      "DOCUMENT_POSITION_DISCONNECTED": "number",
      "DOCUMENT_POSITION_PRECEDING": "number",
      "DOCUMENT_POSITION_FOLLOWING": "number",
      "DOCUMENT_POSITION_CONTAINS": "number",
      "DOCUMENT_POSITION_CONTAINED_BY": "number",
      "DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC": "number"
    },
    "!url": "https://developer.mozilla.org/en/docs/DOM/Node",
    "!doc": "A Node is an interface from which a number of DOM types inherit, and allows these various types to be treated (or tested) similarly."
  },
  "Element": {
    "!type": "fn()",
    "prototype": {
      "!proto": "Node.prototype",
      "getAttribute": {
        "!type": "fn(name: string) -> string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.getAttribute",
        "!doc": "Returns the value of the named attribute on the specified element. If the named attribute does not exist, the value returned will either be null or \"\" (the empty string)."
      },
      "setAttribute": {
        "!type": "fn(name: string, value: string)",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.setAttribute",
        "!doc": "Adds a new attribute or changes the value of an existing attribute on the specified element."
      },
      "removeAttribute": {
        "!type": "fn(name: string)",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.removeAttribute",
        "!doc": "Removes an attribute from the specified element."
      },
      "getAttributeNode": {
        "!type": "fn(name: string) -> +Attr",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.getAttributeNode",
        "!doc": "Returns the specified attribute of the specified element, as an Attr node."
      },
      "getElementsByTagName": {
        "!type": "fn(tagName: string) -> +NodeList",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.getElementsByTagName",
        "!doc": "Returns a list of elements with the given tag name. The subtree underneath the specified element is searched, excluding the element itself. The returned list is live, meaning that it updates itself with the DOM tree automatically. Consequently, there is no need to call several times element.getElementsByTagName with the same element and arguments."
      },
      "getElementsByTagNameNS": {
        "!type": "fn(ns: string, tagName: string) -> +NodeList",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.getElementsByTagNameNS",
        "!doc": "Returns a list of elements with the given tag name belonging to the given namespace."
      },
      "getAttributeNS": {
        "!type": "fn(ns: string, name: string) -> string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.getAttributeNS",
        "!doc": "Returns the string value of the attribute with the specified namespace and name. If the named attribute does not exist, the value returned will either be null or \"\" (the empty string)."
      },
      "setAttributeNS": {
        "!type": "fn(ns: string, name: string, value: string)",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.setAttributeNS",
        "!doc": "Adds a new attribute or changes the value of an attribute with the given namespace and name."
      },
      "removeAttributeNS": {
        "!type": "fn(ns: string, name: string)",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.removeAttributeNS",
        "!doc": "removeAttributeNS removes the specified attribute from an element."
      },
      "getAttributeNodeNS": {
        "!type": "fn(ns: string, name: string) -> +Attr",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.getAttributeNodeNS",
        "!doc": "Returns the Attr node for the attribute with the given namespace and name."
      },
      "hasAttribute": {
        "!type": "fn(name: string) -> bool",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.hasAttribute",
        "!doc": "hasAttribute returns a boolean value indicating whether the specified element has the specified attribute or not."
      },
      "hasAttributeNS": {
        "!type": "fn(ns: string, name: string) -> bool",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.hasAttributeNS",
        "!doc": "hasAttributeNS returns a boolean value indicating whether the current element has the specified attribute."
      },
      "focus": {
        "!type": "fn()",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.focus",
        "!doc": "Sets focus on the specified element, if it can be focused."
      },
      "blur": {
        "!type": "fn()",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.blur",
        "!doc": "The blur method removes keyboard focus from the current element."
      },
      "scrollIntoView": {
        "!type": "fn(top: bool)",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.scrollIntoView",
        "!doc": "The scrollIntoView() method scrolls the element into view."
      },
      "scrollByLines": {
        "!type": "fn(lines: number)",
        "!url": "https://developer.mozilla.org/en/docs/DOM/window.scrollByLines",
        "!doc": "Scrolls the document by the given number of lines."
      },
      "scrollByPages": {
        "!type": "fn(pages: number)",
        "!url": "https://developer.mozilla.org/en/docs/DOM/window.scrollByPages",
        "!doc": "Scrolls the current document by the specified number of pages."
      },
      "getElementsByClassName": {
        "!type": "fn(name: string) -> +NodeList",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.getElementsByClassName",
        "!doc": "Returns a set of elements which have all the given class names. When called on the document object, the complete document is searched, including the root node. You may also call getElementsByClassName on any element; it will return only elements which are descendants of the specified root element with the given class names."
      },
      "querySelector": {
        "!type": "fn(selectors: string) -> +Node",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Element.querySelector",
        "!doc": "Returns the first element that is a descendent of the element on which it is invoked that matches the specified group of selectors."
      },
      "querySelectorAll": {
        "!type": "fn(selectors: string) -> +NodeList",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Element.querySelectorAll",
        "!doc": "Returns a non-live NodeList of all elements descended from the element on which it is invoked that match the specified group of CSS selectors."
      },
      "getClientRects": {
        "!type": "fn() -> [+ClientRect]",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.getClientRects",
        "!doc": "Returns a collection of rectangles that indicate the bounding rectangles for each box in a client."
      },
      "getBoundingClientRect": {
        "!type": "fn() -> +ClientRect",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.getBoundingClientRect",
        "!doc": "Returns a text rectangle object that encloses a group of text rectangles."
      },
      "setAttributeNode": {
        "!type": "fn(attr: +Attr) -> +Attr",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.setAttributeNode",
        "!doc": "Adds a new Attr node to the specified element."
      },
      "removeAttributeNode": {
        "!type": "fn(attr: +Attr) -> +Attr",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.removeAttributeNode",
        "!doc": "Removes the specified attribute from the current element."
      },
      "setAttributeNodeNS": {
        "!type": "fn(attr: +Attr) -> +Attr",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.setAttributeNodeNS",
        "!doc": "Adds a new namespaced attribute node to an element."
      },
      "insertAdjacentHTML": {
        "!type": "fn(position: string, text: string)",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.insertAdjacentHTML",
        "!doc": "Parses the specified text as HTML or XML and inserts the resulting nodes into the DOM tree at a specified position. It does not reparse the element it is being used on and thus it does not corrupt the existing elements inside the element. This, and avoiding the extra step of serialization make it much faster than direct innerHTML manipulation."
      },
      "children": {
        "!type": "+HTMLCollection",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Element.children",
        "!doc": "Returns a collection of child elements of the given element."
      },
      "childElementCount": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Element.childElementCount",
        "!doc": "Returns the number of child elements of the given element."
      },
      "className": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.className",
        "!doc": "Gets and sets the value of the class attribute of the specified element."
      },
      "style": {
        "cssText": "string",
        "alignmentBaseline": "string",
        "background": "string",
        "backgroundAttachment": "string",
        "backgroundClip": "string",
        "backgroundColor": "string",
        "backgroundImage": "string",
        "backgroundOrigin": "string",
        "backgroundPosition": "string",
        "backgroundPositionX": "string",
        "backgroundPositionY": "string",
        "backgroundRepeat": "string",
        "backgroundRepeatX": "string",
        "backgroundRepeatY": "string",
        "backgroundSize": "string",
        "baselineShift": "string",
        "border": "string",
        "borderBottom": "string",
        "borderBottomColor": "string",
        "borderBottomLeftRadius": "string",
        "borderBottomRightRadius": "string",
        "borderBottomStyle": "string",
        "borderBottomWidth": "string",
        "borderCollapse": "string",
        "borderColor": "string",
        "borderImage": "string",
        "borderImageOutset": "string",
        "borderImageRepeat": "string",
        "borderImageSlice": "string",
        "borderImageSource": "string",
        "borderImageWidth": "string",
        "borderLeft": "string",
        "borderLeftColor": "string",
        "borderLeftStyle": "string",
        "borderLeftWidth": "string",
        "borderRadius": "string",
        "borderRight": "string",
        "borderRightColor": "string",
        "borderRightStyle": "string",
        "borderRightWidth": "string",
        "borderSpacing": "string",
        "borderStyle": "string",
        "borderTop": "string",
        "borderTopColor": "string",
        "borderTopLeftRadius": "string",
        "borderTopRightRadius": "string",
        "borderTopStyle": "string",
        "borderTopWidth": "string",
        "borderWidth": "string",
        "bottom": "string",
        "boxShadow": "string",
        "boxSizing": "string",
        "captionSide": "string",
        "clear": "string",
        "clip": "string",
        "clipPath": "string",
        "clipRule": "string",
        "color": "string",
        "colorInterpolation": "string",
        "colorInterpolationFilters": "string",
        "colorProfile": "string",
        "colorRendering": "string",
        "content": "string",
        "counterIncrement": "string",
        "counterReset": "string",
        "cursor": "string",
        "direction": "string",
        "display": "string",
        "dominantBaseline": "string",
        "emptyCells": "string",
        "enableBackground": "string",
        "fill": "string",
        "fillOpacity": "string",
        "fillRule": "string",
        "filter": "string",
        "float": "string",
        "floodColor": "string",
        "floodOpacity": "string",
        "font": "string",
        "fontFamily": "string",
        "fontSize": "string",
        "fontStretch": "string",
        "fontStyle": "string",
        "fontVariant": "string",
        "fontWeight": "string",
        "glyphOrientationHorizontal": "string",
        "glyphOrientationVertical": "string",
        "height": "string",
        "imageRendering": "string",
        "kerning": "string",
        "left": "string",
        "letterSpacing": "string",
        "lightingColor": "string",
        "lineHeight": "string",
        "listStyle": "string",
        "listStyleImage": "string",
        "listStylePosition": "string",
        "listStyleType": "string",
        "margin": "string",
        "marginBottom": "string",
        "marginLeft": "string",
        "marginRight": "string",
        "marginTop": "string",
        "marker": "string",
        "markerEnd": "string",
        "markerMid": "string",
        "markerStart": "string",
        "mask": "string",
        "maxHeight": "string",
        "maxWidth": "string",
        "minHeight": "string",
        "minWidth": "string",
        "opacity": "string",
        "orphans": "string",
        "outline": "string",
        "outlineColor": "string",
        "outlineOffset": "string",
        "outlineStyle": "string",
        "outlineWidth": "string",
        "overflow": "string",
        "overflowWrap": "string",
        "overflowX": "string",
        "overflowY": "string",
        "padding": "string",
        "paddingBottom": "string",
        "paddingLeft": "string",
        "paddingRight": "string",
        "paddingTop": "string",
        "page": "string",
        "pageBreakAfter": "string",
        "pageBreakBefore": "string",
        "pageBreakInside": "string",
        "pointerEvents": "string",
        "position": "string",
        "quotes": "string",
        "resize": "string",
        "right": "string",
        "shapeRendering": "string",
        "size": "string",
        "speak": "string",
        "src": "string",
        "stopColor": "string",
        "stopOpacity": "string",
        "stroke": "string",
        "strokeDasharray": "string",
        "strokeDashoffset": "string",
        "strokeLinecap": "string",
        "strokeLinejoin": "string",
        "strokeMiterlimit": "string",
        "strokeOpacity": "string",
        "strokeWidth": "string",
        "tabSize": "string",
        "tableLayout": "string",
        "textAlign": "string",
        "textAnchor": "string",
        "textDecoration": "string",
        "textIndent": "string",
        "textLineThrough": "string",
        "textLineThroughColor": "string",
        "textLineThroughMode": "string",
        "textLineThroughStyle": "string",
        "textLineThroughWidth": "string",
        "textOverflow": "string",
        "textOverline": "string",
        "textOverlineColor": "string",
        "textOverlineMode": "string",
        "textOverlineStyle": "string",
        "textOverlineWidth": "string",
        "textRendering": "string",
        "textShadow": "string",
        "textTransform": "string",
        "textUnderline": "string",
        "textUnderlineColor": "string",
        "textUnderlineMode": "string",
        "textUnderlineStyle": "string",
        "textUnderlineWidth": "string",
        "top": "string",
        "unicodeBidi": "string",
        "unicodeRange": "string",
        "vectorEffect": "string",
        "verticalAlign": "string",
        "visibility": "string",
        "whiteSpace": "string",
        "width": "string",
        "wordBreak": "string",
        "wordSpacing": "string",
        "wordWrap": "string",
        "writingMode": "string",
        "zIndex": "string",
        "zoom": "string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.style",
        "!doc": "Returns an object that represents the element's style attribute."
      },
      "classList": {
        "!type": "+DOMTokenList",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.classList",
        "!doc": "Returns a token list of the class attribute of the element."
      },
      "contentEditable": {
        "!type": "bool",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Element.contentEditable",
        "!doc": "Indicates whether or not the element is editable."
      },
      "firstElementChild": {
        "!type": "+Element",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Element.firstElementChild",
        "!doc": "Returns the element's first child element or null if there are no child elements."
      },
      "lastElementChild": {
        "!type": "+Element",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Element.lastElementChild",
        "!doc": "Returns the element's last child element or null if there are no child elements."
      },
      "nextElementSibling": {
        "!type": "+Element",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Element.nextElementSibling",
        "!doc": "Returns the element immediately following the specified one in its parent's children list, or null if the specified element is the last one in the list."
      },
      "previousElementSibling": {
        "!type": "+Element",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Element.previousElementSibling",
        "!doc": "Returns the element immediately prior to the specified one in its parent's children list, or null if the specified element is the first one in the list."
      },
      "tabIndex": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.tabIndex",
        "!doc": "Gets/sets the tab order of the current element."
      },
      "title": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.title",
        "!doc": "Establishes the text to be displayed in a 'tool tip' popup when the mouse is over the displayed node."
      },
      "width": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.offsetWidth",
        "!doc": "Returns the layout width of an element."
      },
      "height": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.offsetHeight",
        "!doc": "Height of an element relative to the element's offsetParent."
      },
      "getContext": {
        "!type": "fn(id: string) -> CanvasRenderingContext2D",
        "!url": "https://developer.mozilla.org/en/docs/DOM/HTMLCanvasElement",
        "!doc": "DOM canvas elements expose the HTMLCanvasElement interface, which provides properties and methods for manipulating the layout and presentation of canvas elements. The HTMLCanvasElement interface inherits the properties and methods of the element object interface."
      },
      "supportsContext": "fn(id: string) -> bool",
      "oncopy": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.oncopy",
        "!doc": "The oncopy property returns the onCopy event handler code on the current element."
      },
      "oncut": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.oncut",
        "!doc": "The oncut property returns the onCut event handler code on the current element."
      },
      "onpaste": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onpaste",
        "!doc": "The onpaste property returns the onPaste event handler code on the current element."
      },
      "onbeforeunload": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/HTML/Element/body",
        "!doc": "The HTML <body> element represents the main content of an HTML document. There is only one <body> element in a document."
      },
      "onfocus": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onfocus",
        "!doc": "The onfocus property returns the onFocus event handler code on the current element."
      },
      "onblur": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onblur",
        "!doc": "The onblur property returns the onBlur event handler code, if any, that exists on the current element."
      },
      "onchange": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onchange",
        "!doc": "The onchange property sets and returns the onChange event handler code for the current element."
      },
      "onclick": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onclick",
        "!doc": "The onclick property returns the onClick event handler code on the current element."
      },
      "ondblclick": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.ondblclick",
        "!doc": "The ondblclick property returns the onDblClick event handler code on the current element."
      },
      "onmousedown": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onmousedown",
        "!doc": "The onmousedown property returns the onMouseDown event handler code on the current element."
      },
      "onmouseup": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onmouseup",
        "!doc": "The onmouseup property returns the onMouseUp event handler code on the current element."
      },
      "onmousewheel": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Mozilla_event_reference/wheel",
        "!doc": "The wheel event is fired when a wheel button of a pointing device (usually a mouse) is rotated. This event deprecates the legacy mousewheel event."
      },
      "onmouseover": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onmouseover",
        "!doc": "The onmouseover property returns the onMouseOver event handler code on the current element."
      },
      "onmouseout": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onmouseout",
        "!doc": "The onmouseout property returns the onMouseOut event handler code on the current element."
      },
      "onmousemove": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onmousemove",
        "!doc": "The onmousemove property returns the mousemove event handler code on the current element."
      },
      "oncontextmenu": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/DOM/window.oncontextmenu",
        "!doc": "An event handler property for right-click events on the window. Unless the default behavior is prevented, the browser context menu will activate. Note that this event will occur with any non-disabled right-click event and does not depend on an element possessing the \"contextmenu\" attribute."
      },
      "onkeydown": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onkeydown",
        "!doc": "The onkeydown property returns the onKeyDown event handler code on the current element."
      },
      "onkeyup": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onkeyup",
        "!doc": "The onkeyup property returns the onKeyUp event handler code for the current element."
      },
      "onkeypress": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onkeypress",
        "!doc": "The onkeypress property sets and returns the onKeyPress event handler code for the current element."
      },
      "onresize": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onresize",
        "!doc": "onresize returns the element's onresize event handler code. It can also be used to set the code to be executed when the resize event occurs."
      },
      "onscroll": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onscroll",
        "!doc": "The onscroll property returns the onScroll event handler code on the current element."
      },
      "ondragstart": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/DragDrop/Drag_Operations",
        "!doc": "The following describes the steps that occur during a drag and drop operation."
      },
      "ondragover": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Mozilla_event_reference/dragover",
        "!doc": "The dragover event is fired when an element or text selection is being dragged over a valid drop target (every few hundred milliseconds)."
      },
      "ondragleave": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Mozilla_event_reference/dragleave",
        "!doc": "The dragleave event is fired when a dragged element or text selection leaves a valid drop target."
      },
      "ondragenter": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Mozilla_event_reference/dragenter",
        "!doc": "The dragenter event is fired when a dragged element or text selection enters a valid drop target."
      },
      "ondragend": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Mozilla_event_reference/dragend",
        "!doc": "The dragend event is fired when a drag operation is being ended (by releasing a mouse button or hitting the escape key)."
      },
      "ondrag": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Mozilla_event_reference/drag",
        "!doc": "The drag event is fired when an element or text selection is being dragged (every few hundred milliseconds)."
      },
      "offsetTop": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.offsetTop",
        "!doc": "Returns the distance of the current element relative to the top of the offsetParent node."
      },
      "offsetLeft": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.offsetLeft",
        "!doc": "Returns the number of pixels that the upper left corner of the current element is offset to the left within the offsetParent node."
      },
      "offsetHeight": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.offsetHeight",
        "!doc": "Height of an element relative to the element's offsetParent."
      },
      "offsetWidth": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.offsetWidth",
        "!doc": "Returns the layout width of an element."
      },
      "scrollTop": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.scrollTop",
        "!doc": "Gets or sets the number of pixels that the content of an element is scrolled upward."
      },
      "scrollLeft": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.scrollLeft",
        "!doc": "Gets or sets the number of pixels that an element's content is scrolled to the left."
      },
      "scrollHeight": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.scrollHeight",
        "!doc": "Height of the scroll view of an element; it includes the element padding but not its margin."
      },
      "scrollWidth": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.scrollWidth",
        "!doc": "Read-only property that returns either the width in pixels of the content of an element or the width of the element itself, whichever is greater."
      },
      "clientTop": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.clientTop",
        "!doc": "The width of the top border of an element in pixels. It does not include the top margin or padding. clientTop is read-only."
      },
      "clientLeft": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.clientLeft",
        "!doc": "The width of the left border of an element in pixels. It includes the width of the vertical scrollbar if the text direction of the element is right-to-left and if there is an overflow causing a left vertical scrollbar to be rendered. clientLeft does not include the left margin or the left padding. clientLeft is read-only."
      },
      "clientHeight": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.clientHeight",
        "!doc": "Returns the inner height of an element in pixels, including padding but not the horizontal scrollbar height, border, or margin."
      },
      "clientWidth": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.clientWidth",
        "!doc": "The inner width of an element in pixels. It includes padding but not the vertical scrollbar (if present, if rendered), border or margin."
      },
      "innerHTML": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.innerHTML",
        "!doc": "Sets or gets the HTML syntax describing the element's descendants."
      }
    },
    "!url": "https://developer.mozilla.org/en/docs/DOM/Element",
    "!doc": "Represents an element in an HTML or XML document."
  },
  "Text": {
    "!type": "fn()",
    "prototype": {
      "!proto": "Node.prototype",
      "wholeText": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Text.wholeText",
        "!doc": "Returns all text of all Text nodes logically adjacent to the node.  The text is concatenated in document order.  This allows you to specify any text node and obtain all adjacent text as a single string."
      },
      "splitText": {
        "!type": "fn(offset: number) -> +Text",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Text.splitText",
        "!doc": "Breaks the Text node into two nodes at the specified offset, keeping both nodes in the tree as siblings."
      }
    },
    "!url": "https://developer.mozilla.org/en/docs/DOM/Text",
    "!doc": "In the DOM, the Text interface represents the textual content of an Element or Attr.  If an element has no markup within its content, it has a single child implementing Text that contains the element's text.  However, if the element contains markup, it is parsed into information items and Text nodes that form its children."
  },
  "Document": {
    "!type": "fn()",
    "prototype": {
      "!proto": "Node.prototype",
      "activeElement": {
        "!type": "+Element",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.activeElement",
        "!doc": "Returns the currently focused element, that is, the element that will get keystroke events if the user types any. This attribute is read only."
      },
      "compatMode": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.compatMode",
        "!doc": "Indicates whether the document is rendered in Quirks mode or Strict mode."
      },
      "designMode": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.designMode",
        "!doc": "Can be used to make any document editable, for example in a <iframe />:"
      },
      "dir": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Document.dir",
        "!doc": "This property should indicate and allow the setting of the directionality of the text of the document, whether left to right (default) or right to left."
      },
      "height": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.height",
        "!doc": "Returns the height of the <body> element of the current document."
      },
      "width": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.width",
        "!doc": "Returns the width of the <body> element of the current document in pixels."
      },
      "characterSet": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.characterSet",
        "!doc": "Returns the character encoding of the current document."
      },
      "readyState": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.readyState",
        "!doc": "Returns \"loading\" while the document is loading, \"interactive\" once it is finished parsing but still loading sub-resources, and \"complete\" once it has loaded."
      },
      "location": {
        "!type": "location",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.location",
        "!doc": "Returns a Location object, which contains information about the URL of the document and provides methods for changing that URL."
      },
      "lastModified": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.lastModified",
        "!doc": "Returns a string containing the date and time on which the current document was last modified."
      },
      "head": {
        "!type": "+Element",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.head",
        "!doc": "Returns the <head> element of the current document. If there are more than one <head> elements, the first one is returned."
      },
      "body": {
        "!type": "+Element",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.body",
        "!doc": "Returns the <body> or <frameset> node of the current document."
      },
      "cookie": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.cookie",
        "!doc": "Get and set the cookies associated with the current document."
      },
      "URL": "string",
      "domain": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.domain",
        "!doc": "Gets/sets the domain portion of the origin of the current document, as used by the same origin policy."
      },
      "referrer": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.referrer",
        "!doc": "Returns the URI of the page that linked to this page."
      },
      "title": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.title",
        "!doc": "Gets or sets the title of the document."
      },
      "defaultView": {
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.defaultView",
        "!doc": "In browsers returns the window object associated with the document or null if none available."
      },
      "documentURI": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.documentURI",
        "!doc": "Returns the document location as string. It is read-only per DOM4 specification."
      },
      "xmlStandalone": "bool",
      "xmlVersion": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.xmlVersion",
        "!doc": "Returns the version number as specified in the XML declaration (e.g., <?xml version=\"1.0\"?>) or \"1.0\" if the declaration is absent."
      },
      "xmlEncoding": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Document.xmlEncoding",
        "!doc": "Returns the encoding as determined by the XML declaration. Should be null if unspecified or unknown."
      },
      "inputEncoding": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.inputEncoding",
        "!doc": "Returns a string representing the encoding under which the document was parsed (e.g. ISO-8859-1)."
      },
      "documentElement": {
        "!type": "+Element",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.documentElement",
        "!doc": "Read-only"
      },
      "implementation": {
        "hasFeature": "fn(feature: string, version: number) -> bool",
        "createDocumentType": {
          "!type": "fn(qualifiedName: string, publicId: string, systemId: string) -> +Node",
          "!url": "https://developer.mozilla.org/en/docs/DOM/DOMImplementation.createDocumentType",
          "!doc": "Returns a DocumentType object which can either be used with DOMImplementation.createDocument upon document creation or they can be put into the document via Node.insertBefore() or Node.replaceChild(): http://www.w3.org/TR/DOM-Level-3-Cor...l#ID-B63ED1A31 (less ideal due to features not likely being as accessible: http://www.w3.org/TR/DOM-Level-3-Cor...createDocument ). In any case, entity declarations and notations will not be available: http://www.w3.org/TR/DOM-Level-3-Cor...-createDocType   "
        },
        "createHTMLDocument": {
          "!type": "fn(title: string) -> +Document",
          "!url": "https://developer.mozilla.org/en/docs/DOM/DOMImplementation.createHTMLDocument",
          "!doc": "This method (available from document.implementation) creates a new HTML document."
        },
        "createDocument": {
          "!type": "fn(namespaceURI: string, qualifiedName: string, type: +Node) -> +Document",
          "!url": "https://developer.mozilla.org/en-US/docs/DOM/DOMImplementation.createHTMLDocument",
          "!doc": "This method creates a new HTML document."
        },
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.implementation",
        "!doc": "Returns a DOMImplementation object associated with the current document."
      },
      "doctype": {
        "!type": "+Node",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.doctype",
        "!doc": "Returns the Document Type Declaration (DTD) associated with current document. The returned object implements the DocumentType interface. Use DOMImplementation.createDocumentType() to create a DocumentType."
      },
      "open": {
        "!type": "fn()",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.open",
        "!doc": "The document.open() method opens a document for writing."
      },
      "close": {
        "!type": "fn()",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.close",
        "!doc": "The document.close() method finishes writing to a document, opened with document.open()."
      },
      "write": {
        "!type": "fn(html: string)",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.write",
        "!doc": "Writes a string of text to a document stream opened by document.open()."
      },
      "writeln": {
        "!type": "fn(html: string)",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.writeln",
        "!doc": "Writes a string of text followed by a newline character to a document."
      },
      "clear": {
        "!type": "fn()",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.clear",
        "!doc": "In recent versions of Mozilla-based applications as well as in Internet Explorer and Netscape 4 this method does nothing."
      },
      "hasFocus": {
        "!type": "fn() -> bool",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.hasFocus",
        "!doc": "Returns a Boolean value indicating whether the document or any element inside the document has focus. This method can be used to determine whether the active element in a document has focus."
      },
      "createElement": {
        "!type": "fn(tagName: string) -> +Element",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.createElement",
        "!doc": "Creates the specified element."
      },
      "createElementNS": {
        "!type": "fn(ns: string, tagName: string) -> +Element",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.createElementNS",
        "!doc": "Creates an element with the specified namespace URI and qualified name."
      },
      "createDocumentFragment": {
        "!type": "fn() -> +DocumentFragment",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.createDocumentFragment",
        "!doc": "Creates a new empty DocumentFragment."
      },
      "createTextNode": {
        "!type": "fn(content: string) -> +Text",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.createTextNode",
        "!doc": "Creates a new Text node."
      },
      "createComment": {
        "!type": "fn(content: string) -> +Node",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.createComment",
        "!doc": "Creates a new comment node, and returns it."
      },
      "createCDATASection": {
        "!type": "fn(content: string) -> +Node",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.createCDATASection",
        "!doc": "Creates a new CDATA section node, and returns it. "
      },
      "createProcessingInstruction": {
        "!type": "fn(content: string) -> +Node",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.createProcessingInstruction",
        "!doc": "Creates a new processing instruction node, and returns it."
      },
      "createAttribute": {
        "!type": "fn(name: string) -> +Attr",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.createAttribute",
        "!doc": "Creates a new attribute node, and returns it."
      },
      "createAttributeNS": {
        "!type": "fn(ns: string, name: string) -> +Attr",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Attr",
        "!doc": "This type represents a DOM element's attribute as an object. In most DOM methods, you will probably directly retrieve the attribute as a string (e.g., Element.getAttribute(), but certain functions (e.g., Element.getAttributeNode()) or means of iterating give Attr types."
      },
      "importNode": {
        "!type": "fn(node: +Node, deep: bool) -> +Element",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.importNode",
        "!doc": "Creates a copy of a node from an external document that can be inserted into the current document."
      },
      "getElementById": {
        "!type": "fn(id: string) -> +Element",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.getElementById",
        "!doc": "Returns a reference to the element by its ID."
      },
      "getElementsByTagName": {
        "!type": "fn(tagName: string) -> +NodeList",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.getElementsByTagName",
        "!doc": "Returns a NodeList of elements with the given tag name. The complete document is searched, including the root node. The returned NodeList is live, meaning that it updates itself automatically to stay in sync with the DOM tree without having to call document.getElementsByTagName again."
      },
      "getElementsByTagNameNS": {
        "!type": "fn(ns: string, tagName: string) -> +NodeList",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.getElementsByTagNameNS",
        "!doc": "Returns a list of elements with the given tag name belonging to the given namespace. The complete document is searched, including the root node."
      },
      "createEvent": {
        "!type": "fn(type: string) -> +Event",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.createEvent",
        "!doc": "Creates an event of the type specified. The returned object should be first initialized and can then be passed to element.dispatchEvent."
      },
      "createRange": {
        "!type": "fn() -> +Range",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.createRange",
        "!doc": "Returns a new Range object."
      },
      "evaluate": {
        "!type": "fn(expr: ?) -> +XPathResult",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.evaluate",
        "!doc": "Returns an XPathResult based on an XPath expression and other given parameters."
      },
      "execCommand": {
        "!type": "fn(cmd: string)",
        "!url": "https://developer.mozilla.org/en-US/docs/Rich-Text_Editing_in_Mozilla#Executing_Commands",
        "!doc": "Run command to manipulate the contents of an editable region."
      },
      "queryCommandEnabled": {
        "!type": "fn(cmd: string) -> bool",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document",
        "!doc": "Returns true if the Midas command can be executed on the current range."
      },
      "queryCommandIndeterm": {
        "!type": "fn(cmd: string) -> bool",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document",
        "!doc": "Returns true if the Midas command is in a indeterminate state on the current range."
      },
      "queryCommandState": {
        "!type": "fn(cmd: string) -> bool",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document",
        "!doc": "Returns true if the Midas command has been executed on the current range."
      },
      "queryCommandSupported": {
        "!type": "fn(cmd: string) -> bool",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.queryCommandSupported",
        "!doc": "Reports whether or not the specified editor query command is supported by the browser."
      },
      "queryCommandValue": {
        "!type": "fn(cmd: string) -> string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document",
        "!doc": "Returns the current value of the current range for Midas command."
      },
      "getElementsByName": {
        "!type": "fn(name: string) -> +HTMLCollection",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.getElementsByName",
        "!doc": "Returns a list of elements with a given name in the HTML document."
      },
      "elementFromPoint": {
        "!type": "fn(x: number, y: number) -> +Element",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.elementFromPoint",
        "!doc": "Returns the element from the document whose elementFromPoint method is being called which is the topmost element which lies under the given point.  To get an element, specify the point via coordinates, in CSS pixels, relative to the upper-left-most point in the window or frame containing the document."
      },
      "getSelection": {
        "!type": "fn() -> +Selection",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.getSelection",
        "!doc": "The DOM getSelection() method is available on the Window and Document interfaces."
      },
      "adoptNode": {
        "!type": "fn(node: +Node) -> +Element",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.adoptNode",
        "!doc": "Adopts a node from an external document. The node and its subtree is removed from the document it's in (if any), and its ownerDocument is changed to the current document. The node can then be inserted into the current document."
      },
      "createTreeWalker": {
        "!type": "fn(root: +Node, mask: number) -> ?",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.createTreeWalker",
        "!doc": "Returns a new TreeWalker object."
      },
      "createExpression": {
        "!type": "fn(text: string) -> ?",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.createExpression",
        "!doc": "This method compiles an XPathExpression which can then be used for (repeated) evaluations."
      },
      "createNSResolver": {
        "!type": "fn(node: +Node)",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.createNSResolver",
        "!doc": "Creates an XPathNSResolver which resolves namespaces with respect to the definitions in scope for a specified node."
      },
      "scripts": {
        "!type": "+HTMLCollection",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Document.scripts",
        "!doc": "Returns a list of the <script> elements in the document. The returned object is an HTMLCollection."
      },
      "plugins": {
        "!type": "+HTMLCollection",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.plugins",
        "!doc": "Returns an HTMLCollection object containing one or more HTMLEmbedElements or null which represent the <embed> elements in the current document."
      },
      "embeds": {
        "!type": "+HTMLCollection",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.embeds",
        "!doc": "Returns a list of the embedded OBJECTS within the current document."
      },
      "anchors": {
        "!type": "+HTMLCollection",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.anchors",
        "!doc": "Returns a list of all of the anchors in the document."
      },
      "links": {
        "!type": "+HTMLCollection",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.links",
        "!doc": "The links property returns a collection of all AREA elements and anchor elements in a document with a value for the href attribute. "
      },
      "forms": {
        "!type": "+HTMLCollection",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.forms",
        "!doc": "Returns a collection (an HTMLCollection) of the form elements within the current document."
      },
      "styleSheets": {
        "!type": "+HTMLCollection",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.styleSheets",
        "!doc": "Returns a list of stylesheet objects for stylesheets explicitly linked into or embedded in a document."
      }
    },
    "!url": "https://developer.mozilla.org/en/docs/DOM/document",
    "!doc": "Each web page loaded in the browser has its own document object. This object serves as an entry point to the web page's content (the DOM tree, including elements such as <body> and <table>) and provides functionality global to the document (such as obtaining the page's URL and creating new elements in the document)."
  },
  "document": {
    "!type": "+Document",
    "!url": "https://developer.mozilla.org/en/docs/DOM/document",
    "!doc": "Each web page loaded in the browser has its own document object. This object serves as an entry point to the web page's content (the DOM tree, including elements such as <body> and <table>) and provides functionality global to the document (such as obtaining the page's URL and creating new elements in the document)."
  },
  "XMLDocument": {
    "!type": "fn()",
    "prototype": "Document.prototype",
    "!url": "https://developer.mozilla.org/en/docs/Parsing_and_serializing_XML",
    "!doc": "The Web platform provides the following objects for parsing and serializing XML:"
  },
  "Attr": {
    "!type": "fn()",
    "prototype": {
      "isId": {
        "!type": "bool",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Attr",
        "!doc": "This type represents a DOM element's attribute as an object. In most DOM methods, you will probably directly retrieve the attribute as a string (e.g., Element.getAttribute(), but certain functions (e.g., Element.getAttributeNode()) or means of iterating give Attr types."
      },
      "name": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Attr",
        "!doc": "This type represents a DOM element's attribute as an object. In most DOM methods, you will probably directly retrieve the attribute as a string (e.g., Element.getAttribute(), but certain functions (e.g., Element.getAttributeNode()) or means of iterating give Attr types."
      },
      "value": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Attr",
        "!doc": "This type represents a DOM element's attribute as an object. In most DOM methods, you will probably directly retrieve the attribute as a string (e.g., Element.getAttribute(), but certain functions (e.g., Element.getAttributeNode()) or means of iterating give Attr types."
      }
    },
    "!url": "https://developer.mozilla.org/en/docs/DOM/Attr",
    "!doc": "This type represents a DOM element's attribute as an object. In most DOM methods, you will probably directly retrieve the attribute as a string (e.g., Element.getAttribute(), but certain functions (e.g., Element.getAttributeNode()) or means of iterating give Attr types."
  },
  "NodeList": {
    "!type": "fn()",
    "prototype": {
      "length": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.length",
        "!doc": "Returns the number of items in a NodeList."
      },
      "item": {
        "!type": "fn(i: number) -> +Element",
        "!url": "https://developer.mozilla.org/en/docs/DOM/NodeList.item",
        "!doc": "Returns a node from a NodeList by index."
      },
      "<i>": "+Element"
    },
    "!url": "https://developer.mozilla.org/en/docs/DOM/NodeList",
    "!doc": "NodeList objects are collections of nodes returned by getElementsByTagName, getElementsByTagNameNS, Node.childNodes, querySelectorAll, getElementsByClassName, etc."
  },
  "HTMLCollection": {
    "!type": "fn()",
    "prototype": {
      "length": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/HTMLCollection",
        "!doc": "The number of items in the collection."
      },
      "item": {
        "!type": "fn(i: number) -> +Element",
        "!url": "https://developer.mozilla.org/en/docs/DOM/HTMLCollection",
        "!doc": "Returns the specific node at the given zero-based index into the list. Returns null if the index is out of range."
      },
      "namedItem": {
        "!type": "fn(name: string) -> +Element",
        "!url": "https://developer.mozilla.org/en/docs/DOM/HTMLCollection",
        "!doc": "Returns the specific node whose ID or, as a fallback, name matches the string specified by name. Matching by name is only done as a last resort, only in HTML, and only if the referenced element supports the name attribute. Returns null if no node exists by the given name."
      },
      "<i>": "+Element"
    },
    "!url": "https://developer.mozilla.org/en/docs/DOM/HTMLCollection",
    "!doc": "HTMLCollection is an interface representing a generic collection of elements (in document order) and offers methods and properties for traversing the list."
  },
  "NamedNodeMap": {
    "!type": "fn()",
    "prototype": {
      "length": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/NamedNodeMap",
        "!doc": "The number of items in the map."
      },
      "getNamedItem": {
        "!type": "fn(name: string) -> +Node",
        "!url": "https://developer.mozilla.org/en/docs/DOM/NamedNodeMap",
        "!doc": "Gets a node by name."
      },
      "setNamedItem": {
        "!type": "fn(node: +Node) -> +Node",
        "!url": "https://developer.mozilla.org/en/docs/DOM/NamedNodeMap",
        "!doc": "Adds (or replaces) a node by its nodeName."
      },
      "removeNamedItem": {
        "!type": "fn(name: string) -> +Node",
        "!url": "https://developer.mozilla.org/en/docs/DOM/NamedNodeMap",
        "!doc": "Removes a node (or if an attribute, may reveal a default if present)."
      },
      "item": {
        "!type": "fn(i: number) -> +Node",
        "!url": "https://developer.mozilla.org/en/docs/DOM/NamedNodeMap",
        "!doc": "Returns the item at the given index (or null if the index is higher or equal to the number of nodes)."
      },
      "getNamedItemNS": {
        "!type": "fn(ns: string, name: string) -> +Node",
        "!url": "https://developer.mozilla.org/en/docs/DOM/NamedNodeMap",
        "!doc": "Gets a node by namespace and localName."
      },
      "setNamedItemNS": {
        "!type": "fn(node: +Node) -> +Node",
        "!url": "https://developer.mozilla.org/en/docs/DOM/NamedNodeMap",
        "!doc": "Adds (or replaces) a node by its localName and namespaceURI."
      },
      "removeNamedItemNS": {
        "!type": "fn(ns: string, name: string) -> +Node",
        "!url": "https://developer.mozilla.org/en/docs/DOM/NamedNodeMap",
        "!doc": "Removes a node (or if an attribute, may reveal a default if present)."
      },
      "<i>": "+Node"
    },
    "!url": "https://developer.mozilla.org/en/docs/DOM/NamedNodeMap",
    "!doc": "A collection of nodes returned by Element.attributes (also potentially for DocumentType.entities, DocumentType.notations). NamedNodeMaps are not in any particular order (unlike NodeList), although they may be accessed by an index as in an array (they may also be accessed with the item() method). A NamedNodeMap object are live and will thus be auto-updated if changes are made to their contents internally or elsewhere."
  },
  "DocumentFragment": {
    "!type": "fn()",
    "prototype": {
      "!proto": "Node.prototype"
    },
    "!url": "https://developer.mozilla.org/en/docs/DOM/document.createDocumentFragment",
    "!doc": "Creates a new empty DocumentFragment."
  },
  "DOMTokenList": {
    "!type": "fn()",
    "prototype": {
      "length": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/DOMTokenList",
        "!doc": "The amount of items in the list."
      },
      "item": {
        "!type": "fn(i: number) -> string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/DOMTokenList",
        "!doc": "Returns an item in the list by its index."
      },
      "contains": {
        "!type": "fn(token: string) -> bool",
        "!url": "https://developer.mozilla.org/en/docs/DOM/DOMTokenList",
        "!doc": "Return true if the underlying string contains token, otherwise false."
      },
      "add": {
        "!type": "fn(token: string)",
        "!url": "https://developer.mozilla.org/en/docs/DOM/DOMTokenList",
        "!doc": "Adds token to the underlying string."
      },
      "remove": {
        "!type": "fn(token: string)",
        "!url": "https://developer.mozilla.org/en/docs/DOM/DOMTokenList",
        "!doc": "Remove token from the underlying string."
      },
      "toggle": {
        "!type": "fn(token: string) -> bool",
        "!url": "https://developer.mozilla.org/en/docs/DOM/DOMTokenList",
        "!doc": "Removes token from string and returns false. If token doesn't exist it's added and the function returns true."
      },
      "<i>": "string"
    },
    "!url": "https://developer.mozilla.org/en/docs/DOM/DOMTokenList",
    "!doc": "This type represents a set of space-separated tokens. Commonly returned by HTMLElement.classList, HTMLLinkElement.relList, HTMLAnchorElement.relList or HTMLAreaElement.relList. It is indexed beginning with 0 as with JavaScript arrays. DOMTokenList is always case-sensitive."
  },
  "XPathResult": {
    "!type": "fn()",
    "prototype": {
      "boolValue": "bool",
      "invalidIteratorState": {
        "!type": "bool",
        "!url": "https://developer.mozilla.org/en/docs/Introduction_to_using_XPath_in_JavaScript",
        "!doc": "This document describes the interface for using XPath in JavaScript internally, in extensions, and from websites. Mozilla implements a fair amount of the DOM 3 XPath. Which means that XPath expressions can be run against both HTML and XML documents."
      },
      "numberValue": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/XPathResult",
        "!doc": "Refer to nsIDOMXPathResult for more detail."
      },
      "resultType": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/document.evaluate",
        "!doc": "Returns an XPathResult based on an XPath expression and other given parameters."
      },
      "singleNodeValue": {
        "!type": "+Element",
        "!url": "https://developer.mozilla.org/en/docs/Introduction_to_using_XPath_in_JavaScript",
        "!doc": "This document describes the interface for using XPath in JavaScript internally, in extensions, and from websites. Mozilla implements a fair amount of the DOM 3 XPath. Which means that XPath expressions can be run against both HTML and XML documents."
      },
      "snapshotLength": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/XPathResult",
        "!doc": "Refer to nsIDOMXPathResult for more detail."
      },
      "stringValue": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en/docs/Introduction_to_using_XPath_in_JavaScript",
        "!doc": "This document describes the interface for using XPath in JavaScript internally, in extensions, and from websites. Mozilla implements a fair amount of the DOM 3 XPath. Which means that XPath expressions can be run against both HTML and XML documents."
      },
      "iterateNext": {
        "!type": "fn()",
        "!url": "https://developer.mozilla.org/en/docs/Introduction_to_using_XPath_in_JavaScript",
        "!doc": "This document describes the interface for using XPath in JavaScript internally, in extensions, and from websites. Mozilla implements a fair amount of the DOM 3 XPath. Which means that XPath expressions can be run against both HTML and XML documents."
      },
      "snapshotItem": {
        "!type": "fn()",
        "!url": "https://developer.mozilla.org/en-US/docs/XPathResult#snapshotItem()"
      },
      "ANY_TYPE": "number",
      "NUMBER_TYPE": "number",
      "STRING_TYPE": "number",
      "BOOL_TYPE": "number",
      "UNORDERED_NODE_ITERATOR_TYPE": "number",
      "ORDERED_NODE_ITERATOR_TYPE": "number",
      "UNORDERED_NODE_SNAPSHOT_TYPE": "number",
      "ORDERED_NODE_SNAPSHOT_TYPE": "number",
      "ANY_UNORDERED_NODE_TYPE": "number",
      "FIRST_ORDERED_NODE_TYPE": "number"
    },
    "!url": "https://developer.mozilla.org/en/docs/XPathResult",
    "!doc": "Refer to nsIDOMXPathResult for more detail."
  },
  "ClientRect": {
    "!type": "fn()",
    "prototype": {
      "top": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.getClientRects",
        "!doc": "Top of the box, in pixels, relative to the viewport."
      },
      "left": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.getClientRects",
        "!doc": "Left of the box, in pixels, relative to the viewport."
      },
      "bottom": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.getClientRects",
        "!doc": "Bottom of the box, in pixels, relative to the viewport."
      },
      "right": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/element.getClientRects",
        "!doc": "Right of the box, in pixels, relative to the viewport."
      }
    },
    "!url": "https://developer.mozilla.org/en/docs/DOM/element.getClientRects",
    "!doc": "Returns a collection of rectangles that indicate the bounding rectangles for each box in a client."
  },
  "Event": {
    "!type": "fn()",
    "prototype": {
      "stopPropagation": {
        "!type": "fn()",
        "!url": "https://developer.mozilla.org/en/docs/DOM/event.stopPropagation",
        "!doc": "Prevents further propagation of the current event."
      },
      "preventDefault": {
        "!type": "fn()",
        "!url": "https://developer.mozilla.org/en/docs/DOM/event.preventDefault",
        "!doc": "Cancels the event if it is cancelable, without stopping further propagation of the event."
      },
      "initEvent": {
        "!type": "fn(type: string, bubbles: bool, cancelable: bool)",
        "!url": "https://developer.mozilla.org/en/docs/DOM/event.initEvent",
        "!doc": "The initEvent method is used to initialize the value of an event created using document.createEvent."
      },
      "stopImmediatePropagation": {
        "!type": "fn()",
        "!url": "https://developer.mozilla.org/en/docs/DOM/event.stopImmediatePropagation",
        "!doc": "Prevents other listeners of the same event to be called."
      },
      "NONE": "number",
      "CAPTURING_PHASE": "number",
      "AT_TARGET": "number",
      "BUBBLING_PHASE": "number",
      "MOUSEDOWN": "number",
      "MOUSEUP": "number",
      "MOUSEOVER": "number",
      "MOUSEOUT": "number",
      "MOUSEMOVE": "number",
      "MOUSEDRAG": "number",
      "CLICK": "number",
      "DBLCLICK": "number",
      "KEYDOWN": "number",
      "KEYUP": "number",
      "KEYPRESS": "number",
      "DRAGDROP": "number",
      "FOCUS": "number",
      "BLUR": "number",
      "SELECT": "number",
      "CHANGE": "number",
      "target": {
        "!type": "+Element",
        "!url": "https://developer.mozilla.org/en/docs/DOM/EventTarget",
        "!doc": "An EventTarget is a DOM interface implemented by objects that can receive DOM events and have listeners for them. The most common EventTargets are DOM elements, although other objects can be EventTargets too, for example document, window, XMLHttpRequest, and others."
      },
      "relatedTarget": {
        "!type": "+Element",
        "!url": "https://developer.mozilla.org/en/docs/DOM/event.relatedTarget",
        "!doc": "Identifies a secondary target for the event."
      },
      "pageX": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/event.pageX",
        "!doc": "Returns the horizontal coordinate of the event relative to whole document."
      },
      "pageY": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/event.pageY",
        "!doc": "Returns the vertical coordinate of the event relative to the whole document."
      },
      "clientX": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/event.clientX",
        "!doc": "Returns the horizontal coordinate within the application's client area at which the event occurred (as opposed to the coordinates within the page). For example, clicking in the top-left corner of the client area will always result in a mouse event with a clientX value of 0, regardless of whether the page is scrolled horizontally."
      },
      "clientY": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/event.clientY",
        "!doc": "Returns the vertical coordinate within the application's client area at which the event occurred (as opposed to the coordinates within the page). For example, clicking in the top-left corner of the client area will always result in a mouse event with a clientY value of 0, regardless of whether the page is scrolled vertically."
      },
      "keyCode": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/event.keyCode",
        "!doc": "Returns the Unicode value of a non-character key in a keypress event or any key in any other type of keyboard event."
      },
      "charCode": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/event.charCode",
        "!doc": "Returns the Unicode value of a character key pressed during a keypress event."
      },
      "which": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/event.which",
        "!doc": "Returns the numeric keyCode of the key pressed, or the character code (charCode) for an alphanumeric key pressed."
      },
      "button": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/event.button",
        "!doc": "Indicates which mouse button caused the event."
      },
      "shiftKey": {
        "!type": "bool",
        "!url": "https://developer.mozilla.org/en/docs/DOM/event.shiftKey",
        "!doc": "Indicates whether the SHIFT key was pressed when the event fired."
      },
      "ctrlKey": {
        "!type": "bool",
        "!url": "https://developer.mozilla.org/en/docs/DOM/event.ctrlKey",
        "!doc": "Indicates whether the CTRL key was pressed when the event fired."
      },
      "altKey": {
        "!type": "bool",
        "!url": "https://developer.mozilla.org/en/docs/DOM/event.altKey",
        "!doc": "Indicates whether the ALT key was pressed when the event fired."
      },
      "metaKey": {
        "!type": "bool",
        "!url": "https://developer.mozilla.org/en/docs/DOM/event.metaKey",
        "!doc": "Indicates whether the META key was pressed when the event fired."
      },
      "returnValue": {
        "!type": "bool",
        "!url": "https://developer.mozilla.org/en/docs/DOM/window.onbeforeunload",
        "!doc": "An event that fires when a window is about to unload its resources. The document is still visible and the event is still cancelable."
      },
      "cancelBubble": {
        "!type": "bool",
        "!url": "https://developer.mozilla.org/en/docs/DOM/event.cancelBubble",
        "!doc": "bool is the boolean value of true or false."
      },
      "dataTransfer": {
        "dropEffect": {
          "!type": "string",
          "!url": "https://developer.mozilla.org/en/docs/DragDrop/DataTransfer",
          "!doc": "The actual effect that will be used, and should always be one of the possible values of effectAllowed."
        },
        "effectAllowed": {
          "!type": "string",
          "!url": "https://developer.mozilla.org/en/docs/DragDrop/Drag_Operations",
          "!doc": "Specifies the effects that are allowed for this drag."
        },
        "files": {
          "!type": "+FileList",
          "!url": "https://developer.mozilla.org/en/docs/DragDrop/DataTransfer",
          "!doc": "Contains a list of all the local files available on the data transfer."
        },
        "types": {
          "!type": "[string]",
          "!url": "https://developer.mozilla.org/en-US/docs/DragDrop/DataTransfer",
          "!doc": "Holds a list of the format types of the data that is stored for the first item, in the same order the data was added. An empty list will be returned if no data was added."
        },
        "addElement": {
          "!type": "fn(element: +Element)",
          "!url": "https://developer.mozilla.org/en/docs/DragDrop/DataTransfer",
          "!doc": "Set the drag source."
        },
        "clearData": {
          "!type": "fn(type?: string)",
          "!url": "https://developer.mozilla.org/en/docs/DragDrop/Drag_Operations",
          "!doc": "Remove the data associated with a given type."
        },
        "getData": {
          "!type": "fn(type: string) -> string",
          "!url": "https://developer.mozilla.org/en/docs/DragDrop/Drag_Operations",
          "!doc": "Retrieves the data for a given type, or an empty string if data for that type does not exist or the data transfer contains no data."
        },
        "setData": {
          "!type": "fn(type: string, data: string)",
          "!url": "https://developer.mozilla.org/en/docs/DragDrop/Drag_Operations",
          "!doc": "Set the data for a given type."
        },
        "setDragImage": {
          "!type": "fn(image: +Element)",
          "!url": "https://developer.mozilla.org/en/docs/DragDrop/Drag_Operations",
          "!doc": "Set the image to be used for dragging if a custom one is desired."
        },
        "!url": "https://developer.mozilla.org/en/docs/DragDrop/DataTransfer",
        "!doc": "This object is available from the dataTransfer property of all drag events. It cannot be created separately."
      }
    },
    "!url": "https://developer.mozilla.org/en-US/docs/DOM/event",
    "!doc": "The DOM Event interface is accessible from within the handler function, via the event object passed as the first argument."
  },
  "TouchEvent": {
    "!type": "fn()",
    "prototype": "Event.prototype",
    "!url": "https://developer.mozilla.org/en/docs/DOM/Touch_events",
    "!doc": "In order to provide quality support for touch-based user interfaces, touch events offer the ability to interpret finger activity on touch screens or trackpads."
  },
  "WheelEvent": {
    "!type": "fn()",
    "prototype": "Event.prototype",
    "!url": "https://developer.mozilla.org/en/docs/DOM/WheelEvent",
    "!doc": "The DOM WheelEvent represents events that occur due to the user moving a mouse wheel or similar input device."
  },
  "MouseEvent": {
    "!type": "fn()",
    "prototype": "Event.prototype",
    "!url": "https://developer.mozilla.org/en/docs/DOM/MouseEvent",
    "!doc": "The DOM MouseEvent represents events that occur due to the user interacting with a pointing device (such as a mouse). It's represented by the nsINSDOMMouseEvent interface, which extends the nsIDOMMouseEvent interface."
  },
  "KeyboardEvent": {
    "!type": "fn()",
    "prototype": "Event.prototype",
    "!url": "https://developer.mozilla.org/en/docs/DOM/KeyboardEvent",
    "!doc": "KeyboardEvent objects describe a user interaction with the keyboard. Each event describes a key; the event type (keydown, keypress, or keyup) identifies what kind of activity was performed."
  },
  "HashChangeEvent": {
    "!type": "fn()",
    "prototype": "Event.prototype",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.onhashchange",
    "!doc": "The hashchange event fires when a window's hash changes."
  },
  "ErrorEvent": {
    "!type": "fn()",
    "prototype": "Event.prototype",
    "!url": "https://developer.mozilla.org/en/docs/DOM/DOM_event_reference/error",
    "!doc": "The error event is fired whenever a resource fails to load."
  },
  "CustomEvent": {
    "!type": "fn()",
    "prototype": "Event.prototype",
    "!url": "https://developer.mozilla.org/en/docs/DOM/Event/CustomEvent",
    "!doc": "The DOM CustomEvent are events initialized by an application for any purpose."
  },
  "BeforeLoadEvent": {
    "!type": "fn()",
    "prototype": "Event.prototype",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window",
    "!doc": "This section provides a brief reference for all of the methods, properties, and events available through the DOM window object. The window object implements the Window interface, which in turn inherits from the AbstractView interface. Some additional global functions, namespaces objects, and constructors, not typically associated with the window, but available on it, are listed in the JavaScript Reference."
  },
  "WebSocket": {
    "!type": "fn(url: string)",
    "prototype": {
      "close": {
        "!type": "fn()",
        "!url": "https://developer.mozilla.org/en/docs/WebSockets/WebSockets_reference/CloseEvent",
        "!doc": "A CloseEvent is sent to clients using WebSockets when the connection is closed. This is delivered to the listener indicated by the WebSocket object's onclose attribute."
      },
      "send": {
        "!type": "fn(data: string)",
        "!url": "https://developer.mozilla.org/en/docs/WebSockets/WebSockets_reference/WebSocket",
        "!doc": "The WebSocket object provides the API for creating and managing a WebSocket connection to a server, as well as for sending and receiving data on the connection."
      },
      "binaryType": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en/docs/WebSockets/WebSockets_reference/WebSocket",
        "!doc": "The WebSocket object provides the API for creating and managing a WebSocket connection to a server, as well as for sending and receiving data on the connection."
      },
      "bufferedAmount": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/WebSockets/Writing_WebSocket_client_applications",
        "!doc": "WebSockets is a technology that makes it possible to open an interactive communication session between the user's browser and a server. Using a WebSocket connection, Web applications can perform real-time communication instead of having to poll for changes back and forth."
      },
      "extensions": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en/docs/WebSockets/WebSockets_reference/WebSocket",
        "!doc": "The WebSocket object provides the API for creating and managing a WebSocket connection to a server, as well as for sending and receiving data on the connection."
      },
      "onclose": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/WebSockets/WebSockets_reference/CloseEvent",
        "!doc": "A CloseEvent is sent to clients using WebSockets when the connection is closed. This is delivered to the listener indicated by the WebSocket object's onclose attribute."
      },
      "onerror": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/WebSockets/Writing_WebSocket_client_applications",
        "!doc": "WebSockets is a technology that makes it possible to open an interactive communication session between the user's browser and a server. Using a WebSocket connection, Web applications can perform real-time communication instead of having to poll for changes back and forth."
      },
      "onmessage": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/WebSockets/WebSockets_reference/WebSocket",
        "!doc": "The WebSocket object provides the API for creating and managing a WebSocket connection to a server, as well as for sending and receiving data on the connection."
      },
      "onopen": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/WebSockets/WebSockets_reference/WebSocket",
        "!doc": "The WebSocket object provides the API for creating and managing a WebSocket connection to a server, as well as for sending and receiving data on the connection."
      },
      "protocol": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en/docs/WebSockets",
        "!doc": "WebSockets is an advanced technology that makes it possible to open an interactive communication session between the user's browser and a server. With this API, you can send messages to a server and receive event-driven responses without having to poll the server for a reply."
      },
      "url": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en/docs/WebSockets/Writing_WebSocket_client_applications",
        "!doc": "WebSockets is a technology that makes it possible to open an interactive communication session between the user's browser and a server. Using a WebSocket connection, Web applications can perform real-time communication instead of having to poll for changes back and forth."
      },
      "CONNECTING": "number",
      "OPEN": "number",
      "CLOSING": "number",
      "CLOSED": "number"
    },
    "!url": "https://developer.mozilla.org/en/docs/WebSockets",
    "!doc": "WebSockets is an advanced technology that makes it possible to open an interactive communication session between the user's browser and a server. With this API, you can send messages to a server and receive event-driven responses without having to poll the server for a reply."
  },
  "Worker": {
    "!type": "fn(scriptURL: string)",
    "prototype": {
      "postMessage": {
        "!type": "fn(message: ?)",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Worker",
        "!doc": "Sends a message to the worker's inner scope. This accepts a single parameter, which is the data to send to the worker. The data may be any value or JavaScript object handled by the structured clone algorithm, which includes cyclical references."
      },
      "terminate": {
        "!type": "fn()",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Worker",
        "!doc": "Immediately terminates the worker. This does not offer the worker an opportunity to finish its operations; it is simply stopped at once."
      },
      "onmessage": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Worker",
        "!doc": "An event listener that is called whenever a MessageEvent with type message bubbles through the worker. The message is stored in the event's data member."
      },
      "onerror": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Worker",
        "!doc": "An event listener that is called whenever an ErrorEvent with type error bubbles through the worker."
      }
    },
    "!url": "https://developer.mozilla.org/en/docs/DOM/Worker",
    "!doc": "Workers are background tasks that can be easily created and can send messages back to their creators. Creating a worker is as simple as calling the Worker() constructor, specifying a script to be run in the worker thread."
  },
  "localStorage": {
    "setItem": {
      "!type": "fn(name: string, value: string)",
      "!url": "https://developer.mozilla.org/en/docs/DOM/Storage",
      "!doc": "Store an item in storage."
    },
    "getItem": {
      "!type": "fn(name: string) -> string",
      "!url": "https://developer.mozilla.org/en/docs/DOM/Storage",
      "!doc": "Retrieve an item from storage."
    },
    "!url": "https://developer.mozilla.org/en/docs/DOM/Storage",
    "!doc": "The DOM Storage mechanism is a means through which string key/value pairs can be securely stored and later retrieved for use."
  },
  "sessionStorage": {
    "setItem": {
      "!type": "fn(name: string, value: string)",
      "!url": "https://developer.mozilla.org/en/docs/DOM/Storage",
      "!doc": "Store an item in storage."
    },
    "getItem": {
      "!type": "fn(name: string) -> string",
      "!url": "https://developer.mozilla.org/en/docs/DOM/Storage",
      "!doc": "Retrieve an item from storage."
    },
    "!url": "https://developer.mozilla.org/en/docs/DOM/Storage",
    "!doc": "This is a global object (sessionStorage) that maintains a storage area that's available for the duration of the page session. A page session lasts for as long as the browser is open and survives over page reloads and restores. Opening a page in a new tab or window will cause a new session to be initiated."
  },
  "FileList": {
    "!type": "fn()",
    "prototype": {
      "length": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/FileList",
        "!doc": "A read-only value indicating the number of files in the list."
      },
      "item": {
        "!type": "fn(i: number) -> +File",
        "!url": "https://developer.mozilla.org/en/docs/DOM/FileList",
        "!doc": "Returns a File object representing the file at the specified index in the file list."
      },
      "<i>": "+File"
    },
    "!url": "https://developer.mozilla.org/en/docs/DOM/FileList",
    "!doc": "An object of this type is returned by the files property of the HTML input element; this lets you access the list of files selected with the <input type=\"file\"> element. It's also used for a list of files dropped into web content when using the drag and drop API."
  },
  "File": {
    "!type": "fn()",
    "prototype": {
      "!proto": "Blob.prototype",
      "fileName": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/File.fileName",
        "!doc": "Returns the name of the file. For security reasons the path is excluded from this property."
      },
      "fileSize": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/File.fileSize",
        "!doc": "Returns the size of a file in bytes."
      },
      "lastModifiedDate": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/DOM/File.lastModifiedDate",
        "!doc": "Returns the last modified date of the file. Files without a known last modified date use the current date instead."
      },
      "name": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/File.name",
        "!doc": "Returns the name of the file. For security reasons, the path is excluded from this property."
      }
    },
    "!url": "https://developer.mozilla.org/en/docs/DOM/File",
    "!doc": "The File object provides information about -- and access to the contents of -- files. These are generally retrieved from a FileList object returned as a result of a user selecting files using the input element, or from a drag and drop operation's DataTransfer object."
  },
  "Blob": {
    "!type": "fn(parts: [?], properties?: ?)",
    "prototype": {
      "size": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Blob",
        "!doc": "The size, in bytes, of the data contained in the Blob object. Read only."
      },
      "type": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Blob",
        "!doc": "An ASCII-encoded string, in all lower case, indicating the MIME type of the data contained in the Blob. If the type is unknown, this string is empty. Read only."
      },
      "slice": {
        "!type": "fn(start: number, end?: number, type?: string) -> +Blob",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Blob",
        "!doc": "Returns a new Blob object containing the data in the specified range of bytes of the source Blob."
      }
    },
    "!url": "https://developer.mozilla.org/en/docs/DOM/Blob",
    "!doc": "A Blob object represents a file-like object of immutable, raw data. Blobs represent data that isn't necessarily in a JavaScript-native format. The File interface is based on Blob, inheriting blob functionality and expanding it to support files on the user's system."
  },
  "FileReader": {
    "!type": "fn()",
    "prototype": {
      "abort": {
        "!type": "fn()",
        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
        "!doc": "Aborts the read operation. Upon return, the readyState will be DONE."
      },
      "readAsArrayBuffer": {
        "!type": "fn(blob: +Blob)",
        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
        "!doc": "Starts reading the contents of the specified Blob, producing an ArrayBuffer."
      },
      "readAsBinaryString": {
        "!type": "fn(blob: +Blob)",
        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
        "!doc": "Starts reading the contents of the specified Blob, producing raw binary data."
      },
      "readAsDataURL": {
        "!type": "fn(blob: +Blob)",
        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
        "!doc": "Starts reading the contents of the specified Blob, producing a data: url."
      },
      "readAsText": {
        "!type": "fn(blob: +Blob, encoding?: string)",
        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
        "!doc": "Starts reading the contents of the specified Blob, producing a string."
      },
      "EMPTY": "number",
      "LOADING": "number",
      "DONE": "number",
      "error": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
        "!doc": "The error that occurred while reading the file. Read only."
      },
      "readyState": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
        "!doc": "Indicates the state of the FileReader. This will be one of the State constants. Read only."
      },
      "result": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
        "!doc": "The file's contents. This property is only valid after the read operation is complete, and the format of the data depends on which of the methods was used to initiate the read operation. Read only."
      },
      "onabort": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
        "!doc": "Called when the read operation is aborted."
      },
      "onerror": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
        "!doc": "Called when an error occurs."
      },
      "onload": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
        "!doc": "Called when the read operation is successfully completed."
      },
      "onloadend": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
        "!doc": "Called when the read is completed, whether successful or not. This is called after either onload or onerror."
      },
      "onloadstart": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
        "!doc": "Called when reading the data is about to begin."
      },
      "onprogress": {
        "!type": "?",
        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
        "!doc": "Called periodically while the data is being read."
      }
    },
    "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
    "!doc": "The FileReader object lets web applications asynchronously read the contents of files (or raw data buffers) stored on the user's computer, using File or Blob objects to specify the file or data to read. File objects may be obtained from a FileList object returned as a result of a user selecting files using the <input> element, from a drag and drop operation's DataTransfer object, or from the mozGetAsFile() API on an HTMLCanvasElement."
  },
  "Range": {
    "!type": "fn()",
    "prototype": {
      "collapsed": {
        "!type": "bool",
        "!url": "https://developer.mozilla.org/en/docs/DOM/range.collapsed",
        "!doc": "Returns a boolean indicating whether the range's start and end points are at the same position."
      },
      "commonAncestorContainer": {
        "!type": "+Element",
        "!url": "https://developer.mozilla.org/en/docs/DOM/range.commonAncestorContainer",
        "!doc": "Returns the deepest Node that contains the  startContainer and  endContainer Nodes."
      },
      "endContainer": {
        "!type": "+Element",
        "!url": "https://developer.mozilla.org/en/docs/DOM/range.endContainer",
        "!doc": "Returns the Node within which the Range ends."
      },
      "endOffset": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/range.endOffset",
        "!doc": "Returns a number representing where in the  endContainer the Range ends."
      },
      "startContainer": {
        "!type": "+Element",
        "!url": "https://developer.mozilla.org/en/docs/DOM/range.startContainer",
        "!doc": "Returns the Node within which the Range starts."
      },
      "startOffset": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/range.startOffset",
        "!doc": "Returns a number representing where in the startContainer the Range starts."
      },
      "setStart": {
        "!type": "fn(node: +Element, offset: number)",
        "!url": "https://developer.mozilla.org/en/docs/DOM/range.setStart",
        "!doc": "Sets the start position of a Range."
      },
      "setEnd": {
        "!type": "fn(node: +Element, offset: number)",
        "!url": "https://developer.mozilla.org/en/docs/DOM/range.setEnd",
        "!doc": "Sets the end position of a Range."
      },
      "setStartBefore": {
        "!type": "fn(node: +Element)",
        "!url": "https://developer.mozilla.org/en/docs/DOM/range.setStartBefore",
        "!doc": "Sets the start position of a Range relative to another Node."
      },
      "setStartAfter": {
        "!type": "fn(node: +Element)",
        "!url": "https://developer.mozilla.org/en/docs/DOM/range.setStartAfter",
        "!doc": "Sets the start position of a Range relative to a Node."
      },
      "setEndBefore": {
        "!type": "fn(node: +Element)",
        "!url": "https://developer.mozilla.org/en/docs/DOM/range.setEndBefore",
        "!doc": "Sets the end position of a Range relative to another Node."
      },
      "setEndAfter": {
        "!type": "fn(node: +Element)",
        "!url": "https://developer.mozilla.org/en/docs/DOM/range.setEndAfter",
        "!doc": "Sets the end position of a Range relative to another Node."
      },
      "selectNode": {
        "!type": "fn(node: +Element)",
        "!url": "https://developer.mozilla.org/en/docs/DOM/range.selectNode",
        "!doc": "Sets the Range to contain the Node and its contents."
      },
      "selectNodeContents": {
        "!type": "fn(node: +Element)",
        "!url": "https://developer.mozilla.org/en/docs/DOM/range.selectNodeContents",
        "!doc": "Sets the Range to contain the contents of a Node."
      },
      "collapse": {
        "!type": "fn(toStart: bool)",
        "!url": "https://developer.mozilla.org/en/docs/DOM/range.collapse",
        "!doc": "Collapses the Range to one of its boundary points."
      },
      "cloneContents": {
        "!type": "fn() -> +DocumentFragment",
        "!url": "https://developer.mozilla.org/en/docs/DOM/range.cloneContents",
        "!doc": "Returns a DocumentFragment copying the Nodes of a Range."
      },
      "deleteContents": {
        "!type": "fn()",
        "!url": "https://developer.mozilla.org/en/docs/DOM/range.deleteContents",
        "!doc": "Removes the contents of a Range from the Document."
      },
      "extractContents": {
        "!type": "fn() -> +DocumentFragment",
        "!url": "https://developer.mozilla.org/en/docs/DOM/range.extractContents",
        "!doc": "Moves contents of a Range from the document tree into a DocumentFragment."
      },
      "insertNode": {
        "!type": "fn(node: +Element)",
        "!url": "https://developer.mozilla.org/en/docs/DOM/range.insertNode",
        "!doc": "Insert a node at the start of a Range."
      },
      "surroundContents": {
        "!type": "fn(node: +Element)",
        "!url": "https://developer.mozilla.org/en/docs/DOM/range.surroundContents",
        "!doc": "Moves content of a Range into a new node, placing the new node at the start of the specified range."
      },
      "compareBoundaryPoints": {
        "!type": "fn(how: number, other: +Range) -> number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/range.compareBoundaryPoints",
        "!doc": "Compares the boundary points of two Ranges."
      },
      "cloneRange": {
        "!type": "fn() -> +Range",
        "!url": "https://developer.mozilla.org/en/docs/DOM/range.cloneRange",
        "!doc": "Returns a Range object with boundary points identical to the cloned Range."
      },
      "detach": {
        "!type": "fn()",
        "!url": "https://developer.mozilla.org/en/docs/DOM/range.detach",
        "!doc": "Releases a Range from use to improve performance. This lets the browser choose to release resources associated with this Range. Subsequent attempts to use the detached range will result in a DOMException being thrown with an error code of INVALID_STATE_ERR."
      },
      "END_TO_END": "number",
      "END_TO_START": "number",
      "START_TO_END": "number",
      "START_TO_START": "number"
    },
    "!url": "https://developer.mozilla.org/en/docs/DOM/range.detach",
    "!doc": "Releases a Range from use to improve performance. This lets the browser choose to release resources associated with this Range. Subsequent attempts to use the detached range will result in a DOMException being thrown with an error code of INVALID_STATE_ERR."
  },
  "XMLHttpRequest": {
    "!type": "fn()",
    "prototype": {
      "abort": {
        "!type": "fn()",
        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
        "!doc": "Aborts the request if it has already been sent."
      },
      "getAllResponseHeaders": {
        "!type": "fn() -> string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
        "!doc": "Returns all the response headers as a string, or null if no response has been received. Note: For multipart requests, this returns the headers from the current part of the request, not from the original channel."
      },
      "getResponseHeader": {
        "!type": "fn(header: string) -> string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
        "!doc": "Returns the string containing the text of the specified header, or null if either the response has not yet been received or the header doesn't exist in the response."
      },
      "open": {
        "!type": "fn(method: string, url: string, async?: bool, user?: string, password?: string)",
        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
        "!doc": "Initializes a request."
      },
      "overrideMimeType": {
        "!type": "fn(type: string)",
        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
        "!doc": "Overrides the MIME type returned by the server."
      },
      "send": {
        "!type": "fn(data?: string)",
        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
        "!doc": "Sends the request. If the request is asynchronous (which is the default), this method returns as soon as the request is sent. If the request is synchronous, this method doesn't return until the response has arrived."
      },
      "setRequestHeader": {
        "!type": "fn(header: string, value: string)",
        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
        "!doc": "Sets the value of an HTTP request header.You must call setRequestHeader() after open(), but before send()."
      },
      "onreadystatechange": {
        "!type": "fn()",
        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
        "!doc": "A JavaScript function object that is called whenever the readyState attribute changes."
      },
      "readyState": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
        "!doc": "The state of the request. (0=unsent, 1=opened, 2=headers_received, 3=loading, 4=done)"
      },
      "response": {
        "!type": "+Document",
        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
        "!doc": "The response entity body according to responseType, as an ArrayBuffer, Blob, Document, JavaScript object (for \"json\"), or string. This is null if the request is not complete or was not successful."
      },
      "responseText": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
        "!doc": "The response to the request as text, or null if the request was unsuccessful or has not yet been sent."
      },
      "responseType": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
        "!doc": "Can be set to change the response type."
      },
      "responseXML": {
        "!type": "+Document",
        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
        "!doc": "The response to the request as a DOM Document object, or null if the request was unsuccessful, has not yet been sent, or cannot be parsed as XML or HTML."
      },
      "status": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
        "!doc": "The status of the response to the request. This is the HTTP result code"
      },
      "statusText": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
        "!doc": "The response string returned by the HTTP server. Unlike status, this includes the entire text of the response message (\"200 OK\", for example)."
      },
      "timeout": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest/Synchronous_and_Asynchronous_Requests",
        "!doc": "The number of milliseconds a request can take before automatically being terminated. A value of 0 (which is the default) means there is no timeout."
      },
      "UNSENT": "number",
      "OPENED": "number",
      "HEADERS_RECEIVED": "number",
      "LOADING": "number",
      "DONE": "number"
    },
    "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
    "!doc": "XMLHttpRequest is a JavaScript object that was designed by Microsoft and adopted by Mozilla, Apple, and Google. It's now being standardized in the W3C. It provides an easy way to retrieve data at a URL. Despite its name, XMLHttpRequest can be used to retrieve any type of data, not just XML, and it supports protocols other than HTTP (including file and ftp)."
  },
  "DOMParser": {
    "!type": "fn()",
    "prototype": {
      "parseFromString": {
        "!type": "fn(data: string, mime: string) -> +Document",
        "!url": "https://developer.mozilla.org/en/docs/DOM/DOMParser",
        "!doc": "DOMParser can parse XML or HTML source stored in a string into a DOM Document. DOMParser is specified in DOM Parsing and Serialization."
      }
    },
    "!url": "https://developer.mozilla.org/en/docs/DOM/DOMParser",
    "!doc": "DOMParser can parse XML or HTML source stored in a string into a DOM Document. DOMParser is specified in DOM Parsing and Serialization."
  },
  "Selection": {
    "!type": "fn()",
    "prototype": {
      "anchorNode": {
        "!type": "+Element",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/anchorNode",
        "!doc": "Returns the node in which the selection begins."
      },
      "anchorOffset": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/anchorOffset",
        "!doc": "Returns the number of characters that the selection's anchor is offset within the anchorNode."
      },
      "focusNode": {
        "!type": "+Element",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/focusNode",
        "!doc": "Returns the node in which the selection ends."
      },
      "focusOffset": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/focusOffset",
        "!doc": "Returns the number of characters that the selection's focus is offset within the focusNode. "
      },
      "isCollapsed": {
        "!type": "bool",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/isCollapsed",
        "!doc": "Returns a boolean indicating whether the selection's start and end points are at the same position."
      },
      "rangeCount": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/rangeCount",
        "!doc": "Returns the number of ranges in the selection."
      },
      "getRangeAt": {
        "!type": "fn(i: number) -> +Range",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/getRangeAt",
        "!doc": "Returns a range object representing one of the ranges currently selected."
      },
      "collapse": {
        "!type": "fn()",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/collapse",
        "!doc": "Collapses the current selection to a single point. The document is not modified. If the content is focused and editable, the caret will blink there."
      },
      "extend": {
        "!type": "fn(node: +Element, offset: number)",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/extend",
        "!doc": "Moves the focus of the selection to a specified point. The anchor of the selection does not move. The selection will be from the anchor to the new focus regardless of direction."
      },
      "collapseToStart": {
        "!type": "fn()",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/collapseToStart",
        "!doc": "Collapses the selection to the start of the first range in the selection.  If the content of the selection is focused and editable, the caret will blink there."
      },
      "collapseToEnd": {
        "!type": "fn()",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/collapseToEnd",
        "!doc": "Collapses the selection to the end of the last range in the selection.  If the content the selection is in is focused and editable, the caret will blink there."
      },
      "selectAllChildren": {
        "!type": "fn(node: +Element)",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/selectAllChildren",
        "!doc": "Adds all the children of the specified node to the selection. Previous selection is lost."
      },
      "addRange": {
        "!type": "fn(range: +Range)",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/addRange",
        "!doc": "Adds a Range to a Selection."
      },
      "removeRange": {
        "!type": "fn(range: +Range)",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/removeRange",
        "!doc": "Removes a range from the selection."
      },
      "removeAllRanges": {
        "!type": "fn()",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/removeAllRanges",
        "!doc": "Removes all ranges from the selection, leaving the anchorNode and focusNode properties equal to null and leaving nothing selected. "
      },
      "deleteFromDocument": {
        "!type": "fn()",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/deleteFromDocument",
        "!doc": "Deletes the actual text being represented by a selection object from the document's DOM."
      },
      "containsNode": {
        "!type": "fn(node: +Element) -> bool",
        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/containsNode",
        "!doc": "Indicates if the node is part of the selection."
      }
    },
    "!url": "https://developer.mozilla.org/en/docs/DOM/Selection",
    "!doc": "Selection is the class of the object returned by window.getSelection() and other methods. It represents the text selection in the greater page, possibly spanning multiple elements, when the user drags over static text and other parts of the page. For information about text selection in an individual text editing element."
  },
  "console": {
    "error": {
      "!type": "fn(text: string)",
      "!url": "https://developer.mozilla.org/en/docs/DOM/console.error",
      "!doc": "Outputs an error message to the Web Console."
    },
    "info": {
      "!type": "fn(text: string)",
      "!url": "https://developer.mozilla.org/en/docs/DOM/console.info",
      "!doc": "Outputs an informational message to the Web Console."
    },
    "log": {
      "!type": "fn(text: string)",
      "!url": "https://developer.mozilla.org/en/docs/DOM/console.log",
      "!doc": "Outputs a message to the Web Console."
    },
    "warn": {
      "!type": "fn(text: string)",
      "!url": "https://developer.mozilla.org/en/docs/DOM/console.warn",
      "!doc": "Outputs a warning message to the Web Console."
    },
    "!url": "https://developer.mozilla.org/en/docs/DOM/console",
    "!doc": "The console object provides access to the browser's debugging console. The specifics of how it works vary from browser to browser, but there is a de facto set of features that are typically provided."
  },
  "top": {
    "!type": "<top>",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.top",
    "!doc": "Returns a reference to the topmost window in the window hierarchy."
  },
  "parent": {
    "!type": "<top>",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.parent",
    "!doc": "A reference to the parent of the current window or subframe."
  },
  "window": {
    "!type": "<top>",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window",
    "!doc": "This section provides a brief reference for all of the methods, properties, and events available through the DOM window object. The window object implements the Window interface, which in turn inherits from the AbstractView interface. Some additional global functions, namespaces objects, and constructors, not typically associated with the window, but available on it, are listed in the JavaScript Reference."
  },
  "opener": {
    "!type": "<top>",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.opener",
    "!doc": "Returns a reference to the window that opened this current window."
  },
  "self": {
    "!type": "<top>",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.self",
    "!doc": "Returns an object reference to the window object. "
  },
  "devicePixelRatio": "number",
  "name": {
    "!type": "string",
    "!url": "https://developer.mozilla.org/en/docs/JavaScript/Reference/Global_Objects/Function/name",
    "!doc": "The name of the function."
  },
  "closed": {
    "!type": "bool",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.closed",
    "!doc": "This property indicates whether the referenced window is closed or not."
  },
  "pageYOffset": {
    "!type": "number",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.scrollY",
    "!doc": "Returns the number of pixels that the document has already been scrolled vertically."
  },
  "pageXOffset": {
    "!type": "number",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.scrollX",
    "!doc": "Returns the number of pixels that the document has already been scrolled vertically."
  },
  "scrollY": {
    "!type": "number",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.scrollY",
    "!doc": "Returns the number of pixels that the document has already been scrolled vertically."
  },
  "scrollX": {
    "!type": "number",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.scrollX",
    "!doc": "Returns the number of pixels that the document has already been scrolled vertically."
  },
  "screenTop": {
    "!type": "number",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.screen.top",
    "!doc": "Returns the distance in pixels from the top side of the current screen."
  },
  "screenLeft": {
    "!type": "number",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.screen.left",
    "!doc": "Returns the distance in pixels from the left side of the main screen to the left side of the current screen."
  },
  "screenY": {
    "!type": "number",
    "!url": "https://developer.mozilla.org/en/docs/DOM/event.screenY",
    "!doc": "Returns the vertical coordinate of the event within the screen as a whole."
  },
  "screenX": {
    "!type": "number",
    "!url": "https://developer.mozilla.org/en/docs/DOM/event.screenX",
    "!doc": "Returns the horizontal coordinate of the event within the screen as a whole."
  },
  "innerWidth": {
    "!type": "number",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.innerWidth",
    "!doc": "Width (in pixels) of the browser window viewport including, if rendered, the vertical scrollbar."
  },
  "innerHeight": {
    "!type": "number",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.innerHeight",
    "!doc": "Height (in pixels) of the browser window viewport including, if rendered, the horizontal scrollbar."
  },
  "outerWidth": {
    "!type": "number",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.outerWidth",
    "!doc": "window.outerWidth gets the width of the outside of the browser window. It represents the width of the whole browser window including sidebar (if expanded), window chrome and window resizing borders/handles."
  },
  "outerHeight": {
    "!type": "number",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.outerHeight",
    "!doc": "window.outerHeight gets the height in pixels of the whole browser window."
  },
  "frameElement": {
    "!type": "+Element",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.frameElement",
    "!doc": "Returns the element (such as <iframe> or <object>) in which the window is embedded, or null if the window is top-level."
  },
  "crypto": {
    "getRandomValues": {
      "!type": "fn([number])",
      "!url": "https://developer.mozilla.org/en/docs/DOM/window.crypto.getRandomValues",
      "!doc": "This methods lets you get cryptographically random values."
    },
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.crypto.getRandomValues",
    "!doc": "This methods lets you get cryptographically random values."
  },
  "navigator": {
    "appName": {
      "!type": "string",
      "!url": "https://developer.mozilla.org/en/docs/DOM/window.navigator.appName",
      "!doc": "Returns the name of the browser. The HTML5 specification also allows any browser to return \"Netscape\" here, for compatibility reasons."
    },
    "appVersion": {
      "!type": "string",
      "!url": "https://developer.mozilla.org/en/docs/DOM/window.navigator.appVersion",
      "!doc": "Returns the version of the browser as a string. It may be either a plain version number, like \"5.0\", or a version number followed by more detailed information. The HTML5 specification also allows any browser to return \"4.0\" here, for compatibility reasons."
    },
    "language": {
      "!type": "string",
      "!url": "https://developer.mozilla.org/en/docs/DOM/window.navigator.language",
      "!doc": "Returns a string representing the language version of the browser."
    },
    "platform": {
      "!type": "string",
      "!url": "https://developer.mozilla.org/en/docs/DOM/window.navigator.platform",
      "!doc": "Returns a string representing the platform of the browser."
    },
    "plugins": {
      "!type": "[?]",
      "!url": "https://developer.mozilla.org/en/docs/DOM/window.navigator.plugins",
      "!doc": "Returns a PluginArray object, listing the plugins installed in the application."
    },
    "userAgent": {
      "!type": "string",
      "!url": "https://developer.mozilla.org/en/docs/DOM/window.navigator.userAgent",
      "!doc": "Returns the user agent string for the current browser."
    },
    "vendor": {
      "!type": "string",
      "!url": "https://developer.mozilla.org/en/docs/DOM/window.navigator.vendor",
      "!doc": "Returns the name of the browser vendor for the current browser."
    },
    "javaEnabled": {
      "!type": "bool",
      "!url": "https://developer.mozilla.org/en/docs/DOM/window.navigator.javaEnabled",
      "!doc": "This method indicates whether the current browser is Java-enabled or not."
    },
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.navigator",
    "!doc": "Returns a reference to the navigator object, which can be queried for information about the application running the script."
  },
  "history": {
    "state": {
      "!type": "?",
      "!url": "https://developer.mozilla.org/en/docs/DOM/Manipulating_the_browser_history",
      "!doc": "The DOM window object provides access to the browser's history through the history object. It exposes useful methods and properties that let you move back and forth through the user's history, as well as -- starting with HTML5 -- manipulate the contents of the history stack."
    },
    "length": {
      "!type": "number",
      "!url": "https://developer.mozilla.org/en/docs/DOM/Manipulating_the_browser_history",
      "!doc": "The DOM window object provides access to the browser's history through the history object. It exposes useful methods and properties that let you move back and forth through the user's history, as well as -- starting with HTML5 -- manipulate the contents of the history stack."
    },
    "go": {
      "!type": "fn(delta: number)",
      "!url": "https://developer.mozilla.org/en/docs/DOM/window.history",
      "!doc": "Returns a reference to the History object, which provides an interface for manipulating the browser session history (pages visited in the tab or frame that the current page is loaded in)."
    },
    "forward": {
      "!type": "fn()",
      "!url": "https://developer.mozilla.org/en/docs/DOM/Manipulating_the_browser_history",
      "!doc": "The DOM window object provides access to the browser's history through the history object. It exposes useful methods and properties that let you move back and forth through the user's history, as well as -- starting with HTML5 -- manipulate the contents of the history stack."
    },
    "back": {
      "!type": "fn()",
      "!url": "https://developer.mozilla.org/en/docs/DOM/Manipulating_the_browser_history",
      "!doc": "The DOM window object provides access to the browser's history through the history object. It exposes useful methods and properties that let you move back and forth through the user's history, as well as -- starting with HTML5 -- manipulate the contents of the history stack."
    },
    "pushState": {
      "!type": "fn(data: ?, title: string, url?: string)",
      "!url": "https://developer.mozilla.org/en/docs/DOM/Manipulating_the_browser_history",
      "!doc": "The DOM window object provides access to the browser's history through the history object. It exposes useful methods and properties that let you move back and forth through the user's history, as well as -- starting with HTML5 -- manipulate the contents of the history stack."
    },
    "replaceState": {
      "!type": "fn(data: ?, title: string, url?: string)",
      "!url": "https://developer.mozilla.org/en/docs/DOM/Manipulating_the_browser_history",
      "!doc": "The DOM window object provides access to the browser's history through the history object. It exposes useful methods and properties that let you move back and forth through the user's history, as well as -- starting with HTML5 -- manipulate the contents of the history stack."
    },
    "!url": "https://developer.mozilla.org/en/docs/DOM/Manipulating_the_browser_history",
    "!doc": "The DOM window object provides access to the browser's history through the history object. It exposes useful methods and properties that let you move back and forth through the user's history, as well as -- starting with HTML5 -- manipulate the contents of the history stack."
  },
  "screen": {
    "availWidth": {
      "!type": "number",
      "!url": "https://developer.mozilla.org/en/docs/DOM/window.screen.availWidth",
      "!doc": "Returns the amount of horizontal space in pixels available to the window."
    },
    "availHeight": {
      "!type": "number",
      "!url": "https://developer.mozilla.org/en/docs/DOM/window.screen.availHeight",
      "!doc": "Returns the amount of vertical space available to the window on the screen."
    },
    "availTop": {
      "!type": "number",
      "!url": "https://developer.mozilla.org/en/docs/DOM/window.screen.availTop",
      "!doc": "Specifies the y-coordinate of the first pixel that is not allocated to permanent or semipermanent user interface features."
    },
    "availLeft": {
      "!type": "number",
      "!url": "https://developer.mozilla.org/en/docs/DOM/window.screen.availLeft",
      "!doc": "Returns the first available pixel available from the left side of the screen."
    },
    "pixelDepth": {
      "!type": "number",
      "!url": "https://developer.mozilla.org/en/docs/DOM/window.screen.pixelDepth",
      "!doc": "Returns the bit depth of the screen."
    },
    "colorDepth": {
      "!type": "number",
      "!url": "https://developer.mozilla.org/en/docs/DOM/window.screen.colorDepth",
      "!doc": "Returns the color depth of the screen."
    },
    "width": {
      "!type": "number",
      "!url": "https://developer.mozilla.org/en/docs/DOM/window.screen.width",
      "!doc": "Returns the width of the screen."
    },
    "height": {
      "!type": "number",
      "!url": "https://developer.mozilla.org/en/docs/DOM/window.screen.height",
      "!doc": "Returns the height of the screen in pixels."
    },
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.screen",
    "!doc": "Returns a reference to the screen object associated with the window."
  },
  "postMessage": {
    "!type": "fn(message: string, targetOrigin: string)",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.postMessage",
    "!doc": "window.postMessage, when called, causes a MessageEvent to be dispatched at the target window when any pending script that must be executed completes (e.g. remaining event handlers if window.postMessage is called from an event handler, previously-set pending timeouts, etc.). The MessageEvent has the type message, a data property which is set to the value of the first argument provided to window.postMessage, an origin property corresponding to the origin of the main document in the window calling window.postMessage at the time window.postMessage was called, and a source property which is the window from which window.postMessage is called. (Other standard properties of events are present with their expected values.)"
  },
  "close": {
    "!type": "fn()",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.close",
    "!doc": "Closes the current window, or a referenced window."
  },
  "blur": {
    "!type": "fn()",
    "!url": "https://developer.mozilla.org/en/docs/DOM/element.blur",
    "!doc": "The blur method removes keyboard focus from the current element."
  },
  "focus": {
    "!type": "fn()",
    "!url": "https://developer.mozilla.org/en/docs/DOM/element.focus",
    "!doc": "Sets focus on the specified element, if it can be focused."
  },
  "onload": {
    "!type": "?",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.onload",
    "!doc": "An event handler for the load event of a window."
  },
  "onunload": {
    "!type": "?",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.onunload",
    "!doc": "The unload event is raised when the window is unloading its content and resources. The resources removal is processed after the unload event occurs."
  },
  "onscroll": {
    "!type": "?",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.onscroll",
    "!doc": "Specifies the function to be called when the window is scrolled."
  },
  "onresize": {
    "!type": "?",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.onresize",
    "!doc": "An event handler for the resize event on the window."
  },
  "ononline": {
    "!type": "?",
    "!url": "https://developer.mozilla.org/en/docs/DOM/document.ononline",
    "!doc": ",fgh s dgkljgsdfl dfjg sdlgj sdlg sdlfj dlg jkdfkj dfjgdfkglsdfjsdlfkgj hdflkg hdlkfjgh dfkjgh"
  },
  "onoffline": {
    "!type": "?",
    "!url": "https://developer.mozilla.org/en/docs/Online_and_offline_events",
    "!doc": "Some browsers implement Online/Offline events from the WHATWG Web Applications 1.0 specification."
  },
  "onmousewheel": {
    "!type": "?",
    "!url": "https://developer.mozilla.org/en/docs/DOM/DOM_event_reference/mousewheel",
    "!doc": "The DOM mousewheel event is fired asynchronously when mouse wheel or similar device is operated. It's represented by the MouseWheelEvent interface."
  },
  "onmouseup": {
    "!type": "?",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.onmouseup",
    "!doc": "An event handler for the mouseup event on the window."
  },
  "onmouseover": {
    "!type": "?",
    "!url": "https://developer.mozilla.org/en/docs/DOM/element.onmouseover",
    "!doc": "The onmouseover property returns the onMouseOver event handler code on the current element."
  },
  "onmouseout": {
    "!type": "?",
    "!url": "https://developer.mozilla.org/en/docs/DOM/element.onmouseout",
    "!doc": "The onmouseout property returns the onMouseOut event handler code on the current element."
  },
  "onmousemove": {
    "!type": "?",
    "!url": "https://developer.mozilla.org/en/docs/DOM/element.onmousemove",
    "!doc": "The onmousemove property returns the mousemove event handler code on the current element."
  },
  "onmousedown": {
    "!type": "?",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.onmousedown",
    "!doc": "An event handler for the mousedown event on the window."
  },
  "onclick": {
    "!type": "?",
    "!url": "https://developer.mozilla.org/en/docs/DOM/element.onclick",
    "!doc": "The onclick property returns the onClick event handler code on the current element."
  },
  "ondblclick": {
    "!type": "?",
    "!url": "https://developer.mozilla.org/en/docs/DOM/element.ondblclick",
    "!doc": "The ondblclick property returns the onDblClick event handler code on the current element."
  },
  "onmessage": {
    "!type": "?",
    "!url": "https://developer.mozilla.org/en/docs/DOM/Worker",
    "!doc": "Dedicated Web Workers provide a simple means for web content to run scripts in background threads.  Once created, a worker can send messages to the spawning task by posting messages to an event handler specified by the creator."
  },
  "onkeyup": {
    "!type": "?",
    "!url": "https://developer.mozilla.org/en/docs/DOM/element.onkeyup",
    "!doc": "The onkeyup property returns the onKeyUp event handler code for the current element."
  },
  "onkeypress": {
    "!type": "?",
    "!url": "https://developer.mozilla.org/en/docs/DOM/element.onkeypress",
    "!doc": "The onkeypress property sets and returns the onKeyPress event handler code for the current element."
  },
  "onkeydown": {
    "!type": "?",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.onkeydown",
    "!doc": "An event handler for the keydown event on the window."
  },
  "oninput": {
    "!type": "?",
    "!url": "https://developer.mozilla.org/en/docs/DOM/DOM_event_reference/input",
    "!doc": "The DOM input event is fired synchronously when the value of an <input> or <textarea> element is changed. Additionally, it's also fired on contenteditable editors when its contents are changed. In this case, the event target is the editing host element. If there are two or more elements which have contenteditable as true, \"editing host\" is the nearest ancestor element whose parent isn't editable. Similarly, it's also fired on root element of designMode editors."
  },
  "onpopstate": {
    "!type": "?",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.onpopstate",
    "!doc": "An event handler for the popstate event on the window."
  },
  "onhashchange": {
    "!type": "?",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.onhashchange",
    "!doc": "The hashchange event fires when a window's hash changes."
  },
  "onfocus": {
    "!type": "?",
    "!url": "https://developer.mozilla.org/en/docs/DOM/element.onfocus",
    "!doc": "The onfocus property returns the onFocus event handler code on the current element."
  },
  "onblur": {
    "!type": "?",
    "!url": "https://developer.mozilla.org/en/docs/DOM/element.onblur",
    "!doc": "The onblur property returns the onBlur event handler code, if any, that exists on the current element."
  },
  "onerror": {
    "!type": "?",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.onerror",
    "!doc": "An event handler for runtime script errors."
  },
  "ondrop": {
    "!type": "?",
    "!url": "https://developer.mozilla.org/en-US/docs/DOM/Mozilla_event_reference/drop",
    "!doc": "The drop event is fired when an element or text selection is dropped on a valid drop target."
  },
  "ondragstart": {
    "!type": "?",
    "!url": "https://developer.mozilla.org/en-US/docs/DOM/Mozilla_event_reference/dragstart",
    "!doc": "The dragstart event is fired when the user starts dragging an element or text selection."
  },
  "ondragover": {
    "!type": "?",
    "!url": "https://developer.mozilla.org/en-US/docs/DOM/Mozilla_event_reference/dragover",
    "!doc": "The dragover event is fired when an element or text selection is being dragged over a valid drop target (every few hundred milliseconds)."
  },
  "ondragleave": {
    "!type": "?",
    "!url": "https://developer.mozilla.org/en-US/docs/DOM/Mozilla_event_reference/dragleave",
    "!doc": "The dragleave event is fired when a dragged element or text selection leaves a valid drop target."
  },
  "ondragenter": {
    "!type": "?",
    "!url": "https://developer.mozilla.org/en-US/docs/DOM/Mozilla_event_reference/dragenter",
    "!doc": "The dragenter event is fired when a dragged element or text selection enters a valid drop target."
  },
  "ondragend": {
    "!type": "?",
    "!url": "https://developer.mozilla.org/en-US/docs/DOM/Mozilla_event_reference/dragend",
    "!doc": "The dragend event is fired when a drag operation is being ended (by releasing a mouse button or hitting the escape key)."
  },
  "ondrag": {
    "!type": "?",
    "!url": "https://developer.mozilla.org/en-US/docs/DOM/Mozilla_event_reference/drag",
    "!doc": "The drag event is fired when an element or text selection is being dragged (every few hundred milliseconds)."
  },
  "oncontextmenu": {
    "!type": "?",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.oncontextmenu",
    "!doc": "An event handler property for right-click events on the window. Unless the default behavior is prevented, the browser context menu will activate (though IE8 has a bug with this and will not activate the context menu if a contextmenu event handler is defined). Note that this event will occur with any non-disabled right-click event and does not depend on an element possessing the \"contextmenu\" attribute."
  },
  "onchange": {
    "!type": "?",
    "!url": "https://developer.mozilla.org/en/docs/DOM/element.onchange",
    "!doc": "The onchange property sets and returns the onChange event handler code for the current element."
  },
  "onbeforeunload": {
    "!type": "?",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.onbeforeunload",
    "!doc": "An event that fires when a window is about to unload its resources. The document is still visible and the event is still cancelable."
  },
  "onabort": {
    "!type": "?",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.onabort",
    "!doc": "An event handler for abort events sent to the window."
  },
  "getSelection": {
    "!type": "fn() -> +Selection",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.getSelection",
    "!doc": "Returns a selection object representing the range of text selected by the user. "
  },
  "alert": {
    "!type": "fn(message: string)",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.alert",
    "!doc": "Display an alert dialog with the specified content and an OK button."
  },
  "confirm": {
    "!type": "fn(message: string) -> bool",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.confirm",
    "!doc": "Displays a modal dialog with a message and two buttons, OK and Cancel."
  },
  "prompt": {
    "!type": "fn(message: string, value: string) -> string",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.prompt",
    "!doc": "Displays a dialog with a message prompting the user to input some text."
  },
  "scrollBy": {
    "!type": "fn(x: number, y: number)",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.scrollBy",
    "!doc": "Scrolls the document in the window by the given amount."
  },
  "scrollTo": {
    "!type": "fn(x: number, y: number)",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.scrollTo",
    "!doc": "Scrolls to a particular set of coordinates in the document."
  },
  "scroll": {
    "!type": "fn(x: number, y: number)",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.scroll",
    "!doc": "Scrolls the window to a particular place in the document."
  },
  "setTimeout": {
    "!type": "fn(f: fn(), ms: number) -> number",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.setTimeout",
    "!doc": "Calls a function or executes a code snippet after specified delay."
  },
  "clearTimeout": {
    "!type": "fn(timeout: number)",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.clearTimeout",
    "!doc": "Clears the delay set by window.setTimeout()."
  },
  "setInterval": {
    "!type": "fn(f: fn(), ms: number) -> number",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.setInterval",
    "!doc": "Calls a function or executes a code snippet repeatedly, with a fixed time delay between each call to that function."
  },
  "clearInterval": {
    "!type": "fn(interval: number)",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.clearInterval",
    "!doc": "Cancels repeated action which was set up using setInterval."
  },
  "atob": {
    "!type": "fn(encoded: string) -> string",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.atob",
    "!doc": "Decodes a string of data which has been encoded using base-64 encoding."
  },
  "btoa": {
    "!type": "fn(data: string) -> string",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.btoa",
    "!doc": "Creates a base-64 encoded ASCII string from a string of binary data."
  },
  "addEventListener": {
    "!type": "fn(type: string, listener: fn(e: +Event), capture: bool)",
    "!url": "https://developer.mozilla.org/en/docs/DOM/EventTarget.addEventListener",
    "!doc": "Registers a single event listener on a single target. The event target may be a single element in a document, the document itself, a window, or an XMLHttpRequest."
  },
  "removeEventListener": {
    "!type": "fn(type: string, listener: fn(), capture: bool)",
    "!url": "https://developer.mozilla.org/en/docs/DOM/EventTarget.removeEventListener",
    "!doc": "Allows the removal of event listeners from the event target."
  },
  "dispatchEvent": {
    "!type": "fn(event: +Event) -> bool",
    "!url": "https://developer.mozilla.org/en/docs/DOM/EventTarget.dispatchEvent",
    "!doc": "Dispatches an event into the event system. The event is subject to the same capturing and bubbling behavior as directly dispatched events."
  },
  "getComputedStyle": {
    "!type": "fn(node: +Element, pseudo?: string) -> Element.prototype.style",
    "!url": "https://developer.mozilla.org/en/docs/DOM/window.getComputedStyle",
    "!doc": "Gives the final used values of all the CSS properties of an element."
  },
  "CanvasRenderingContext2D": {
    "canvas": "+Element",
    "width": "number",
    "height": "number",
    "commit": "fn()",
    "save": "fn()",
    "restore": "fn()",
    "currentTransform": "?",
    "scale": "fn(x: number, y: number)",
    "rotate": "fn(angle: number)",
    "translate": "fn(x: number, y: number)",
    "transform": "fn(a: number, b: number, c: number, d: number, e: number, f: number)",
    "setTransform": "fn(a: number, b: number, c: number, d: number, e: number, f: number)",
    "resetTransform": "fn()",
    "globalAlpha": "number",
    "globalCompositeOperation": "string",
    "imageSmoothingEnabled": "bool",
    "strokeStyle": "string",
    "fillStyle": "string",
    "createLinearGradient": "fn(x0: number, y0: number, x1: number, y1: number) -> ?",
    "createPattern": "fn(image: ?, repetition: string) -> ?",
    "shadowOffsetX": "number",
    "shadowOffsetY": "number",
    "shadowBlur": "number",
    "shadowColor": "string",
    "clearRect": "fn(x: number, y: number, w: number, h: number)",
    "fillRect": "fn(x: number, y: number, w: number, h: number)",
    "strokeRect": "fn(x: number, y: number, w: number, h: number)",
    "fillRule": "string",
    "fill": "fn()",
    "beginPath": "fn()",
    "stroke": "fn()",
    "clip": "fn()",
    "resetClip": "fn()",
    "measureText": "fn(text: string) -> ?",
    "drawImage": "fn(image: ?, dx: number, dy: number)",
    "createImageData": "fn(sw: number, sh: number) -> ?",
    "getImageData": "fn(sx: number, sy: number, sw: number, sh: number) -> ?",
    "putImageData": "fn(imagedata: ?, dx: number, dy: number)",
    "lineWidth": "number",
    "lineCap": "string",
    "lineJoin": "string",
    "miterLimit": "number",
    "setLineDash": "fn(segments: [number])",
    "getLineDash": "fn() -> [number]",
    "lineDashOffset": "number",
    "font": "string",
    "textAlign": "string",
    "textBaseline": "string",
    "direction": "string",
    "closePath": "fn()",
    "moveTo": "fn(x: number, y: number)",
    "lineTo": "fn(x: number, y: number)",
    "quadraticCurveTo": "fn(cpx: number, cpy: number, x: number, y: number)",
    "bezierCurveTo": "fn(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number)",
    "arcTo": "fn(x1: number, y1: number, x2: number, y2: number, radius: number)",
    "rect": "fn(x: number, y: number, w: number, h: number)",
    "arc": "fn(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: bool)",
    "ellipse": "fn(x: number, y: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, anticlockwise: bool)"
  }
}

},{}],98:[function(require,module,exports){
module.exports={
  "!name": "ecma5",
  "!define": {"Error.prototype": "Error.prototype"},
  "Infinity": {
    "!type": "number",
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Infinity",
    "!doc": "A numeric value representing infinity."
  },
  "undefined": {
    "!type": "?",
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/undefined",
    "!doc": "The value undefined."
  },
  "NaN": {
    "!type": "number",
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/NaN",
    "!doc": "A value representing Not-A-Number."
  },
  "Object": {
    "!type": "fn()",
    "getPrototypeOf": {
      "!type": "fn(obj: ?) -> ?",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/getPrototypeOf",
      "!doc": "Returns the prototype (i.e. the internal prototype) of the specified object."
    },
    "create": {
      "!type": "fn(proto: ?) -> !custom:Object_create",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/create",
      "!doc": "Creates a new object with the specified prototype object and properties."
    },
    "defineProperty": {
      "!type": "fn(obj: ?, prop: string, desc: ?)",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/defineProperty",
      "!doc": "Defines a new property directly on an object, or modifies an existing property on an object, and returns the object. If you want to see how to use the Object.defineProperty method with a binary-flags-like syntax, see this article."
    },
    "defineProperties": {
      "!type": "fn(obj: ?, props: ?)",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/defineProperty",
      "!doc": "Defines a new property directly on an object, or modifies an existing property on an object, and returns the object. If you want to see how to use the Object.defineProperty method with a binary-flags-like syntax, see this article."
    },
    "getOwnPropertyDescriptor": {
      "!type": "fn(obj: ?, prop: string) -> ?",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor",
      "!doc": "Returns a property descriptor for an own property (that is, one directly present on an object, not present by dint of being along an object's prototype chain) of a given object."
    },
    "keys": {
      "!type": "fn(obj: ?) -> [string]",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/keys",
      "!doc": "Returns an array of a given object's own enumerable properties, in the same order as that provided by a for-in loop (the difference being that a for-in loop enumerates properties in the prototype chain as well)."
    },
    "getOwnPropertyNames": {
      "!type": "fn(obj: ?) -> [string]",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames",
      "!doc": "Returns an array of all properties (enumerable or not) found directly upon a given object."
    },
    "seal": {
      "!type": "fn(obj: ?)",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/seal",
      "!doc": "Seals an object, preventing new properties from being added to it and marking all existing properties as non-configurable. Values of present properties can still be changed as long as they are writable."
    },
    "isSealed": {
      "!type": "fn(obj: ?) -> bool",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/isSealed",
      "!doc": "Determine if an object is sealed."
    },
    "freeze": {
      "!type": "fn(obj: ?)",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/freeze",
      "!doc": "Freezes an object: that is, prevents new properties from being added to it; prevents existing properties from being removed; and prevents existing properties, or their enumerability, configurability, or writability, from being changed. In essence the object is made effectively immutable. The method returns the object being frozen."
    },
    "isFrozen": {
      "!type": "fn(obj: ?) -> bool",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/isFrozen",
      "!doc": "Determine if an object is frozen."
    },
    "prototype": {
      "!stdProto": "Object",
      "toString": {
        "!type": "fn() -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/toString",
        "!doc": "Returns a string representing the object."
      },
      "toLocaleString": {
        "!type": "fn() -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/toLocaleString",
        "!doc": "Returns a string representing the object. This method is meant to be overriden by derived objects for locale-specific purposes."
      },
      "valueOf": {
        "!type": "fn() -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/valueOf",
        "!doc": "Returns the primitive value of the specified object"
      },
      "hasOwnProperty": {
        "!type": "fn(prop: string) -> bool",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/hasOwnProperty",
        "!doc": "Returns a boolean indicating whether the object has the specified property."
      },
      "propertyIsEnumerable": {
        "!type": "fn(prop: string) -> bool",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable",
        "!doc": "Returns a Boolean indicating whether the specified property is enumerable."
      }
    },
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object",
    "!doc": "Creates an object wrapper."
  },
  "Function": {
    "!type": "fn(body: string) -> fn()",
    "prototype": {
      "!stdProto": "Function",
      "apply": {
        "!type": "fn(this: ?, args: [?])",
        "!effects": [
          "call and return !this this=!0 !1.<i> !1.<i> !1.<i>"
        ],
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/apply",
        "!doc": "Calls a function with a given this value and arguments provided as an array (or an array like object)."
      },
      "call": {
        "!type": "fn(this: ?, args?: ?) -> !this.!ret",
        "!effects": [
          "call and return !this this=!0 !1 !2 !3 !4"
        ],
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/call",
        "!doc": "Calls a function with a given this value and arguments provided individually."
      },
      "bind": {
        "!type": "fn(this: ?, args?: ?) -> !custom:Function_bind",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/bind",
        "!doc": "Creates a new function that, when called, has its this keyword set to the provided value, with a given sequence of arguments preceding any provided when the new function was called."
      },
      "prototype": "?"
    },
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function",
    "!doc": "Every function in JavaScript is actually a Function object."
  },
  "Array": {
    "!type": "fn(size: number) -> !custom:Array_ctor",
    "isArray": {
      "!type": "fn(value: ?) -> bool",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/isArray",
      "!doc": "Returns true if an object is an array, false if it is not."
    },
    "prototype": {
      "!stdProto": "Array",
      "length": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/length",
        "!doc": "An unsigned, 32-bit integer that specifies the number of elements in an array."
      },
      "concat": {
        "!type": "fn(other: [?]) -> !this",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/concat",
        "!doc": "Returns a new array comprised of this array joined with other array(s) and/or value(s)."
      },
      "join": {
        "!type": "fn(separator?: string) -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/join",
        "!doc": "Joins all elements of an array into a string."
      },
      "splice": {
        "!type": "fn(pos: number, amount: number)",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/splice",
        "!doc": "Changes the content of an array, adding new elements while removing old elements."
      },
      "pop": {
        "!type": "fn() -> !this.<i>",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/pop",
        "!doc": "Removes the last element from an array and returns that element."
      },
      "push": {
        "!type": "fn(newelt: ?) -> number",
        "!effects": [
          "propagate !0 !this.<i>"
        ],
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/push",
        "!doc": "Mutates an array by appending the given elements and returning the new length of the array."
      },
      "shift": {
        "!type": "fn() -> !this.<i>",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/shift",
        "!doc": "Removes the first element from an array and returns that element. This method changes the length of the array."
      },
      "unshift": {
        "!type": "fn(newelt: ?) -> number",
        "!effects": [
          "propagate !0 !this.<i>"
        ],
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/unshift",
        "!doc": "Adds one or more elements to the beginning of an array and returns the new length of the array."
      },
      "slice": {
        "!type": "fn(from: number, to?: number) -> !this",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/slice",
        "!doc": "Returns a shallow copy of a portion of an array."
      },
      "reverse": {
        "!type": "fn()",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/reverse",
        "!doc": "Reverses an array in place.  The first array element becomes the last and the last becomes the first."
      },
      "sort": {
        "!type": "fn(compare?: fn(a: ?, b: ?) -> number)",
        "!effects": [
          "call !0 !this.<i> !this.<i>"
        ],
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/sort",
        "!doc": "Sorts the elements of an array in place and returns the array."
      },
      "indexOf": {
        "!type": "fn(elt: ?, from?: number) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/indexOf",
        "!doc": "Returns the first index at which a given element can be found in the array, or -1 if it is not present."
      },
      "lastIndexOf": {
        "!type": "fn(elt: ?, from?: number) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/lastIndexOf",
        "!doc": "Returns the last index at which a given element can be found in the array, or -1 if it is not present. The array is searched backwards, starting at fromIndex."
      },
      "every": {
        "!type": "fn(test: fn(elt: ?, i: number) -> bool, context?: ?) -> bool",
        "!effects": [
          "call !0 this=!1 !this.<i> number"
        ],
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/every",
        "!doc": "Tests whether all elements in the array pass the test implemented by the provided function."
      },
      "some": {
        "!type": "fn(test: fn(elt: ?, i: number) -> bool, context?: ?) -> bool",
        "!effects": [
          "call !0 this=!1 !this.<i> number"
        ],
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/some",
        "!doc": "Tests whether some element in the array passes the test implemented by the provided function."
      },
      "filter": {
        "!type": "fn(test: fn(elt: ?, i: number) -> bool, context?: ?) -> !this",
        "!effects": [
          "call !0 this=!1 !this.<i> number"
        ],
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/filter",
        "!doc": "Creates a new array with all elements that pass the test implemented by the provided function."
      },
      "forEach": {
        "!type": "fn(f: fn(elt: ?, i: number), context?: ?)",
        "!effects": [
          "call !0 this=!1 !this.<i> number"
        ],
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/forEach",
        "!doc": "Executes a provided function once per array element."
      },
      "map": {
        "!type": "fn(f: fn(elt: ?, i: number) -> ?, context?: ?) -> [!0.!ret]",
        "!effects": [
          "call !0 this=!1 !this.<i> number"
        ],
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/map",
        "!doc": "Creates a new array with the results of calling a provided function on every element in this array."
      },
      "reduce": {
        "!type": "fn(combine: fn(sum: ?, elt: ?, i: number) -> ?, init?: ?) -> !0.!ret",
        "!effects": [
          "call !0 !1 !this.<i> number"
        ],
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/Reduce",
        "!doc": "Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value."
      },
      "reduceRight": {
        "!type": "fn(combine: fn(sum: ?, elt: ?, i: number) -> ?, init?: ?) -> !0.!ret",
        "!effects": [
          "call !0 !1 !this.<i> number"
        ],
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/ReduceRight",
        "!doc": "Apply a function simultaneously against two values of the array (from right-to-left) as to reduce it to a single value."
      }
    },
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array",
    "!doc": "The JavaScript Array global object is a constructor for arrays, which are high-level, list-like objects."
  },
  "String": {
    "!type": "fn(value: ?) -> string",
    "fromCharCode": {
      "!type": "fn(code: number) -> string",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/fromCharCode",
      "!doc": "Returns a string created by using the specified sequence of Unicode values."
    },
    "prototype": {
      "!stdProto": "String",
      "length": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/JavaScript/Reference/Global_Objects/String",
        "!doc": "The String global object is a constructor for strings, or a sequence of characters."
      },
      "<i>": "string",
      "charAt": {
        "!type": "fn(i: number) -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/charAt",
        "!doc": "Returns the specified character from a string."
      },
      "charCodeAt": {
        "!type": "fn(i: number) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/charCodeAt",
        "!doc": "Returns the numeric Unicode value of the character at the given index (except for unicode codepoints > 0x10000)."
      },
      "indexOf": {
        "!type": "fn(char: string, from?: number) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/indexOf",
        "!doc": "Returns the index within the calling String object of the first occurrence of the specified value, starting the search at fromIndex,\nreturns -1 if the value is not found."
      },
      "lastIndexOf": {
        "!type": "fn(char: string, from?: number) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/lastIndexOf",
        "!doc": "Returns the index within the calling String object of the last occurrence of the specified value, or -1 if not found. The calling string is searched backward, starting at fromIndex."
      },
      "substring": {
        "!type": "fn(from: number, to?: number) -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/substring",
        "!doc": "Returns a subset of a string between one index and another, or through the end of the string."
      },
      "substr": {
        "!type": "fn(from: number, length?: number) -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/substr",
        "!doc": "Returns the characters in a string beginning at the specified location through the specified number of characters."
      },
      "slice": {
        "!type": "fn(from: number, to?: number) -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/slice",
        "!doc": "Extracts a section of a string and returns a new string."
      },
      "trim": {
        "!type": "fn() -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/Trim",
        "!doc": "Removes whitespace from both ends of the string."
      },
      "trimLeft": {
        "!type": "fn() -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/TrimLeft",
        "!doc": "Removes whitespace from the left end of the string."
      },
      "trimRight": {
        "!type": "fn() -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/TrimRight",
        "!doc": "Removes whitespace from the right end of the string."
      },
      "toUpperCase": {
        "!type": "fn() -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/toUpperCase",
        "!doc": "Returns the calling string value converted to uppercase."
      },
      "toLowerCase": {
        "!type": "fn() -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/toLowerCase",
        "!doc": "Returns the calling string value converted to lowercase."
      },
      "toLocaleUpperCase": {
        "!type": "fn() -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/toLocaleUpperCase",
        "!doc": "Returns the calling string value converted to upper case, according to any locale-specific case mappings."
      },
      "toLocaleLowerCase": {
        "!type": "fn() -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/toLocaleLowerCase",
        "!doc": "Returns the calling string value converted to lower case, according to any locale-specific case mappings."
      },
      "split": {
        "!type": "fn(pattern: string) -> [string]",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/split",
        "!doc": "Splits a String object into an array of strings by separating the string into substrings."
      },
      "concat": {
        "!type": "fn(other: string) -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/concat",
        "!doc": "Combines the text of two or more strings and returns a new string."
      },
      "localeCompare": {
        "!type": "fn(other: string) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/localeCompare",
        "!doc": "Returns a number indicating whether a reference string comes before or after or is the same as the given string in sort order."
      },
      "match": {
        "!type": "fn(pattern: +RegExp) -> [string]",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/match",
        "!doc": "Used to retrieve the matches when matching a string against a regular expression."
      },
      "replace": {
        "!type": "fn(pattern: +RegExp, replacement: string) -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/replace",
        "!doc": "Returns a new string with some or all matches of a pattern replaced by a replacement.  The pattern can be a string or a RegExp, and the replacement can be a string or a function to be called for each match."
      },
      "search": {
        "!type": "fn(pattern: +RegExp) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/search",
        "!doc": "Executes the search for a match between a regular expression and this String object."
      }
    },
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String",
    "!doc": "The String global object is a constructor for strings, or a sequence of characters."
  },
  "Number": {
    "!type": "fn(value: ?) -> number",
    "MAX_VALUE": {
      "!type": "number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/MAX_VALUE",
      "!doc": "The maximum numeric value representable in JavaScript."
    },
    "MIN_VALUE": {
      "!type": "number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/MIN_VALUE",
      "!doc": "The smallest positive numeric value representable in JavaScript."
    },
    "POSITIVE_INFINITY": {
      "!type": "number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/POSITIVE_INFINITY",
      "!doc": "A value representing the positive Infinity value."
    },
    "NEGATIVE_INFINITY": {
      "!type": "number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/NEGATIVE_INFINITY",
      "!doc": "A value representing the negative Infinity value."
    },
    "prototype": {
      "!stdProto": "Number",
      "toString": {
        "!type": "fn(radix?: number) -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/toString",
        "!doc": "Returns a string representing the specified Number object"
      },
      "toFixed": {
        "!type": "fn(digits: number) -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/toFixed",
        "!doc": "Formats a number using fixed-point notation"
      },
      "toExponential": {
        "!type": "fn(digits: number) -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/toExponential",
        "!doc": "Returns a string representing the Number object in exponential notation"
      }
    },
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number",
    "!doc": "The Number JavaScript object is a wrapper object allowing you to work with numerical values. A Number object is created using the Number() constructor."
  },
  "Boolean": {
    "!type": "fn(value: ?) -> bool",
    "prototype": {
      "!stdProto": "Boolean"
    },
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Boolean",
    "!doc": "The Boolean object is an object wrapper for a boolean value."
  },
  "RegExp": {
    "!type": "fn(source: string, flags?: string)",
    "prototype": {
      "!stdProto": "RegExp",
      "exec": {
        "!type": "fn(input: string) -> [string]",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp/exec",
        "!doc": "Executes a search for a match in a specified string. Returns a result array, or null."
      },
      "compile": {
        "!type": "fn(source: string, flags?: string)",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp",
        "!doc": "Creates a regular expression object for matching text with a pattern."
      },
      "test": {
        "!type": "fn(input: string) -> bool",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp/test",
        "!doc": "Executes the search for a match between a regular expression and a specified string. Returns true or false."
      },
      "global": {
        "!type": "bool",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp",
        "!doc": "Creates a regular expression object for matching text with a pattern."
      },
      "ignoreCase": {
        "!type": "bool",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp",
        "!doc": "Creates a regular expression object for matching text with a pattern."
      },
      "multiline": {
        "!type": "bool",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp/multiline",
        "!doc": "Reflects whether or not to search in strings across multiple lines.\n"
      },
      "source": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp/source",
        "!doc": "A read-only property that contains the text of the pattern, excluding the forward slashes.\n"
      },
      "lastIndex": {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp/lastIndex",
        "!doc": "A read/write integer property that specifies the index at which to start the next match."
      }
    },
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp",
    "!doc": "Creates a regular expression object for matching text with a pattern."
  },
  "Date": {
    "!type": "fn(ms: number)",
    "parse": {
      "!type": "fn(source: string) -> +Date",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/parse",
      "!doc": "Parses a string representation of a date, and returns the number of milliseconds since January 1, 1970, 00:00:00 UTC."
    },
    "UTC": {
      "!type": "fn(year: number, month: number, date: number, hour?: number, min?: number, sec?: number, ms?: number) -> number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/UTC",
      "!doc": "Accepts the same parameters as the longest form of the constructor, and returns the number of milliseconds in a Date object since January 1, 1970, 00:00:00, universal time."
    },
    "now": {
      "!type": "fn() -> number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/now",
      "!doc": "Returns the number of milliseconds elapsed since 1 January 1970 00:00:00 UTC."
    },
    "prototype": {
      "toUTCString": {
        "!type": "fn() -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/toUTCString",
        "!doc": "Converts a date to a string, using the universal time convention."
      },
      "toISOString": {
        "!type": "fn() -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/toISOString",
        "!doc": "JavaScript provides a direct way to convert a date object into a string in ISO format, the ISO 8601 Extended Format."
      },
      "toDateString": {
        "!type": "fn() -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/toDateString",
        "!doc": "Returns the date portion of a Date object in human readable form in American English."
      },
      "toTimeString": {
        "!type": "fn() -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/toTimeString",
        "!doc": "Returns the time portion of a Date object in human readable form in American English."
      },
      "toLocaleDateString": {
        "!type": "fn() -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/toLocaleDateString",
        "!doc": "Converts a date to a string, returning the \"date\" portion using the operating system's locale's conventions.\n"
      },
      "toLocaleTimeString": {
        "!type": "fn() -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/toLocaleTimeString",
        "!doc": "Converts a date to a string, returning the \"time\" portion using the current locale's conventions."
      },
      "getTime": {
        "!type": "fn() -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getTime",
        "!doc": "Returns the numeric value corresponding to the time for the specified date according to universal time."
      },
      "getFullYear": {
        "!type": "fn() -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getFullYear",
        "!doc": "Returns the year of the specified date according to local time."
      },
      "getYear": {
        "!type": "fn() -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getYear",
        "!doc": "Returns the year in the specified date according to local time."
      },
      "getMonth": {
        "!type": "fn() -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getMonth",
        "!doc": "Returns the month in the specified date according to local time."
      },
      "getUTCMonth": {
        "!type": "fn() -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getUTCMonth",
        "!doc": "Returns the month of the specified date according to universal time.\n"
      },
      "getDate": {
        "!type": "fn() -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getDate",
        "!doc": "Returns the day of the month for the specified date according to local time."
      },
      "getUTCDate": {
        "!type": "fn() -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getUTCDate",
        "!doc": "Returns the day (date) of the month in the specified date according to universal time.\n"
      },
      "getDay": {
        "!type": "fn() -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getDay",
        "!doc": "Returns the day of the week for the specified date according to local time."
      },
      "getUTCDay": {
        "!type": "fn() -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getUTCDay",
        "!doc": "Returns the day of the week in the specified date according to universal time.\n"
      },
      "getHours": {
        "!type": "fn() -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getHours",
        "!doc": "Returns the hour for the specified date according to local time."
      },
      "getUTCHours": {
        "!type": "fn() -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getUTCHours",
        "!doc": "Returns the hours in the specified date according to universal time.\n"
      },
      "getMinutes": {
        "!type": "fn() -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getMinutes",
        "!doc": "Returns the minutes in the specified date according to local time."
      },
      "getUTCMinutes": {
        "!type": "fn() -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date",
        "!doc": "Creates JavaScript Date instances which let you work with dates and times."
      },
      "getSeconds": {
        "!type": "fn() -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getSeconds",
        "!doc": "Returns the seconds in the specified date according to local time."
      },
      "getUTCSeconds": {
        "!type": "fn() -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getUTCSeconds",
        "!doc": "Returns the seconds in the specified date according to universal time.\n"
      },
      "getMilliseconds": {
        "!type": "fn() -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getMilliseconds",
        "!doc": "Returns the milliseconds in the specified date according to local time."
      },
      "getUTCMilliseconds": {
        "!type": "fn() -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getUTCMilliseconds",
        "!doc": "Returns the milliseconds in the specified date according to universal time.\n"
      },
      "getTimezoneOffset": {
        "!type": "fn() -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getTimezoneOffset",
        "!doc": "Returns the time-zone offset from UTC, in minutes, for the current locale."
      },
      "setTime": {
        "!type": "fn(date: +Date) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setTime",
        "!doc": "Sets the Date object to the time represented by a number of milliseconds since January 1, 1970, 00:00:00 UTC.\n"
      },
      "setFullYear": {
        "!type": "fn(year: number) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setFullYear",
        "!doc": "Sets the full year for a specified date according to local time.\n"
      },
      "setUTCFullYear": {
        "!type": "fn(year: number) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCFullYear",
        "!doc": "Sets the full year for a specified date according to universal time.\n"
      },
      "setMonth": {
        "!type": "fn(month: number) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setMonth",
        "!doc": "Set the month for a specified date according to local time."
      },
      "setUTCMonth": {
        "!type": "fn(month: number) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCMonth",
        "!doc": "Sets the month for a specified date according to universal time.\n"
      },
      "setDate": {
        "!type": "fn(day: number) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setDate",
        "!doc": "Sets the day of the month for a specified date according to local time."
      },
      "setUTCDate": {
        "!type": "fn(day: number) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCDate",
        "!doc": "Sets the day of the month for a specified date according to universal time.\n"
      },
      "setHours": {
        "!type": "fn(hour: number) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setHours",
        "!doc": "Sets the hours for a specified date according to local time, and returns the number of milliseconds since 1 January 1970 00:00:00 UTC until the time represented by the updated Date instance."
      },
      "setUTCHours": {
        "!type": "fn(hour: number) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCHours",
        "!doc": "Sets the hour for a specified date according to universal time.\n"
      },
      "setMinutes": {
        "!type": "fn(min: number) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setMinutes",
        "!doc": "Sets the minutes for a specified date according to local time."
      },
      "setUTCMinutes": {
        "!type": "fn(min: number) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCMinutes",
        "!doc": "Sets the minutes for a specified date according to universal time.\n"
      },
      "setSeconds": {
        "!type": "fn(sec: number) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setSeconds",
        "!doc": "Sets the seconds for a specified date according to local time."
      },
      "setUTCSeconds": {
        "!type": "fn(sec: number) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCSeconds",
        "!doc": "Sets the seconds for a specified date according to universal time.\n"
      },
      "setMilliseconds": {
        "!type": "fn(ms: number) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setMilliseconds",
        "!doc": "Sets the milliseconds for a specified date according to local time.\n"
      },
      "setUTCMilliseconds": {
        "!type": "fn(ms: number) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCMilliseconds",
        "!doc": "Sets the milliseconds for a specified date according to universal time.\n"
      }
    },
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date",
    "!doc": "Creates JavaScript Date instances which let you work with dates and times."
  },
  "Error": {
    "!type": "fn(message: string)",
    "prototype": {
      "name": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Error/name",
        "!doc": "A name for the type of error."
      },
      "message": {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Error/message",
        "!doc": "A human-readable description of the error."
      }
    },
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Error",
    "!doc": "Creates an error object."
  },
  "SyntaxError": {
    "!type": "fn(message: string)",
    "prototype": "Error.prototype",
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/SyntaxError",
    "!doc": "Represents an error when trying to interpret syntactically invalid code."
  },
  "ReferenceError": {
    "!type": "fn(message: string)",
    "prototype": "Error.prototype",
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/ReferenceError",
    "!doc": "Represents an error when a non-existent variable is referenced."
  },
  "URIError": {
    "!type": "fn(message: string)",
    "prototype": "Error.prototype",
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/URIError",
    "!doc": "Represents an error when a malformed URI is encountered."
  },
  "EvalError": {
    "!type": "fn(message: string)",
    "prototype": "Error.prototype",
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/EvalError",
    "!doc": "Represents an error regarding the eval function."
  },
  "RangeError": {
    "!type": "fn(message: string)",
    "prototype": "Error.prototype",
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RangeError",
    "!doc": "Represents an error when a number is not within the correct range allowed."
  },
  "parseInt": {
    "!type": "fn(string: string, radix?: number) -> number",
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/parseInt",
    "!doc": "Parses a string argument and returns an integer of the specified radix or base."
  },
  "parseFloat": {
    "!type": "fn(string: string) -> number",
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/parseFloat",
    "!doc": "Parses a string argument and returns a floating point number."
  },
  "isNaN": {
    "!type": "fn(value: number) -> bool",
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/isNaN",
    "!doc": "Determines whether a value is NaN or not. Be careful, this function is broken. You may be interested in ECMAScript 6 Number.isNaN."
  },
  "eval": {
    "!type": "fn(code: string) -> ?",
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/eval",
    "!doc": "Evaluates JavaScript code represented as a string."
  },
  "encodeURI": {
    "!type": "fn(uri: string) -> string",
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/encodeURI",
    "!doc": "Encodes a Uniform Resource Identifier (URI) by replacing each instance of certain characters by one, two, three, or four escape sequences representing the UTF-8 encoding of the character (will only be four escape sequences for characters composed of two \"surrogate\" characters)."
  },
  "encodeURIComponent": {
    "!type": "fn(uri: string) -> string",
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/encodeURIComponent",
    "!doc": "Encodes a Uniform Resource Identifier (URI) component by replacing each instance of certain characters by one, two, three, or four escape sequences representing the UTF-8 encoding of the character (will only be four escape sequences for characters composed of two \"surrogate\" characters)."
  },
  "decodeURI": {
    "!type": "fn(uri: string) -> string",
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/decodeURI",
    "!doc": "Decodes a Uniform Resource Identifier (URI) previously created by encodeURI or by a similar routine."
  },
  "decodeURIComponent": {
    "!type": "fn(uri: string) -> string",
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/decodeURIComponent",
    "!doc": "Decodes a Uniform Resource Identifier (URI) component previously created by encodeURIComponent or by a similar routine."
  },
  "Math": {
    "E": {
      "!type": "number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/E",
      "!doc": "The base of natural logarithms, e, approximately 2.718."
    },
    "LN2": {
      "!type": "number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/LN2",
      "!doc": "The natural logarithm of 2, approximately 0.693."
    },
    "LN10": {
      "!type": "number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/LN10",
      "!doc": "The natural logarithm of 10, approximately 2.302."
    },
    "LOG2E": {
      "!type": "number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/LOG2E",
      "!doc": "The base 2 logarithm of E (approximately 1.442)."
    },
    "LOG10E": {
      "!type": "number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/LOG10E",
      "!doc": "The base 10 logarithm of E (approximately 0.434)."
    },
    "SQRT1_2": {
      "!type": "number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/SQRT1_2",
      "!doc": "The square root of 1/2; equivalently, 1 over the square root of 2, approximately 0.707."
    },
    "SQRT2": {
      "!type": "number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/SQRT2",
      "!doc": "The square root of 2, approximately 1.414."
    },
    "PI": {
      "!type": "number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/PI",
      "!doc": "The ratio of the circumference of a circle to its diameter, approximately 3.14159."
    },
    "abs": {
      "!type": "fn(number) -> number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/abs",
      "!doc": "Returns the absolute value of a number."
    },
    "cos": {
      "!type": "fn(number) -> number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/cos",
      "!doc": "Returns the cosine of a number."
    },
    "sin": {
      "!type": "fn(number) -> number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/sin",
      "!doc": "Returns the sine of a number."
    },
    "tan": {
      "!type": "fn(number) -> number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/tan",
      "!doc": "Returns the tangent of a number."
    },
    "acos": {
      "!type": "fn(number) -> number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/acos",
      "!doc": "Returns the arccosine (in radians) of a number."
    },
    "asin": {
      "!type": "fn(number) -> number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/asin",
      "!doc": "Returns the arcsine (in radians) of a number."
    },
    "atan": {
      "!type": "fn(number) -> number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/atan",
      "!doc": "Returns the arctangent (in radians) of a number."
    },
    "atan2": {
      "!type": "fn(number, number) -> number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/atan2",
      "!doc": "Returns the arctangent of the quotient of its arguments."
    },
    "ceil": {
      "!type": "fn(number) -> number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/ceil",
      "!doc": "Returns the smallest integer greater than or equal to a number."
    },
    "floor": {
      "!type": "fn(number) -> number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/floor",
      "!doc": "Returns the largest integer less than or equal to a number."
    },
    "round": {
      "!type": "fn(number) -> number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/round",
      "!doc": "Returns the value of a number rounded to the nearest integer."
    },
    "exp": {
      "!type": "fn(number) -> number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/exp",
      "!doc": "Returns Ex, where x is the argument, and E is Euler's constant, the base of the natural logarithms."
    },
    "log": {
      "!type": "fn(number) -> number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/log",
      "!doc": "Returns the natural logarithm (base E) of a number."
    },
    "sqrt": {
      "!type": "fn(number) -> number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/sqrt",
      "!doc": "Returns the square root of a number."
    },
    "pow": {
      "!type": "fn(number, number) -> number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/pow",
      "!doc": "Returns base to the exponent power, that is, baseexponent."
    },
    "max": {
      "!type": "fn(number, number) -> number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/max",
      "!doc": "Returns the largest of zero or more numbers."
    },
    "min": {
      "!type": "fn(number, number) -> number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/min",
      "!doc": "Returns the smallest of zero or more numbers."
    },
    "random": {
      "!type": "fn() -> number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/random",
      "!doc": "Returns a floating-point, pseudo-random number in the range [0, 1) that is, from 0 (inclusive) up to but not including 1 (exclusive), which you can then scale to your desired range."
    },
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math",
    "!doc": "A built-in object that has properties and methods for mathematical constants and functions."
  },
  "JSON": {
    "parse": {
      "!type": "fn(json: string) -> ?",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/JSON/parse",
      "!doc": "Parse a string as JSON, optionally transforming the value produced by parsing."
    },
    "stringify": {
      "!type": "fn(value: ?) -> string",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/JSON/stringify",
      "!doc": "Convert a value to JSON, optionally replacing values if a replacer function is specified, or optionally including only the specified properties if a replacer array is specified."
    },
    "!url": "https://developer.mozilla.org/en-US/docs/JSON",
    "!doc": "JSON (JavaScript Object Notation) is a data-interchange format.  It closely resembles a subset of JavaScript syntax, although it is not a strict subset. (See JSON in the JavaScript Reference for full details.)  It is useful when writing any kind of JavaScript-based application, including websites and browser extensions.  For example, you might store user information in JSON format in a cookie, or you might store extension preferences in JSON in a string-valued browser preference."
  }
}

},{}],99:[function(require,module,exports){
var _          = require('underscore');
var middleware = require('../../state/middleware');
var isInScope  = require('../codemirror/is-in-scope');
var fromPath   = require('../from-path');

/**
 * Split arguments into an array of key to definition.
 *
 * @param  {String} string
 * @return {Array}
 */
var sanitizeFunctionType = function (string) {
  var fnParts = string.split(' -> ');
  var result  = fnParts.length > 1 ? fnParts.pop() : null;
  var fnType  = fnParts.join(' -> ');
  var args    = [];

  // Map the arguments to a sanitized string.
  var type = fnType.replace(/^fn\((.*)\)/, function (match, params) {
    var level    = 0;
    var argMap   = [];
    var curParam = '';

    // Iterate over every character categorizing into arguments.
    for (var i = 0; i < params.length; i++) {
      var char = params[i];

      if (char === ',' && level === 0) {
        argMap.push(curParam.trim());
        curParam = '';
      } else {
        curParam += char;

        if (char === '{' || char === '(') {
          level++;
        } else if (char === '}' || char === ')') {
          level--;
        }
      }
    }

    argMap.push(curParam);

    // Return only the argument names and push the definitions into an array.
    return 'fn(' + _.map(argMap, function (arg) {
      var split = arg.split(':');
      var name  = split.shift().trim();

      if (split.length) {
        args.push(sanitizeDefinition({
          '!type': split.join(':').trim()
        }));
      } else {
        args.push(null);
      }

      return name;
    }).join(', ') + ')';
  });

  // Return an object to be mixed in with the original description.
  return {
    '!type':   type,
    '!args':   args,
    '!return': result
  };
};

/**
 * Sanitize a definition object into our regular format.
 *
 * @param  {Object} definition
 * @return {Object}
 */

/* jshint -W003 */
var sanitizeDefinition = function (description) {
  _.each(description, function (describe, key) {
    // Skip over definition keys.
    if (!_.isObject(describe) || key.charAt(0) === '!') { return; }

    // Sanitize a function into its individual parts.
    if (/^fn\(/.test(describe['!type'])) {
      _.extend(describe, sanitizeFunctionType(describe['!type']));
    }

    return sanitizeDefinition(describe);
  });

  return description;
};
/* jshint +W003 */

/**
 * JavaScript description documents from Tern.js.
 *
 * @type {Array}
 */
var DESCRIPTIONS = _.map([
  require('./ecma5.json'),
  require('./browser.json')
], sanitizeDefinition);

/**
 * Recurse through the description structure and attach descriptions to nodes
 * using a `Map` interface.
 *
 * @param  {Map}    map
 * @param  {Object} describe
 * @param  {Object} global
 * @return {Map}
 */
var attachDescriptions = function (map, describe, global) {
  (function recurse (definition, context) {
    // Break recursion on a non-object.
    if (!_.isObject(context) || !_.isObject(definition)) { return; }

    // Set the map object reference to point to the description.
    map.set(context, definition);

    // Iterate over the definition object and attach more definitions.
    _.each(definition, function (describe, key) {
      // Definitions are prepended with an exclamation mark.
      if (key.charAt(0) === '!') { return; }

      // We need to use property descriptors here since Firefox throws errors
      // with getters on some prototype properties.
      var descriptor = Object.getOwnPropertyDescriptor(context, key);

      return descriptor && recurse(describe, descriptor.value);
    });
  })(describe, global);

  return map;
};

/**
 * Accepts a window object and returns an object for use with middleware.
 *
 * @param  {Object} sandbox
 * @return {Object}
 */
module.exports = function (global) {
  var map     = new Map();
  var plugins = {};

  // Iterate over the description documents and attach.
  _.each(DESCRIPTIONS, function (description) {
    attachDescriptions(map, description, global);
  });

  /**
   * Middleware plugin for describing native types.
   *
   * @param {Object}   data
   * @param {Function} next
   * @param {Function} done
   */
  plugins['completion:describe'] = function (data, next, done) {
    var token   = data.token;
    var context = data.context;
    var description;

    // Avoiding describing function arguments and variables.
    if (token.type === 'variable' && isInScope(token, token.string)) {
      return next();
    }

    if (context == null && data.parent) {
      try {
        context = data.parent[token.string];
      } catch (e) {}
    }

    if (_.isObject(context)) {
      description = map.get(context);
    }

    if (!description) {
      if (!data.parent) {
        return next();
      }

      var obj = data.parent;
      var type;

      while (obj) {
        var objDesc = map.get(obj);

        if (objDesc) {
          if ((type = objDesc['!type']) && type.charAt(0) === '+') {
            obj = fromPath(data.window, type.substr(1).split('.')).prototype;
            objDesc = map.get(obj);
          }

          if (objDesc[token.string]) {
            description = objDesc[token.string];
            break;
          }
        }

        obj = data.window.Object.getPrototypeOf(obj);
      }
    }

    // If we didn't retrieve a description, allow the next function to run.
    if (description == null) {
      return next();
    }

    return done(null, description);
  };

  /**
   * Middleware for looking up function return types for native functions.
   *
   * @param {Object}   data
   * @param {Function} next
   * @param {Function} done
   */
  plugins['completion:function'] = function (data, next, done) {
    var constructors = [
      data.window.Array,
      data.window.String,
      data.window.Boolean
    ];

    // Constructor functions are relatively easy to handle.
    if (data.isConstructor || _.contains(constructors, data.context)) {
      return done(null, data.context.prototype);
    }

    // This may be a little dodgy, but as long as someone hasn't extended the
    // native prototype object with something that has side-effects, we'll be
    // fine.
    if (!_.isObject(data.parent)) {
      return done(null, data.context.call(data.parent));
    }

    // Use the documentation to detect the return types.
    middleware.trigger('completion:describe', data, function (err, describe) {
      var returnType = describe && describe['!return'];

      // Check for an error and ensure we have a return description.
      if (err || !/^fn\(/.test(describe['!type']) || !returnType) {
        return next(err);
      }

      if (returnType === 'string') {
        return done(null, data.window.String());
      }

      if (returnType === 'number') {
        return done(null, data.window.Number());
      }

      if (returnType === 'bool') {
        return done(null, data.window.Boolean());
      }

      if (/\[.*\]/.test(returnType)) {
        return done(null, data.window.Array());
      }

      if (returnType === 'fn()') {
        return done(null, data.window.Function());
      }

      // Returns its own instance.
      if (returnType === '!this') {
        return done(null, data.parent);
      }

      // Instance type return.
      if (_.isString(returnType) && returnType.charAt(0) === '+') {
        var path        = returnType.substr(1).split('.');
        var constructor = fromPath(data.window, path);

        if (_.isFunction(constructor)) {
          return done(null, constructor.prototype);
        }
      }

      return next();
    }, true);
  };

  return plugins;
};

},{"../../state/middleware":109,"../codemirror/is-in-scope":75,"../from-path":94,"./browser.json":97,"./ecma5.json":98,"underscore":49}],100:[function(require,module,exports){
var middleware = require('../state/middleware');

/**
 * Creates a sandbox instance for executing arbitrary code.
 *
 * @return {Sandbox}
 */
var Sandbox = module.exports = function () {
  this.frame = document.createElement('iframe');
  this.frame.style.display = 'none';
  document.body.appendChild(this.frame);
  this.window = this.frame.contentWindow;
};

/**
 * Execute code in the sandbox environment.
 *
 * @param  {String}   code
 * @param  {Function} done
 */
Sandbox.prototype.execute = function (code, done) {
  var global = this.window;

  middleware.trigger('sandbox:context', {}, function (err, context) {
    // Allow middleware to run the execution event. This is the perfect handler
    // for async execution cells and even allows people to hook into the code
    // before it runs. Think linters, etc.
    middleware.trigger('sandbox:execute', {
      code:    code,
      context: context,
      window:  global
    }, done);
  });
};

/**
 * Remove the sandbox instance from the document.
 *
 * @return {Sandbox}
 */
Sandbox.prototype.remove = function () {
  this.frame.parentNode.removeChild(this.frame);
  delete this.frame;
  delete this.window;

  return this;
};

},{"../state/middleware":109}],101:[function(require,module,exports){
var _       = require('underscore');
var typeOf  = require('./type');
var __slice = Object.prototype.toString;

/**
 * Get a functions name.
 *
 * @param  {Function} fn
 * @return {String}
 */
var getFunctionName = function (fn) {
  return fn.name;
};

if (!('name' in Function.prototype)) {
  getFunctionName = function (fn) {
    var fnString = Function.prototype.toString.call(fn);

    // Run a simple regular expression to get the function name and return.
    return (/function\s+(.{1,})\s*\(/).exec(fnString)[1];
  };
}

/**
 * Gets internal object name. Works like the Chrome console and grabs the
 * contructor name to render with the preview.
 *
 * @param  {Object} object
 * @return {String}
 */
var getInternalName = function (object) {
  var name = 'Object';

  if (object == null) {
    return '' + object;
  }

  do {
    // By default, get the object type using `Object.prototype.toString`. This
    // is the most consistent method for built-in types returning things like
    // `JSON`, `global`, `HTMLDocument`, etc.
    name = __slice.call(object).slice(8, -1);

    // If the native object type is simply `Object`, try a more advanced
    // way of getting the type from the constructor function. This is really
    // only useful in client defined code and constructors. Wrap the whole
    // check in a `try..catch` statement since we don't know who's constructor
    // we are accessing and if it'll throw an error (E.g. `window.parent`).
    if (name === 'Object') {
      try {
        if (__slice.call(object.constructor) === '[object Function]') {
          name = getFunctionName(object.constructor);
        }
      } catch (e) {}
    }
  } while (name === 'Object' && (object = Object.getPrototypeOf(object)));

  return name;
};

/**
 * Stringify a string.
 *
 * @param  {String} string
 * @return {String}
 */
var stringifyString = function (string) {
  return '"' + string.replace(/"/g, '\\"') + '"';
};

/**
 * Stringify a child object, Chrome-style. This stringifies non-primitives to
 * their base name and keep primitives the visibly the same.
 *
 * @param  {*}      object
 * @return {String}
 */
var stringifyChild = function (object) {
  // Objects are renders as their object types. However, some types are known
  // lists so we can add the length to the preview.
  if (_.isObject(object)) {
    var internalName = getInternalName(object);

    // Check if the element is usually a list-like object.
    var isList = _.contains(
      ['Array', 'NodeList', 'HTMLCollection'], internalName
    );

    return internalName + (isList ? '[' + object.length + ']' : '');
  }

  if (_.isString(object)) {
    return stringifyString(object);
  }

  return '' + object;
};

/**
 * Stringify an array as an array literal.
 *
 * @param  {Array} array
 * @return {String}
 */
var stringifyArray = function (array) {
  return '[' + _.map(array, function (value) {
    return stringifyChild(value);
  }, this).join(', ') + ']';
};

/**
 * Stringify an object. Only does shallow stringification of enumerable
 * properties.
 *
 * @param  {Object} object
 * @return {String}
 */
var stringifyObject = function (object) {
  // Using the `keys` function to grab all the keys and then iterate, otherwise
  // when stringifying something like the window, it tries to use numeric
  // indexes like an array because of the `length` property.
  var objectString = _.map(_.keys(object), function (key) {
    var value = object[key];
    return stringifyString(key) + ': ' + stringifyChild(value);
  }, this).join(', ');

  return getInternalName(object) + ' {' + objectString + '}';
};

/**
 * Stringify an error instance.
 *
 * @param  {Error} error
 * @return {String}
 */
var stringifyError = function (error) {
  // TIL DOMExceptions don't allow calling `toString`.
  return Error.prototype.toString.call(error);
};

/**
 * Stringify an element node. Handle every type of node, not just elements but
 * also strings and comments.
 *
 * @param  {Node}   node
 * @return {String}
 */
var stringifyElement = function (node) {
  // Stringify document nodes by stringifying all child nodes.
  if (node.nodeType === Node.DOCUMENT_NODE) {
    return _.map(node.childNodes, function (childNode) {
      return stringifyElement(childNode);
    }).join('');
  }

  // Escape attribute node values. The name will already be escaped.
  if (node.nodeType === Node.ATTRIBUTE_NODE) {
    return node.name + '=' + stringifyString(node.value);
  }

  // The document type node needs manual concatination.
  if (node.nodeType === Node.DOCUMENT_TYPE_NODE) {
    var doctype = [node.nodeName];

    if (node.publicId) {
      doctype.push('PUBLIC', stringifyString(node.publicId));
    }

    if (node.systemId) {
      doctype.push(stringifyString(node.systemId));
    }

    return '<!DOCTYPE ' + doctype.join(' ') + '>';
  }

  // Not all elements can be appended, so if we fail render it as an object.
  // TODO: Track failures somewhere so I can add future support.
  try {
    var div = document.createElement('div');
    div.appendChild(node.cloneNode(true));
    return div.innerHTML;
  } catch (e) {
    return stringifyObject(node);
  }
};

/**
 * Stringy any elements passed in for the inspector preview.
 *
 * @param  {*} object
 * @return {String}
 */
var stringify = module.exports = function (object) {
  var type = typeOf(object);

  if (type === 'error') {
    return stringifyError(object);
  }

  if (type === 'array') {
    return stringifyArray(object);
  }

  if (type === 'object') {
    return stringifyObject(object);
  }

  if (type === 'string') {
    return stringifyString(object);
  }

  if (type === 'element') {
    var stringifiedElement = stringifyElement(object);

    // Ensure that stringified elements always have an output. Useful for cases
    // where we might be attempting to stringify an empty fragment.
    return stringifiedElement.trim() ? stringifiedElement : object.nodeName;
  }

  // Every other type can safely be typecasted to the expected output.
  return '' + object;
};

// Expose useful internal helpers.
stringify.stringifyChild  = stringifyChild;
stringify.getInternalName = getInternalName;

},{"./type":102,"underscore":49}],102:[function(require,module,exports){
module.exports = function (object) {
  switch (Object.prototype.toString.call(object)) {
  case '[object Function]':
    return 'function';
  case '[object Date]':
    return 'date';
  case '[object RegExp]':
    return 'regexp';
  case '[object Arguments]':
    return 'arguments';
  case '[object Array]':
    return 'array';
  case '[object String]':
    return 'string';
  case '[object Error]':
    return 'error';
  case '[object Number]':
    return 'number';
  }

  // Detect whether an object is an element using the `nodeType` property.
  if (object && object.nodeType === +object.nodeType) { return 'element'; }

  // Return a null type check or do the regular typeof.
  return object === null ? 'null' : typeof object;
};

},{}],103:[function(require,module,exports){
var Backbone = require('backbone');

/**
 * Plain cell model for use in the notebook collection.
 *
 * @type {Function}
 */
module.exports = Backbone.Model.extend({
  defaults: {
    type: 'text',
    value: ''
  }
});

},{"backbone":3}],104:[function(require,module,exports){
var _        = require('underscore');
var Backbone = require('backbone');

/**
 * Model used for holding a notebooks meta data.
 *
 * @type {Function}
 */
var Meta = module.exports = Backbone.Model.extend({
  defaults: {
    title: 'Untitled Notebook'
  }
});

/**
 * Reset a model by removing any unused attributes and updating everything else.
 *
 * @param  {Object} attrs
 * @param  {Object} options
 * @return {Meta}
 */
Meta.prototype.reset = function (attrs, options) {
  this.set(
    _.omit(this.attributes, _.keys(attrs)),
    _.extend({}, options, { unset: true })
  );

  this.set(attrs);

  return this;
};

},{"backbone":3,"underscore":49}],105:[function(require,module,exports){
var Backbone = require('backbone');
var Meta     = require('./meta');

/**
 * Create a notebook constructor for handling the notebook state.
 *
 * @type {[type]}
 */
var Notebook = module.exports = Backbone.Model.extend({
  defaults: {
    id:      null,
    meta:    null,
    cells:   [],
    ownerId: null,
    content: ''
  }
});

/**
 * Fix the notebook saying it's not new when it has an empty id.
 *
 * @return {Boolean}
 */
Notebook.prototype.isNew = function () {
  return !this.get('id');
};

/**
 * Set fresh model data when initializing.
 */
Notebook.prototype.initialize = function (attrs) {
  this.set('meta', (attrs && attrs.meta) || new Meta({
    title: 'Untitled Notebook'
  }));

  this.set('cells', (attrs && attrs.cells) || []);
};

},{"./meta":104,"backbone":3}],106:[function(require,module,exports){
var Backbone = require('backbone');

/**
 * Just a placeholder for the list of notebooks that the persistence plugin
 * maintains. Two fields.
 */
module.exports = Backbone.Model.extend({
  defaults: {
    id:        null,
    updatedAt: null
  }
});

},{"backbone":3}],107:[function(require,module,exports){
var Backbone = require('backbone');
var bounce   = require('../lib/bounce');

/**
 * Configuration is a static backbone model that we listen to for changes in
 * application setup.
 *
 * @type {Object}
 */
var config = module.exports = new Backbone.Model({
  // The url is the embedding frame url.
  // The `url` is the parent window url, `fullUrl` is the url to the full-size
  // application (E.g. Anypoint Platform), `siteUrl` is the static sponsoring
  // site and `siteTitle` is a configurable name for the site host.
  url:       window.location.href,
  fullUrl:   {"url":"https://mulesoft.github.io/api-notebook/","title":"API Notebook","oauthCallback":"/authenticate/oauth.html"}.url,
  siteUrl:   {"url":"https://mulesoft.github.io/api-notebook/","title":"API Notebook","oauthCallback":"/authenticate/oauth.html"}.url,
  siteTitle: {"url":"https://mulesoft.github.io/api-notebook/","title":"API Notebook","oauthCallback":"/authenticate/oauth.html"}.title,

  // Alter the visible UI.
  header:         true,
  footer:         false,
  sidebar:        true,
  savable:        true,
  embedded:       false,
  textReadOnly:   false,
  codeReadOnly:   false,
  authentication: true,

  // Set the UI text.
  authenticateText:   'Authenticate',
  unauthenticateText: 'Unauthenticate',

  // Content options.
  content:        '',
  defaultContent: ''
});

/**
 * Every time the style config changes, update the css.
 */
config.listenTo(config, 'change:style', (function () {
  var headEl  = document.head || document.getElementsByTagName('head')[0];
  var styleEl = headEl.appendChild(document.createElement('style'));

  return bounce(function () {
    styleEl.textContent = config.get('style');
  });
})());

/**
 * Listen for changes in the embedded config option and update conditional
 * styles.
 */
config.listenTo(config, 'change:embedded', bounce(function () {
  var isEmbedded      = !!config.get('embedded');
  var canAuthenticate = !!config.get('authentication');

  config.set({
    footer:       isEmbedded,
    header:       !isEmbedded,
    sidebar:      !isEmbedded && canAuthenticate,
    savable:      !isEmbedded && canAuthenticate,
    textReadOnly: !isEmbedded
  });

  var className = document.body.className.replace(' notebook-embedded', '');

  // If the notebook is embedded add the embedded class.
  if (isEmbedded) {
    document.body.className = className + ' notebook-embedded';
  }
}));

/**
 * Changes in authentication affect other parts of the application.
 */
config.listenTo(config, 'change:authentication', bounce(function () {
  var isEmbedded      = !!config.get('embedded');
  var canAuthenticate = !!config.get('authentication');

  config.set({
    sidebar: canAuthenticate && !isEmbedded,
    savable: canAuthenticate && !isEmbedded
  });
}));

},{"../lib/bounce":69,"backbone":3}],108:[function(require,module,exports){
var _         = require('underscore');
var Backbone  = require('backbone');
var domListen = require('../lib/dom-listen');

/**
 * Very simple implementation of a message bus that can be used anywhere within
 * the application.
 *
 * @type {Object}
 */
var messages = module.exports = _.extend({}, Backbone.Events);

/**
 * Proxy resize events to the current state.
 */
messages.listenTo(domListen(window), 'resize', _.throttle(function () {
  // Trigger a resize message to the parent frame.
  messages.trigger('resize');
}, 60));

},{"../lib/dom-listen":88,"backbone":3,"underscore":49}],109:[function(require,module,exports){
var _        = require('underscore');
var Backbone = require('backbone');

/**
 * Return a function that transforms a function into accept a single object
 * with the key as the first function parameter and the value as the second
 * function parameter.
 *
 * @param  {Function} fn
 * @return {Function}
 */
var acceptObject = function (fn) {
  return function (object) {
    if (typeof object === 'object') {
      return _.each(object, function (value, key) {
        return fn.call(this, key, value);
      }, this);
    }

    return fn.apply(this, arguments);
  };
};

/**
 * An event based implementation of a namespaced middleware system. Provides a
 * method to register new plugins and a queue system to trigger plugin hooks
 * while still being capable of having a fallback function.
 *
 * @type {Object}
 */
var middleware = module.exports = _.extend({}, Backbone.Events);

/**
 * The stack is an object that contains all the middleware functions to be
 * executed on an event. Similar in concept to `Backbone.Events._events`.
 * @type {Object}
 */
middleware._stack = {};

/**
 * Register a function callback for the plugin hook. This is similar to connect
 * middleware except plugins are passed a data object, next function and done
 * function. The registered plugins also run in reverse to normal, since we add
 * plugins after application initialization.
 *
 * @param  {String}   name
 * @param  {Function} fn
 * @return {this}
 */
middleware.register = acceptObject(function (name, fn) {
  var stack = this._stack[name] || (this._stack[name] = []);
  this.trigger('middleware:register', {
    name:   name,
    plugin: fn
  });
  stack.push(fn);
  return this;
});

/**
 * Register a plugin that will only run only once.
 *
 * @param  {String}   name
 * @param  {Function} fn
 * @return {this}
 */
middleware.registerOnce = acceptObject(function (name, fn) {
  return this.register(name, function self () {
    middleware.deregister(name, self);
    fn.apply(this, arguments);
    fn = null;
  });
});

/**
 * Removes a function, or all functions, from a given middleware trigger.
 *
 * @param  {String}   name
 * @param  {Function} fn
 * @return {this}
 */
middleware.deregister = acceptObject(function (name, fn) {
  var stack = this._stack[name] || [];

  for (var i = 0; i < stack.length; i++) {
    if (arguments.length < 2 || stack[i] === fn) {
      this.trigger('middleware:deregister', {
        name:   name,
        plugin: stack[i]
      });
      stack.splice(i, 1);
      i -= 1; // Decrement the index by one with the function we just removed.
    }
  }

  // Delete empty arrays.
  if (!stack.length) {
    delete this._stack[name];
  }

  return this;
});

/**
 * Checks whether a middleware stack exists for the
 *
 * @param  {String}  name
 * @return {Boolean}
 */
middleware.exists = function (name) {
  return !!(this._stack[name] && this._stack[name].length);
};

/**
 * Listens to any events triggered on the middleware system and runs through
 * the middleware stack based on the event name.
 *
 * @param {String}   name
 * @param {Object}   data
 * @param {Function} done
 * @param {Function} discard
 */
middleware.listenTo(middleware, 'all', function (name, data, done, discard) {
  var sent  = false;
  var stack = this._stack[name] || [];
  var index = stack.length;
  var previousData;

  // Call the final function when we are done executing the middleware stack.
  // It should also be passed as a parameter of the data object to each
  // middleware operation since it's possible to short-circuit the entire stack.
  var over = function (err, data) {
    // Set the function to have been already "run" and call the final function.
    sent = true;

    if (_.isFunction(done)) {
      // If we don't have enough arguments, send the previous data object.
      if (arguments.length < 2 && !discard) {
        data = previousData;
      }

      return done(err, data);
    }
  };

  // Call the next function on the stack, passing errors from the previous
  // stack call so it could be handled within the stack by another middleware.
  (function move (err, data) {
    var layer = stack[--index];

    // If we were provided two arguments, the second argument would have been
    // an updated data object. If we weren't passed two arguments, use the
    // previous know data object.
    if (arguments.length < 2) {
      data = previousData;
    } else {
      previousData = data;
    }

    // If we have called the done function inside a plugin, or we have hit
    // the end of the stack loop, we need to break the recursive next loop.
    if (sent || !layer) {
      if (!sent) {
        over(err, discard ? null : data);
      }

      return;
    }

    try {
      var arity  = layer.length;
      var called = (function (has) {
        return function (fn) {
          return function () {
            if (has) { return; }

            has = true;
            return fn.apply(null, arguments);
          };
        };
      })(false);

      // Error handling middleware can be registered by using a function with
      // four arguments. E.g. `function (err, data, next, done) {}`. Any
      // functions with less than four arguments will be called when we don't
      // have an error in the pipeline.
      if (err) {
        if (arity > 3) {
          layer(err, data, called(move), called(over));
        } else {
          move(err, data);
        }
      } else if (arity < 4) {
        layer(data, called(move), called(over));
      } else {
        move(null, data);
      }
    } catch (e) {
      move(e, data);
    }
  })(null, data);
});

},{"backbone":3,"underscore":49}],110:[function(require,module,exports){
var _                = require('underscore');
var Backbone         = require('backbone');
var config           = require('./config');
var messages         = require('./messages');
var middleware       = require('./middleware');
var bounce           = require('../lib/bounce');
var isMac            = require('../lib/browser/about').mac;
var Notebook         = require('../models/notebook');
var PersistenceItems = require('../collections/persistence-items');

/**
 * Persistence is a static model that holds all persistent notebook data.
 *
 * @type {Function}
 */
var Persistence = Backbone.Model.extend({
  defaults: {
    items:      new PersistenceItems(),
    notebook:   new Notebook(),
    state:      0,
    userId:     null,
    userTitle:  '',
    readyState: false
  }
});

/**
 * Represent persistence states in event listeners as numerical entities.
 *
 * @type {Number}
 */
Persistence.prototype.NULL      = Persistence.NULL      = 0;
Persistence.prototype.SAVING    = Persistence.SAVING    = 1;
Persistence.prototype.LOADING   = Persistence.LOADING   = 2;
Persistence.prototype.SAVE_FAIL = Persistence.SAVE_FAIL = 3;
Persistence.prototype.SAVE_DONE = Persistence.SAVE_DONE = 4;
Persistence.prototype.LOAD_FAIL = Persistence.LOAD_FAIL = 5;
Persistence.prototype.LOAD_DONE = Persistence.LOAD_DONE = 6;
Persistence.prototype.CHANGED   = Persistence.CHANGED   = 7;
Persistence.prototype.CLONING   = Persistence.CLONING   = 8;

/**
 * Return whether the current user session is the owner of the current notebook.
 *
 * @param  {Object}  model
 * @return {Boolean}
 */
Persistence.prototype.isOwner = function (model) {
  return !model.get('ownerId') || model.get('ownerId') === this.get('userId');
};

/**
 * Check if the user is the owner of the current notebook.
 *
 * @return {Boolean}
 */
Persistence.prototype.isCurrentOwner = function () {
  return this.isOwner(this.get('notebook'));
};

/**
 * Check if a model is new.
 *
 * @param  {Object}  model
 * @return {Boolean}
 */
Persistence.prototype.isNew = function (model) {
  return !model.get('id');
};

/**
 * Check if the current model is new.
 *
 * @return {Boolean}
 */
Persistence.prototype.isCurrentNew = function () {
  return this.isNew(this.get('notebook'));
};

/**
 * Return whether a user is currently authenticated.
 *
 * @return {Boolean}
 */
Persistence.prototype.isAuthenticated = function () {
  return this.has('userId');
};

/**
 * Checks whether a persistence model has been unsaved.
 *
 * @param  {Object}  model
 * @return {Boolean}
 */
Persistence.prototype.isSaved = function (model) {
  // Check against a map of the different states.
  return model.get('savedContent') === model.get('content');
};

/**
 * Check if the current model has been saved.
 *
 * @return {Boolean}
 */
Persistence.prototype.isCurrentSaved = function () {
  return this.isSaved(this.get('notebook'));
};

/**
 * Check whether a notebook should be saved. There are a number of factors that
 * dictate whether we *should* save the notebook.
 *
 * @param  {Object}  model
 * @return {Boolean}
 */
Persistence.prototype.shouldSave = function (model) {
  return !this.isNew(model) &&
    !this.isSaved(model) &&
    this.isOwner(model) &&
    this.isAuthenticated();
};

/**
 * Serialize a model and update the content string.
 *
 * @param {Object}   model
 * @param {Function} done
 */
Persistence.prototype.serialize = function (model, done) {
  middleware.trigger(
    'persistence:serialize',
    _.extend(this.getMiddlewareData(model), {
      content: null
    }),
    function (err, data) {
      model.set('content', data.content);
      return done(err, data);
    }
  );
};

/**
 * Deserialize a models content and set the cells array.
 *
 * @param {Object}   object
 * @param {Function} done
 */
Persistence.prototype.deserialize = function (model, done) {
  middleware.trigger(
    'persistence:deserialize',
    _.extend(this.getMiddlewareData(model), {
      ownerId: null,
      cells:   null
    }),
    function (err, data) {
      model.get('meta').reset(data.meta);
      model.set('cells', data.cells);
      return done(err, data);
    }
  );
};

/**
 * Create a new notebook.
 *
 * @param {Function} done
 */
Persistence.prototype.new = function (done) {
  this.set('state', Persistence.NULL);

  return this.load(new Notebook(), done);
};

/**
 * Save a notebook model.
 *
 * @param {Object}   model
 * @param {Function} done
 */
Persistence.prototype.save = function (model, done) {
  if (!config.get('savable')) {
    return done && done(new Error('Save is not available'));
  }

  if (!this.isOwner(model)) {
    return done && done(new Error('You are not the current notebook owner'));
  }

  this.set('state', Persistence.SAVING);

  middleware.trigger(
    'persistence:save',
    this.getMiddlewareData(model),
    _.bind(function (err, data) {
      if (err) {
        this.set('state', Persistence.SAVE_FAIL);
        return done && done(err);
      }

      // Update the model attributes.
      model.set('id',        data.id);
      model.set('content',   data.content);
      model.set('ownerId',   data.ownerId);
      model.set('updatedAt', new Date());
      model.get('meta').reset(data.meta);
      model.set('savedContent', model.get('content'));

      this.set('state', Persistence.SAVE_DONE);

      // Add a persistence item entry.
      this.get('items').add({
        id:        model.get('id'),
        meta:      model.get('meta').toJSON(),
        updatedAt: model.get('updatedAt')
      }, {
        merge: true
      });

      return done && done();
    }, this)
  );
};

/**
 * Remove a given notebook, specified by its id, which is persistence
 * engine-specific.
 *
 * @param {String}   id
 * @param {Function} done
 */
Persistence.prototype.remove = function (id, done) {
  middleware.trigger('persistence:remove', {
    id: id
  }, _.bind(function(err) {
    if (err) {
      return done && done(err);
    }

    this.get('items').remove(this.get('items').get(id));

    return done && done();
  }, this));
};

/**
 * Authenticate with the external persistence provider.
 *
 * @param {Function} done
 */
Persistence.prototype.authenticate = function (done) {
  if (!config.get('authentication')) {
    return done && done(new Error('Authentication has been disabled'));
  }

  middleware.trigger(
    'persistence:authenticate',
    _.extend(this.getMiddlewareData(), {
      userId:    null,
      userTitle: null
    }),
    _.bind(function (err, data) {
      this.set('userId',    data.userId);
      this.set('userTitle', data.userTitle);

      return done && done(err);
    }, this)
  );
};

/**
 * Unauthenticate the persistence layer login.
 *
 * @param {Function} done
 */
Persistence.prototype.unauthenticate = function (done) {
  middleware.trigger(
    'persistence:unauthenticate',
    this.getMiddlewareData(),
    _.bind(function (err) {
      this.unset('userId');
      this.unset('userTitle');

      this.get('items').reset();

      return done && done(err);
    }, this)
  );
};

/**
 * Get the persistence object in a format that is suitable for middleware.
 *
 * @return {Object}
 */
Persistence.prototype.getMiddlewareData = function (model) {
  var obj = model ? model.toJSON() : {};

  return _.extend(obj, {
    meta:            model ? model.get('meta').toJSON() : {},
    save:            _.bind(this.save, this, model),
    isNew:           _.bind(this.isNew, this, model),
    isOwner:         _.bind(this.isOwner, this, model),
    isSaved:         _.bind(this.isSaved, this, model),
    shouldSave:      _.bind(this.shouldSave, this, model),
    authenticate:    _.bind(this.authenticate, this),
    isAuthenticated: _.bind(this.isAuthenticated, this)
  });
};

/**
 * Load a notebook model.
 *
 * @param {Object}   model
 * @param {Function} done
 */
Persistence.prototype.load = function (model, done) {
  model._loading = true;
  this.set('state', Persistence.LOADING);

  return middleware.trigger(
    'persistence:load',
    _.extend(this.getMiddlewareData(model), {
      meta:    {},
      content: null,
      cells:   null
    }),
    _.bind(function (err, data) {
      // Update all relevant model attributes.
      model.set({
        id:        data.id,
        ownerId:   data.ownerId,
        updatedAt: data.updatedAt
      });

      model.set('content', data.content, {
        silent: true
      });

      delete model._loading;

      var complete = _.bind(function (err) {
        this.set('state', err ? Persistence.LOAD_FAIL : Persistence.LOAD_DONE);

        return done && done(err);
      }, this);

      if (err) {
        return complete(err);
      }

      return this.loadModel(model, complete);
    }, this)
  );
};

/**
 * Extremely basic model load function.
 */
Persistence.prototype.loadModel = function (model, done) {
  return this.deserialize(model, _.bind(function (err) {
    model.set('savedContent', model.get('content'));

    this.set('notebook', model);
    config.set('content', model.get('content'));
    this.trigger('changeNotebook');

    return done && done(err);
  }, this));
};

/**
 * Generate a list of all loadable notebooks. Note that this will often
 * involve going to the network or disk.
 *
 * @param {Function} done
 */
Persistence.prototype.list = function (done) {
  if (!this.isAuthenticated()) {
    return done && done(new Error('Not authenticated'));
  }

  return middleware.trigger(
    'persistence:list', [], _.bind(function (err, list) {
      this.get('items').set(list);

      return done(err, this.get('items').toJSON());
    }, this)
  );
};

/**
 * Clone the notebook and reset the persistence layer to look normal again.
 */
Persistence.prototype.clone = function (done) {
  this.set('state', Persistence.CLONING);

  var model = this.get('notebook').clone();

  // Set the notebook instance in the state.
  model.unset('id');
  model.unset('ownerId');

  middleware.trigger(
    'persistence:clone',
    this.getMiddlewareData(model),
    _.bind(function (err, data) {
      model.set('cells', data.cells, { silent: true });
      model.get('meta').reset(data.meta);

      this.set('state', Persistence.NULL);
      this.set('notebook', model);
      this.trigger('changeNotebook');

      return done && done(err);
    }, this)
  );
};

/**
 * Export a static instance of the persistence model.
 *
 * @type {Object}
 */
var persistence = module.exports = new Persistence();

/**
 * Sync the notebook and stringified contents together.
 */
persistence.listenTo(persistence, 'change:notebook', bounce((function () {
  var model   = persistence.get('notebook');
  var syncing = false;

  /**
   * Wrap sync methods to protect from an infinite loop.
   *
   * @param  {Function} fn
   * @return {Function}
   */
  var wrapSync = function (method) {
    return function () {
      if (syncing) { return; }

      syncing = true;

      return persistence[method](model, function () {
        syncing = false;
      });
    };
  };

  /**
   * Wrap serialization in async guards.
   */
  var serialize   = wrapSync('serialize');
  var deserialize = wrapSync('deserialize');

  return function () {
    /**
     * Remove listeners on the previous notebook instance.
     */
    persistence.stopListening(model);
    persistence.stopListening(model.get('meta'));
    model = persistence.get('notebook');

    /**
     * Deserialize the notebook on static changes.
     */
    persistence.listenTo(model, 'change:content', deserialize);

    /**
     * Serialize the notebook on dynamic changes.
     */
    persistence.listenTo(model, 'change:cells', serialize);
    persistence.listenTo(model.get('meta'), 'change', serialize);

    /**
     * Update the configuration id any time the model changes.
     */
    persistence.listenTo(model, 'change:id', bounce(function () {
      config.set('id', model.get('id'));
    }));

    /**
     * Any changes that occur should be synced with the state and config.
     */
    persistence.listenTo(model, 'change:content', bounce(function () {
      // Avoid triggering content changes when the notebook is loading.
      if (model._loading) { return; }

      var hasChanged = !persistence.isSaved(model);

      config.set('content', model.get('content'));
      persistence.set('state', persistence[hasChanged ? 'CHANGED' : 'NULL']);

      middleware.trigger(
        'persistence:change',
        persistence.getMiddlewareData(persistence.get('notebook'))
      );
    }));
  };
})()));

/**
 * Listens to any changes to the user id and emits a custom `changeUser` event
 * that different parts of the application bind to and does things like
 * rerendering of notebook.
 */
persistence.listenTo(
  persistence, 'change:userId change:userTitle', _.debounce(function () {
    this.trigger('changeUser', this);
  }, 300)
);

/**
 * Check with an external service whether a users session is authenticated. This
 * should only check, and not actually trigger authentication which would be a
 * jarring experience. Also load the initial notebook contents alongside.
 */
persistence.listenTo(middleware, 'application:ready', function () {
  if (!config.get('authentication')) {
    return;
  }

  return middleware.trigger(
    'persistence:authenticated',
    _.extend(this.getMiddlewareData(), {
      userId:    null,
      userTitle: null
    }), _.bind(function (err, data) {
      this.set('userId',     data.userId);
      this.set('userTitle',  data.userTitle);

      // Set the ready state flag for the API Notebook Site to hook onto.
      this.set('readyState', true);

      if (!this.has('id') && !this.has('ownerId')) {
        this.set('ownerId', this.get('userId'));
      }
    }, this)
  );
});

/**
 * On load messages, reload the current persistence object.
 */
persistence.listenTo(messages, 'load', function (id) {
  return persistence.load(new Notebook({ id: id }));
});

/**
 * Keep the persistence meta data in sync with the config option.
 */
persistence.listenTo(config, 'change:url', function () {
  if (!config.get('id')) { return; }

  persistence.get('notebook').get('meta').set('site', config.get('url'));
});

/**
 * When the application is ready, finally attempt to load the initial content.
 *
 * @param {Object}   app
 * @param {Function} next
 */
middleware.register('application:ready', function (app, next) {
  var notebook = new Notebook({
    id:      config.get('id'),
    content: config.get('content')
  });

  // Handle configuration content over a remote data load.
  if (notebook.get('content')) {
    return persistence.loadModel(notebook, next);
  }

  return persistence.load(notebook, next);
});

/**
 * When the application is ready, start listening for live id changes.
 *
 * @param {Object}   app
 * @param {Function} next
 */
middleware.register('application:ready', function (app, next) {
  /**
   * Listens for global id changes and updates persistence. Primarily for
   * loading a new notebook from the embed frame where the current url scheme
   * is unlikely to be maintained.
   */
  persistence.listenTo(config, 'change:id', function () {
    var configId   = config.get('id');
    var notebookId = persistence.get('notebook').get('id');

    // Avoid loading over the same notebook instance.
    if ((!configId && !notebookId) || (configId === notebookId)) {
      return;
    }

    persistence.load(new Notebook({ id: configId }));
  });

  return next();
});

/**
 * When the application is ready, start listening for config content changes.
 *
 * @param {Object}   app
 * @param {Function} next
 */
middleware.register('application:ready', function (app, next) {
  persistence.listenTo(config, 'change:content', function () {
    var configContent   = config.get('content');
    var notebookContent = persistence.get('notebook').get('content');

    // Avoid loading over the same notebook content.
    if (configContent === notebookContent) {
      return;
    }

    persistence.loadModel(new Notebook({ content: configContent }));
  });

  return next();
});

/**
 * Register a function to block the regular save button and override with saving
 * to the persistence layer.
 */
middleware.register(
  'keydown:' + (isMac ? 'Cmd' : 'Ctrl') + '-S',
  function (event, next, done) {
    if (!config.get('savable')) { return; }

    event.preventDefault();
    return persistence.save(persistence.get('notebook'), done);
  }
);

},{"../collections/persistence-items":67,"../lib/bounce":69,"../lib/browser/about":70,"../models/notebook":105,"./config":107,"./messages":108,"./middleware":109,"backbone":3,"underscore":49}],111:[function(require,module,exports){
var DOMBars  = require('dombars/runtime');
var Backbone = require('backbone');
var messages = require('./messages');

/**
 * Extendable implementation of application state data. State can listen to the
 * global messaging object, but it should never listen the other way around.
 *
 * @type {Object}
 */
var state = module.exports = new Backbone.Model();

/**
 * Keep track of the previous execution.
 */
var execTimeout = null;

/**
 * Listen to resize events through the messages and update the current state.
 */
state.listenTo(messages, 'resize refresh', function () {
  if (execTimeout) {
    return;
  }

  /**
   * Should be most performant to utilize the render loop.
   */
  execTimeout = DOMBars.VM.exec(function () {
    execTimeout = null;

    state.set('viewportWidth',  window.innerWidth);
    state.set('viewportHeight', window.innerHeight);
    state.set('documentWidth',  document.documentElement.scrollWidth);
    state.set('documentHeight', document.documentElement.scrollHeight);
  });
});

},{"./messages":108,"backbone":3,"dombars/runtime":42}],112:[function(require,module,exports){
var _        = require('underscore');
var storage  = require('store');
var Backbone = require('backbone');

/**
 * The constructor function for a store instance.
 *
 * @type {Function}
 */
var Store = Backbone.Model.extend();

/**
 * Set all the attributes from localStorage on initialization.
 */
Store.prototype.initialize = function () {
  if (!storage.enabled) { return; }

  _.each(storage.getAll(), function (value, key) {
    if (!this._isPersistenceKey(key)) { return; }

    this.attributes[key.substr(this._prefix.length + 1)] = value;
  }, this);
};

/**
 * The prefix for storing in localStorage.
 *
 * @type {String}
 */
Store.prototype._prefix = 'store';

/**
 * Returns the persistence key for localStorage.
 *
 * @param  {String} key
 * @return {String}
 */
Store.prototype._persistenceKey = function (key) {
  return this._prefix + '-' + key;
};

/**
 * Validate a key and check if it is a valid persistence key for this instance.
 *
 * @param  {String}  key
 * @return {Boolean}
 */
Store.prototype._isPersistenceKey = function (key) {
  return key.substr(0, this._prefix.length + 1) === this._prefix + '-';
};

/**
 * Override `set` to also save to localStorage.
 *
 * @param {String} key
 * @param {*}      value
 */
Store.prototype.set = function (key, value, options) {
  var attrs;

  if (typeof key === 'object') {
    attrs   = key;
    options = value;
  } else {
    (attrs = {})[key] = value;
  }

  if (storage.enabled) {
    // Can't seem to ignore the JSHint `for` loop body error here, so this
    // behaviour is inconsistent with `Backbone.prototype.set`.
    for (var attr in attrs) {
      if (_.has(attrs, attr)) {
        var method = options && options.unset ? 'remove' : 'set';
        storage[method](this._persistenceKey(attr), attrs[attr]);
      }
    }
  }

  return Backbone.Model.prototype.set.apply(this, arguments);
};

/**
 * Override `clear` to also empty localStorage.
 */
Store.prototype.clear = function () {
  // Check all the keys in persistent store and remove keys active for this
  // instance.
  if (storage.enabled) {
    _.each(storage.getAll(), function (value, key) {
      if (this._isPersistenceKey(key)) {
        storage.remove(key);
      }
    }, this);
  }

  return Backbone.Model.prototype.clear.apply(this, arguments);
};

/**
 * Override `unset` to also remove the key from localStorage.
 */
Store.prototype.unset = function (key) {
  if (storage.enabled) {
    storage.remove(this._persistenceKey(key));
  }

  return Backbone.Model.prototype.unset.call(this, key);
};

/**
 * Generate a custom storage scheme and attach to the regular store.
 *
 * @param  {String} name
 * @return {Object}
 */
Store.prototype.customStore = function (name) {
  if (!_.isString(name)) {
    throw new Error('Custom stores require a storage prefix');
  }

  var CustomStore = this.constructor.extend({
    _prefix: name
  });

  return (this._ || (this._ = {}))[name] = new CustomStore();
};

/**
 * Export a static instance of the store model.
 *
 * @type {Store}
 */
module.exports = new Store();

},{"backbone":3,"store":48,"underscore":49}],113:[function(require,module,exports){
var _        = require('underscore');
var DOMBars  = require('../lib/dombars');
var Backbone = require('backbone');

var View         = require('./template');
var Sidebar      = require('./sidebar');
var Notebook     = require('./notebook');
var EditNotebook = require('./edit-notebook');
var bounce       = require('../lib/bounce');
var controls     = require('../lib/controls');
var state        = require('../state/state');
var config       = require('../state/config');
var messages     = require('../state/messages');
var middleware   = require('../state/middleware');
var persistence  = require('../state/persistence');
var domListen    = require('../lib/dom-listen');
var notifyError  = require('../lib/notify-error');

var ENTER_KEY    = 13;
var EMBED_SCRIPT = {"script":"https://mulesoft.github.io/api-notebook/scripts/embed.js"}.script;

/**
 * Create a central application view.
 *
 * @type {Function}
 */
var App = module.exports = View.extend({
  className: 'application'
});

/**
 * Keep track of all events that can be triggered from the DOM.
 *
 * @type {Object}
 */
App.prototype.events = {
  // Block clicks on a disabled button.
  'click .toolbar-buttons button': function (e) {
    var node = e.target;

    while (node.tagName !== 'BUTTON') {
      node = node.parentNode;
    }

    if (node.classList.contains('btn-disabled')) {
      e.stopImmediatePropagation();
    }
  },
  'click .notebook-help':   'showShortcuts',
  'click .notebook-exec':   'runNotebook',
  'click .notebook-clone':  'cloneNotebook',
  'click .notebook-save':   'saveNotebook',
  'click .notebook-share':  'shareNotebook',
  'click .toggle-notebook': 'toggleView',
  'click .notebook-new':    'newNotebook',
  // Listen for `Enter` presses and blur the input.
  'keydown .notebook-title': function (e) {
    if (e.which !== ENTER_KEY) { return; }

    e.preventDefault();
    e.srcElement.blur();
  },
  // Update the notebook title on blur to avoid multiple persistence attempts.
  'focusout .notebook-title': function (e) {
    persistence.get('notebook').get('meta').set('title', e.target.value);
  }
};

/**
 * Runs when we create an instance of the applications. Starts listening for
 * relevant events to respond to.
 */
App.prototype.initialize = function () {
  View.prototype.initialize.apply(this, arguments);

  var model = persistence.get('notebook');

  // Set a sidebar instance to render.
  this.data.set('sidebar', new Sidebar());
  this.data.set('activeView', 'view');

  /**
   * Block attempts to close the window when the persistence state is dirty.
   */
  this.listenTo(domListen(window), 'beforeunload', function (e) {
    if (!config.get('savable') || persistence.isCurrentSaved()) { return; }

    return (e || window.event).returnValue = 'Your changes will be lost.';
  });

  /**
   * Re-render the notebook when the notebook changes.
   */
  this.listenTo(persistence, 'changeNotebook', this.renderView);

  /**
   * Update user state data when the user changes.
   */
  this.listenTo(persistence, 'changeUser changeNotebook', bounce(function () {
    var canSave = config.get('savable');
    var isOwner = persistence.isCurrentOwner();

    this.data.set('owner',         isOwner);
    this.data.set('savable',       canSave && isOwner);
    this.data.set('authenticated', persistence.isAuthenticated());
  }, this));

  /**
   * Update the saved view state when the id changes.
   */
  this.listenTo(persistence, 'change:notebook', bounce(function () {
    this.stopListening(model, 'change:id');
    this.stopListening(model.get('meta'), 'change:title');

    // Update model reference.
    model = persistence.get('notebook');

    this.listenTo(model, 'change:id', bounce(function () {
      var canSave = config.get('savable');
      var isNew   = persistence.isNew(model);

      this.data.set('shareable', !isNew);
      this.data.set('cloneable', canSave && !isNew);
    }, this));

    // Update the title when the current notebook updates.
    this.listenTo(model.get('meta'), 'change:title', bounce(function () {
      var title   = model.get('meta').get('title');
      var titleEl = this.el.querySelector('.notebook-title');

      if (titleEl) {
        titleEl.value = title;
      }

      document.title = title ? title + '  Notebook' : 'Notebook';
    }, this));
  }, this));

  /**
   * Update state variables when the persistence state changes.
   */
  this.listenTo(persistence, 'change:state', bounce(function () {
    var timestamp    = new Date().toLocaleTimeString();
    var isNew        = persistence.isCurrentNew();
    var currentState = persistence.get('state');
    var canSave      = config.get('savable');

    var states = {
      1: 'Saving',
      2: 'Loading',
      3: 'Save failed',
      4: isNew ? '' : 'Saved ' + timestamp,
      5: 'Load Failed',
      6: isNew ? '' : 'Loaded ' + timestamp,
      7: canSave ? 'Unsaved changes' : '', // Avoid displaying when impossible.
      8: 'Cloning notebook'
    };

    if (currentState === 5) {
      middleware.trigger('ui:notify', {
        title: 'Load failed!',
        message: 'Could not load the notebook'
      });
    }

    state.set('loading',       currentState === 2);
    this.data.set('stateText', states[currentState]);
  }, this));

  /**
   * Add or remove a footer class depending on visibility.
   */
  this.listenTo(config, 'change:header', bounce(function () {
    var has = config.get('header');
    this.el.classList[has ? 'add' : 'remove']('application-has-header');
  }, this));

  /**
   * Add or remove a footer class depending on visibility.
   */
  this.listenTo(config, 'change:footer', bounce(function () {
    var has = config.get('footer');
    this.el.classList[has ? 'add' : 'remove']('application-has-footer');
  }, this));

  return this;
};

/**
 * Precompile the appliction template.
 *
 * @type {Function}
 */
App.prototype.template = require('../../templates/views/app.hbs');

/**
 * Render the current view.
 */
App.prototype.renderView = function () {
  var view   = this.data.get('activeView');
  var method = (view === 'view' ? 'showNotebook' : 'showEditor');

  return this[method]();
};

/**
 * Render the standard notebook view.
 */
App.prototype.showNotebook = function () {
  this.data.set('notebook', new Notebook({
    model: persistence.get('notebook')
  }));

  this.data.set('activeView', 'view');
  DOMBars.VM.exec(_.bind(messages.trigger, messages, 'refresh'));
};

/**
 * Render the notebook raw source editor.
 */
App.prototype.showEditor = function () {
  this.data.set('notebook', new EditNotebook({
    model: persistence.get('notebook')
  }));

  this.data.set('activeView', 'edit');
  DOMBars.VM.exec(_.bind(messages.trigger, messages, 'refresh'));
};

/**
 * Toggle the view between edit and notebook view.
 */
App.prototype.toggleView = function () {
  // Set the opposite view to active.
  var view = this.data.get('activeView');
  this.data.set('activeView', view === 'view' ? 'edit' : 'view');

  return this.renderView();
};

/**
 * Shows the shortcut modal.
 */
App.prototype.showShortcuts = function () {
  var allControls = controls.editor.concat(controls.code).concat(controls.text);

  middleware.trigger('ui:modal', {
    title: 'Keyboard Shortcuts',
    content: [
      '<table class="controls-table">' +
        '<colgroup>' +
          '<col class="controls-col-mini">' +
          '<col class="controls-col-large">' +
        '</colgroup>' +
        '<tr>' +
          '<th>Key Combination</th>' +
          '<th>Action</th>' +
        '</tr>' +
        _.map(allControls, function (control) {
          return [
            '<tr>',
            '<td>' + (control.keyCode || control.shortcut) + '</td>',
            '<td>' + control.description + '</td>',
            '</tr>'
          ].join('\n');
        }).join('\n') +
      '</table>'
    ].join('\n')
  });
};

/**
 * Append the application view to an element.
 *
 * @return {App}
 */
App.prototype.appendTo = function () {
  View.prototype.appendTo.apply(this, arguments);
  this.renderView();
  return this;
};

/**
 * Runs the entire notebook sequentially.
 */
App.prototype.runNotebook = function () {
  return this.data.get('notebook').execute();
};

/**
 * Clone the current notebook in-memory.
 */
App.prototype.cloneNotebook = function () {
  return persistence.clone(notifyError('Could not clone notebook'));
};

/**
 * Manually attempt to save the notebook.
 */
App.prototype.saveNotebook = function () {
  return persistence.save(
    persistence.get('notebook'), notifyError('Could not save notebook')
  );
};

/**
 * Manually create a new notebook instance. Before we discard any current
 * changes, check with the user.
 */
App.prototype.newNotebook = function () {
  var newNotebook = function (err, confirmed) {
    if (err || !confirmed) { return; }

    return persistence.new(notifyError('Could not create new notebook'));
  };

  // If the current notebook is already saved, immediately reload.
  if (persistence.isCurrentSaved()) {
    return newNotebook(null, true);
  }

  // Confirm with the user that this is the action they want to do.
  return middleware.trigger('ui:confirm', {
    title: 'You have unsaved changes. Abandon changes?',
    content: '<p>' +
      'Save your work by pressing \'Cancel\' and ' +
      'then clicking the save icon in the toolbar or using ' +
      'the keystroke CMD + S (or CTRL + S).' +
      '</p>' +
      '<p>' +
      'Press \'OK\' to abandon this notebook. ' +
      'Your changes will be lost.' +
      '</p>'
  }, newNotebook);
};

/**
 * Share the notebook inside a modal display.
 */
App.prototype.shareNotebook = function () {
  var id          = persistence.get('notebook').get('id');
  var shareScript = '<script src="' + EMBED_SCRIPT + '" data-notebook' +
    (id ? ' data-id="' + id + '"' : '') + '></script>';

  middleware.trigger('ui:modal', {
    title: 'Share Notebook',
    content: '<p class="notebook-share-about">Copy this code to embed.</p>' +
      '<div class="form-group">' +
      '<input class="notebook-share-input item-share" ' +
      'value="' + _.escape(shareScript) + '" readonly>' +
      '<p class="notebook-share-about">Copy this link to share.</p>' +
      '<input class="notebook-share-input item-share" ' +
      'value="' + config.get('url') + '" readonly>' +
      '</div>',
    show: function (modal) {
      Backbone.$(modal.el).on('click', '.notebook-share-input', function (e) {
        e.target.select();
      });
    }
  });
};

},{"../../templates/views/app.hbs":129,"../lib/bounce":69,"../lib/controls":87,"../lib/dom-listen":88,"../lib/dombars":93,"../lib/notify-error":95,"../state/config":107,"../state/messages":108,"../state/middleware":109,"../state/persistence":110,"../state/state":111,"./edit-notebook":117,"./notebook":123,"./sidebar":125,"./template":126,"backbone":3,"underscore":49}],114:[function(require,module,exports){
var _         = require('underscore');
var View      = require('./template');
var template  = require('../../templates/views/cell-buttons.hbs');
var domListen = require('../lib/dom-listen');

/**
 * Displays the cell controls overlay menu.
 *
 * @type {Function}
 */
var ButtonsView = module.exports = View.extend({
  className: 'cell-buttons',
  events: {
    'click .action': 'onClick'
  }
});

/**
 * Keep an array of controls to display.
 *
 * @type {Array}
 */
ButtonsView.controls = [];

/**
 * Initialize the buttons view.
 */
ButtonsView.prototype.initialize = function () {
  this.listenTo(domListen(document), 'mousemove', _.throttle(function (e) {
    // Avoid removing the buttons when moving the mouse inside itself.
    if (this.el.contains(e.target)) {
      return;
    }

    return this.remove();
  }, 10));

  return View.prototype.initialize.call(this);
};

/**
 * Require the buttons template.
 *
 * @type {Function}
 */
ButtonsView.prototype.template = template;

/**
 * Event handler for clicks on control buttons. Pass thru for clicks on the
 * parent element.
 *
 * @param {object} e The normalized event object.
 */
ButtonsView.prototype.onClick = function (e) {
  e.preventDefault();

  this.trigger('action', this, e.target.getAttribute('data-action'));
  this.remove();
};

/**
 * Push some initial controls into the view.
 */
ButtonsView.controls.push({
  label: 'Insert Text Cell',
  command: 'newText'
}, {
  label: 'Insert Code Cell',
  command: 'newCode'
});

},{"../../templates/views/cell-buttons.hbs":130,"../lib/dom-listen":88,"./template":126,"underscore":49}],115:[function(require,module,exports){
var _          = require('underscore');
var View       = require('./template');
var template   = require('../../templates/views/cell-controls.hbs');
var middleware = require('../state/middleware');
var domListen  = require('../lib/dom-listen');

/**
 * Displays the cell controls overlay menu.
 *
 * @type {Function}
 */
var ControlsView = module.exports = View.extend({
  className: 'cell-controls',
  events: {
    'mousedown .action':  'onClick',
    'touchstart .action': 'onClick'
  }
});

/**
 * Controls view template.
 *
 * @type {Function}
 */
ControlsView.prototype.template = template;

/**
 * Render the controls overlay.
 *
 * @param  {Array}        controls
 * @return {ControlsView}
 */
ControlsView.prototype.render = function (controls) {
  // Set the controls to be rendered in the template.
  this.data.set('controls', controls || []);

  View.prototype.render.call(this);

  // Any events on the document view should cause focus to be lost.
  this.listenTo(domListen(document), 'mousedown',  this.remove);
  this.listenTo(domListen(document), 'touchstart', this.remove);

  var keydownMiddleware = middleware.register(
    'keydown:Esc', _.bind(function (event, next, done) {
      this.remove();
      return done();
    }, this)
  );

  this.listenTo(this, 'remove', function () {
    middleware.deregister('keydown:Esc', keydownMiddleware);
  });

  return this;
};

/**
 * Event handler for clicks on control buttons. Pass thru for clicks on the
 * parent element.
 *
 * @param {object} e The normalized event object.
 */
ControlsView.prototype.onClick = function (e) {
  var node = e.target;

  while (!node.hasAttribute('data-action')) {
    node = node.parentNode;
  }

  this.trigger('action', this, node.getAttribute('data-action'));
  return this.remove();
};

},{"../../templates/views/cell-controls.hbs":131,"../lib/dom-listen":88,"../state/middleware":109,"./template":126,"underscore":49}],116:[function(require,module,exports){
var _          = require('underscore');
var DOMBars    = require('../lib/dombars');
var EditorCell = require('./editor-cell');
var ResultCell = require('./result-cell');
var Completion = require('../lib/completion');
var extraKeys  = require('./lib/extra-keys');
var controls   = require('../lib/controls').code;
var config     = require('../state/config');

/**
 * Initialize a new code cell view.
 *
 * @type {Function}
 */
var CodeCell = module.exports = EditorCell.extend({
  className: 'cell cell-code'
});

/**
 * Runs when the code cell is initialized.
 */
CodeCell.prototype.initialize = function () {
  EditorCell.prototype.initialize.apply(this, arguments);

  this.listenTo(config, 'codeReadOnly', function () {
    this.data.set('readOnly', config.get('codeReadOnly'));
    this.renderEditor();
  });

  this.listenTo(this.model, 'change:isError', function (model, isError) {
    this.el.classList[isError ? 'add' : 'remove']('cell-code-error');
  });

  // Set a static result cell instance.
  this.resultCell = new ResultCell({ model: this.model });
};

/**
 * Default cell model attributes.
 *
 * @type {Object}
 */
CodeCell.prototype.cellAttributes = {
  type: 'code'
};

/**
 * Merge the editor cell template with the code cell.
 *
 * @type {Function}
 */
CodeCell.prototype.template = DOMBars.Utils.mergeTemplates(
  EditorCell.prototype.template, require('../../templates/views/code-cell.hbs')
);

/**
 * Extend the editor cell with an event for triggering execute.
 *
 * @type {Object}
 */
CodeCell.prototype.events = _.extend({
  'click .cell-execute': function () {
    return this.execute();
  }
}, EditorCell.prototype.events);

/**
 * Extend the editor cell controls with custom controls.
 *
 * @type {Array}
 */
CodeCell.prototype.cellControls = _.extend(
  [], EditorCell.prototype.cellControls
);

// Push the execute command into the menu.
CodeCell.prototype.cellControls.push(_.find(controls, function (control) {
  return control.command === 'execute';
}));

/**
 * Sets the options to be used by the CodeMirror instance when initialized.
 *
 * @type {Object}
 */
CodeCell.prototype.editorOptions = _.extend(
  {}, EditorCell.prototype.editorOptions, {
    mode: {
      name: 'javascript',
      globalVars: true
    }
  }
);

/**
 * Defines extra keys to be used by the editor for code cell.
 *
 * @type {Object}
 */
CodeCell.prototype.editorOptions.extraKeys = _.extend(
  {}, EditorCell.prototype.editorOptions.extraKeys, extraKeys(controls)
);

/**
 * Update the result cell index calculation.
 *
 * @return {CodeCell}
 */
CodeCell.prototype.update = function () {
  this.resultCell.update();
  return EditorCell.prototype.update.call(this);
};

/**
 * Execute the code cell contents and render the result.
 *
 * @param {Function} done
 */
CodeCell.prototype.execute = function (done) {
  // Set the value as our own model for executing.
  this.model.set('value', this.editor.getValue());

  // First run previous cells if they need to be run.
  this.notebook.executePrevious(this, _.bind(function () {
    // Add a class to the cell to display execution.
    this.data.set('executing', true);

    this.notebook.sandbox.execute(this.getValue(), _.bind(function (err, data) {
      this.data.set({
        executed:  true,
        executing: false
      });

      this.model.set({
        result:  data.result,
        isError: data.isError
      });

      this.change();
      this.trigger('execute', this, data);
      return done && done(err, data);
    }, this));
  }, this));
};

/**
 * Update the result cell rendering.
 */
CodeCell.prototype.change = function () {
  this.resultCell.change();

  return this;
};

/**
 * Create a new line in the editor.
 */
CodeCell.prototype.newLine = function () {
  this.editor.execCommand('newlineAndIndent');

  return this;
};

/**
 * Set up the editor instance and bindings.
 *
 * @return {CodeCell}
 */
CodeCell.prototype.bindEditor = function () {
  EditorCell.prototype.bindEditor.call(this);

  // Set up the autocompletion widget.
  this._completion = new Completion(
    this.editor, this.notebook.completionOptions
  );

  return this;
};

/**
 * Remove all editor instance data.
 */
CodeCell.prototype.unbindEditor = function () {
  this._completion.remove();
  delete this._completion;
  return EditorCell.prototype.unbindEditor.call(this);
};

},{"../../templates/views/code-cell.hbs":132,"../lib/completion":85,"../lib/controls":87,"../lib/dombars":93,"../state/config":107,"./editor-cell":118,"./lib/extra-keys":122,"./result-cell":124,"underscore":49}],117:[function(require,module,exports){
var _          = require('underscore');
var View       = require('./view');
var messages   = require('../state/messages');
var CodeMirror = require('codemirror');

/**
 * Create a new raw notebook editor instance.
 *
 * @type {Function}
 */
var EditNotebook = module.exports = View.extend({
  className: 'notebook-edit'
});

/**
 * Render the notebook editor.
 *
 * @return {EditNotebook}
 */
EditNotebook.prototype.render = function () {
  this.editor = new CodeMirror(this.el, {
    mode:           'gfm',
    value:          this.model.get('content'),
    tabSize:        2,
    lineNumbers:    true,
    lineWrapping:   true,
    viewportMargin: Infinity
  });

  // Update the persistence code every time we change the content.
  this.listenTo(this.editor, 'change', _.bind(function (cm) {
    messages.trigger('resize');
    this.model.set('content', cm.getValue());
  }, this));

  this.listenTo(messages, 'refresh', _.bind(this.editor.refresh, this.editor));

  this.listenTo(this.model, 'change:content', function () {
    if (this.model.get('content') === this.editor.getValue()) { return; }

    this.editor.setValue(this.model.get('content'));
  });

  return this;
};

},{"../state/messages":108,"./view":128,"codemirror":22,"underscore":49}],118:[function(require,module,exports){
var _          = require('underscore');
var CodeMirror = require('codemirror');

var View         = require('./template');
var template     = require('../../templates/views/editor-cell.hbs');
var extraKeys    = require('./lib/extra-keys');
var controls     = require('../lib/controls').editor;
var messages     = require('../state/messages');
var domListen    = require('../lib/dom-listen');
var Cell         = require('../models/cell');
var CellButtons  = require('./cell-buttons');
var CellControls = require('./cell-controls');
var embedProtect = require('./lib/embed-protect');
var cellControls = new CellControls();

/**
 * Wrap a function method and ensure it only triggers when we're allowed access.
 *
 * @param  {Object}   obj
 * @param  {String}   method
 * @return {Function}
 */
var triggerSelf = function (obj, method) {
  obj[method] = embedProtect(function () {
    this.trigger(method, this);
  });
};

/**
 * Create a generic editor cell instance view.
 *
 * @type {Function}
 */
var EditorCell = module.exports = View.extend({
  className: 'cell cell-editor'
});

/**
 * Runs when we initialize the editor cell.
 */
EditorCell.prototype.initialize = function (options) {
  View.prototype.initialize.apply(this, arguments);

  // Alias the notebook instance.
  this.notebook = options && options.notebook;

  // Alias model properties or create a new cell model.
  this.model      = (options && options.model) || new Cell(this.cellAttributes);
  this.model.view = this;
};

/**
 * Default cell attributes for initialization.
 *
 * @type {Object}
 */
EditorCell.prototype.cellAttributes = {};

/**
 * Embed the editor cell template.
 *
 * @type {Function}
 */
EditorCell.prototype.template = template;

/**
 * Event listeners for all editor cells in the notebook.
 *
 * @type {Object}
 */
EditorCell.prototype.events = {
  'mousedown .cell-menu-toggle':  'showControls',
  'touchstart .cell-menu-toggle': 'showControls'
};

/**
 * Set the base editor options used in CodeMirror.
 *
 * @type {Object}
 */
EditorCell.prototype.editorOptions = {
  tabSize:        2,
  lineNumbers:    true,
  lineWrapping:   true,
  viewportMargin: Infinity,
  extraKeys:      extraKeys(controls)
};

/**
 * Remove the editor cell as a result of user action.
 *
 * @return {EditorCell}
 */
EditorCell.prototype.delete = embedProtect(function () {
  this.trigger('delete', this);
  this.remove();

  return this;
});

/**
 * Remove the editor cell.
 *
 * @return {EditorCell}
 */
EditorCell.prototype.remove = function () {
  View.prototype.remove.call(this);
  messages.trigger('resize');

  return this;
};

/**
 * Clones the editor cell and triggers a clone event with the cloned view.
 *
 * @return {EditorCell} Cloned view.
 */
EditorCell.prototype.clone = embedProtect(function () {
  var clone = new this.constructor({
    model:    this.model.clone(),
    notebook: this.notebook
  });

  this.trigger('clone', this, clone);
  return clone;
});

/**
 * Inserts a new line directly below the current line. Keeps previous cursor
 * history so undo puts the cursor back to the same position.
 */
EditorCell.prototype.newLineBelow = function () {
  var line = this.editor.getCursor().line;

  this.editor.doc.replaceRange('\n', {
    ch:   Infinity,
    line: line++
  });
  this.editor.indentLine(line, null, true);
  this.editor.doc.setCursor({
    cm:   Infinity,
    line: line
  });
};

/**
 * Toggle comments in the current editor instance.
 */
EditorCell.prototype.toggleComment = function () {
  this.editor.execCommand('toggleComment');
};

/**
 * Focus the editor cell.
 *
 * @return {EditorCell}
 */
EditorCell.prototype.focus = function () {
  if (this.editor) {
    this.editor.focus();
  }

  return this;
};

/**
 * Check whether the current cell has focus.
 *
 * @return {Boolean}
 */
EditorCell.prototype.hasFocus = function () {
  return !!this.editor && this.editor.hasFocus();
};

/**
 * Return the first line of the editor.
 *
 * @return {Number}
 */
EditorCell.prototype.firstLine = function () {
  var prevView = this.getPrevView();

  return prevView ? prevView.lastLine() + 1 : 1;
};

/**
 * Return the last line of the editor.
 *
 * @return {Number}
 */
EditorCell.prototype.lastLine = function () {
  // Avoid using `this.editor` to calculate the last line.
  return this.firstLine() + this.lineCount();
};

/**
 * Return the number of lines in the editor.
 *
 * @return {Number}
 */
EditorCell.prototype.lineCount = function () {
  return this.getValue().split('\n').length - 1;
};

/**
 * Update the editor line numbers.
 *
 * @param  {Number}     [line]
 * @return {EditorCell}
 */
EditorCell.prototype.updateLineNumbers = function (line) {
  var nextView = this.getNextView();

  // Update the first line number. Pass a number to set it manually.
  line = line || this.firstLine();

  // Allow the editor to update the line number.
  if (this.editor) {
    this.editor.setOption('firstLineNumber', line);
  }

  return nextView && nextView.updateLineNumbers(line + this.lineCount() + 1);
};

/**
 * Update the editor instance.
 *
 * @return {EditorCell}
 */
EditorCell.prototype.update = function () {
  this.updateLineNumbers();

  return this;
};

/**
 * Refresh the editor instance.
 *
 * @return {EditorCell}
 */
EditorCell.prototype.refresh = function () {
  if (this.editor) {
    this.editor.refresh();
  }

  return this;
};

/**
 * Set up bindings with the CodeMirror instance.
 *
 * @return {EditorCell}
 */
EditorCell.prototype.bindEditor = function () {
  // Trigger a focus event on the view when the cell is focused.
  this.listenTo(this.editor, 'focus', _.bind(function () {
    this.trigger('focus', this);
    this.el.classList.add('active');
  }, this));

  // Trigger a blur event on the view when the cell is blurred.
  this.listenTo(this.editor, 'blur', _.bind(function () {
    this.trigger('blur', this);
    this.el.classList.remove('active');
  }, this));

  // Save the value of the model every time a change happens
  this.listenTo(this.editor, 'change', _.bind(function (cm, data) {
    this.model.set('value', cm.getValue());
    this.trigger('change', this, data);
    messages.trigger('resize');

    if (data.text.length > 1 || data.from.line !== data.to.line) {
      this.updateLineNumbers();
    }
  }, this));

  return this;
};

/**
 * Remove all bindings set up with the CodeMirror instance.
 *
 * @return {EditorCell}
 */
EditorCell.prototype.unbindEditor = function () {
  this.stopListening(this.editor);

  return this;
};

/**
 * Remove the CodeMirror view from the DOM.
 *
 * @return {EditorCell}
 */
EditorCell.prototype.removeEditor = function () {
  if (!this.editor) {
    return this;
  }

  this.docHistory = this.editor.doc.getHistory();
  this.unbindEditor();

  // Get the editor element DOM instance to be removed.
  var editorElement = this.editor.getWrapperElement();

  // Delete references to the CodeMirror instance. This needs to be done before
  // it's removed from the DOM, since it's relied on in other "blur" events.
  delete this.editor;

  if (editorElement && editorElement.parentNode) {
    editorElement.parentNode.removeChild(editorElement);
  }

  return this;
};

/**
 * Set the controls to display in the cell menu.
 *
 * @type {Array}
 */
EditorCell.prototype.cellControls = _.filter(controls, function (control) {
  return {
    'moveUp':    true,
    'moveDown':  true,
    'switch':    true,
    'clone':     true,
    'delete':    true,
    'appendNew': true
  }[control.command];
});

/**
 * Render a CodeMirror instance inside the view.
 *
 * @return {EditorCell}
 */
EditorCell.prototype.renderEditor = function () {
  // Remove the currently rendered editor from all references.
  this.removeEditor();

  // If an editor already exists, rerender the editor keeping the same options.
  this.editor = new CodeMirror(_.bind(function (el) {
    this.el.insertBefore(el, this.el.firstChild);
  }, this), _.extend({
    view:            this,
    value:           this.getValue(),
    readOnly:        this.isReadOnly(),
    firstLineNumber: this.firstLine()
  }, this.editorOptions));

  // Initialize every editor with the cursor at the end.
  this.moveCursorToEnd();

  // Add an extra css class for helping with styling read-only editors.
  if (this.editor.getOption('readOnly')) {
    this.editor.getWrapperElement().className += ' CodeMirror-readOnly';
  }

  // Alias the current view to the editor, since keyMaps are shared between
  // all instances of CodeMirror.
  this.editor.view = this;

  // Bind the editor events at the end in case of any focus issues when
  // changing docs, etc.
  this.bindEditor();

  // Copy old history to updated instance.
  if (this.docHistory) {
    this.editor.doc.setHistory(this.docHistory);
    delete this.docHistory;
  }

  // Trigger a resize event for the just inserted code editor.
  messages.trigger('resize');

  return this;
};

/**
 * Render the editor cell and attach the controls.
 *
 * @return {EditorCell}
 */
EditorCell.prototype.render = function () {
  View.prototype.render.call(this);

  this.renderEditor();
  this.update();
  this.listenTo(messages, 'refresh', this.refresh);

  var timeout       = 100;
  var aboveListener = domListen(this.el.querySelector('.cell-border-above'));
  var belowListener = domListen(this.el.querySelector('.cell-border-below'));

  var showAboveTimeout;
  var showBelowTimeout;

  this.listenTo(aboveListener, 'mouseenter', function () {
    showAboveTimeout = window.setTimeout(
      _.bind(this.showButtonsAbove, this), timeout
    );
  });

  this.listenTo(belowListener, 'mouseenter', function () {
    showBelowTimeout = window.setTimeout(
      _.bind(this.showButtonsBelow, this), timeout
    );
  });

  this.listenTo(aboveListener, 'mouseleave', function () {
    window.clearTimeout(showAboveTimeout);
  });

  this.listenTo(belowListener, 'mouseleave', function () {
    window.clearTimeout(showBelowTimeout);
  });

  return this;
};

/**
 * Create a cell controls instance and append to the editor cell.
 *
 * @param  {Object}       e
 * @return {CellControls}
 */
EditorCell.prototype.showControls = function (e) {
  e.stopPropagation();

  var controls = cellControls.render(this.cellControls).appendTo(this.el);

  this.listenTo(controls, 'remove', this.stopListening);
  this.listenTo(controls, 'action', function (_, action) {
    return this[action]();
  });

  return controls;
};

/**
 * Create a cell buttons instance and show it above the notebook cell.
 *
 * @return {CellButtons}
 */
EditorCell.prototype.showButtonsAbove = function () {
  if (this.data.has('cellButtonsAbove')) { return; }

  var buttons = new CellButtons();
  this.data.set('cellButtonsAbove', buttons);

  this.listenTo(buttons, 'remove', function (view) {
    this.stopListening(view);
    this.data.unset('cellButtonsAbove');
  });

  this.listenTo(buttons, 'action', function (_, action) {
    return this[action + 'Above']();
  });

  return buttons;
};

/**
 * Create a cell buttons instance and show it below the notebook cell.
 *
 * @return {CellButtons}
 */
EditorCell.prototype.showButtonsBelow = function () {
  if (this.data.has('cellButtonsBelow')) { return; }

  var buttons = new CellButtons();
  this.data.set('cellButtonsBelow', buttons);

  this.listenTo(buttons, 'remove', function (view) {
    this.stopListening(view);
    this.data.unset('cellButtonsBelow');
  });

  this.listenTo(buttons, 'action', function (_, action) {
    return this[action + 'Below']();
  });

  return buttons;
};

/**
 * Get the current value of the cell.
 *
 * @return {String}
 */
EditorCell.prototype.getValue = function () {
  return this.model.get('value') || '';
};

/**
 * Sets the value of the current editor instance.
 *
 * @param  {String}     value
 * @return {EditorCell}
 */
EditorCell.prototype.setValue = function (value) {
  if (_.isString(value)) {
    if (this.editor) {
      this.editor.doc.setValue(value);
      this.editor.doc.clearHistory();
    }

    this.model.set('value', value);
  }

  return this;
};

/**
 * Moves the CodeMirror cursor to the end of document, or end of the line.
 *
 * @param  {Number}     line
 * @return {EditorCell}
 */
EditorCell.prototype.moveCursorToEnd = function (line) {
  if (!this.editor) { return this; }

  this.editor.setCursor(
    isNaN(line) ? this.editor.doc.lastLine() : line, Infinity
  );

  return this;
};

/**
 * Browse up to the previous code view contents.
 */
EditorCell.prototype.browseUp = function () {
  var curLine   = this.editor.doc.getCursor().line;
  var firstLine = this.editor.doc.firstLine();

  if (curLine === firstLine) {
    return this.trigger('browseUp', this);
  }

  this.editor.execCommand('goLineUp');
};

/**
 * Browse down to the next code view contents.
 */
EditorCell.prototype.browseDown = function () {
  var curLine  = this.editor.doc.getCursor().line;
  var lastLine = this.editor.doc.lastLine();

  if (curLine === lastLine) {
    return this.trigger('browseDown', this);
  }

  this.editor.execCommand('goLineDown');
};

/**
 * Returns the previous view in the notebook collection.
 *
 * @return {EditorCell}
 */
EditorCell.prototype.getPrevView = function () {
  if (this.model.collection) {
    return _.result(this.model.collection.getPrev(this.model), 'view');
  }
};

/**
 * Returns the next view in the notebook collection.
 *
 * @return {EditorCell}
 */
EditorCell.prototype.getNextView = function () {
  if (this.model.collection) {
    return _.result(this.model.collection.getNext(this.model), 'view');
  }
};

/**
 * Checks whether the current user is the current owner of the cell and able to
 * edit it.
 *
 * @return {Boolean}
 */
EditorCell.prototype.isReadOnly = function () {
  return this.data.get('readOnly');
};

/**
 * Add a few simple binding for just proxying events.
 */
triggerSelf(EditorCell.prototype, 'switch');
triggerSelf(EditorCell.prototype, 'moveUp');
triggerSelf(EditorCell.prototype, 'moveDown');
triggerSelf(EditorCell.prototype, 'newTextAbove');
triggerSelf(EditorCell.prototype, 'newCodeAbove');
triggerSelf(EditorCell.prototype, 'newTextBelow');
triggerSelf(EditorCell.prototype, 'newCodeBelow');

/**
 * Alias the append new cell below function to creating a new code cell.
 *
 * @type {Function}
 */
EditorCell.prototype.appendNew = EditorCell.prototype.newCodeBelow;

},{"../../templates/views/editor-cell.hbs":133,"../lib/controls":87,"../lib/dom-listen":88,"../models/cell":103,"../state/messages":108,"./cell-buttons":114,"./cell-controls":115,"./lib/embed-protect":121,"./lib/extra-keys":122,"./template":126,"codemirror":22,"underscore":49}],119:[function(require,module,exports){
var _         = require('underscore');
var trim      = _.bind(Function.prototype.call, String.prototype.trim);
var type      = require('../lib/type');
var Inspector = require('./inspector');

/**
 * Create an instance of the inspector suited for rendering errors.
 *
 * @type {Function}
 */
var ErrorInspector = module.exports = Inspector.extend();

/**
 * Runs when a new error inspector instance is created.
 */
ErrorInspector.prototype.initialize = function () {
  Inspector.prototype.initialize.apply(this, arguments);

  // Check whether we rendering an initialized error.
  this._isError = (type(this.inspect) === 'error' && 'stack' in this.inspect);
};

/**
 * Returns whether the inspector should be expandable.
 *
 * @return {Boolean}
 */
ErrorInspector.prototype.isExpandable = function () {
  if (this._isError) {
    return !!this.inspect.stack.length;
  }

  return Inspector.prototype.isExpandable.call(this);
};

/**
 * Returns the stringified preview. In this case, it will be the error message.
 *
 * @return {String}
 */
ErrorInspector.prototype.stringifyPreview = function () {
  if (this._isError) {
    return Error.prototype.toString.call(this.inspect);
  }

  return Inspector.prototype.stringifyPreview.call(this);
};

/**
 * Render the stack trace as the child.
 *
 * @return {ErrorInspector}
 */
ErrorInspector.prototype._renderChildren = function () {
  // Stack trace rendering support.
  if (this._isError) {
    var stack   = this.inspect.stack;
    var traceEl = document.createElement('div');
    var message = Error.prototype.toString.call(this.inspect);

    // Check for Chrome-style stack traces which include the error message.
    if (stack.substr(0, message.length) === message) {
      stack = _.map(stack.split('\n').slice(1), trim).join('\n');
    }

    // Remove useless Safari eval stack trace line.
    stack = stack.replace(/^eval code\n/, '');

    traceEl.className   = 'inspector-trace';
    traceEl.textContent = stack;

    this.childrenEl.appendChild(traceEl);

    return this;
  }

  return Inspector.prototype._renderChildren.call(this);
};

/**
 * Remove the stack trace from display.
 *
 * @return {ErrorInspector}
 */
ErrorInspector.prototype._removeChildren = function () {
  if (this._isError) {
    this.childrenEl.innerHTML = '';

    return this;
  }

  return Inspector.prototype._removeChildren.call(this);
};

},{"../lib/type":102,"./inspector":120,"underscore":49}],120:[function(require,module,exports){
var _          = require('underscore');
var View       = require('./view');
var domify     = require('domify');
var stringify  = require('../lib/stringify');
var messages   = require('../state/messages');
var middleware = require('../state/middleware');

/**
 * Match anything that looks like a valid uri. This includes "data:", "mailto:",
 * "http://", "https://", "ftp://" and anything else that may exist.
 */
var linkRegExp = new RegExp(
  '(' +
    '(?:\\w+:\\/{2}|(?:data|mailto)\\:)' +
    '(?:' +
      '[A-Za-z0-9\\.\\-_~:/\\?#\\[\\]@!\\$&\'\\(\\)\\*\\+,;=]|%[A-Fa-f0-9]{2}' +
    ')+' +
  ')',
  'g'
);

/**
 * Creates a new inspector view instance.
 *
 * @type {Function}
 */
var InspectorView = module.exports = View.extend({
  className: 'inspector'
});

/**
 * Runs when a new instector instance is created.
 *
 * @param  {Object} options
 */
InspectorView.prototype.initialize = function (options) {
  View.prototype.initialize.apply(this, arguments);

  _.extend(this, _.pick(
    options, ['property', 'parent', 'inspect', 'internal', 'window']
  ));

  if (this.parent) {
    this.listenTo(this.parent, 'close', this.close);
  }
};

/**
 * Listen to events in the view and stop them from propagating (since parent
 * inspector views are listening to the same events).
 *
 * @type {Object}
 */
InspectorView.prototype.events = {
  'click': function (e) {
    e.stopPropagation();
    this.toggle();
  }
};

/**
 * Open the inspector to view the children.
 */
InspectorView.prototype.open = function () {
  this.trigger('open', this);
  this.el.classList.add('open');
  messages.trigger('resize');
};

/**
 * Closes the inspector instance and hides the children.
 */
InspectorView.prototype.close = function () {
  this.trigger('close', this);
  this.el.classList.remove('open');
  messages.trigger('resize');
};

/**
 * Toggle the display of children.
 */
InspectorView.prototype.toggle = function () {
  this[this.el.classList.contains('open') ? 'close' : 'open']();
};

/**
 * Returns whether the inspector is actually expandable.
 *
 * @return {Boolean}
 */
InspectorView.prototype.isExpandable = function () {
  return _.isObject(this.inspect);
};

/**
 * Stringifies the inspected object for display.
 *
 * @return {String}
 */
InspectorView.prototype.stringifyPreview = function () {
  // If we have a parent object, render in the simplified format. Except for
  // functions, we still want the full output for functions.
  if (this.parent) {
    // PhantomJS reports `NodeList` instances to be functions.
    if (Object.prototype.toString.call(this.inspect) === '[object Function]') {
      return this.inspect.toString();
    } else {
      return stringify.stringifyChild(this.inspect);
    }
  }

  return stringify(this.inspect);
};

/**
 * Render a child property view. Passes through all sorts of properties to help
 * with rendering.
 *
 * @param  {String} property Inspected property name.
 * @param  {*}      inspect  The object to inspect.
 * @param  {String} internal A string representing the internal property.
 * @return {InspectorView}
 */
InspectorView.prototype._renderChild = function (property, inspect, internal) {
  var inspector = new InspectorView({
    parent:   this,
    window:   this.window,
    inspect:  inspect,
    property: property,
    internal: internal
  });
  this.children[inspector.cid] = inspector;
  inspector.render().appendTo(this.childrenEl);

  return this;
};

/**
 * Render all child properties.
 *
 * @return {InspectorView}
 */
InspectorView.prototype.renderChildren = function () {
  // The element may not even be expandable. In which case, we can safely return
  // early before doing any rendering.
  if (!this.isExpandable(this.inspect)) { return this; }

  this._renderChildrenEl();

  // If it should be expanded, add a class to show it can be.
  this.el.classList.add('can-expand');

  this.listenTo(this, 'open',  this._renderChildren);
  this.listenTo(this, 'close', this._removeChildren);

  return this;
};

/**
 * Render the children element container.
 *
 * @return {InspectorView}
 */
InspectorView.prototype._renderChildrenEl = function () {
  var el = this.childrenEl = domify('<div class="children"></div>');
  this.el.appendChild(el);
  this.children = {};
  return this;
};

/**
 * Render all child properties of the currently inspected object.
 *
 * @return {InspectorView}
 */
InspectorView.prototype._renderChildren = function () {
  // We need to use the `Object.*` functions from the correct window object.
  // Firefox 26 returns `undefined` as the value for an arrays length property
  // when accessed using the wrong frames `Object.getOwnPropertyDescriptor`.
  var getPrototypeOf           = this.window.Object.getPrototypeOf;
  var getOwnPropertyNames      = this.window.Object.getOwnPropertyNames;
  var getOwnPropertyDescriptor = this.window.Object.getOwnPropertyDescriptor;
  var allPropertyNames;

  // Wrap getting property names in a `try..catch` since the inspected object
  // is unknown. We also need to get only unique property names since Chrome
  // has a pretty major bug where all `document` keys are returned twice.
  try {
    allPropertyNames = _.uniq(getOwnPropertyNames(this.inspect));
  } catch (e) {
    return this;
  }

  // We want to sort the keys numerically, and then alphabetically.
  var propertyNames = allPropertyNames.sort(function (a, b) {
    var aNum = parseInt(a, 10);
    var bNum = parseInt(b, 10);

    // Order two numbers by their values.
    if (!isNaN(aNum) && !isNaN(bNum)) {
      return aNum - bNum;
    }

    // Numbers should always come out on top.
    if (!isNaN(aNum)) {
      return -1;
    }

    if (!isNaN(bNum)) {
      return 1;
    }

    // Strings can be sorted like usual.
    return a > b ? 1 : -1;
  });

  _.each(propertyNames, function (prop) {
    var descriptor;

    // Wrap the collection and checking of property names in a `try..catch`
    // statement since the origin of the object is unknown. For example,
    // attempting to check `window.parent` cross-domain will throw an error.
    try {
      descriptor = getOwnPropertyDescriptor(this.inspect, prop);
    } catch (e) {}

    // Even though we are iterating over our own property names, PhantomJS is
    // finding a way to return an `undefined` property descriptor.
    if (_.isUndefined(descriptor)) { return; }

    // Check for the existence of getters and setters, otherwise it's a regular
    // property.
    if (_.isFunction(descriptor.get) || _.isFunction(descriptor.set)) {
      if (_.isFunction(descriptor.get)) {
        this._renderChild(prop, descriptor.get, '[[Getter]]');
      }

      if (_.isFunction(descriptor.set)) {
        this._renderChild(prop, descriptor.set, '[[Setter]]');
      }
    } else {
      this._renderChild(prop, descriptor.value);
    }
  }, this);

  // Render the internal prototype property.
  this._renderChild(null, getPrototypeOf(this.inspect), '[[Prototype]]');

  return this;
};

/**
 * Remove all the currently rendered children.
 *
 * @return {InspectorView}
 */
InspectorView.prototype._removeChildren = function () {
  _.each(this.children, function (child) {
    child.remove();
  });

  return this;
};

/**
 * Render the inspector preview.
 *
 * @return {InspectorView}
 */
InspectorView.prototype.renderPreview = function () {
  var parent = this.parent && this.parent.inspect;
  var desc;

  if (parent && !this.internal) {
    desc = this.window.Object.getOwnPropertyDescriptor(parent, this.property);
  }

  // Run filter middleware to check if the property should be filtered from
  // the basic display.
  middleware.trigger('inspector:filter', {
    parent:     parent,
    window:     this.window,
    property:   this.property,
    internal:   this.internal,
    descriptor: desc
  }, _.bind(function (err, filter) {
    if (!filter) { return this.remove(); }

    var html        = '';
    var prefix      = '';
    var special     = !!this.internal;
    var preview     = this.stringifyPreview(this.inspect);
    var htmlPreview = '';

    if (typeof this.inspect === 'string') {
      var previous = 0;

      preview.replace(linkRegExp, function (match, uri, index) {
        var escapedUri = _.escape(uri);

        // Append the html preview in multiple steps.
        htmlPreview += _.escape(preview.slice(previous, index));
        htmlPreview += '<a href="' + escapedUri + '" target="_blank">';
        htmlPreview += escapedUri;
        htmlPreview += '</a>';

        // Increment the previous marker to the current position.
        previous = index + match.length;
      });

      htmlPreview += _.escape(preview.substr(previous));
    } else {
      htmlPreview = _.escape(preview);
    }

    // If we have a property name, use it as the display prefix.
    if (this.property) {
      prefix = this.property;
    }

    // If we have a parent object, do some more advanced checks to establish
    // some more advanced properties such as the prefix and special display.
    if (parent) {
      if (this.internal) {
        // Internal properties are always specially rendered properties.
        special = true;

        // Setters and getters still should still be rendered with their
        // property names. Everything else can just be rendered using the
        // internal property notation.
        if (this.internal === '[[Getter]]') {
          prefix = 'get ' + this.property;
        } else if (this.internal === '[[Setter]]') {
          prefix = 'set ' + this.property;
        } else {
          prefix = this.internal;
        }
      } else {
        special = !desc.writable || !desc.configurable || !desc.enumerable;
      }
    }

    html += '<div class="arrow"></div>';
    html += '<div class="preview">';
    if (prefix) {
      html += '<span class="property' + (special ? ' is-special' : '') + '">';
      html += _.escape('' + prefix);
      html += '</span>: ';
    }
    html += '<span class="inspect" title="' + _.escape(preview) + '">';
    html += htmlPreview.split('\n').join('');
    html += '</span>';
    html += '</div>';

    this.el.appendChild(this.previewEl = domify(html));
  }, this));

  return this;
};

/**
 * Renders the inspector view.
 *
 * @return {InspectorView}
 */
InspectorView.prototype.render = function () {
  View.prototype.render.call(this);
  this.renderPreview();
  this.renderChildren();

  return this;
};

/**
 * Remove the inspector from the current view. Also removes itself from its
 * parent inspector view.
 */
InspectorView.prototype.remove = function () {
  if (this.parent) {
    delete this.parent.children[this.cid];
  }

  return View.prototype.remove.call(this);
};

},{"../lib/stringify":101,"../state/messages":108,"../state/middleware":109,"./view":128,"domify":43,"underscore":49}],121:[function(require,module,exports){
var config = require('../../state/config');

/**
 * Export a function that wraps methods on an instance with a protection against
 * running when not the owner.
 *
 * @param  {Function} method
 * @return {Function}
 */
module.exports = function (method) {
  return function () {
    if (config.get('embedded')) {
      return this;
    }

    return method.apply(this, arguments);
  };
};

},{"../../state/config":107}],122:[function(require,module,exports){
var _ = require('underscore');

/**
 * Accepts an array of controls and returns a keymap accepted by CodeMirror.
 *
 * @param  {Array}  controls
 * @return {Object}
 */
module.exports = function (controls) {
  var extraKeys = {};

  _.each(controls, function (control) {
    if (!control.keyMap) { return; }

    // Assign the key mapping to the extra keys object.
    extraKeys[control.keyMap] = function (cm) {
      cm.view[control.command]();
    };
  });

  return extraKeys;
};

},{"underscore":49}],123:[function(require,module,exports){
var _ = require('underscore');

var View       = require('./view');
var CodeView   = require('./code-cell');
var TextView   = require('./text-cell');
var EditorView = require('./editor-cell');

var Cells       = require('../collections/cells');
var Sandbox     = require('../lib/sandbox');
var config      = require('../state/config');
var messages    = require('../state/messages');
var middleware  = require('../state/middleware');
var insertAfter = require('../lib/browser/insert-after');

var completionMiddleware = require('../lib/sandbox-completion');

/**
 * Generates a generic function for appending new view instances.
 *
 * @param  {Backbone.View} View
 * @return {Function}
 */
var appendNewView = function (View) {
  return function (el, value) {
    var view = new View({ notebook: this });
    this.appendView(view, el);

    if (value) {
      view.setValue(value);
    }

    // Trigger a message to listen to, when we aren't rendering a notebook.
    if (!this._rendering) {
      messages.trigger('cell:new', view);
    }

    return view;
  };
};

/**
 * Generates a generic function for prepending new views.
 *
 * @param  {Backbone.View} View
 * @return {Function}
 */
var prependNewView = function (View) {
  return function (el, value) {
    return appendNewView(View).call(this, function (viewEl) {
      el.parentNode.insertBefore(viewEl, el);
    }, value);
  };
};

/**
 * Create a new notebook instance.
 *
 * @type {Function}
 */
var Notebook = module.exports = View.extend({
  className: 'notebook-view'
});

 /**
 * Initialize the notebook view.
 */
Notebook.prototype.initialize = function () {
  this.collection = new Cells();

  return View.prototype.initialize.apply(this, arguments);
};

/**
 * Removes the notebook from the DOM.
 *
 * @return {Notebook}
 */
Notebook.prototype.remove = function () {
  // Remove lingering notebook views.
  if (this.sandbox) {
    this.sandbox.remove();
    delete this.sandbox;
  }

  // Remove notebook view specific middleware.
  middleware.deregister(this._middleware);
  delete this._middleware;

  return View.prototype.remove.call(this);
};

/**
 * Refresh the completion context object, used by the completion helper in code
 * cells to get completion results.
 *
 * @return {Notebook}
 */
Notebook.prototype.updateCompletion = function () {
  // Extends the context with additional inline completion results. Requires
  // using `Object.create` since you can't extend an object with every property
  // of the global object.
  var context = Object.create(this.sandbox.window);

  middleware.trigger('sandbox:context', context, _.bind(function (err, data) {
    this.completionOptions.context = data;
  }, this));

  return this;
};

/**
 * Render the notebook view.
 *
 * @return {Notebook}
 */
Notebook.prototype.render = function () {
  View.prototype.render.call(this);

  // Create a new sandbox instance for every notebook view.
  this.sandbox = new Sandbox();

  // The completion options object is shared between all cells and used for
  // completion. Make sure we set this connection up before rendering any cells.
  this.completionOptions = {
    window: this.sandbox.window
  };

  // Register a middleware hook for augmenting the sandbox context.
  this._middleware = {
    'sandbox:context': _.bind(function (context, next) {
      _.each(this.collection.filter(function (model) {
        return model.get('type') === 'code';
      }), function (model, index) {
        context['$' + index] = model.get('result');
      });

      return next();
    }, this)
  };

  _.extend(this._middleware, completionMiddleware(this.sandbox.window));
  middleware.register(this._middleware);

  // Set a rendering flag while we are rendering the initial collection.
  this._rendering = true;

  // Iterate over the notebook cells and add to the view.
  _.each(this.model.get('cells'), function (cell) {
    var appendView = 'appendCodeView';

    if (cell.type === 'text') {
      appendView = 'appendTextView';
    }

    this[appendView](null, cell.value);
  }, this);

  // If no cells were appended, manually append a starting code view.
  if (!this.collection.length) {
    this.appendCodeView();
  }

  // Remove the rendering flag once the initial view has been set up.
  delete this._rendering;

  // When we only have one cell and no value (fresh notebook), show the first
  // cells border buttons.
  if (this.collection.length === 1) {
    var model = this.collection.at(0);

    if (!model.get('value')) {
      model.view.showButtonsAbove();
    }
  }

  this.listenTo(this.collection, 'remove sort', this.updateCompletion);

  this.listenTo(this.collection, 'change remove sort', function () {
    this.model.set('cells', this.collection.toJSON());
  });

  this.updateCompletion();

  return this;
};

/**
 * Execute the entire notebook sequentially.
 *
 * @param {Function} done
 */
Notebook.prototype.execute = function (done) {
  if (this._executing) {
    return done && done(new Error('Already executing notebook'));
  }

  var that = this;
  this._executing = true;

  // This chaining is a little awkward, but it allows the execution to work with
  // asynchronous callbacks.
  (function execution (view) {
    // If no view is passed through, we must have hit the last view.
    if (!view) {
      that._executing = false;
      return done && done();
    }

    // Only execute code cells, skips other cell types.
    if (view.model.get('type') === 'code') {
      view.execute(function () {
        execution(that.getNextView(view));
      });
    } else {
      execution(that.getNextView(view));
    }
  })(this.collection.at(0).view);
};

/**
 * Execute notebook cells sequentially until a certain view.
 *
 * @param {Backbone.View} current
 * @param {Function}      done
 */
Notebook.prototype.executePrevious = function (current, done) {
  var that = this;

  // Don't need to executePrevious if we're already in a full execution.
  if (this._executing) {
    return done && done();
  }

  this._executing = true;

  (function execution (view) {
    // If no view is passed through, we must have hit the last view.
    if (!view || current === view) {
      that._executing = false;
      return done && done();
    }

    // Only execute code cells, skips other cell types.
    if (view.model.get('type') === 'code' && !view.data.get('executed')) {
      view.execute(function () {
        execution(that.getNextView(view));
      });
    } else {
      execution(that.getNextView(view));
    }
  })(this.collection.at(0).view);
};

/**
 * Returns the next view in the notebook.
 *
 * @param  {Object} view
 * @return {Object}
 */
Notebook.prototype.getNextView = function (view) {
  var model = this.collection.getNext(view.model);
  return model && model.view;
};

/**
 * Returns the previous view in the notebook.
 *
 * @param  {Object} view
 * @return {Object}
 */
Notebook.prototype.getPrevView = function (view) {
  var model = this.collection.getPrev(view.model);
  return model && model.view;
};

/**
 * Append and prepend new cell view instances.
 */
Notebook.prototype.appendCodeView  = appendNewView(CodeView);
Notebook.prototype.appendTextView  = appendNewView(TextView);
Notebook.prototype.prependCodeView = prependNewView(CodeView);
Notebook.prototype.prependTextView = prependNewView(TextView);

/**
 * Append any view to the notebook. Sets up a few listeners on every view
 * instance and manages interactions between cells.
 *
 * @param  {Object}   view
 * @param  {Node}     before
 * @return {Notebook}
 */
Notebook.prototype.appendView = function (view, before) {
  if (view instanceof EditorView) {
    this.listenTo(view, 'moveUp', function (view) {
      if (!view.el.previousSibling) { return; }

      view.el.parentNode.insertBefore(view.el, view.el.previousSibling);
      this.collection.sort();
      view.update().focus();
    });

    this.listenTo(view, 'moveDown', function (view) {
      if (!view.el.nextSibling) { return; }

      insertAfter(view.el, view.el.nextSibling);
      view.focus();
      this.collection.sort();
      this.getPrevView(view).update();
    });

    this.listenTo(view, 'newTextAbove', function (view) {
      var newView = this.prependTextView(view.el).refresh().focus();

      newView.update();
    });

    this.listenTo(view, 'newCodeAbove', function (view) {
      var newView = this.prependCodeView(view.el).refresh().focus();

      newView.update();
    });

    this.listenTo(view, 'newTextBelow', function (view) {
      var newView = this.appendTextView(view.el).refresh().focus();

      newView.update();
    });

    this.listenTo(view, 'newCodeBelow', function (view) {
      var newView = this.appendCodeView(view.el).refresh().focus();

      newView.update();
    });

    // Listen to clone events and append the new views after the current view
    this.listenTo(view, 'clone', function (view, clone) {
      this.appendView(clone, view.el);
      // Need to work around the editor being removed and added with text cells
      var cursor = view.editor && view.editor.getCursor();
      clone.focus().editor.setCursor(cursor);
      clone.update();
    });

    this.listenTo(view, 'remove', function (view) {
      var nextView = this.getNextView(view) || this.getPrevView(view);

      this.collection.remove(view.model);
      messages.trigger('cell:remove', view);

      if (nextView) {
        // Focus on the new cell instance.
        nextView.update().focus().moveCursorToEnd();
      }
    });

    this.listenTo(view, 'delete', function () {
      // If it's the last cell in the document, append an empty code cell.
      if (this.collection.length < 2) {
        this.appendCodeView().refresh().focus().showButtonsAbove();
      }
    });

    // Listen for switch events, which isn't a real switch but recreates the
    // view using the data it has available. This results in some issues, but
    // avoids a whole different set of issues that would arrise trying to change
    // everything on the fly.
    this.listenTo(view, 'switch', function (view) {
      var newView;

      if (view instanceof TextView) {
        newView = this.appendCodeView(view.el, view.getValue());
      } else {
        newView = this.appendTextView(view.el, view.getValue());
      }

      var cursor = view.editor && view.editor.getCursor();

      view.delete();
      newView.update().refresh().focus();

      if (cursor) {
        newView.editor.setCursor(cursor);
      }
    });

    this.listenTo(view, 'browseUp', function (view) {
      var prevView = this.getPrevView(view);

      if (prevView) {
        prevView.focus().editor.setCursor({
          line: prevView.editor.lastLine(),
          ch:   view.editor.getCursor().ch
        });
      }
    });

    this.listenTo(view, 'browseDown', function (view) {
      var nextView = this.getNextView(view);

      if (nextView) {
        nextView.focus().editor.setCursor({
          line: 0,
          ch:   view.editor.getCursor().ch
        });
      }
    });
  }

  // Listening to different events for `text` cells.
  if (view instanceof TextView) {
    this.listenTo(view, 'blur', function (view) {
      if (this.el.lastChild === view.el) {
        this.appendCodeView().refresh().focus();
      }
    });
  }

  // Listening to another set of events for `code` cells.
  if (view instanceof CodeView) {
    // Listen to execution events from the child views, which may or may not
    // require new working cells to be appended to the notebook.
    this.listenTo(view, 'execute', function (view) {
      // Refresh all completion data when a cell is executed.
      this.updateCompletion();

      // Need a flag here so we don't cause an infinite loop when executing the
      // notebook contents. (E.g. Hitting the last cell and adding a new cell).
      if (this._executing || config.get('embedded')) { return; }

      if (this.el.lastChild === view.el) {
        this.appendCodeView().refresh().focus();
      } else {
        this.getNextView(view).focus().moveCursorToEnd();
      }
    });
  }

  this.collection.push(view.model);

  // Append the view to the end of the notebook.
  view.render().appendTo(_.bind(function (el) {
    if (_.isFunction(before)) {
      return before(el);
    }

    return before ? insertAfter(el, before) : this.el.appendChild(el);
  }, this));

  // Sort the collection every time a node is added in a different position to
  // just being appended at the end.
  if (before) { this.collection.sort(); }

  return this;
};

},{"../collections/cells":66,"../lib/browser/insert-after":71,"../lib/sandbox":100,"../lib/sandbox-completion":99,"../state/config":107,"../state/messages":108,"../state/middleware":109,"./code-cell":116,"./editor-cell":118,"./text-cell":127,"./view":128,"underscore":49}],124:[function(require,module,exports){
var _          = require('underscore');
var View       = require('./template');
var messages   = require('../state/messages');
var template   = require('../../templates/views/result-cell.hbs');
var middleware = require('../state/middleware');

/**
 * Return a new result cell instance.
 *
 * @type {Function}
 */
var ResultCell = module.exports = View.extend({
  className: 'cell cell-result cell-result-pending'
});

/**
 * Automatically update the result body on change.
 */
ResultCell.prototype.change = function () {
  this.empty();

  if (this.model.get('isError')) {
    this.el.classList.add('result-error');
  }

  var attachElement  = this.el.querySelector('.result-content');
  var notebookWindow = this.model.view ?
    this.model.view.notebook.sandbox.window : window;

  middleware.trigger('result:render', {
    el:      attachElement,
    window:  notebookWindow,
    inspect: this.model.get('result'),
    isError: this.model.get('isError')
  }, _.bind(function (err, remove) {
    if (typeof remove === 'function') {
      this._remove = remove;
    }

    // Avoid an empty element when rendering fails.
    if (!attachElement.childNodes.length) {
      attachElement.innerHTML = '&nbsp;';
    }

    this.el.classList.remove('cell-result-pending');
    messages.trigger('resize');
  }, this));

  return this;
};

/**
 * The result cell template.
 *
 * @type {Function}
 */
ResultCell.prototype.template = template;

/**
 * Refreshes the result cell based on the parent cell view.
 */
ResultCell.prototype.update = function () {
  if (this.model.collection) {
    this.data.set('index', this.model.collection.codeIndexOf(this.model));
  }

  return this;
};

/**
 * Empty the result cell.
 */
ResultCell.prototype.empty = function () {
  // Any views must subscribe to this API style.
  if (this._remove) {
    this._remove();
    delete this._remove;
  }

  // Force the element to be cleared.
  this.el.querySelector('.result-content').innerHTML = '';

  return this;
};

/**
 * Empty the cell before removing.
 */
ResultCell.prototype.remove = function () {
  this.empty();
  return View.prototype.remove.call(this);
};

},{"../../templates/views/result-cell.hbs":134,"../state/messages":108,"../state/middleware":109,"./template":126,"underscore":49}],125:[function(require,module,exports){
var _           = require('underscore');
var View        = require('./template');
var bounce      = require('../lib/bounce');
var config      = require('../state/config');
var middleware  = require('../state/middleware');
var persistence = require('../state/persistence');
var notifyError = require('../lib/notify-error');

/**
 * Create a new sidebar view class.
 *
 * @type {Function}
 */
var SidebarView = module.exports = View.extend({
  className: 'notebook-sidebar'
});

/**
 * Initialize the sidebar view.
 */
SidebarView.prototype.initialize = function () {
  View.prototype.initialize.apply(this, arguments);

  /**
   * Check whether the current notebook has been saved.
   */
  this.listenTo(persistence, 'change:state', bounce(function () {
    this.data.set('saved', persistence.isCurrentSaved());
  }, this));
};

/**
 * An object of all events that trigger on the sidebar view.
 *
 * @type {Object}
 */
SidebarView.prototype.events = {
  'click [data-delete]': function (e) {
    e.preventDefault();
    e.stopImmediatePropagation();

    this.deleteId(e.target.getAttribute('data-delete'));
  },
  'click [data-load]': function (e, target) {
    var id = target.getAttribute('data-load');

    // If the current notebook has not been saved yet, prompt the user.
    if (!persistence.isCurrentSaved()) {
      return middleware.trigger('ui:confirm', {
        title: 'You have unsaved changes. Abandon changes?',
        content: '<p>' +
          'Save your work by pressing \'Cancel\' and ' +
          'then clicking the save icon in the toolbar or using ' +
          'the keystroke CMD + S (or CTRL + S).' +
          '</p>' +
          '<p>' +
          'Press \'OK\' to abandon this notebook. ' +
          'Your changes will be lost.' +
          '</p>'
      }, _.bind(function (err, confirmed) {
        if (err || !confirmed) { return; }

        return this.updateId(id);
      }, this));
    }

    return this.updateId(id);
  },
  'click .sidebar-toggle': function () {
    var isOpen = !this.el.classList.contains('sidebar-closed');

    this.el.classList[isOpen ? 'add' : 'remove']('sidebar-closed');
  },
  'click .persistence-authenticate':   'authenticate',
  'click .persistence-unauthenticate': 'unauthenticate',
  'click .sidebar-authenticate': function (e) {
    e.preventDefault();
  }
};

/**
 * Require the sidebar template.
 *
 * @type {Function}
 */
SidebarView.prototype.template = require('../../templates/views/sidebar.hbs');

/**
 * Reload the persistent notebooks list.
 */
SidebarView.prototype.updateList = function () {
  this.data.set('updating', true);

  persistence.list(_.bind(function (err, list) {
    this.data.set('updating', false);

    return this.data.set('list', list);
  }, this));
};

/**
 * Add some sidebar helpers.
 *
 * @type {Object}
 */
SidebarView.prototype.templateHelpers = {
  dateFormat: function (date) {
    return date.toLocaleTimeString() + ' ' + date.toLocaleDateString();
  }
};

/**
 * Override the render function to load the initial notebook list.
 */
SidebarView.prototype.render = function () {
  this.listenTo(persistence, 'change:userId', bounce(this.updateList, this));

  return View.prototype.render.call(this);
};

/**
 * Load an id into the persistence layer.
 *
 * @param {String} id
 */
SidebarView.prototype.updateId = function (id) {
  config.set('id', id);
  this.el.querySelector('.sidebar-list').scrollTop = 0;
};

/**
 * Delete an id using the persistence layer.
 *
 * @param {String} id
 */
SidebarView.prototype.deleteId = function (id) {
  middleware.trigger('ui:confirm', {
    title: 'Delete Notebook',
    content: 'Are you sure you want to delete this notebook?' +
    ' Deleted notebooks cannot be restored.'
  }, _.bind(function (err, confirmed) {
    return confirmed && persistence.remove(id, _.bind(function (err) {
      if (err) {
        return middleware.trigger('ui:notify', {
          title: 'Unable to delete the notebook',
          message: 'Refresh and try again'
        });
      }

      if (persistence.get('notebook').get('id') === id) {
        this.updateId('');
      }

      var listItemEl = this.el.querySelector('[data-load="' + id + '"]');
      return listItemEl && listItemEl.parentNode.removeChild(listItemEl);
    }, this));
  }, this));
};

/**
 * Authenticate to the notebook persistence layer.
 */
SidebarView.prototype.authenticate = function () {
  return persistence.authenticate(notifyError('Login failed!'));
};

/**
 * Unauthenticate from the notebook.
 */
SidebarView.prototype.unauthenticate = function () {
  return persistence.unauthenticate(notifyError('Could not log out!'));
};

},{"../../templates/views/sidebar.hbs":135,"../lib/bounce":69,"../lib/notify-error":95,"../state/config":107,"../state/middleware":109,"../state/persistence":110,"./template":126,"underscore":49}],126:[function(require,module,exports){
var _    = require('underscore');
var View = require('./view');

// State modules should be provided as the default data with every view.
var state       = require('../state/state');
var config      = require('../state/config');
var persistence = require('../state/persistence');

/**
 * Create a new view instance that uses the DOMBars templating engine.
 *
 * @type {Function}
 */
var TemplateView = module.exports = View.extend();

/**
 * The template property should be set on any extending views, and is executed
 * on render.
 *
 * @type {Function}
 */
TemplateView.prototype.template = function () {};

/**
 * Allow custom template data to be passed into the template.
 *
 * @type {Object}
 */
TemplateView.prototype.templateData = {
  state:       state,
  config:      config,
  persistence: persistence
};

/**
 * Allow custom helpers to be passed into the template render.
 *
 * @type {Object}
 */
TemplateView.prototype.templateHelpers = {};

/**
 * Render the template using the element using the template function.
 *
 * @return {this}
 */
TemplateView.prototype.render = function () {
  View.prototype.render.call(this);

  this.rendered = this.template(this.model, {
    data: _.extend({
      view: this,
      data: this.data
    }, this.templateData),
    helpers: this.templateHelpers
  });

  if (this.rendered.value) {
    this.el.appendChild(this.rendered.value);
  }

  return this;
};

/**
 * Unsubscribe the template listeners before removal.
 */
TemplateView.prototype.remove = function () {
  if (this.rendered) {
    this.rendered.unsubscribe();
    delete this.rendered;
  }

  return View.prototype.remove.call(this);
};

},{"../state/config":107,"../state/persistence":110,"../state/state":111,"./view":128,"underscore":49}],127:[function(require,module,exports){
var _            = require('underscore');
var marked       = require('marked');
var domify       = require('domify');
var EditorCell   = require('./editor-cell');
var config       = require('../state/config');
var messages     = require('../state/messages');
var embedProtect = require('./lib/embed-protect');

var blockRules  = marked.Lexer.rules;
var inlineRules = marked.InlineLexer.rules;

/**
 * Get all previous text to a focus node.
 *
 * @return {String}
 */
var getPrevText = function (node, offset, container) {
  var text = '';

  if (!container.contains(node)) {
    return text;
  }

  text += node.textContent.substr(0, offset);

  while (node !== container) {
    var temp    = '';
    var curNode = node;
    var sibling = (node = node.parentNode).firstChild;

    while (sibling !== curNode) {
      if (sibling.nodeType === Node.ELEMENT_NODE && sibling.tagName === 'BR') {
        temp += '\n';
      } else if (sibling.nodeType !== Node.COMMENT_NODE) {
        temp += sibling.textContent;
      }

      sibling = sibling.nextSibling;
    }

    text = temp + text;
  }

  return text;
};

/**
 * Find the text end position in a markdown document.
 *
 * @param  {String} text
 * @param  {String} markdown
 * @return {Object}
 */
var getTextPosition = function (text, markdown) {
  // Make a copy of the markdown which will be edited as we move along.
  var source   = markdown;
  var position = 0;
  var index    = 0;
  var m;

  while (index < text.length) {
    if (text[index] === source[0]) {
      index++;
      position++;
      source = source.substr(1);
      continue;
    }

    // Detect headings.
    if (m = /^( *#{1,6} *)([^\n]+?) *#* *(?:\n+|$)/.exec(source)) {
      if (index + m[2].length > text.length) {
        position += m[1].length + text.length - index;
        break;
      }

      index += m[2].length + 1;
      position += m[0].length;
      source = source.substr(m[0].length);
      continue;
    }

    // Correct links, images, autolinks.
    if (m = (
      inlineRules.link.exec(source) ||
      inlineRules.reflink.exec(source) ||
      inlineRules.autolink.exec(source)
    )) {
      // Ignore images in the output.
      if (m[0].charAt(0) === '!') {
        position += m[0].length;
        source = source.substr(m[0].length);
        continue;
      }

      // Handle the click position inside the link.
      if (index + m[1].length > text.length) {
        position += text.length - index + 1;
        break;
      }

      index += m[1].length;
      position += m[0].length;
      source = source.substr(m[0].length);
      continue;
    }

    // Correct code indentation.
    if (m = blockRules.code.exec(source)) {
      position += 4;
      source = source.substr(4);
      continue;
    }

    // Skip over heading underlines, definitions, block quotes, code fences,
    // lists, element tags.
    if (m = (
      / *[=\-]{2,} *(?:\n+|$)/.exec(source) ||
      blockRules.def.exec(source) ||
      /^ *> */.exec(source) ||
      /^ *(?:`{3,}|~{3,}) *(?:\S+)? *\n/.exec(source) ||
      /^(?:[*+-]|\d+\.) */.exec(source) ||
      blockRules.hr.exec(source) ||
      inlineRules.tag.exec(source)
    )) {
      position += m[0].length;
      source = source.substr(m[0].length);
      continue;
    }

    // Fix em, strong and code elements. Matches up to four times since
    // the marked parser is kind of relaxed on this.
    if (m = (
      /^([\*_]{1,4})([\*_]{0,4})([\s\S]+?)\2\1(?!\1)/.exec(source) ||
      /^(`+)(\s*)([\s\S]*?[^`])\s*\1(?!`)/.exec(source)
    )) {
      if (index + m[3].length > text.length) {
        position += text.length - index + m[1].length + m[2].length;
        break;
      }

      index += m[3].length;
      position += m[0].length;
      source = source.substr(m[0].length);
      continue;
    }

    // Skip over escape characters.
    if (m = inlineRules.escape.exec(source)) {
      position += 1;
      source = source.substr(1);
      continue;
    }

    // Fix trailing spaces at end of lines in markdown.
    if (m = /( +)(?:\n|$)/.exec(source)) {
      source = source.substr(m[1].length);
      position += m[1].length;
      continue;
    }

    // Fix spacing between elements in parsed markdown output.
    if (text.charAt(index) === '\n') {
      index += 1;
      continue;
    }

    break;
  }

  var line = 0;

  var ch = markdown.substr(0, position).replace(/.*\r?\n/g, function () {
    return line++, '';
  }).length;

  return {
    ch:   ch,
    line: line
  };
};

/**
 * Create a new text cell instance.
 *
 * @type {Function}
 */
var TextCell = module.exports = EditorCell.extend({
  className: 'cell cell-text'
});

/**
 * Initialize the text cell and set default options.
 */
TextCell.prototype.initialize = function () {
  EditorCell.prototype.initialize.apply(this, arguments);

  this.listenTo(config, 'textReadOnly', function () {
    this.data.set('readOnly', !config.get('textReadOnly'));
    this.renderEditor();
  });
};

/**
 * Default cell model attributes.
 *
 * @type {Object}
 */
TextCell.prototype.cellAttributes = {
  type: 'text'
};

/**
 * Listen for events on text cell instances.
 *
 * @type {Object}
 */
TextCell.prototype.events = _.extend({
  'click .markdown': function (e) {
    if (this.hasFocus() || _.contains(['A', 'BUTTON'], e.target.tagName)) {
      return;
    }

    var selection = window.getSelection();
    var positions = this.getPositions(selection, this.model.get('value'));

    return this.focus(positions);
  }
}, EditorCell.prototype.events);

/**
 * Options that will be passed to the CodeMirror instance.
 *
 * @type {Object}
 */
TextCell.prototype.editorOptions = _.extend(
  {},
  EditorCell.prototype.editorOptions,
  {
    mode: 'gfm',
    theme: 'text-cell'
  }
);

/**
 * Binds the CodeMirror instance with any listeners.
 *
 * @return {TextCell}
 */
TextCell.prototype.bindEditor = function () {
  EditorCell.prototype.bindEditor.call(this);

  // Listen to itself since editor cells have a built in protection here.
  this.listenTo(this, 'blur', this.renderEditor);

  return this;
};

/**
 * Focus the text cell instance. Render the CodeMirror instance.
 *
 * @return {TextCell}
 */
TextCell.prototype.focus = embedProtect(function (cursor) {
  EditorCell.prototype.renderEditor.call(this);
  this.editor.focus();

  // Set the closest cursor positions.
  if (cursor) {
    this.editor.doc.setSelection(cursor.start, cursor.end);
  }

  return this;
});


/**
 * Return the positions of a selection node relative to markdown text.
 *
 * @return {Object}
 */
TextCell.prototype.getPositions = function (selection) {
  var focusText, anchorText;

  var positions    = {};
  var anchorNode   = selection.anchorNode;
  var focusNode    = selection.focusNode;
  var anchorOffset = selection.anchorOffset;
  var focusOffset  = selection.focusOffset;

  // Get the text leading up to the focus node.
  focusText = getPrevText(focusNode, focusOffset, this.markdownElement);
  positions.end = getTextPosition(focusText, this.getValue());

  if (anchorNode === focusNode && anchorOffset === focusOffset) {
    anchorText = focusText;
    positions.start = positions.end;
  } else {
    anchorText = getPrevText(anchorNode, anchorOffset, this.markdownElement);
    positions.start = getTextPosition(anchorText, this.getValue());
  }

  return positions;
};

/**
 * Set the value of the text cell. Switches between updating the CodeMirror view
 * and the Markdown rendered preview.
 *
 * @param  {String}   value
 * @return {TextCell}
 */
TextCell.prototype.setValue = function (value) {
  EditorCell.prototype.setValue.call(this, value);

  return this.renderEditor();
};

/**
 * Remove the rendered Markdown cell and potential editor instance.
 *
 * @return {TextCell}
 */
TextCell.prototype.removeEditor = function () {
  if (this.markdownElement) {
    this.markdownElement.parentNode.removeChild(this.markdownElement);
    delete this.markdownElement;
  }

  return EditorCell.prototype.removeEditor.call(this);
};

/**
 * Override the editor with a markdown viewer.
 *
 * @return {TextCell}
 */
TextCell.prototype.renderEditor = function () {
  this.removeEditor();

  this.markdownElement = this.el.insertBefore(
    domify('<div class="markdown"></div>'), this.el.firstChild
  );

  marked(this.getValue(), {
    gfm: true,
    // highlight: function () {},
    tables: true,
    breaks: true,
    pedantic: false,
    sanitize: false,
    smartLists: true,
    smartypants: false,
    langPrefix: 'lang-'
  }, _.bind(function (err, html) {
    this.markdownElement.innerHTML = html;
  }, this));

  messages.trigger('resize');

  return this;
};

},{"../state/config":107,"../state/messages":108,"./editor-cell":118,"./lib/embed-protect":121,"domify":43,"marked":46,"underscore":49}],128:[function(require,module,exports){
var Backbone = require('backbone');

/**
 * Create a new view instance. This is the base view instance so any generic
 * view methods or functionality should be added here.
 *
 * @type {Function}
 */
var View = module.exports = Backbone.View.extend();

/**
 * Initialize every view with a private data collection. This allows views to
 * hold view specific logic that doesn't belong with a model.
 */
View.prototype.initialize = function () {
  this.data = new Backbone.Model({
    rendered: false
  });
};

/**
 * Render the view instance.
 *
 * @return {this}
 */
View.prototype.render = function () {
  this.el.innerHTML = '';
  this.delegateEvents();
  this.data.set('rendered', true);
  return this;
};

/**
 * Remove the view instance from the DOM.
 *
 * @return {this}
 */
View.prototype.remove = function () {
  // Trigger the `remove` event before actually removing the view since we may
  // need to append a new element afterward, etc.
  this.trigger('remove', this);
  Backbone.View.prototype.remove.call(this);
  return this;
};

/**
 * Insert an element last in the list of child nodes of this view.
 *
 * @param  {Node} el The element to append this view to.
 * @return {this}
 */
View.prototype.appendTo = function (el) {
  if (typeof el.appendChild === 'function') {
    el.appendChild(this.el);
  } else {
    el.call(this, this.el);
  }
  return this;
};

/**
 * Insert an element first in the list of child nodes of this element.
 *
 * @param  {Node} el The element to prepend this view to.
 * @return {this}
 */
View.prototype.prependTo = function (el) {
  return this.appendTo.call(this, function () {
    el.insertBefore(this.el, el.firstChild);
  });
};

},{"backbone":3}],129:[function(require,module,exports){
// DOMBarsify compiled template
var DOMBars = require("dombars/runtime");
module.exports = DOMBars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = document.createDocumentFragment(), stack1, stack2, element1, get=this.get, functionType="function", escapeExpression=this.escapeExpression, appendChild=this.appendChild, self=this, partial=this.partial, createElement=this.createElement, setAttribute=this.setAttribute, createText=this.createText, wrapProgram=this.wrapProgram, createDOM=this.createDOM, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1, element2;
  appendChild(buffer, document.createTextNode("\n  "));
  stack1 = element1 = createElement(partial(self.program(2, program2, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(4, program4, data), depth0), partial(self.program(6, program6, data), depth0));
  appendChild(element1, self.program(8, program8, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n\n  "));
  stack1 = element2 = createElement(partial(self.program(23, program23, data), depth0), function (el) { element2 = el; });
  setAttribute(function () { return element2; }, partial(self.program(4, program4, data), depth0), partial(self.program(25, program25, data), depth0));
  appendChild(element2, self.program(27, program27, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n"));
  return buffer;
  }
function program2(depth0,data) {
  
  
  return "header";
  }

function program4(depth0,data) {
  
  
  return "class";
  }

function program6(depth0,data) {
  
  
  return "notebook-header clearfix";
  }

function program8(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1;
  appendChild(buffer, document.createTextNode("\n    "));
  stack1 = element1 = createElement(partial(self.program(9, program9, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(4, program4, data), depth0), partial(self.program(11, program11, data), depth0));
  setAttribute(function () { return element1; }, partial(self.program(13, program13, data), depth0), partial(self.program(15, program15, data), depth0));
  setAttribute(function () { return element1; }, partial(self.program(17, program17, data), depth0), partial(self.program(19, program19, data), depth0));
  appendChild(element1, self.program(21, program21, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n  "));
  return buffer;
  }
function program9(depth0,data) {
  
  
  return "input";
  }

function program11(depth0,data) {
  
  
  return "notebook-title";
  }

function program13(depth0,data) {
  
  
  return "autocomplete";
  }

function program15(depth0,data) {
  
  
  return "off";
  }

function program17(depth0,data) {
  
  
  return "value";
  }

function program19(depth0,data) {
  
  var stack1;
  return escapeExpression(((stack1 = ((stack1 = ((stack1 = ((stack1 = (data == null || data === false ? data : get(data, "persistence", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "notebook", "stack1"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "meta", "stack1"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "title", "stack1"))),typeof stack1 === functionType ? stack1.apply(depth0) : stack1));
  }

function program21(depth0,data) {
  
  var buffer = document.createDocumentFragment();
  return buffer;
  }

function program23(depth0,data) {
  
  
  return "div";
  }

function program25(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "notebook-toolbar clearfix notebook-"
    + escapeExpression(((stack1 = ((stack1 = (data == null || data === false ? data : get(data, "data", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "activeView", "stack1"))),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "-active";
  return buffer;
  }

function program27(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1, element2;
  appendChild(buffer, document.createTextNode("\n    "));
  stack1 = element1 = createElement(partial(self.program(23, program23, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(4, program4, data), depth0), partial(self.program(28, program28, data), depth0));
  appendChild(element1, self.program(30, program30, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n\n    "));
  stack1 = element2 = createElement(partial(self.program(23, program23, data), depth0), function (el) { element2 = el; });
  setAttribute(function () { return element2; }, partial(self.program(4, program4, data), depth0), partial(self.program(44, program44, data), depth0));
  appendChild(element2, self.program(46, program46, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n  "));
  return buffer;
  }
function program28(depth0,data) {
  
  
  return "toolbar-end";
  }

function program30(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1;
  appendChild(buffer, document.createTextNode("\n      "));
  stack1 = element1 = createElement(partial(self.program(31, program31, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(4, program4, data), depth0), partial(self.program(33, program33, data), depth0));
  setAttribute(function () { return element1; }, partial(self.program(35, program35, data), depth0), partial(self.program(37, program37, data), depth0));
  appendChild(element1, self.program(39, program39, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n    "));
  return buffer;
  }
function program31(depth0,data) {
  
  
  return "button";
  }

function program33(depth0,data) {
  
  
  return "edit-source toggle-notebook hint--bottom";
  }

function program35(depth0,data) {
  
  
  return "data-hint";
  }

function program37(depth0,data) {
  
  
  return "Edit source";
  }

function program39(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1;
  appendChild(buffer, document.createTextNode("\n        "));
  stack1 = element1 = createElement(partial(self.program(40, program40, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(4, program4, data), depth0), partial(self.program(42, program42, data), depth0));
  appendChild(element1, self.program(21, program21, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n      "));
  return buffer;
  }
function program40(depth0,data) {
  
  
  return "i";
  }

function program42(depth0,data) {
  
  
  return "icon";
  }

function program44(depth0,data) {
  
  
  return "toolbar-inner";
  }

function program46(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, stack2, element1;
  appendChild(buffer, document.createTextNode("\n      "));
  stack1 = function () {
  stack2 = helpers['if'].call(depth0, ((stack1 = (data == null || data === false ? data : get(data, "data", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "stateText", "stack1")), {hash:{},inverse:wrapProgram(self.noop),fn:wrapProgram(self.program(47, program47, data)),data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription});
  return stack2;
  };
  appendChild(buffer, createDOM(stack1));
  appendChild(buffer, document.createTextNode("\n      "));
  stack1 = element1 = createElement(partial(self.program(23, program23, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(4, program4, data), depth0), partial(self.program(52, program52, data), depth0));
  appendChild(element1, self.program(54, program54, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n    "));
  return buffer;
  }
function program47(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1;
  appendChild(buffer, document.createTextNode("\n        "));
  stack1 = element1 = createElement(partial(self.program(23, program23, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(4, program4, data), depth0), partial(self.program(48, program48, data), depth0));
  appendChild(element1, self.program(50, program50, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n      "));
  return buffer;
  }
function program48(depth0,data) {
  
  
  return "persistence-status";
  }

function program50(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, stack2;
  stack1 = function () {
  stack2 = ((stack1 = ((stack1 = (data == null || data === false ? data : get(data, "data", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "stateText", "stack1"))),typeof stack1 === functionType ? stack1.apply(depth0) : stack1);
  return stack2;
  };
  appendChild(buffer, createText(stack1));
  appendChild(buffer, document.createTextNode("."));
  return buffer;
  }

function program52(depth0,data) {
  
  
  return "toolbar-buttons";
  }

function program54(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1, element2;
  appendChild(buffer, document.createTextNode("\n        "));
  stack1 = element1 = createElement(partial(self.program(55, program55, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(4, program4, data), depth0), partial(self.program(57, program57, data), depth0));
  appendChild(element1, self.program(59, program59, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n        "));
  stack1 = element2 = createElement(partial(self.program(55, program55, data), depth0), function (el) { element2 = el; });
  setAttribute(function () { return element2; }, partial(self.program(4, program4, data), depth0), partial(self.program(64, program64, data), depth0));
  appendChild(element2, self.program(66, program66, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n      "));
  return buffer;
  }
function program55(depth0,data) {
  
  
  return "span";
  }

function program57(depth0,data) {
  
  
  return "btn-edit";
  }

function program59(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1;
  appendChild(buffer, document.createTextNode("\n          "));
  stack1 = element1 = createElement(partial(self.program(31, program31, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(4, program4, data), depth0), partial(self.program(60, program60, data), depth0));
  appendChild(element1, self.program(62, program62, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n        "));
  return buffer;
  }
function program60(depth0,data) {
  
  
  return "btn-text toggle-notebook";
  }

function program62(depth0,data) {
  
  
  return document.createTextNode("Return to notebook view");
  }

function program64(depth0,data) {
  
  
  return "btn-view";
  }

function program66(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1, element2;
  appendChild(buffer, document.createTextNode("\n          "));
  stack1 = element1 = createElement(partial(self.program(55, program55, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(4, program4, data), depth0), partial(self.program(67, program67, data), depth0));
  appendChild(element1, self.program(69, program69, data)(depth0));
  appendChild(buffer, stack1);
  stack1 = element2 = createElement(partial(self.program(55, program55, data), depth0), function (el) { element2 = el; });
  setAttribute(function () { return element2; }, partial(self.program(4, program4, data), depth0), partial(self.program(67, program67, data), depth0));
  appendChild(element2, self.program(107, program107, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n        "));
  return buffer;
  }
function program67(depth0,data) {
  
  
  return "btn-group";
  }

function program69(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, stack2, element1, element2;
  appendChild(buffer, document.createTextNode("\n            "));
  stack1 = element1 = createElement(partial(self.program(31, program31, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(4, program4, data), depth0), partial(self.program(70, program70, data), depth0));
  setAttribute(function () { return element1; }, partial(self.program(35, program35, data), depth0), partial(self.program(72, program72, data), depth0));
  appendChild(element1, self.program(74, program74, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n            "));
  stack1 = function () {
  stack2 = helpers['if'].call(depth0, ((stack1 = (data == null || data === false ? data : get(data, "config", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "savable", "stack1")), {hash:{},inverse:wrapProgram(self.noop),fn:wrapProgram(self.program(77, program77, data)),data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription});
  return stack2;
  };
  appendChild(buffer, createDOM(stack1));
  appendChild(buffer, document.createTextNode("\n            "));
  stack1 = element2 = createElement(partial(self.program(31, program31, data), depth0), function (el) { element2 = el; });
  setAttribute(function () { return element2; }, partial(self.program(4, program4, data), depth0), partial(self.program(99, program99, data), depth0));
  setAttribute(function () { return element2; }, partial(self.program(35, program35, data), depth0), partial(self.program(101, program101, data), depth0));
  appendChild(element2, self.program(104, program104, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n          "));
  return buffer;
  }
function program70(depth0,data) {
  
  
  return "btn-round notebook-new hint--bottom";
  }

function program72(depth0,data) {
  
  
  return "New notebook";
  }

function program74(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1;
  appendChild(buffer, document.createTextNode("\n              "));
  stack1 = element1 = createElement(partial(self.program(40, program40, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(4, program4, data), depth0), partial(self.program(75, program75, data), depth0));
  appendChild(element1, self.program(21, program21, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n            "));
  return buffer;
  }
function program75(depth0,data) {
  
  
  return "icon-doc";
  }

function program77(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1, element2;
  appendChild(buffer, document.createTextNode("\n            "));
  stack1 = element1 = createElement(partial(self.program(31, program31, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(4, program4, data), depth0), partial(self.program(78, program78, data), depth0));
  setAttribute(function () { return element1; }, partial(self.program(35, program35, data), depth0), partial(self.program(81, program81, data), depth0));
  appendChild(element1, self.program(86, program86, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n            "));
  stack1 = element2 = createElement(partial(self.program(31, program31, data), depth0), function (el) { element2 = el; });
  setAttribute(function () { return element2; }, partial(self.program(4, program4, data), depth0), partial(self.program(89, program89, data), depth0));
  setAttribute(function () { return element2; }, partial(self.program(35, program35, data), depth0), partial(self.program(91, program91, data), depth0));
  appendChild(element2, self.program(96, program96, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n            "));
  return buffer;
  }
function program78(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "btn-round notebook-save hint--bottom ";
  stack1 = helpers.unless.call(depth0, ((stack1 = (data == null || data === false ? data : get(data, "data", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "savable", "stack1")), {hash:{},inverse:wrapProgram(self.noop),fn:wrapProgram(self.program(79, program79, data)),data:data,attribute:true,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription});
  buffer += stack1;
  return buffer;
  }
function program79(depth0,data) {
  
  
  return "btn-disabled";
  }

function program81(depth0,data) {
  
  var stack1;
  stack1 = helpers['if'].call(depth0, ((stack1 = (data == null || data === false ? data : get(data, "data", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "savable", "stack1")), {hash:{},inverse:wrapProgram(self.program(84, program84, data)),fn:wrapProgram(self.program(82, program82, data)),data:data,attribute:true,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription});
  return stack1;
  }
function program82(depth0,data) {
  
  
  return "Save notebook";
  }

function program84(depth0,data) {
  
  
  return "Clone the notebook to save";
  }

function program86(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1;
  appendChild(buffer, document.createTextNode("\n              "));
  stack1 = element1 = createElement(partial(self.program(40, program40, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(4, program4, data), depth0), partial(self.program(87, program87, data), depth0));
  appendChild(element1, self.program(21, program21, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n            "));
  return buffer;
  }
function program87(depth0,data) {
  
  
  return "icon-floppy";
  }

function program89(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "btn-round notebook-clone hint--bottom ";
  stack1 = helpers.unless.call(depth0, ((stack1 = (data == null || data === false ? data : get(data, "data", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "cloneable", "stack1")), {hash:{},inverse:wrapProgram(self.noop),fn:wrapProgram(self.program(79, program79, data)),data:data,attribute:true,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription});
  buffer += stack1;
  return buffer;
  }

function program91(depth0,data) {
  
  var stack1;
  stack1 = helpers['if'].call(depth0, ((stack1 = (data == null || data === false ? data : get(data, "data", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "cloneable", "stack1")), {hash:{},inverse:wrapProgram(self.program(94, program94, data)),fn:wrapProgram(self.program(92, program92, data)),data:data,attribute:true,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription});
  return stack1;
  }
function program92(depth0,data) {
  
  
  return "Clone notebook";
  }

function program94(depth0,data) {
  
  
  return "Save notebook to fork";
  }

function program96(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1;
  appendChild(buffer, document.createTextNode("\n              "));
  stack1 = element1 = createElement(partial(self.program(40, program40, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(4, program4, data), depth0), partial(self.program(97, program97, data), depth0));
  appendChild(element1, self.program(21, program21, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n            "));
  return buffer;
  }
function program97(depth0,data) {
  
  
  return "icon-fork";
  }

function program99(depth0,data) {
  
  
  return "btn-round notebook-share hint--bottom";
  }

function program101(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "Share ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (data == null || data === false ? data : get(data, "data", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "shareable", "stack1")), {hash:{},inverse:wrapProgram(self.noop),fn:wrapProgram(self.program(102, program102, data)),data:data,attribute:true,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription});
  buffer += stack1
    + " notebook";
  return buffer;
  }
function program102(depth0,data) {
  
  
  return "current";
  }

function program104(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1;
  appendChild(buffer, document.createTextNode("\n              "));
  stack1 = element1 = createElement(partial(self.program(40, program40, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(4, program4, data), depth0), partial(self.program(105, program105, data), depth0));
  appendChild(element1, self.program(21, program21, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n            "));
  return buffer;
  }
function program105(depth0,data) {
  
  
  return "icon-share";
  }

function program107(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1, element2;
  appendChild(buffer, document.createTextNode("\n            "));
  stack1 = element1 = createElement(partial(self.program(31, program31, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(4, program4, data), depth0), partial(self.program(108, program108, data), depth0));
  setAttribute(function () { return element1; }, partial(self.program(35, program35, data), depth0), partial(self.program(110, program110, data), depth0));
  appendChild(element1, self.program(112, program112, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n            "));
  stack1 = element2 = createElement(partial(self.program(31, program31, data), depth0), function (el) { element2 = el; });
  setAttribute(function () { return element2; }, partial(self.program(4, program4, data), depth0), partial(self.program(115, program115, data), depth0));
  setAttribute(function () { return element2; }, partial(self.program(35, program35, data), depth0), partial(self.program(117, program117, data), depth0));
  appendChild(element2, self.program(119, program119, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n          "));
  return buffer;
  }
function program108(depth0,data) {
  
  
  return "btn-round notebook-exec hint--bottom";
  }

function program110(depth0,data) {
  
  
  return "Play notebook";
  }

function program112(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1;
  appendChild(buffer, document.createTextNode("\n              "));
  stack1 = element1 = createElement(partial(self.program(40, program40, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(4, program4, data), depth0), partial(self.program(113, program113, data), depth0));
  appendChild(element1, self.program(21, program21, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n            "));
  return buffer;
  }
function program113(depth0,data) {
  
  
  return "icon-play";
  }

function program115(depth0,data) {
  
  
  return "btn-round notebook-help hint--bottom";
  }

function program117(depth0,data) {
  
  
  return "Shortcuts";
  }

function program119(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1;
  appendChild(buffer, document.createTextNode("\n              "));
  stack1 = element1 = createElement(partial(self.program(40, program40, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(4, program4, data), depth0), partial(self.program(42, program42, data), depth0));
  appendChild(element1, self.program(21, program21, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n            "));
  return buffer;
  }

function program121(depth0,data) {
  
  
  return "notebook";
  }

function program123(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, stack2, element1;
  appendChild(buffer, document.createTextNode("\n  "));
  stack1 = function () {
  stack2 = helpers['if'].call(depth0, ((stack1 = (data == null || data === false ? data : get(data, "config", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "sidebar", "stack1")), {hash:{},inverse:wrapProgram(self.noop),fn:wrapProgram(self.program(124, program124, data)),data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription});
  return stack2;
  };
  appendChild(buffer, createDOM(stack1));
  appendChild(buffer, document.createTextNode("\n\n  "));
  stack1 = element1 = createElement(partial(self.program(23, program23, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(4, program4, data), depth0), partial(self.program(126, program126, data), depth0));
  appendChild(element1, self.program(128, program128, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n"));
  return buffer;
  }
function program124(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, stack2, helper, options;
  appendChild(buffer, document.createTextNode("\n    "));
  stack1 = function () {
  stack2 = (helper = helpers.view || get(depth0, "view", "depth0"),options={hash:{},data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription},helper ? helper.call(depth0, ((stack1 = (data == null || data === false ? data : get(data, "data", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "sidebar", "stack1")), options) : helperMissing.call(depth0, "view", ((stack1 = (data == null || data === false ? data : get(data, "data", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "sidebar", "stack1")), options));
  return stack2;
  };
  appendChild(buffer, createDOM(stack1));
  appendChild(buffer, document.createTextNode("\n  "));
  return buffer;
  }

function program126(depth0,data) {
  
  
  return "notebook-content";
  }

function program128(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, stack2, helper, options;
  appendChild(buffer, document.createTextNode("\n    "));
  stack1 = function () {
  stack2 = (helper = helpers.view || get(depth0, "view", "depth0"),options={hash:{},data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription},helper ? helper.call(depth0, ((stack1 = (data == null || data === false ? data : get(data, "data", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "notebook", "stack1")), options) : helperMissing.call(depth0, "view", ((stack1 = (data == null || data === false ? data : get(data, "data", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "notebook", "stack1")), options));
  return stack2;
  };
  appendChild(buffer, createDOM(stack1));
  appendChild(buffer, document.createTextNode("\n\n    "));
  stack1 = function () {
  stack2 = helpers.unless.call(depth0, ((stack1 = (data == null || data === false ? data : get(data, "config", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "embedded", "stack1")), {hash:{},inverse:wrapProgram(self.noop),fn:wrapProgram(self.program(129, program129, data)),data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription});
  return stack2;
  };
  appendChild(buffer, createDOM(stack1));
  appendChild(buffer, document.createTextNode("\n  "));
  return buffer;
  }
function program129(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1;
  appendChild(buffer, document.createTextNode("\n      "));
  stack1 = element1 = createElement(partial(self.program(130, program130, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(132, program132, data), depth0), partial(self.program(134, program134, data), depth0));
  setAttribute(function () { return element1; }, partial(self.program(4, program4, data), depth0), partial(self.program(136, program136, data), depth0));
  appendChild(element1, self.program(138, program138, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n    "));
  return buffer;
  }
function program130(depth0,data) {
  
  
  return "a";
  }

function program132(depth0,data) {
  
  
  return "href";
  }

function program134(depth0,data) {
  
  
  return "http://mulesoft.com";
  }

function program136(depth0,data) {
  
  
  return "ir powered-by-logo";
  }

function program138(depth0,data) {
  
  
  return document.createTextNode("Mulesoft");
  }

function program140(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1;
  appendChild(buffer, document.createTextNode("\n  "));
  stack1 = element1 = createElement(partial(self.program(23, program23, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(4, program4, data), depth0), partial(self.program(141, program141, data), depth0));
  appendChild(element1, self.program(143, program143, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n"));
  return buffer;
  }
function program141(depth0,data) {
  
  
  return "modal ui-loading";
  }

function program143(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1;
  appendChild(buffer, document.createTextNode("\n    "));
  stack1 = element1 = createElement(partial(self.program(40, program40, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(4, program4, data), depth0), partial(self.program(144, program144, data), depth0));
  appendChild(element1, self.program(21, program21, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n  "));
  return buffer;
  }
function program144(depth0,data) {
  
  
  return "ui-loading-icon icon-arrows-cw animate-spin";
  }

function program146(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1;
  appendChild(buffer, document.createTextNode("\n  "));
  stack1 = element1 = createElement(partial(self.program(23, program23, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(4, program4, data), depth0), partial(self.program(147, program147, data), depth0));
  appendChild(element1, self.program(149, program149, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n"));
  return buffer;
  }
function program147(depth0,data) {
  
  
  return "notebook-footer clearfix";
  }

function program149(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1, element2;
  appendChild(buffer, document.createTextNode("\n    "));
  stack1 = element1 = createElement(partial(self.program(23, program23, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(4, program4, data), depth0), partial(self.program(150, program150, data), depth0));
  appendChild(element1, self.program(152, program152, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n\n    "));
  stack1 = element2 = createElement(partial(self.program(23, program23, data), depth0), function (el) { element2 = el; });
  setAttribute(function () { return element2; }, partial(self.program(4, program4, data), depth0), partial(self.program(168, program168, data), depth0));
  appendChild(element2, self.program(170, program170, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n  "));
  return buffer;
  }
function program150(depth0,data) {
  
  
  return "footer-end";
  }

function program152(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, stack2, element1, helper, options;
  appendChild(buffer, document.createTextNode("\n      "));
  stack1 = element1 = createElement(partial(self.program(31, program31, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(4, program4, data), depth0), partial(self.program(153, program153, data), depth0));
  setAttribute(function () { return element1; }, partial(self.program(35, program35, data), depth0), partial(self.program(155, program155, data), depth0));
  appendChild(element1, self.program(157, program157, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n      "));
  stack1 = function () {
  stack2 = (helper = helpers.unlessEqual || get(depth0, "unlessEqual", "depth0"),options={hash:{},inverse:wrapProgram(self.noop),fn:wrapProgram(self.program(159, program159, data)),data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription},helper ? helper.call(depth0, ((stack1 = (data == null || data === false ? data : get(data, "config", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "fullUrl", "stack1")), ((stack1 = (data == null || data === false ? data : get(data, "config", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "siteUrl", "stack1")), options) : helperMissing.call(depth0, "unlessEqual", ((stack1 = (data == null || data === false ? data : get(data, "config", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "fullUrl", "stack1")), ((stack1 = (data == null || data === false ? data : get(data, "config", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "siteUrl", "stack1")), options));
  return stack2;
  };
  appendChild(buffer, createDOM(stack1));
  appendChild(buffer, document.createTextNode("\n    "));
  return buffer;
  }
function program153(depth0,data) {
  
  
  return "btn-footer notebook-exec hint--top";
  }

function program155(depth0,data) {
  
  
  return "Execute all cells";
  }

function program157(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1;
  appendChild(buffer, document.createTextNode("\n        Play notebook"));
  stack1 = element1 = createElement(partial(self.program(40, program40, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(4, program4, data), depth0), partial(self.program(113, program113, data), depth0));
  appendChild(element1, self.program(21, program21, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n      "));
  return buffer;
  }

function program159(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1;
  appendChild(buffer, document.createTextNode("\n        "));
  stack1 = element1 = createElement(partial(self.program(130, program130, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(132, program132, data), depth0), partial(self.program(160, program160, data), depth0));
  setAttribute(function () { return element1; }, partial(self.program(4, program4, data), depth0), partial(self.program(162, program162, data), depth0));
  setAttribute(function () { return element1; }, partial(self.program(35, program35, data), depth0), partial(self.program(164, program164, data), depth0));
  appendChild(element1, self.program(166, program166, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n      "));
  return buffer;
  }
function program160(depth0,data) {
  
  var stack1;
  return escapeExpression(((stack1 = ((stack1 = (data == null || data === false ? data : get(data, "config", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "fullUrl", "stack1"))),typeof stack1 === functionType ? stack1.apply(depth0) : stack1));
  }

function program162(depth0,data) {
  
  
  return "btn-footer hint--top";
  }

function program164(depth0,data) {
  
  
  return "Make your own copy of this notebook";
  }

function program166(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1;
  appendChild(buffer, document.createTextNode("\n          Clone notebook"));
  stack1 = element1 = createElement(partial(self.program(40, program40, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(4, program4, data), depth0), partial(self.program(97, program97, data), depth0));
  appendChild(element1, self.program(21, program21, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n        "));
  return buffer;
  }

function program168(depth0,data) {
  
  
  return "footer-inner";
  }

function program170(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, stack2;
  appendChild(buffer, document.createTextNode("\n      "));
  stack1 = function () {
  stack2 = helpers['if'].call(depth0, ((stack1 = (data == null || data === false ? data : get(data, "data", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "shareable", "stack1")), {hash:{},inverse:wrapProgram(self.program(178, program178, data)),fn:wrapProgram(self.program(171, program171, data)),data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription});
  return stack2;
  };
  appendChild(buffer, createDOM(stack1));
  appendChild(buffer, document.createTextNode("\n    "));
  return buffer;
  }
function program171(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1, element2;
  appendChild(buffer, document.createTextNode("\n        "));
  stack1 = element1 = createElement(partial(self.program(130, program130, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(132, program132, data), depth0), partial(self.program(160, program160, data), depth0));
  appendChild(element1, self.program(172, program172, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode(" hosted by "));
  stack1 = element2 = createElement(partial(self.program(130, program130, data), depth0), function (el) { element2 = el; });
  setAttribute(function () { return element2; }, partial(self.program(132, program132, data), depth0), partial(self.program(174, program174, data), depth0));
  appendChild(element2, self.program(176, program176, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n      "));
  return buffer;
  }
function program172(depth0,data) {
  
  var stack1, stack2;
  stack1 = function () {
  stack2 = ((stack1 = ((stack1 = ((stack1 = ((stack1 = (data == null || data === false ? data : get(data, "persistence", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "notebook", "stack1"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "meta", "stack1"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "title", "stack1"))),typeof stack1 === functionType ? stack1.apply(depth0) : stack1);
  return stack2;
  };
  return createText(stack1);
  }

function program174(depth0,data) {
  
  var stack1;
  return escapeExpression(((stack1 = ((stack1 = (data == null || data === false ? data : get(data, "config", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "siteUrl", "stack1"))),typeof stack1 === functionType ? stack1.apply(depth0) : stack1));
  }

function program176(depth0,data) {
  
  var stack1, stack2;
  stack1 = function () {
  stack2 = ((stack1 = ((stack1 = (data == null || data === false ? data : get(data, "config", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "siteTitle", "stack1"))),typeof stack1 === functionType ? stack1.apply(depth0) : stack1);
  return stack2;
  };
  return createText(stack1);
  }

function program178(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1;
  appendChild(buffer, document.createTextNode("\n        Hosted by "));
  stack1 = element1 = createElement(partial(self.program(130, program130, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(132, program132, data), depth0), partial(self.program(174, program174, data), depth0));
  appendChild(element1, self.program(176, program176, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n      "));
  return buffer;
  }

  stack1 = function () {
  stack2 = helpers['if'].call(depth0, ((stack1 = (data == null || data === false ? data : get(data, "config", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "header", "stack1")), {hash:{},inverse:wrapProgram(self.noop),fn:wrapProgram(self.program(1, program1, data)),data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription});
  return stack2;
  };
  appendChild(buffer, createDOM(stack1));
  appendChild(buffer, document.createTextNode("\n\n"));
  stack1 = element1 = createElement(partial(self.program(23, program23, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(4, program4, data), depth0), partial(self.program(121, program121, data), depth0));
  appendChild(element1, self.program(123, program123, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n\n"));
  stack1 = function () {
  stack2 = helpers['if'].call(depth0, ((stack1 = (data == null || data === false ? data : get(data, "state", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "loading", "stack1")), {hash:{},inverse:wrapProgram(self.noop),fn:wrapProgram(self.program(140, program140, data)),data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription});
  return stack2;
  };
  appendChild(buffer, createDOM(stack1));
  appendChild(buffer, document.createTextNode("\n\n"));
  stack1 = function () {
  stack2 = helpers['if'].call(depth0, ((stack1 = (data == null || data === false ? data : get(data, "config", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "footer", "stack1")), {hash:{},inverse:wrapProgram(self.noop),fn:wrapProgram(self.program(146, program146, data)),data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription});
  return stack2;
  };
  appendChild(buffer, createDOM(stack1));
  appendChild(buffer, document.createTextNode("\n"));
  return buffer;
  });
},{"dombars/runtime":42}],130:[function(require,module,exports){
// DOMBarsify compiled template
var DOMBars = require("dombars/runtime");
module.exports = DOMBars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = document.createDocumentFragment(), stack1, element1, functionType="function", self=this, get=this.get, escapeExpression=this.escapeExpression, createText=this.createText, appendChild=this.appendChild, partial=this.partial, createElement=this.createElement, setAttribute=this.setAttribute, wrapProgram=this.wrapProgram, createDOM=this.createDOM;

function program1(depth0,data) {
  
  
  return "div";
  }

function program3(depth0,data) {
  
  
  return "class";
  }

function program5(depth0,data) {
  
  
  return "cell-buttons-container";
  }

function program7(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, stack2;
  appendChild(buffer, document.createTextNode("\n  "));
  stack1 = function () {
  stack2 = helpers.each.call(depth0, ((stack1 = ((stack1 = (data == null || data === false ? data : get(data, "view", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "constructor", "stack1"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "controls", "stack1")), {hash:{},inverse:wrapProgram(self.noop),fn:wrapProgram(self.program(8, program8, data)),data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription});
  return stack2;
  };
  appendChild(buffer, createDOM(stack1));
  appendChild(buffer, document.createTextNode("\n"));
  return buffer;
  }
function program8(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1;
  appendChild(buffer, document.createTextNode("\n  "));
  stack1 = element1 = createElement(partial(self.program(9, program9, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(3, program3, data), depth0), partial(self.program(11, program11, data), depth0));
  setAttribute(function () { return element1; }, partial(self.program(13, program13, data), depth0), partial(self.program(15, program15, data), depth0));
  appendChild(element1, self.program(17, program17, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n  "));
  return buffer;
  }
function program9(depth0,data) {
  
  
  return "button";
  }

function program11(depth0,data) {
  
  
  return "action";
  }

function program13(depth0,data) {
  
  
  return "data-action";
  }

function program15(depth0,data) {
  
  var stack1, helper;
  if (helper = helpers.command) { stack1 = helper.call(depth0, {hash:{},data:data,attribute:true,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription}); }
  else { helper = get(depth0, "command", "depth0"); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data,attribute:true,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription}) : helper; }
  return escapeExpression(stack1);
  }

function program17(depth0,data) {
  
  var stack1, stack2, helper;
  stack1 = function () {
  if (helper = helpers.label) { stack2 = helper.call(depth0, {hash:{},data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription}); }
  else { helper = get(depth0, "label", "depth0"); stack2 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription}) : helper; }
  return stack2;
  };
  return createText(stack1);
  }

  stack1 = element1 = createElement(partial(self.program(1, program1, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(3, program3, data), depth0), partial(self.program(5, program5, data), depth0));
  appendChild(element1, self.program(7, program7, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n"));
  return buffer;
  });
},{"dombars/runtime":42}],131:[function(require,module,exports){
// DOMBarsify compiled template
var DOMBars = require("dombars/runtime");
module.exports = DOMBars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = document.createDocumentFragment(), stack1, stack2, functionType="function", self=this, get=this.get, escapeExpression=this.escapeExpression, createText=this.createText, appendChild=this.appendChild, partial=this.partial, createElement=this.createElement, wrapProgram=this.wrapProgram, createDOM=this.createDOM, setAttribute=this.setAttribute;

function program1(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1;
  appendChild(buffer, document.createTextNode("\n"));
  stack1 = element1 = createElement(partial(self.program(2, program2, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(4, program4, data), depth0), partial(self.program(6, program6, data), depth0));
  setAttribute(function () { return element1; }, partial(self.program(8, program8, data), depth0), partial(self.program(10, program10, data), depth0));
  appendChild(element1, self.program(12, program12, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n"));
  return buffer;
  }
function program2(depth0,data) {
  
  
  return "button";
  }

function program4(depth0,data) {
  
  
  return "class";
  }

function program6(depth0,data) {
  
  
  return "action";
  }

function program8(depth0,data) {
  
  
  return "data-action";
  }

function program10(depth0,data) {
  
  var stack1, helper;
  if (helper = helpers.command) { stack1 = helper.call(depth0, {hash:{},data:data,attribute:true,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription}); }
  else { helper = get(depth0, "command", "depth0"); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data,attribute:true,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription}) : helper; }
  return escapeExpression(stack1);
  }

function program12(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, stack2, helper;
  appendChild(buffer, document.createTextNode("\n  "));
  stack1 = function () {
  if (helper = helpers.label) { stack2 = helper.call(depth0, {hash:{},data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription}); }
  else { helper = get(depth0, "label", "depth0"); stack2 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription}) : helper; }
  return stack2;
  };
  appendChild(buffer, createText(stack1));
  stack1 = function () {
  stack2 = helpers['if'].call(depth0, get(depth0, "keyCode", "depth0"), {hash:{},inverse:wrapProgram(self.noop),fn:wrapProgram(self.program(13, program13, data)),data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription});
  return stack2;
  };
  appendChild(buffer, createDOM(stack1));
  appendChild(buffer, document.createTextNode("\n"));
  return buffer;
  }
function program13(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1;
  appendChild(buffer, document.createTextNode(" "));
  stack1 = element1 = createElement(partial(self.program(14, program14, data), depth0), function (el) { element1 = el; });
  appendChild(element1, self.program(16, program16, data)(depth0));
  appendChild(buffer, stack1);
  return buffer;
  }
function program14(depth0,data) {
  
  
  return "span";
  }

function program16(depth0,data) {
  
  var stack1, stack2, helper;
  stack1 = function () {
  if (helper = helpers.keyCode) { stack2 = helper.call(depth0, {hash:{},data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription}); }
  else { helper = get(depth0, "keyCode", "depth0"); stack2 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription}) : helper; }
  return stack2;
  };
  return createText(stack1);
  }

  stack1 = function () {
  stack2 = helpers.each.call(depth0, ((stack1 = (data == null || data === false ? data : get(data, "data", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "controls", "stack1")), {hash:{},inverse:wrapProgram(self.noop),fn:wrapProgram(self.program(1, program1, data)),data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription});
  return stack2;
  };
  appendChild(buffer, createDOM(stack1));
  appendChild(buffer, document.createTextNode("\n"));
  return buffer;
  });
},{"dombars/runtime":42}],132:[function(require,module,exports){
// DOMBarsify compiled template
var DOMBars = require("dombars/runtime");
module.exports = DOMBars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = document.createDocumentFragment(), stack1, stack2, helper, options, appendChild=this.appendChild, self=this, partial=this.partial, createElement=this.createElement, setAttribute=this.setAttribute, get=this.get, wrapProgram=this.wrapProgram, createDOM=this.createDOM, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1;
  appendChild(buffer, document.createTextNode("\n  "));
  stack1 = element1 = createElement(partial(self.program(2, program2, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(4, program4, data), depth0), partial(self.program(6, program6, data), depth0));
  appendChild(element1, self.program(8, program8, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n"));
  return buffer;
  }
function program2(depth0,data) {
  
  
  return "button";
  }

function program4(depth0,data) {
  
  
  return "class";
  }

function program6(depth0,data) {
  
  
  return "btn cell-controls-btn cell-execute";
  }

function program8(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1;
  appendChild(buffer, document.createTextNode("\n    "));
  stack1 = element1 = createElement(partial(self.program(9, program9, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(4, program4, data), depth0), partial(self.program(11, program11, data), depth0));
  appendChild(element1, self.program(13, program13, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n  "));
  return buffer;
  }
function program9(depth0,data) {
  
  
  return "i";
  }

function program11(depth0,data) {
  
  
  return "icon-play";
  }

function program13(depth0,data) {
  
  var buffer = document.createDocumentFragment();
  return buffer;
  }

function program15(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1;
  appendChild(buffer, document.createTextNode("\n  "));
  stack1 = element1 = createElement(partial(self.program(9, program9, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(4, program4, data), depth0), partial(self.program(16, program16, data), depth0));
  appendChild(element1, self.program(13, program13, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n"));
  return buffer;
  }
function program16(depth0,data) {
  
  
  return "cell-ui-execute icon-arrows-cw animate-spin";
  }

  stack1 = function () {
  stack2 = helpers['if'].call(depth0, ((stack1 = (data == null || data === false ? data : get(data, "config", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "embedded", "stack1")), {hash:{},inverse:wrapProgram(self.noop),fn:wrapProgram(self.program(1, program1, data)),data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription});
  return stack2;
  };
  appendChild(buffer, createDOM(stack1));
  appendChild(buffer, document.createTextNode("\n\n"));
  stack1 = function () {
  stack2 = helpers['if'].call(depth0, ((stack1 = (data == null || data === false ? data : get(data, "data", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "executing", "stack1")), {hash:{},inverse:wrapProgram(self.noop),fn:wrapProgram(self.program(15, program15, data)),data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription});
  return stack2;
  };
  appendChild(buffer, createDOM(stack1));
  appendChild(buffer, document.createTextNode("\n\n"));
  stack1 = function () {
  stack2 = (helper = helpers.view || get(depth0, "view", "depth0"),options={hash:{},data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription},helper ? helper.call(depth0, ((stack1 = (data == null || data === false ? data : get(data, "view", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "resultCell", "stack1")), options) : helperMissing.call(depth0, "view", ((stack1 = (data == null || data === false ? data : get(data, "view", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "resultCell", "stack1")), options));
  return stack2;
  };
  appendChild(buffer, createDOM(stack1));
  appendChild(buffer, document.createTextNode("\n"));
  return buffer;
  });
},{"dombars/runtime":42}],133:[function(require,module,exports){
// DOMBarsify compiled template
var DOMBars = require("dombars/runtime");
module.exports = DOMBars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = document.createDocumentFragment(), stack1, stack2, appendChild=this.appendChild, get=this.get, helperMissing=helpers.helperMissing, self=this, createDOM=this.createDOM, partial=this.partial, createElement=this.createElement, setAttribute=this.setAttribute, wrapProgram=this.wrapProgram;

function program1(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1, element2, element3;
  appendChild(buffer, document.createTextNode("\n  "));
  stack1 = element1 = createElement(partial(self.program(2, program2, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(4, program4, data), depth0), partial(self.program(6, program6, data), depth0));
  appendChild(element1, self.program(8, program8, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n\n  "));
  stack1 = element2 = createElement(partial(self.program(10, program10, data), depth0), function (el) { element2 = el; });
  setAttribute(function () { return element2; }, partial(self.program(4, program4, data), depth0), partial(self.program(12, program12, data), depth0));
  appendChild(element2, self.program(14, program14, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n\n  "));
  stack1 = element3 = createElement(partial(self.program(10, program10, data), depth0), function (el) { element3 = el; });
  setAttribute(function () { return element3; }, partial(self.program(4, program4, data), depth0), partial(self.program(27, program27, data), depth0));
  appendChild(element3, self.program(29, program29, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n"));
  return buffer;
  }
function program2(depth0,data) {
  
  
  return "button";
  }

function program4(depth0,data) {
  
  
  return "class";
  }

function program6(depth0,data) {
  
  
  return "btn cell-controls-btn cell-menu-toggle";
  }

function program8(depth0,data) {
  
  
  return document.createTextNode("");
  }

function program10(depth0,data) {
  
  
  return "div";
  }

function program12(depth0,data) {
  
  
  return "cell-border cell-border-above";
  }

function program14(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, stack2, element1, element2;
  appendChild(buffer, document.createTextNode("\n    "));
  stack1 = element1 = createElement(partial(self.program(15, program15, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(4, program4, data), depth0), partial(self.program(17, program17, data), depth0));
  appendChild(element1, self.program(19, program19, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n    "));
  stack1 = element2 = createElement(partial(self.program(21, program21, data), depth0), function (el) { element2 = el; });
  setAttribute(function () { return element2; }, partial(self.program(4, program4, data), depth0), partial(self.program(23, program23, data), depth0));
  appendChild(element2, self.program(19, program19, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n    "));
  stack1 = function () {
  stack2 = helpers['if'].call(depth0, ((stack1 = (data == null || data === false ? data : get(data, "data", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "cellButtonsAbove", "stack1")), {hash:{},inverse:wrapProgram(self.noop),fn:wrapProgram(self.program(25, program25, data)),data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription});
  return stack2;
  };
  appendChild(buffer, createDOM(stack1));
  appendChild(buffer, document.createTextNode("\n  "));
  return buffer;
  }
function program15(depth0,data) {
  
  
  return "span";
  }

function program17(depth0,data) {
  
  
  return "cell-border-line";
  }

function program19(depth0,data) {
  
  var buffer = document.createDocumentFragment();
  return buffer;
  }

function program21(depth0,data) {
  
  
  return "i";
  }

function program23(depth0,data) {
  
  
  return "cell-border-btn icon-plus-circled";
  }

function program25(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, stack2, helper, options;
  appendChild(buffer, document.createTextNode("\n      "));
  stack1 = function () {
  stack2 = (helper = helpers.view || get(depth0, "view", "depth0"),options={hash:{},data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription},helper ? helper.call(depth0, ((stack1 = (data == null || data === false ? data : get(data, "data", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "cellButtonsAbove", "stack1")), options) : helperMissing.call(depth0, "view", ((stack1 = (data == null || data === false ? data : get(data, "data", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "cellButtonsAbove", "stack1")), options));
  return stack2;
  };
  appendChild(buffer, createDOM(stack1));
  appendChild(buffer, document.createTextNode("\n    "));
  return buffer;
  }

function program27(depth0,data) {
  
  
  return "cell-border cell-border-below";
  }

function program29(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, stack2, element1, element2;
  appendChild(buffer, document.createTextNode("\n    "));
  stack1 = element1 = createElement(partial(self.program(15, program15, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(4, program4, data), depth0), partial(self.program(17, program17, data), depth0));
  appendChild(element1, self.program(19, program19, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n    "));
  stack1 = element2 = createElement(partial(self.program(21, program21, data), depth0), function (el) { element2 = el; });
  setAttribute(function () { return element2; }, partial(self.program(4, program4, data), depth0), partial(self.program(23, program23, data), depth0));
  appendChild(element2, self.program(19, program19, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n    "));
  stack1 = function () {
  stack2 = helpers['if'].call(depth0, ((stack1 = (data == null || data === false ? data : get(data, "data", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "cellButtonsBelow", "stack1")), {hash:{},inverse:wrapProgram(self.noop),fn:wrapProgram(self.program(30, program30, data)),data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription});
  return stack2;
  };
  appendChild(buffer, createDOM(stack1));
  appendChild(buffer, document.createTextNode("\n  "));
  return buffer;
  }
function program30(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, stack2, helper, options;
  appendChild(buffer, document.createTextNode("\n      "));
  stack1 = function () {
  stack2 = (helper = helpers.view || get(depth0, "view", "depth0"),options={hash:{},data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription},helper ? helper.call(depth0, ((stack1 = (data == null || data === false ? data : get(data, "data", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "cellButtonsBelow", "stack1")), options) : helperMissing.call(depth0, "view", ((stack1 = (data == null || data === false ? data : get(data, "data", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "cellButtonsBelow", "stack1")), options));
  return stack2;
  };
  appendChild(buffer, createDOM(stack1));
  appendChild(buffer, document.createTextNode("\n    "));
  return buffer;
  }

  stack1 = function () {
  stack2 = helpers.unless.call(depth0, ((stack1 = (data == null || data === false ? data : get(data, "config", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "embedded", "stack1")), {hash:{},inverse:wrapProgram(self.noop),fn:wrapProgram(self.program(1, program1, data)),data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription});
  return stack2;
  };
  appendChild(buffer, createDOM(stack1));
  appendChild(buffer, document.createTextNode("\n"));
  return buffer;
  });
},{"dombars/runtime":42}],134:[function(require,module,exports){
// DOMBarsify compiled template
var DOMBars = require("dombars/runtime");
module.exports = DOMBars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = document.createDocumentFragment(), stack1, element1, element2, appendChild=this.appendChild, get=this.get, functionType="function", createText=this.createText, self=this, partial=this.partial, createElement=this.createElement, setAttribute=this.setAttribute;

function program1(depth0,data) {
  
  
  return "div";
  }

function program3(depth0,data) {
  
  
  return "class";
  }

function program5(depth0,data) {
  
  
  return "result-label";
  }

function program7(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, stack2;
  appendChild(buffer, document.createTextNode("$"));
  stack1 = function () {
  stack2 = ((stack1 = ((stack1 = (data == null || data === false ? data : get(data, "data", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "index", "stack1"))),typeof stack1 === functionType ? stack1.apply(depth0) : stack1);
  return stack2;
  };
  appendChild(buffer, createText(stack1));
  appendChild(buffer, document.createTextNode("="));
  return buffer;
  }

function program9(depth0,data) {
  
  
  return "result-content";
  }

function program11(depth0,data) {
  
  var buffer = document.createDocumentFragment();
  return buffer;
  }

  stack1 = element1 = createElement(partial(self.program(1, program1, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(3, program3, data), depth0), partial(self.program(5, program5, data), depth0));
  appendChild(element1, self.program(7, program7, data)(depth0));
  appendChild(buffer, stack1);
  stack1 = element2 = createElement(partial(self.program(1, program1, data), depth0), function (el) { element2 = el; });
  setAttribute(function () { return element2; }, partial(self.program(3, program3, data), depth0), partial(self.program(9, program9, data), depth0));
  appendChild(element2, self.program(11, program11, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n"));
  return buffer;
  });
},{"dombars/runtime":42}],135:[function(require,module,exports){
// DOMBarsify compiled template
var DOMBars = require("dombars/runtime");
module.exports = DOMBars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = document.createDocumentFragment(), stack1, element1, element2, appendChild=this.appendChild, self=this, partial=this.partial, createElement=this.createElement, setAttribute=this.setAttribute, get=this.get, functionType="function", escapeExpression=this.escapeExpression, createText=this.createText, wrapProgram=this.wrapProgram, createDOM=this.createDOM, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  
  return "div";
  }

function program3(depth0,data) {
  
  
  return "class";
  }

function program5(depth0,data) {
  
  
  return "sidebar-toggle";
  }

function program7(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1;
  appendChild(buffer, document.createTextNode("\n  "));
  stack1 = element1 = createElement(partial(self.program(8, program8, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(3, program3, data), depth0), partial(self.program(10, program10, data), depth0));
  appendChild(element1, self.program(12, program12, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n"));
  return buffer;
  }
function program8(depth0,data) {
  
  
  return "i";
  }

function program10(depth0,data) {
  
  
  return "icon";
  }

function program12(depth0,data) {
  
  var buffer = document.createDocumentFragment();
  return buffer;
  }

function program14(depth0,data) {
  
  
  return "sidebar-content";
  }

function program16(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1, element2;
  appendChild(buffer, document.createTextNode("\n  "));
  stack1 = element1 = createElement(partial(self.program(1, program1, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(3, program3, data), depth0), partial(self.program(17, program17, data), depth0));
  appendChild(element1, self.program(19, program19, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n\n  "));
  stack1 = element2 = createElement(partial(self.program(1, program1, data), depth0), function (el) { element2 = el; });
  setAttribute(function () { return element2; }, partial(self.program(3, program3, data), depth0), partial(self.program(51, program51, data), depth0));
  appendChild(element2, self.program(53, program53, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n"));
  return buffer;
  }
function program17(depth0,data) {
  
  
  return "sidebar-user";
  }

function program19(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, stack2, element1;
  appendChild(buffer, document.createTextNode("\n    "));
  stack1 = function () {
  stack2 = helpers['if'].call(depth0, ((stack1 = (data == null || data === false ? data : get(data, "persistence", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "userId", "stack1")), {hash:{},inverse:wrapProgram(self.noop),fn:wrapProgram(self.program(20, program20, data)),data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription});
  return stack2;
  };
  appendChild(buffer, createDOM(stack1));
  appendChild(buffer, document.createTextNode("\n    "));
  stack1 = element1 = createElement(partial(self.program(1, program1, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(3, program3, data), depth0), partial(self.program(23, program23, data), depth0));
  setAttribute(function () { return element1; }, partial(self.program(25, program25, data), depth0), partial(self.program(27, program27, data), depth0));
  appendChild(element1, self.program(29, program29, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n  "));
  return buffer;
  }
function program20(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1;
  appendChild(buffer, document.createTextNode("\n      "));
  stack1 = element1 = createElement(partial(self.program(8, program8, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(3, program3, data), depth0), partial(self.program(21, program21, data), depth0));
  appendChild(element1, self.program(12, program12, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n    "));
  return buffer;
  }
function program21(depth0,data) {
  
  
  return "sidebar-user-icon icon-folder-open-empty";
  }

function program23(depth0,data) {
  
  
  return "sidebar-user-title";
  }

function program25(depth0,data) {
  
  
  return "title";
  }

function program27(depth0,data) {
  
  var stack1;
  return escapeExpression(((stack1 = ((stack1 = (data == null || data === false ? data : get(data, "persistence", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "userTitle", "stack1"))),typeof stack1 === functionType ? stack1.apply(depth0) : stack1));
  }

function program29(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, stack2, element1;
  appendChild(buffer, document.createTextNode("\n      "));
  stack1 = function () {
  stack2 = helpers['if'].call(depth0, ((stack1 = (data == null || data === false ? data : get(data, "persistence", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "userId", "stack1")), {hash:{},inverse:wrapProgram(self.program(32, program32, data)),fn:wrapProgram(self.program(30, program30, data)),data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription});
  return stack2;
  };
  appendChild(buffer, createDOM(stack1));
  appendChild(buffer, document.createTextNode("\n\n      "));
  stack1 = element1 = createElement(partial(self.program(34, program34, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(3, program3, data), depth0), partial(self.program(36, program36, data), depth0));
  appendChild(element1, self.program(39, program39, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n    "));
  return buffer;
  }
function program30(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, stack2;
  appendChild(buffer, document.createTextNode("\n        "));
  stack1 = function () {
  stack2 = ((stack1 = ((stack1 = (data == null || data === false ? data : get(data, "persistence", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "userTitle", "stack1"))),typeof stack1 === functionType ? stack1.apply(depth0) : stack1);
  return stack2;
  };
  appendChild(buffer, createText(stack1));
  appendChild(buffer, document.createTextNode("\n      "));
  return buffer;
  }

function program32(depth0,data) {
  
  
  return document.createTextNode("\n        Unauthenticated\n      ");
  }

function program34(depth0,data) {
  
  
  return "p";
  }

function program36(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "sidebar-authenticate text-small persistence-";
  stack1 = helpers['if'].call(depth0, ((stack1 = (data == null || data === false ? data : get(data, "persistence", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "userId", "stack1")), {hash:{},inverse:wrapProgram(self.noop),fn:wrapProgram(self.program(37, program37, data)),data:data,attribute:true,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription});
  buffer += stack1
    + "authenticate";
  return buffer;
  }
function program37(depth0,data) {
  
  
  return "un";
  }

function program39(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1;
  appendChild(buffer, document.createTextNode("\n        "));
  stack1 = element1 = createElement(partial(self.program(40, program40, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(42, program42, data), depth0), partial(self.program(44, program44, data), depth0));
  appendChild(element1, self.program(46, program46, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n      "));
  return buffer;
  }
function program40(depth0,data) {
  
  
  return "a";
  }

function program42(depth0,data) {
  
  
  return "href";
  }

function program44(depth0,data) {
  
  
  return "#";
  }

function program46(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, stack2;
  appendChild(buffer, document.createTextNode("\n          "));
  stack1 = function () {
  stack2 = helpers['if'].call(depth0, ((stack1 = (data == null || data === false ? data : get(data, "persistence", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "userId", "stack1")), {hash:{},inverse:wrapProgram(self.program(49, program49, data)),fn:wrapProgram(self.program(47, program47, data)),data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription});
  return stack2;
  };
  appendChild(buffer, createDOM(stack1));
  appendChild(buffer, document.createTextNode("\n        "));
  return buffer;
  }
function program47(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, stack2;
  appendChild(buffer, document.createTextNode("\n            "));
  stack1 = function () {
  stack2 = ((stack1 = ((stack1 = (data == null || data === false ? data : get(data, "config", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "unauthenticateText", "stack1"))),typeof stack1 === functionType ? stack1.apply(depth0) : stack1);
  return stack2;
  };
  appendChild(buffer, createText(stack1));
  appendChild(buffer, document.createTextNode("\n          "));
  return buffer;
  }

function program49(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, stack2;
  appendChild(buffer, document.createTextNode("\n            "));
  stack1 = function () {
  stack2 = ((stack1 = ((stack1 = (data == null || data === false ? data : get(data, "config", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "authenticateText", "stack1"))),typeof stack1 === functionType ? stack1.apply(depth0) : stack1);
  return stack2;
  };
  appendChild(buffer, createText(stack1));
  appendChild(buffer, document.createTextNode("\n          "));
  return buffer;
  }

function program51(depth0,data) {
  
  
  return "sidebar-list";
  }

function program53(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, stack2, element1;
  appendChild(buffer, document.createTextNode("\n    "));
  appendChild(buffer, document.createTextNode("\n    "));
  stack1 = element1 = createElement(partial(self.program(1, program1, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(3, program3, data), depth0), partial(self.program(54, program54, data), depth0));
  appendChild(element1, self.program(57, program57, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n\n    "));
  stack1 = function () {
  stack2 = helpers['if'].call(depth0, ((stack1 = (data == null || data === false ? data : get(data, "data", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "updating", "stack1")), {hash:{},inverse:wrapProgram(self.program(90, program90, data)),fn:wrapProgram(self.program(84, program84, data)),data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription});
  return stack2;
  };
  appendChild(buffer, createDOM(stack1));
  appendChild(buffer, document.createTextNode("\n  "));
  return buffer;
  }
function program54(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "list-item item item-active ";
  stack1 = helpers.unless.call(depth0, ((stack1 = (data == null || data === false ? data : get(data, "data", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "saved", "stack1")), {hash:{},inverse:wrapProgram(self.noop),fn:wrapProgram(self.program(55, program55, data)),data:data,attribute:true,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription});
  buffer += stack1;
  return buffer;
  }
function program55(depth0,data) {
  
  
  return "item-unsaved";
  }

function program57(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, stack2;
  appendChild(buffer, document.createTextNode("\n    "));
  stack1 = function () {
  stack2 = helpers['with'].call(depth0, ((stack1 = (data == null || data === false ? data : get(data, "persistence", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "notebook", "stack1")), {hash:{},inverse:wrapProgram(self.noop),fn:wrapProgram(self.program(58, program58, data)),data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription});
  return stack2;
  };
  appendChild(buffer, createDOM(stack1));
  appendChild(buffer, document.createTextNode("\n    "));
  return buffer;
  }
function program58(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, stack2, element1;
  appendChild(buffer, document.createTextNode("\n      "));
  stack1 = function () {
  stack2 = helpers['if'].call(depth0, get(depth0, "id", "depth0"), {hash:{},inverse:wrapProgram(self.noop),fn:wrapProgram(self.program(59, program59, data)),data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription});
  return stack2;
  };
  appendChild(buffer, createDOM(stack1));
  appendChild(buffer, document.createTextNode("\n\n      "));
  stack1 = element1 = createElement(partial(self.program(1, program1, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(3, program3, data), depth0), partial(self.program(67, program67, data), depth0));
  appendChild(element1, self.program(69, program69, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n    "));
  return buffer;
  }
function program59(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, stack2, helper, options;
  appendChild(buffer, document.createTextNode("\n        "));
  stack1 = function () {
  stack2 = (helper = helpers.equal || get(depth0, "equal", "depth0"),options={hash:{},inverse:wrapProgram(self.noop),fn:wrapProgram(self.program(60, program60, data)),data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription},helper ? helper.call(depth0, ((stack1 = (data == null || data === false ? data : get(data, "persistence", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "userId", "stack1")), get(depth0, "ownerId", "depth0"), options) : helperMissing.call(depth0, "equal", ((stack1 = (data == null || data === false ? data : get(data, "persistence", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "userId", "stack1")), get(depth0, "ownerId", "depth0"), options));
  return stack2;
  };
  appendChild(buffer, createDOM(stack1));
  appendChild(buffer, document.createTextNode("\n      "));
  return buffer;
  }
function program60(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1;
  appendChild(buffer, document.createTextNode("\n          "));
  stack1 = element1 = createElement(partial(self.program(8, program8, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(3, program3, data), depth0), partial(self.program(61, program61, data), depth0));
  setAttribute(function () { return element1; }, partial(self.program(63, program63, data), depth0), partial(self.program(65, program65, data), depth0));
  appendChild(element1, self.program(12, program12, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n        "));
  return buffer;
  }
function program61(depth0,data) {
  
  
  return "icon-cancel-circled";
  }

function program63(depth0,data) {
  
  
  return "data-delete";
  }

function program65(depth0,data) {
  
  var stack1, helper;
  if (helper = helpers.id) { stack1 = helper.call(depth0, {hash:{},data:data,attribute:true,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription}); }
  else { helper = get(depth0, "id", "depth0"); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data,attribute:true,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription}) : helper; }
  return escapeExpression(stack1);
  }

function program67(depth0,data) {
  
  
  return "item-description";
  }

function program69(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1, element2;
  appendChild(buffer, document.createTextNode("\n        "));
  stack1 = element1 = createElement(partial(self.program(1, program1, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(3, program3, data), depth0), partial(self.program(70, program70, data), depth0));
  appendChild(element1, self.program(72, program72, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n\n        "));
  stack1 = element2 = createElement(partial(self.program(1, program1, data), depth0), function (el) { element2 = el; });
  setAttribute(function () { return element2; }, partial(self.program(3, program3, data), depth0), partial(self.program(77, program77, data), depth0));
  appendChild(element2, self.program(79, program79, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n      "));
  return buffer;
  }
function program70(depth0,data) {
  
  
  return "item-title";
  }

function program72(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, stack2;
  appendChild(buffer, document.createTextNode("\n          "));
  stack1 = function () {
  stack2 = helpers['if'].call(depth0, ((stack1 = get(depth0, "meta", "depth0")),stack1 == null || stack1 === false ? stack1 : get(stack1, "title", "stack1")), {hash:{},inverse:wrapProgram(self.program(75, program75, data)),fn:wrapProgram(self.program(73, program73, data)),data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription});
  return stack2;
  };
  appendChild(buffer, createDOM(stack1));
  appendChild(buffer, document.createTextNode("\n        "));
  return buffer;
  }
function program73(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, stack2;
  appendChild(buffer, document.createTextNode("\n            "));
  stack1 = function () {
  stack2 = ((stack1 = ((stack1 = get(depth0, "meta", "depth0")),stack1 == null || stack1 === false ? stack1 : get(stack1, "title", "stack1"))),typeof stack1 === functionType ? stack1.apply(depth0) : stack1);
  return stack2;
  };
  appendChild(buffer, createText(stack1));
  appendChild(buffer, document.createTextNode("\n          "));
  return buffer;
  }

function program75(depth0,data) {
  
  var buffer = document.createDocumentFragment();
  appendChild(buffer, document.createTextNode("\n            "));
  appendChild(buffer, document.createTextNode(""));
  appendChild(buffer, document.createTextNode("\n          "));
  return buffer;
  }

function program77(depth0,data) {
  
  
  return "item-timestamp";
  }

function program79(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, stack2;
  appendChild(buffer, document.createTextNode("\n          "));
  stack1 = function () {
  stack2 = helpers['if'].call(depth0, get(depth0, "updatedAt", "depth0"), {hash:{},inverse:wrapProgram(self.program(82, program82, data)),fn:wrapProgram(self.program(80, program80, data)),data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription});
  return stack2;
  };
  appendChild(buffer, createDOM(stack1));
  appendChild(buffer, document.createTextNode("\n        "));
  return buffer;
  }
function program80(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, stack2, helper, options;
  appendChild(buffer, document.createTextNode("\n            "));
  stack1 = function () {
  stack2 = (helper = helpers.dateFormat || get(depth0, "dateFormat", "depth0"),options={hash:{},data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription},helper ? helper.call(depth0, get(depth0, "updatedAt", "depth0"), options) : helperMissing.call(depth0, "dateFormat", get(depth0, "updatedAt", "depth0"), options));
  return stack2;
  };
  appendChild(buffer, createText(stack1));
  appendChild(buffer, document.createTextNode("\n          "));
  return buffer;
  }

function program82(depth0,data) {
  
  
  return document.createTextNode("\n            Unsaved\n          ");
  }

function program84(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1;
  appendChild(buffer, document.createTextNode("\n      "));
  stack1 = element1 = createElement(partial(self.program(1, program1, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(3, program3, data), depth0), partial(self.program(85, program85, data), depth0));
  appendChild(element1, self.program(87, program87, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n    "));
  return buffer;
  }
function program85(depth0,data) {
  
  
  return "list-item sidebar-updating text-center";
  }

function program87(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1;
  appendChild(buffer, document.createTextNode("\n        "));
  stack1 = element1 = createElement(partial(self.program(8, program8, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(3, program3, data), depth0), partial(self.program(88, program88, data), depth0));
  appendChild(element1, self.program(12, program12, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n      "));
  return buffer;
  }
function program88(depth0,data) {
  
  
  return "icon-arrows-cw animate-spin";
  }

function program90(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, stack2, helper, options;
  appendChild(buffer, document.createTextNode("\n      "));
  stack1 = function () {
  stack2 = (helper = helpers.collection || get(depth0, "collection", "depth0"),options={hash:{},inverse:wrapProgram(self.noop),fn:wrapProgram(self.program(91, program91, data)),data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription},helper ? helper.call(depth0, ((stack1 = (data == null || data === false ? data : get(data, "persistence", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "items", "stack1")), options) : helperMissing.call(depth0, "collection", ((stack1 = (data == null || data === false ? data : get(data, "persistence", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "items", "stack1")), options));
  return stack2;
  };
  appendChild(buffer, createDOM(stack1));
  appendChild(buffer, document.createTextNode("\n    "));
  return buffer;
  }
function program91(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1;
  appendChild(buffer, document.createTextNode("\n        "));
  stack1 = element1 = createElement(partial(self.program(1, program1, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(3, program3, data), depth0), partial(self.program(92, program92, data), depth0));
  setAttribute(function () { return element1; }, partial(self.program(95, program95, data), depth0), partial(self.program(65, program65, data), depth0));
  appendChild(element1, self.program(97, program97, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n      "));
  return buffer;
  }
function program92(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "list-item item ";
  stack1 = (helper = helpers.equal || get(depth0, "equal", "depth0"),options={hash:{},inverse:wrapProgram(self.noop),fn:wrapProgram(self.program(93, program93, data)),data:data,attribute:true,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription},helper ? helper.call(depth0, get(depth0, "id", "depth0"), ((stack1 = ((stack1 = (data == null || data === false ? data : get(data, "persistence", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "notebook", "stack1"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "id", "stack1")), options) : helperMissing.call(depth0, "equal", get(depth0, "id", "depth0"), ((stack1 = ((stack1 = (data == null || data === false ? data : get(data, "persistence", "data"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "notebook", "stack1"))),stack1 == null || stack1 === false ? stack1 : get(stack1, "id", "stack1")), options));
  buffer += stack1;
  return buffer;
  }
function program93(depth0,data) {
  
  
  return "item-hidden";
  }

function program95(depth0,data) {
  
  
  return "data-load";
  }

function program97(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1, element2;
  appendChild(buffer, document.createTextNode("\n          "));
  stack1 = element1 = createElement(partial(self.program(8, program8, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(3, program3, data), depth0), partial(self.program(61, program61, data), depth0));
  setAttribute(function () { return element1; }, partial(self.program(63, program63, data), depth0), partial(self.program(65, program65, data), depth0));
  appendChild(element1, self.program(12, program12, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n\n          "));
  stack1 = element2 = createElement(partial(self.program(1, program1, data), depth0), function (el) { element2 = el; });
  setAttribute(function () { return element2; }, partial(self.program(3, program3, data), depth0), partial(self.program(67, program67, data), depth0));
  appendChild(element2, self.program(98, program98, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n        "));
  return buffer;
  }
function program98(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, stack2, element1;
  appendChild(buffer, document.createTextNode("\n            "));
  stack1 = element1 = createElement(partial(self.program(1, program1, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(3, program3, data), depth0), partial(self.program(70, program70, data), depth0));
  appendChild(element1, self.program(99, program99, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n\n            "));
  stack1 = function () {
  stack2 = helpers['if'].call(depth0, get(depth0, "updatedAt", "depth0"), {hash:{},inverse:wrapProgram(self.noop),fn:wrapProgram(self.program(104, program104, data)),data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription});
  return stack2;
  };
  appendChild(buffer, createDOM(stack1));
  appendChild(buffer, document.createTextNode("\n          "));
  return buffer;
  }
function program99(depth0,data) {
  
  var stack1, stack2;
  stack1 = function () {
  stack2 = helpers['if'].call(depth0, ((stack1 = get(depth0, "meta", "depth0")),stack1 == null || stack1 === false ? stack1 : get(stack1, "title", "stack1")), {hash:{},inverse:wrapProgram(self.program(102, program102, data)),fn:wrapProgram(self.program(100, program100, data)),data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription});
  return stack2;
  };
  return createDOM(stack1);
  }
function program100(depth0,data) {
  
  var stack1, stack2;
  stack1 = function () {
  stack2 = ((stack1 = ((stack1 = get(depth0, "meta", "depth0")),stack1 == null || stack1 === false ? stack1 : get(stack1, "title", "stack1"))),typeof stack1 === functionType ? stack1.apply(depth0) : stack1);
  return stack2;
  };
  return createText(stack1);
  }

function program102(depth0,data) {
  
  var stack1, stack2, helper;
  stack1 = function () {
  if (helper = helpers.id) { stack2 = helper.call(depth0, {hash:{},data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription}); }
  else { helper = get(depth0, "id", "depth0"); stack2 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription}) : helper; }
  return stack2;
  };
  return createText(stack1);
  }

function program104(depth0,data) {
  
  var buffer = document.createDocumentFragment(), stack1, element1;
  appendChild(buffer, document.createTextNode("\n              "));
  stack1 = element1 = createElement(partial(self.program(1, program1, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(3, program3, data), depth0), partial(self.program(77, program77, data), depth0));
  appendChild(element1, self.program(105, program105, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n            "));
  return buffer;
  }
function program105(depth0,data) {
  
  var stack1, stack2, helper, options;
  stack1 = function () {
  stack2 = (helper = helpers.dateFormat || get(depth0, "dateFormat", "depth0"),options={hash:{},data:data,attribute:false,update:self.subscription.boundUpdate,unsubscribe:self.subscription.boundUnsubscription},helper ? helper.call(depth0, get(depth0, "updatedAt", "depth0"), options) : helperMissing.call(depth0, "dateFormat", get(depth0, "updatedAt", "depth0"), options));
  return stack2;
  };
  return createText(stack1);
  }

  stack1 = element1 = createElement(partial(self.program(1, program1, data), depth0), function (el) { element1 = el; });
  setAttribute(function () { return element1; }, partial(self.program(3, program3, data), depth0), partial(self.program(5, program5, data), depth0));
  appendChild(element1, self.program(7, program7, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n\n"));
  stack1 = element2 = createElement(partial(self.program(1, program1, data), depth0), function (el) { element2 = el; });
  setAttribute(function () { return element2; }, partial(self.program(3, program3, data), depth0), partial(self.program(14, program14, data), depth0));
  appendChild(element2, self.program(16, program16, data)(depth0));
  appendChild(buffer, stack1);
  appendChild(buffer, document.createTextNode("\n"));
  return buffer;
  });
},{"dombars/runtime":42}]},{},[68])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9hc3luYy9saWIvYXN5bmMuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9iYWNrYm9uZS5uYXRpdmUvYmFja2JvbmUubmF0aXZlLmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvYmFja2JvbmUvYmFja2JvbmUuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9oZWxwZXJzLmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvaW5kZXguanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9tZDUuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ybmcuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9zaGEuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9zaGEyNTYuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pbnNlcnQtbW9kdWxlLWdsb2JhbHMvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL25hdGl2ZS1idWZmZXItYnJvd3NlcmlmeS9pbmRleC5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL25hdGl2ZS1idWZmZXItYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2xpYi9iNjQuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9uYXRpdmUtYnVmZmVyLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nL2RlY29kZS5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nL2VuY29kZS5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nL2luZGV4LmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXJsL3VybC5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL2NoYW5nZS1jYXNlL2NoYW5nZS1jYXNlLmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9hZGRvbi9jb21tZW50L2NvbW1lbnQuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL2FkZG9uL21vZGUvb3ZlcmxheS5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbGliL2NvZGVtaXJyb3IuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvY2xpa2UvY2xpa2UuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvY3NzL2Nzcy5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS9nZm0vZ2ZtLmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL2h0bWxtaXhlZC9odG1sbWl4ZWQuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvamF2YXNjcmlwdC9qYXZhc2NyaXB0LmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL21hcmtkb3duL21hcmtkb3duLmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL3htbC94bWwuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9kb21iYXJzL2xpYi9iYXNlLmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvZG9tYmFycy9saWIvZXhjZXB0aW9uLmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvZG9tYmFycy9saWIvcmFmLmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvZG9tYmFycy9saWIvcnVudGltZS5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL2RvbWJhcnMvbGliL3NhZmUtc3RyaW5nLmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvZG9tYmFycy9saWIvdHJhY2stbm9kZS5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL2RvbWJhcnMvbGliL3V0aWxzLmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvZG9tYmFycy9ub2RlX21vZHVsZXMvaGFuZGxlYmFycy9kaXN0L2Nqcy9oYW5kbGViYXJzL2Jhc2UuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9kb21iYXJzL25vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2Rpc3QvY2pzL2hhbmRsZWJhcnMvZXhjZXB0aW9uLmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvZG9tYmFycy9ub2RlX21vZHVsZXMvaGFuZGxlYmFycy9kaXN0L2Nqcy9oYW5kbGViYXJzL3J1bnRpbWUuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9kb21iYXJzL25vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2Rpc3QvY2pzL2hhbmRsZWJhcnMvc2FmZS1zdHJpbmcuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9kb21iYXJzL25vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2Rpc3QvY2pzL2hhbmRsZWJhcnMvdXRpbHMuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9kb21iYXJzL3J1bnRpbWUuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9kb21pZnkvaW5kZXguanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9lczYtY29sbGVjdGlvbnMvc3JjL2VzNi1jb2xsZWN0aW9ucy5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL2thbWluby9saWIva2FtaW5vLmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvbWFya2VkL2xpYi9tYXJrZWQuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9xcy9pbmRleC5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL3N0b3JlL3N0b3JlLmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS91bmRlcnNjb3JlLmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9wdWJsaWMvc2NyaXB0cy9ib290c3RyYXAvZG9tL2luZGV4LmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9wdWJsaWMvc2NyaXB0cy9ib290c3RyYXAvZG9tL292ZXJmbG93LXNjcm9sbC5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svcHVibGljL3NjcmlwdHMvYm9vdHN0cmFwL2luZGV4LmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9wdWJsaWMvc2NyaXB0cy9ib290c3RyYXAvcGx1Z2lucy9hamF4LmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9wdWJsaWMvc2NyaXB0cy9ib290c3RyYXAvcGx1Z2lucy9hcHBsaWNhdGlvbi5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svcHVibGljL3NjcmlwdHMvYm9vdHN0cmFwL3BsdWdpbnMvYXV0aGVudGljYXRpb24vYmFzaWMuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL3B1YmxpYy9zY3JpcHRzL2Jvb3RzdHJhcC9wbHVnaW5zL2F1dGhlbnRpY2F0aW9uL2luZGV4LmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9wdWJsaWMvc2NyaXB0cy9ib290c3RyYXAvcGx1Z2lucy9hdXRoZW50aWNhdGlvbi9saWIvYXV0aC13aW5kb3cuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL3B1YmxpYy9zY3JpcHRzL2Jvb3RzdHJhcC9wbHVnaW5zL2F1dGhlbnRpY2F0aW9uL29hdXRoMS5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svcHVibGljL3NjcmlwdHMvYm9vdHN0cmFwL3BsdWdpbnMvYXV0aGVudGljYXRpb24vb2F1dGgyLmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9wdWJsaWMvc2NyaXB0cy9ib290c3RyYXAvcGx1Z2lucy9jb21wbGV0aW9uLmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9wdWJsaWMvc2NyaXB0cy9ib290c3RyYXAvcGx1Z2lucy9pbmRleC5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svcHVibGljL3NjcmlwdHMvYm9vdHN0cmFwL3BsdWdpbnMvcGVyc2lzdGVuY2UuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL3B1YmxpYy9zY3JpcHRzL2Jvb3RzdHJhcC9wbHVnaW5zL3Jlc3VsdC1jZWxsLmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9wdWJsaWMvc2NyaXB0cy9ib290c3RyYXAvcGx1Z2lucy9zYW5kYm94LmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9wdWJsaWMvc2NyaXB0cy9ib290c3RyYXAvcGx1Z2lucy91aS5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svcHVibGljL3NjcmlwdHMvY29sbGVjdGlvbnMvY2VsbHMuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL3B1YmxpYy9zY3JpcHRzL2NvbGxlY3Rpb25zL3BlcnNpc3RlbmNlLWl0ZW1zLmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9wdWJsaWMvc2NyaXB0cy9pbmRleC5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svcHVibGljL3NjcmlwdHMvbGliL2JvdW5jZS5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svcHVibGljL3NjcmlwdHMvbGliL2Jyb3dzZXIvYWJvdXQuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL3B1YmxpYy9zY3JpcHRzL2xpYi9icm93c2VyL2luc2VydC1hZnRlci5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svcHVibGljL3NjcmlwdHMvbGliL2Jyb3dzZXIvbG9hZC1zY3JpcHQuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL3B1YmxpYy9zY3JpcHRzL2xpYi9jb2RlbWlycm9yL2NvcnJlY3QtdG9rZW4uanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL3B1YmxpYy9zY3JpcHRzL2xpYi9jb2RlbWlycm9yL2dldC10b2tlbi5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svcHVibGljL3NjcmlwdHMvbGliL2NvZGVtaXJyb3IvaXMtaW4tc2NvcGUuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL3B1YmxpYy9zY3JpcHRzL2xpYi9jb2RlbWlycm9yL3NhbmRib3gtYXJndW1lbnRzLmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9wdWJsaWMvc2NyaXB0cy9saWIvY29kZW1pcnJvci9zYW5kYm94LWNvbXBsZXRpb24uanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL3B1YmxpYy9zY3JpcHRzL2xpYi9jb2RlbWlycm9yL3Rva2VuLWhlbHBlcnMuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL3B1YmxpYy9zY3JpcHRzL2xpYi9jb2RlbWlycm9yL3ZhcnMtaGFzLXZhbHVlLmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9wdWJsaWMvc2NyaXB0cy9saWIvY29tcGxldGlvbi9hcmd1bWVudC1kb2N1bWVudGF0aW9uLmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9wdWJsaWMvc2NyaXB0cy9saWIvY29tcGxldGlvbi9mb3JtYXQtZG9jdW1lbnRhdGlvbi5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svcHVibGljL3NjcmlwdHMvbGliL2NvbXBsZXRpb24vZ2hvc3QuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL3B1YmxpYy9zY3JpcHRzL2xpYi9jb21wbGV0aW9uL2hpbnQtZG9jdW1lbnRhdGlvbi5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svcHVibGljL3NjcmlwdHMvbGliL2NvbXBsZXRpb24vaGludHMuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL3B1YmxpYy9zY3JpcHRzL2xpYi9jb21wbGV0aW9uL2luZGV4LmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9wdWJsaWMvc2NyaXB0cy9saWIvY29tcGxldGlvbi93aWRnZXQuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL3B1YmxpYy9zY3JpcHRzL2xpYi9jb250cm9scy5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svcHVibGljL3NjcmlwdHMvbGliL2RvbS1saXN0ZW4uanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL3B1YmxpYy9zY3JpcHRzL2xpYi9kb21iYXJzL2hlbHBlcnMvY29sbGVjdGlvbi5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svcHVibGljL3NjcmlwdHMvbGliL2RvbWJhcnMvaGVscGVycy9lcXVhbC5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svcHVibGljL3NjcmlwdHMvbGliL2RvbWJhcnMvaGVscGVycy9pZi5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svcHVibGljL3NjcmlwdHMvbGliL2RvbWJhcnMvaGVscGVycy92aWV3LmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9wdWJsaWMvc2NyaXB0cy9saWIvZG9tYmFycy9pbmRleC5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svcHVibGljL3NjcmlwdHMvbGliL2Zyb20tcGF0aC5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svcHVibGljL3NjcmlwdHMvbGliL25vdGlmeS1lcnJvci5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svcHVibGljL3NjcmlwdHMvbGliL3Bvc3QtbWVzc2FnZS5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svcHVibGljL3NjcmlwdHMvbGliL3NhbmRib3gtY29tcGxldGlvbi9icm93c2VyLmpzb24iLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL3B1YmxpYy9zY3JpcHRzL2xpYi9zYW5kYm94LWNvbXBsZXRpb24vZWNtYTUuanNvbiIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svcHVibGljL3NjcmlwdHMvbGliL3NhbmRib3gtY29tcGxldGlvbi9pbmRleC5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svcHVibGljL3NjcmlwdHMvbGliL3NhbmRib3guanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL3B1YmxpYy9zY3JpcHRzL2xpYi9zdHJpbmdpZnkuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL3B1YmxpYy9zY3JpcHRzL2xpYi90eXBlLmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9wdWJsaWMvc2NyaXB0cy9tb2RlbHMvY2VsbC5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svcHVibGljL3NjcmlwdHMvbW9kZWxzL21ldGEuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL3B1YmxpYy9zY3JpcHRzL21vZGVscy9ub3RlYm9vay5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svcHVibGljL3NjcmlwdHMvbW9kZWxzL3BlcnNpc3RlbmNlLWl0ZW0uanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL3B1YmxpYy9zY3JpcHRzL3N0YXRlL2NvbmZpZy5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svcHVibGljL3NjcmlwdHMvc3RhdGUvbWVzc2FnZXMuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL3B1YmxpYy9zY3JpcHRzL3N0YXRlL21pZGRsZXdhcmUuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL3B1YmxpYy9zY3JpcHRzL3N0YXRlL3BlcnNpc3RlbmNlLmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9wdWJsaWMvc2NyaXB0cy9zdGF0ZS9zdGF0ZS5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svcHVibGljL3NjcmlwdHMvc3RhdGUvc3RvcmUuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL3B1YmxpYy9zY3JpcHRzL3ZpZXdzL2FwcC5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svcHVibGljL3NjcmlwdHMvdmlld3MvY2VsbC1idXR0b25zLmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9wdWJsaWMvc2NyaXB0cy92aWV3cy9jZWxsLWNvbnRyb2xzLmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9wdWJsaWMvc2NyaXB0cy92aWV3cy9jb2RlLWNlbGwuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL3B1YmxpYy9zY3JpcHRzL3ZpZXdzL2VkaXQtbm90ZWJvb2suanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL3B1YmxpYy9zY3JpcHRzL3ZpZXdzL2VkaXRvci1jZWxsLmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9wdWJsaWMvc2NyaXB0cy92aWV3cy9lcnJvci1pbnNwZWN0b3IuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL3B1YmxpYy9zY3JpcHRzL3ZpZXdzL2luc3BlY3Rvci5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svcHVibGljL3NjcmlwdHMvdmlld3MvbGliL2VtYmVkLXByb3RlY3QuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL3B1YmxpYy9zY3JpcHRzL3ZpZXdzL2xpYi9leHRyYS1rZXlzLmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9wdWJsaWMvc2NyaXB0cy92aWV3cy9ub3RlYm9vay5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svcHVibGljL3NjcmlwdHMvdmlld3MvcmVzdWx0LWNlbGwuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL3B1YmxpYy9zY3JpcHRzL3ZpZXdzL3NpZGViYXIuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL3B1YmxpYy9zY3JpcHRzL3ZpZXdzL3RlbXBsYXRlLmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9wdWJsaWMvc2NyaXB0cy92aWV3cy90ZXh0LWNlbGwuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL3B1YmxpYy9zY3JpcHRzL3ZpZXdzL3ZpZXcuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL3B1YmxpYy90ZW1wbGF0ZXMvdmlld3MvYXBwLmhicyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svcHVibGljL3RlbXBsYXRlcy92aWV3cy9jZWxsLWJ1dHRvbnMuaGJzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9wdWJsaWMvdGVtcGxhdGVzL3ZpZXdzL2NlbGwtY29udHJvbHMuaGJzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9wdWJsaWMvdGVtcGxhdGVzL3ZpZXdzL2NvZGUtY2VsbC5oYnMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL3B1YmxpYy90ZW1wbGF0ZXMvdmlld3MvZWRpdG9yLWNlbGwuaGJzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9wdWJsaWMvdGVtcGxhdGVzL3ZpZXdzL3Jlc3VsdC1jZWxsLmhicyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svcHVibGljL3RlbXBsYXRlcy92aWV3cy9zaWRlYmFyLmhicyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzc3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3aURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hpQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3ZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2bkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3QyT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5c0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNscEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUlBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3prQkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3J0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2wxQ0E7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL2dCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4MkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0N0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNob0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeldBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDam1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzc3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKmdsb2JhbCBzZXRJbW1lZGlhdGU6IGZhbHNlLCBzZXRUaW1lb3V0OiBmYWxzZSwgY29uc29sZTogZmFsc2UgKi9cbihmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgYXN5bmMgPSB7fTtcblxuICAgIC8vIGdsb2JhbCBvbiB0aGUgc2VydmVyLCB3aW5kb3cgaW4gdGhlIGJyb3dzZXJcbiAgICB2YXIgcm9vdCwgcHJldmlvdXNfYXN5bmM7XG5cbiAgICByb290ID0gdGhpcztcbiAgICBpZiAocm9vdCAhPSBudWxsKSB7XG4gICAgICBwcmV2aW91c19hc3luYyA9IHJvb3QuYXN5bmM7XG4gICAgfVxuXG4gICAgYXN5bmMubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcm9vdC5hc3luYyA9IHByZXZpb3VzX2FzeW5jO1xuICAgICAgICByZXR1cm4gYXN5bmM7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG9ubHlfb25jZShmbikge1xuICAgICAgICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChjYWxsZWQpIHRocm93IG5ldyBFcnJvcihcIkNhbGxiYWNrIHdhcyBhbHJlYWR5IGNhbGxlZC5cIik7XG4gICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgZm4uYXBwbHkocm9vdCwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vLy8gY3Jvc3MtYnJvd3NlciBjb21wYXRpYmxpdHkgZnVuY3Rpb25zIC8vLy9cblxuICAgIHZhciBfZWFjaCA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yKSB7XG4gICAgICAgIGlmIChhcnIuZm9yRWFjaCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyci5mb3JFYWNoKGl0ZXJhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaXRlcmF0b3IoYXJyW2ldLCBpLCBhcnIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBfbWFwID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IpIHtcbiAgICAgICAgaWYgKGFyci5tYXApIHtcbiAgICAgICAgICAgIHJldHVybiBhcnIubWFwKGl0ZXJhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBfZWFjaChhcnIsIGZ1bmN0aW9uICh4LCBpLCBhKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goaXRlcmF0b3IoeCwgaSwgYSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcblxuICAgIHZhciBfcmVkdWNlID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIG1lbW8pIHtcbiAgICAgICAgaWYgKGFyci5yZWR1Y2UpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnIucmVkdWNlKGl0ZXJhdG9yLCBtZW1vKTtcbiAgICAgICAgfVxuICAgICAgICBfZWFjaChhcnIsIGZ1bmN0aW9uICh4LCBpLCBhKSB7XG4gICAgICAgICAgICBtZW1vID0gaXRlcmF0b3IobWVtbywgeCwgaSwgYSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xuXG4gICAgdmFyIF9rZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH07XG5cbiAgICAvLy8vIGV4cG9ydGVkIGFzeW5jIG1vZHVsZSBmdW5jdGlvbnMgLy8vL1xuXG4gICAgLy8vLyBuZXh0VGljayBpbXBsZW1lbnRhdGlvbiB3aXRoIGJyb3dzZXItY29tcGF0aWJsZSBmYWxsYmFjayAvLy8vXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fCAhKHByb2Nlc3MubmV4dFRpY2spKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBhc3luYy5uZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgIC8vIG5vdCBhIGRpcmVjdCBhbGlhcyBmb3IgSUUxMCBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKGZuKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUgPSBhc3luYy5uZXh0VGljaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFzeW5jLm5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlID0gYXN5bmMubmV4dFRpY2s7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFzeW5jLm5leHRUaWNrID0gcHJvY2Vzcy5uZXh0VGljaztcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUgPSBhc3luYy5uZXh0VGljaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jLmVhY2ggPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgaWYgKCFhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29tcGxldGVkID0gMDtcbiAgICAgICAgX2VhY2goYXJyLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgaXRlcmF0b3IoeCwgb25seV9vbmNlKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZWQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCA+PSBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBhc3luYy5mb3JFYWNoID0gYXN5bmMuZWFjaDtcblxuICAgIGFzeW5jLmVhY2hTZXJpZXMgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgaWYgKCFhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29tcGxldGVkID0gMDtcbiAgICAgICAgdmFyIGl0ZXJhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihhcnJbY29tcGxldGVkXSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZCArPSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGxldGVkID49IGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGl0ZXJhdGUoKTtcbiAgICB9O1xuICAgIGFzeW5jLmZvckVhY2hTZXJpZXMgPSBhc3luYy5lYWNoU2VyaWVzO1xuXG4gICAgYXN5bmMuZWFjaExpbWl0ID0gZnVuY3Rpb24gKGFyciwgbGltaXQsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZm4gPSBfZWFjaExpbWl0KGxpbWl0KTtcbiAgICAgICAgZm4uYXBwbHkobnVsbCwgW2FyciwgaXRlcmF0b3IsIGNhbGxiYWNrXSk7XG4gICAgfTtcbiAgICBhc3luYy5mb3JFYWNoTGltaXQgPSBhc3luYy5lYWNoTGltaXQ7XG5cbiAgICB2YXIgX2VhY2hMaW1pdCA9IGZ1bmN0aW9uIChsaW1pdCkge1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICBpZiAoIWFyci5sZW5ndGggfHwgbGltaXQgPD0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNvbXBsZXRlZCA9IDA7XG4gICAgICAgICAgICB2YXIgc3RhcnRlZCA9IDA7XG4gICAgICAgICAgICB2YXIgcnVubmluZyA9IDA7XG5cbiAgICAgICAgICAgIChmdW5jdGlvbiByZXBsZW5pc2ggKCkge1xuICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQgPj0gYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAocnVubmluZyA8IGxpbWl0ICYmIHN0YXJ0ZWQgPCBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ZWQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgcnVubmluZyArPSAxO1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvcihhcnJbc3RhcnRlZCAtIDFdLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVkICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVubmluZyAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQgPj0gYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGVuaXNoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9O1xuICAgIH07XG5cblxuICAgIHZhciBkb1BhcmFsbGVsID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgW2FzeW5jLmVhY2hdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgZG9QYXJhbGxlbExpbWl0ID0gZnVuY3Rpb24obGltaXQsIGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgW19lYWNoTGltaXQobGltaXQpXS5jb25jYXQoYXJncykpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgdmFyIGRvU2VyaWVzID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgW2FzeW5jLmVhY2hTZXJpZXNdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIH07XG4gICAgfTtcblxuXG4gICAgdmFyIF9hc3luY01hcCA9IGZ1bmN0aW9uIChlYWNoZm4sIGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGFyciA9IF9tYXAoYXJyLCBmdW5jdGlvbiAoeCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHtpbmRleDogaSwgdmFsdWU6IHh9O1xuICAgICAgICB9KTtcbiAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LnZhbHVlLCBmdW5jdGlvbiAoZXJyLCB2KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0c1t4LmluZGV4XSA9IHY7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdHMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGFzeW5jLm1hcCA9IGRvUGFyYWxsZWwoX2FzeW5jTWFwKTtcbiAgICBhc3luYy5tYXBTZXJpZXMgPSBkb1NlcmllcyhfYXN5bmNNYXApO1xuICAgIGFzeW5jLm1hcExpbWl0ID0gZnVuY3Rpb24gKGFyciwgbGltaXQsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gX21hcExpbWl0KGxpbWl0KShhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIHZhciBfbWFwTGltaXQgPSBmdW5jdGlvbihsaW1pdCkge1xuICAgICAgICByZXR1cm4gZG9QYXJhbGxlbExpbWl0KGxpbWl0LCBfYXN5bmNNYXApO1xuICAgIH07XG5cbiAgICAvLyByZWR1Y2Ugb25seSBoYXMgYSBzZXJpZXMgdmVyc2lvbiwgYXMgZG9pbmcgcmVkdWNlIGluIHBhcmFsbGVsIHdvbid0XG4gICAgLy8gd29yayBpbiBtYW55IHNpdHVhdGlvbnMuXG4gICAgYXN5bmMucmVkdWNlID0gZnVuY3Rpb24gKGFyciwgbWVtbywgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGFzeW5jLmVhY2hTZXJpZXMoYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKG1lbW8sIHgsIGZ1bmN0aW9uIChlcnIsIHYpIHtcbiAgICAgICAgICAgICAgICBtZW1vID0gdjtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgbWVtbyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gaW5qZWN0IGFsaWFzXG4gICAgYXN5bmMuaW5qZWN0ID0gYXN5bmMucmVkdWNlO1xuICAgIC8vIGZvbGRsIGFsaWFzXG4gICAgYXN5bmMuZm9sZGwgPSBhc3luYy5yZWR1Y2U7XG5cbiAgICBhc3luYy5yZWR1Y2VSaWdodCA9IGZ1bmN0aW9uIChhcnIsIG1lbW8sIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmV2ZXJzZWQgPSBfbWFwKGFyciwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9KS5yZXZlcnNlKCk7XG4gICAgICAgIGFzeW5jLnJlZHVjZShyZXZlcnNlZCwgbWVtbywgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIC8vIGZvbGRyIGFsaWFzXG4gICAgYXN5bmMuZm9sZHIgPSBhc3luYy5yZWR1Y2VSaWdodDtcblxuICAgIHZhciBfZmlsdGVyID0gZnVuY3Rpb24gKGVhY2hmbiwgYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgYXJyID0gX21hcChhcnIsIGZ1bmN0aW9uICh4LCBpKSB7XG4gICAgICAgICAgICByZXR1cm4ge2luZGV4OiBpLCB2YWx1ZTogeH07XG4gICAgICAgIH0pO1xuICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgudmFsdWUsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKF9tYXAocmVzdWx0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4O1xuICAgICAgICAgICAgfSksIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHgudmFsdWU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYXN5bmMuZmlsdGVyID0gZG9QYXJhbGxlbChfZmlsdGVyKTtcbiAgICBhc3luYy5maWx0ZXJTZXJpZXMgPSBkb1NlcmllcyhfZmlsdGVyKTtcbiAgICAvLyBzZWxlY3QgYWxpYXNcbiAgICBhc3luYy5zZWxlY3QgPSBhc3luYy5maWx0ZXI7XG4gICAgYXN5bmMuc2VsZWN0U2VyaWVzID0gYXN5bmMuZmlsdGVyU2VyaWVzO1xuXG4gICAgdmFyIF9yZWplY3QgPSBmdW5jdGlvbiAoZWFjaGZuLCBhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBhcnIgPSBfbWFwKGFyciwgZnVuY3Rpb24gKHgsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiB7aW5kZXg6IGksIHZhbHVlOiB4fTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IoeC52YWx1ZSwgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKF9tYXAocmVzdWx0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4O1xuICAgICAgICAgICAgfSksIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHgudmFsdWU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYXN5bmMucmVqZWN0ID0gZG9QYXJhbGxlbChfcmVqZWN0KTtcbiAgICBhc3luYy5yZWplY3RTZXJpZXMgPSBkb1NlcmllcyhfcmVqZWN0KTtcblxuICAgIHZhciBfZGV0ZWN0ID0gZnVuY3Rpb24gKGVhY2hmbiwgYXJyLCBpdGVyYXRvciwgbWFpbl9jYWxsYmFjaykge1xuICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2soeCk7XG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIG1haW5fY2FsbGJhY2soKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBhc3luYy5kZXRlY3QgPSBkb1BhcmFsbGVsKF9kZXRlY3QpO1xuICAgIGFzeW5jLmRldGVjdFNlcmllcyA9IGRvU2VyaWVzKF9kZXRlY3QpO1xuXG4gICAgYXN5bmMuc29tZSA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBtYWluX2NhbGxiYWNrKSB7XG4gICAgICAgIGFzeW5jLmVhY2goYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbl9jYWxsYmFjayh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgbWFpbl9jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIG1haW5fY2FsbGJhY2soZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIGFueSBhbGlhc1xuICAgIGFzeW5jLmFueSA9IGFzeW5jLnNvbWU7XG5cbiAgICBhc3luYy5ldmVyeSA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBtYWluX2NhbGxiYWNrKSB7XG4gICAgICAgIGFzeW5jLmVhY2goYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2KSB7XG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2soZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgbWFpbl9jYWxsYmFjayh0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBhbGwgYWxpYXNcbiAgICBhc3luYy5hbGwgPSBhc3luYy5ldmVyeTtcblxuICAgIGFzeW5jLnNvcnRCeSA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBhc3luYy5tYXAoYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIGZ1bmN0aW9uIChlcnIsIGNyaXRlcmlhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwge3ZhbHVlOiB4LCBjcml0ZXJpYTogY3JpdGVyaWF9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVyciwgcmVzdWx0cykge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGZuID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYSwgYiA9IHJpZ2h0LmNyaXRlcmlhO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBfbWFwKHJlc3VsdHMuc29ydChmbiksIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4LnZhbHVlO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGFzeW5jLmF1dG8gPSBmdW5jdGlvbiAodGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgIHZhciBrZXlzID0gX2tleXModGFza3MpO1xuICAgICAgICBpZiAoIWtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0cyA9IHt9O1xuXG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdmFyIGFkZExpc3RlbmVyID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMudW5zaGlmdChmbik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzW2ldID09PSBmbikge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgdGFza0NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX2VhY2gobGlzdGVuZXJzLnNsaWNlKDApLCBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgYWRkTGlzdGVuZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF9rZXlzKHJlc3VsdHMpLmxlbmd0aCA9PT0ga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHRzKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBfZWFjaChrZXlzLCBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSAodGFza3Nba10gaW5zdGFuY2VvZiBGdW5jdGlvbikgPyBbdGFza3Nba11dOiB0YXNrc1trXTtcbiAgICAgICAgICAgIHZhciB0YXNrQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzYWZlUmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBfZWFjaChfa2V5cyhyZXN1bHRzKSwgZnVuY3Rpb24ocmtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2FmZVJlc3VsdHNbcmtleV0gPSByZXN1bHRzW3JrZXldO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc2FmZVJlc3VsdHNba10gPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIHNhZmVSZXN1bHRzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcCBzdWJzZXF1ZW50IGVycm9ycyBoaXR0aW5nIGNhbGxiYWNrIG11bHRpcGxlIHRpbWVzXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2tdID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKHRhc2tDb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciByZXF1aXJlcyA9IHRhc2suc2xpY2UoMCwgTWF0aC5hYnModGFzay5sZW5ndGggLSAxKSkgfHwgW107XG4gICAgICAgICAgICB2YXIgcmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9yZWR1Y2UocmVxdWlyZXMsIGZ1bmN0aW9uIChhLCB4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoYSAmJiByZXN1bHRzLmhhc093blByb3BlcnR5KHgpKTtcbiAgICAgICAgICAgICAgICB9LCB0cnVlKSAmJiAhcmVzdWx0cy5oYXNPd25Qcm9wZXJ0eShrKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocmVhZHkoKSkge1xuICAgICAgICAgICAgICAgIHRhc2tbdGFzay5sZW5ndGggLSAxXSh0YXNrQ2FsbGJhY2ssIHJlc3VsdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVhZHkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFza1t0YXNrLmxlbmd0aCAtIDFdKHRhc2tDYWxsYmFjaywgcmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGFkZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGFzeW5jLndhdGVyZmFsbCA9IGZ1bmN0aW9uICh0YXNrcywgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgaWYgKHRhc2tzLmNvbnN0cnVjdG9yICE9PSBBcnJheSkge1xuICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IHRvIHdhdGVyZmFsbCBtdXN0IGJlIGFuIGFycmF5IG9mIGZ1bmN0aW9ucycpO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGFza3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd3JhcEl0ZXJhdG9yID0gZnVuY3Rpb24gKGl0ZXJhdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2god3JhcEl0ZXJhdG9yKG5leHQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICB3cmFwSXRlcmF0b3IoYXN5bmMuaXRlcmF0b3IodGFza3MpKSgpO1xuICAgIH07XG5cbiAgICB2YXIgX3BhcmFsbGVsID0gZnVuY3Rpb24oZWFjaGZuLCB0YXNrcywgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgaWYgKHRhc2tzLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgICAgICAgZWFjaGZuLm1hcCh0YXNrcywgZnVuY3Rpb24gKGZuLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgICAgICBmbihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChudWxsLCBlcnIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgZWFjaGZuLmVhY2goX2tleXModGFza3MpLCBmdW5jdGlvbiAoaywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0YXNrc1trXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNba10gPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBhc3luYy5wYXJhbGxlbCA9IGZ1bmN0aW9uICh0YXNrcywgY2FsbGJhY2spIHtcbiAgICAgICAgX3BhcmFsbGVsKHsgbWFwOiBhc3luYy5tYXAsIGVhY2g6IGFzeW5jLmVhY2ggfSwgdGFza3MsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMucGFyYWxsZWxMaW1pdCA9IGZ1bmN0aW9uKHRhc2tzLCBsaW1pdCwgY2FsbGJhY2spIHtcbiAgICAgICAgX3BhcmFsbGVsKHsgbWFwOiBfbWFwTGltaXQobGltaXQpLCBlYWNoOiBfZWFjaExpbWl0KGxpbWl0KSB9LCB0YXNrcywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBhc3luYy5zZXJpZXMgPSBmdW5jdGlvbiAodGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgIGlmICh0YXNrcy5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcbiAgICAgICAgICAgIGFzeW5jLm1hcFNlcmllcyh0YXNrcywgZnVuY3Rpb24gKGZuLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgICAgICBmbihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChudWxsLCBlcnIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgYXN5bmMuZWFjaFNlcmllcyhfa2V5cyh0YXNrcyksIGZ1bmN0aW9uIChrLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRhc2tzW2tdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1trXSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGFzeW5jLml0ZXJhdG9yID0gZnVuY3Rpb24gKHRhc2tzKSB7XG4gICAgICAgIHZhciBtYWtlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBmbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFza3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2tzW2luZGV4XS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZm4ubmV4dCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZuLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChpbmRleCA8IHRhc2tzLmxlbmd0aCAtIDEpID8gbWFrZUNhbGxiYWNrKGluZGV4ICsgMSk6IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbWFrZUNhbGxiYWNrKDApO1xuICAgIH07XG5cbiAgICBhc3luYy5hcHBseSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkoXG4gICAgICAgICAgICAgICAgbnVsbCwgYXJncy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBfY29uY2F0ID0gZnVuY3Rpb24gKGVhY2hmbiwgYXJyLCBmbiwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHIgPSBbXTtcbiAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGNiKSB7XG4gICAgICAgICAgICBmbih4LCBmdW5jdGlvbiAoZXJyLCB5KSB7XG4gICAgICAgICAgICAgICAgciA9IHIuY29uY2F0KHkgfHwgW10pO1xuICAgICAgICAgICAgICAgIGNiKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBhc3luYy5jb25jYXQgPSBkb1BhcmFsbGVsKF9jb25jYXQpO1xuICAgIGFzeW5jLmNvbmNhdFNlcmllcyA9IGRvU2VyaWVzKF9jb25jYXQpO1xuXG4gICAgYXN5bmMud2hpbHN0ID0gZnVuY3Rpb24gKHRlc3QsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGVzdCgpKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXN5bmMud2hpbHN0KHRlc3QsIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgYXN5bmMuZG9XaGlsc3QgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIHRlc3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIGl0ZXJhdG9yKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0ZXN0KCkpIHtcbiAgICAgICAgICAgICAgICBhc3luYy5kb1doaWxzdChpdGVyYXRvciwgdGVzdCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGFzeW5jLnVudGlsID0gZnVuY3Rpb24gKHRlc3QsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIXRlc3QoKSkge1xuICAgICAgICAgICAgaXRlcmF0b3IoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFzeW5jLnVudGlsKHRlc3QsIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgYXN5bmMuZG9VbnRpbCA9IGZ1bmN0aW9uIChpdGVyYXRvciwgdGVzdCwgY2FsbGJhY2spIHtcbiAgICAgICAgaXRlcmF0b3IoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0ZXN0KCkpIHtcbiAgICAgICAgICAgICAgICBhc3luYy5kb1VudGlsKGl0ZXJhdG9yLCB0ZXN0LCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgYXN5bmMucXVldWUgPSBmdW5jdGlvbiAod29ya2VyLCBjb25jdXJyZW5jeSkge1xuICAgICAgICBpZiAoY29uY3VycmVuY3kgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uY3VycmVuY3kgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIF9pbnNlcnQocSwgZGF0YSwgcG9zLCBjYWxsYmFjaykge1xuICAgICAgICAgIGlmKGRhdGEuY29uc3RydWN0b3IgIT09IEFycmF5KSB7XG4gICAgICAgICAgICAgIGRhdGEgPSBbZGF0YV07XG4gICAgICAgICAgfVxuICAgICAgICAgIF9lYWNoKGRhdGEsIGZ1bmN0aW9uKHRhc2spIHtcbiAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICBkYXRhOiB0YXNrLFxuICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/IGNhbGxiYWNrIDogbnVsbFxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICAgICAgICBxLnRhc2tzLnVuc2hpZnQoaXRlbSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcS50YXNrcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHEuc2F0dXJhdGVkICYmIHEudGFza3MubGVuZ3RoID09PSBjb25jdXJyZW5jeSkge1xuICAgICAgICAgICAgICAgICAgcS5zYXR1cmF0ZWQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUocS5wcm9jZXNzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3b3JrZXJzID0gMDtcbiAgICAgICAgdmFyIHEgPSB7XG4gICAgICAgICAgICB0YXNrczogW10sXG4gICAgICAgICAgICBjb25jdXJyZW5jeTogY29uY3VycmVuY3ksXG4gICAgICAgICAgICBzYXR1cmF0ZWQ6IG51bGwsXG4gICAgICAgICAgICBlbXB0eTogbnVsbCxcbiAgICAgICAgICAgIGRyYWluOiBudWxsLFxuICAgICAgICAgICAgcHVzaDogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIF9pbnNlcnQocSwgZGF0YSwgZmFsc2UsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bnNoaWZ0OiBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgX2luc2VydChxLCBkYXRhLCB0cnVlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJvY2VzczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh3b3JrZXJzIDwgcS5jb25jdXJyZW5jeSAmJiBxLnRhc2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFzayA9IHEudGFza3Muc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHEuZW1wdHkgJiYgcS50YXNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHEuZW1wdHkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3b3JrZXJzICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2VycyAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhc2suY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXNrLmNhbGxiYWNrLmFwcGx5KHRhc2ssIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocS5kcmFpbiAmJiBxLnRhc2tzLmxlbmd0aCArIHdvcmtlcnMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxLmRyYWluKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBxLnByb2Nlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNiID0gb25seV9vbmNlKG5leHQpO1xuICAgICAgICAgICAgICAgICAgICB3b3JrZXIodGFzay5kYXRhLCBjYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxlbmd0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBxLnRhc2tzLmxlbmd0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBydW5uaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdvcmtlcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBxO1xuICAgIH07XG5cbiAgICBhc3luYy5jYXJnbyA9IGZ1bmN0aW9uICh3b3JrZXIsIHBheWxvYWQpIHtcbiAgICAgICAgdmFyIHdvcmtpbmcgICAgID0gZmFsc2UsXG4gICAgICAgICAgICB0YXNrcyAgICAgICA9IFtdO1xuXG4gICAgICAgIHZhciBjYXJnbyA9IHtcbiAgICAgICAgICAgIHRhc2tzOiB0YXNrcyxcbiAgICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWQsXG4gICAgICAgICAgICBzYXR1cmF0ZWQ6IG51bGwsXG4gICAgICAgICAgICBlbXB0eTogbnVsbCxcbiAgICAgICAgICAgIGRyYWluOiBudWxsLFxuICAgICAgICAgICAgcHVzaDogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYoZGF0YS5jb25zdHJ1Y3RvciAhPT0gQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IFtkYXRhXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX2VhY2goZGF0YSwgZnVuY3Rpb24odGFzaykge1xuICAgICAgICAgICAgICAgICAgICB0YXNrcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHRhc2ssXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nID8gY2FsbGJhY2sgOiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FyZ28uc2F0dXJhdGVkICYmIHRhc2tzLmxlbmd0aCA9PT0gcGF5bG9hZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FyZ28uc2F0dXJhdGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUoY2FyZ28ucHJvY2Vzcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJvY2VzczogZnVuY3Rpb24gcHJvY2VzcygpIHtcbiAgICAgICAgICAgICAgICBpZiAod29ya2luZykgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICh0YXNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoY2FyZ28uZHJhaW4pIGNhcmdvLmRyYWluKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgdHMgPSB0eXBlb2YgcGF5bG9hZCA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRhc2tzLnNwbGljZSgwLCBwYXlsb2FkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGFza3Muc3BsaWNlKDApO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRzID0gX21hcCh0cywgZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhc2suZGF0YTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmKGNhcmdvLmVtcHR5KSBjYXJnby5lbXB0eSgpO1xuICAgICAgICAgICAgICAgIHdvcmtpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHdvcmtlcihkcywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB3b3JraW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgICAgIF9lYWNoKHRzLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhc2tzLmxlbmd0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBydW5uaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdvcmtpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjYXJnbztcbiAgICB9O1xuXG4gICAgdmFyIF9jb25zb2xlX2ZuID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncy5jb25jYXQoW2Z1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uc29sZS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb25zb2xlW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZWFjaChhcmdzLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGVbbmFtZV0oeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBhc3luYy5sb2cgPSBfY29uc29sZV9mbignbG9nJyk7XG4gICAgYXN5bmMuZGlyID0gX2NvbnNvbGVfZm4oJ2RpcicpO1xuICAgIC8qYXN5bmMuaW5mbyA9IF9jb25zb2xlX2ZuKCdpbmZvJyk7XG4gICAgYXN5bmMud2FybiA9IF9jb25zb2xlX2ZuKCd3YXJuJyk7XG4gICAgYXN5bmMuZXJyb3IgPSBfY29uc29sZV9mbignZXJyb3InKTsqL1xuXG4gICAgYXN5bmMubWVtb2l6ZSA9IGZ1bmN0aW9uIChmbiwgaGFzaGVyKSB7XG4gICAgICAgIHZhciBtZW1vID0ge307XG4gICAgICAgIHZhciBxdWV1ZXMgPSB7fTtcbiAgICAgICAgaGFzaGVyID0gaGFzaGVyIHx8IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICAgICAgICAgIHZhciBrZXkgPSBoYXNoZXIuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICBpZiAoa2V5IGluIG1lbW8pIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBtZW1vW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5IGluIHF1ZXVlcykge1xuICAgICAgICAgICAgICAgIHF1ZXVlc1trZXldLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcXVldWVzW2tleV0gPSBbY2FsbGJhY2tdO1xuICAgICAgICAgICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MuY29uY2F0KFtmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lbW9ba2V5XSA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHEgPSBxdWV1ZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHF1ZXVlc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcVtpXS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbWVtb2l6ZWQubWVtbyA9IG1lbW87XG4gICAgICAgIG1lbW9pemVkLnVubWVtb2l6ZWQgPSBmbjtcbiAgICAgICAgcmV0dXJuIG1lbW9pemVkO1xuICAgIH07XG5cbiAgICBhc3luYy51bm1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoZm4udW5tZW1vaXplZCB8fCBmbikuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGFzeW5jLnRpbWVzID0gZnVuY3Rpb24gKGNvdW50LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGNvdW50ZXIgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb3VudGVyLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzeW5jLm1hcChjb3VudGVyLCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBhc3luYy50aW1lc1NlcmllcyA9IGZ1bmN0aW9uIChjb3VudCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBjb3VudGVyID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgY291bnRlci5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3luYy5tYXBTZXJpZXMoY291bnRlciwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMuY29tcG9zZSA9IGZ1bmN0aW9uICgvKiBmdW5jdGlvbnMuLi4gKi8pIHtcbiAgICAgICAgdmFyIGZucyA9IEFycmF5LnByb3RvdHlwZS5yZXZlcnNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgICAgICBhc3luYy5yZWR1Y2UoZm5zLCBhcmdzLCBmdW5jdGlvbiAobmV3YXJncywgZm4sIGNiKSB7XG4gICAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgbmV3YXJncy5jb25jYXQoW2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVyciA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgY2IoZXJyLCBuZXh0YXJncyk7XG4gICAgICAgICAgICAgICAgfV0pKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlcnIsIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGF0LCBbZXJyXS5jb25jYXQocmVzdWx0cykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBfYXBwbHlFYWNoID0gZnVuY3Rpb24gKGVhY2hmbiwgZm5zIC8qYXJncy4uLiovKSB7XG4gICAgICAgIHZhciBnbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gZWFjaGZuKGZucywgZnVuY3Rpb24gKGZuLCBjYikge1xuICAgICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIGFyZ3MuY29uY2F0KFtjYl0pKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgICAgICAgICAgcmV0dXJuIGdvLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGdvO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBhc3luYy5hcHBseUVhY2ggPSBkb1BhcmFsbGVsKF9hcHBseUVhY2gpO1xuICAgIGFzeW5jLmFwcGx5RWFjaFNlcmllcyA9IGRvU2VyaWVzKF9hcHBseUVhY2gpO1xuXG4gICAgYXN5bmMuZm9yZXZlciA9IGZ1bmN0aW9uIChmbiwgY2FsbGJhY2spIHtcbiAgICAgICAgZnVuY3Rpb24gbmV4dChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZuKG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIG5leHQoKTtcbiAgICB9O1xuXG4gICAgLy8gQU1EIC8gUmVxdWlyZUpTXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgIT09ICd1bmRlZmluZWQnICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gYXN5bmM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBOb2RlLmpzXG4gICAgZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBhc3luYztcbiAgICB9XG4gICAgLy8gaW5jbHVkZWQgZGlyZWN0bHkgdmlhIDxzY3JpcHQ+IHRhZ1xuICAgIGVsc2Uge1xuICAgICAgICByb290LmFzeW5jID0gYXN5bmM7XG4gICAgfVxuXG59KCkpO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luc2VydC1tb2R1bGUtZ2xvYmFscy9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXCIpKSIsIi8qKlxuICogQmFja2JvbmUuTmF0aXZlXG4gKlxuICogRm9yIGFsbCBkZXRhaWxzIGFuZCBkb2N1bWVudGF0aW9uOlxuICogaHR0cDovL2dpdGh1Yi5jb20vaW5rbGluZy9iYWNrYm9uZS5uYXRpdmVcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMyBJbmtsaW5nIFN5c3RlbXMsIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBUaGUgcHVycG9zZSBvZiB0aGlzIGxpYnJhcnkgaXMgdG8gYWxsb3cgQmFja2JvbmUgdG8gd29yayB3aXRob3V0IG5lZWRpbmcgdG8gbG9hZCBqUXVlcnkgb3IgWmVwdG8uXG4gKiBUaGlzIGZpbGUgcHJvdmlkZXMgYSBiYXNpYyBqUXVlcnktbGlrZSBpbXBsZW1lbnRhdGlvbiBmb3IgQmFja2JvbmUsIGltcGxlbWVudGluZyB0aGVcbiAqIG1pbmltdW0gZnVuY3Rpb25hbGl0eSBmb3IgQmFja2JvbmUgdG8gZnVuY3Rpb24uIFdlIGFzc3VtZSB0aGF0IEJhY2tib25lIGFwcGxpY2F0aW9ucyB1c2luZ1xuICogdGhpcyB3aWxsIG5vdCBleHBlY3QgdGhlIHN0YW5kYXJkIGpRdWVyeSBBUEkgdG8gd29yaywgYW5kIHdpbGwgaW5zdGVhZCB1c2UgbmF0aXZlIEpTIGZ1bmN0aW9ucy5cbiAqXG4gKiBLZWVwIGluIG1pbmQgdGhhdCBkdWUgdG8gdGhlIEFQSXMgaW4gdGhpcywgaXQgd2lsbCBsaWtlbHkgb25seSB3b3JrIG9uIHJlY2VudCBicm93c2Vycy5cbiAqXG4gKiBOb3RlOlxuICogIC0gQ29yZSBCYWNrYm9uZSBvbmx5IG5lZWRzIGNvbGxlY3Rpb25zIHdpdGggc2luZ2xlIG1lbWJlcnMsIHNvIHRoYXQgaXMgYWxsIHRoYXQgaGFzIGJlZW5cbiAqICAgICAgc3VwcG9ydGVkIGluIHRoaXMgbGlicmFyeS4gSXQgaXMgZXhwZWN0ZWQgdGhhdCB5b3Ugd2lsbCBqdXN0IHVzZSBxdWVyeVNlbGVjdG9yQWxsIGluc3RlYWQuXG4gKiAgICAgIFRoaXMgd2lsbCBiZSBtb3N0IG9idmlvdXMgaWYgeW91IG1ha2UgaGVhdnkgdXNlIG9mICd2aWV3LiQnLlxuICogIC0gRXZlbnRzIGRlbGVnYXRlZCB3aXRoIHNlbGVjdG9ycyBzdGFydGluZyB3aXRoICc+JyBhcmUgbm90IHN1cHBvcnRlZC5cbiAqICAtIER1ZSB0byAnY3VycmVudFRhcmdldCcgYmVpbmcgcmVhZC1vbmx5IG9uIHN0YW5kYXJkIERPTSBldmVudHMsIHdlIGNhbm5vdCBtYWtlIHN0YW5kYXJkXG4gKiAgICAgIGV2ZW50cyBiZWhhdmUgaWRlbnRpY2FsbHkgdG8galF1ZXJ5J3MgZXZlbnRzIHdoZW4gZGVsZWdhdGlvbiBpcyB1c2VkLiBUaGUgZWxlbWVudCBtYXRjaGluZ1xuICogICAgICB0aGUgZGVsZWdhdGUgc2VsZWN0b3IgaXMgaW5zdGVhZCBwYXNzZWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBldmVudCBoYW5kbGVycy5cbiAqICAtIFRoZSAnJC5hamF4JyBpbXBsZW1lbnRhdGlvbiBpcyB2ZXJ5IHNpbXBsZSBhbmQgbGlrZWx5IG5lZWRzIHRvIGJlIGV4cGFuZGVkIHRvIGJldHRlciBzdXBwb3J0XG4gKiAgICAgIHN0YW5kYXJkIHVzZS1jYXNlcy5cbiAqXG4gKiBUZXN0ZWQgd2l0aCBCYWNrYm9uZSB2MC45LjIgYW5kIDEuMC4wLlxuICovXG4oZnVuY3Rpb24oKXtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vIFJlZ3VsYXIgZXhwcmVzc2lvbiB0byBtYXRjaCBhbiBldmVudCBuYW1lIGFuZC9vciBhIG5hbWVzcGFjZS5cbiAgICB2YXIgbmFtZXNwYWNlUkUgPSAvXihbXi5dKyk/KD86XFwuKFteLl0rKSk/JC87XG5cbiAgICB2YXIgbWF0Y2hlc1NlbGVjdG9yID0gRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlc1NlbGVjdG9yIHx8IG51bGw7XG4gICAgaWYgKCFtYXRjaGVzU2VsZWN0b3Ipe1xuICAgICAgICBbJ3dlYmtpdCcsICdtb3onLCAnbycsICdtcyddLmZvckVhY2goZnVuY3Rpb24ocHJlZml4KXtcbiAgICAgICAgICAgIHZhciBmdW5jID0gRWxlbWVudC5wcm90b3R5cGVbcHJlZml4ICsgJ01hdGNoZXNTZWxlY3RvciddO1xuICAgICAgICAgICAgaWYgKGZ1bmMpIG1hdGNoZXNTZWxlY3RvciA9IGZ1bmM7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFRoZSBlbGVtZW50IHByb3BlcnR5IHRvIHNhdmUgdGhlIGNhY2hlIGtleSBvbi5cbiAgICB2YXIgY2FjaGVLZXlQcm9wID0gJ2JhY2tib25lTmF0aXZlS2V5JyArIE1hdGgucmFuZG9tKCk7XG4gICAgdmFyIGlkID0gMTtcbiAgICB2YXIgaGFuZGxlcnMgPSB7fTtcbiAgICB2YXIgdW51c2VkS2V5cyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBldmVudCBoYW5kbGVycyBmb3IgYSBnaXZlbiBlbGVtZW50LCBjcmVhdGluZyBhbiBlbXB0eSBzZXQgaWYgb25lIGRvZXNuJ3QgZXhpc3QuXG4gICAgICpcbiAgICAgKiBUbyBhdm9pZCBjb25zdGFudGx5IGZpbGxpbmcgdGhlIGhhbmRsZXJzIG9iamVjdCB3aXRoIG51bGwgdmFsdWVzLCB3ZSByZXVzZSBvbGQgSURzIHRoYXRcbiAgICAgKiBoYXZlIGJlZW4gY3JlYXRlZCBhbmQgdGhlbiBjbGVhcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbCBUaGUgZWxlbWVudCB0byBnZXQgaGFuZGxlcnMgZm9yLlxuICAgICAqXG4gICAgICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIGhhbmRsZXJzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhbmRsZXJzRm9yKGVsKXtcbiAgICAgICAgaWYgKCFlbFtjYWNoZUtleVByb3BdKXtcbiAgICAgICAgICAgIC8vIFBpY2sgYSBuZXcga2V5LCBmcm9tIHRoZSB1bnVzZWQgcG9vbCwgb3IgbWFrZSBhIG5ldyBvbmUuXG4gICAgICAgICAgICBlbFtjYWNoZUtleVByb3BdID0gdW51c2VkS2V5cy5sZW5ndGggPT09IDAgPyArK2lkIDogdW51c2VkS2V5cy5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYWNoZUtleSA9IGVsW2NhY2hlS2V5UHJvcF07XG4gICAgICAgIHJldHVybiBoYW5kbGVyc1tjYWNoZUtleV0gfHwgKGhhbmRsZXJzW2NhY2hlS2V5XSA9IFtdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciB0aGUgZXZlbnQgaGFuZGxlcnMgZm9yIGEgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWwgVGhlIGVsZW1lbnQgdG8gY2xlYXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xlYXJIYW5kbGVycyhlbCl7XG4gICAgICAgIHZhciBjYWNoZUtleSA9IGVsW2NhY2hlS2V5UHJvcF07XG4gICAgICAgIGlmIChoYW5kbGVyc1tjYWNoZUtleV0pe1xuICAgICAgICAgICAgaGFuZGxlcnNbY2FjaGVLZXldID0gbnVsbDtcbiAgICAgICAgICAgIGVsW2NhY2hlS2V5UHJvcF0gPSBudWxsO1xuICAgICAgICAgICAgdW51c2VkS2V5cy5wdXNoKGNhY2hlS2V5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBldmVudCBoYW5kbGVycyB0byBhbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBwYXJlbnRFbGVtZW50IFRoZSBlbGVtZW50IHRvIGJpbmQgZXZlbnQgaGFuZGxlcnMgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgZXZlbnQgdG8gYmluZCwgZS5nLiAnY2xpY2snLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciAoT3B0aW9uYWwpIFRoZSBzZWxlY3RvciB0byBtYXRjaCB3aGVuIGFuIGV2ZW50IHByb3BhZ2F0ZXMgdXAuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihFdmVudCwgRWxlbWVudCl9IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGV2ZW50IGlzIGZpcmVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uKHBhcmVudEVsZW1lbnQsIGV2ZW50TmFtZSwgc2VsZWN0b3IsIGNhbGxiYWNrKXtcbiAgICAgICAgLy8gQWRqdXN0IGFyZ3VtZW50cyBpZiBzZWxlY3RvciB3YXMgbm90IHByb3ZpZGVkLlxuICAgICAgICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSAnZnVuY3Rpb24nKXtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gc2VsZWN0b3I7XG4gICAgICAgICAgICBzZWxlY3RvciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFydHMgPSBuYW1lc3BhY2VSRS5leGVjKGV2ZW50TmFtZSk7XG4gICAgICAgIGV2ZW50TmFtZSA9IHBhcnRzWzFdIHx8IG51bGw7XG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSBwYXJ0c1syXSB8fCBudWxsO1xuXG4gICAgICAgIGlmICghZXZlbnROYW1lKSByZXR1cm47XG5cbiAgICAgICAgdmFyIGhhbmRsZXIgPSBjYWxsYmFjaztcbiAgICAgICAgdmFyIG9yaWdpbmFsQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKHNlbGVjdG9yKXtcbiAgICAgICAgICAgIC8vIEV2ZW50IGRlbGVnYXRpb24gaGFuZGxlciB0byBtYXRjaCBhIHNlbGVjdG9yIGZvciBjaGlsZCBlbGVtZW50IGV2ZW50cy5cbiAgICAgICAgICAgIGhhbmRsZXIgPSBmdW5jdGlvbihldmVudCl7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZWwgPSBldmVudC50YXJnZXQ7IGVsICYmIGVsICE9PSBwYXJlbnRFbGVtZW50OyBlbCA9IGVsLnBhcmVudEVsZW1lbnQpe1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlc1NlbGVjdG9yLmNhbGwoZWwsIHNlbGVjdG9yKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBqUXVlcnkgZG9lcyBub3QgaW5jbHVkZSB0aGUgc2Vjb25kIGFyZ3VtZW50LCBidXQgd2UgaGF2ZSBpbmNsdWRlZCBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHNpbXBsaWNpdHkgYmVjYXVzZSAndGhpcycgd2lsbCBsaWtlbHkgYmUgYm91bmQgdG8gdGhlIHZpZXcgaW5zaWRlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgY2FsbGJhY2ssIGFuZCBhcyBub3RlZCBhYm92ZSwgd2UgY2Fubm90IG92ZXJyaWRlICdjdXJyZW50VGFyZ2V0Jy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBvcmlnaW5hbENhbGxiYWNrLmNhbGwoZWwsIGV2ZW50LCBlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gU3RhbmRhcmQgZXZlbnQgaGFuZGxlciBib3VuZCBkaXJlY3RseSB0byB0aGUgZWxlbWVudC5cbiAgICAgICAgICAgIGhhbmRsZXIgPSBmdW5jdGlvbihldmVudCl7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsQ2FsbGJhY2suY2FsbChwYXJlbnRFbGVtZW50LCBldmVudCwgcGFyZW50RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2Upe1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBwYXJlbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBmYWxzZSk7XG5cbiAgICAgICAgLy8gU2F2ZSBldmVudCBoYW5kbGVyIG1ldGFkYXRhIHNvIHRoYXQgdGhlIGhhbmRsZXIgY2FuIGJlIHVuYm91bmQgbGF0ZXIuXG4gICAgICAgIGhhbmRsZXJzRm9yKHBhcmVudEVsZW1lbnQpLnB1c2goe1xuICAgICAgICAgICAgZXZlbnROYW1lOiBldmVudE5hbWUsXG4gICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzZWxlY3Rvcjogc2VsZWN0b3JcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFuIGV2ZW50IGhhbmRsZXIgZnJvbSBhbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBwYXJlbnRFbGVtZW50IFRoZSBlbGVtZW50IHRvIHVuYmluZCBldmVudCBoYW5kbGVycyBmcm9tLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgKE9wdGlvbmFsKSBUaGUgZXZlbnQgdG8gdW5iaW5kLCBlLmcuICdjbGljaycuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIChPcHRpb25hbCkgVGhlIHNlbGVjdG9yIHRvIHVuYmluZC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEV2ZW50LCBFbGVtZW50KX0gY2FsbGJhY2sgKE9wdGlvbmFsKSBUaGUgZnVuY3Rpb24gdG8gdW5iaW5kLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9mZihwYXJlbnRFbGVtZW50LCBldmVudE5hbWUsIHNlbGVjdG9yLCBjYWxsYmFjayl7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09ICdmdW5jdGlvbicpe1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBzZWxlY3RvcjtcbiAgICAgICAgICAgIHNlbGVjdG9yID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJ0cyA9IG5hbWVzcGFjZVJFLmV4ZWMoZXZlbnROYW1lIHx8ICcnKTtcbiAgICAgICAgZXZlbnROYW1lID0gcGFydHNbMV07XG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSBwYXJ0c1syXTtcbiAgICAgICAgdmFyIGhhbmRsZXJzID0gaGFuZGxlcnNGb3IocGFyZW50RWxlbWVudCkgfHwgW107XG5cbiAgICAgICAgaWYgKCFldmVudE5hbWUgJiYgIW5hbWVzcGFjZSAmJiAhc2VsZWN0b3IgJiYgIWNhbGxiYWNrKXtcbiAgICAgICAgICAgIC8vIEZhc3RwYXRoIHRvIHJlbW92ZSBhbGwgaGFuZGxlcnMuXG4gICAgICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pe1xuICAgICAgICAgICAgICAgIHBhcmVudEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihpdGVtLmV2ZW50TmFtZSwgaXRlbS5oYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNsZWFySGFuZGxlcnMocGFyZW50RWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlZEhhbmRsZXJzID0gaGFuZGxlcnMuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pe1xuICAgICAgICAgICAgICAgIHJldHVybiAoKCFuYW1lc3BhY2UgfHwgaXRlbS5uYW1lc3BhY2UgPT09IG5hbWVzcGFjZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFldmVudE5hbWUgfHwgaXRlbS5ldmVudE5hbWUgPT09IGV2ZW50TmFtZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFjYWxsYmFjayB8fCBpdGVtLmNhbGxiYWNrID09PSBjYWxsYmFjaykgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFzZWxlY3RvciB8fCBpdGVtLnNlbGVjdG9yID09PSBzZWxlY3RvcikpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1hdGNoZWRIYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pe1xuICAgICAgICAgICAgICAgIHBhcmVudEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihpdGVtLmV2ZW50TmFtZSwgaXRlbS5oYW5kbGVyLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICBoYW5kbGVycy5zcGxpY2UoaGFuZGxlcnMuaW5kZXhPZihpdGVtKSwgMSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGhhbmRsZXJzLmxlbmd0aCA9PT0gMCkgY2xlYXJIYW5kbGVycyhwYXJlbnRFbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyBqUXVlcnktc3R5bGUgZWxlbWVudCByZXByZXNlbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEVsZW1lbnR8V2luZG93fSBlbGVtZW50IFRoZXJlIGFyZSBzZXZlcmFsIGRpZmZlcmVudCBwb3NzaWJsZSB2YWx1ZXMgZm9yIHRoaXNcbiAgICAgKiAgICAgIGFyZ3VtZW50OlxuICAgICAqICAgICAgLSB7c3RyaW5nfSBBIHNuaXBwZXQgb2YgSFRNTCwgaWYgaXQgc3RhcnRzIHdpdGggYSAnPCcsIG9yIGEgc2VsZWN0b3IgdG8gZmluZC5cbiAgICAgKiAgICAgIC0ge0VsZW1lbnR9IEFuIGV4aXN0aW5nIGVsZW1lbnQgdG8gd3JhcC5cbiAgICAgKiAgICAgIC0ge1dpbmRvd30gVGhlIHdpbmRvdyBvYmplY3QgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gc2VhcmNoIHdpdGhpbiwgaWYgYSBzZWxlY3RvciB3YXMgZ2l2ZW4uXG4gICAgICogICAgICBEZWZhdWx0cyB0byBkb2N1bWVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAkKGVsZW1lbnQsIGNvbnRleHQpe1xuICAgICAgICBjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuICAgICAgICAvLyBDYWxsIGFzIGEgY29uc3RydWN0b3IgaWYgaXQgd2FzIHVzZWQgYXMgYSBmdW5jdGlvbi5cbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mICQpKSByZXR1cm4gbmV3ICQoZWxlbWVudCwgY29udGV4dCk7XG5cbiAgICAgICAgaWYgKCFlbGVtZW50KXtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycpe1xuICAgICAgICAgICAgaWYgKC9eXFxzKjwvLnRlc3QoZWxlbWVudCkpe1xuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGFyYml0cmFyeSBIVE1MIGludG8gYW4gZWxlbWVudC5cbiAgICAgICAgICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgZGl2LmlubmVySFRNTCA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgdGhpc1swXSA9IGRpdi5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIGRpdi5yZW1vdmVDaGlsZChkaXYuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzWzBdID0gY29udGV4dC5xdWVyeVNlbGVjdG9yKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaGFuZGxlcyBib3RoIHRoZSAnRWxlbWVudCcgYW5kICdXaW5kb3cnIGNhc2UsIGFzIGJvdGggc3VwcG9ydFxuICAgICAgICAgICAgLy8gZXZlbnQgYmluZGluZyB2aWEgJ2FkZEV2ZW50TGlzdGVuZXInLlxuICAgICAgICAgICAgdGhpc1swXSA9IGVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAkLnByb3RvdHlwZSA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBmb2xsb3dpbmcgbWV0aG9kcyBhcmUgdXNlZCBieSBCYWNrYm9uZSwgYnV0IG9ubHkgaW4gY29kZS1wYXRocyBmb3IgSUUgNi83IHN1cHBvcnQuXG4gICAgICAgICAqIFNpbmNlIG5vbmUgb2YgdGhpcyB3aWxsIHdvcmsgZm9yIG9sZCBJRSBhbnl3YXksIHRoZXkgYXJlIG5vdCBpbXBsZW1lbnRlZCwgYW5kXG4gICAgICAgICAqIGluc3RlYWQgbGVmdCBmb3IgZG9jdW1lbnRhdGlvbiBwdXJwb3Nlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogVXNlZCBpbiBCYWNrYm9uZS5IaXN0b3J5LnByb3RvdHlwZS5zdGFydC5cbiAgICAgICAgICovXG4gICAgICAgIGhpZGU6IG51bGwsXG4gICAgICAgIGFwcGVuZFRvOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaW5kIGlzIG5vdCBzdXBwb3J0ZWQgdG8gZW5jb3VyYWdlIHRoZSB1c2Ugb2YgcXVlcnlTZWxlY3RvcihBbGwpIGFzIGFuIGFsdGVybmF0aXZlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBlLmcuXG4gICAgICAgICAqIEluc3RlYWQgb2YgJ3RoaXMuJChzZWwpJywgdXNlICd0aGlzLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsKScuXG4gICAgICAgICAqXG4gICAgICAgICAqIFVzZWQgaW4gQmFja2JvbmUuVmlldy5wcm90b3R5cGUuJCwgYnV0IG5vdCBhY3R1YWxseSBjYWxsZWQgaW50ZXJuYWxseS5cbiAgICAgICAgICovXG4gICAgICAgIGZpbmQ6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBhdHRyaWJ1dGVzIHRvIHRoZSBlbGVtZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBVc2VkIGluIEJhY2tib25lLlZpZXcucHJvdG90eXBlLm1ha2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzIEEgc2V0IG9mIGF0dHJpYnV0ZXMgdG8gYXBwbHkgdG8gdGhlIGVsZW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4geyR9IFRoaXMgaW5zdGFuY2UuXG4gICAgICAgICAqL1xuICAgICAgICBhdHRyOiBmdW5jdGlvbihhdHRycyl7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbihhdHRyKXtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGF0dHIpe1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbMF0uaW5uZXJIVE1MID0gYXR0cnNbYXR0cl07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzWzBdLnRleHRDb250ZW50ID0gYXR0cnNbYXR0cl07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1swXS5jbGFzc05hbWUgPSBhdHRyc1thdHRyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1swXS5zZXRBdHRyaWJ1dGUoYXR0ciwgYXR0cnNbYXR0cl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBIVE1MIGNvbnRlbnQgb2YgdGhlIGVsZW1lbnQuIEJhY2tib25lIGRvZXMgbm90IHVzZSB0aGUgbm8tYXJndW1lbnQgdmVyc2lvblxuICAgICAgICAgKiB0byByZWFkIGlubmVySFRNTCwgc28gdGhhdCBoYXMgbm90IGJlZW4gaW1wbGVtZW50ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFVzZWQgaW4gQmFja2JvbmUuVmlldy5wcm90b3R5cGUubWFrZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGh0bWwgVGhlIEhUTUwgdG8gc2V0IGFzIHRoZSBlbGVtZW50IGNvbnRlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4geyR9IFRoaXMgaW5zdGFuY2UuXG4gICAgICAgICAqL1xuICAgICAgICBodG1sOiBmdW5jdGlvbihodG1sKXtcbiAgICAgICAgICAgIHRoaXNbMF0uaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgYW4gZWxlbWVudCBmcm9tIHRoZSBET00gYW5kIHJlbW92ZSBhbGwgZXZlbnQgaGFuZGxlcnMgYm91bmQgdG8gaXQgYW5kXG4gICAgICAgICAqIGl0cyBjaGlsZCBlbGVtZW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogVXNlZCBpbiBCYWNrYm9uZS5WaWV3LnByb3RvdHlwZS5yZW1vdmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4geyR9IFRoaXMgaW5zdGFuY2UuXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB2YXIgZWwgPSB0aGlzWzBdO1xuICAgICAgICAgICAgaWYgKGVsLnBhcmVudEVsZW1lbnQpIGVsLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoZWwpO1xuXG4gICAgICAgICAgICAvLyBVbmJpbmQgYWxsIGV2ZW50IGhhbmRsZXJzIG9uIHRoZSBlbGVtZW50IGFuZCBjaGlsZHJlbi5cbiAgICAgICAgICAgIChmdW5jdGlvbiByZW1vdmVDaGlsZEV2ZW50cyhlbGVtZW50KXtcbiAgICAgICAgICAgICAgICBvZmYoZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuY2hpbGROb2Rlc1tpXS5ub2RlVHlwZSAhPT0gTm9kZS5URVhUX05PREUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2hpbGRFdmVudHMoZWxlbWVudC5jaGlsZE5vZGVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKGVsKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJpbmQgYW4gZXZlbnQgaGFuZGxlciB0byB0aGlzIGVsZW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIGV2ZW50IHRvIGJpbmQsIGUuZy4gJ2NsaWNrJy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIChPcHRpb25hbCkgVGhlIHNlbGVjdG9yIHRvIG1hdGNoIHdoZW4gYW4gZXZlbnQgcHJvcGFnYXRlcyB1cC5cbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbihFdmVudCwgRWxlbWVudCl9IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGV2ZW50IGlzIGZpcmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgb246IGZ1bmN0aW9uKGV2ZW50TmFtZSwgc2VsZWN0b3IsIGNhbGxiYWNrKXtcbiAgICAgICAgICAgIG9uKHRoaXNbMF0sIGV2ZW50TmFtZSwgc2VsZWN0b3IsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbmJpbmQgYW4gZXZlbnQgaGFuZGxlciB0byB0aGlzIGVsZW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgKE9wdGlvbmFsKSBUaGUgZXZlbnQgdG8gdW5iaW5kLCBlLmcuICdjbGljaycuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciAoT3B0aW9uYWwpIFRoZSBzZWxlY3RvciB0byB1bmJpbmQuXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXZlbnQsIEVsZW1lbnQpfSBjYWxsYmFjayAoT3B0aW9uYWwpIFRoZSBmdW5jdGlvbiB0byB1bmJpbmQuXG4gICAgICAgICAqL1xuICAgICAgICBvZmY6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgc2VsZWN0b3IsIGNhbGxiYWNrKXtcbiAgICAgICAgICAgIG9mZih0aGlzWzBdLCBldmVudE5hbWUsIHNlbGVjdG9yLCBjYWxsYmFjayk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBCYWNrYm9uZSB2MC45LjIgc3VwcG9ydC5cbiAgICAgICAgYmluZDogZnVuY3Rpb24oZXZlbnROYW1lLCBjYWxsYmFjayl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vbihldmVudE5hbWUsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5iaW5kOiBmdW5jdGlvbihldmVudE5hbWUsIGNhbGxiYWNrKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9mZihldmVudE5hbWUsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVsZWdhdGU6IGZ1bmN0aW9uKHNlbGVjdG9yLCBldmVudE5hbWUsIGNhbGxiYWNrKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9uKGV2ZW50TmFtZSwgc2VsZWN0b3IsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5kZWxlZ2F0ZTogZnVuY3Rpb24oc2VsZWN0b3IsIGV2ZW50TmFtZSwgY2FsbGJhY2spe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2ZmKGV2ZW50TmFtZSwgc2VsZWN0b3IsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGFuIEFKQVggcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIHRvIHVzZSBmb3IgdGhlIGNvbm5lY3Rpb246XG4gICAgICogICAgICAtIHtzdHJpbmd9IHVybCBUaGUgVVJMIHRvIGNvbm5lY3QgdG8uXG4gICAgICogICAgICAtIHtzdHJpbmd9IHR5cGUgVGhlIHR5cGUgb2YgcmVxdWVzdCwgZS5nLiAnR0VUJywgb3IgJ1BPU1QnLlxuICAgICAqICAgICAgLSB7c3RyaW5nfSBkYXRhVHlwZSBUaGUgdHlwZSBvZiBkYXRhIGV4cGVjdGVkLCAnanNvbicuXG4gICAgICogICAgICAtIHtzdHJpbmd9IGNvbnRlbnRUeXBlIFRoZSBjb250ZW50LXR5cGUgb2YgdGhlIGRhdGEuXG4gICAgICogICAgICAtIHtzdHJpbmd8b2JqZWN0fSBkYXRhIFRoZSBjb250ZW50IHRvIHNlbmQuXG4gICAgICogICAgICAtIHtmdW5jdGlvbihYTUxIdHRwUmVxdWVzdCl9IGJlZm9yZVNlbmQgQSBjYWxsYmFjayB0byBjYWxsIGJlZm9yZSBzZW5kaW5nLlxuICAgICAqICAgICAgLSB7Ym9vbGVhbn0gcHJvY2Vzc0RhdGEgVHJ1ZSBpZiAnZGF0YScgc2hvdWxkIGJlIGNvbnZlcnRlZFxuICAgICAqICAgICAgICAgIHRvIGEgcXVlcnkgc3RyaW5nIGZyb20gYW4gb2JqZWN0LlxuICAgICAqICAgICAgLSB7ZnVuY3Rpb24oe3N0cmluZ3xvYmplY3R9LCB7c3RyaW5nfSwge1hNTEh0dHBSZXF1ZXN0fSl9IHN1Y2Nlc3MgVGhlIHN1Y2Nlc3MgY2FsbGJhY2suXG4gICAgICogICAgICAtIHtmdW5jdGlvbih7WE1MSHR0cFJlcXVlc3R9KX0gZXJyb3IgVGhlIGVycm9yIGNhbGxiYWNrLlxuICAgICAqL1xuICAgICQuYWpheCA9IGZ1bmN0aW9uKG9wdGlvbnMpe1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdmFyIHR5cGUgPSBvcHRpb25zLnR5cGUgfHwgJ0dFVCc7XG4gICAgICAgIHZhciB1cmwgPSBvcHRpb25zLnVybDtcbiAgICAgICAgdmFyIHByb2Nlc3NEYXRhID0gb3B0aW9ucy5wcm9jZXNzRGF0YSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICEhb3B0aW9ucy5wcm9jZXNzRGF0YTtcblxuICAgICAgICAvLyBQcm9jZXNzIHRoZSBkYXRhIGZvciBzZW5kaW5nLlxuICAgICAgICB2YXIgZGF0YSA9IG9wdGlvbnMuZGF0YTtcbiAgICAgICAgaWYgKHByb2Nlc3NEYXRhICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0Jyl7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gT2JqZWN0LmtleXMoZGF0YSkubWFwKGZ1bmN0aW9uKHByb3Ape1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQocHJvcCkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQoZGF0YVtwcm9wXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRhdGEgPSBwYXJhbXMuam9pbignJicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGF0YSBmb3IgR0VUIGFuZCBIRUFEIGdvZXMgaW4gdGhlIFVSTC5cbiAgICAgICAgaWYgKGRhdGEgJiYgKHR5cGUgPT09ICdHRVQnIHx8IHR5cGUgPT09ICdIRUFEJykpe1xuICAgICAgICAgICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBkYXRhO1xuICAgICAgICAgICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgeGhyLm9wZW4odHlwZSwgdXJsLCB0cnVlKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5jb250ZW50VHlwZSkgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsIG9wdGlvbnMuY29udGVudFR5cGUpO1xuICAgICAgICBpZiAob3B0aW9ucy5iZWZvcmVTZW5kKSBvcHRpb25zLmJlZm9yZVNlbmQoeGhyKTtcblxuICAgICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSB4aHIucmVzcG9uc2VUZXh0O1xuXG4gICAgICAgICAgICAvLyBQYXJzZSB0aGUgSlNPTiBiZWZvcmUgY2FsbGluZyBzdWNjZXNzLlxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGF0YVR5cGUgPT09ICdqc29uJyl7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IEpTT04ucGFyc2UoY29udGVudCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFlcnJvciAmJiAoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCkpe1xuICAgICAgICAgICAgICAgIC8vIFRoZSBsYXN0IHR3byBhcmd1bWVudHMgb25seSBhcHBseSB0byB2MC45LjIuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3VjY2Vzcykgb3B0aW9ucy5zdWNjZXNzKGNvbnRlbnQsIHhoci5zdGF0dXNUZXh0LCB4aHIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHNpZ25hdHVyZSBpcyBpbmNvbnNpc3RlbnQgd2l0aCB2MC45LjIsIGJ1dCBpcyBjb3JyZWN0IGZvciAxLjAuMC5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5lcnJvcikgb3B0aW9ucy5lcnJvcih4aHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgeGhyLm9uZXJyb3IgPSB4aHIub25hYm9ydCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5lcnJvcikgb3B0aW9ucy5lcnJvcih4aHIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHhoci5zZW5kKGRhdGEpO1xuXG4gICAgICAgIHJldHVybiB4aHI7XG4gICAgfTtcblxuICAgIC8vIEV4cG9zZSBvbi9vZmYgZm9yIGV4dGVybmFsIHVzZSB3aXRoIGhhdmluZyB0byBpbnN0YW50aWF0ZSBhIHdyYXBwZXIuXG4gICAgJC5vbiA9IG9uO1xuICAgICQub2ZmID0gb2ZmO1xuXG4gICAgaWYodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gbW9kdWxlLmV4cG9ydHMgPSAkO1xuICAgIH1cblxuICAgIHZhciByb290ID0gdGhpcztcbiAgICB2YXIgb3JpZ2luYWxCYWNrYm9uZU5hdGl2ZSA9IHJvb3QuQmFja2JvbmUgPyByb290LkJhY2tib25lLk5hdGl2ZSA6IG51bGw7XG4gICAgdmFyIG9yaWdpbmFsJCA9IHJvb3QuJDtcbiAgICBpZiAocm9vdC5CYWNrYm9uZSkgcm9vdC5CYWNrYm9uZS5OYXRpdmUgPSAkO1xuICAgIHJvb3QuJCA9ICQ7XG5cbiAgICAkLm5vQ29uZmxpY3QgPSBmdW5jdGlvbihkZWVwKXtcbiAgICAgICAgcm9vdC4kID0gb3JpZ2luYWwkO1xuICAgICAgICBpZiAoZGVlcCkgcm9vdC5CYWNrYm9uZS5OYXRpdmUgPSBvcmlnaW5hbEJhY2tib25lTmF0aXZlO1xuICAgICAgICByZXR1cm4gJDtcbiAgICB9O1xuXG4gICAgaWYgKHJvb3QuQmFja2JvbmUpe1xuICAgICAgICBpZiAocm9vdC5CYWNrYm9uZS5zZXREb21MaWJyYXJ5KXsgLy8gdjAuOS4yXG4gICAgICAgICAgICByb290LkJhY2tib25lLnNldERvbUxpYnJhcnkoJCk7XG4gICAgICAgIH0gZWxzZSB7IC8vIHYxLjAuMFxuICAgICAgICAgICAgcm9vdC5CYWNrYm9uZS4kID0gJDtcbiAgICAgICAgfVxuICAgIH1cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyAgICAgQmFja2JvbmUuanMgMS4xLjBcblxuLy8gICAgIChjKSAyMDEwLTIwMTEgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIEluYy5cbi8vICAgICAoYykgMjAxMS0yMDEzIEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4vLyAgICAgQmFja2JvbmUgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4vLyAgICAgRm9yIGFsbCBkZXRhaWxzIGFuZCBkb2N1bWVudGF0aW9uOlxuLy8gICAgIGh0dHA6Ly9iYWNrYm9uZWpzLm9yZ1xuXG4oZnVuY3Rpb24oKXtcblxuICAvLyBJbml0aWFsIFNldHVwXG4gIC8vIC0tLS0tLS0tLS0tLS1cblxuICAvLyBTYXZlIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0IChgd2luZG93YCBpbiB0aGUgYnJvd3NlciwgYGV4cG9ydHNgXG4gIC8vIG9uIHRoZSBzZXJ2ZXIpLlxuICB2YXIgcm9vdCA9IHRoaXM7XG5cbiAgLy8gU2F2ZSB0aGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGBCYWNrYm9uZWAgdmFyaWFibGUsIHNvIHRoYXQgaXQgY2FuIGJlXG4gIC8vIHJlc3RvcmVkIGxhdGVyIG9uLCBpZiBgbm9Db25mbGljdGAgaXMgdXNlZC5cbiAgdmFyIHByZXZpb3VzQmFja2JvbmUgPSByb290LkJhY2tib25lO1xuXG4gIC8vIENyZWF0ZSBsb2NhbCByZWZlcmVuY2VzIHRvIGFycmF5IG1ldGhvZHMgd2UnbGwgd2FudCB0byB1c2UgbGF0ZXIuXG4gIHZhciBhcnJheSA9IFtdO1xuICB2YXIgcHVzaCA9IGFycmF5LnB1c2g7XG4gIHZhciBzbGljZSA9IGFycmF5LnNsaWNlO1xuICB2YXIgc3BsaWNlID0gYXJyYXkuc3BsaWNlO1xuXG4gIC8vIFRoZSB0b3AtbGV2ZWwgbmFtZXNwYWNlLiBBbGwgcHVibGljIEJhY2tib25lIGNsYXNzZXMgYW5kIG1vZHVsZXMgd2lsbFxuICAvLyBiZSBhdHRhY2hlZCB0byB0aGlzLiBFeHBvcnRlZCBmb3IgYm90aCB0aGUgYnJvd3NlciBhbmQgdGhlIHNlcnZlci5cbiAgdmFyIEJhY2tib25lO1xuICBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgQmFja2JvbmUgPSBleHBvcnRzO1xuICB9IGVsc2Uge1xuICAgIEJhY2tib25lID0gcm9vdC5CYWNrYm9uZSA9IHt9O1xuICB9XG5cbiAgLy8gQ3VycmVudCB2ZXJzaW9uIG9mIHRoZSBsaWJyYXJ5LiBLZWVwIGluIHN5bmMgd2l0aCBgcGFja2FnZS5qc29uYC5cbiAgQmFja2JvbmUuVkVSU0lPTiA9ICcxLjEuMCc7XG5cbiAgLy8gUmVxdWlyZSBVbmRlcnNjb3JlLCBpZiB3ZSdyZSBvbiB0aGUgc2VydmVyLCBhbmQgaXQncyBub3QgYWxyZWFkeSBwcmVzZW50LlxuICB2YXIgXyA9IHJvb3QuXztcbiAgaWYgKCFfICYmICh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpKSBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xuXG4gIC8vIEZvciBCYWNrYm9uZSdzIHB1cnBvc2VzLCBqUXVlcnksIFplcHRvLCBFbmRlciwgb3IgTXkgTGlicmFyeSAoa2lkZGluZykgb3duc1xuICAvLyB0aGUgYCRgIHZhcmlhYmxlLlxuICBCYWNrYm9uZS4kID0gcm9vdC5qUXVlcnkgfHwgcm9vdC5aZXB0byB8fCByb290LmVuZGVyIHx8IHJvb3QuJDtcblxuICAvLyBSdW5zIEJhY2tib25lLmpzIGluICpub0NvbmZsaWN0KiBtb2RlLCByZXR1cm5pbmcgdGhlIGBCYWNrYm9uZWAgdmFyaWFibGVcbiAgLy8gdG8gaXRzIHByZXZpb3VzIG93bmVyLiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoaXMgQmFja2JvbmUgb2JqZWN0LlxuICBCYWNrYm9uZS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcm9vdC5CYWNrYm9uZSA9IHByZXZpb3VzQmFja2JvbmU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gVHVybiBvbiBgZW11bGF0ZUhUVFBgIHRvIHN1cHBvcnQgbGVnYWN5IEhUVFAgc2VydmVycy4gU2V0dGluZyB0aGlzIG9wdGlvblxuICAvLyB3aWxsIGZha2UgYFwiUEFUQ0hcImAsIGBcIlBVVFwiYCBhbmQgYFwiREVMRVRFXCJgIHJlcXVlc3RzIHZpYSB0aGUgYF9tZXRob2RgIHBhcmFtZXRlciBhbmRcbiAgLy8gc2V0IGEgYFgtSHR0cC1NZXRob2QtT3ZlcnJpZGVgIGhlYWRlci5cbiAgQmFja2JvbmUuZW11bGF0ZUhUVFAgPSBmYWxzZTtcblxuICAvLyBUdXJuIG9uIGBlbXVsYXRlSlNPTmAgdG8gc3VwcG9ydCBsZWdhY3kgc2VydmVycyB0aGF0IGNhbid0IGRlYWwgd2l0aCBkaXJlY3RcbiAgLy8gYGFwcGxpY2F0aW9uL2pzb25gIHJlcXVlc3RzIC4uLiB3aWxsIGVuY29kZSB0aGUgYm9keSBhc1xuICAvLyBgYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkYCBpbnN0ZWFkIGFuZCB3aWxsIHNlbmQgdGhlIG1vZGVsIGluIGFcbiAgLy8gZm9ybSBwYXJhbSBuYW1lZCBgbW9kZWxgLlxuICBCYWNrYm9uZS5lbXVsYXRlSlNPTiA9IGZhbHNlO1xuXG4gIC8vIEJhY2tib25lLkV2ZW50c1xuICAvLyAtLS0tLS0tLS0tLS0tLS1cblxuICAvLyBBIG1vZHVsZSB0aGF0IGNhbiBiZSBtaXhlZCBpbiB0byAqYW55IG9iamVjdCogaW4gb3JkZXIgdG8gcHJvdmlkZSBpdCB3aXRoXG4gIC8vIGN1c3RvbSBldmVudHMuIFlvdSBtYXkgYmluZCB3aXRoIGBvbmAgb3IgcmVtb3ZlIHdpdGggYG9mZmAgY2FsbGJhY2tcbiAgLy8gZnVuY3Rpb25zIHRvIGFuIGV2ZW50OyBgdHJpZ2dlcmAtaW5nIGFuIGV2ZW50IGZpcmVzIGFsbCBjYWxsYmFja3MgaW5cbiAgLy8gc3VjY2Vzc2lvbi5cbiAgLy9cbiAgLy8gICAgIHZhciBvYmplY3QgPSB7fTtcbiAgLy8gICAgIF8uZXh0ZW5kKG9iamVjdCwgQmFja2JvbmUuRXZlbnRzKTtcbiAgLy8gICAgIG9iamVjdC5vbignZXhwYW5kJywgZnVuY3Rpb24oKXsgYWxlcnQoJ2V4cGFuZGVkJyk7IH0pO1xuICAvLyAgICAgb2JqZWN0LnRyaWdnZXIoJ2V4cGFuZCcpO1xuICAvL1xuICB2YXIgRXZlbnRzID0gQmFja2JvbmUuRXZlbnRzID0ge1xuXG4gICAgLy8gQmluZCBhbiBldmVudCB0byBhIGBjYWxsYmFja2AgZnVuY3Rpb24uIFBhc3NpbmcgYFwiYWxsXCJgIHdpbGwgYmluZFxuICAgIC8vIHRoZSBjYWxsYmFjayB0byBhbGwgZXZlbnRzIGZpcmVkLlxuICAgIG9uOiBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgaWYgKCFldmVudHNBcGkodGhpcywgJ29uJywgbmFtZSwgW2NhbGxiYWNrLCBjb250ZXh0XSkgfHwgIWNhbGxiYWNrKSByZXR1cm4gdGhpcztcbiAgICAgIHRoaXMuX2V2ZW50cyB8fCAodGhpcy5fZXZlbnRzID0ge30pO1xuICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50c1tuYW1lXSB8fCAodGhpcy5fZXZlbnRzW25hbWVdID0gW10pO1xuICAgICAgZXZlbnRzLnB1c2goe2NhbGxiYWNrOiBjYWxsYmFjaywgY29udGV4dDogY29udGV4dCwgY3R4OiBjb250ZXh0IHx8IHRoaXN9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBCaW5kIGFuIGV2ZW50IHRvIG9ubHkgYmUgdHJpZ2dlcmVkIGEgc2luZ2xlIHRpbWUuIEFmdGVyIHRoZSBmaXJzdCB0aW1lXG4gICAgLy8gdGhlIGNhbGxiYWNrIGlzIGludm9rZWQsIGl0IHdpbGwgYmUgcmVtb3ZlZC5cbiAgICBvbmNlOiBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgaWYgKCFldmVudHNBcGkodGhpcywgJ29uY2UnLCBuYW1lLCBbY2FsbGJhY2ssIGNvbnRleHRdKSB8fCAhY2FsbGJhY2spIHJldHVybiB0aGlzO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIG9uY2UgPSBfLm9uY2UoZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYub2ZmKG5hbWUsIG9uY2UpO1xuICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG4gICAgICBvbmNlLl9jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgcmV0dXJuIHRoaXMub24obmFtZSwgb25jZSwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSBvbmUgb3IgbWFueSBjYWxsYmFja3MuIElmIGBjb250ZXh0YCBpcyBudWxsLCByZW1vdmVzIGFsbFxuICAgIC8vIGNhbGxiYWNrcyB3aXRoIHRoYXQgZnVuY3Rpb24uIElmIGBjYWxsYmFja2AgaXMgbnVsbCwgcmVtb3ZlcyBhbGxcbiAgICAvLyBjYWxsYmFja3MgZm9yIHRoZSBldmVudC4gSWYgYG5hbWVgIGlzIG51bGwsIHJlbW92ZXMgYWxsIGJvdW5kXG4gICAgLy8gY2FsbGJhY2tzIGZvciBhbGwgZXZlbnRzLlxuICAgIG9mZjogZnVuY3Rpb24obmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgIHZhciByZXRhaW4sIGV2LCBldmVudHMsIG5hbWVzLCBpLCBsLCBqLCBrO1xuICAgICAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIWV2ZW50c0FwaSh0aGlzLCAnb2ZmJywgbmFtZSwgW2NhbGxiYWNrLCBjb250ZXh0XSkpIHJldHVybiB0aGlzO1xuICAgICAgaWYgKCFuYW1lICYmICFjYWxsYmFjayAmJiAhY29udGV4dCkge1xuICAgICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBuYW1lcyA9IG5hbWUgPyBbbmFtZV0gOiBfLmtleXModGhpcy5fZXZlbnRzKTtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBuYW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICBpZiAoZXZlbnRzID0gdGhpcy5fZXZlbnRzW25hbWVdKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzW25hbWVdID0gcmV0YWluID0gW107XG4gICAgICAgICAgaWYgKGNhbGxiYWNrIHx8IGNvbnRleHQpIHtcbiAgICAgICAgICAgIGZvciAoaiA9IDAsIGsgPSBldmVudHMubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICAgIGV2ID0gZXZlbnRzW2pdO1xuICAgICAgICAgICAgICBpZiAoKGNhbGxiYWNrICYmIGNhbGxiYWNrICE9PSBldi5jYWxsYmFjayAmJiBjYWxsYmFjayAhPT0gZXYuY2FsbGJhY2suX2NhbGxiYWNrKSB8fFxuICAgICAgICAgICAgICAgICAgKGNvbnRleHQgJiYgY29udGV4dCAhPT0gZXYuY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICByZXRhaW4ucHVzaChldik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFyZXRhaW4ubGVuZ3RoKSBkZWxldGUgdGhpcy5fZXZlbnRzW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBUcmlnZ2VyIG9uZSBvciBtYW55IGV2ZW50cywgZmlyaW5nIGFsbCBib3VuZCBjYWxsYmFja3MuIENhbGxiYWNrcyBhcmVcbiAgICAvLyBwYXNzZWQgdGhlIHNhbWUgYXJndW1lbnRzIGFzIGB0cmlnZ2VyYCBpcywgYXBhcnQgZnJvbSB0aGUgZXZlbnQgbmFtZVxuICAgIC8vICh1bmxlc3MgeW91J3JlIGxpc3RlbmluZyBvbiBgXCJhbGxcImAsIHdoaWNoIHdpbGwgY2F1c2UgeW91ciBjYWxsYmFjayB0b1xuICAgIC8vIHJlY2VpdmUgdGhlIHRydWUgbmFtZSBvZiB0aGUgZXZlbnQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50KS5cbiAgICB0cmlnZ2VyOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICBpZiAoIXRoaXMuX2V2ZW50cykgcmV0dXJuIHRoaXM7XG4gICAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgIGlmICghZXZlbnRzQXBpKHRoaXMsICd0cmlnZ2VyJywgbmFtZSwgYXJncykpIHJldHVybiB0aGlzO1xuICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50c1tuYW1lXTtcbiAgICAgIHZhciBhbGxFdmVudHMgPSB0aGlzLl9ldmVudHMuYWxsO1xuICAgICAgaWYgKGV2ZW50cykgdHJpZ2dlckV2ZW50cyhldmVudHMsIGFyZ3MpO1xuICAgICAgaWYgKGFsbEV2ZW50cykgdHJpZ2dlckV2ZW50cyhhbGxFdmVudHMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gVGVsbCB0aGlzIG9iamVjdCB0byBzdG9wIGxpc3RlbmluZyB0byBlaXRoZXIgc3BlY2lmaWMgZXZlbnRzIC4uLiBvclxuICAgIC8vIHRvIGV2ZXJ5IG9iamVjdCBpdCdzIGN1cnJlbnRseSBsaXN0ZW5pbmcgdG8uXG4gICAgc3RvcExpc3RlbmluZzogZnVuY3Rpb24ob2JqLCBuYW1lLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGxpc3RlbmluZ1RvID0gdGhpcy5fbGlzdGVuaW5nVG87XG4gICAgICBpZiAoIWxpc3RlbmluZ1RvKSByZXR1cm4gdGhpcztcbiAgICAgIHZhciByZW1vdmUgPSAhbmFtZSAmJiAhY2FsbGJhY2s7XG4gICAgICBpZiAoIWNhbGxiYWNrICYmIHR5cGVvZiBuYW1lID09PSAnb2JqZWN0JykgY2FsbGJhY2sgPSB0aGlzO1xuICAgICAgaWYgKG9iaikgKGxpc3RlbmluZ1RvID0ge30pW29iai5fbGlzdGVuSWRdID0gb2JqO1xuICAgICAgZm9yICh2YXIgaWQgaW4gbGlzdGVuaW5nVG8pIHtcbiAgICAgICAgb2JqID0gbGlzdGVuaW5nVG9baWRdO1xuICAgICAgICBvYmoub2ZmKG5hbWUsIGNhbGxiYWNrLCB0aGlzKTtcbiAgICAgICAgaWYgKHJlbW92ZSB8fCBfLmlzRW1wdHkob2JqLl9ldmVudHMpKSBkZWxldGUgdGhpcy5fbGlzdGVuaW5nVG9baWRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gIH07XG5cbiAgLy8gUmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gc3BsaXQgZXZlbnQgc3RyaW5ncy5cbiAgdmFyIGV2ZW50U3BsaXR0ZXIgPSAvXFxzKy87XG5cbiAgLy8gSW1wbGVtZW50IGZhbmN5IGZlYXR1cmVzIG9mIHRoZSBFdmVudHMgQVBJIHN1Y2ggYXMgbXVsdGlwbGUgZXZlbnRcbiAgLy8gbmFtZXMgYFwiY2hhbmdlIGJsdXJcImAgYW5kIGpRdWVyeS1zdHlsZSBldmVudCBtYXBzIGB7Y2hhbmdlOiBhY3Rpb259YFxuICAvLyBpbiB0ZXJtcyBvZiB0aGUgZXhpc3RpbmcgQVBJLlxuICB2YXIgZXZlbnRzQXBpID0gZnVuY3Rpb24ob2JqLCBhY3Rpb24sIG5hbWUsIHJlc3QpIHtcbiAgICBpZiAoIW5hbWUpIHJldHVybiB0cnVlO1xuXG4gICAgLy8gSGFuZGxlIGV2ZW50IG1hcHMuXG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgZm9yICh2YXIga2V5IGluIG5hbWUpIHtcbiAgICAgICAgb2JqW2FjdGlvbl0uYXBwbHkob2JqLCBba2V5LCBuYW1lW2tleV1dLmNvbmNhdChyZXN0KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHNwYWNlIHNlcGFyYXRlZCBldmVudCBuYW1lcy5cbiAgICBpZiAoZXZlbnRTcGxpdHRlci50ZXN0KG5hbWUpKSB7XG4gICAgICB2YXIgbmFtZXMgPSBuYW1lLnNwbGl0KGV2ZW50U3BsaXR0ZXIpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBuYW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgb2JqW2FjdGlvbl0uYXBwbHkob2JqLCBbbmFtZXNbaV1dLmNvbmNhdChyZXN0KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLy8gQSBkaWZmaWN1bHQtdG8tYmVsaWV2ZSwgYnV0IG9wdGltaXplZCBpbnRlcm5hbCBkaXNwYXRjaCBmdW5jdGlvbiBmb3JcbiAgLy8gdHJpZ2dlcmluZyBldmVudHMuIFRyaWVzIHRvIGtlZXAgdGhlIHVzdWFsIGNhc2VzIHNwZWVkeSAobW9zdCBpbnRlcm5hbFxuICAvLyBCYWNrYm9uZSBldmVudHMgaGF2ZSAzIGFyZ3VtZW50cykuXG4gIHZhciB0cmlnZ2VyRXZlbnRzID0gZnVuY3Rpb24oZXZlbnRzLCBhcmdzKSB7XG4gICAgdmFyIGV2LCBpID0gLTEsIGwgPSBldmVudHMubGVuZ3RoLCBhMSA9IGFyZ3NbMF0sIGEyID0gYXJnc1sxXSwgYTMgPSBhcmdzWzJdO1xuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgpOyByZXR1cm47XG4gICAgICBjYXNlIDE6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4LCBhMSk7IHJldHVybjtcbiAgICAgIGNhc2UgMjogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgsIGExLCBhMik7IHJldHVybjtcbiAgICAgIGNhc2UgMzogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgsIGExLCBhMiwgYTMpOyByZXR1cm47XG4gICAgICBkZWZhdWx0OiB3aGlsZSAoKytpIDwgbCkgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5hcHBseShldi5jdHgsIGFyZ3MpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgbGlzdGVuTWV0aG9kcyA9IHtsaXN0ZW5UbzogJ29uJywgbGlzdGVuVG9PbmNlOiAnb25jZSd9O1xuXG4gIC8vIEludmVyc2lvbi1vZi1jb250cm9sIHZlcnNpb25zIG9mIGBvbmAgYW5kIGBvbmNlYC4gVGVsbCAqdGhpcyogb2JqZWN0IHRvXG4gIC8vIGxpc3RlbiB0byBhbiBldmVudCBpbiBhbm90aGVyIG9iamVjdCAuLi4ga2VlcGluZyB0cmFjayBvZiB3aGF0IGl0J3NcbiAgLy8gbGlzdGVuaW5nIHRvLlxuICBfLmVhY2gobGlzdGVuTWV0aG9kcywgZnVuY3Rpb24oaW1wbGVtZW50YXRpb24sIG1ldGhvZCkge1xuICAgIEV2ZW50c1ttZXRob2RdID0gZnVuY3Rpb24ob2JqLCBuYW1lLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGxpc3RlbmluZ1RvID0gdGhpcy5fbGlzdGVuaW5nVG8gfHwgKHRoaXMuX2xpc3RlbmluZ1RvID0ge30pO1xuICAgICAgdmFyIGlkID0gb2JqLl9saXN0ZW5JZCB8fCAob2JqLl9saXN0ZW5JZCA9IF8udW5pcXVlSWQoJ2wnKSk7XG4gICAgICBsaXN0ZW5pbmdUb1tpZF0gPSBvYmo7XG4gICAgICBpZiAoIWNhbGxiYWNrICYmIHR5cGVvZiBuYW1lID09PSAnb2JqZWN0JykgY2FsbGJhY2sgPSB0aGlzO1xuICAgICAgb2JqW2ltcGxlbWVudGF0aW9uXShuYW1lLCBjYWxsYmFjaywgdGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICB9KTtcblxuICAvLyBBbGlhc2VzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgRXZlbnRzLmJpbmQgICA9IEV2ZW50cy5vbjtcbiAgRXZlbnRzLnVuYmluZCA9IEV2ZW50cy5vZmY7XG5cbiAgLy8gQWxsb3cgdGhlIGBCYWNrYm9uZWAgb2JqZWN0IHRvIHNlcnZlIGFzIGEgZ2xvYmFsIGV2ZW50IGJ1cywgZm9yIGZvbGtzIHdob1xuICAvLyB3YW50IGdsb2JhbCBcInB1YnN1YlwiIGluIGEgY29udmVuaWVudCBwbGFjZS5cbiAgXy5leHRlbmQoQmFja2JvbmUsIEV2ZW50cyk7XG5cbiAgLy8gQmFja2JvbmUuTW9kZWxcbiAgLy8gLS0tLS0tLS0tLS0tLS1cblxuICAvLyBCYWNrYm9uZSAqKk1vZGVscyoqIGFyZSB0aGUgYmFzaWMgZGF0YSBvYmplY3QgaW4gdGhlIGZyYW1ld29yayAtLVxuICAvLyBmcmVxdWVudGx5IHJlcHJlc2VudGluZyBhIHJvdyBpbiBhIHRhYmxlIGluIGEgZGF0YWJhc2Ugb24geW91ciBzZXJ2ZXIuXG4gIC8vIEEgZGlzY3JldGUgY2h1bmsgb2YgZGF0YSBhbmQgYSBidW5jaCBvZiB1c2VmdWwsIHJlbGF0ZWQgbWV0aG9kcyBmb3JcbiAgLy8gcGVyZm9ybWluZyBjb21wdXRhdGlvbnMgYW5kIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGF0IGRhdGEuXG5cbiAgLy8gQ3JlYXRlIGEgbmV3IG1vZGVsIHdpdGggdGhlIHNwZWNpZmllZCBhdHRyaWJ1dGVzLiBBIGNsaWVudCBpZCAoYGNpZGApXG4gIC8vIGlzIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGFuZCBhc3NpZ25lZCBmb3IgeW91LlxuICB2YXIgTW9kZWwgPSBCYWNrYm9uZS5Nb2RlbCA9IGZ1bmN0aW9uKGF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgYXR0cnMgPSBhdHRyaWJ1dGVzIHx8IHt9O1xuICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgdGhpcy5jaWQgPSBfLnVuaXF1ZUlkKCdjJyk7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gICAgaWYgKG9wdGlvbnMuY29sbGVjdGlvbikgdGhpcy5jb2xsZWN0aW9uID0gb3B0aW9ucy5jb2xsZWN0aW9uO1xuICAgIGlmIChvcHRpb25zLnBhcnNlKSBhdHRycyA9IHRoaXMucGFyc2UoYXR0cnMsIG9wdGlvbnMpIHx8IHt9O1xuICAgIGF0dHJzID0gXy5kZWZhdWx0cyh7fSwgYXR0cnMsIF8ucmVzdWx0KHRoaXMsICdkZWZhdWx0cycpKTtcbiAgICB0aGlzLnNldChhdHRycywgb3B0aW9ucyk7XG4gICAgdGhpcy5jaGFuZ2VkID0ge307XG4gICAgdGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLy8gQXR0YWNoIGFsbCBpbmhlcml0YWJsZSBtZXRob2RzIHRvIHRoZSBNb2RlbCBwcm90b3R5cGUuXG4gIF8uZXh0ZW5kKE1vZGVsLnByb3RvdHlwZSwgRXZlbnRzLCB7XG5cbiAgICAvLyBBIGhhc2ggb2YgYXR0cmlidXRlcyB3aG9zZSBjdXJyZW50IGFuZCBwcmV2aW91cyB2YWx1ZSBkaWZmZXIuXG4gICAgY2hhbmdlZDogbnVsbCxcblxuICAgIC8vIFRoZSB2YWx1ZSByZXR1cm5lZCBkdXJpbmcgdGhlIGxhc3QgZmFpbGVkIHZhbGlkYXRpb24uXG4gICAgdmFsaWRhdGlvbkVycm9yOiBudWxsLFxuXG4gICAgLy8gVGhlIGRlZmF1bHQgbmFtZSBmb3IgdGhlIEpTT04gYGlkYCBhdHRyaWJ1dGUgaXMgYFwiaWRcImAuIE1vbmdvREIgYW5kXG4gICAgLy8gQ291Y2hEQiB1c2VycyBtYXkgd2FudCB0byBzZXQgdGhpcyB0byBgXCJfaWRcImAuXG4gICAgaWRBdHRyaWJ1dGU6ICdpZCcsXG5cbiAgICAvLyBJbml0aWFsaXplIGlzIGFuIGVtcHR5IGZ1bmN0aW9uIGJ5IGRlZmF1bHQuIE92ZXJyaWRlIGl0IHdpdGggeW91ciBvd25cbiAgICAvLyBpbml0aWFsaXphdGlvbiBsb2dpYy5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpe30sXG5cbiAgICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBtb2RlbCdzIGBhdHRyaWJ1dGVzYCBvYmplY3QuXG4gICAgdG9KU09OOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gXy5jbG9uZSh0aGlzLmF0dHJpYnV0ZXMpO1xuICAgIH0sXG5cbiAgICAvLyBQcm94eSBgQmFja2JvbmUuc3luY2AgYnkgZGVmYXVsdCAtLSBidXQgb3ZlcnJpZGUgdGhpcyBpZiB5b3UgbmVlZFxuICAgIC8vIGN1c3RvbSBzeW5jaW5nIHNlbWFudGljcyBmb3IgKnRoaXMqIHBhcnRpY3VsYXIgbW9kZWwuXG4gICAgc3luYzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gQmFja2JvbmUuc3luYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZS5cbiAgICBnZXQ6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbYXR0cl07XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgSFRNTC1lc2NhcGVkIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZS5cbiAgICBlc2NhcGU6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIHJldHVybiBfLmVzY2FwZSh0aGlzLmdldChhdHRyKSk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBhdHRyaWJ1dGUgY29udGFpbnMgYSB2YWx1ZSB0aGF0IGlzIG5vdCBudWxsXG4gICAgLy8gb3IgdW5kZWZpbmVkLlxuICAgIGhhczogZnVuY3Rpb24oYXR0cikge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KGF0dHIpICE9IG51bGw7XG4gICAgfSxcblxuICAgIC8vIFNldCBhIGhhc2ggb2YgbW9kZWwgYXR0cmlidXRlcyBvbiB0aGUgb2JqZWN0LCBmaXJpbmcgYFwiY2hhbmdlXCJgLiBUaGlzIGlzXG4gICAgLy8gdGhlIGNvcmUgcHJpbWl0aXZlIG9wZXJhdGlvbiBvZiBhIG1vZGVsLCB1cGRhdGluZyB0aGUgZGF0YSBhbmQgbm90aWZ5aW5nXG4gICAgLy8gYW55b25lIHdobyBuZWVkcyB0byBrbm93IGFib3V0IHRoZSBjaGFuZ2UgaW4gc3RhdGUuIFRoZSBoZWFydCBvZiB0aGUgYmVhc3QuXG4gICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbCwgb3B0aW9ucykge1xuICAgICAgdmFyIGF0dHIsIGF0dHJzLCB1bnNldCwgY2hhbmdlcywgc2lsZW50LCBjaGFuZ2luZywgcHJldiwgY3VycmVudDtcbiAgICAgIGlmIChrZXkgPT0gbnVsbCkgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIEhhbmRsZSBib3RoIGBcImtleVwiLCB2YWx1ZWAgYW5kIGB7a2V5OiB2YWx1ZX1gIC1zdHlsZSBhcmd1bWVudHMuXG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYXR0cnMgPSBrZXk7XG4gICAgICAgIG9wdGlvbnMgPSB2YWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAoYXR0cnMgPSB7fSlba2V5XSA9IHZhbDtcbiAgICAgIH1cblxuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcblxuICAgICAgLy8gUnVuIHZhbGlkYXRpb24uXG4gICAgICBpZiAoIXRoaXMuX3ZhbGlkYXRlKGF0dHJzLCBvcHRpb25zKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBFeHRyYWN0IGF0dHJpYnV0ZXMgYW5kIG9wdGlvbnMuXG4gICAgICB1bnNldCAgICAgICAgICAgPSBvcHRpb25zLnVuc2V0O1xuICAgICAgc2lsZW50ICAgICAgICAgID0gb3B0aW9ucy5zaWxlbnQ7XG4gICAgICBjaGFuZ2VzICAgICAgICAgPSBbXTtcbiAgICAgIGNoYW5naW5nICAgICAgICA9IHRoaXMuX2NoYW5naW5nO1xuICAgICAgdGhpcy5fY2hhbmdpbmcgID0gdHJ1ZTtcblxuICAgICAgaWYgKCFjaGFuZ2luZykge1xuICAgICAgICB0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXMgPSBfLmNsb25lKHRoaXMuYXR0cmlidXRlcyk7XG4gICAgICAgIHRoaXMuY2hhbmdlZCA9IHt9O1xuICAgICAgfVxuICAgICAgY3VycmVudCA9IHRoaXMuYXR0cmlidXRlcywgcHJldiA9IHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlcztcblxuICAgICAgLy8gQ2hlY2sgZm9yIGNoYW5nZXMgb2YgYGlkYC5cbiAgICAgIGlmICh0aGlzLmlkQXR0cmlidXRlIGluIGF0dHJzKSB0aGlzLmlkID0gYXR0cnNbdGhpcy5pZEF0dHJpYnV0ZV07XG5cbiAgICAgIC8vIEZvciBlYWNoIGBzZXRgIGF0dHJpYnV0ZSwgdXBkYXRlIG9yIGRlbGV0ZSB0aGUgY3VycmVudCB2YWx1ZS5cbiAgICAgIGZvciAoYXR0ciBpbiBhdHRycykge1xuICAgICAgICB2YWwgPSBhdHRyc1thdHRyXTtcbiAgICAgICAgaWYgKCFfLmlzRXF1YWwoY3VycmVudFthdHRyXSwgdmFsKSkgY2hhbmdlcy5wdXNoKGF0dHIpO1xuICAgICAgICBpZiAoIV8uaXNFcXVhbChwcmV2W2F0dHJdLCB2YWwpKSB7XG4gICAgICAgICAgdGhpcy5jaGFuZ2VkW2F0dHJdID0gdmFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLmNoYW5nZWRbYXR0cl07XG4gICAgICAgIH1cbiAgICAgICAgdW5zZXQgPyBkZWxldGUgY3VycmVudFthdHRyXSA6IGN1cnJlbnRbYXR0cl0gPSB2YWw7XG4gICAgICB9XG5cbiAgICAgIC8vIFRyaWdnZXIgYWxsIHJlbGV2YW50IGF0dHJpYnV0ZSBjaGFuZ2VzLlxuICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgaWYgKGNoYW5nZXMubGVuZ3RoKSB0aGlzLl9wZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGFuZ2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlOicgKyBjaGFuZ2VzW2ldLCB0aGlzLCBjdXJyZW50W2NoYW5nZXNbaV1dLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBZb3UgbWlnaHQgYmUgd29uZGVyaW5nIHdoeSB0aGVyZSdzIGEgYHdoaWxlYCBsb29wIGhlcmUuIENoYW5nZXMgY2FuXG4gICAgICAvLyBiZSByZWN1cnNpdmVseSBuZXN0ZWQgd2l0aGluIGBcImNoYW5nZVwiYCBldmVudHMuXG4gICAgICBpZiAoY2hhbmdpbmcpIHJldHVybiB0aGlzO1xuICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuX3BlbmRpbmcpIHtcbiAgICAgICAgICB0aGlzLl9wZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2UnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fcGVuZGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5fY2hhbmdpbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgYW4gYXR0cmlidXRlIGZyb20gdGhlIG1vZGVsLCBmaXJpbmcgYFwiY2hhbmdlXCJgLiBgdW5zZXRgIGlzIGEgbm9vcFxuICAgIC8vIGlmIHRoZSBhdHRyaWJ1dGUgZG9lc24ndCBleGlzdC5cbiAgICB1bnNldDogZnVuY3Rpb24oYXR0ciwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KGF0dHIsIHZvaWQgMCwgXy5leHRlbmQoe30sIG9wdGlvbnMsIHt1bnNldDogdHJ1ZX0pKTtcbiAgICB9LFxuXG4gICAgLy8gQ2xlYXIgYWxsIGF0dHJpYnV0ZXMgb24gdGhlIG1vZGVsLCBmaXJpbmcgYFwiY2hhbmdlXCJgLlxuICAgIGNsZWFyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgYXR0cnMgPSB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmF0dHJpYnV0ZXMpIGF0dHJzW2tleV0gPSB2b2lkIDA7XG4gICAgICByZXR1cm4gdGhpcy5zZXQoYXR0cnMsIF8uZXh0ZW5kKHt9LCBvcHRpb25zLCB7dW5zZXQ6IHRydWV9KSk7XG4gICAgfSxcblxuICAgIC8vIERldGVybWluZSBpZiB0aGUgbW9kZWwgaGFzIGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgYFwiY2hhbmdlXCJgIGV2ZW50LlxuICAgIC8vIElmIHlvdSBzcGVjaWZ5IGFuIGF0dHJpYnV0ZSBuYW1lLCBkZXRlcm1pbmUgaWYgdGhhdCBhdHRyaWJ1dGUgaGFzIGNoYW5nZWQuXG4gICAgaGFzQ2hhbmdlZDogZnVuY3Rpb24oYXR0cikge1xuICAgICAgaWYgKGF0dHIgPT0gbnVsbCkgcmV0dXJuICFfLmlzRW1wdHkodGhpcy5jaGFuZ2VkKTtcbiAgICAgIHJldHVybiBfLmhhcyh0aGlzLmNoYW5nZWQsIGF0dHIpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBhdHRyaWJ1dGVzIHRoYXQgaGF2ZSBjaGFuZ2VkLCBvclxuICAgIC8vIGZhbHNlIGlmIHRoZXJlIGFyZSBubyBjaGFuZ2VkIGF0dHJpYnV0ZXMuIFVzZWZ1bCBmb3IgZGV0ZXJtaW5pbmcgd2hhdFxuICAgIC8vIHBhcnRzIG9mIGEgdmlldyBuZWVkIHRvIGJlIHVwZGF0ZWQgYW5kL29yIHdoYXQgYXR0cmlidXRlcyBuZWVkIHRvIGJlXG4gICAgLy8gcGVyc2lzdGVkIHRvIHRoZSBzZXJ2ZXIuIFVuc2V0IGF0dHJpYnV0ZXMgd2lsbCBiZSBzZXQgdG8gdW5kZWZpbmVkLlxuICAgIC8vIFlvdSBjYW4gYWxzbyBwYXNzIGFuIGF0dHJpYnV0ZXMgb2JqZWN0IHRvIGRpZmYgYWdhaW5zdCB0aGUgbW9kZWwsXG4gICAgLy8gZGV0ZXJtaW5pbmcgaWYgdGhlcmUgKndvdWxkIGJlKiBhIGNoYW5nZS5cbiAgICBjaGFuZ2VkQXR0cmlidXRlczogZnVuY3Rpb24oZGlmZikge1xuICAgICAgaWYgKCFkaWZmKSByZXR1cm4gdGhpcy5oYXNDaGFuZ2VkKCkgPyBfLmNsb25lKHRoaXMuY2hhbmdlZCkgOiBmYWxzZTtcbiAgICAgIHZhciB2YWwsIGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgIHZhciBvbGQgPSB0aGlzLl9jaGFuZ2luZyA/IHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlcyA6IHRoaXMuYXR0cmlidXRlcztcbiAgICAgIGZvciAodmFyIGF0dHIgaW4gZGlmZikge1xuICAgICAgICBpZiAoXy5pc0VxdWFsKG9sZFthdHRyXSwgKHZhbCA9IGRpZmZbYXR0cl0pKSkgY29udGludWU7XG4gICAgICAgIChjaGFuZ2VkIHx8IChjaGFuZ2VkID0ge30pKVthdHRyXSA9IHZhbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIHByZXZpb3VzIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZSwgcmVjb3JkZWQgYXQgdGhlIHRpbWUgdGhlIGxhc3RcbiAgICAvLyBgXCJjaGFuZ2VcImAgZXZlbnQgd2FzIGZpcmVkLlxuICAgIHByZXZpb3VzOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICBpZiAoYXR0ciA9PSBudWxsIHx8ICF0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXMpIHJldHVybiBudWxsO1xuICAgICAgcmV0dXJuIHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlc1thdHRyXTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IGFsbCBvZiB0aGUgYXR0cmlidXRlcyBvZiB0aGUgbW9kZWwgYXQgdGhlIHRpbWUgb2YgdGhlIHByZXZpb3VzXG4gICAgLy8gYFwiY2hhbmdlXCJgIGV2ZW50LlxuICAgIHByZXZpb3VzQXR0cmlidXRlczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXy5jbG9uZSh0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXMpO1xuICAgIH0sXG5cbiAgICAvLyBGZXRjaCB0aGUgbW9kZWwgZnJvbSB0aGUgc2VydmVyLiBJZiB0aGUgc2VydmVyJ3MgcmVwcmVzZW50YXRpb24gb2YgdGhlXG4gICAgLy8gbW9kZWwgZGlmZmVycyBmcm9tIGl0cyBjdXJyZW50IGF0dHJpYnV0ZXMsIHRoZXkgd2lsbCBiZSBvdmVycmlkZGVuLFxuICAgIC8vIHRyaWdnZXJpbmcgYSBgXCJjaGFuZ2VcImAgZXZlbnQuXG4gICAgZmV0Y2g6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gXy5jbG9uZShvcHRpb25zKSA6IHt9O1xuICAgICAgaWYgKG9wdGlvbnMucGFyc2UgPT09IHZvaWQgMCkgb3B0aW9ucy5wYXJzZSA9IHRydWU7XG4gICAgICB2YXIgbW9kZWwgPSB0aGlzO1xuICAgICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XG4gICAgICBvcHRpb25zLnN1Y2Nlc3MgPSBmdW5jdGlvbihyZXNwKSB7XG4gICAgICAgIGlmICghbW9kZWwuc2V0KG1vZGVsLnBhcnNlKHJlc3AsIG9wdGlvbnMpLCBvcHRpb25zKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoc3VjY2Vzcykgc3VjY2Vzcyhtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICAgIG1vZGVsLnRyaWdnZXIoJ3N5bmMnLCBtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICB9O1xuICAgICAgd3JhcEVycm9yKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXMuc3luYygncmVhZCcsIHRoaXMsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgYSBoYXNoIG9mIG1vZGVsIGF0dHJpYnV0ZXMsIGFuZCBzeW5jIHRoZSBtb2RlbCB0byB0aGUgc2VydmVyLlxuICAgIC8vIElmIHRoZSBzZXJ2ZXIgcmV0dXJucyBhbiBhdHRyaWJ1dGVzIGhhc2ggdGhhdCBkaWZmZXJzLCB0aGUgbW9kZWwnc1xuICAgIC8vIHN0YXRlIHdpbGwgYmUgYHNldGAgYWdhaW4uXG4gICAgc2F2ZTogZnVuY3Rpb24oa2V5LCB2YWwsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBhdHRycywgbWV0aG9kLCB4aHIsIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG5cbiAgICAgIC8vIEhhbmRsZSBib3RoIGBcImtleVwiLCB2YWx1ZWAgYW5kIGB7a2V5OiB2YWx1ZX1gIC1zdHlsZSBhcmd1bWVudHMuXG4gICAgICBpZiAoa2V5ID09IG51bGwgfHwgdHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYXR0cnMgPSBrZXk7XG4gICAgICAgIG9wdGlvbnMgPSB2YWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAoYXR0cnMgPSB7fSlba2V5XSA9IHZhbDtcbiAgICAgIH1cblxuICAgICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHt2YWxpZGF0ZTogdHJ1ZX0sIG9wdGlvbnMpO1xuXG4gICAgICAvLyBJZiB3ZSdyZSBub3Qgd2FpdGluZyBhbmQgYXR0cmlidXRlcyBleGlzdCwgc2F2ZSBhY3RzIGFzXG4gICAgICAvLyBgc2V0KGF0dHIpLnNhdmUobnVsbCwgb3B0cylgIHdpdGggdmFsaWRhdGlvbi4gT3RoZXJ3aXNlLCBjaGVjayBpZlxuICAgICAgLy8gdGhlIG1vZGVsIHdpbGwgYmUgdmFsaWQgd2hlbiB0aGUgYXR0cmlidXRlcywgaWYgYW55LCBhcmUgc2V0LlxuICAgICAgaWYgKGF0dHJzICYmICFvcHRpb25zLndhaXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNldChhdHRycywgb3B0aW9ucykpIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdGhpcy5fdmFsaWRhdGUoYXR0cnMsIG9wdGlvbnMpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB0ZW1wb3JhcnkgYXR0cmlidXRlcyBpZiBge3dhaXQ6IHRydWV9YC5cbiAgICAgIGlmIChhdHRycyAmJiBvcHRpb25zLndhaXQpIHtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gXy5leHRlbmQoe30sIGF0dHJpYnV0ZXMsIGF0dHJzKTtcbiAgICAgIH1cblxuICAgICAgLy8gQWZ0ZXIgYSBzdWNjZXNzZnVsIHNlcnZlci1zaWRlIHNhdmUsIHRoZSBjbGllbnQgaXMgKG9wdGlvbmFsbHkpXG4gICAgICAvLyB1cGRhdGVkIHdpdGggdGhlIHNlcnZlci1zaWRlIHN0YXRlLlxuICAgICAgaWYgKG9wdGlvbnMucGFyc2UgPT09IHZvaWQgMCkgb3B0aW9ucy5wYXJzZSA9IHRydWU7XG4gICAgICB2YXIgbW9kZWwgPSB0aGlzO1xuICAgICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XG4gICAgICBvcHRpb25zLnN1Y2Nlc3MgPSBmdW5jdGlvbihyZXNwKSB7XG4gICAgICAgIC8vIEVuc3VyZSBhdHRyaWJ1dGVzIGFyZSByZXN0b3JlZCBkdXJpbmcgc3luY2hyb25vdXMgc2F2ZXMuXG4gICAgICAgIG1vZGVsLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgICAgICB2YXIgc2VydmVyQXR0cnMgPSBtb2RlbC5wYXJzZShyZXNwLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKG9wdGlvbnMud2FpdCkgc2VydmVyQXR0cnMgPSBfLmV4dGVuZChhdHRycyB8fCB7fSwgc2VydmVyQXR0cnMpO1xuICAgICAgICBpZiAoXy5pc09iamVjdChzZXJ2ZXJBdHRycykgJiYgIW1vZGVsLnNldChzZXJ2ZXJBdHRycywgb3B0aW9ucykpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHN1Y2Nlc3MobW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgICBtb2RlbC50cmlnZ2VyKCdzeW5jJywgbW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgfTtcbiAgICAgIHdyYXBFcnJvcih0aGlzLCBvcHRpb25zKTtcblxuICAgICAgbWV0aG9kID0gdGhpcy5pc05ldygpID8gJ2NyZWF0ZScgOiAob3B0aW9ucy5wYXRjaCA/ICdwYXRjaCcgOiAndXBkYXRlJyk7XG4gICAgICBpZiAobWV0aG9kID09PSAncGF0Y2gnKSBvcHRpb25zLmF0dHJzID0gYXR0cnM7XG4gICAgICB4aHIgPSB0aGlzLnN5bmMobWV0aG9kLCB0aGlzLCBvcHRpb25zKTtcblxuICAgICAgLy8gUmVzdG9yZSBhdHRyaWJ1dGVzLlxuICAgICAgaWYgKGF0dHJzICYmIG9wdGlvbnMud2FpdCkgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcblxuICAgICAgcmV0dXJuIHhocjtcbiAgICB9LFxuXG4gICAgLy8gRGVzdHJveSB0aGlzIG1vZGVsIG9uIHRoZSBzZXJ2ZXIgaWYgaXQgd2FzIGFscmVhZHkgcGVyc2lzdGVkLlxuICAgIC8vIE9wdGltaXN0aWNhbGx5IHJlbW92ZXMgdGhlIG1vZGVsIGZyb20gaXRzIGNvbGxlY3Rpb24sIGlmIGl0IGhhcyBvbmUuXG4gICAgLy8gSWYgYHdhaXQ6IHRydWVgIGlzIHBhc3NlZCwgd2FpdHMgZm9yIHRoZSBzZXJ2ZXIgdG8gcmVzcG9uZCBiZWZvcmUgcmVtb3ZhbC5cbiAgICBkZXN0cm95OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyA/IF8uY2xvbmUob3B0aW9ucykgOiB7fTtcbiAgICAgIHZhciBtb2RlbCA9IHRoaXM7XG4gICAgICB2YXIgc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcztcblxuICAgICAgdmFyIGRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbW9kZWwudHJpZ2dlcignZGVzdHJveScsIG1vZGVsLCBtb2RlbC5jb2xsZWN0aW9uLCBvcHRpb25zKTtcbiAgICAgIH07XG5cbiAgICAgIG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgICAgaWYgKG9wdGlvbnMud2FpdCB8fCBtb2RlbC5pc05ldygpKSBkZXN0cm95KCk7XG4gICAgICAgIGlmIChzdWNjZXNzKSBzdWNjZXNzKG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKCFtb2RlbC5pc05ldygpKSBtb2RlbC50cmlnZ2VyKCdzeW5jJywgbW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuaXNOZXcoKSkge1xuICAgICAgICBvcHRpb25zLnN1Y2Nlc3MoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgd3JhcEVycm9yKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgICB2YXIgeGhyID0gdGhpcy5zeW5jKCdkZWxldGUnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgIGlmICghb3B0aW9ucy53YWl0KSBkZXN0cm95KCk7XG4gICAgICByZXR1cm4geGhyO1xuICAgIH0sXG5cbiAgICAvLyBEZWZhdWx0IFVSTCBmb3IgdGhlIG1vZGVsJ3MgcmVwcmVzZW50YXRpb24gb24gdGhlIHNlcnZlciAtLSBpZiB5b3UncmVcbiAgICAvLyB1c2luZyBCYWNrYm9uZSdzIHJlc3RmdWwgbWV0aG9kcywgb3ZlcnJpZGUgdGhpcyB0byBjaGFuZ2UgdGhlIGVuZHBvaW50XG4gICAgLy8gdGhhdCB3aWxsIGJlIGNhbGxlZC5cbiAgICB1cmw6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGJhc2UgPSBfLnJlc3VsdCh0aGlzLCAndXJsUm9vdCcpIHx8IF8ucmVzdWx0KHRoaXMuY29sbGVjdGlvbiwgJ3VybCcpIHx8IHVybEVycm9yKCk7XG4gICAgICBpZiAodGhpcy5pc05ldygpKSByZXR1cm4gYmFzZTtcbiAgICAgIHJldHVybiBiYXNlICsgKGJhc2UuY2hhckF0KGJhc2UubGVuZ3RoIC0gMSkgPT09ICcvJyA/ICcnIDogJy8nKSArIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmlkKTtcbiAgICB9LFxuXG4gICAgLy8gKipwYXJzZSoqIGNvbnZlcnRzIGEgcmVzcG9uc2UgaW50byB0aGUgaGFzaCBvZiBhdHRyaWJ1dGVzIHRvIGJlIGBzZXRgIG9uXG4gICAgLy8gdGhlIG1vZGVsLiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBpcyBqdXN0IHRvIHBhc3MgdGhlIHJlc3BvbnNlIGFsb25nLlxuICAgIHBhcnNlOiBmdW5jdGlvbihyZXNwLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gcmVzcDtcbiAgICB9LFxuXG4gICAgLy8gQ3JlYXRlIGEgbmV3IG1vZGVsIHdpdGggaWRlbnRpY2FsIGF0dHJpYnV0ZXMgdG8gdGhpcyBvbmUuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuYXR0cmlidXRlcyk7XG4gICAgfSxcblxuICAgIC8vIEEgbW9kZWwgaXMgbmV3IGlmIGl0IGhhcyBuZXZlciBiZWVuIHNhdmVkIHRvIHRoZSBzZXJ2ZXIsIGFuZCBsYWNrcyBhbiBpZC5cbiAgICBpc05ldzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5pZCA9PSBudWxsO1xuICAgIH0sXG5cbiAgICAvLyBDaGVjayBpZiB0aGUgbW9kZWwgaXMgY3VycmVudGx5IGluIGEgdmFsaWQgc3RhdGUuXG4gICAgaXNWYWxpZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZhbGlkYXRlKHt9LCBfLmV4dGVuZChvcHRpb25zIHx8IHt9LCB7IHZhbGlkYXRlOiB0cnVlIH0pKTtcbiAgICB9LFxuXG4gICAgLy8gUnVuIHZhbGlkYXRpb24gYWdhaW5zdCB0aGUgbmV4dCBjb21wbGV0ZSBzZXQgb2YgbW9kZWwgYXR0cmlidXRlcyxcbiAgICAvLyByZXR1cm5pbmcgYHRydWVgIGlmIGFsbCBpcyB3ZWxsLiBPdGhlcndpc2UsIGZpcmUgYW4gYFwiaW52YWxpZFwiYCBldmVudC5cbiAgICBfdmFsaWRhdGU6IGZ1bmN0aW9uKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIW9wdGlvbnMudmFsaWRhdGUgfHwgIXRoaXMudmFsaWRhdGUpIHJldHVybiB0cnVlO1xuICAgICAgYXR0cnMgPSBfLmV4dGVuZCh7fSwgdGhpcy5hdHRyaWJ1dGVzLCBhdHRycyk7XG4gICAgICB2YXIgZXJyb3IgPSB0aGlzLnZhbGlkYXRpb25FcnJvciA9IHRoaXMudmFsaWRhdGUoYXR0cnMsIG9wdGlvbnMpIHx8IG51bGw7XG4gICAgICBpZiAoIWVycm9yKSByZXR1cm4gdHJ1ZTtcbiAgICAgIHRoaXMudHJpZ2dlcignaW52YWxpZCcsIHRoaXMsIGVycm9yLCBfLmV4dGVuZChvcHRpb25zLCB7dmFsaWRhdGlvbkVycm9yOiBlcnJvcn0pKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgLy8gVW5kZXJzY29yZSBtZXRob2RzIHRoYXQgd2Ugd2FudCB0byBpbXBsZW1lbnQgb24gdGhlIE1vZGVsLlxuICB2YXIgbW9kZWxNZXRob2RzID0gWydrZXlzJywgJ3ZhbHVlcycsICdwYWlycycsICdpbnZlcnQnLCAncGljaycsICdvbWl0J107XG5cbiAgLy8gTWl4IGluIGVhY2ggVW5kZXJzY29yZSBtZXRob2QgYXMgYSBwcm94eSB0byBgTW9kZWwjYXR0cmlidXRlc2AuXG4gIF8uZWFjaChtb2RlbE1ldGhvZHMsIGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgIE1vZGVsLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIGFyZ3MudW5zaGlmdCh0aGlzLmF0dHJpYnV0ZXMpO1xuICAgICAgcmV0dXJuIF9bbWV0aG9kXS5hcHBseShfLCBhcmdzKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBCYWNrYm9uZS5Db2xsZWN0aW9uXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBJZiBtb2RlbHMgdGVuZCB0byByZXByZXNlbnQgYSBzaW5nbGUgcm93IG9mIGRhdGEsIGEgQmFja2JvbmUgQ29sbGVjdGlvbiBpc1xuICAvLyBtb3JlIGFuYWxhZ291cyB0byBhIHRhYmxlIGZ1bGwgb2YgZGF0YSAuLi4gb3IgYSBzbWFsbCBzbGljZSBvciBwYWdlIG9mIHRoYXRcbiAgLy8gdGFibGUsIG9yIGEgY29sbGVjdGlvbiBvZiByb3dzIHRoYXQgYmVsb25nIHRvZ2V0aGVyIGZvciBhIHBhcnRpY3VsYXIgcmVhc29uXG4gIC8vIC0tIGFsbCBvZiB0aGUgbWVzc2FnZXMgaW4gdGhpcyBwYXJ0aWN1bGFyIGZvbGRlciwgYWxsIG9mIHRoZSBkb2N1bWVudHNcbiAgLy8gYmVsb25naW5nIHRvIHRoaXMgcGFydGljdWxhciBhdXRob3IsIGFuZCBzbyBvbi4gQ29sbGVjdGlvbnMgbWFpbnRhaW5cbiAgLy8gaW5kZXhlcyBvZiB0aGVpciBtb2RlbHMsIGJvdGggaW4gb3JkZXIsIGFuZCBmb3IgbG9va3VwIGJ5IGBpZGAuXG5cbiAgLy8gQ3JlYXRlIGEgbmV3ICoqQ29sbGVjdGlvbioqLCBwZXJoYXBzIHRvIGNvbnRhaW4gYSBzcGVjaWZpYyB0eXBlIG9mIGBtb2RlbGAuXG4gIC8vIElmIGEgYGNvbXBhcmF0b3JgIGlzIHNwZWNpZmllZCwgdGhlIENvbGxlY3Rpb24gd2lsbCBtYWludGFpblxuICAvLyBpdHMgbW9kZWxzIGluIHNvcnQgb3JkZXIsIGFzIHRoZXkncmUgYWRkZWQgYW5kIHJlbW92ZWQuXG4gIHZhciBDb2xsZWN0aW9uID0gQmFja2JvbmUuQ29sbGVjdGlvbiA9IGZ1bmN0aW9uKG1vZGVscywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgaWYgKG9wdGlvbnMubW9kZWwpIHRoaXMubW9kZWwgPSBvcHRpb25zLm1vZGVsO1xuICAgIGlmIChvcHRpb25zLmNvbXBhcmF0b3IgIT09IHZvaWQgMCkgdGhpcy5jb21wYXJhdG9yID0gb3B0aW9ucy5jb21wYXJhdG9yO1xuICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgdGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKG1vZGVscykgdGhpcy5yZXNldChtb2RlbHMsIF8uZXh0ZW5kKHtzaWxlbnQ6IHRydWV9LCBvcHRpb25zKSk7XG4gIH07XG5cbiAgLy8gRGVmYXVsdCBvcHRpb25zIGZvciBgQ29sbGVjdGlvbiNzZXRgLlxuICB2YXIgc2V0T3B0aW9ucyA9IHthZGQ6IHRydWUsIHJlbW92ZTogdHJ1ZSwgbWVyZ2U6IHRydWV9O1xuICB2YXIgYWRkT3B0aW9ucyA9IHthZGQ6IHRydWUsIHJlbW92ZTogZmFsc2V9O1xuXG4gIC8vIERlZmluZSB0aGUgQ29sbGVjdGlvbidzIGluaGVyaXRhYmxlIG1ldGhvZHMuXG4gIF8uZXh0ZW5kKENvbGxlY3Rpb24ucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIC8vIFRoZSBkZWZhdWx0IG1vZGVsIGZvciBhIGNvbGxlY3Rpb24gaXMganVzdCBhICoqQmFja2JvbmUuTW9kZWwqKi5cbiAgICAvLyBUaGlzIHNob3VsZCBiZSBvdmVycmlkZGVuIGluIG1vc3QgY2FzZXMuXG4gICAgbW9kZWw6IE1vZGVsLFxuXG4gICAgLy8gSW5pdGlhbGl6ZSBpcyBhbiBlbXB0eSBmdW5jdGlvbiBieSBkZWZhdWx0LiBPdmVycmlkZSBpdCB3aXRoIHlvdXIgb3duXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gbG9naWMuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKXt9LFxuXG4gICAgLy8gVGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYSBDb2xsZWN0aW9uIGlzIGFuIGFycmF5IG9mIHRoZVxuICAgIC8vIG1vZGVscycgYXR0cmlidXRlcy5cbiAgICB0b0pTT046IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihtb2RlbCl7IHJldHVybiBtb2RlbC50b0pTT04ob3B0aW9ucyk7IH0pO1xuICAgIH0sXG5cbiAgICAvLyBQcm94eSBgQmFja2JvbmUuc3luY2AgYnkgZGVmYXVsdC5cbiAgICBzeW5jOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBCYWNrYm9uZS5zeW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8vIEFkZCBhIG1vZGVsLCBvciBsaXN0IG9mIG1vZGVscyB0byB0aGUgc2V0LlxuICAgIGFkZDogZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXQobW9kZWxzLCBfLmV4dGVuZCh7bWVyZ2U6IGZhbHNlfSwgb3B0aW9ucywgYWRkT3B0aW9ucykpO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgYSBtb2RlbCwgb3IgYSBsaXN0IG9mIG1vZGVscyBmcm9tIHRoZSBzZXQuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBzaW5ndWxhciA9ICFfLmlzQXJyYXkobW9kZWxzKTtcbiAgICAgIG1vZGVscyA9IHNpbmd1bGFyID8gW21vZGVsc10gOiBfLmNsb25lKG1vZGVscyk7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgICAgdmFyIGksIGwsIGluZGV4LCBtb2RlbDtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBtb2RlbHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG1vZGVsID0gbW9kZWxzW2ldID0gdGhpcy5nZXQobW9kZWxzW2ldKTtcbiAgICAgICAgaWYgKCFtb2RlbCkgY29udGludWU7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ieUlkW21vZGVsLmlkXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2J5SWRbbW9kZWwuY2lkXTtcbiAgICAgICAgaW5kZXggPSB0aGlzLmluZGV4T2YobW9kZWwpO1xuICAgICAgICB0aGlzLm1vZGVscy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB0aGlzLmxlbmd0aC0tO1xuICAgICAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgb3B0aW9ucy5pbmRleCA9IGluZGV4O1xuICAgICAgICAgIG1vZGVsLnRyaWdnZXIoJ3JlbW92ZScsIG1vZGVsLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZW1vdmVSZWZlcmVuY2UobW9kZWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNpbmd1bGFyID8gbW9kZWxzWzBdIDogbW9kZWxzO1xuICAgIH0sXG5cbiAgICAvLyBVcGRhdGUgYSBjb2xsZWN0aW9uIGJ5IGBzZXRgLWluZyBhIG5ldyBsaXN0IG9mIG1vZGVscywgYWRkaW5nIG5ldyBvbmVzLFxuICAgIC8vIHJlbW92aW5nIG1vZGVscyB0aGF0IGFyZSBubyBsb25nZXIgcHJlc2VudCwgYW5kIG1lcmdpbmcgbW9kZWxzIHRoYXRcbiAgICAvLyBhbHJlYWR5IGV4aXN0IGluIHRoZSBjb2xsZWN0aW9uLCBhcyBuZWNlc3NhcnkuIFNpbWlsYXIgdG8gKipNb2RlbCNzZXQqKixcbiAgICAvLyB0aGUgY29yZSBvcGVyYXRpb24gZm9yIHVwZGF0aW5nIHRoZSBkYXRhIGNvbnRhaW5lZCBieSB0aGUgY29sbGVjdGlvbi5cbiAgICBzZXQ6IGZ1bmN0aW9uKG1vZGVscywgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IF8uZGVmYXVsdHMoe30sIG9wdGlvbnMsIHNldE9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMucGFyc2UpIG1vZGVscyA9IHRoaXMucGFyc2UobW9kZWxzLCBvcHRpb25zKTtcbiAgICAgIHZhciBzaW5ndWxhciA9ICFfLmlzQXJyYXkobW9kZWxzKTtcbiAgICAgIG1vZGVscyA9IHNpbmd1bGFyID8gKG1vZGVscyA/IFttb2RlbHNdIDogW10pIDogXy5jbG9uZShtb2RlbHMpO1xuICAgICAgdmFyIGksIGwsIGlkLCBtb2RlbCwgYXR0cnMsIGV4aXN0aW5nLCBzb3J0O1xuICAgICAgdmFyIGF0ID0gb3B0aW9ucy5hdDtcbiAgICAgIHZhciB0YXJnZXRNb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICB2YXIgc29ydGFibGUgPSB0aGlzLmNvbXBhcmF0b3IgJiYgKGF0ID09IG51bGwpICYmIG9wdGlvbnMuc29ydCAhPT0gZmFsc2U7XG4gICAgICB2YXIgc29ydEF0dHIgPSBfLmlzU3RyaW5nKHRoaXMuY29tcGFyYXRvcikgPyB0aGlzLmNvbXBhcmF0b3IgOiBudWxsO1xuICAgICAgdmFyIHRvQWRkID0gW10sIHRvUmVtb3ZlID0gW10sIG1vZGVsTWFwID0ge307XG4gICAgICB2YXIgYWRkID0gb3B0aW9ucy5hZGQsIG1lcmdlID0gb3B0aW9ucy5tZXJnZSwgcmVtb3ZlID0gb3B0aW9ucy5yZW1vdmU7XG4gICAgICB2YXIgb3JkZXIgPSAhc29ydGFibGUgJiYgYWRkICYmIHJlbW92ZSA/IFtdIDogZmFsc2U7XG5cbiAgICAgIC8vIFR1cm4gYmFyZSBvYmplY3RzIGludG8gbW9kZWwgcmVmZXJlbmNlcywgYW5kIHByZXZlbnQgaW52YWxpZCBtb2RlbHNcbiAgICAgIC8vIGZyb20gYmVpbmcgYWRkZWQuXG4gICAgICBmb3IgKGkgPSAwLCBsID0gbW9kZWxzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBhdHRycyA9IG1vZGVsc1tpXTtcbiAgICAgICAgaWYgKGF0dHJzIGluc3RhbmNlb2YgTW9kZWwpIHtcbiAgICAgICAgICBpZCA9IG1vZGVsID0gYXR0cnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWQgPSBhdHRyc1t0YXJnZXRNb2RlbC5wcm90b3R5cGUuaWRBdHRyaWJ1dGVdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgYSBkdXBsaWNhdGUgaXMgZm91bmQsIHByZXZlbnQgaXQgZnJvbSBiZWluZyBhZGRlZCBhbmRcbiAgICAgICAgLy8gb3B0aW9uYWxseSBtZXJnZSBpdCBpbnRvIHRoZSBleGlzdGluZyBtb2RlbC5cbiAgICAgICAgaWYgKGV4aXN0aW5nID0gdGhpcy5nZXQoaWQpKSB7XG4gICAgICAgICAgaWYgKHJlbW92ZSkgbW9kZWxNYXBbZXhpc3RpbmcuY2lkXSA9IHRydWU7XG4gICAgICAgICAgaWYgKG1lcmdlKSB7XG4gICAgICAgICAgICBhdHRycyA9IGF0dHJzID09PSBtb2RlbCA/IG1vZGVsLmF0dHJpYnV0ZXMgOiBhdHRycztcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBhcnNlKSBhdHRycyA9IGV4aXN0aW5nLnBhcnNlKGF0dHJzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGV4aXN0aW5nLnNldChhdHRycywgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoc29ydGFibGUgJiYgIXNvcnQgJiYgZXhpc3RpbmcuaGFzQ2hhbmdlZChzb3J0QXR0cikpIHNvcnQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtb2RlbHNbaV0gPSBleGlzdGluZztcblxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgbmV3LCB2YWxpZCBtb2RlbCwgcHVzaCBpdCB0byB0aGUgYHRvQWRkYCBsaXN0LlxuICAgICAgICB9IGVsc2UgaWYgKGFkZCkge1xuICAgICAgICAgIG1vZGVsID0gbW9kZWxzW2ldID0gdGhpcy5fcHJlcGFyZU1vZGVsKGF0dHJzLCBvcHRpb25zKTtcbiAgICAgICAgICBpZiAoIW1vZGVsKSBjb250aW51ZTtcbiAgICAgICAgICB0b0FkZC5wdXNoKG1vZGVsKTtcblxuICAgICAgICAgIC8vIExpc3RlbiB0byBhZGRlZCBtb2RlbHMnIGV2ZW50cywgYW5kIGluZGV4IG1vZGVscyBmb3IgbG9va3VwIGJ5XG4gICAgICAgICAgLy8gYGlkYCBhbmQgYnkgYGNpZGAuXG4gICAgICAgICAgbW9kZWwub24oJ2FsbCcsIHRoaXMuX29uTW9kZWxFdmVudCwgdGhpcyk7XG4gICAgICAgICAgdGhpcy5fYnlJZFttb2RlbC5jaWRdID0gbW9kZWw7XG4gICAgICAgICAgaWYgKG1vZGVsLmlkICE9IG51bGwpIHRoaXMuX2J5SWRbbW9kZWwuaWRdID0gbW9kZWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yZGVyKSBvcmRlci5wdXNoKGV4aXN0aW5nIHx8IG1vZGVsKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIG5vbmV4aXN0ZW50IG1vZGVscyBpZiBhcHByb3ByaWF0ZS5cbiAgICAgIGlmIChyZW1vdmUpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgaWYgKCFtb2RlbE1hcFsobW9kZWwgPSB0aGlzLm1vZGVsc1tpXSkuY2lkXSkgdG9SZW1vdmUucHVzaChtb2RlbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvUmVtb3ZlLmxlbmd0aCkgdGhpcy5yZW1vdmUodG9SZW1vdmUsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICAvLyBTZWUgaWYgc29ydGluZyBpcyBuZWVkZWQsIHVwZGF0ZSBgbGVuZ3RoYCBhbmQgc3BsaWNlIGluIG5ldyBtb2RlbHMuXG4gICAgICBpZiAodG9BZGQubGVuZ3RoIHx8IChvcmRlciAmJiBvcmRlci5sZW5ndGgpKSB7XG4gICAgICAgIGlmIChzb3J0YWJsZSkgc29ydCA9IHRydWU7XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IHRvQWRkLmxlbmd0aDtcbiAgICAgICAgaWYgKGF0ICE9IG51bGwpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gdG9BZGQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGVscy5zcGxpY2UoYXQgKyBpLCAwLCB0b0FkZFtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChvcmRlcikgdGhpcy5tb2RlbHMubGVuZ3RoID0gMDtcbiAgICAgICAgICB2YXIgb3JkZXJlZE1vZGVscyA9IG9yZGVyIHx8IHRvQWRkO1xuICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBvcmRlcmVkTW9kZWxzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5tb2RlbHMucHVzaChvcmRlcmVkTW9kZWxzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gU2lsZW50bHkgc29ydCB0aGUgY29sbGVjdGlvbiBpZiBhcHByb3ByaWF0ZS5cbiAgICAgIGlmIChzb3J0KSB0aGlzLnNvcnQoe3NpbGVudDogdHJ1ZX0pO1xuXG4gICAgICAvLyBVbmxlc3Mgc2lsZW5jZWQsIGl0J3MgdGltZSB0byBmaXJlIGFsbCBhcHByb3ByaWF0ZSBhZGQvc29ydCBldmVudHMuXG4gICAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSB0b0FkZC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAobW9kZWwgPSB0b0FkZFtpXSkudHJpZ2dlcignYWRkJywgbW9kZWwsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3J0IHx8IChvcmRlciAmJiBvcmRlci5sZW5ndGgpKSB0aGlzLnRyaWdnZXIoJ3NvcnQnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gUmV0dXJuIHRoZSBhZGRlZCAob3IgbWVyZ2VkKSBtb2RlbCAob3IgbW9kZWxzKS5cbiAgICAgIHJldHVybiBzaW5ndWxhciA/IG1vZGVsc1swXSA6IG1vZGVscztcbiAgICB9LFxuXG4gICAgLy8gV2hlbiB5b3UgaGF2ZSBtb3JlIGl0ZW1zIHRoYW4geW91IHdhbnQgdG8gYWRkIG9yIHJlbW92ZSBpbmRpdmlkdWFsbHksXG4gICAgLy8geW91IGNhbiByZXNldCB0aGUgZW50aXJlIHNldCB3aXRoIGEgbmV3IGxpc3Qgb2YgbW9kZWxzLCB3aXRob3V0IGZpcmluZ1xuICAgIC8vIGFueSBncmFudWxhciBgYWRkYCBvciBgcmVtb3ZlYCBldmVudHMuIEZpcmVzIGByZXNldGAgd2hlbiBmaW5pc2hlZC5cbiAgICAvLyBVc2VmdWwgZm9yIGJ1bGsgb3BlcmF0aW9ucyBhbmQgb3B0aW1pemF0aW9ucy5cbiAgICByZXNldDogZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLm1vZGVscy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlUmVmZXJlbmNlKHRoaXMubW9kZWxzW2ldKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMucHJldmlvdXNNb2RlbHMgPSB0aGlzLm1vZGVscztcbiAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgICBtb2RlbHMgPSB0aGlzLmFkZChtb2RlbHMsIF8uZXh0ZW5kKHtzaWxlbnQ6IHRydWV9LCBvcHRpb25zKSk7XG4gICAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB0aGlzLnRyaWdnZXIoJ3Jlc2V0JywgdGhpcywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gbW9kZWxzO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSBtb2RlbCB0byB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgIHB1c2g6IGZ1bmN0aW9uKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5hZGQobW9kZWwsIF8uZXh0ZW5kKHthdDogdGhpcy5sZW5ndGh9LCBvcHRpb25zKSk7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSBhIG1vZGVsIGZyb20gdGhlIGVuZCBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICBwb3A6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBtb2RlbCA9IHRoaXMuYXQodGhpcy5sZW5ndGggLSAxKTtcbiAgICAgIHRoaXMucmVtb3ZlKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBtb2RlbDtcbiAgICB9LFxuXG4gICAgLy8gQWRkIGEgbW9kZWwgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICB1bnNoaWZ0OiBmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuYWRkKG1vZGVsLCBfLmV4dGVuZCh7YXQ6IDB9LCBvcHRpb25zKSk7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSBhIG1vZGVsIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICBzaGlmdDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIG1vZGVsID0gdGhpcy5hdCgwKTtcbiAgICAgIHRoaXMucmVtb3ZlKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBtb2RlbDtcbiAgICB9LFxuXG4gICAgLy8gU2xpY2Ugb3V0IGEgc3ViLWFycmF5IG9mIG1vZGVscyBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuICAgIHNsaWNlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzbGljZS5hcHBseSh0aGlzLm1vZGVscywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IGEgbW9kZWwgZnJvbSB0aGUgc2V0IGJ5IGlkLlxuICAgIGdldDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgICByZXR1cm4gdGhpcy5fYnlJZFtvYmouaWRdIHx8IHRoaXMuX2J5SWRbb2JqLmNpZF0gfHwgdGhpcy5fYnlJZFtvYmpdO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIG1vZGVsIGF0IHRoZSBnaXZlbiBpbmRleC5cbiAgICBhdDogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1vZGVsc1tpbmRleF07XG4gICAgfSxcblxuICAgIC8vIFJldHVybiBtb2RlbHMgd2l0aCBtYXRjaGluZyBhdHRyaWJ1dGVzLiBVc2VmdWwgZm9yIHNpbXBsZSBjYXNlcyBvZlxuICAgIC8vIGBmaWx0ZXJgLlxuICAgIHdoZXJlOiBmdW5jdGlvbihhdHRycywgZmlyc3QpIHtcbiAgICAgIGlmIChfLmlzRW1wdHkoYXR0cnMpKSByZXR1cm4gZmlyc3QgPyB2b2lkIDAgOiBbXTtcbiAgICAgIHJldHVybiB0aGlzW2ZpcnN0ID8gJ2ZpbmQnIDogJ2ZpbHRlciddKGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBhdHRycykge1xuICAgICAgICAgIGlmIChhdHRyc1trZXldICE9PSBtb2RlbC5nZXQoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybiB0aGUgZmlyc3QgbW9kZWwgd2l0aCBtYXRjaGluZyBhdHRyaWJ1dGVzLiBVc2VmdWwgZm9yIHNpbXBsZSBjYXNlc1xuICAgIC8vIG9mIGBmaW5kYC5cbiAgICBmaW5kV2hlcmU6IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgICByZXR1cm4gdGhpcy53aGVyZShhdHRycywgdHJ1ZSk7XG4gICAgfSxcblxuICAgIC8vIEZvcmNlIHRoZSBjb2xsZWN0aW9uIHRvIHJlLXNvcnQgaXRzZWxmLiBZb3UgZG9uJ3QgbmVlZCB0byBjYWxsIHRoaXMgdW5kZXJcbiAgICAvLyBub3JtYWwgY2lyY3Vtc3RhbmNlcywgYXMgdGhlIHNldCB3aWxsIG1haW50YWluIHNvcnQgb3JkZXIgYXMgZWFjaCBpdGVtXG4gICAgLy8gaXMgYWRkZWQuXG4gICAgc29ydDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKCF0aGlzLmNvbXBhcmF0b3IpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNvcnQgYSBzZXQgd2l0aG91dCBhIGNvbXBhcmF0b3InKTtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG5cbiAgICAgIC8vIFJ1biBzb3J0IGJhc2VkIG9uIHR5cGUgb2YgYGNvbXBhcmF0b3JgLlxuICAgICAgaWYgKF8uaXNTdHJpbmcodGhpcy5jb21wYXJhdG9yKSB8fCB0aGlzLmNvbXBhcmF0b3IubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHRoaXMubW9kZWxzID0gdGhpcy5zb3J0QnkodGhpcy5jb21wYXJhdG9yLCB0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubW9kZWxzLnNvcnQoXy5iaW5kKHRoaXMuY29tcGFyYXRvciwgdGhpcykpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB0aGlzLnRyaWdnZXIoJ3NvcnQnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBQbHVjayBhbiBhdHRyaWJ1dGUgZnJvbSBlYWNoIG1vZGVsIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgIHBsdWNrOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICByZXR1cm4gXy5pbnZva2UodGhpcy5tb2RlbHMsICdnZXQnLCBhdHRyKTtcbiAgICB9LFxuXG4gICAgLy8gRmV0Y2ggdGhlIGRlZmF1bHQgc2V0IG9mIG1vZGVscyBmb3IgdGhpcyBjb2xsZWN0aW9uLCByZXNldHRpbmcgdGhlXG4gICAgLy8gY29sbGVjdGlvbiB3aGVuIHRoZXkgYXJyaXZlLiBJZiBgcmVzZXQ6IHRydWVgIGlzIHBhc3NlZCwgdGhlIHJlc3BvbnNlXG4gICAgLy8gZGF0YSB3aWxsIGJlIHBhc3NlZCB0aHJvdWdoIHRoZSBgcmVzZXRgIG1ldGhvZCBpbnN0ZWFkIG9mIGBzZXRgLlxuICAgIGZldGNoOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyA/IF8uY2xvbmUob3B0aW9ucykgOiB7fTtcbiAgICAgIGlmIChvcHRpb25zLnBhcnNlID09PSB2b2lkIDApIG9wdGlvbnMucGFyc2UgPSB0cnVlO1xuICAgICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XG4gICAgICB2YXIgY29sbGVjdGlvbiA9IHRoaXM7XG4gICAgICBvcHRpb25zLnN1Y2Nlc3MgPSBmdW5jdGlvbihyZXNwKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBvcHRpb25zLnJlc2V0ID8gJ3Jlc2V0JyA6ICdzZXQnO1xuICAgICAgICBjb2xsZWN0aW9uW21ldGhvZF0ocmVzcCwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChzdWNjZXNzKSBzdWNjZXNzKGNvbGxlY3Rpb24sIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgICBjb2xsZWN0aW9uLnRyaWdnZXIoJ3N5bmMnLCBjb2xsZWN0aW9uLCByZXNwLCBvcHRpb25zKTtcbiAgICAgIH07XG4gICAgICB3cmFwRXJyb3IodGhpcywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcy5zeW5jKCdyZWFkJywgdGhpcywgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8vIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBhIG1vZGVsIGluIHRoaXMgY29sbGVjdGlvbi4gQWRkIHRoZSBtb2RlbCB0byB0aGVcbiAgICAvLyBjb2xsZWN0aW9uIGltbWVkaWF0ZWx5LCB1bmxlc3MgYHdhaXQ6IHRydWVgIGlzIHBhc3NlZCwgaW4gd2hpY2ggY2FzZSB3ZVxuICAgIC8vIHdhaXQgZm9yIHRoZSBzZXJ2ZXIgdG8gYWdyZWUuXG4gICAgY3JlYXRlOiBmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBfLmNsb25lKG9wdGlvbnMpIDoge307XG4gICAgICBpZiAoIShtb2RlbCA9IHRoaXMuX3ByZXBhcmVNb2RlbChtb2RlbCwgb3B0aW9ucykpKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoIW9wdGlvbnMud2FpdCkgdGhpcy5hZGQobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzO1xuICAgICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XG4gICAgICBvcHRpb25zLnN1Y2Nlc3MgPSBmdW5jdGlvbihtb2RlbCwgcmVzcCwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy53YWl0KSBjb2xsZWN0aW9uLmFkZChtb2RlbCwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChzdWNjZXNzKSBzdWNjZXNzKG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgIH07XG4gICAgICBtb2RlbC5zYXZlKG51bGwsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIG1vZGVsO1xuICAgIH0sXG5cbiAgICAvLyAqKnBhcnNlKiogY29udmVydHMgYSByZXNwb25zZSBpbnRvIGEgbGlzdCBvZiBtb2RlbHMgdG8gYmUgYWRkZWQgdG8gdGhlXG4gICAgLy8gY29sbGVjdGlvbi4gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gaXMganVzdCB0byBwYXNzIGl0IHRocm91Z2guXG4gICAgcGFyc2U6IGZ1bmN0aW9uKHJlc3AsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiByZXNwO1xuICAgIH0sXG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgY29sbGVjdGlvbiB3aXRoIGFuIGlkZW50aWNhbCBsaXN0IG9mIG1vZGVscyBhcyB0aGlzIG9uZS5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5tb2RlbHMpO1xuICAgIH0sXG5cbiAgICAvLyBQcml2YXRlIG1ldGhvZCB0byByZXNldCBhbGwgaW50ZXJuYWwgc3RhdGUuIENhbGxlZCB3aGVuIHRoZSBjb2xsZWN0aW9uXG4gICAgLy8gaXMgZmlyc3QgaW5pdGlhbGl6ZWQgb3IgcmVzZXQuXG4gICAgX3Jlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMubW9kZWxzID0gW107XG4gICAgICB0aGlzLl9ieUlkICA9IHt9O1xuICAgIH0sXG5cbiAgICAvLyBQcmVwYXJlIGEgaGFzaCBvZiBhdHRyaWJ1dGVzIChvciBvdGhlciBtb2RlbCkgdG8gYmUgYWRkZWQgdG8gdGhpc1xuICAgIC8vIGNvbGxlY3Rpb24uXG4gICAgX3ByZXBhcmVNb2RlbDogZnVuY3Rpb24oYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChhdHRycyBpbnN0YW5jZW9mIE1vZGVsKSB7XG4gICAgICAgIGlmICghYXR0cnMuY29sbGVjdGlvbikgYXR0cnMuY29sbGVjdGlvbiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBhdHRycztcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gXy5jbG9uZShvcHRpb25zKSA6IHt9O1xuICAgICAgb3B0aW9ucy5jb2xsZWN0aW9uID0gdGhpcztcbiAgICAgIHZhciBtb2RlbCA9IG5ldyB0aGlzLm1vZGVsKGF0dHJzLCBvcHRpb25zKTtcbiAgICAgIGlmICghbW9kZWwudmFsaWRhdGlvbkVycm9yKSByZXR1cm4gbW9kZWw7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2ludmFsaWQnLCB0aGlzLCBtb2RlbC52YWxpZGF0aW9uRXJyb3IsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvLyBJbnRlcm5hbCBtZXRob2QgdG8gc2V2ZXIgYSBtb2RlbCdzIHRpZXMgdG8gYSBjb2xsZWN0aW9uLlxuICAgIF9yZW1vdmVSZWZlcmVuY2U6IGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICBpZiAodGhpcyA9PT0gbW9kZWwuY29sbGVjdGlvbikgZGVsZXRlIG1vZGVsLmNvbGxlY3Rpb247XG4gICAgICBtb2RlbC5vZmYoJ2FsbCcsIHRoaXMuX29uTW9kZWxFdmVudCwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8vIEludGVybmFsIG1ldGhvZCBjYWxsZWQgZXZlcnkgdGltZSBhIG1vZGVsIGluIHRoZSBzZXQgZmlyZXMgYW4gZXZlbnQuXG4gICAgLy8gU2V0cyBuZWVkIHRvIHVwZGF0ZSB0aGVpciBpbmRleGVzIHdoZW4gbW9kZWxzIGNoYW5nZSBpZHMuIEFsbCBvdGhlclxuICAgIC8vIGV2ZW50cyBzaW1wbHkgcHJveHkgdGhyb3VnaC4gXCJhZGRcIiBhbmQgXCJyZW1vdmVcIiBldmVudHMgdGhhdCBvcmlnaW5hdGVcbiAgICAvLyBpbiBvdGhlciBjb2xsZWN0aW9ucyBhcmUgaWdub3JlZC5cbiAgICBfb25Nb2RlbEV2ZW50OiBmdW5jdGlvbihldmVudCwgbW9kZWwsIGNvbGxlY3Rpb24sIG9wdGlvbnMpIHtcbiAgICAgIGlmICgoZXZlbnQgPT09ICdhZGQnIHx8IGV2ZW50ID09PSAncmVtb3ZlJykgJiYgY29sbGVjdGlvbiAhPT0gdGhpcykgcmV0dXJuO1xuICAgICAgaWYgKGV2ZW50ID09PSAnZGVzdHJveScpIHRoaXMucmVtb3ZlKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgIGlmIChtb2RlbCAmJiBldmVudCA9PT0gJ2NoYW5nZTonICsgbW9kZWwuaWRBdHRyaWJ1dGUpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2J5SWRbbW9kZWwucHJldmlvdXMobW9kZWwuaWRBdHRyaWJ1dGUpXTtcbiAgICAgICAgaWYgKG1vZGVsLmlkICE9IG51bGwpIHRoaXMuX2J5SWRbbW9kZWwuaWRdID0gbW9kZWw7XG4gICAgICB9XG4gICAgICB0aGlzLnRyaWdnZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgLy8gVW5kZXJzY29yZSBtZXRob2RzIHRoYXQgd2Ugd2FudCB0byBpbXBsZW1lbnQgb24gdGhlIENvbGxlY3Rpb24uXG4gIC8vIDkwJSBvZiB0aGUgY29yZSB1c2VmdWxuZXNzIG9mIEJhY2tib25lIENvbGxlY3Rpb25zIGlzIGFjdHVhbGx5IGltcGxlbWVudGVkXG4gIC8vIHJpZ2h0IGhlcmU6XG4gIHZhciBtZXRob2RzID0gWydmb3JFYWNoJywgJ2VhY2gnLCAnbWFwJywgJ2NvbGxlY3QnLCAncmVkdWNlJywgJ2ZvbGRsJyxcbiAgICAnaW5qZWN0JywgJ3JlZHVjZVJpZ2h0JywgJ2ZvbGRyJywgJ2ZpbmQnLCAnZGV0ZWN0JywgJ2ZpbHRlcicsICdzZWxlY3QnLFxuICAgICdyZWplY3QnLCAnZXZlcnknLCAnYWxsJywgJ3NvbWUnLCAnYW55JywgJ2luY2x1ZGUnLCAnY29udGFpbnMnLCAnaW52b2tlJyxcbiAgICAnbWF4JywgJ21pbicsICd0b0FycmF5JywgJ3NpemUnLCAnZmlyc3QnLCAnaGVhZCcsICd0YWtlJywgJ2luaXRpYWwnLCAncmVzdCcsXG4gICAgJ3RhaWwnLCAnZHJvcCcsICdsYXN0JywgJ3dpdGhvdXQnLCAnZGlmZmVyZW5jZScsICdpbmRleE9mJywgJ3NodWZmbGUnLFxuICAgICdsYXN0SW5kZXhPZicsICdpc0VtcHR5JywgJ2NoYWluJ107XG5cbiAgLy8gTWl4IGluIGVhY2ggVW5kZXJzY29yZSBtZXRob2QgYXMgYSBwcm94eSB0byBgQ29sbGVjdGlvbiNtb2RlbHNgLlxuICBfLmVhY2gobWV0aG9kcywgZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgQ29sbGVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICBhcmdzLnVuc2hpZnQodGhpcy5tb2RlbHMpO1xuICAgICAgcmV0dXJuIF9bbWV0aG9kXS5hcHBseShfLCBhcmdzKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBVbmRlcnNjb3JlIG1ldGhvZHMgdGhhdCB0YWtlIGEgcHJvcGVydHkgbmFtZSBhcyBhbiBhcmd1bWVudC5cbiAgdmFyIGF0dHJpYnV0ZU1ldGhvZHMgPSBbJ2dyb3VwQnknLCAnY291bnRCeScsICdzb3J0QnknXTtcblxuICAvLyBVc2UgYXR0cmlidXRlcyBpbnN0ZWFkIG9mIHByb3BlcnRpZXMuXG4gIF8uZWFjaChhdHRyaWJ1dGVNZXRob2RzLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgICBDb2xsZWN0aW9uLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odmFsdWUsIGNvbnRleHQpIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IF8uaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZSA6IGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICAgIHJldHVybiBtb2RlbC5nZXQodmFsdWUpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBfW21ldGhvZF0odGhpcy5tb2RlbHMsIGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBCYWNrYm9uZS5WaWV3XG4gIC8vIC0tLS0tLS0tLS0tLS1cblxuICAvLyBCYWNrYm9uZSBWaWV3cyBhcmUgYWxtb3N0IG1vcmUgY29udmVudGlvbiB0aGFuIHRoZXkgYXJlIGFjdHVhbCBjb2RlLiBBIFZpZXdcbiAgLy8gaXMgc2ltcGx5IGEgSmF2YVNjcmlwdCBvYmplY3QgdGhhdCByZXByZXNlbnRzIGEgbG9naWNhbCBjaHVuayBvZiBVSSBpbiB0aGVcbiAgLy8gRE9NLiBUaGlzIG1pZ2h0IGJlIGEgc2luZ2xlIGl0ZW0sIGFuIGVudGlyZSBsaXN0LCBhIHNpZGViYXIgb3IgcGFuZWwsIG9yXG4gIC8vIGV2ZW4gdGhlIHN1cnJvdW5kaW5nIGZyYW1lIHdoaWNoIHdyYXBzIHlvdXIgd2hvbGUgYXBwLiBEZWZpbmluZyBhIGNodW5rIG9mXG4gIC8vIFVJIGFzIGEgKipWaWV3KiogYWxsb3dzIHlvdSB0byBkZWZpbmUgeW91ciBET00gZXZlbnRzIGRlY2xhcmF0aXZlbHksIHdpdGhvdXRcbiAgLy8gaGF2aW5nIHRvIHdvcnJ5IGFib3V0IHJlbmRlciBvcmRlciAuLi4gYW5kIG1ha2VzIGl0IGVhc3kgZm9yIHRoZSB2aWV3IHRvXG4gIC8vIHJlYWN0IHRvIHNwZWNpZmljIGNoYW5nZXMgaW4gdGhlIHN0YXRlIG9mIHlvdXIgbW9kZWxzLlxuXG4gIC8vIENyZWF0aW5nIGEgQmFja2JvbmUuVmlldyBjcmVhdGVzIGl0cyBpbml0aWFsIGVsZW1lbnQgb3V0c2lkZSBvZiB0aGUgRE9NLFxuICAvLyBpZiBhbiBleGlzdGluZyBlbGVtZW50IGlzIG5vdCBwcm92aWRlZC4uLlxuICB2YXIgVmlldyA9IEJhY2tib25lLlZpZXcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5jaWQgPSBfLnVuaXF1ZUlkKCd2aWV3Jyk7XG4gICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICBfLmV4dGVuZCh0aGlzLCBfLnBpY2sob3B0aW9ucywgdmlld09wdGlvbnMpKTtcbiAgICB0aGlzLl9lbnN1cmVFbGVtZW50KCk7XG4gICAgdGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5kZWxlZ2F0ZUV2ZW50cygpO1xuICB9O1xuXG4gIC8vIENhY2hlZCByZWdleCB0byBzcGxpdCBrZXlzIGZvciBgZGVsZWdhdGVgLlxuICB2YXIgZGVsZWdhdGVFdmVudFNwbGl0dGVyID0gL14oXFxTKylcXHMqKC4qKSQvO1xuXG4gIC8vIExpc3Qgb2YgdmlldyBvcHRpb25zIHRvIGJlIG1lcmdlZCBhcyBwcm9wZXJ0aWVzLlxuICB2YXIgdmlld09wdGlvbnMgPSBbJ21vZGVsJywgJ2NvbGxlY3Rpb24nLCAnZWwnLCAnaWQnLCAnYXR0cmlidXRlcycsICdjbGFzc05hbWUnLCAndGFnTmFtZScsICdldmVudHMnXTtcblxuICAvLyBTZXQgdXAgYWxsIGluaGVyaXRhYmxlICoqQmFja2JvbmUuVmlldyoqIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXG4gIF8uZXh0ZW5kKFZpZXcucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIC8vIFRoZSBkZWZhdWx0IGB0YWdOYW1lYCBvZiBhIFZpZXcncyBlbGVtZW50IGlzIGBcImRpdlwiYC5cbiAgICB0YWdOYW1lOiAnZGl2JyxcblxuICAgIC8vIGpRdWVyeSBkZWxlZ2F0ZSBmb3IgZWxlbWVudCBsb29rdXAsIHNjb3BlZCB0byBET00gZWxlbWVudHMgd2l0aGluIHRoZVxuICAgIC8vIGN1cnJlbnQgdmlldy4gVGhpcyBzaG91bGQgYmUgcHJlZmVycmVkIHRvIGdsb2JhbCBsb29rdXBzIHdoZXJlIHBvc3NpYmxlLlxuICAgICQ6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gdGhpcy4kZWwuZmluZChzZWxlY3Rvcik7XG4gICAgfSxcblxuICAgIC8vIEluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gT3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93blxuICAgIC8vIGluaXRpYWxpemF0aW9uIGxvZ2ljLlxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCl7fSxcblxuICAgIC8vICoqcmVuZGVyKiogaXMgdGhlIGNvcmUgZnVuY3Rpb24gdGhhdCB5b3VyIHZpZXcgc2hvdWxkIG92ZXJyaWRlLCBpbiBvcmRlclxuICAgIC8vIHRvIHBvcHVsYXRlIGl0cyBlbGVtZW50IChgdGhpcy5lbGApLCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBIVE1MLiBUaGVcbiAgICAvLyBjb252ZW50aW9uIGlzIGZvciAqKnJlbmRlcioqIHRvIGFsd2F5cyByZXR1cm4gYHRoaXNgLlxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIHRoaXMgdmlldyBieSB0YWtpbmcgdGhlIGVsZW1lbnQgb3V0IG9mIHRoZSBET00sIGFuZCByZW1vdmluZyBhbnlcbiAgICAvLyBhcHBsaWNhYmxlIEJhY2tib25lLkV2ZW50cyBsaXN0ZW5lcnMuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuJGVsLnJlbW92ZSgpO1xuICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gQ2hhbmdlIHRoZSB2aWV3J3MgZWxlbWVudCAoYHRoaXMuZWxgIHByb3BlcnR5KSwgaW5jbHVkaW5nIGV2ZW50XG4gICAgLy8gcmUtZGVsZWdhdGlvbi5cbiAgICBzZXRFbGVtZW50OiBmdW5jdGlvbihlbGVtZW50LCBkZWxlZ2F0ZSkge1xuICAgICAgaWYgKHRoaXMuJGVsKSB0aGlzLnVuZGVsZWdhdGVFdmVudHMoKTtcbiAgICAgIHRoaXMuJGVsID0gZWxlbWVudCBpbnN0YW5jZW9mIEJhY2tib25lLiQgPyBlbGVtZW50IDogQmFja2JvbmUuJChlbGVtZW50KTtcbiAgICAgIHRoaXMuZWwgPSB0aGlzLiRlbFswXTtcbiAgICAgIGlmIChkZWxlZ2F0ZSAhPT0gZmFsc2UpIHRoaXMuZGVsZWdhdGVFdmVudHMoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgY2FsbGJhY2tzLCB3aGVyZSBgdGhpcy5ldmVudHNgIGlzIGEgaGFzaCBvZlxuICAgIC8vXG4gICAgLy8gKntcImV2ZW50IHNlbGVjdG9yXCI6IFwiY2FsbGJhY2tcIn0qXG4gICAgLy9cbiAgICAvLyAgICAge1xuICAgIC8vICAgICAgICdtb3VzZWRvd24gLnRpdGxlJzogICdlZGl0JyxcbiAgICAvLyAgICAgICAnY2xpY2sgLmJ1dHRvbic6ICAgICAnc2F2ZScsXG4gICAgLy8gICAgICAgJ2NsaWNrIC5vcGVuJzogICAgICAgZnVuY3Rpb24oZSkgeyAuLi4gfVxuICAgIC8vICAgICB9XG4gICAgLy9cbiAgICAvLyBwYWlycy4gQ2FsbGJhY2tzIHdpbGwgYmUgYm91bmQgdG8gdGhlIHZpZXcsIHdpdGggYHRoaXNgIHNldCBwcm9wZXJseS5cbiAgICAvLyBVc2VzIGV2ZW50IGRlbGVnYXRpb24gZm9yIGVmZmljaWVuY3kuXG4gICAgLy8gT21pdHRpbmcgdGhlIHNlbGVjdG9yIGJpbmRzIHRoZSBldmVudCB0byBgdGhpcy5lbGAuXG4gICAgLy8gVGhpcyBvbmx5IHdvcmtzIGZvciBkZWxlZ2F0ZS1hYmxlIGV2ZW50czogbm90IGBmb2N1c2AsIGBibHVyYCwgYW5kXG4gICAgLy8gbm90IGBjaGFuZ2VgLCBgc3VibWl0YCwgYW5kIGByZXNldGAgaW4gSW50ZXJuZXQgRXhwbG9yZXIuXG4gICAgZGVsZWdhdGVFdmVudHM6IGZ1bmN0aW9uKGV2ZW50cykge1xuICAgICAgaWYgKCEoZXZlbnRzIHx8IChldmVudHMgPSBfLnJlc3VsdCh0aGlzLCAnZXZlbnRzJykpKSkgcmV0dXJuIHRoaXM7XG4gICAgICB0aGlzLnVuZGVsZWdhdGVFdmVudHMoKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBldmVudHMpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IGV2ZW50c1trZXldO1xuICAgICAgICBpZiAoIV8uaXNGdW5jdGlvbihtZXRob2QpKSBtZXRob2QgPSB0aGlzW2V2ZW50c1trZXldXTtcbiAgICAgICAgaWYgKCFtZXRob2QpIGNvbnRpbnVlO1xuXG4gICAgICAgIHZhciBtYXRjaCA9IGtleS5tYXRjaChkZWxlZ2F0ZUV2ZW50U3BsaXR0ZXIpO1xuICAgICAgICB2YXIgZXZlbnROYW1lID0gbWF0Y2hbMV0sIHNlbGVjdG9yID0gbWF0Y2hbMl07XG4gICAgICAgIG1ldGhvZCA9IF8uYmluZChtZXRob2QsIHRoaXMpO1xuICAgICAgICBldmVudE5hbWUgKz0gJy5kZWxlZ2F0ZUV2ZW50cycgKyB0aGlzLmNpZDtcbiAgICAgICAgaWYgKHNlbGVjdG9yID09PSAnJykge1xuICAgICAgICAgIHRoaXMuJGVsLm9uKGV2ZW50TmFtZSwgbWV0aG9kKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLiRlbC5vbihldmVudE5hbWUsIHNlbGVjdG9yLCBtZXRob2QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gQ2xlYXJzIGFsbCBjYWxsYmFja3MgcHJldmlvdXNseSBib3VuZCB0byB0aGUgdmlldyB3aXRoIGBkZWxlZ2F0ZUV2ZW50c2AuXG4gICAgLy8gWW91IHVzdWFsbHkgZG9uJ3QgbmVlZCB0byB1c2UgdGhpcywgYnV0IG1heSB3aXNoIHRvIGlmIHlvdSBoYXZlIG11bHRpcGxlXG4gICAgLy8gQmFja2JvbmUgdmlld3MgYXR0YWNoZWQgdG8gdGhlIHNhbWUgRE9NIGVsZW1lbnQuXG4gICAgdW5kZWxlZ2F0ZUV2ZW50czogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLiRlbC5vZmYoJy5kZWxlZ2F0ZUV2ZW50cycgKyB0aGlzLmNpZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gRW5zdXJlIHRoYXQgdGhlIFZpZXcgaGFzIGEgRE9NIGVsZW1lbnQgdG8gcmVuZGVyIGludG8uXG4gICAgLy8gSWYgYHRoaXMuZWxgIGlzIGEgc3RyaW5nLCBwYXNzIGl0IHRocm91Z2ggYCQoKWAsIHRha2UgdGhlIGZpcnN0XG4gICAgLy8gbWF0Y2hpbmcgZWxlbWVudCwgYW5kIHJlLWFzc2lnbiBpdCB0byBgZWxgLiBPdGhlcndpc2UsIGNyZWF0ZVxuICAgIC8vIGFuIGVsZW1lbnQgZnJvbSB0aGUgYGlkYCwgYGNsYXNzTmFtZWAgYW5kIGB0YWdOYW1lYCBwcm9wZXJ0aWVzLlxuICAgIF9lbnN1cmVFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5lbCkge1xuICAgICAgICB2YXIgYXR0cnMgPSBfLmV4dGVuZCh7fSwgXy5yZXN1bHQodGhpcywgJ2F0dHJpYnV0ZXMnKSk7XG4gICAgICAgIGlmICh0aGlzLmlkKSBhdHRycy5pZCA9IF8ucmVzdWx0KHRoaXMsICdpZCcpO1xuICAgICAgICBpZiAodGhpcy5jbGFzc05hbWUpIGF0dHJzWydjbGFzcyddID0gXy5yZXN1bHQodGhpcywgJ2NsYXNzTmFtZScpO1xuICAgICAgICB2YXIgJGVsID0gQmFja2JvbmUuJCgnPCcgKyBfLnJlc3VsdCh0aGlzLCAndGFnTmFtZScpICsgJz4nKS5hdHRyKGF0dHJzKTtcbiAgICAgICAgdGhpcy5zZXRFbGVtZW50KCRlbCwgZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRFbGVtZW50KF8ucmVzdWx0KHRoaXMsICdlbCcpLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8vIEJhY2tib25lLnN5bmNcbiAgLy8gLS0tLS0tLS0tLS0tLVxuXG4gIC8vIE92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gdG8gY2hhbmdlIHRoZSBtYW5uZXIgaW4gd2hpY2ggQmFja2JvbmUgcGVyc2lzdHNcbiAgLy8gbW9kZWxzIHRvIHRoZSBzZXJ2ZXIuIFlvdSB3aWxsIGJlIHBhc3NlZCB0aGUgdHlwZSBvZiByZXF1ZXN0LCBhbmQgdGhlXG4gIC8vIG1vZGVsIGluIHF1ZXN0aW9uLiBCeSBkZWZhdWx0LCBtYWtlcyBhIFJFU1RmdWwgQWpheCByZXF1ZXN0XG4gIC8vIHRvIHRoZSBtb2RlbCdzIGB1cmwoKWAuIFNvbWUgcG9zc2libGUgY3VzdG9taXphdGlvbnMgY291bGQgYmU6XG4gIC8vXG4gIC8vICogVXNlIGBzZXRUaW1lb3V0YCB0byBiYXRjaCByYXBpZC1maXJlIHVwZGF0ZXMgaW50byBhIHNpbmdsZSByZXF1ZXN0LlxuICAvLyAqIFNlbmQgdXAgdGhlIG1vZGVscyBhcyBYTUwgaW5zdGVhZCBvZiBKU09OLlxuICAvLyAqIFBlcnNpc3QgbW9kZWxzIHZpYSBXZWJTb2NrZXRzIGluc3RlYWQgb2YgQWpheC5cbiAgLy9cbiAgLy8gVHVybiBvbiBgQmFja2JvbmUuZW11bGF0ZUhUVFBgIGluIG9yZGVyIHRvIHNlbmQgYFBVVGAgYW5kIGBERUxFVEVgIHJlcXVlc3RzXG4gIC8vIGFzIGBQT1NUYCwgd2l0aCBhIGBfbWV0aG9kYCBwYXJhbWV0ZXIgY29udGFpbmluZyB0aGUgdHJ1ZSBIVFRQIG1ldGhvZCxcbiAgLy8gYXMgd2VsbCBhcyBhbGwgcmVxdWVzdHMgd2l0aCB0aGUgYm9keSBhcyBgYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkYFxuICAvLyBpbnN0ZWFkIG9mIGBhcHBsaWNhdGlvbi9qc29uYCB3aXRoIHRoZSBtb2RlbCBpbiBhIHBhcmFtIG5hbWVkIGBtb2RlbGAuXG4gIC8vIFVzZWZ1bCB3aGVuIGludGVyZmFjaW5nIHdpdGggc2VydmVyLXNpZGUgbGFuZ3VhZ2VzIGxpa2UgKipQSFAqKiB0aGF0IG1ha2VcbiAgLy8gaXQgZGlmZmljdWx0IHRvIHJlYWQgdGhlIGJvZHkgb2YgYFBVVGAgcmVxdWVzdHMuXG4gIEJhY2tib25lLnN5bmMgPSBmdW5jdGlvbihtZXRob2QsIG1vZGVsLCBvcHRpb25zKSB7XG4gICAgdmFyIHR5cGUgPSBtZXRob2RNYXBbbWV0aG9kXTtcblxuICAgIC8vIERlZmF1bHQgb3B0aW9ucywgdW5sZXNzIHNwZWNpZmllZC5cbiAgICBfLmRlZmF1bHRzKG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSksIHtcbiAgICAgIGVtdWxhdGVIVFRQOiBCYWNrYm9uZS5lbXVsYXRlSFRUUCxcbiAgICAgIGVtdWxhdGVKU09OOiBCYWNrYm9uZS5lbXVsYXRlSlNPTlxuICAgIH0pO1xuXG4gICAgLy8gRGVmYXVsdCBKU09OLXJlcXVlc3Qgb3B0aW9ucy5cbiAgICB2YXIgcGFyYW1zID0ge3R5cGU6IHR5cGUsIGRhdGFUeXBlOiAnanNvbid9O1xuXG4gICAgLy8gRW5zdXJlIHRoYXQgd2UgaGF2ZSBhIFVSTC5cbiAgICBpZiAoIW9wdGlvbnMudXJsKSB7XG4gICAgICBwYXJhbXMudXJsID0gXy5yZXN1bHQobW9kZWwsICd1cmwnKSB8fCB1cmxFcnJvcigpO1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSB0aGF0IHdlIGhhdmUgdGhlIGFwcHJvcHJpYXRlIHJlcXVlc3QgZGF0YS5cbiAgICBpZiAob3B0aW9ucy5kYXRhID09IG51bGwgJiYgbW9kZWwgJiYgKG1ldGhvZCA9PT0gJ2NyZWF0ZScgfHwgbWV0aG9kID09PSAndXBkYXRlJyB8fCBtZXRob2QgPT09ICdwYXRjaCcpKSB7XG4gICAgICBwYXJhbXMuY29udGVudFR5cGUgPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICBwYXJhbXMuZGF0YSA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuYXR0cnMgfHwgbW9kZWwudG9KU09OKG9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICAvLyBGb3Igb2xkZXIgc2VydmVycywgZW11bGF0ZSBKU09OIGJ5IGVuY29kaW5nIHRoZSByZXF1ZXN0IGludG8gYW4gSFRNTC1mb3JtLlxuICAgIGlmIChvcHRpb25zLmVtdWxhdGVKU09OKSB7XG4gICAgICBwYXJhbXMuY29udGVudFR5cGUgPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJztcbiAgICAgIHBhcmFtcy5kYXRhID0gcGFyYW1zLmRhdGEgPyB7bW9kZWw6IHBhcmFtcy5kYXRhfSA6IHt9O1xuICAgIH1cblxuICAgIC8vIEZvciBvbGRlciBzZXJ2ZXJzLCBlbXVsYXRlIEhUVFAgYnkgbWltaWNraW5nIHRoZSBIVFRQIG1ldGhvZCB3aXRoIGBfbWV0aG9kYFxuICAgIC8vIEFuZCBhbiBgWC1IVFRQLU1ldGhvZC1PdmVycmlkZWAgaGVhZGVyLlxuICAgIGlmIChvcHRpb25zLmVtdWxhdGVIVFRQICYmICh0eXBlID09PSAnUFVUJyB8fCB0eXBlID09PSAnREVMRVRFJyB8fCB0eXBlID09PSAnUEFUQ0gnKSkge1xuICAgICAgcGFyYW1zLnR5cGUgPSAnUE9TVCc7XG4gICAgICBpZiAob3B0aW9ucy5lbXVsYXRlSlNPTikgcGFyYW1zLmRhdGEuX21ldGhvZCA9IHR5cGU7XG4gICAgICB2YXIgYmVmb3JlU2VuZCA9IG9wdGlvbnMuYmVmb3JlU2VuZDtcbiAgICAgIG9wdGlvbnMuYmVmb3JlU2VuZCA9IGZ1bmN0aW9uKHhocikge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignWC1IVFRQLU1ldGhvZC1PdmVycmlkZScsIHR5cGUpO1xuICAgICAgICBpZiAoYmVmb3JlU2VuZCkgcmV0dXJuIGJlZm9yZVNlbmQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRG9uJ3QgcHJvY2VzcyBkYXRhIG9uIGEgbm9uLUdFVCByZXF1ZXN0LlxuICAgIGlmIChwYXJhbXMudHlwZSAhPT0gJ0dFVCcgJiYgIW9wdGlvbnMuZW11bGF0ZUpTT04pIHtcbiAgICAgIHBhcmFtcy5wcm9jZXNzRGF0YSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIElmIHdlJ3JlIHNlbmRpbmcgYSBgUEFUQ0hgIHJlcXVlc3QsIGFuZCB3ZSdyZSBpbiBhbiBvbGQgSW50ZXJuZXQgRXhwbG9yZXJcbiAgICAvLyB0aGF0IHN0aWxsIGhhcyBBY3RpdmVYIGVuYWJsZWQgYnkgZGVmYXVsdCwgb3ZlcnJpZGUgalF1ZXJ5IHRvIHVzZSB0aGF0XG4gICAgLy8gZm9yIFhIUiBpbnN0ZWFkLiBSZW1vdmUgdGhpcyBsaW5lIHdoZW4galF1ZXJ5IHN1cHBvcnRzIGBQQVRDSGAgb24gSUU4LlxuICAgIGlmIChwYXJhbXMudHlwZSA9PT0gJ1BBVENIJyAmJiBub1hoclBhdGNoKSB7XG4gICAgICBwYXJhbXMueGhyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgQWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxIVFRQXCIpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHRoZSByZXF1ZXN0LCBhbGxvd2luZyB0aGUgdXNlciB0byBvdmVycmlkZSBhbnkgQWpheCBvcHRpb25zLlxuICAgIHZhciB4aHIgPSBvcHRpb25zLnhociA9IEJhY2tib25lLmFqYXgoXy5leHRlbmQocGFyYW1zLCBvcHRpb25zKSk7XG4gICAgbW9kZWwudHJpZ2dlcigncmVxdWVzdCcsIG1vZGVsLCB4aHIsIG9wdGlvbnMpO1xuICAgIHJldHVybiB4aHI7XG4gIH07XG5cbiAgdmFyIG5vWGhyUGF0Y2ggPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhIXdpbmRvdy5BY3RpdmVYT2JqZWN0ICYmICEod2luZG93LlhNTEh0dHBSZXF1ZXN0ICYmIChuZXcgWE1MSHR0cFJlcXVlc3QpLmRpc3BhdGNoRXZlbnQpO1xuXG4gIC8vIE1hcCBmcm9tIENSVUQgdG8gSFRUUCBmb3Igb3VyIGRlZmF1bHQgYEJhY2tib25lLnN5bmNgIGltcGxlbWVudGF0aW9uLlxuICB2YXIgbWV0aG9kTWFwID0ge1xuICAgICdjcmVhdGUnOiAnUE9TVCcsXG4gICAgJ3VwZGF0ZSc6ICdQVVQnLFxuICAgICdwYXRjaCc6ICAnUEFUQ0gnLFxuICAgICdkZWxldGUnOiAnREVMRVRFJyxcbiAgICAncmVhZCc6ICAgJ0dFVCdcbiAgfTtcblxuICAvLyBTZXQgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgYEJhY2tib25lLmFqYXhgIHRvIHByb3h5IHRocm91Z2ggdG8gYCRgLlxuICAvLyBPdmVycmlkZSB0aGlzIGlmIHlvdSdkIGxpa2UgdG8gdXNlIGEgZGlmZmVyZW50IGxpYnJhcnkuXG4gIEJhY2tib25lLmFqYXggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gQmFja2JvbmUuJC5hamF4LmFwcGx5KEJhY2tib25lLiQsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLy8gQmFja2JvbmUuUm91dGVyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFJvdXRlcnMgbWFwIGZhdXgtVVJMcyB0byBhY3Rpb25zLCBhbmQgZmlyZSBldmVudHMgd2hlbiByb3V0ZXMgYXJlXG4gIC8vIG1hdGNoZWQuIENyZWF0aW5nIGEgbmV3IG9uZSBzZXRzIGl0cyBgcm91dGVzYCBoYXNoLCBpZiBub3Qgc2V0IHN0YXRpY2FsbHkuXG4gIHZhciBSb3V0ZXIgPSBCYWNrYm9uZS5Sb3V0ZXIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICBpZiAob3B0aW9ucy5yb3V0ZXMpIHRoaXMucm91dGVzID0gb3B0aW9ucy5yb3V0ZXM7XG4gICAgdGhpcy5fYmluZFJvdXRlcygpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIENhY2hlZCByZWd1bGFyIGV4cHJlc3Npb25zIGZvciBtYXRjaGluZyBuYW1lZCBwYXJhbSBwYXJ0cyBhbmQgc3BsYXR0ZWRcbiAgLy8gcGFydHMgb2Ygcm91dGUgc3RyaW5ncy5cbiAgdmFyIG9wdGlvbmFsUGFyYW0gPSAvXFwoKC4qPylcXCkvZztcbiAgdmFyIG5hbWVkUGFyYW0gICAgPSAvKFxcKFxcPyk/OlxcdysvZztcbiAgdmFyIHNwbGF0UGFyYW0gICAgPSAvXFwqXFx3Ky9nO1xuICB2YXIgZXNjYXBlUmVnRXhwICA9IC9bXFwte31cXFtcXF0rPy4sXFxcXFxcXiR8I1xcc10vZztcblxuICAvLyBTZXQgdXAgYWxsIGluaGVyaXRhYmxlICoqQmFja2JvbmUuUm91dGVyKiogcHJvcGVydGllcyBhbmQgbWV0aG9kcy5cbiAgXy5leHRlbmQoUm91dGVyLnByb3RvdHlwZSwgRXZlbnRzLCB7XG5cbiAgICAvLyBJbml0aWFsaXplIGlzIGFuIGVtcHR5IGZ1bmN0aW9uIGJ5IGRlZmF1bHQuIE92ZXJyaWRlIGl0IHdpdGggeW91ciBvd25cbiAgICAvLyBpbml0aWFsaXphdGlvbiBsb2dpYy5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpe30sXG5cbiAgICAvLyBNYW51YWxseSBiaW5kIGEgc2luZ2xlIG5hbWVkIHJvdXRlIHRvIGEgY2FsbGJhY2suIEZvciBleGFtcGxlOlxuICAgIC8vXG4gICAgLy8gICAgIHRoaXMucm91dGUoJ3NlYXJjaC86cXVlcnkvcDpudW0nLCAnc2VhcmNoJywgZnVuY3Rpb24ocXVlcnksIG51bSkge1xuICAgIC8vICAgICAgIC4uLlxuICAgIC8vICAgICB9KTtcbiAgICAvL1xuICAgIHJvdXRlOiBmdW5jdGlvbihyb3V0ZSwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICAgIGlmICghXy5pc1JlZ0V4cChyb3V0ZSkpIHJvdXRlID0gdGhpcy5fcm91dGVUb1JlZ0V4cChyb3V0ZSk7XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG5hbWUpKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmFtZTtcbiAgICAgICAgbmFtZSA9ICcnO1xuICAgICAgfVxuICAgICAgaWYgKCFjYWxsYmFjaykgY2FsbGJhY2sgPSB0aGlzW25hbWVdO1xuICAgICAgdmFyIHJvdXRlciA9IHRoaXM7XG4gICAgICBCYWNrYm9uZS5oaXN0b3J5LnJvdXRlKHJvdXRlLCBmdW5jdGlvbihmcmFnbWVudCkge1xuICAgICAgICB2YXIgYXJncyA9IHJvdXRlci5fZXh0cmFjdFBhcmFtZXRlcnMocm91dGUsIGZyYWdtZW50KTtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2suYXBwbHkocm91dGVyLCBhcmdzKTtcbiAgICAgICAgcm91dGVyLnRyaWdnZXIuYXBwbHkocm91dGVyLCBbJ3JvdXRlOicgKyBuYW1lXS5jb25jYXQoYXJncykpO1xuICAgICAgICByb3V0ZXIudHJpZ2dlcigncm91dGUnLCBuYW1lLCBhcmdzKTtcbiAgICAgICAgQmFja2JvbmUuaGlzdG9yeS50cmlnZ2VyKCdyb3V0ZScsIHJvdXRlciwgbmFtZSwgYXJncyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBTaW1wbGUgcHJveHkgdG8gYEJhY2tib25lLmhpc3RvcnlgIHRvIHNhdmUgYSBmcmFnbWVudCBpbnRvIHRoZSBoaXN0b3J5LlxuICAgIG5hdmlnYXRlOiBmdW5jdGlvbihmcmFnbWVudCwgb3B0aW9ucykge1xuICAgICAgQmFja2JvbmUuaGlzdG9yeS5uYXZpZ2F0ZShmcmFnbWVudCwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gQmluZCBhbGwgZGVmaW5lZCByb3V0ZXMgdG8gYEJhY2tib25lLmhpc3RvcnlgLiBXZSBoYXZlIHRvIHJldmVyc2UgdGhlXG4gICAgLy8gb3JkZXIgb2YgdGhlIHJvdXRlcyBoZXJlIHRvIHN1cHBvcnQgYmVoYXZpb3Igd2hlcmUgdGhlIG1vc3QgZ2VuZXJhbFxuICAgIC8vIHJvdXRlcyBjYW4gYmUgZGVmaW5lZCBhdCB0aGUgYm90dG9tIG9mIHRoZSByb3V0ZSBtYXAuXG4gICAgX2JpbmRSb3V0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLnJvdXRlcykgcmV0dXJuO1xuICAgICAgdGhpcy5yb3V0ZXMgPSBfLnJlc3VsdCh0aGlzLCAncm91dGVzJyk7XG4gICAgICB2YXIgcm91dGUsIHJvdXRlcyA9IF8ua2V5cyh0aGlzLnJvdXRlcyk7XG4gICAgICB3aGlsZSAoKHJvdXRlID0gcm91dGVzLnBvcCgpKSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMucm91dGUocm91dGUsIHRoaXMucm91dGVzW3JvdXRlXSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYSByb3V0ZSBzdHJpbmcgaW50byBhIHJlZ3VsYXIgZXhwcmVzc2lvbiwgc3VpdGFibGUgZm9yIG1hdGNoaW5nXG4gICAgLy8gYWdhaW5zdCB0aGUgY3VycmVudCBsb2NhdGlvbiBoYXNoLlxuICAgIF9yb3V0ZVRvUmVnRXhwOiBmdW5jdGlvbihyb3V0ZSkge1xuICAgICAgcm91dGUgPSByb3V0ZS5yZXBsYWNlKGVzY2FwZVJlZ0V4cCwgJ1xcXFwkJicpXG4gICAgICAgICAgICAgICAgICAgLnJlcGxhY2Uob3B0aW9uYWxQYXJhbSwgJyg/OiQxKT8nKVxuICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKG5hbWVkUGFyYW0sIGZ1bmN0aW9uKG1hdGNoLCBvcHRpb25hbCkge1xuICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbmFsID8gbWF0Y2ggOiAnKFteXFwvXSspJztcbiAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKHNwbGF0UGFyYW0sICcoLio/KScpO1xuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoJ14nICsgcm91dGUgKyAnJCcpO1xuICAgIH0sXG5cbiAgICAvLyBHaXZlbiBhIHJvdXRlLCBhbmQgYSBVUkwgZnJhZ21lbnQgdGhhdCBpdCBtYXRjaGVzLCByZXR1cm4gdGhlIGFycmF5IG9mXG4gICAgLy8gZXh0cmFjdGVkIGRlY29kZWQgcGFyYW1ldGVycy4gRW1wdHkgb3IgdW5tYXRjaGVkIHBhcmFtZXRlcnMgd2lsbCBiZVxuICAgIC8vIHRyZWF0ZWQgYXMgYG51bGxgIHRvIG5vcm1hbGl6ZSBjcm9zcy1icm93c2VyIGJlaGF2aW9yLlxuICAgIF9leHRyYWN0UGFyYW1ldGVyczogZnVuY3Rpb24ocm91dGUsIGZyYWdtZW50KSB7XG4gICAgICB2YXIgcGFyYW1zID0gcm91dGUuZXhlYyhmcmFnbWVudCkuc2xpY2UoMSk7XG4gICAgICByZXR1cm4gXy5tYXAocGFyYW1zLCBmdW5jdGlvbihwYXJhbSkge1xuICAgICAgICByZXR1cm4gcGFyYW0gPyBkZWNvZGVVUklDb21wb25lbnQocGFyYW0pIDogbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICB9KTtcblxuICAvLyBCYWNrYm9uZS5IaXN0b3J5XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBIYW5kbGVzIGNyb3NzLWJyb3dzZXIgaGlzdG9yeSBtYW5hZ2VtZW50LCBiYXNlZCBvbiBlaXRoZXJcbiAgLy8gW3B1c2hTdGF0ZV0oaHR0cDovL2RpdmVpbnRvaHRtbDUuaW5mby9oaXN0b3J5Lmh0bWwpIGFuZCByZWFsIFVSTHMsIG9yXG4gIC8vIFtvbmhhc2hjaGFuZ2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvRE9NL3dpbmRvdy5vbmhhc2hjaGFuZ2UpXG4gIC8vIGFuZCBVUkwgZnJhZ21lbnRzLiBJZiB0aGUgYnJvd3NlciBzdXBwb3J0cyBuZWl0aGVyIChvbGQgSUUsIG5hdGNoKSxcbiAgLy8gZmFsbHMgYmFjayB0byBwb2xsaW5nLlxuICB2YXIgSGlzdG9yeSA9IEJhY2tib25lLkhpc3RvcnkgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmhhbmRsZXJzID0gW107XG4gICAgXy5iaW5kQWxsKHRoaXMsICdjaGVja1VybCcpO1xuXG4gICAgLy8gRW5zdXJlIHRoYXQgYEhpc3RvcnlgIGNhbiBiZSB1c2VkIG91dHNpZGUgb2YgdGhlIGJyb3dzZXIuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLmxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuICAgICAgdGhpcy5oaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XG4gICAgfVxuICB9O1xuXG4gIC8vIENhY2hlZCByZWdleCBmb3Igc3RyaXBwaW5nIGEgbGVhZGluZyBoYXNoL3NsYXNoIGFuZCB0cmFpbGluZyBzcGFjZS5cbiAgdmFyIHJvdXRlU3RyaXBwZXIgPSAvXlsjXFwvXXxcXHMrJC9nO1xuXG4gIC8vIENhY2hlZCByZWdleCBmb3Igc3RyaXBwaW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMuXG4gIHZhciByb290U3RyaXBwZXIgPSAvXlxcLyt8XFwvKyQvZztcblxuICAvLyBDYWNoZWQgcmVnZXggZm9yIGRldGVjdGluZyBNU0lFLlxuICB2YXIgaXNFeHBsb3JlciA9IC9tc2llIFtcXHcuXSsvO1xuXG4gIC8vIENhY2hlZCByZWdleCBmb3IgcmVtb3ZpbmcgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIHRyYWlsaW5nU2xhc2ggPSAvXFwvJC87XG5cbiAgLy8gQ2FjaGVkIHJlZ2V4IGZvciBzdHJpcHBpbmcgdXJscyBvZiBoYXNoIGFuZCBxdWVyeS5cbiAgdmFyIHBhdGhTdHJpcHBlciA9IC9bPyNdLiokLztcblxuICAvLyBIYXMgdGhlIGhpc3RvcnkgaGFuZGxpbmcgYWxyZWFkeSBiZWVuIHN0YXJ0ZWQ/XG4gIEhpc3Rvcnkuc3RhcnRlZCA9IGZhbHNlO1xuXG4gIC8vIFNldCB1cCBhbGwgaW5oZXJpdGFibGUgKipCYWNrYm9uZS5IaXN0b3J5KiogcHJvcGVydGllcyBhbmQgbWV0aG9kcy5cbiAgXy5leHRlbmQoSGlzdG9yeS5wcm90b3R5cGUsIEV2ZW50cywge1xuXG4gICAgLy8gVGhlIGRlZmF1bHQgaW50ZXJ2YWwgdG8gcG9sbCBmb3IgaGFzaCBjaGFuZ2VzLCBpZiBuZWNlc3NhcnksIGlzXG4gICAgLy8gdHdlbnR5IHRpbWVzIGEgc2Vjb25kLlxuICAgIGludGVydmFsOiA1MCxcblxuICAgIC8vIEdldHMgdGhlIHRydWUgaGFzaCB2YWx1ZS4gQ2Fubm90IHVzZSBsb2NhdGlvbi5oYXNoIGRpcmVjdGx5IGR1ZSB0byBidWdcbiAgICAvLyBpbiBGaXJlZm94IHdoZXJlIGxvY2F0aW9uLmhhc2ggd2lsbCBhbHdheXMgYmUgZGVjb2RlZC5cbiAgICBnZXRIYXNoOiBmdW5jdGlvbih3aW5kb3cpIHtcbiAgICAgIHZhciBtYXRjaCA9ICh3aW5kb3cgfHwgdGhpcykubG9jYXRpb24uaHJlZi5tYXRjaCgvIyguKikkLyk7XG4gICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIGNyb3NzLWJyb3dzZXIgbm9ybWFsaXplZCBVUkwgZnJhZ21lbnQsIGVpdGhlciBmcm9tIHRoZSBVUkwsXG4gICAgLy8gdGhlIGhhc2gsIG9yIHRoZSBvdmVycmlkZS5cbiAgICBnZXRGcmFnbWVudDogZnVuY3Rpb24oZnJhZ21lbnQsIGZvcmNlUHVzaFN0YXRlKSB7XG4gICAgICBpZiAoZnJhZ21lbnQgPT0gbnVsbCkge1xuICAgICAgICBpZiAodGhpcy5faGFzUHVzaFN0YXRlIHx8ICF0aGlzLl93YW50c0hhc2hDaGFuZ2UgfHwgZm9yY2VQdXNoU3RhdGUpIHtcbiAgICAgICAgICBmcmFnbWVudCA9IHRoaXMubG9jYXRpb24ucGF0aG5hbWU7XG4gICAgICAgICAgdmFyIHJvb3QgPSB0aGlzLnJvb3QucmVwbGFjZSh0cmFpbGluZ1NsYXNoLCAnJyk7XG4gICAgICAgICAgaWYgKCFmcmFnbWVudC5pbmRleE9mKHJvb3QpKSBmcmFnbWVudCA9IGZyYWdtZW50LnNsaWNlKHJvb3QubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmcmFnbWVudCA9IHRoaXMuZ2V0SGFzaCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZnJhZ21lbnQucmVwbGFjZShyb3V0ZVN0cmlwcGVyLCAnJyk7XG4gICAgfSxcblxuICAgIC8vIFN0YXJ0IHRoZSBoYXNoIGNoYW5nZSBoYW5kbGluZywgcmV0dXJuaW5nIGB0cnVlYCBpZiB0aGUgY3VycmVudCBVUkwgbWF0Y2hlc1xuICAgIC8vIGFuIGV4aXN0aW5nIHJvdXRlLCBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmIChIaXN0b3J5LnN0YXJ0ZWQpIHRocm93IG5ldyBFcnJvcihcIkJhY2tib25lLmhpc3RvcnkgaGFzIGFscmVhZHkgYmVlbiBzdGFydGVkXCIpO1xuICAgICAgSGlzdG9yeS5zdGFydGVkID0gdHJ1ZTtcblxuICAgICAgLy8gRmlndXJlIG91dCB0aGUgaW5pdGlhbCBjb25maWd1cmF0aW9uLiBEbyB3ZSBuZWVkIGFuIGlmcmFtZT9cbiAgICAgIC8vIElzIHB1c2hTdGF0ZSBkZXNpcmVkIC4uLiBpcyBpdCBhdmFpbGFibGU/XG4gICAgICB0aGlzLm9wdGlvbnMgICAgICAgICAgPSBfLmV4dGVuZCh7cm9vdDogJy8nfSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMucm9vdCAgICAgICAgICAgICA9IHRoaXMub3B0aW9ucy5yb290O1xuICAgICAgdGhpcy5fd2FudHNIYXNoQ2hhbmdlID0gdGhpcy5vcHRpb25zLmhhc2hDaGFuZ2UgIT09IGZhbHNlO1xuICAgICAgdGhpcy5fd2FudHNQdXNoU3RhdGUgID0gISF0aGlzLm9wdGlvbnMucHVzaFN0YXRlO1xuICAgICAgdGhpcy5faGFzUHVzaFN0YXRlICAgID0gISEodGhpcy5vcHRpb25zLnB1c2hTdGF0ZSAmJiB0aGlzLmhpc3RvcnkgJiYgdGhpcy5oaXN0b3J5LnB1c2hTdGF0ZSk7XG4gICAgICB2YXIgZnJhZ21lbnQgICAgICAgICAgPSB0aGlzLmdldEZyYWdtZW50KCk7XG4gICAgICB2YXIgZG9jTW9kZSAgICAgICAgICAgPSBkb2N1bWVudC5kb2N1bWVudE1vZGU7XG4gICAgICB2YXIgb2xkSUUgICAgICAgICAgICAgPSAoaXNFeHBsb3Jlci5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSkgJiYgKCFkb2NNb2RlIHx8IGRvY01vZGUgPD0gNykpO1xuXG4gICAgICAvLyBOb3JtYWxpemUgcm9vdCB0byBhbHdheXMgaW5jbHVkZSBhIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoLlxuICAgICAgdGhpcy5yb290ID0gKCcvJyArIHRoaXMucm9vdCArICcvJykucmVwbGFjZShyb290U3RyaXBwZXIsICcvJyk7XG5cbiAgICAgIGlmIChvbGRJRSAmJiB0aGlzLl93YW50c0hhc2hDaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5pZnJhbWUgPSBCYWNrYm9uZS4kKCc8aWZyYW1lIHNyYz1cImphdmFzY3JpcHQ6MFwiIHRhYmluZGV4PVwiLTFcIiAvPicpLmhpZGUoKS5hcHBlbmRUbygnYm9keScpWzBdLmNvbnRlbnRXaW5kb3c7XG4gICAgICAgIHRoaXMubmF2aWdhdGUoZnJhZ21lbnQpO1xuICAgICAgfVxuXG4gICAgICAvLyBEZXBlbmRpbmcgb24gd2hldGhlciB3ZSdyZSB1c2luZyBwdXNoU3RhdGUgb3IgaGFzaGVzLCBhbmQgd2hldGhlclxuICAgICAgLy8gJ29uaGFzaGNoYW5nZScgaXMgc3VwcG9ydGVkLCBkZXRlcm1pbmUgaG93IHdlIGNoZWNrIHRoZSBVUkwgc3RhdGUuXG4gICAgICBpZiAodGhpcy5faGFzUHVzaFN0YXRlKSB7XG4gICAgICAgIEJhY2tib25lLiQod2luZG93KS5vbigncG9wc3RhdGUnLCB0aGlzLmNoZWNrVXJsKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fd2FudHNIYXNoQ2hhbmdlICYmICgnb25oYXNoY2hhbmdlJyBpbiB3aW5kb3cpICYmICFvbGRJRSkge1xuICAgICAgICBCYWNrYm9uZS4kKHdpbmRvdykub24oJ2hhc2hjaGFuZ2UnLCB0aGlzLmNoZWNrVXJsKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fd2FudHNIYXNoQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrVXJsSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCh0aGlzLmNoZWNrVXJsLCB0aGlzLmludGVydmFsKTtcbiAgICAgIH1cblxuICAgICAgLy8gRGV0ZXJtaW5lIGlmIHdlIG5lZWQgdG8gY2hhbmdlIHRoZSBiYXNlIHVybCwgZm9yIGEgcHVzaFN0YXRlIGxpbmtcbiAgICAgIC8vIG9wZW5lZCBieSBhIG5vbi1wdXNoU3RhdGUgYnJvd3Nlci5cbiAgICAgIHRoaXMuZnJhZ21lbnQgPSBmcmFnbWVudDtcbiAgICAgIHZhciBsb2MgPSB0aGlzLmxvY2F0aW9uO1xuICAgICAgdmFyIGF0Um9vdCA9IGxvYy5wYXRobmFtZS5yZXBsYWNlKC9bXlxcL10kLywgJyQmLycpID09PSB0aGlzLnJvb3Q7XG5cbiAgICAgIC8vIFRyYW5zaXRpb24gZnJvbSBoYXNoQ2hhbmdlIHRvIHB1c2hTdGF0ZSBvciB2aWNlIHZlcnNhIGlmIGJvdGggYXJlXG4gICAgICAvLyByZXF1ZXN0ZWQuXG4gICAgICBpZiAodGhpcy5fd2FudHNIYXNoQ2hhbmdlICYmIHRoaXMuX3dhbnRzUHVzaFN0YXRlKSB7XG5cbiAgICAgICAgLy8gSWYgd2UndmUgc3RhcnRlZCBvZmYgd2l0aCBhIHJvdXRlIGZyb20gYSBgcHVzaFN0YXRlYC1lbmFibGVkXG4gICAgICAgIC8vIGJyb3dzZXIsIGJ1dCB3ZSdyZSBjdXJyZW50bHkgaW4gYSBicm93c2VyIHRoYXQgZG9lc24ndCBzdXBwb3J0IGl0Li4uXG4gICAgICAgIGlmICghdGhpcy5faGFzUHVzaFN0YXRlICYmICFhdFJvb3QpIHtcbiAgICAgICAgICB0aGlzLmZyYWdtZW50ID0gdGhpcy5nZXRGcmFnbWVudChudWxsLCB0cnVlKTtcbiAgICAgICAgICB0aGlzLmxvY2F0aW9uLnJlcGxhY2UodGhpcy5yb290ICsgdGhpcy5sb2NhdGlvbi5zZWFyY2ggKyAnIycgKyB0aGlzLmZyYWdtZW50KTtcbiAgICAgICAgICAvLyBSZXR1cm4gaW1tZWRpYXRlbHkgYXMgYnJvd3NlciB3aWxsIGRvIHJlZGlyZWN0IHRvIG5ldyB1cmxcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAvLyBPciBpZiB3ZSd2ZSBzdGFydGVkIG91dCB3aXRoIGEgaGFzaC1iYXNlZCByb3V0ZSwgYnV0IHdlJ3JlIGN1cnJlbnRseVxuICAgICAgICAvLyBpbiBhIGJyb3dzZXIgd2hlcmUgaXQgY291bGQgYmUgYHB1c2hTdGF0ZWAtYmFzZWQgaW5zdGVhZC4uLlxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2hhc1B1c2hTdGF0ZSAmJiBhdFJvb3QgJiYgbG9jLmhhc2gpIHtcbiAgICAgICAgICB0aGlzLmZyYWdtZW50ID0gdGhpcy5nZXRIYXNoKCkucmVwbGFjZShyb3V0ZVN0cmlwcGVyLCAnJyk7XG4gICAgICAgICAgdGhpcy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSh7fSwgZG9jdW1lbnQudGl0bGUsIHRoaXMucm9vdCArIHRoaXMuZnJhZ21lbnQgKyBsb2Muc2VhcmNoKTtcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnNpbGVudCkgcmV0dXJuIHRoaXMubG9hZFVybCgpO1xuICAgIH0sXG5cbiAgICAvLyBEaXNhYmxlIEJhY2tib25lLmhpc3RvcnksIHBlcmhhcHMgdGVtcG9yYXJpbHkuIE5vdCB1c2VmdWwgaW4gYSByZWFsIGFwcCxcbiAgICAvLyBidXQgcG9zc2libHkgdXNlZnVsIGZvciB1bml0IHRlc3RpbmcgUm91dGVycy5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIEJhY2tib25lLiQod2luZG93KS5vZmYoJ3BvcHN0YXRlJywgdGhpcy5jaGVja1VybCkub2ZmKCdoYXNoY2hhbmdlJywgdGhpcy5jaGVja1VybCk7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuX2NoZWNrVXJsSW50ZXJ2YWwpO1xuICAgICAgSGlzdG9yeS5zdGFydGVkID0gZmFsc2U7XG4gICAgfSxcblxuICAgIC8vIEFkZCBhIHJvdXRlIHRvIGJlIHRlc3RlZCB3aGVuIHRoZSBmcmFnbWVudCBjaGFuZ2VzLiBSb3V0ZXMgYWRkZWQgbGF0ZXJcbiAgICAvLyBtYXkgb3ZlcnJpZGUgcHJldmlvdXMgcm91dGVzLlxuICAgIHJvdXRlOiBmdW5jdGlvbihyb3V0ZSwgY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuaGFuZGxlcnMudW5zaGlmdCh7cm91dGU6IHJvdXRlLCBjYWxsYmFjazogY2FsbGJhY2t9KTtcbiAgICB9LFxuXG4gICAgLy8gQ2hlY2tzIHRoZSBjdXJyZW50IFVSTCB0byBzZWUgaWYgaXQgaGFzIGNoYW5nZWQsIGFuZCBpZiBpdCBoYXMsXG4gICAgLy8gY2FsbHMgYGxvYWRVcmxgLCBub3JtYWxpemluZyBhY3Jvc3MgdGhlIGhpZGRlbiBpZnJhbWUuXG4gICAgY2hlY2tVcmw6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5nZXRGcmFnbWVudCgpO1xuICAgICAgaWYgKGN1cnJlbnQgPT09IHRoaXMuZnJhZ21lbnQgJiYgdGhpcy5pZnJhbWUpIHtcbiAgICAgICAgY3VycmVudCA9IHRoaXMuZ2V0RnJhZ21lbnQodGhpcy5nZXRIYXNoKHRoaXMuaWZyYW1lKSk7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudCA9PT0gdGhpcy5mcmFnbWVudCkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKHRoaXMuaWZyYW1lKSB0aGlzLm5hdmlnYXRlKGN1cnJlbnQpO1xuICAgICAgdGhpcy5sb2FkVXJsKCk7XG4gICAgfSxcblxuICAgIC8vIEF0dGVtcHQgdG8gbG9hZCB0aGUgY3VycmVudCBVUkwgZnJhZ21lbnQuIElmIGEgcm91dGUgc3VjY2VlZHMgd2l0aCBhXG4gICAgLy8gbWF0Y2gsIHJldHVybnMgYHRydWVgLiBJZiBubyBkZWZpbmVkIHJvdXRlcyBtYXRjaGVzIHRoZSBmcmFnbWVudCxcbiAgICAvLyByZXR1cm5zIGBmYWxzZWAuXG4gICAgbG9hZFVybDogZnVuY3Rpb24oZnJhZ21lbnQpIHtcbiAgICAgIGZyYWdtZW50ID0gdGhpcy5mcmFnbWVudCA9IHRoaXMuZ2V0RnJhZ21lbnQoZnJhZ21lbnQpO1xuICAgICAgcmV0dXJuIF8uYW55KHRoaXMuaGFuZGxlcnMsIGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGhhbmRsZXIucm91dGUudGVzdChmcmFnbWVudCkpIHtcbiAgICAgICAgICBoYW5kbGVyLmNhbGxiYWNrKGZyYWdtZW50KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIFNhdmUgYSBmcmFnbWVudCBpbnRvIHRoZSBoYXNoIGhpc3RvcnksIG9yIHJlcGxhY2UgdGhlIFVSTCBzdGF0ZSBpZiB0aGVcbiAgICAvLyAncmVwbGFjZScgb3B0aW9uIGlzIHBhc3NlZC4gWW91IGFyZSByZXNwb25zaWJsZSBmb3IgcHJvcGVybHkgVVJMLWVuY29kaW5nXG4gICAgLy8gdGhlIGZyYWdtZW50IGluIGFkdmFuY2UuXG4gICAgLy9cbiAgICAvLyBUaGUgb3B0aW9ucyBvYmplY3QgY2FuIGNvbnRhaW4gYHRyaWdnZXI6IHRydWVgIGlmIHlvdSB3aXNoIHRvIGhhdmUgdGhlXG4gICAgLy8gcm91dGUgY2FsbGJhY2sgYmUgZmlyZWQgKG5vdCB1c3VhbGx5IGRlc2lyYWJsZSksIG9yIGByZXBsYWNlOiB0cnVlYCwgaWZcbiAgICAvLyB5b3Ugd2lzaCB0byBtb2RpZnkgdGhlIGN1cnJlbnQgVVJMIHdpdGhvdXQgYWRkaW5nIGFuIGVudHJ5IHRvIHRoZSBoaXN0b3J5LlxuICAgIG5hdmlnYXRlOiBmdW5jdGlvbihmcmFnbWVudCwgb3B0aW9ucykge1xuICAgICAgaWYgKCFIaXN0b3J5LnN0YXJ0ZWQpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICghb3B0aW9ucyB8fCBvcHRpb25zID09PSB0cnVlKSBvcHRpb25zID0ge3RyaWdnZXI6ICEhb3B0aW9uc307XG5cbiAgICAgIHZhciB1cmwgPSB0aGlzLnJvb3QgKyAoZnJhZ21lbnQgPSB0aGlzLmdldEZyYWdtZW50KGZyYWdtZW50IHx8ICcnKSk7XG5cbiAgICAgIC8vIFN0cmlwIHRoZSBmcmFnbWVudCBvZiB0aGUgcXVlcnkgYW5kIGhhc2ggZm9yIG1hdGNoaW5nLlxuICAgICAgZnJhZ21lbnQgPSBmcmFnbWVudC5yZXBsYWNlKHBhdGhTdHJpcHBlciwgJycpO1xuXG4gICAgICBpZiAodGhpcy5mcmFnbWVudCA9PT0gZnJhZ21lbnQpIHJldHVybjtcbiAgICAgIHRoaXMuZnJhZ21lbnQgPSBmcmFnbWVudDtcblxuICAgICAgLy8gRG9uJ3QgaW5jbHVkZSBhIHRyYWlsaW5nIHNsYXNoIG9uIHRoZSByb290LlxuICAgICAgaWYgKGZyYWdtZW50ID09PSAnJyAmJiB1cmwgIT09ICcvJykgdXJsID0gdXJsLnNsaWNlKDAsIC0xKTtcblxuICAgICAgLy8gSWYgcHVzaFN0YXRlIGlzIGF2YWlsYWJsZSwgd2UgdXNlIGl0IHRvIHNldCB0aGUgZnJhZ21lbnQgYXMgYSByZWFsIFVSTC5cbiAgICAgIGlmICh0aGlzLl9oYXNQdXNoU3RhdGUpIHtcbiAgICAgICAgdGhpcy5oaXN0b3J5W29wdGlvbnMucmVwbGFjZSA/ICdyZXBsYWNlU3RhdGUnIDogJ3B1c2hTdGF0ZSddKHt9LCBkb2N1bWVudC50aXRsZSwgdXJsKTtcblxuICAgICAgLy8gSWYgaGFzaCBjaGFuZ2VzIGhhdmVuJ3QgYmVlbiBleHBsaWNpdGx5IGRpc2FibGVkLCB1cGRhdGUgdGhlIGhhc2hcbiAgICAgIC8vIGZyYWdtZW50IHRvIHN0b3JlIGhpc3RvcnkuXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3dhbnRzSGFzaENoYW5nZSkge1xuICAgICAgICB0aGlzLl91cGRhdGVIYXNoKHRoaXMubG9jYXRpb24sIGZyYWdtZW50LCBvcHRpb25zLnJlcGxhY2UpO1xuICAgICAgICBpZiAodGhpcy5pZnJhbWUgJiYgKGZyYWdtZW50ICE9PSB0aGlzLmdldEZyYWdtZW50KHRoaXMuZ2V0SGFzaCh0aGlzLmlmcmFtZSkpKSkge1xuICAgICAgICAgIC8vIE9wZW5pbmcgYW5kIGNsb3NpbmcgdGhlIGlmcmFtZSB0cmlja3MgSUU3IGFuZCBlYXJsaWVyIHRvIHB1c2ggYVxuICAgICAgICAgIC8vIGhpc3RvcnkgZW50cnkgb24gaGFzaC10YWcgY2hhbmdlLiAgV2hlbiByZXBsYWNlIGlzIHRydWUsIHdlIGRvbid0XG4gICAgICAgICAgLy8gd2FudCB0aGlzLlxuICAgICAgICAgIGlmKCFvcHRpb25zLnJlcGxhY2UpIHRoaXMuaWZyYW1lLmRvY3VtZW50Lm9wZW4oKS5jbG9zZSgpO1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZUhhc2godGhpcy5pZnJhbWUubG9jYXRpb24sIGZyYWdtZW50LCBvcHRpb25zLnJlcGxhY2UpO1xuICAgICAgICB9XG5cbiAgICAgIC8vIElmIHlvdSd2ZSB0b2xkIHVzIHRoYXQgeW91IGV4cGxpY2l0bHkgZG9uJ3Qgd2FudCBmYWxsYmFjayBoYXNoY2hhbmdlLVxuICAgICAgLy8gYmFzZWQgaGlzdG9yeSwgdGhlbiBgbmF2aWdhdGVgIGJlY29tZXMgYSBwYWdlIHJlZnJlc2guXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhdGlvbi5hc3NpZ24odXJsKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnRyaWdnZXIpIHJldHVybiB0aGlzLmxvYWRVcmwoZnJhZ21lbnQpO1xuICAgIH0sXG5cbiAgICAvLyBVcGRhdGUgdGhlIGhhc2ggbG9jYXRpb24sIGVpdGhlciByZXBsYWNpbmcgdGhlIGN1cnJlbnQgZW50cnksIG9yIGFkZGluZ1xuICAgIC8vIGEgbmV3IG9uZSB0byB0aGUgYnJvd3NlciBoaXN0b3J5LlxuICAgIF91cGRhdGVIYXNoOiBmdW5jdGlvbihsb2NhdGlvbiwgZnJhZ21lbnQsIHJlcGxhY2UpIHtcbiAgICAgIGlmIChyZXBsYWNlKSB7XG4gICAgICAgIHZhciBocmVmID0gbG9jYXRpb24uaHJlZi5yZXBsYWNlKC8oamF2YXNjcmlwdDp8IykuKiQvLCAnJyk7XG4gICAgICAgIGxvY2F0aW9uLnJlcGxhY2UoaHJlZiArICcjJyArIGZyYWdtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNvbWUgYnJvd3NlcnMgcmVxdWlyZSB0aGF0IGBoYXNoYCBjb250YWlucyBhIGxlYWRpbmcgIy5cbiAgICAgICAgbG9jYXRpb24uaGFzaCA9ICcjJyArIGZyYWdtZW50O1xuICAgICAgfVxuICAgIH1cblxuICB9KTtcblxuICAvLyBDcmVhdGUgdGhlIGRlZmF1bHQgQmFja2JvbmUuaGlzdG9yeS5cbiAgQmFja2JvbmUuaGlzdG9yeSA9IG5ldyBIaXN0b3J5O1xuXG4gIC8vIEhlbHBlcnNcbiAgLy8gLS0tLS0tLVxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjb3JyZWN0bHkgc2V0IHVwIHRoZSBwcm90b3R5cGUgY2hhaW4sIGZvciBzdWJjbGFzc2VzLlxuICAvLyBTaW1pbGFyIHRvIGBnb29nLmluaGVyaXRzYCwgYnV0IHVzZXMgYSBoYXNoIG9mIHByb3RvdHlwZSBwcm9wZXJ0aWVzIGFuZFxuICAvLyBjbGFzcyBwcm9wZXJ0aWVzIHRvIGJlIGV4dGVuZGVkLlxuICB2YXIgZXh0ZW5kID0gZnVuY3Rpb24ocHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcztcbiAgICB2YXIgY2hpbGQ7XG5cbiAgICAvLyBUaGUgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHRoZSBuZXcgc3ViY2xhc3MgaXMgZWl0aGVyIGRlZmluZWQgYnkgeW91XG4gICAgLy8gKHRoZSBcImNvbnN0cnVjdG9yXCIgcHJvcGVydHkgaW4geW91ciBgZXh0ZW5kYCBkZWZpbml0aW9uKSwgb3IgZGVmYXVsdGVkXG4gICAgLy8gYnkgdXMgdG8gc2ltcGx5IGNhbGwgdGhlIHBhcmVudCdzIGNvbnN0cnVjdG9yLlxuICAgIGlmIChwcm90b1Byb3BzICYmIF8uaGFzKHByb3RvUHJvcHMsICdjb25zdHJ1Y3RvcicpKSB7XG4gICAgICBjaGlsZCA9IHByb3RvUHJvcHMuY29uc3RydWN0b3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoaWxkID0gZnVuY3Rpb24oKXsgcmV0dXJuIHBhcmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9O1xuICAgIH1cblxuICAgIC8vIEFkZCBzdGF0aWMgcHJvcGVydGllcyB0byB0aGUgY29uc3RydWN0b3IgZnVuY3Rpb24sIGlmIHN1cHBsaWVkLlxuICAgIF8uZXh0ZW5kKGNoaWxkLCBwYXJlbnQsIHN0YXRpY1Byb3BzKTtcblxuICAgIC8vIFNldCB0aGUgcHJvdG90eXBlIGNoYWluIHRvIGluaGVyaXQgZnJvbSBgcGFyZW50YCwgd2l0aG91dCBjYWxsaW5nXG4gICAgLy8gYHBhcmVudGAncyBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICB2YXIgU3Vycm9nYXRlID0gZnVuY3Rpb24oKXsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9O1xuICAgIFN1cnJvZ2F0ZS5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlO1xuICAgIGNoaWxkLnByb3RvdHlwZSA9IG5ldyBTdXJyb2dhdGU7XG5cbiAgICAvLyBBZGQgcHJvdG90eXBlIHByb3BlcnRpZXMgKGluc3RhbmNlIHByb3BlcnRpZXMpIHRvIHRoZSBzdWJjbGFzcyxcbiAgICAvLyBpZiBzdXBwbGllZC5cbiAgICBpZiAocHJvdG9Qcm9wcykgXy5leHRlbmQoY2hpbGQucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcblxuICAgIC8vIFNldCBhIGNvbnZlbmllbmNlIHByb3BlcnR5IGluIGNhc2UgdGhlIHBhcmVudCdzIHByb3RvdHlwZSBpcyBuZWVkZWRcbiAgICAvLyBsYXRlci5cbiAgICBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlO1xuXG4gICAgcmV0dXJuIGNoaWxkO1xuICB9O1xuXG4gIC8vIFNldCB1cCBpbmhlcml0YW5jZSBmb3IgdGhlIG1vZGVsLCBjb2xsZWN0aW9uLCByb3V0ZXIsIHZpZXcgYW5kIGhpc3RvcnkuXG4gIE1vZGVsLmV4dGVuZCA9IENvbGxlY3Rpb24uZXh0ZW5kID0gUm91dGVyLmV4dGVuZCA9IFZpZXcuZXh0ZW5kID0gSGlzdG9yeS5leHRlbmQgPSBleHRlbmQ7XG5cbiAgLy8gVGhyb3cgYW4gZXJyb3Igd2hlbiBhIFVSTCBpcyBuZWVkZWQsIGFuZCBub25lIGlzIHN1cHBsaWVkLlxuICB2YXIgdXJsRXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgXCJ1cmxcIiBwcm9wZXJ0eSBvciBmdW5jdGlvbiBtdXN0IGJlIHNwZWNpZmllZCcpO1xuICB9O1xuXG4gIC8vIFdyYXAgYW4gb3B0aW9uYWwgZXJyb3IgY2FsbGJhY2sgd2l0aCBhIGZhbGxiYWNrIGVycm9yIGV2ZW50LlxuICB2YXIgd3JhcEVycm9yID0gZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgZXJyb3IgPSBvcHRpb25zLmVycm9yO1xuICAgIG9wdGlvbnMuZXJyb3IgPSBmdW5jdGlvbihyZXNwKSB7XG4gICAgICBpZiAoZXJyb3IpIGVycm9yKG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgIG1vZGVsLnRyaWdnZXIoJ2Vycm9yJywgbW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgIH07XG4gIH07XG5cbn0pLmNhbGwodGhpcyk7XG4iLCJ2YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xudmFyIGludFNpemUgPSA0O1xudmFyIHplcm9CdWZmZXIgPSBuZXcgQnVmZmVyKGludFNpemUpOyB6ZXJvQnVmZmVyLmZpbGwoMCk7XG52YXIgY2hyc3ogPSA4O1xuXG5mdW5jdGlvbiB0b0FycmF5KGJ1ZiwgYmlnRW5kaWFuKSB7XG4gIGlmICgoYnVmLmxlbmd0aCAlIGludFNpemUpICE9PSAwKSB7XG4gICAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGggKyAoaW50U2l6ZSAtIChidWYubGVuZ3RoICUgaW50U2l6ZSkpO1xuICAgIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoW2J1ZiwgemVyb0J1ZmZlcl0sIGxlbik7XG4gIH1cblxuICB2YXIgYXJyID0gW107XG4gIHZhciBmbiA9IGJpZ0VuZGlhbiA/IGJ1Zi5yZWFkSW50MzJCRSA6IGJ1Zi5yZWFkSW50MzJMRTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpICs9IGludFNpemUpIHtcbiAgICBhcnIucHVzaChmbi5jYWxsKGJ1ZiwgaSkpO1xuICB9XG4gIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIHRvQnVmZmVyKGFyciwgc2l6ZSwgYmlnRW5kaWFuKSB7XG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHNpemUpO1xuICB2YXIgZm4gPSBiaWdFbmRpYW4gPyBidWYud3JpdGVJbnQzMkJFIDogYnVmLndyaXRlSW50MzJMRTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBmbi5jYWxsKGJ1ZiwgYXJyW2ldLCBpICogNCwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIGJ1Zjtcbn1cblxuZnVuY3Rpb24gaGFzaChidWYsIGZuLCBoYXNoU2l6ZSwgYmlnRW5kaWFuKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIGJ1ZiA9IG5ldyBCdWZmZXIoYnVmKTtcbiAgdmFyIGFyciA9IGZuKHRvQXJyYXkoYnVmLCBiaWdFbmRpYW4pLCBidWYubGVuZ3RoICogY2hyc3opO1xuICByZXR1cm4gdG9CdWZmZXIoYXJyLCBoYXNoU2l6ZSwgYmlnRW5kaWFuKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IGhhc2g6IGhhc2ggfTtcbiIsInZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXJcbnZhciBzaGEgPSByZXF1aXJlKCcuL3NoYScpXG52YXIgc2hhMjU2ID0gcmVxdWlyZSgnLi9zaGEyNTYnKVxudmFyIHJuZyA9IHJlcXVpcmUoJy4vcm5nJylcbnZhciBtZDUgPSByZXF1aXJlKCcuL21kNScpXG5cbnZhciBhbGdvcml0aG1zID0ge1xuICBzaGExOiBzaGEsXG4gIHNoYTI1Njogc2hhMjU2LFxuICBtZDU6IG1kNVxufVxuXG52YXIgYmxvY2tzaXplID0gNjRcbnZhciB6ZXJvQnVmZmVyID0gbmV3IEJ1ZmZlcihibG9ja3NpemUpOyB6ZXJvQnVmZmVyLmZpbGwoMClcbmZ1bmN0aW9uIGhtYWMoZm4sIGtleSwgZGF0YSkge1xuICBpZighQnVmZmVyLmlzQnVmZmVyKGtleSkpIGtleSA9IG5ldyBCdWZmZXIoa2V5KVxuICBpZighQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSBkYXRhID0gbmV3IEJ1ZmZlcihkYXRhKVxuXG4gIGlmKGtleS5sZW5ndGggPiBibG9ja3NpemUpIHtcbiAgICBrZXkgPSBmbihrZXkpXG4gIH0gZWxzZSBpZihrZXkubGVuZ3RoIDwgYmxvY2tzaXplKSB7XG4gICAga2V5ID0gQnVmZmVyLmNvbmNhdChba2V5LCB6ZXJvQnVmZmVyXSwgYmxvY2tzaXplKVxuICB9XG5cbiAgdmFyIGlwYWQgPSBuZXcgQnVmZmVyKGJsb2Nrc2l6ZSksIG9wYWQgPSBuZXcgQnVmZmVyKGJsb2Nrc2l6ZSlcbiAgZm9yKHZhciBpID0gMDsgaSA8IGJsb2Nrc2l6ZTsgaSsrKSB7XG4gICAgaXBhZFtpXSA9IGtleVtpXSBeIDB4MzZcbiAgICBvcGFkW2ldID0ga2V5W2ldIF4gMHg1Q1xuICB9XG5cbiAgdmFyIGhhc2ggPSBmbihCdWZmZXIuY29uY2F0KFtpcGFkLCBkYXRhXSkpXG4gIHJldHVybiBmbihCdWZmZXIuY29uY2F0KFtvcGFkLCBoYXNoXSkpXG59XG5cbmZ1bmN0aW9uIGhhc2goYWxnLCBrZXkpIHtcbiAgYWxnID0gYWxnIHx8ICdzaGExJ1xuICB2YXIgZm4gPSBhbGdvcml0aG1zW2FsZ11cbiAgdmFyIGJ1ZnMgPSBbXVxuICB2YXIgbGVuZ3RoID0gMFxuICBpZighZm4pIGVycm9yKCdhbGdvcml0aG06JywgYWxnLCAnaXMgbm90IHlldCBzdXBwb3J0ZWQnKVxuICByZXR1cm4ge1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIGlmKCFCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIGRhdGEgPSBuZXcgQnVmZmVyKGRhdGEpXG4gICAgICAgIFxuICAgICAgYnVmcy5wdXNoKGRhdGEpXG4gICAgICBsZW5ndGggKz0gZGF0YS5sZW5ndGhcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcbiAgICBkaWdlc3Q6IGZ1bmN0aW9uIChlbmMpIHtcbiAgICAgIHZhciBidWYgPSBCdWZmZXIuY29uY2F0KGJ1ZnMpXG4gICAgICB2YXIgciA9IGtleSA/IGhtYWMoZm4sIGtleSwgYnVmKSA6IGZuKGJ1ZilcbiAgICAgIGJ1ZnMgPSBudWxsXG4gICAgICByZXR1cm4gZW5jID8gci50b1N0cmluZyhlbmMpIDogclxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBlcnJvciAoKSB7XG4gIHZhciBtID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLmpvaW4oJyAnKVxuICB0aHJvdyBuZXcgRXJyb3IoW1xuICAgIG0sXG4gICAgJ3dlIGFjY2VwdCBwdWxsIHJlcXVlc3RzJyxcbiAgICAnaHR0cDovL2dpdGh1Yi5jb20vZG9taW5pY3RhcnIvY3J5cHRvLWJyb3dzZXJpZnknXG4gICAgXS5qb2luKCdcXG4nKSlcbn1cblxuZXhwb3J0cy5jcmVhdGVIYXNoID0gZnVuY3Rpb24gKGFsZykgeyByZXR1cm4gaGFzaChhbGcpIH1cbmV4cG9ydHMuY3JlYXRlSG1hYyA9IGZ1bmN0aW9uIChhbGcsIGtleSkgeyByZXR1cm4gaGFzaChhbGcsIGtleSkgfVxuZXhwb3J0cy5yYW5kb21CeXRlcyA9IGZ1bmN0aW9uKHNpemUsIGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgdW5kZWZpbmVkLCBuZXcgQnVmZmVyKHJuZyhzaXplKSkpXG4gICAgfSBjYXRjaCAoZXJyKSB7IGNhbGxiYWNrKGVycikgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKHJuZyhzaXplKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBlYWNoKGEsIGYpIHtcbiAgZm9yKHZhciBpIGluIGEpXG4gICAgZihhW2ldLCBpKVxufVxuXG4vLyB0aGUgbGVhc3QgSSBjYW4gZG8gaXMgbWFrZSBlcnJvciBtZXNzYWdlcyBmb3IgdGhlIHJlc3Qgb2YgdGhlIG5vZGUuanMvY3J5cHRvIGFwaS5cbmVhY2goWydjcmVhdGVDcmVkZW50aWFscydcbiwgJ2NyZWF0ZUNpcGhlcidcbiwgJ2NyZWF0ZUNpcGhlcml2J1xuLCAnY3JlYXRlRGVjaXBoZXInXG4sICdjcmVhdGVEZWNpcGhlcml2J1xuLCAnY3JlYXRlU2lnbidcbiwgJ2NyZWF0ZVZlcmlmeSdcbiwgJ2NyZWF0ZURpZmZpZUhlbGxtYW4nXG4sICdwYmtkZjInXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgZXhwb3J0c1tuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBlcnJvcignc29ycnksJywgbmFtZSwgJ2lzIG5vdCBpbXBsZW1lbnRlZCB5ZXQnKVxuICB9XG59KVxuIiwiLypcclxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBSU0EgRGF0YSBTZWN1cml0eSwgSW5jLiBNRDUgTWVzc2FnZVxyXG4gKiBEaWdlc3QgQWxnb3JpdGhtLCBhcyBkZWZpbmVkIGluIFJGQyAxMzIxLlxyXG4gKiBWZXJzaW9uIDIuMSBDb3B5cmlnaHQgKEMpIFBhdWwgSm9obnN0b24gMTk5OSAtIDIwMDIuXHJcbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcclxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlXHJcbiAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBtb3JlIGluZm8uXHJcbiAqL1xyXG5cclxudmFyIGhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcclxuXHJcbi8qXHJcbiAqIFBlcmZvcm0gYSBzaW1wbGUgc2VsZi10ZXN0IHRvIHNlZSBpZiB0aGUgVk0gaXMgd29ya2luZ1xyXG4gKi9cclxuZnVuY3Rpb24gbWQ1X3ZtX3Rlc3QoKVxyXG57XHJcbiAgcmV0dXJuIGhleF9tZDUoXCJhYmNcIikgPT0gXCI5MDAxNTA5ODNjZDI0ZmIwZDY5NjNmN2QyOGUxN2Y3MlwiO1xyXG59XHJcblxyXG4vKlxyXG4gKiBDYWxjdWxhdGUgdGhlIE1ENSBvZiBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzLCBhbmQgYSBiaXQgbGVuZ3RoXHJcbiAqL1xyXG5mdW5jdGlvbiBjb3JlX21kNSh4LCBsZW4pXHJcbntcclxuICAvKiBhcHBlbmQgcGFkZGluZyAqL1xyXG4gIHhbbGVuID4+IDVdIHw9IDB4ODAgPDwgKChsZW4pICUgMzIpO1xyXG4gIHhbKCgobGVuICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IGxlbjtcclxuXHJcbiAgdmFyIGEgPSAgMTczMjU4NDE5MztcclxuICB2YXIgYiA9IC0yNzE3MzM4Nzk7XHJcbiAgdmFyIGMgPSAtMTczMjU4NDE5NDtcclxuICB2YXIgZCA9ICAyNzE3MzM4Nzg7XHJcblxyXG4gIGZvcih2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSArPSAxNilcclxuICB7XHJcbiAgICB2YXIgb2xkYSA9IGE7XHJcbiAgICB2YXIgb2xkYiA9IGI7XHJcbiAgICB2YXIgb2xkYyA9IGM7XHJcbiAgICB2YXIgb2xkZCA9IGQ7XHJcblxyXG4gICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2krIDBdLCA3ICwgLTY4MDg3NjkzNik7XHJcbiAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSsgMV0sIDEyLCAtMzg5NTY0NTg2KTtcclxuICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpKyAyXSwgMTcsICA2MDYxMDU4MTkpO1xyXG4gICAgYiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2krIDNdLCAyMiwgLTEwNDQ1MjUzMzApO1xyXG4gICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2krIDRdLCA3ICwgLTE3NjQxODg5Nyk7XHJcbiAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSsgNV0sIDEyLCAgMTIwMDA4MDQyNik7XHJcbiAgICBjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSsgNl0sIDE3LCAtMTQ3MzIzMTM0MSk7XHJcbiAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSsgN10sIDIyLCAtNDU3MDU5ODMpO1xyXG4gICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2krIDhdLCA3ICwgIDE3NzAwMzU0MTYpO1xyXG4gICAgZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2krIDldLCAxMiwgLTE5NTg0MTQ0MTcpO1xyXG4gICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2krMTBdLCAxNywgLTQyMDYzKTtcclxuICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpKzExXSwgMjIsIC0xOTkwNDA0MTYyKTtcclxuICAgIGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpKzEyXSwgNyAsICAxODA0NjAzNjgyKTtcclxuICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpKzEzXSwgMTIsIC00MDM0MTEwMSk7XHJcbiAgICBjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSsxNF0sIDE3LCAtMTUwMjAwMjI5MCk7XHJcbiAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSsxNV0sIDIyLCAgMTIzNjUzNTMyOSk7XHJcblxyXG4gICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2krIDFdLCA1ICwgLTE2NTc5NjUxMCk7XHJcbiAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSsgNl0sIDkgLCAtMTA2OTUwMTYzMik7XHJcbiAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsxMV0sIDE0LCAgNjQzNzE3NzEzKTtcclxuICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpKyAwXSwgMjAsIC0zNzM4OTczMDIpO1xyXG4gICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2krIDVdLCA1ICwgLTcwMTU1ODY5MSk7XHJcbiAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSsxMF0sIDkgLCAgMzgwMTYwODMpO1xyXG4gICAgYyA9IG1kNV9nZyhjLCBkLCBhLCBiLCB4W2krMTVdLCAxNCwgLTY2MDQ3ODMzNSk7XHJcbiAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSsgNF0sIDIwLCAtNDA1NTM3ODQ4KTtcclxuICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpKyA5XSwgNSAsICA1Njg0NDY0MzgpO1xyXG4gICAgZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2krMTRdLCA5ICwgLTEwMTk4MDM2OTApO1xyXG4gICAgYyA9IG1kNV9nZyhjLCBkLCBhLCBiLCB4W2krIDNdLCAxNCwgLTE4NzM2Mzk2MSk7XHJcbiAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSsgOF0sIDIwLCAgMTE2MzUzMTUwMSk7XHJcbiAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSsxM10sIDUgLCAtMTQ0NDY4MTQ2Nyk7XHJcbiAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSsgMl0sIDkgLCAtNTE0MDM3ODQpO1xyXG4gICAgYyA9IG1kNV9nZyhjLCBkLCBhLCBiLCB4W2krIDddLCAxNCwgIDE3MzUzMjg0NzMpO1xyXG4gICAgYiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2krMTJdLCAyMCwgLTE5MjY2MDc3MzQpO1xyXG5cclxuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKyA1XSwgNCAsIC0zNzg1NTgpO1xyXG4gICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2krIDhdLCAxMSwgLTIwMjI1NzQ0NjMpO1xyXG4gICAgYyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2krMTFdLCAxNiwgIDE4MzkwMzA1NjIpO1xyXG4gICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krMTRdLCAyMywgLTM1MzA5NTU2KTtcclxuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKyAxXSwgNCAsIC0xNTMwOTkyMDYwKTtcclxuICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpKyA0XSwgMTEsICAxMjcyODkzMzUzKTtcclxuICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpKyA3XSwgMTYsIC0xNTU0OTc2MzIpO1xyXG4gICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krMTBdLCAyMywgLTEwOTQ3MzA2NDApO1xyXG4gICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2krMTNdLCA0ICwgIDY4MTI3OTE3NCk7XHJcbiAgICBkID0gbWQ1X2hoKGQsIGEsIGIsIGMsIHhbaSsgMF0sIDExLCAtMzU4NTM3MjIyKTtcclxuICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpKyAzXSwgMTYsIC03MjI1MjE5NzkpO1xyXG4gICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krIDZdLCAyMywgIDc2MDI5MTg5KTtcclxuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKyA5XSwgNCAsIC02NDAzNjQ0ODcpO1xyXG4gICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2krMTJdLCAxMSwgLTQyMTgxNTgzNSk7XHJcbiAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSsxNV0sIDE2LCAgNTMwNzQyNTIwKTtcclxuICAgIGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpKyAyXSwgMjMsIC05OTUzMzg2NTEpO1xyXG5cclxuICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpKyAwXSwgNiAsIC0xOTg2MzA4NDQpO1xyXG4gICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2krIDddLCAxMCwgIDExMjY4OTE0MTUpO1xyXG4gICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2krMTRdLCAxNSwgLTE0MTYzNTQ5MDUpO1xyXG4gICAgYiA9IG1kNV9paShiLCBjLCBkLCBhLCB4W2krIDVdLCAyMSwgLTU3NDM0MDU1KTtcclxuICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpKzEyXSwgNiAsICAxNzAwNDg1NTcxKTtcclxuICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpKyAzXSwgMTAsIC0xODk0OTg2NjA2KTtcclxuICAgIGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpKzEwXSwgMTUsIC0xMDUxNTIzKTtcclxuICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpKyAxXSwgMjEsIC0yMDU0OTIyNzk5KTtcclxuICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpKyA4XSwgNiAsICAxODczMzEzMzU5KTtcclxuICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpKzE1XSwgMTAsIC0zMDYxMTc0NCk7XHJcbiAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSsgNl0sIDE1LCAtMTU2MDE5ODM4MCk7XHJcbiAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSsxM10sIDIxLCAgMTMwOTE1MTY0OSk7XHJcbiAgICBhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSsgNF0sIDYgLCAtMTQ1NTIzMDcwKTtcclxuICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpKzExXSwgMTAsIC0xMTIwMjEwMzc5KTtcclxuICAgIGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpKyAyXSwgMTUsICA3MTg3ODcyNTkpO1xyXG4gICAgYiA9IG1kNV9paShiLCBjLCBkLCBhLCB4W2krIDldLCAyMSwgLTM0MzQ4NTU1MSk7XHJcblxyXG4gICAgYSA9IHNhZmVfYWRkKGEsIG9sZGEpO1xyXG4gICAgYiA9IHNhZmVfYWRkKGIsIG9sZGIpO1xyXG4gICAgYyA9IHNhZmVfYWRkKGMsIG9sZGMpO1xyXG4gICAgZCA9IHNhZmVfYWRkKGQsIG9sZGQpO1xyXG4gIH1cclxuICByZXR1cm4gQXJyYXkoYSwgYiwgYywgZCk7XHJcblxyXG59XHJcblxyXG4vKlxyXG4gKiBUaGVzZSBmdW5jdGlvbnMgaW1wbGVtZW50IHRoZSBmb3VyIGJhc2ljIG9wZXJhdGlvbnMgdGhlIGFsZ29yaXRobSB1c2VzLlxyXG4gKi9cclxuZnVuY3Rpb24gbWQ1X2NtbihxLCBhLCBiLCB4LCBzLCB0KVxyXG57XHJcbiAgcmV0dXJuIHNhZmVfYWRkKGJpdF9yb2woc2FmZV9hZGQoc2FmZV9hZGQoYSwgcSksIHNhZmVfYWRkKHgsIHQpKSwgcyksYik7XHJcbn1cclxuZnVuY3Rpb24gbWQ1X2ZmKGEsIGIsIGMsIGQsIHgsIHMsIHQpXHJcbntcclxuICByZXR1cm4gbWQ1X2NtbigoYiAmIGMpIHwgKCh+YikgJiBkKSwgYSwgYiwgeCwgcywgdCk7XHJcbn1cclxuZnVuY3Rpb24gbWQ1X2dnKGEsIGIsIGMsIGQsIHgsIHMsIHQpXHJcbntcclxuICByZXR1cm4gbWQ1X2NtbigoYiAmIGQpIHwgKGMgJiAofmQpKSwgYSwgYiwgeCwgcywgdCk7XHJcbn1cclxuZnVuY3Rpb24gbWQ1X2hoKGEsIGIsIGMsIGQsIHgsIHMsIHQpXHJcbntcclxuICByZXR1cm4gbWQ1X2NtbihiIF4gYyBeIGQsIGEsIGIsIHgsIHMsIHQpO1xyXG59XHJcbmZ1bmN0aW9uIG1kNV9paShhLCBiLCBjLCBkLCB4LCBzLCB0KVxyXG57XHJcbiAgcmV0dXJuIG1kNV9jbW4oYyBeIChiIHwgKH5kKSksIGEsIGIsIHgsIHMsIHQpO1xyXG59XHJcblxyXG4vKlxyXG4gKiBBZGQgaW50ZWdlcnMsIHdyYXBwaW5nIGF0IDJeMzIuIFRoaXMgdXNlcyAxNi1iaXQgb3BlcmF0aW9ucyBpbnRlcm5hbGx5XHJcbiAqIHRvIHdvcmsgYXJvdW5kIGJ1Z3MgaW4gc29tZSBKUyBpbnRlcnByZXRlcnMuXHJcbiAqL1xyXG5mdW5jdGlvbiBzYWZlX2FkZCh4LCB5KVxyXG57XHJcbiAgdmFyIGxzdyA9ICh4ICYgMHhGRkZGKSArICh5ICYgMHhGRkZGKTtcclxuICB2YXIgbXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7XHJcbiAgcmV0dXJuIChtc3cgPDwgMTYpIHwgKGxzdyAmIDB4RkZGRik7XHJcbn1cclxuXHJcbi8qXHJcbiAqIEJpdHdpc2Ugcm90YXRlIGEgMzItYml0IG51bWJlciB0byB0aGUgbGVmdC5cclxuICovXHJcbmZ1bmN0aW9uIGJpdF9yb2wobnVtLCBjbnQpXHJcbntcclxuICByZXR1cm4gKG51bSA8PCBjbnQpIHwgKG51bSA+Pj4gKDMyIC0gY250KSk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWQ1KGJ1Zikge1xyXG4gIHJldHVybiBoZWxwZXJzLmhhc2goYnVmLCBjb3JlX21kNSwgMTYpO1xyXG59O1xyXG4iLCIvLyBPcmlnaW5hbCBjb2RlIGFkYXB0ZWQgZnJvbSBSb2JlcnQgS2llZmZlci5cbi8vIGRldGFpbHMgYXQgaHR0cHM6Ly9naXRodWIuY29tL2Jyb29mYS9ub2RlLXV1aWRcbihmdW5jdGlvbigpIHtcbiAgdmFyIF9nbG9iYWwgPSB0aGlzO1xuXG4gIHZhciBtYXRoUk5HLCB3aGF0d2dSTkc7XG5cbiAgLy8gTk9URTogTWF0aC5yYW5kb20oKSBkb2VzIG5vdCBndWFyYW50ZWUgXCJjcnlwdG9ncmFwaGljIHF1YWxpdHlcIlxuICBtYXRoUk5HID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIHZhciBieXRlcyA9IG5ldyBBcnJheShzaXplKTtcbiAgICB2YXIgcjtcblxuICAgIGZvciAodmFyIGkgPSAwLCByOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICBpZiAoKGkgJiAweDAzKSA9PSAwKSByID0gTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwO1xuICAgICAgYnl0ZXNbaV0gPSByID4+PiAoKGkgJiAweDAzKSA8PCAzKSAmIDB4ZmY7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ5dGVzO1xuICB9XG5cbiAgaWYgKF9nbG9iYWwuY3J5cHRvICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICB3aGF0d2dSTkcgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYnl0ZXMpO1xuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgfVxuXG4gIG1vZHVsZS5leHBvcnRzID0gd2hhdHdnUk5HIHx8IG1hdGhSTkc7XG5cbn0oKSlcbiIsIi8qXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTEsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgUFVCIDE4MC0xXG4gKiBWZXJzaW9uIDIuMWEgQ29weXJpZ2h0IFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDIuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2VcbiAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBkZXRhaWxzLlxuICovXG5cbnZhciBoZWxwZXJzID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XG5cbi8qXG4gKiBDYWxjdWxhdGUgdGhlIFNIQS0xIG9mIGFuIGFycmF5IG9mIGJpZy1lbmRpYW4gd29yZHMsIGFuZCBhIGJpdCBsZW5ndGhcbiAqL1xuZnVuY3Rpb24gY29yZV9zaGExKHgsIGxlbilcbntcbiAgLyogYXBwZW5kIHBhZGRpbmcgKi9cbiAgeFtsZW4gPj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBsZW4gJSAzMik7XG4gIHhbKChsZW4gKyA2NCA+PiA5KSA8PCA0KSArIDE1XSA9IGxlbjtcblxuICB2YXIgdyA9IEFycmF5KDgwKTtcbiAgdmFyIGEgPSAgMTczMjU4NDE5MztcbiAgdmFyIGIgPSAtMjcxNzMzODc5O1xuICB2YXIgYyA9IC0xNzMyNTg0MTk0O1xuICB2YXIgZCA9ICAyNzE3MzM4Nzg7XG4gIHZhciBlID0gLTEwMDk1ODk3NzY7XG5cbiAgZm9yKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpICs9IDE2KVxuICB7XG4gICAgdmFyIG9sZGEgPSBhO1xuICAgIHZhciBvbGRiID0gYjtcbiAgICB2YXIgb2xkYyA9IGM7XG4gICAgdmFyIG9sZGQgPSBkO1xuICAgIHZhciBvbGRlID0gZTtcblxuICAgIGZvcih2YXIgaiA9IDA7IGogPCA4MDsgaisrKVxuICAgIHtcbiAgICAgIGlmKGogPCAxNikgd1tqXSA9IHhbaSArIGpdO1xuICAgICAgZWxzZSB3W2pdID0gcm9sKHdbai0zXSBeIHdbai04XSBeIHdbai0xNF0gXiB3W2otMTZdLCAxKTtcbiAgICAgIHZhciB0ID0gc2FmZV9hZGQoc2FmZV9hZGQocm9sKGEsIDUpLCBzaGExX2Z0KGosIGIsIGMsIGQpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgc2FmZV9hZGQoc2FmZV9hZGQoZSwgd1tqXSksIHNoYTFfa3QoaikpKTtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICBjID0gcm9sKGIsIDMwKTtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IHQ7XG4gICAgfVxuXG4gICAgYSA9IHNhZmVfYWRkKGEsIG9sZGEpO1xuICAgIGIgPSBzYWZlX2FkZChiLCBvbGRiKTtcbiAgICBjID0gc2FmZV9hZGQoYywgb2xkYyk7XG4gICAgZCA9IHNhZmVfYWRkKGQsIG9sZGQpO1xuICAgIGUgPSBzYWZlX2FkZChlLCBvbGRlKTtcbiAgfVxuICByZXR1cm4gQXJyYXkoYSwgYiwgYywgZCwgZSk7XG5cbn1cblxuLypcbiAqIFBlcmZvcm0gdGhlIGFwcHJvcHJpYXRlIHRyaXBsZXQgY29tYmluYXRpb24gZnVuY3Rpb24gZm9yIHRoZSBjdXJyZW50XG4gKiBpdGVyYXRpb25cbiAqL1xuZnVuY3Rpb24gc2hhMV9mdCh0LCBiLCBjLCBkKVxue1xuICBpZih0IDwgMjApIHJldHVybiAoYiAmIGMpIHwgKCh+YikgJiBkKTtcbiAgaWYodCA8IDQwKSByZXR1cm4gYiBeIGMgXiBkO1xuICBpZih0IDwgNjApIHJldHVybiAoYiAmIGMpIHwgKGIgJiBkKSB8IChjICYgZCk7XG4gIHJldHVybiBiIF4gYyBeIGQ7XG59XG5cbi8qXG4gKiBEZXRlcm1pbmUgdGhlIGFwcHJvcHJpYXRlIGFkZGl0aXZlIGNvbnN0YW50IGZvciB0aGUgY3VycmVudCBpdGVyYXRpb25cbiAqL1xuZnVuY3Rpb24gc2hhMV9rdCh0KVxue1xuICByZXR1cm4gKHQgPCAyMCkgPyAgMTUxODUwMDI0OSA6ICh0IDwgNDApID8gIDE4NTk3NzUzOTMgOlxuICAgICAgICAgKHQgPCA2MCkgPyAtMTg5NDAwNzU4OCA6IC04OTk0OTc1MTQ7XG59XG5cbi8qXG4gKiBBZGQgaW50ZWdlcnMsIHdyYXBwaW5nIGF0IDJeMzIuIFRoaXMgdXNlcyAxNi1iaXQgb3BlcmF0aW9ucyBpbnRlcm5hbGx5XG4gKiB0byB3b3JrIGFyb3VuZCBidWdzIGluIHNvbWUgSlMgaW50ZXJwcmV0ZXJzLlxuICovXG5mdW5jdGlvbiBzYWZlX2FkZCh4LCB5KVxue1xuICB2YXIgbHN3ID0gKHggJiAweEZGRkYpICsgKHkgJiAweEZGRkYpO1xuICB2YXIgbXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7XG4gIHJldHVybiAobXN3IDw8IDE2KSB8IChsc3cgJiAweEZGRkYpO1xufVxuXG4vKlxuICogQml0d2lzZSByb3RhdGUgYSAzMi1iaXQgbnVtYmVyIHRvIHRoZSBsZWZ0LlxuICovXG5mdW5jdGlvbiByb2wobnVtLCBjbnQpXG57XG4gIHJldHVybiAobnVtIDw8IGNudCkgfCAobnVtID4+PiAoMzIgLSBjbnQpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzaGExKGJ1Zikge1xuICByZXR1cm4gaGVscGVycy5oYXNoKGJ1ZiwgY29yZV9zaGExLCAyMCwgdHJ1ZSk7XG59O1xuIiwiXG4vKipcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2VjdXJlIEhhc2ggQWxnb3JpdGhtLCBTSEEtMjU2LCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIDE4MC0yXG4gKiBWZXJzaW9uIDIuMi1iZXRhIENvcHlyaWdodCBBbmdlbCBNYXJpbiwgUGF1bCBKb2huc3RvbiAyMDAwIC0gMjAwOS5cbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqXG4gKi9cblxudmFyIGhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcblxudmFyIHNhZmVfYWRkID0gZnVuY3Rpb24oeCwgeSkge1xuICB2YXIgbHN3ID0gKHggJiAweEZGRkYpICsgKHkgJiAweEZGRkYpO1xuICB2YXIgbXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7XG4gIHJldHVybiAobXN3IDw8IDE2KSB8IChsc3cgJiAweEZGRkYpO1xufTtcblxudmFyIFMgPSBmdW5jdGlvbihYLCBuKSB7XG4gIHJldHVybiAoWCA+Pj4gbikgfCAoWCA8PCAoMzIgLSBuKSk7XG59O1xuXG52YXIgUiA9IGZ1bmN0aW9uKFgsIG4pIHtcbiAgcmV0dXJuIChYID4+PiBuKTtcbn07XG5cbnZhciBDaCA9IGZ1bmN0aW9uKHgsIHksIHopIHtcbiAgcmV0dXJuICgoeCAmIHkpIF4gKCh+eCkgJiB6KSk7XG59O1xuXG52YXIgTWFqID0gZnVuY3Rpb24oeCwgeSwgeikge1xuICByZXR1cm4gKCh4ICYgeSkgXiAoeCAmIHopIF4gKHkgJiB6KSk7XG59O1xuXG52YXIgU2lnbWEwMjU2ID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gKFMoeCwgMikgXiBTKHgsIDEzKSBeIFMoeCwgMjIpKTtcbn07XG5cbnZhciBTaWdtYTEyNTYgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiAoUyh4LCA2KSBeIFMoeCwgMTEpIF4gUyh4LCAyNSkpO1xufTtcblxudmFyIEdhbW1hMDI1NiA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIChTKHgsIDcpIF4gUyh4LCAxOCkgXiBSKHgsIDMpKTtcbn07XG5cbnZhciBHYW1tYTEyNTYgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiAoUyh4LCAxNykgXiBTKHgsIDE5KSBeIFIoeCwgMTApKTtcbn07XG5cbnZhciBjb3JlX3NoYTI1NiA9IGZ1bmN0aW9uKG0sIGwpIHtcbiAgdmFyIEsgPSBuZXcgQXJyYXkoMHg0MjhBMkY5OCwweDcxMzc0NDkxLDB4QjVDMEZCQ0YsMHhFOUI1REJBNSwweDM5NTZDMjVCLDB4NTlGMTExRjEsMHg5MjNGODJBNCwweEFCMUM1RUQ1LDB4RDgwN0FBOTgsMHgxMjgzNUIwMSwweDI0MzE4NUJFLDB4NTUwQzdEQzMsMHg3MkJFNUQ3NCwweDgwREVCMUZFLDB4OUJEQzA2QTcsMHhDMTlCRjE3NCwweEU0OUI2OUMxLDB4RUZCRTQ3ODYsMHhGQzE5REM2LDB4MjQwQ0ExQ0MsMHgyREU5MkM2RiwweDRBNzQ4NEFBLDB4NUNCMEE5REMsMHg3NkY5ODhEQSwweDk4M0U1MTUyLDB4QTgzMUM2NkQsMHhCMDAzMjdDOCwweEJGNTk3RkM3LDB4QzZFMDBCRjMsMHhENUE3OTE0NywweDZDQTYzNTEsMHgxNDI5Mjk2NywweDI3QjcwQTg1LDB4MkUxQjIxMzgsMHg0RDJDNkRGQywweDUzMzgwRDEzLDB4NjUwQTczNTQsMHg3NjZBMEFCQiwweDgxQzJDOTJFLDB4OTI3MjJDODUsMHhBMkJGRThBMSwweEE4MUE2NjRCLDB4QzI0QjhCNzAsMHhDNzZDNTFBMywweEQxOTJFODE5LDB4RDY5OTA2MjQsMHhGNDBFMzU4NSwweDEwNkFBMDcwLDB4MTlBNEMxMTYsMHgxRTM3NkMwOCwweDI3NDg3NzRDLDB4MzRCMEJDQjUsMHgzOTFDMENCMywweDRFRDhBQTRBLDB4NUI5Q0NBNEYsMHg2ODJFNkZGMywweDc0OEY4MkVFLDB4NzhBNTYzNkYsMHg4NEM4NzgxNCwweDhDQzcwMjA4LDB4OTBCRUZGRkEsMHhBNDUwNkNFQiwweEJFRjlBM0Y3LDB4QzY3MTc4RjIpO1xuICB2YXIgSEFTSCA9IG5ldyBBcnJheSgweDZBMDlFNjY3LCAweEJCNjdBRTg1LCAweDNDNkVGMzcyLCAweEE1NEZGNTNBLCAweDUxMEU1MjdGLCAweDlCMDU2ODhDLCAweDFGODNEOUFCLCAweDVCRTBDRDE5KTtcbiAgICB2YXIgVyA9IG5ldyBBcnJheSg2NCk7XG4gICAgdmFyIGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGo7XG4gICAgdmFyIFQxLCBUMjtcbiAgLyogYXBwZW5kIHBhZGRpbmcgKi9cbiAgbVtsID4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbCAlIDMyKTtcbiAgbVsoKGwgKyA2NCA+PiA5KSA8PCA0KSArIDE1XSA9IGw7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbS5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICBhID0gSEFTSFswXTsgYiA9IEhBU0hbMV07IGMgPSBIQVNIWzJdOyBkID0gSEFTSFszXTsgZSA9IEhBU0hbNF07IGYgPSBIQVNIWzVdOyBnID0gSEFTSFs2XTsgaCA9IEhBU0hbN107XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCA2NDsgaisrKSB7XG4gICAgICBpZiAoaiA8IDE2KSB7XG4gICAgICAgIFdbal0gPSBtW2ogKyBpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFdbal0gPSBzYWZlX2FkZChzYWZlX2FkZChzYWZlX2FkZChHYW1tYTEyNTYoV1tqIC0gMl0pLCBXW2ogLSA3XSksIEdhbW1hMDI1NihXW2ogLSAxNV0pKSwgV1tqIC0gMTZdKTtcbiAgICAgIH1cbiAgICAgIFQxID0gc2FmZV9hZGQoc2FmZV9hZGQoc2FmZV9hZGQoc2FmZV9hZGQoaCwgU2lnbWExMjU2KGUpKSwgQ2goZSwgZiwgZykpLCBLW2pdKSwgV1tqXSk7XG4gICAgICBUMiA9IHNhZmVfYWRkKFNpZ21hMDI1NihhKSwgTWFqKGEsIGIsIGMpKTtcbiAgICAgIGggPSBnOyBnID0gZjsgZiA9IGU7IGUgPSBzYWZlX2FkZChkLCBUMSk7IGQgPSBjOyBjID0gYjsgYiA9IGE7IGEgPSBzYWZlX2FkZChUMSwgVDIpO1xuICAgIH1cbiAgICBIQVNIWzBdID0gc2FmZV9hZGQoYSwgSEFTSFswXSk7IEhBU0hbMV0gPSBzYWZlX2FkZChiLCBIQVNIWzFdKTsgSEFTSFsyXSA9IHNhZmVfYWRkKGMsIEhBU0hbMl0pOyBIQVNIWzNdID0gc2FmZV9hZGQoZCwgSEFTSFszXSk7XG4gICAgSEFTSFs0XSA9IHNhZmVfYWRkKGUsIEhBU0hbNF0pOyBIQVNIWzVdID0gc2FmZV9hZGQoZiwgSEFTSFs1XSk7IEhBU0hbNl0gPSBzYWZlX2FkZChnLCBIQVNIWzZdKTsgSEFTSFs3XSA9IHNhZmVfYWRkKGgsIEhBU0hbN10pO1xuICB9XG4gIHJldHVybiBIQVNIO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzaGEyNTYoYnVmKSB7XG4gIHJldHVybiBoZWxwZXJzLmhhc2goYnVmLCBjb3JlX3NoYTI1NiwgMzIsIHRydWUpO1xufTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnByb2Nlc3MubmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW5TZXRJbW1lZGlhdGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5zZXRJbW1lZGlhdGU7XG4gICAgdmFyIGNhblBvc3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lclxuICAgIDtcblxuICAgIGlmIChjYW5TZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmKSB7IHJldHVybiB3aW5kb3cuc2V0SW1tZWRpYXRlKGYpIH07XG4gICAgfVxuXG4gICAgaWYgKGNhblBvc3QpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gZXYuc291cmNlO1xuICAgICAgICAgICAgaWYgKChzb3VyY2UgPT09IHdpbmRvdyB8fCBzb3VyY2UgPT09IG51bGwpICYmIGV2LmRhdGEgPT09ICdwcm9jZXNzLXRpY2snKSB7XG4gICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICAgICAgcXVldWUucHVzaChmbik7XG4gICAgICAgICAgICB3aW5kb3cucG9zdE1lc3NhZ2UoJ3Byb2Nlc3MtdGljaycsICcqJyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgIH07XG59KSgpO1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbiIsInZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5fdXNlVHlwZWRBcnJheXNgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAoY29tcGF0aWJsZSBkb3duIHRvIElFNilcbiAqL1xuQnVmZmVyLl91c2VUeXBlZEFycmF5cyA9IChmdW5jdGlvbiAoKSB7XG4gICAvLyBEZXRlY3QgaWYgYnJvd3NlciBzdXBwb3J0cyBUeXBlZCBBcnJheXMuIFN1cHBvcnRlZCBicm93c2VycyBhcmUgSUUgMTArLFxuICAgLy8gRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKywgT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICAgaWYgKHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnKVxuICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgLy8gRG9lcyB0aGUgYnJvd3NlciBzdXBwb3J0IGFkZGluZyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXM/IElmXG4gIC8vIG5vdCwgdGhlbiB0aGF0J3MgdGhlIHNhbWUgYXMgbm8gYFVpbnQ4QXJyYXlgIHN1cHBvcnQuIFdlIG5lZWQgdG8gYmUgYWJsZSB0b1xuICAvLyBhZGQgYWxsIHRoZSBub2RlIEJ1ZmZlciBBUEkgbWV0aG9kcy5cbiAgLy8gUmVsZXZhbnQgRmlyZWZveCBidWc6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOFxuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgwKVxuICAgIGFyci5mb28gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XG4gICAgcmV0dXJuIDQyID09PSBhcnIuZm9vKCkgJiZcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAvLyBDaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59KSgpXG5cbi8qKlxuICogQ2xhc3M6IEJ1ZmZlclxuICogPT09PT09PT09PT09PVxuICpcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgYXJlIGF1Z21lbnRlZFxuICogd2l0aCBmdW5jdGlvbiBwcm9wZXJ0aWVzIGZvciBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgQVBJIGZ1bmN0aW9ucy4gV2UgdXNlXG4gKiBgVWludDhBcnJheWAgc28gdGhhdCBzcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdCByZXR1cm5zXG4gKiBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBCeSBhdWdtZW50aW5nIHRoZSBpbnN0YW5jZXMsIHdlIGNhbiBhdm9pZCBtb2RpZnlpbmcgdGhlIGBVaW50OEFycmF5YFxuICogcHJvdG90eXBlLlxuICovXG5mdW5jdGlvbiBCdWZmZXIgKHN1YmplY3QsIGVuY29kaW5nLCBub1plcm8pIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpXG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybylcblxuICB2YXIgdHlwZSA9IHR5cGVvZiBzdWJqZWN0XG5cbiAgLy8gV29ya2Fyb3VuZDogbm9kZSdzIGJhc2U2NCBpbXBsZW1lbnRhdGlvbiBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgc3RyaW5nc1xuICAvLyB3aGlsZSBiYXNlNjQtanMgZG9lcyBub3QuXG4gIGlmIChlbmNvZGluZyA9PT0gJ2Jhc2U2NCcgJiYgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBzdWJqZWN0ID0gc3RyaW5ndHJpbShzdWJqZWN0KVxuICAgIHdoaWxlIChzdWJqZWN0Lmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICAgIHN1YmplY3QgPSBzdWJqZWN0ICsgJz0nXG4gICAgfVxuICB9XG5cbiAgLy8gRmluZCB0aGUgbGVuZ3RoXG4gIHZhciBsZW5ndGhcbiAgaWYgKHR5cGUgPT09ICdudW1iZXInKVxuICAgIGxlbmd0aCA9IGNvZXJjZShzdWJqZWN0KVxuICBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJylcbiAgICBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChzdWJqZWN0LCBlbmNvZGluZylcbiAgZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpXG4gICAgbGVuZ3RoID0gY29lcmNlKHN1YmplY3QubGVuZ3RoKSAvLyBBc3N1bWUgb2JqZWN0IGlzIGFuIGFycmF5XG4gIGVsc2VcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG5lZWRzIHRvIGJlIGEgbnVtYmVyLCBhcnJheSBvciBzdHJpbmcuJylcblxuICB2YXIgYnVmXG4gIGlmIChCdWZmZXIuX3VzZVR5cGVkQXJyYXlzKSB7XG4gICAgLy8gUHJlZmVycmVkOiBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIGJ1ZiA9IGF1Z21lbnQobmV3IFVpbnQ4QXJyYXkobGVuZ3RoKSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIFRISVMgaW5zdGFuY2Ugb2YgQnVmZmVyIChjcmVhdGVkIGJ5IGBuZXdgKVxuICAgIGJ1ZiA9IHRoaXNcbiAgICBidWYubGVuZ3RoID0gbGVuZ3RoXG4gICAgYnVmLl9pc0J1ZmZlciA9IHRydWVcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChCdWZmZXIuX3VzZVR5cGVkQXJyYXlzICYmIHR5cGVvZiBVaW50OEFycmF5ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICBzdWJqZWN0IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIC8vIFNwZWVkIG9wdGltaXphdGlvbiAtLSB1c2Ugc2V0IGlmIHdlJ3JlIGNvcHlpbmcgZnJvbSBhIFVpbnQ4QXJyYXlcbiAgICBidWYuX3NldChzdWJqZWN0KVxuICB9IGVsc2UgaWYgKGlzQXJyYXlpc2goc3ViamVjdCkpIHtcbiAgICAvLyBUcmVhdCBhcnJheS1pc2ggb2JqZWN0cyBhcyBhIGJ5dGUgYXJyYXlcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkpXG4gICAgICAgIGJ1ZltpXSA9IHN1YmplY3QucmVhZFVJbnQ4KGkpXG4gICAgICBlbHNlXG4gICAgICAgIGJ1ZltpXSA9IHN1YmplY3RbaV1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBidWYud3JpdGUoc3ViamVjdCwgMCwgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgIUJ1ZmZlci5fdXNlVHlwZWRBcnJheXMgJiYgIW5vWmVybykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgYnVmW2ldID0gMFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuLy8gU1RBVElDIE1FVEhPRFNcbi8vID09PT09PT09PT09PT09XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICdyYXcnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiAoYikge1xuICByZXR1cm4gISEoYiAhPT0gbnVsbCAmJiBiICE9PSB1bmRlZmluZWQgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gZnVuY3Rpb24gKHN0ciwgZW5jb2RpbmcpIHtcbiAgdmFyIHJldFxuICBzdHIgPSBzdHIgKyAnJ1xuICBzd2l0Y2ggKGVuY29kaW5nIHx8ICd1dGY4Jykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoIC8gMlxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB1dGY4VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdyYXcnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gYmFzZTY0VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aCAqIDJcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gKGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGFzc2VydChpc0FycmF5KGxpc3QpLCAnVXNhZ2U6IEJ1ZmZlci5jb25jYXQobGlzdCwgW3RvdGFsTGVuZ3RoXSlcXG4nICtcbiAgICAgICdsaXN0IHNob3VsZCBiZSBhbiBBcnJheS4nKVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKDApXG4gIH0gZWxzZSBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gbGlzdFswXVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB0b3RhbExlbmd0aCAhPT0gJ251bWJlcicpIHtcbiAgICB0b3RhbExlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdG90YWxMZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcih0b3RhbExlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV1cbiAgICBpdGVtLmNvcHkoYnVmLCBwb3MpXG4gICAgcG9zICs9IGl0ZW0ubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG4vLyBCVUZGRVIgSU5TVEFOQ0UgTUVUSE9EU1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gX2hleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgYXNzZXJ0KHN0ckxlbiAlIDIgPT09IDAsICdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYnl0ZSA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBhc3NlcnQoIWlzTmFOKGJ5dGUpLCAnSW52YWxpZCBoZXggc3RyaW5nJylcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBieXRlXG4gIH1cbiAgQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSBpICogMlxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBfdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IEJ1ZmZlci5fY2hhcnNXcml0dGVuID1cbiAgICBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gX2FzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPVxuICAgIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gX2JpbmFyeVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIF9hc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gX2Jhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IEJ1ZmZlci5fY2hhcnNXcml0dGVuID1cbiAgICBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIFN1cHBvcnQgYm90aCAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpXG4gIC8vIGFuZCB0aGUgbGVnYWN5IChzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBpZiAoIWlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSBsZW5ndGhcbiAgICBsZW5ndGggPSBzd2FwXG4gIH1cblxuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKVxuXG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0dXJuIF9oZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICd1Y3MyJzogLy8gVE9ETzogTm8gc3VwcG9ydCBmb3IgdWNzMiBvciB1dGYxNmxlIGVuY29kaW5ncyB5ZXRcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIF91dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXR1cm4gX2FzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0dXJuIF9iaW5hcnlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXR1cm4gX2Jhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKClcbiAgc3RhcnQgPSBOdW1iZXIoc3RhcnQpIHx8IDBcbiAgZW5kID0gKGVuZCAhPT0gdW5kZWZpbmVkKVxuICAgID8gTnVtYmVyKGVuZClcbiAgICA6IGVuZCA9IHNlbGYubGVuZ3RoXG5cbiAgLy8gRmFzdHBhdGggZW1wdHkgc3RyaW5nc1xuICBpZiAoZW5kID09PSBzdGFydClcbiAgICByZXR1cm4gJydcblxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldHVybiBfaGV4U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAndWNzMic6IC8vIFRPRE86IE5vIHN1cHBvcnQgZm9yIHVjczIgb3IgdXRmMTZsZSBlbmNvZGluZ3MgeWV0XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiBfdXRmOFNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0dXJuIF9hc2NpaVNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldHVybiBfYmluYXJ5U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIF9iYXNlNjRTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICh0YXJnZXQsIHRhcmdldF9zdGFydCwgc3RhcnQsIGVuZCkge1xuICB2YXIgc291cmNlID0gdGhpc1xuXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICghdGFyZ2V0X3N0YXJ0KSB0YXJnZXRfc3RhcnQgPSAwXG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgc291cmNlLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBhc3NlcnQoZW5kID49IHN0YXJ0LCAnc291cmNlRW5kIDwgc291cmNlU3RhcnQnKVxuICBhc3NlcnQodGFyZ2V0X3N0YXJ0ID49IDAgJiYgdGFyZ2V0X3N0YXJ0IDwgdGFyZ2V0Lmxlbmd0aCxcbiAgICAgICd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgYXNzZXJ0KHN0YXJ0ID49IDAgJiYgc3RhcnQgPCBzb3VyY2UubGVuZ3RoLCAnc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGFzc2VydChlbmQgPj0gMCAmJiBlbmQgPD0gc291cmNlLmxlbmd0aCwgJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpXG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgPCBlbmQgLSBzdGFydClcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0X3N0YXJ0ICsgc3RhcnRcblxuICAvLyBjb3B5IVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyBpKyspXG4gICAgdGFyZ2V0W2kgKyB0YXJnZXRfc3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG59XG5cbmZ1bmN0aW9uIF9iYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gX3V0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXMgPSAnJ1xuICB2YXIgdG1wID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgaWYgKGJ1ZltpXSA8PSAweDdGKSB7XG4gICAgICByZXMgKz0gZGVjb2RlVXRmOENoYXIodG1wKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICAgICAgdG1wID0gJydcbiAgICB9IGVsc2Uge1xuICAgICAgdG1wICs9ICclJyArIGJ1ZltpXS50b1N0cmluZygxNilcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzICsgZGVjb2RlVXRmOENoYXIodG1wKVxufVxuXG5mdW5jdGlvbiBfYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspXG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIF9iaW5hcnlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHJldHVybiBfYXNjaWlTbGljZShidWYsIHN0YXJ0LCBlbmQpXG59XG5cbmZ1bmN0aW9uIF9oZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbi8vIGh0dHA6Ly9ub2RlanMub3JnL2FwaS9idWZmZXIuaHRtbCNidWZmZXJfYnVmX3NsaWNlX3N0YXJ0X2VuZFxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IGNsYW1wKHN0YXJ0LCBsZW4sIDApXG4gIGVuZCA9IGNsYW1wKGVuZCwgbGVuLCBsZW4pXG5cbiAgaWYgKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpIHtcbiAgICByZXR1cm4gYXVnbWVudCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpKVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgdmFyIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZCwgdHJ1ZSlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyBpKyspIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgICByZXR1cm4gbmV3QnVmXG4gIH1cbn1cblxuLy8gYGdldGAgd2lsbCBiZSByZW1vdmVkIGluIE5vZGUgMC4xMytcbkJ1ZmZlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLmdldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMucmVhZFVJbnQ4KG9mZnNldClcbn1cblxuLy8gYHNldGAgd2lsbCBiZSByZW1vdmVkIGluIE5vZGUgMC4xMytcbkJ1ZmZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHYsIG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLnNldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMud3JpdGVVSW50OCh2LCBvZmZzZXQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm5cblxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbmZ1bmN0aW9uIF9yZWFkVUludDE2IChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbFxuICBpZiAobGl0dGxlRW5kaWFuKSB7XG4gICAgdmFsID0gYnVmW29mZnNldF1cbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMV0gPDwgOFxuICB9IGVsc2Uge1xuICAgIHZhbCA9IGJ1ZltvZmZzZXRdIDw8IDhcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMV1cbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkVUludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkVUludDE2KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfcmVhZFVJbnQzMiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWxcbiAgaWYgKGxpdHRsZUVuZGlhbikge1xuICAgIGlmIChvZmZzZXQgKyAyIDwgbGVuKVxuICAgICAgdmFsID0gYnVmW29mZnNldCArIDJdIDw8IDE2XG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDFdIDw8IDhcbiAgICB2YWwgfD0gYnVmW29mZnNldF1cbiAgICBpZiAob2Zmc2V0ICsgMyA8IGxlbilcbiAgICAgIHZhbCA9IHZhbCArIChidWZbb2Zmc2V0ICsgM10gPDwgMjQgPj4+IDApXG4gIH0gZWxzZSB7XG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgPSBidWZbb2Zmc2V0ICsgMV0gPDwgMTZcbiAgICBpZiAob2Zmc2V0ICsgMiA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMl0gPDwgOFxuICAgIGlmIChvZmZzZXQgKyAzIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAzXVxuICAgIHZhbCA9IHZhbCArIChidWZbb2Zmc2V0XSA8PCAyNCA+Pj4gMClcbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkVUludDMyKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkVUludDMyKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm5cblxuICB2YXIgbmVnID0gdGhpc1tvZmZzZXRdICYgMHg4MFxuICBpZiAobmVnKVxuICAgIHJldHVybiAoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTFcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuZnVuY3Rpb24gX3JlYWRJbnQxNiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWwgPSBfcmVhZFVJbnQxNihidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCB0cnVlKVxuICB2YXIgbmVnID0gdmFsICYgMHg4MDAwXG4gIGlmIChuZWcpXG4gICAgcmV0dXJuICgweGZmZmYgLSB2YWwgKyAxKSAqIC0xXG4gIGVsc2VcbiAgICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRJbnQxNih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF9yZWFkSW50MzIgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsID0gX3JlYWRVSW50MzIoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgdHJ1ZSlcbiAgdmFyIG5lZyA9IHZhbCAmIDB4ODAwMDAwMDBcbiAgaWYgKG5lZylcbiAgICByZXR1cm4gKDB4ZmZmZmZmZmYgLSB2YWwgKyAxKSAqIC0xXG4gIGVsc2VcbiAgICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF9yZWFkRmxvYXQgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgcmV0dXJuIGllZWU3NTQucmVhZChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3JlYWREb3VibGUgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCArIDcgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgcmV0dXJuIGllZWU3NTQucmVhZChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWREb3VibGUodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWREb3VibGUodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aCkgcmV0dXJuXG5cbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbn1cblxuZnVuY3Rpb24gX3dyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZilcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4obGVuIC0gb2Zmc2V0LCAyKTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9XG4gICAgICAgICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAgICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3dyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZmZmZmYpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGxlbiAtIG9mZnNldCwgNCk7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPVxuICAgICAgICAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2YsIC0weDgwKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm5cblxuICBpZiAodmFsdWUgPj0gMClcbiAgICB0aGlzLndyaXRlVUludDgodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpXG4gIGVsc2VcbiAgICB0aGlzLndyaXRlVUludDgoMHhmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3dyaXRlSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZmZmLCAtMHg4MDAwKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWYgKHZhbHVlID49IDApXG4gICAgX3dyaXRlVUludDE2KGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbiAgZWxzZVxuICAgIF93cml0ZVVJbnQxNihidWYsIDB4ZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfd3JpdGVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGlmICh2YWx1ZSA+PSAwKVxuICAgIF93cml0ZVVJbnQzMihidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG4gIGVsc2VcbiAgICBfd3JpdGVVSW50MzIoYnVmLCAweGZmZmZmZmZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF93cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZklFRUU3NTQodmFsdWUsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF93cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyA3IDwgYnVmLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZJRUVFNzU0KHZhbHVlLCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBmaWxsKHZhbHVlLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uICh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXZhbHVlKSB2YWx1ZSA9IDBcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kKSBlbmQgPSB0aGlzLmxlbmd0aFxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5jaGFyQ29kZUF0KDApXG4gIH1cblxuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsdWUpLCAndmFsdWUgaXMgbm90IGEgbnVtYmVyJylcbiAgYXNzZXJ0KGVuZCA+PSBzdGFydCwgJ2VuZCA8IHN0YXJ0JylcblxuICAvLyBGaWxsIDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIGFzc2VydChzdGFydCA+PSAwICYmIHN0YXJ0IDwgdGhpcy5sZW5ndGgsICdzdGFydCBvdXQgb2YgYm91bmRzJylcbiAgYXNzZXJ0KGVuZCA+PSAwICYmIGVuZCA8PSB0aGlzLmxlbmd0aCwgJ2VuZCBvdXQgb2YgYm91bmRzJylcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHRoaXNbaV0gPSB2YWx1ZVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG91dCA9IFtdXG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgb3V0W2ldID0gdG9IZXgodGhpc1tpXSlcbiAgICBpZiAoaSA9PT0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUykge1xuICAgICAgb3V0W2kgKyAxXSA9ICcuLi4nXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIG91dC5qb2luKCcgJykgKyAnPidcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGBBcnJheUJ1ZmZlcmAgd2l0aCB0aGUgKmNvcGllZCogbWVtb3J5IG9mIHRoZSBidWZmZXIgaW5zdGFuY2UuXG4gKiBBZGRlZCBpbiBOb2RlIDAuMTIuIE9ubHkgYXZhaWxhYmxlIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBBcnJheUJ1ZmZlci5cbiAqL1xuQnVmZmVyLnByb3RvdHlwZS50b0FycmF5QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoQnVmZmVyLl91c2VUeXBlZEFycmF5cykge1xuICAgICAgcmV0dXJuIChuZXcgQnVmZmVyKHRoaXMpKS5idWZmZXJcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KHRoaXMubGVuZ3RoKVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSlcbiAgICAgICAgYnVmW2ldID0gdGhpc1tpXVxuICAgICAgcmV0dXJuIGJ1Zi5idWZmZXJcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCdWZmZXIudG9BcnJheUJ1ZmZlciBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpXG4gIH1cbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG52YXIgQlAgPSBCdWZmZXIucHJvdG90eXBlXG5cbi8qKlxuICogQXVnbWVudCB0aGUgVWludDhBcnJheSAqaW5zdGFuY2UqIChub3QgdGhlIGNsYXNzISkgd2l0aCBCdWZmZXIgbWV0aG9kc1xuICovXG5mdW5jdGlvbiBhdWdtZW50IChhcnIpIHtcbiAgYXJyLl9pc0J1ZmZlciA9IHRydWVcblxuICAvLyBzYXZlIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBVaW50OEFycmF5IGdldC9zZXQgbWV0aG9kcyBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgYXJyLl9nZXQgPSBhcnIuZ2V0XG4gIGFyci5fc2V0ID0gYXJyLnNldFxuXG4gIC8vIGRlcHJlY2F0ZWQsIHdpbGwgYmUgcmVtb3ZlZCBpbiBub2RlIDAuMTMrXG4gIGFyci5nZXQgPSBCUC5nZXRcbiAgYXJyLnNldCA9IEJQLnNldFxuXG4gIGFyci53cml0ZSA9IEJQLndyaXRlXG4gIGFyci50b1N0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0xvY2FsZVN0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0pTT04gPSBCUC50b0pTT05cbiAgYXJyLmNvcHkgPSBCUC5jb3B5XG4gIGFyci5zbGljZSA9IEJQLnNsaWNlXG4gIGFyci5yZWFkVUludDggPSBCUC5yZWFkVUludDhcbiAgYXJyLnJlYWRVSW50MTZMRSA9IEJQLnJlYWRVSW50MTZMRVxuICBhcnIucmVhZFVJbnQxNkJFID0gQlAucmVhZFVJbnQxNkJFXG4gIGFyci5yZWFkVUludDMyTEUgPSBCUC5yZWFkVUludDMyTEVcbiAgYXJyLnJlYWRVSW50MzJCRSA9IEJQLnJlYWRVSW50MzJCRVxuICBhcnIucmVhZEludDggPSBCUC5yZWFkSW50OFxuICBhcnIucmVhZEludDE2TEUgPSBCUC5yZWFkSW50MTZMRVxuICBhcnIucmVhZEludDE2QkUgPSBCUC5yZWFkSW50MTZCRVxuICBhcnIucmVhZEludDMyTEUgPSBCUC5yZWFkSW50MzJMRVxuICBhcnIucmVhZEludDMyQkUgPSBCUC5yZWFkSW50MzJCRVxuICBhcnIucmVhZEZsb2F0TEUgPSBCUC5yZWFkRmxvYXRMRVxuICBhcnIucmVhZEZsb2F0QkUgPSBCUC5yZWFkRmxvYXRCRVxuICBhcnIucmVhZERvdWJsZUxFID0gQlAucmVhZERvdWJsZUxFXG4gIGFyci5yZWFkRG91YmxlQkUgPSBCUC5yZWFkRG91YmxlQkVcbiAgYXJyLndyaXRlVUludDggPSBCUC53cml0ZVVJbnQ4XG4gIGFyci53cml0ZVVJbnQxNkxFID0gQlAud3JpdGVVSW50MTZMRVxuICBhcnIud3JpdGVVSW50MTZCRSA9IEJQLndyaXRlVUludDE2QkVcbiAgYXJyLndyaXRlVUludDMyTEUgPSBCUC53cml0ZVVJbnQzMkxFXG4gIGFyci53cml0ZVVJbnQzMkJFID0gQlAud3JpdGVVSW50MzJCRVxuICBhcnIud3JpdGVJbnQ4ID0gQlAud3JpdGVJbnQ4XG4gIGFyci53cml0ZUludDE2TEUgPSBCUC53cml0ZUludDE2TEVcbiAgYXJyLndyaXRlSW50MTZCRSA9IEJQLndyaXRlSW50MTZCRVxuICBhcnIud3JpdGVJbnQzMkxFID0gQlAud3JpdGVJbnQzMkxFXG4gIGFyci53cml0ZUludDMyQkUgPSBCUC53cml0ZUludDMyQkVcbiAgYXJyLndyaXRlRmxvYXRMRSA9IEJQLndyaXRlRmxvYXRMRVxuICBhcnIud3JpdGVGbG9hdEJFID0gQlAud3JpdGVGbG9hdEJFXG4gIGFyci53cml0ZURvdWJsZUxFID0gQlAud3JpdGVEb3VibGVMRVxuICBhcnIud3JpdGVEb3VibGVCRSA9IEJQLndyaXRlRG91YmxlQkVcbiAgYXJyLmZpbGwgPSBCUC5maWxsXG4gIGFyci5pbnNwZWN0ID0gQlAuaW5zcGVjdFxuICBhcnIudG9BcnJheUJ1ZmZlciA9IEJQLnRvQXJyYXlCdWZmZXJcblxuICByZXR1cm4gYXJyXG59XG5cbi8vIHNsaWNlKHN0YXJ0LCBlbmQpXG5mdW5jdGlvbiBjbGFtcCAoaW5kZXgsIGxlbiwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgaW5kZXggIT09ICdudW1iZXInKSByZXR1cm4gZGVmYXVsdFZhbHVlXG4gIGluZGV4ID0gfn5pbmRleDsgIC8vIENvZXJjZSB0byBpbnRlZ2VyLlxuICBpZiAoaW5kZXggPj0gbGVuKSByZXR1cm4gbGVuXG4gIGlmIChpbmRleCA+PSAwKSByZXR1cm4gaW5kZXhcbiAgaW5kZXggKz0gbGVuXG4gIGlmIChpbmRleCA+PSAwKSByZXR1cm4gaW5kZXhcbiAgcmV0dXJuIDBcbn1cblxuZnVuY3Rpb24gY29lcmNlIChsZW5ndGgpIHtcbiAgLy8gQ29lcmNlIGxlbmd0aCB0byBhIG51bWJlciAocG9zc2libHkgTmFOKSwgcm91bmQgdXBcbiAgLy8gaW4gY2FzZSBpdCdzIGZyYWN0aW9uYWwgKGUuZy4gMTIzLjQ1NikgdGhlbiBkbyBhXG4gIC8vIGRvdWJsZSBuZWdhdGUgdG8gY29lcmNlIGEgTmFOIHRvIDAuIEVhc3ksIHJpZ2h0P1xuICBsZW5ndGggPSB+fk1hdGguY2VpbCgrbGVuZ3RoKVxuICByZXR1cm4gbGVuZ3RoIDwgMCA/IDAgOiBsZW5ndGhcbn1cblxuZnVuY3Rpb24gaXNBcnJheSAoc3ViamVjdCkge1xuICByZXR1cm4gKEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHN1YmplY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN1YmplY3QpID09PSAnW29iamVjdCBBcnJheV0nXG4gIH0pKHN1YmplY3QpXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlpc2ggKHN1YmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXkoc3ViamVjdCkgfHwgQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpIHx8XG4gICAgICBzdWJqZWN0ICYmIHR5cGVvZiBzdWJqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgdHlwZW9mIHN1YmplY3QubGVuZ3RoID09PSAnbnVtYmVyJ1xufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGIgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGlmIChiIDw9IDB4N0YpXG4gICAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSlcbiAgICBlbHNlIHtcbiAgICAgIHZhciBzdGFydCA9IGlcbiAgICAgIGlmIChiID49IDB4RDgwMCAmJiBiIDw9IDB4REZGRikgaSsrXG4gICAgICB2YXIgaCA9IGVuY29kZVVSSUNvbXBvbmVudChzdHIuc2xpY2Uoc3RhcnQsIGkrMSkpLnN1YnN0cigxKS5zcGxpdCgnJScpXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGgubGVuZ3RoOyBqKyspXG4gICAgICAgIGJ5dGVBcnJheS5wdXNoKHBhcnNlSW50KGhbal0sIDE2KSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShzdHIpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgcG9zXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpXG4gICAgICBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGRlY29kZVV0ZjhDaGFyIChzdHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEKSAvLyBVVEYgOCBpbnZhbGlkIGNoYXJcbiAgfVxufVxuXG4vKlxuICogV2UgaGF2ZSB0byBtYWtlIHN1cmUgdGhhdCB0aGUgdmFsdWUgaXMgYSB2YWxpZCBpbnRlZ2VyLiBUaGlzIG1lYW5zIHRoYXQgaXRcbiAqIGlzIG5vbi1uZWdhdGl2ZS4gSXQgaGFzIG5vIGZyYWN0aW9uYWwgY29tcG9uZW50IGFuZCB0aGF0IGl0IGRvZXMgbm90XG4gKiBleGNlZWQgdGhlIG1heGltdW0gYWxsb3dlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gdmVyaWZ1aW50ICh2YWx1ZSwgbWF4KSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicsICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJylcbiAgYXNzZXJ0KHZhbHVlID49IDAsXG4gICAgICAnc3BlY2lmaWVkIGEgbmVnYXRpdmUgdmFsdWUgZm9yIHdyaXRpbmcgYW4gdW5zaWduZWQgdmFsdWUnKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgaXMgbGFyZ2VyIHRoYW4gbWF4aW11bSB2YWx1ZSBmb3IgdHlwZScpXG4gIGFzc2VydChNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUsICd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpXG59XG5cbmZ1bmN0aW9uIHZlcmlmc2ludCh2YWx1ZSwgbWF4LCBtaW4pIHtcbiAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJywgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlJylcbiAgYXNzZXJ0KHZhbHVlID49IG1pbiwgJ3ZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWUnKVxuICBhc3NlcnQoTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKVxufVxuXG5mdW5jdGlvbiB2ZXJpZklFRUU3NTQodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicsICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJylcbiAgYXNzZXJ0KHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZScpXG4gIGFzc2VydCh2YWx1ZSA+PSBtaW4sICd2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlJylcbn1cblxuZnVuY3Rpb24gYXNzZXJ0ICh0ZXN0LCBtZXNzYWdlKSB7XG4gIGlmICghdGVzdCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgfHwgJ0ZhaWxlZCBhc3NlcnRpb24nKVxufVxuIiwidmFyIGxvb2t1cCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcblxuOyhmdW5jdGlvbiAoZXhwb3J0cykge1xuXHQndXNlIHN0cmljdCc7XG5cbiAgdmFyIEFyciA9ICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgPyBVaW50OEFycmF5XG4gICAgOiBBcnJheVxuXG5cdHZhciBaRVJPICAgPSAnMCcuY2hhckNvZGVBdCgwKVxuXHR2YXIgUExVUyAgID0gJysnLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIICA9ICcvJy5jaGFyQ29kZUF0KDApXG5cdHZhciBOVU1CRVIgPSAnMCcuY2hhckNvZGVBdCgwKVxuXHR2YXIgTE9XRVIgID0gJ2EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFVQUEVSICA9ICdBJy5jaGFyQ29kZUF0KDApXG5cblx0ZnVuY3Rpb24gZGVjb2RlIChlbHQpIHtcblx0XHR2YXIgY29kZSA9IGVsdC5jaGFyQ29kZUF0KDApXG5cdFx0aWYgKGNvZGUgPT09IFBMVVMpXG5cdFx0XHRyZXR1cm4gNjIgLy8gJysnXG5cdFx0aWYgKGNvZGUgPT09IFNMQVNIKVxuXHRcdFx0cmV0dXJuIDYzIC8vICcvJ1xuXHRcdGlmIChjb2RlIDwgTlVNQkVSKVxuXHRcdFx0cmV0dXJuIC0xIC8vbm8gbWF0Y2hcblx0XHRpZiAoY29kZSA8IE5VTUJFUiArIDEwKVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBOVU1CRVIgKyAyNiArIDI2XG5cdFx0aWYgKGNvZGUgPCBVUFBFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBVUFBFUlxuXHRcdGlmIChjb2RlIDwgTE9XRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gTE9XRVIgKyAyNlxuXHR9XG5cblx0ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkgKGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG5cblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuXHRcdH1cblxuXHRcdC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuXHRcdC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuXHRcdC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuXHRcdC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2Vcblx0XHR2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXHRcdHBsYWNlSG9sZGVycyA9ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAyKSA/IDIgOiAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMSkgPyAxIDogMFxuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gbmV3IEFycihiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cdFx0bCA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gNCA6IGI2NC5sZW5ndGhcblxuXHRcdHZhciBMID0gMFxuXG5cdFx0ZnVuY3Rpb24gcHVzaCAodikge1xuXHRcdFx0YXJyW0wrK10gPSB2XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxOCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCAxMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA8PCA2KSB8IGRlY29kZShiNjQuY2hhckF0KGkgKyAzKSlcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNilcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMCkgPj4gOClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPj4gNClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxMCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCA0KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpID4+IDIpXG5cdFx0XHRwdXNoKCh0bXAgPj4gOCkgJiAweEZGKVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdHJldHVybiBhcnJcblx0fVxuXG5cdGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQgKHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGhcblxuXHRcdGZ1bmN0aW9uIGVuY29kZSAobnVtKSB7XG5cdFx0XHRyZXR1cm4gbG9va3VwLmNoYXJBdChudW0pXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcblx0XHRcdHJldHVybiBlbmNvZGUobnVtID4+IDE4ICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDEyICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDYgJiAweDNGKSArIGVuY29kZShudW0gJiAweDNGKVxuXHRcdH1cblxuXHRcdC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG5cdFx0XHRvdXRwdXQgKz0gdHJpcGxldFRvQmFzZTY0KHRlbXApXG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV1cblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDIpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz09J1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHR0ZW1wID0gKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDJdIDw8IDgpICsgKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMTApXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPj4gNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDIpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9J1xuXHRcdFx0XHRicmVha1xuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXRcblx0fVxuXG5cdG1vZHVsZS5leHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXlcblx0bW9kdWxlLmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IHVpbnQ4VG9CYXNlNjRcbn0oKSlcbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sXG4gICAgICBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxLFxuICAgICAgZU1heCA9ICgxIDw8IGVMZW4pIC0gMSxcbiAgICAgIGVCaWFzID0gZU1heCA+PiAxLFxuICAgICAgbkJpdHMgPSAtNyxcbiAgICAgIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMCxcbiAgICAgIGQgPSBpc0xFID8gLTEgOiAxLFxuICAgICAgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXTtcblxuICBpICs9IGQ7XG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIHMgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBlTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KTtcblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgZSA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IG1MZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpO1xuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhcztcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpO1xuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbik7XG4gICAgZSA9IGUgLSBlQmlhcztcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKTtcbn07XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgYyxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMCksXG4gICAgICBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSksXG4gICAgICBkID0gaXNMRSA/IDEgOiAtMSxcbiAgICAgIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDA7XG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDA7XG4gICAgZSA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpO1xuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpO1xuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG07XG4gIGVMZW4gKz0gbUxlbjtcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KTtcblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjg7XG59O1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuLyohIGh0dHA6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjIuNCBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0bW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teIC1+XS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9cXHgyRXxcXHUzMDAyfFxcdUZGMEV8XFx1RkY2MS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdGFycmF5W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIGFycmF5O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHRyZXR1cm4gbWFwKHN0cmluZy5zcGxpdChyZWdleFNlcGFyYXRvcnMpLCBmbikuam9pbignLicpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cDovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIHRvIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHlcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIHRvIFVuaWNvZGUuIE9ubHkgdGhlXG5cdCAqIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS4gaXQgZG9lc24ndFxuXHQgKiBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIGNvbnZlcnRlZCB0b1xuXHQgKiBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgUHVueWNvZGUgZG9tYWluIG5hbWUgdG8gY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGRvbWFpbikge1xuXHRcdHJldHVybiBtYXBEb21haW4oZG9tYWluLCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSB0byBQdW55Y29kZS4gT25seSB0aGVcblx0ICogbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLiBpdCBkb2Vzbid0XG5cdCAqIG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgdG8gY29udmVydCwgYXMgYSBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZS5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoZG9tYWluKSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihkb21haW4sIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjIuNCcsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHVueWNvZGU7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgIWZyZWVFeHBvcnRzLm5vZGVUeXBlKSB7XG5cdFx0aWYgKGZyZWVNb2R1bGUpIHsgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7IC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgeyAvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG9ialtrXS5tYXAoZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG4iLCIvKmpzaGludCBzdHJpY3Q6dHJ1ZSBub2RlOnRydWUgZXM1OnRydWUgb25ldmFyOnRydWUgbGF4Y29tbWE6dHJ1ZSBsYXhicmVhazp0cnVlIGVxZXFlcTp0cnVlIGltbWVkOnRydWUgbGF0ZWRlZjp0cnVlKi9cbihmdW5jdGlvbiAoKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIHB1bnljb2RlID0gcmVxdWlyZSgncHVueWNvZGUnKTtcblxuZXhwb3J0cy5wYXJzZSA9IHVybFBhcnNlO1xuZXhwb3J0cy5yZXNvbHZlID0gdXJsUmVzb2x2ZTtcbmV4cG9ydHMucmVzb2x2ZU9iamVjdCA9IHVybFJlc29sdmVPYmplY3Q7XG5leHBvcnRzLmZvcm1hdCA9IHVybEZvcm1hdDtcblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cbiAgICBkZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnficsICdgJ10uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KGRlbGltcyksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddXG4gICAgICAuY29uY2F0KHVud2lzZSkuY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIG5vbkF1dGhDaGFycyA9IFsnLycsICdAJywgJz8nLCAnIyddLmNvbmNhdChkZWxpbXMpLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlthLXpBLVowLTldW2EtejAtOUEtWl8tXXswLDYyfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oW2EtekEtWjAtOV1bYS16MC05QS1aXy1dezAsNjJ9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGhhdmUgYSBwYXRoIGNvbXBvbmVudC5cbiAgICBwYXRoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdHlwZW9mKHVybCkgPT09ICdvYmplY3QnICYmIHVybC5ocmVmKSByZXR1cm4gdXJsO1xuXG4gIGlmICh0eXBlb2YgdXJsICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICB2YXIgb3V0ID0ge30sXG4gICAgICByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICBvdXQucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICBvdXQuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvLyBkb24ndCBlbmZvcmNlIGZ1bGwgUkZDIGNvcnJlY3RuZXNzLCBqdXN0IGJlIHVuc3R1cGlkIGFib3V0IGl0LlxuXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBAIHNpZ24sIHVubGVzcyBzb21lIG5vbi1hdXRoIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIHZhciBhdFNpZ24gPSByZXN0LmluZGV4T2YoJ0AnKTtcbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgdmFyIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG5cbiAgICAgIC8vIHRoZXJlICptYXkgYmUqIGFuIGF1dGhcbiAgICAgIHZhciBoYXNBdXRoID0gdHJ1ZTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9uQXV0aENoYXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoYXV0aC5pbmRleE9mKG5vbkF1dGhDaGFyc1tpXSkgIT09IC0xKSB7XG4gICAgICAgICAgLy8gbm90IGEgdmFsaWQgYXV0aC4gIFNvbWV0aGluZyBsaWtlIGh0dHA6Ly9mb28uY29tL2JhckBiYXovXG4gICAgICAgICAgaGFzQXV0aCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNBdXRoKSB7XG4gICAgICAgIC8vIHBsdWNrIG9mZiB0aGUgYXV0aCBwb3J0aW9uLlxuICAgICAgICBvdXQuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKGF0U2lnbiArIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmaXJzdE5vbkhvc3QgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBpbmRleCA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSAmJlxuICAgICAgICAgIChmaXJzdE5vbkhvc3QgPCAwIHx8IGluZGV4IDwgZmlyc3ROb25Ib3N0KSkgZmlyc3ROb25Ib3N0ID0gaW5kZXg7XG4gICAgfVxuXG4gICAgaWYgKGZpcnN0Tm9uSG9zdCAhPT0gLTEpIHtcbiAgICAgIG91dC5ob3N0ID0gcmVzdC5zdWJzdHIoMCwgZmlyc3ROb25Ib3N0KTtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cihmaXJzdE5vbkhvc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQuaG9zdCA9IHJlc3Q7XG4gICAgICByZXN0ID0gJyc7XG4gICAgfVxuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB2YXIgcCA9IHBhcnNlSG9zdChvdXQuaG9zdCk7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIG91dFtrZXldID0gcFtrZXldO1xuICAgIH1cblxuICAgIC8vIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXG4gICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICBvdXQuaG9zdG5hbWUgPSBvdXQuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSBvdXQuaG9zdG5hbWVbMF0gPT09ICdbJyAmJlxuICAgICAgICBvdXQuaG9zdG5hbWVbb3V0Lmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAob3V0Lmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICBvdXQuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2UgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSBvdXQuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0Lmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxuICAgIG91dC5ob3N0bmFtZSA9IG91dC5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnkgY29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgdGhlIHBhcnQgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhcyBub24gQVNDSUkgY2hhcmFjdGVycy4gSS5lLiBpdCBkb3NlbnQgbWF0dGVyIGlmXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBpbiBBU0NJSS5cbiAgICAgIHZhciBkb21haW5BcnJheSA9IG91dC5ob3N0bmFtZS5zcGxpdCgnLicpO1xuICAgICAgdmFyIG5ld091dCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb21haW5BcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcyA9IGRvbWFpbkFycmF5W2ldO1xuICAgICAgICBuZXdPdXQucHVzaChzLm1hdGNoKC9bXkEtWmEtejAtOV8tXS8pID9cbiAgICAgICAgICAgICd4bi0tJyArIHB1bnljb2RlLmVuY29kZShzKSA6IHMpO1xuICAgICAgfVxuICAgICAgb3V0Lmhvc3RuYW1lID0gbmV3T3V0LmpvaW4oJy4nKTtcbiAgICB9XG5cbiAgICBvdXQuaG9zdCA9IChvdXQuaG9zdG5hbWUgfHwgJycpICtcbiAgICAgICAgKChvdXQucG9ydCkgPyAnOicgKyBvdXQucG9ydCA6ICcnKTtcbiAgICBvdXQuaHJlZiArPSBvdXQuaG9zdDtcblxuICAgIC8vIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICBvdXQuaG9zdG5hbWUgPSBvdXQuaG9zdG5hbWUuc3Vic3RyKDEsIG91dC5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgb3V0Lmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIG91dC5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgb3V0LnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgb3V0LnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2Uob3V0LnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIG91dC5zZWFyY2ggPSAnJztcbiAgICBvdXQucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgb3V0LnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIG91dC5ob3N0bmFtZSAmJiAhb3V0LnBhdGhuYW1lKSB7XG4gICAgb3V0LnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAob3V0LnBhdGhuYW1lIHx8IG91dC5zZWFyY2gpIHtcbiAgICBvdXQucGF0aCA9IChvdXQucGF0aG5hbWUgPyBvdXQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgKG91dC5zZWFyY2ggPyBvdXQuc2VhcmNoIDogJycpO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIG91dC5ocmVmID0gdXJsRm9ybWF0KG91dCk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAodHlwZW9mKG9iaikgPT09ICdzdHJpbmcnKSBvYmogPSB1cmxQYXJzZShvYmopO1xuXG4gIHZhciBhdXRoID0gb2JqLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IG9iai5wcm90b2NvbCB8fCAnJyxcbiAgICAgIHBhdGhuYW1lID0gb2JqLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgaGFzaCA9IG9iai5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAob2JqLmhvc3QgIT09IHVuZGVmaW5lZCkge1xuICAgIGhvc3QgPSBhdXRoICsgb2JqLmhvc3Q7XG4gIH0gZWxzZSBpZiAob2JqLmhvc3RuYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICBob3N0ID0gYXV0aCArIChvYmouaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIG9iai5ob3N0bmFtZSA6XG4gICAgICAgICdbJyArIG9iai5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKG9iai5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIG9iai5wb3J0O1xuICAgIH1cbiAgfVxuXG4gIGlmIChvYmoucXVlcnkgJiYgdHlwZW9mIG9iai5xdWVyeSA9PT0gJ29iamVjdCcgJiZcbiAgICAgIE9iamVjdC5rZXlzKG9iai5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkob2JqLnF1ZXJ5KTtcbiAgfVxuXG4gIHZhciBzZWFyY2ggPSBvYmouc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmIChvYmouc2xhc2hlcyB8fFxuICAgICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsRm9ybWF0KHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkpO1xufVxuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTtcblxuICBzb3VyY2UgPSB1cmxQYXJzZSh1cmxGb3JtYXQoc291cmNlKSwgZmFsc2UsIHRydWUpO1xuICByZWxhdGl2ZSA9IHVybFBhcnNlKHVybEZvcm1hdChyZWxhdGl2ZSksIGZhbHNlLCB0cnVlKTtcblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgc291cmNlLmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHNvdXJjZS5ocmVmID0gdXJsRm9ybWF0KHNvdXJjZSk7XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICByZWxhdGl2ZS5wcm90b2NvbCA9IHNvdXJjZS5wcm90b2NvbDtcbiAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdICYmXG4gICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lICYmICFyZWxhdGl2ZS5wYXRobmFtZSkge1xuICAgICAgcmVsYXRpdmUucGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lID0gJy8nO1xuICAgIH1cbiAgICByZWxhdGl2ZS5ocmVmID0gdXJsRm9ybWF0KHJlbGF0aXZlKTtcbiAgICByZXR1cm4gcmVsYXRpdmU7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHNvdXJjZS5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHJlbGF0aXZlLmhyZWYgPSB1cmxGb3JtYXQocmVsYXRpdmUpO1xuICAgICAgcmV0dXJuIHJlbGF0aXZlO1xuICAgIH1cbiAgICBzb3VyY2UucHJvdG9jb2wgPSByZWxhdGl2ZS5wcm90b2NvbDtcbiAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIWhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTtcbiAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTtcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9ICcnO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJztcbiAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICByZWxhdGl2ZS5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH1cbiAgICBzb3VyY2UucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICBzb3VyY2Uuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHNvdXJjZS5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNvdXJjZS5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICBzb3VyY2UuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgc291cmNlLmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICBzb3VyY2UucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChzb3VyY2UucGF0aG5hbWUgIT09IHVuZGVmaW5lZCB8fCBzb3VyY2Uuc2VhcmNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHNvdXJjZS5wYXRoID0gKHNvdXJjZS5wYXRobmFtZSA/IHNvdXJjZS5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChzb3VyY2Uuc2VhcmNoID8gc291cmNlLnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgc291cmNlLnNsYXNoZXMgPSBzb3VyY2Uuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHNvdXJjZS5ocmVmID0gdXJsRm9ybWF0KHNvdXJjZSk7XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIHZhciBpc1NvdXJjZUFicyA9IChzb3VyY2UucGF0aG5hbWUgJiYgc291cmNlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSxcbiAgICAgIGlzUmVsQWJzID0gKFxuICAgICAgICAgIHJlbGF0aXZlLmhvc3QgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAoc291cmNlLmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHNvdXJjZS5wYXRobmFtZSAmJiBzb3VyY2UucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gc291cmNlLnByb3RvY29sICYmXG4gICAgICAgICAgIXNsYXNoZWRQcm90b2NvbFtzb3VyY2UucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHNvdXJjZS5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG5cbiAgICBkZWxldGUgc291cmNlLmhvc3RuYW1lO1xuICAgIGRlbGV0ZSBzb3VyY2UucG9ydDtcbiAgICBpZiAoc291cmNlLmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHNvdXJjZS5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQoc291cmNlLmhvc3QpO1xuICAgIH1cbiAgICBkZWxldGUgc291cmNlLmhvc3Q7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICBkZWxldGUgcmVsYXRpdmUuaG9zdG5hbWU7XG4gICAgICBkZWxldGUgcmVsYXRpdmUucG9ydDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgZGVsZXRlIHJlbGF0aXZlLmhvc3Q7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHNvdXJjZS5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogc291cmNlLmhvc3Q7XG4gICAgc291cmNlLmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogc291cmNlLmhvc3RuYW1lO1xuICAgIHNvdXJjZS5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgc291cmNlLnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgc291cmNlLnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICBzb3VyY2UucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICgnc2VhcmNoJyBpbiByZWxhdGl2ZSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHNvdXJjZS5ob3N0bmFtZSA9IHNvdXJjZS5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHNvdXJjZS5ob3N0ICYmIHNvdXJjZS5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICBzb3VyY2UuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgc291cmNlLmhvc3QgPSBzb3VyY2UuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHNvdXJjZS5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgc291cmNlLnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChzb3VyY2UucGF0aG5hbWUgIT09IHVuZGVmaW5lZCB8fCBzb3VyY2Uuc2VhcmNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHNvdXJjZS5wYXRoID0gKHNvdXJjZS5wYXRobmFtZSA/IHNvdXJjZS5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChzb3VyY2Uuc2VhcmNoID8gc291cmNlLnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgc291cmNlLmhyZWYgPSB1cmxGb3JtYXQoc291cmNlKTtcbiAgICByZXR1cm4gc291cmNlO1xuICB9XG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICBkZWxldGUgc291cmNlLnBhdGhuYW1lO1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoIXNvdXJjZS5zZWFyY2gpIHtcbiAgICAgIHNvdXJjZS5wYXRoID0gJy8nICsgc291cmNlLnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHNvdXJjZS5wYXRoO1xuICAgIH1cbiAgICBzb3VyY2UuaHJlZiA9IHVybEZvcm1hdChzb3VyY2UpO1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChzb3VyY2UuaG9zdCB8fCByZWxhdGl2ZS5ob3N0KSAmJiAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8XG4gICAgICBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICBzb3VyY2UuaG9zdG5hbWUgPSBzb3VyY2UuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSBzb3VyY2UuaG9zdCAmJiBzb3VyY2UuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHNvdXJjZS5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgc291cmNlLmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICBzb3VyY2UuaG9zdCA9IHNvdXJjZS5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAoc291cmNlLmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIHNvdXJjZS5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmIChzb3VyY2UucGF0aG5hbWUgIT09IHVuZGVmaW5lZCB8fCBzb3VyY2Uuc2VhcmNoICE9PSB1bmRlZmluZWQpIHtcbiAgICBzb3VyY2UucGF0aCA9IChzb3VyY2UucGF0aG5hbWUgPyBzb3VyY2UucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNvdXJjZS5zZWFyY2ggPyBzb3VyY2Uuc2VhcmNoIDogJycpO1xuICB9XG4gIHNvdXJjZS5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCBzb3VyY2UuYXV0aDtcbiAgc291cmNlLnNsYXNoZXMgPSBzb3VyY2Uuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICBzb3VyY2UuaHJlZiA9IHVybEZvcm1hdChzb3VyY2UpO1xuICByZXR1cm4gc291cmNlO1xufVxuXG5mdW5jdGlvbiBwYXJzZUhvc3QoaG9zdCkge1xuICB2YXIgb3V0ID0ge307XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICBvdXQucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIG91dC5ob3N0bmFtZSA9IGhvc3Q7XG4gIHJldHVybiBvdXQ7XG59XG5cbn0oKSk7XG4iLCIvKipcbiAqIFdyYXBzIGEgZnVuY3Rpb24gd2l0aCBhIHNlY3VyaXR5IGNoZWNrIHRoYXQgZW5zdXJlcyB0aGUgYXJndW1lbnQgYmVpbmdcbiAqIHBhc3NlZCBpbiBpcyBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG52YXIgYWNjZXB0U3RyaW5nID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDaGFuZ2luZyBjYXNlIHdpbGwgb25seSB3b3JrcyBvbiBzdHJpbmdzJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG4vKipcbiAqIFNhbml0aXplcyBhIHBhc3NlZCBpbiBzdHJpbmcgd2l0aCBjZXJ0YWluIG9wdGlvbnMuIEl0IGFjY2VwdHMgYSByZXBsYWNlbWVudFxuICogZnVuY3Rpb24gdGhhdCBzaG91bGQgYWNjZXB0IGEgc3RyaW5nIHdvcmQgcGFyYW1ldGVyLiBJdCBhbHNvIGFjY2VwdHMgYW5cbiAqIG9wdGlvbmFsIHNlcGFyYXRvciBvdmVycmlkZSB0byByZXBsYWNlIHRoZSBzZXBhcmF0b3IgY2hhcmFjdGVyLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gICBzdHJpbmdcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSByZXBsYWNlbWVudFxuICogQHBhcmFtICB7RnVuY3Rpb258U3RyaW5nfSBbc2VwYXJhdG9yXVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbnZhciBzYW5pdGl6ZVN0cmluZyA9IGZ1bmN0aW9uIChzdHJpbmcsIHJlcGxhY2VtZW50LCBzZXBhcmF0b3IpIHtcbiAgdmFyIGluZGV4ID0gLTE7XG5cbiAgcmV0dXJuIHN0cmluZ1xuICAgIC5yZXBsYWNlKC8oW2EtejAtOV0pKFtBLVpdKS9nLCAnJDEgJDInKVxuICAgIC5yZXBsYWNlKC8oW15hLXpBLVowLTldKikoW2EtekEtWjAtOV0qKS9nLCBmdW5jdGlvbiAoXywgJDAsICQxKSB7XG4gICAgICB2YXIgcHJlZml4ID0gJDA7XG5cbiAgICAgIGluZGV4ICs9IDE7XG5cbiAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXBhcmF0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcHJlZml4ID0gc2VwYXJhdG9yO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZXBhcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBwcmVmaXggPSBzZXBhcmF0b3IoJDAsIGluZGV4LCBzdHJpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmVmaXggKyByZXBsYWNlbWVudCgkMSwgaW5kZXgsIHN0cmluZyk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEV4cG9ydHMgb2JqZWN0LlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBlID0gZXhwb3J0cztcblxuLyoqXG4gKiBFeHBvc2UgYSBtdXRhYmxlIGFycmF5IG9mIGluc2lnbmlmaWNhbnQgd29yZHMgdGhhdCB3aWxsIG5vdCBiZSB0aXRsZSBjYXNlZC5cbiAqXG4gKiBAdHlwZSB7QXJyYXl9XG4gKi9cbmUuaW5zaWduaWZpY2FudFdvcmRzID0gWydhbmQnXTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgYm9vbGVhbiBkZXNjcmliaW5nIHdoZXRoZXIgdGhlIHN0cmluZyBpcyBhbGwgVVBQRVJDQVNFIG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZS5pc1VwcGVyQ2FzZSA9IGFjY2VwdFN0cmluZyhmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcgPT09IGUudXBwZXJDYXNlKHN0cmluZyk7XG59KTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgYm9vbGVhbiBkZXNjcmliaW5nIHdoZXRoZXIgdGhlIHN0cmluZyBpcyBhbGwgbG93ZXJjYXNlIG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZS5pc0xvd2VyQ2FzZSA9IGFjY2VwdFN0cmluZyhmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcgPT09IGUubG93ZXJDYXNlKHN0cmluZyk7XG59KTtcblxuLyoqXG4gKiBMb3dlcmNhc2UgYSBwYXNzZWQgaW4gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmUubG93ZXJDYXNlID0gYWNjZXB0U3RyaW5nKGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy50b0xvd2VyQ2FzZSgpO1xufSk7XG5cbi8qKlxuICogVXBwZXJjYXNlIGEgcGFzc2VkIGluIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5lLnVwcGVyQ2FzZSA9IGFjY2VwdFN0cmluZyhmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcudG9VcHBlckNhc2UoKTtcbn0pO1xuXG4vKipcbiAqIFVwcGVyY2FzZSB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmUudXBwZXJDYXNlRmlyc3QgPSBhY2NlcHRTdHJpbmcoZnVuY3Rpb24gKHN0cmluZykge1xuICByZXR1cm4gZS51cHBlckNhc2Uoc3RyaW5nLmNoYXJBdCgwKSkgKyBzdHJpbmcuc3Vic3RyKDEpO1xufSk7XG5cbi8qKlxuICogTG93ZXJjYXNlIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZS5sb3dlckNhc2VGaXJzdCA9IGFjY2VwdFN0cmluZyhmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHJldHVybiBlLmxvd2VyQ2FzZShzdHJpbmcuY2hhckF0KDApKSArIHN0cmluZy5zdWJzdHIoMSk7XG59KTtcblxuLyoqXG4gKiBUaXRsZSBjYXNlIGEgcGFzc2VkIGluIHN0cmluZy4gUGFzcyBhbiBvcHRpb25hbCBib29sZWFuIGZsYWcgdG8gdGl0bGUgY2FzZVxuICogYWxsIHdvcmRzLiBEZWZhdWx0IGJlaGF2aW91ciBpcyB0byBza2lwIGluc2lnbmljYW50IHdvcmRzLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gIHN0cmluZ1xuICogQHBhcmFtICB7Qm9vbGVhbn0gc2lnbmlmaWNhbnRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZS50aXRsZUNhc2UgPSBlLnRpdGxlID0gYWNjZXB0U3RyaW5nKGZ1bmN0aW9uIChzdHJpbmcsIHNpZ25pZmljYW50KSB7XG4gIHJldHVybiBzdHJpbmdcbiAgICAvLyBSZW1vdmUgcHJlZml4ZWQgd2hpdGVzcGFjZS5cbiAgICAucmVwbGFjZSgvXlxccy8sICcnKVxuICAgIC8vIFJlbW92ZSBzdWZmaXhlZCB3aGl0ZXNwYWNlLlxuICAgIC5yZXBsYWNlKC9cXHMkLywgJycpXG4gICAgLy8gVHVybiBhbGwgd2hpdGVzcGFjZSBpbnRvIGEgc2luZ2xlIHNwYWNlIGNoYXJhY3Rlci5cbiAgICAucmVwbGFjZSgvXFxzKy9nLCAnICcpXG4gICAgLy8gUmVwbGFjZSB3b3JkIHN0cmluZ3MuIE1hdGNoZXMgXCJXLkguT1wiLCBcInRlc3RzJ1wiLCBcInRlc3Qnc1wiLCBcInRlc3RcIiwgZXRjLlxuICAgIC5yZXBsYWNlKFxuICAgICAgLyg/Oig/OlthLXpBLVpdXFwuKStbYS16QS1aXXxbYS16QS1aXFwnXFwtXStbYS16QS1aXSopL2csXG4gICAgICBmdW5jdGlvbiAod29yZCwgaW5kZXgpIHtcbiAgICAgICAgLy8gVXBwZXJjYXNlIFwiVy5ILk9cIlxuICAgICAgICBpZiAoLyg/OlthLXpBLVpdXFwuKStbYS16QS1aXS9nLnRlc3Qod29yZCkpIHtcbiAgICAgICAgICByZXR1cm4gZS51cHBlckNhc2Uod29yZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNpZ25pZmljYW50ICYmIGluZGV4ID4gMCkge1xuICAgICAgICAgIGlmICh3b3JkLmxlbmd0aCA8IDMgfHwgfmUuaW5zaWduaWZpY2FudFdvcmRzLmluZGV4T2Yod29yZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBlLmxvd2VyQ2FzZSh3b3JkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZS51cHBlckNhc2VGaXJzdChlLmxvd2VyQ2FzZSh3b3JkKSk7XG4gICAgICB9KVxuICAgIC8vIEZpeCBicm9rZW4gc2VudGVuY2UgZm9ybWF0dGluZy5cbiAgICAucmVwbGFjZSgvKFxcLlxcLFxcIVxcP1xcOykoW2EtekEtWjAtOV0rKSAvZywgJyQxICQyJyk7XG59KTtcblxuLyoqXG4gKiBTZW50ZW5jZSBjYXNlIGEgcGFzc2VkIGluIHN0cmluZy4gRS5nLiBcIlRlc3RTdHJpbmdcIiA9PiBcInRlc3Qgc3RyaW5nXCIuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZS5zZW50ZW5jZUNhc2UgPSBlLnNlbnRlbmNlID0gYWNjZXB0U3RyaW5nKGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgcmV0dXJuIHNhbml0aXplU3RyaW5nKHN0cmluZywgZS5sb3dlckNhc2UsICcgJyk7XG59KTtcblxuLyoqXG4gKiBQYXNjYWwgY2FzZSBhIHBhc3NlZCBpbiBzdHJpbmcuIEUuZy4gXCJ0ZXN0IHN0cmluZ1wiID0+IFwiVGVzdFN0cmluZ1wiLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmUucGFzY2FsQ2FzZSA9IGUucGFzY2FsID0gYWNjZXB0U3RyaW5nKGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgcmV0dXJuIHNhbml0aXplU3RyaW5nKHN0cmluZywgZnVuY3Rpb24gKHdvcmQpIHtcbiAgICByZXR1cm4gZS51cHBlckNhc2VGaXJzdChlLmxvd2VyQ2FzZSh3b3JkKSk7XG4gIH0sICcnKTtcbn0pO1xuXG4vKipcbiAqIENhbWVsIGNhc2UgYSBwYXNzZWQgaW4gc3RyaW5nLiBFLmcuIFwidGVzdCBzdHJpbmdcIiA9PiBcInRlc3RTdHJpbmdcIi5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5lLmNhbWVsQ2FzZSA9IGUuY2FtZWwgPSBhY2NlcHRTdHJpbmcoZnVuY3Rpb24gKHN0cmluZykge1xuICByZXR1cm4gZS5sb3dlckNhc2VGaXJzdChlLnBhc2NhbENhc2Uoc3RyaW5nKSk7XG59KTtcblxuLyoqXG4gKiBTbmFrZSBjYXNlIGEgcGFzc2VkIGluIHN0cmluZy4gRS5nLiBcInRlc3Qgc3RyaW5nXCIgPT4gXCJ0ZXN0X3N0cmluZ1wiLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmUuc25ha2VDYXNlID0gZS5zbmFrZSA9IGFjY2VwdFN0cmluZyhmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHJldHVybiBzYW5pdGl6ZVN0cmluZyhzdHJpbmcsIGUubG93ZXJDYXNlLCAnXycpO1xufSk7XG5cbi8qKlxuICogUGFyYW0gY2FzZSBhIHBhc3NlZCBpbiBzdHJpbmcuIEUuZy4gXCJ0ZXN0IHN0cmluZ1wiID0+IFwidGVzdC1zdHJpbmdcIi5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5lLnBhcmFtQ2FzZSA9IGUucGFyYW0gPSBhY2NlcHRTdHJpbmcoZnVuY3Rpb24gKHN0cmluZykge1xuICByZXR1cm4gc2FuaXRpemVTdHJpbmcoc3RyaW5nLCBlLmxvd2VyQ2FzZSwgJy0nKTtcbn0pO1xuXG4vKipcbiAqIERvdCBjYXNlIGEgcGFzc2VkIGluIHN0cmluZy4gRS5nLiBcInRlc3Qgc3RyaW5nXCIgPT4gXCJ0ZXN0LnN0cmluZ1wiLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmUuZG90Q2FzZSA9IGUuZG90ID0gYWNjZXB0U3RyaW5nKGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgcmV0dXJuIHNhbml0aXplU3RyaW5nKHN0cmluZywgZS5sb3dlckNhc2UsICcuJyk7XG59KTtcblxuLyoqXG4gKiBQYXRoIGNhc2UgYSBwYXNzZWQgaW4gc3RyaW5nLiBFLmcuIFwidGVzdCBzdHJpbmdcIiA9PiBcInRlc3Qvc3RyaW5nXCIuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZS5wYXRoQ2FzZSA9IGUucGF0aCA9IGFjY2VwdFN0cmluZyhmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHJldHVybiBzYW5pdGl6ZVN0cmluZyhzdHJpbmcsIGUubG93ZXJDYXNlLCAnLycpO1xufSk7XG5cbi8qKlxuICogQ29uc3RhbnQgY2FzZSBhIHBhc3NlZCBpbiBzdHJpbmcuIEUuZy4gXCJ0ZXN0IHN0cmluZ1wiID0+IFwiVEVTVF9TVFJJTkdcIi5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5lLmNvbnN0YW50Q2FzZSA9IGUuY29uc3RhbnQgPSBhY2NlcHRTdHJpbmcoZnVuY3Rpb24gKHN0cmluZykge1xuICByZXR1cm4gc2FuaXRpemVTdHJpbmcoc3RyaW5nLCBlLnVwcGVyQ2FzZSwgJ18nKTtcbn0pO1xuXG4vKipcbiAqIFJldmVyc2UgdGhlIGNhc2Ugb2YgYSBzdHJpbmcuIEUuZy4gXCJUZXN0IFN0cmluZ1wiID0+IFwidEVTVCBzVFJJTkdcIi5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5lLnN3aXRjaENhc2UgPSBlLnN3aXRjaCA9IGFjY2VwdFN0cmluZyhmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvW2EtekEtWl0vZywgZnVuY3Rpb24gKGMpIHtcbiAgICB2YXIgdSA9IGUudXBwZXJDYXNlKGMpO1xuICAgIHJldHVybiBjID09PSB1ID8gZS5sb3dlckNhc2UoYykgOiB1O1xuICB9KTtcbn0pO1xuIiwiKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIG5vT3B0aW9ucyA9IHt9O1xuICB2YXIgbm9uV1MgPSAvW15cXHNcXHUwMGEwXS87XG4gIHZhciBQb3MgPSBDb2RlTWlycm9yLlBvcztcblxuICBmdW5jdGlvbiBmaXJzdE5vbldTKHN0cikge1xuICAgIHZhciBmb3VuZCA9IHN0ci5zZWFyY2gobm9uV1MpO1xuICAgIHJldHVybiBmb3VuZCA9PSAtMSA/IDAgOiBmb3VuZDtcbiAgfVxuXG4gIENvZGVNaXJyb3IuY29tbWFuZHMudG9nZ2xlQ29tbWVudCA9IGZ1bmN0aW9uKGNtKSB7XG4gICAgdmFyIG1pbkxpbmUgPSBJbmZpbml0eSwgcmFuZ2VzID0gY20ubGlzdFNlbGVjdGlvbnMoKSwgbW9kZSA9IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IHJhbmdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZyb20gPSByYW5nZXNbaV0uZnJvbSgpLCB0byA9IHJhbmdlc1tpXS50bygpO1xuICAgICAgaWYgKGZyb20ubGluZSA+PSBtaW5MaW5lKSBjb250aW51ZTtcbiAgICAgIGlmICh0by5saW5lID49IG1pbkxpbmUpIHRvID0gUG9zKG1pbkxpbmUsIDApO1xuICAgICAgbWluTGluZSA9IGZyb20ubGluZTtcbiAgICAgIGlmIChtb2RlID09IG51bGwpIHtcbiAgICAgICAgaWYgKGNtLnVuY29tbWVudChmcm9tLCB0bykpIG1vZGUgPSBcInVuXCI7XG4gICAgICAgIGVsc2UgeyBjbS5saW5lQ29tbWVudChmcm9tLCB0byk7IG1vZGUgPSBcImxpbmVcIjsgfVxuICAgICAgfSBlbHNlIGlmIChtb2RlID09IFwidW5cIikge1xuICAgICAgICBjbS51bmNvbW1lbnQoZnJvbSwgdG8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY20ubGluZUNvbW1lbnQoZnJvbSwgdG8pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBDb2RlTWlycm9yLmRlZmluZUV4dGVuc2lvbihcImxpbmVDb21tZW50XCIsIGZ1bmN0aW9uKGZyb20sIHRvLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0gbm9PcHRpb25zO1xuICAgIHZhciBzZWxmID0gdGhpcywgbW9kZSA9IHNlbGYuZ2V0TW9kZUF0KGZyb20pO1xuICAgIHZhciBjb21tZW50U3RyaW5nID0gb3B0aW9ucy5saW5lQ29tbWVudCB8fCBtb2RlLmxpbmVDb21tZW50O1xuICAgIGlmICghY29tbWVudFN0cmluZykge1xuICAgICAgaWYgKG9wdGlvbnMuYmxvY2tDb21tZW50U3RhcnQgfHwgbW9kZS5ibG9ja0NvbW1lbnRTdGFydCkge1xuICAgICAgICBvcHRpb25zLmZ1bGxMaW5lcyA9IHRydWU7XG4gICAgICAgIHNlbGYuYmxvY2tDb21tZW50KGZyb20sIHRvLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGZpcnN0TGluZSA9IHNlbGYuZ2V0TGluZShmcm9tLmxpbmUpO1xuICAgIGlmIChmaXJzdExpbmUgPT0gbnVsbCkgcmV0dXJuO1xuICAgIHZhciBlbmQgPSBNYXRoLm1pbih0by5jaCAhPSAwIHx8IHRvLmxpbmUgPT0gZnJvbS5saW5lID8gdG8ubGluZSArIDEgOiB0by5saW5lLCBzZWxmLmxhc3RMaW5lKCkgKyAxKTtcbiAgICB2YXIgcGFkID0gb3B0aW9ucy5wYWRkaW5nID09IG51bGwgPyBcIiBcIiA6IG9wdGlvbnMucGFkZGluZztcbiAgICB2YXIgYmxhbmtMaW5lcyA9IG9wdGlvbnMuY29tbWVudEJsYW5rTGluZXMgfHwgZnJvbS5saW5lID09IHRvLmxpbmU7XG5cbiAgICBzZWxmLm9wZXJhdGlvbihmdW5jdGlvbigpIHtcbiAgICAgIGlmIChvcHRpb25zLmluZGVudCkge1xuICAgICAgICB2YXIgYmFzZVN0cmluZyA9IGZpcnN0TGluZS5zbGljZSgwLCBmaXJzdE5vbldTKGZpcnN0TGluZSkpO1xuICAgICAgICBmb3IgKHZhciBpID0gZnJvbS5saW5lOyBpIDwgZW5kOyArK2kpIHtcbiAgICAgICAgICB2YXIgbGluZSA9IHNlbGYuZ2V0TGluZShpKSwgY3V0ID0gYmFzZVN0cmluZy5sZW5ndGg7XG4gICAgICAgICAgaWYgKCFibGFua0xpbmVzICYmICFub25XUy50ZXN0KGxpbmUpKSBjb250aW51ZTtcbiAgICAgICAgICBpZiAobGluZS5zbGljZSgwLCBjdXQpICE9IGJhc2VTdHJpbmcpIGN1dCA9IGZpcnN0Tm9uV1MobGluZSk7XG4gICAgICAgICAgc2VsZi5yZXBsYWNlUmFuZ2UoYmFzZVN0cmluZyArIGNvbW1lbnRTdHJpbmcgKyBwYWQsIFBvcyhpLCAwKSwgUG9zKGksIGN1dCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gZnJvbS5saW5lOyBpIDwgZW5kOyArK2kpIHtcbiAgICAgICAgICBpZiAoYmxhbmtMaW5lcyB8fCBub25XUy50ZXN0KHNlbGYuZ2V0TGluZShpKSkpXG4gICAgICAgICAgICBzZWxmLnJlcGxhY2VSYW5nZShjb21tZW50U3RyaW5nICsgcGFkLCBQb3MoaSwgMCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lRXh0ZW5zaW9uKFwiYmxvY2tDb21tZW50XCIsIGZ1bmN0aW9uKGZyb20sIHRvLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0gbm9PcHRpb25zO1xuICAgIHZhciBzZWxmID0gdGhpcywgbW9kZSA9IHNlbGYuZ2V0TW9kZUF0KGZyb20pO1xuICAgIHZhciBzdGFydFN0cmluZyA9IG9wdGlvbnMuYmxvY2tDb21tZW50U3RhcnQgfHwgbW9kZS5ibG9ja0NvbW1lbnRTdGFydDtcbiAgICB2YXIgZW5kU3RyaW5nID0gb3B0aW9ucy5ibG9ja0NvbW1lbnRFbmQgfHwgbW9kZS5ibG9ja0NvbW1lbnRFbmQ7XG4gICAgaWYgKCFzdGFydFN0cmluZyB8fCAhZW5kU3RyaW5nKSB7XG4gICAgICBpZiAoKG9wdGlvbnMubGluZUNvbW1lbnQgfHwgbW9kZS5saW5lQ29tbWVudCkgJiYgb3B0aW9ucy5mdWxsTGluZXMgIT0gZmFsc2UpXG4gICAgICAgIHNlbGYubGluZUNvbW1lbnQoZnJvbSwgdG8sIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBNYXRoLm1pbih0by5saW5lLCBzZWxmLmxhc3RMaW5lKCkpO1xuICAgIGlmIChlbmQgIT0gZnJvbS5saW5lICYmIHRvLmNoID09IDAgJiYgbm9uV1MudGVzdChzZWxmLmdldExpbmUoZW5kKSkpIC0tZW5kO1xuXG4gICAgdmFyIHBhZCA9IG9wdGlvbnMucGFkZGluZyA9PSBudWxsID8gXCIgXCIgOiBvcHRpb25zLnBhZGRpbmc7XG4gICAgaWYgKGZyb20ubGluZSA+IGVuZCkgcmV0dXJuO1xuXG4gICAgc2VsZi5vcGVyYXRpb24oZnVuY3Rpb24oKSB7XG4gICAgICBpZiAob3B0aW9ucy5mdWxsTGluZXMgIT0gZmFsc2UpIHtcbiAgICAgICAgdmFyIGxhc3RMaW5lSGFzVGV4dCA9IG5vbldTLnRlc3Qoc2VsZi5nZXRMaW5lKGVuZCkpO1xuICAgICAgICBzZWxmLnJlcGxhY2VSYW5nZShwYWQgKyBlbmRTdHJpbmcsIFBvcyhlbmQpKTtcbiAgICAgICAgc2VsZi5yZXBsYWNlUmFuZ2Uoc3RhcnRTdHJpbmcgKyBwYWQsIFBvcyhmcm9tLmxpbmUsIDApKTtcbiAgICAgICAgdmFyIGxlYWQgPSBvcHRpb25zLmJsb2NrQ29tbWVudExlYWQgfHwgbW9kZS5ibG9ja0NvbW1lbnRMZWFkO1xuICAgICAgICBpZiAobGVhZCAhPSBudWxsKSBmb3IgKHZhciBpID0gZnJvbS5saW5lICsgMTsgaSA8PSBlbmQ7ICsraSlcbiAgICAgICAgICBpZiAoaSAhPSBlbmQgfHwgbGFzdExpbmVIYXNUZXh0KVxuICAgICAgICAgICAgc2VsZi5yZXBsYWNlUmFuZ2UobGVhZCArIHBhZCwgUG9zKGksIDApKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYucmVwbGFjZVJhbmdlKGVuZFN0cmluZywgdG8pO1xuICAgICAgICBzZWxmLnJlcGxhY2VSYW5nZShzdGFydFN0cmluZywgZnJvbSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lRXh0ZW5zaW9uKFwidW5jb21tZW50XCIsIGZ1bmN0aW9uKGZyb20sIHRvLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0gbm9PcHRpb25zO1xuICAgIHZhciBzZWxmID0gdGhpcywgbW9kZSA9IHNlbGYuZ2V0TW9kZUF0KGZyb20pO1xuICAgIHZhciBlbmQgPSBNYXRoLm1pbih0by5saW5lLCBzZWxmLmxhc3RMaW5lKCkpLCBzdGFydCA9IE1hdGgubWluKGZyb20ubGluZSwgZW5kKTtcblxuICAgIC8vIFRyeSBmaW5kaW5nIGxpbmUgY29tbWVudHNcbiAgICB2YXIgbGluZVN0cmluZyA9IG9wdGlvbnMubGluZUNvbW1lbnQgfHwgbW9kZS5saW5lQ29tbWVudCwgbGluZXMgPSBbXTtcbiAgICB2YXIgcGFkID0gb3B0aW9ucy5wYWRkaW5nID09IG51bGwgPyBcIiBcIiA6IG9wdGlvbnMucGFkZGluZywgZGlkU29tZXRoaW5nO1xuICAgIGxpbmVDb21tZW50OiB7XG4gICAgICBpZiAoIWxpbmVTdHJpbmcpIGJyZWFrIGxpbmVDb21tZW50O1xuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgKytpKSB7XG4gICAgICAgIHZhciBsaW5lID0gc2VsZi5nZXRMaW5lKGkpO1xuICAgICAgICB2YXIgZm91bmQgPSBsaW5lLmluZGV4T2YobGluZVN0cmluZyk7XG4gICAgICAgIGlmIChmb3VuZCA+IC0xICYmICEvY29tbWVudC8udGVzdChzZWxmLmdldFRva2VuVHlwZUF0KFBvcyhpLCBmb3VuZCArIDEpKSkpIGZvdW5kID0gLTE7XG4gICAgICAgIGlmIChmb3VuZCA9PSAtMSAmJiAoaSAhPSBlbmQgfHwgaSA9PSBzdGFydCkgJiYgbm9uV1MudGVzdChsaW5lKSkgYnJlYWsgbGluZUNvbW1lbnQ7XG4gICAgICAgIGlmIChmb3VuZCA+IC0xICYmIG5vbldTLnRlc3QobGluZS5zbGljZSgwLCBmb3VuZCkpKSBicmVhayBsaW5lQ29tbWVudDtcbiAgICAgICAgbGluZXMucHVzaChsaW5lKTtcbiAgICAgIH1cbiAgICAgIHNlbGYub3BlcmF0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyArK2kpIHtcbiAgICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2kgLSBzdGFydF07XG4gICAgICAgICAgdmFyIHBvcyA9IGxpbmUuaW5kZXhPZihsaW5lU3RyaW5nKSwgZW5kUG9zID0gcG9zICsgbGluZVN0cmluZy5sZW5ndGg7XG4gICAgICAgICAgaWYgKHBvcyA8IDApIGNvbnRpbnVlO1xuICAgICAgICAgIGlmIChsaW5lLnNsaWNlKGVuZFBvcywgZW5kUG9zICsgcGFkLmxlbmd0aCkgPT0gcGFkKSBlbmRQb3MgKz0gcGFkLmxlbmd0aDtcbiAgICAgICAgICBkaWRTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgIHNlbGYucmVwbGFjZVJhbmdlKFwiXCIsIFBvcyhpLCBwb3MpLCBQb3MoaSwgZW5kUG9zKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKGRpZFNvbWV0aGluZykgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gVHJ5IGJsb2NrIGNvbW1lbnRzXG4gICAgdmFyIHN0YXJ0U3RyaW5nID0gb3B0aW9ucy5ibG9ja0NvbW1lbnRTdGFydCB8fCBtb2RlLmJsb2NrQ29tbWVudFN0YXJ0O1xuICAgIHZhciBlbmRTdHJpbmcgPSBvcHRpb25zLmJsb2NrQ29tbWVudEVuZCB8fCBtb2RlLmJsb2NrQ29tbWVudEVuZDtcbiAgICBpZiAoIXN0YXJ0U3RyaW5nIHx8ICFlbmRTdHJpbmcpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgbGVhZCA9IG9wdGlvbnMuYmxvY2tDb21tZW50TGVhZCB8fCBtb2RlLmJsb2NrQ29tbWVudExlYWQ7XG4gICAgdmFyIHN0YXJ0TGluZSA9IHNlbGYuZ2V0TGluZShzdGFydCksIGVuZExpbmUgPSBlbmQgPT0gc3RhcnQgPyBzdGFydExpbmUgOiBzZWxmLmdldExpbmUoZW5kKTtcbiAgICB2YXIgb3BlbiA9IHN0YXJ0TGluZS5pbmRleE9mKHN0YXJ0U3RyaW5nKSwgY2xvc2UgPSBlbmRMaW5lLmxhc3RJbmRleE9mKGVuZFN0cmluZyk7XG4gICAgaWYgKGNsb3NlID09IC0xICYmIHN0YXJ0ICE9IGVuZCkge1xuICAgICAgZW5kTGluZSA9IHNlbGYuZ2V0TGluZSgtLWVuZCk7XG4gICAgICBjbG9zZSA9IGVuZExpbmUubGFzdEluZGV4T2YoZW5kU3RyaW5nKTtcbiAgICB9XG4gICAgaWYgKG9wZW4gPT0gLTEgfHwgY2xvc2UgPT0gLTEgfHxcbiAgICAgICAgIS9jb21tZW50Ly50ZXN0KHNlbGYuZ2V0VG9rZW5UeXBlQXQoUG9zKHN0YXJ0LCBvcGVuICsgMSkpKSB8fFxuICAgICAgICAhL2NvbW1lbnQvLnRlc3Qoc2VsZi5nZXRUb2tlblR5cGVBdChQb3MoZW5kLCBjbG9zZSArIDEpKSkpXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBzZWxmLm9wZXJhdGlvbihmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYucmVwbGFjZVJhbmdlKFwiXCIsIFBvcyhlbmQsIGNsb3NlIC0gKHBhZCAmJiBlbmRMaW5lLnNsaWNlKGNsb3NlIC0gcGFkLmxlbmd0aCwgY2xvc2UpID09IHBhZCA/IHBhZC5sZW5ndGggOiAwKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBQb3MoZW5kLCBjbG9zZSArIGVuZFN0cmluZy5sZW5ndGgpKTtcbiAgICAgIHZhciBvcGVuRW5kID0gb3BlbiArIHN0YXJ0U3RyaW5nLmxlbmd0aDtcbiAgICAgIGlmIChwYWQgJiYgc3RhcnRMaW5lLnNsaWNlKG9wZW5FbmQsIG9wZW5FbmQgKyBwYWQubGVuZ3RoKSA9PSBwYWQpIG9wZW5FbmQgKz0gcGFkLmxlbmd0aDtcbiAgICAgIHNlbGYucmVwbGFjZVJhbmdlKFwiXCIsIFBvcyhzdGFydCwgb3BlbiksIFBvcyhzdGFydCwgb3BlbkVuZCkpO1xuICAgICAgaWYgKGxlYWQpIGZvciAodmFyIGkgPSBzdGFydCArIDE7IGkgPD0gZW5kOyArK2kpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBzZWxmLmdldExpbmUoaSksIGZvdW5kID0gbGluZS5pbmRleE9mKGxlYWQpO1xuICAgICAgICBpZiAoZm91bmQgPT0gLTEgfHwgbm9uV1MudGVzdChsaW5lLnNsaWNlKDAsIGZvdW5kKSkpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgZm91bmRFbmQgPSBmb3VuZCArIGxlYWQubGVuZ3RoO1xuICAgICAgICBpZiAocGFkICYmIGxpbmUuc2xpY2UoZm91bmRFbmQsIGZvdW5kRW5kICsgcGFkLmxlbmd0aCkgPT0gcGFkKSBmb3VuZEVuZCArPSBwYWQubGVuZ3RoO1xuICAgICAgICBzZWxmLnJlcGxhY2VSYW5nZShcIlwiLCBQb3MoaSwgZm91bmQpLCBQb3MoaSwgZm91bmRFbmQpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG59KTtcbiIsIi8vIFV0aWxpdHkgZnVuY3Rpb24gdGhhdCBhbGxvd3MgbW9kZXMgdG8gYmUgY29tYmluZWQuIFRoZSBtb2RlIGdpdmVuXG4vLyBhcyB0aGUgYmFzZSBhcmd1bWVudCB0YWtlcyBjYXJlIG9mIG1vc3Qgb2YgdGhlIG5vcm1hbCBtb2RlXG4vLyBmdW5jdGlvbmFsaXR5LCBidXQgYSBzZWNvbmQgKHR5cGljYWxseSBzaW1wbGUpIG1vZGUgaXMgdXNlZCwgd2hpY2hcbi8vIGNhbiBvdmVycmlkZSB0aGUgc3R5bGUgb2YgdGV4dC4gQm90aCBtb2RlcyBnZXQgdG8gcGFyc2UgYWxsIG9mIHRoZVxuLy8gdGV4dCwgYnV0IHdoZW4gYm90aCBhc3NpZ24gYSBub24tbnVsbCBzdHlsZSB0byBhIHBpZWNlIG9mIGNvZGUsIHRoZVxuLy8gb3ZlcmxheSB3aW5zLCB1bmxlc3MgdGhlIGNvbWJpbmUgYXJndW1lbnQgd2FzIHRydWUsIGluIHdoaWNoIGNhc2Vcbi8vIHRoZSBzdHlsZXMgYXJlIGNvbWJpbmVkLlxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbkNvZGVNaXJyb3Iub3ZlcmxheU1vZGUgPSBmdW5jdGlvbihiYXNlLCBvdmVybGF5LCBjb21iaW5lKSB7XG4gIHJldHVybiB7XG4gICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiYXNlOiBDb2RlTWlycm9yLnN0YXJ0U3RhdGUoYmFzZSksXG4gICAgICAgIG92ZXJsYXk6IENvZGVNaXJyb3Iuc3RhcnRTdGF0ZShvdmVybGF5KSxcbiAgICAgICAgYmFzZVBvczogMCwgYmFzZUN1cjogbnVsbCxcbiAgICAgICAgb3ZlcmxheVBvczogMCwgb3ZlcmxheUN1cjogbnVsbCxcbiAgICAgICAgbGluZVNlZW46IG51bGxcbiAgICAgIH07XG4gICAgfSxcbiAgICBjb3B5U3RhdGU6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiYXNlOiBDb2RlTWlycm9yLmNvcHlTdGF0ZShiYXNlLCBzdGF0ZS5iYXNlKSxcbiAgICAgICAgb3ZlcmxheTogQ29kZU1pcnJvci5jb3B5U3RhdGUob3ZlcmxheSwgc3RhdGUub3ZlcmxheSksXG4gICAgICAgIGJhc2VQb3M6IHN0YXRlLmJhc2VQb3MsIGJhc2VDdXI6IG51bGwsXG4gICAgICAgIG92ZXJsYXlQb3M6IHN0YXRlLm92ZXJsYXlQb3MsIG92ZXJsYXlDdXI6IG51bGxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBpZiAoc3RyZWFtLnNvbCgpIHx8IHN0cmVhbS5zdHJpbmcgIT0gc3RhdGUubGluZVNlZW4gfHxcbiAgICAgICAgICBNYXRoLm1pbihzdGF0ZS5iYXNlUG9zLCBzdGF0ZS5vdmVybGF5UG9zKSA8IHN0cmVhbS5zdGFydCkge1xuICAgICAgICBzdGF0ZS5saW5lU2VlbiA9IHN0cmVhbS5zdHJpbmc7XG4gICAgICAgIHN0YXRlLmJhc2VQb3MgPSBzdGF0ZS5vdmVybGF5UG9zID0gc3RyZWFtLnN0YXJ0O1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RyZWFtLnN0YXJ0ID09IHN0YXRlLmJhc2VQb3MpIHtcbiAgICAgICAgc3RhdGUuYmFzZUN1ciA9IGJhc2UudG9rZW4oc3RyZWFtLCBzdGF0ZS5iYXNlKTtcbiAgICAgICAgc3RhdGUuYmFzZVBvcyA9IHN0cmVhbS5wb3M7XG4gICAgICB9XG4gICAgICBpZiAoc3RyZWFtLnN0YXJ0ID09IHN0YXRlLm92ZXJsYXlQb3MpIHtcbiAgICAgICAgc3RyZWFtLnBvcyA9IHN0cmVhbS5zdGFydDtcbiAgICAgICAgc3RhdGUub3ZlcmxheUN1ciA9IG92ZXJsYXkudG9rZW4oc3RyZWFtLCBzdGF0ZS5vdmVybGF5KTtcbiAgICAgICAgc3RhdGUub3ZlcmxheVBvcyA9IHN0cmVhbS5wb3M7XG4gICAgICB9XG4gICAgICBzdHJlYW0ucG9zID0gTWF0aC5taW4oc3RhdGUuYmFzZVBvcywgc3RhdGUub3ZlcmxheVBvcyk7XG5cbiAgICAgIGlmIChzdGF0ZS5vdmVybGF5Q3VyID09IG51bGwpIHJldHVybiBzdGF0ZS5iYXNlQ3VyO1xuICAgICAgaWYgKHN0YXRlLmJhc2VDdXIgIT0gbnVsbCAmJiBjb21iaW5lKSByZXR1cm4gc3RhdGUuYmFzZUN1ciArIFwiIFwiICsgc3RhdGUub3ZlcmxheUN1cjtcbiAgICAgIGVsc2UgcmV0dXJuIHN0YXRlLm92ZXJsYXlDdXI7XG4gICAgfSxcblxuICAgIGluZGVudDogYmFzZS5pbmRlbnQgJiYgZnVuY3Rpb24oc3RhdGUsIHRleHRBZnRlcikge1xuICAgICAgcmV0dXJuIGJhc2UuaW5kZW50KHN0YXRlLmJhc2UsIHRleHRBZnRlcik7XG4gICAgfSxcbiAgICBlbGVjdHJpY0NoYXJzOiBiYXNlLmVsZWN0cmljQ2hhcnMsXG5cbiAgICBpbm5lck1vZGU6IGZ1bmN0aW9uKHN0YXRlKSB7IHJldHVybiB7c3RhdGU6IHN0YXRlLmJhc2UsIG1vZGU6IGJhc2V9OyB9LFxuXG4gICAgYmxhbmtMaW5lOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgaWYgKGJhc2UuYmxhbmtMaW5lKSBiYXNlLmJsYW5rTGluZShzdGF0ZS5iYXNlKTtcbiAgICAgIGlmIChvdmVybGF5LmJsYW5rTGluZSkgb3ZlcmxheS5ibGFua0xpbmUoc3RhdGUub3ZlcmxheSk7XG4gICAgfVxuICB9O1xufTtcblxufSk7XG4iLCIvLyBUaGlzIGlzIENvZGVNaXJyb3IgKGh0dHA6Ly9jb2RlbWlycm9yLm5ldCksIGEgY29kZSBlZGl0b3Jcbi8vIGltcGxlbWVudGVkIGluIEphdmFTY3JpcHQgb24gdG9wIG9mIHRoZSBicm93c2VyJ3MgRE9NLlxuLy9cbi8vIFlvdSBjYW4gZmluZCBzb21lIHRlY2huaWNhbCBiYWNrZ3JvdW5kIGZvciBzb21lIG9mIHRoZSBjb2RlIGJlbG93XG4vLyBhdCBodHRwOi8vbWFyaWpuaGF2ZXJiZWtlLm5sL2Jsb2cvI2NtLWludGVybmFscyAuXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZHVsZS5leHBvcnRzID0gbW9kKCk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIHJldHVybiBkZWZpbmUoW10sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICB0aGlzLkNvZGVNaXJyb3IgPSBtb2QoKTtcbn0pKGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICAvLyBCUk9XU0VSIFNOSUZGSU5HXG5cbiAgLy8gS2x1ZGdlcyBmb3IgYnVncyBhbmQgYmVoYXZpb3IgZGlmZmVyZW5jZXMgdGhhdCBjYW4ndCBiZSBmZWF0dXJlXG4gIC8vIGRldGVjdGVkIGFyZSBlbmFibGVkIGJhc2VkIG9uIHVzZXJBZ2VudCBldGMgc25pZmZpbmcuXG5cbiAgdmFyIGdlY2tvID0gL2dlY2tvXFwvXFxkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgLy8gaWVfdXB0b04gbWVhbnMgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbiBOIG9yIGxvd2VyXG4gIHZhciBpZV91cHRvMTAgPSAvTVNJRSBcXGQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIHZhciBpZV91cHRvNyA9IGllX3VwdG8xMCAmJiAoZG9jdW1lbnQuZG9jdW1lbnRNb2RlID09IG51bGwgfHwgZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDwgOCk7XG4gIHZhciBpZV91cHRvOCA9IGllX3VwdG8xMCAmJiAoZG9jdW1lbnQuZG9jdW1lbnRNb2RlID09IG51bGwgfHwgZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDwgOSk7XG4gIHZhciBpZV91cHRvOSA9IGllX3VwdG8xMCAmJiAoZG9jdW1lbnQuZG9jdW1lbnRNb2RlID09IG51bGwgfHwgZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDwgMTApO1xuICB2YXIgaWVfMTF1cCA9IC9UcmlkZW50XFwvKFs3LTldfFxcZHsyLH0pXFwuLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB2YXIgaWUgPSBpZV91cHRvMTAgfHwgaWVfMTF1cDtcbiAgdmFyIHdlYmtpdCA9IC9XZWJLaXRcXC8vLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIHZhciBxdHdlYmtpdCA9IHdlYmtpdCAmJiAvUXRcXC9cXGQrXFwuXFxkKy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgdmFyIGNocm9tZSA9IC9DaHJvbWVcXC8vLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIHZhciBwcmVzdG8gPSAvT3BlcmFcXC8vLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIHZhciBzYWZhcmkgPSAvQXBwbGUgQ29tcHV0ZXIvLnRlc3QobmF2aWdhdG9yLnZlbmRvcik7XG4gIHZhciBraHRtbCA9IC9LSFRNTFxcLy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgdmFyIG1hY19nZU1vdW50YWluTGlvbiA9IC9NYWMgT1MgWCAxXFxkXFxEKFs4LTldfFxcZFxcZClcXEQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIHZhciBwaGFudG9tID0gL1BoYW50b21KUy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuICB2YXIgaW9zID0gL0FwcGxlV2ViS2l0Ly50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmIC9Nb2JpbGVcXC9cXHcrLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAvLyBUaGlzIGlzIHdvZWZ1bGx5IGluY29tcGxldGUuIFN1Z2dlc3Rpb25zIGZvciBhbHRlcm5hdGl2ZSBtZXRob2RzIHdlbGNvbWUuXG4gIHZhciBtb2JpbGUgPSBpb3MgfHwgL0FuZHJvaWR8d2ViT1N8QmxhY2tCZXJyeXxPcGVyYSBNaW5pfE9wZXJhIE1vYml8SUVNb2JpbGUvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB2YXIgbWFjID0gaW9zIHx8IC9NYWMvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKTtcbiAgdmFyIHdpbmRvd3MgPSAvd2luL2kudGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xuXG4gIHZhciBwcmVzdG9fdmVyc2lvbiA9IHByZXN0byAmJiBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9WZXJzaW9uXFwvKFxcZCpcXC5cXGQqKS8pO1xuICBpZiAocHJlc3RvX3ZlcnNpb24pIHByZXN0b192ZXJzaW9uID0gTnVtYmVyKHByZXN0b192ZXJzaW9uWzFdKTtcbiAgaWYgKHByZXN0b192ZXJzaW9uICYmIHByZXN0b192ZXJzaW9uID49IDE1KSB7IHByZXN0byA9IGZhbHNlOyB3ZWJraXQgPSB0cnVlOyB9XG4gIC8vIFNvbWUgYnJvd3NlcnMgdXNlIHRoZSB3cm9uZyBldmVudCBwcm9wZXJ0aWVzIHRvIHNpZ25hbCBjbWQvY3RybCBvbiBPUyBYXG4gIHZhciBmbGlwQ3RybENtZCA9IG1hYyAmJiAocXR3ZWJraXQgfHwgcHJlc3RvICYmIChwcmVzdG9fdmVyc2lvbiA9PSBudWxsIHx8IHByZXN0b192ZXJzaW9uIDwgMTIuMTEpKTtcbiAgdmFyIGNhcHR1cmVSaWdodENsaWNrID0gZ2Vja28gfHwgKGllICYmICFpZV91cHRvOCk7XG5cbiAgLy8gT3B0aW1pemUgc29tZSBjb2RlIHdoZW4gdGhlc2UgZmVhdHVyZXMgYXJlIG5vdCB1c2VkLlxuICB2YXIgc2F3UmVhZE9ubHlTcGFucyA9IGZhbHNlLCBzYXdDb2xsYXBzZWRTcGFucyA9IGZhbHNlO1xuXG4gIC8vIEVESVRPUiBDT05TVFJVQ1RPUlxuXG4gIC8vIEEgQ29kZU1pcnJvciBpbnN0YW5jZSByZXByZXNlbnRzIGFuIGVkaXRvci4gVGhpcyBpcyB0aGUgb2JqZWN0XG4gIC8vIHRoYXQgdXNlciBjb2RlIGlzIHVzdWFsbHkgZGVhbGluZyB3aXRoLlxuXG4gIGZ1bmN0aW9uIENvZGVNaXJyb3IocGxhY2UsIG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ29kZU1pcnJvcikpIHJldHVybiBuZXcgQ29kZU1pcnJvcihwbGFjZSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAvLyBEZXRlcm1pbmUgZWZmZWN0aXZlIG9wdGlvbnMgYmFzZWQgb24gZ2l2ZW4gdmFsdWVzIGFuZCBkZWZhdWx0cy5cbiAgICBjb3B5T2JqKGRlZmF1bHRzLCBvcHRpb25zLCBmYWxzZSk7XG4gICAgc2V0R3V0dGVyc0ZvckxpbmVOdW1iZXJzKG9wdGlvbnMpO1xuXG4gICAgdmFyIGRvYyA9IG9wdGlvbnMudmFsdWU7XG4gICAgaWYgKHR5cGVvZiBkb2MgPT0gXCJzdHJpbmdcIikgZG9jID0gbmV3IERvYyhkb2MsIG9wdGlvbnMubW9kZSk7XG4gICAgdGhpcy5kb2MgPSBkb2M7XG5cbiAgICB2YXIgZGlzcGxheSA9IHRoaXMuZGlzcGxheSA9IG5ldyBEaXNwbGF5KHBsYWNlLCBkb2MpO1xuICAgIGRpc3BsYXkud3JhcHBlci5Db2RlTWlycm9yID0gdGhpcztcbiAgICB1cGRhdGVHdXR0ZXJzKHRoaXMpO1xuICAgIHRoZW1lQ2hhbmdlZCh0aGlzKTtcbiAgICBpZiAob3B0aW9ucy5saW5lV3JhcHBpbmcpXG4gICAgICB0aGlzLmRpc3BsYXkud3JhcHBlci5jbGFzc05hbWUgKz0gXCIgQ29kZU1pcnJvci13cmFwXCI7XG4gICAgaWYgKG9wdGlvbnMuYXV0b2ZvY3VzICYmICFtb2JpbGUpIGZvY3VzSW5wdXQodGhpcyk7XG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAga2V5TWFwczogW10sICAvLyBzdG9yZXMgbWFwcyBhZGRlZCBieSBhZGRLZXlNYXBcbiAgICAgIG92ZXJsYXlzOiBbXSwgLy8gaGlnaGxpZ2h0aW5nIG92ZXJsYXlzLCBhcyBhZGRlZCBieSBhZGRPdmVybGF5XG4gICAgICBtb2RlR2VuOiAwLCAgIC8vIGJ1bXBlZCB3aGVuIG1vZGUvb3ZlcmxheSBjaGFuZ2VzLCB1c2VkIHRvIGludmFsaWRhdGUgaGlnaGxpZ2h0aW5nIGluZm9cbiAgICAgIG92ZXJ3cml0ZTogZmFsc2UsIGZvY3VzZWQ6IGZhbHNlLFxuICAgICAgc3VwcHJlc3NFZGl0czogZmFsc2UsIC8vIHVzZWQgdG8gZGlzYWJsZSBlZGl0aW5nIGR1cmluZyBrZXkgaGFuZGxlcnMgd2hlbiBpbiByZWFkT25seSBtb2RlXG4gICAgICBwYXN0ZUluY29taW5nOiBmYWxzZSwgY3V0SW5jb21pbmc6IGZhbHNlLCAvLyBoZWxwIHJlY29nbml6ZSBwYXN0ZS9jdXQgZWRpdHMgaW4gcmVhZElucHV0XG4gICAgICBkcmFnZ2luZ1RleHQ6IGZhbHNlLFxuICAgICAgaGlnaGxpZ2h0OiBuZXcgRGVsYXllZCgpIC8vIHN0b3JlcyBoaWdobGlnaHQgd29ya2VyIHRpbWVvdXRcbiAgICB9O1xuXG4gICAgLy8gT3ZlcnJpZGUgbWFnaWMgdGV4dGFyZWEgY29udGVudCByZXN0b3JlIHRoYXQgSUUgc29tZXRpbWVzIGRvZXNcbiAgICAvLyBvbiBvdXIgaGlkZGVuIHRleHRhcmVhIG9uIHJlbG9hZFxuICAgIGlmIChpZV91cHRvMTApIHNldFRpbWVvdXQoYmluZChyZXNldElucHV0LCB0aGlzLCB0cnVlKSwgMjApO1xuXG4gICAgcmVnaXN0ZXJFdmVudEhhbmRsZXJzKHRoaXMpO1xuXG4gICAgdmFyIGNtID0gdGhpcztcbiAgICBydW5Jbk9wKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgY20uY3VyT3AuZm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgYXR0YWNoRG9jKGNtLCBkb2MpO1xuXG4gICAgICBpZiAoKG9wdGlvbnMuYXV0b2ZvY3VzICYmICFtb2JpbGUpIHx8IGFjdGl2ZUVsdCgpID09IGRpc3BsYXkuaW5wdXQpXG4gICAgICAgIHNldFRpbWVvdXQoYmluZChvbkZvY3VzLCBjbSksIDIwKTtcbiAgICAgIGVsc2VcbiAgICAgICAgb25CbHVyKGNtKTtcblxuICAgICAgZm9yICh2YXIgb3B0IGluIG9wdGlvbkhhbmRsZXJzKSBpZiAob3B0aW9uSGFuZGxlcnMuaGFzT3duUHJvcGVydHkob3B0KSlcbiAgICAgICAgb3B0aW9uSGFuZGxlcnNbb3B0XShjbSwgb3B0aW9uc1tvcHRdLCBJbml0KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5pdEhvb2tzLmxlbmd0aDsgKytpKSBpbml0SG9va3NbaV0oY20pO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gRElTUExBWSBDT05TVFJVQ1RPUlxuXG4gIC8vIFRoZSBkaXNwbGF5IGhhbmRsZXMgdGhlIERPTSBpbnRlZ3JhdGlvbiwgYm90aCBmb3IgaW5wdXQgcmVhZGluZ1xuICAvLyBhbmQgY29udGVudCBkcmF3aW5nLiBJdCBob2xkcyByZWZlcmVuY2VzIHRvIERPTSBub2RlcyBhbmRcbiAgLy8gZGlzcGxheS1yZWxhdGVkIHN0YXRlLlxuXG4gIGZ1bmN0aW9uIERpc3BsYXkocGxhY2UsIGRvYykge1xuICAgIHZhciBkID0gdGhpcztcblxuICAgIC8vIFRoZSBzZW1paGlkZGVuIHRleHRhcmVhIHRoYXQgaXMgZm9jdXNlZCB3aGVuIHRoZSBlZGl0b3IgaXNcbiAgICAvLyBmb2N1c2VkLCBhbmQgcmVjZWl2ZXMgaW5wdXQuXG4gICAgdmFyIGlucHV0ID0gZC5pbnB1dCA9IGVsdChcInRleHRhcmVhXCIsIG51bGwsIG51bGwsIFwicG9zaXRpb246IGFic29sdXRlOyBwYWRkaW5nOiAwOyB3aWR0aDogMXB4OyBoZWlnaHQ6IDFlbTsgb3V0bGluZTogbm9uZVwiKTtcbiAgICAvLyBUaGUgdGV4dGFyZWEgaXMga2VwdCBwb3NpdGlvbmVkIG5lYXIgdGhlIGN1cnNvciB0byBwcmV2ZW50IHRoZVxuICAgIC8vIGZhY3QgdGhhdCBpdCdsbCBiZSBzY3JvbGxlZCBpbnRvIHZpZXcgb24gaW5wdXQgZnJvbSBzY3JvbGxpbmdcbiAgICAvLyBvdXIgZmFrZSBjdXJzb3Igb3V0IG9mIHZpZXcuIE9uIHdlYmtpdCwgd2hlbiB3cmFwPW9mZiwgcGFzdGUgaXNcbiAgICAvLyB2ZXJ5IHNsb3cuIFNvIG1ha2UgdGhlIGFyZWEgd2lkZSBpbnN0ZWFkLlxuICAgIGlmICh3ZWJraXQpIGlucHV0LnN0eWxlLndpZHRoID0gXCIxMDAwcHhcIjtcbiAgICBlbHNlIGlucHV0LnNldEF0dHJpYnV0ZShcIndyYXBcIiwgXCJvZmZcIik7XG4gICAgLy8gSWYgYm9yZGVyOiAwOyAtLSBpT1MgZmFpbHMgdG8gb3BlbiBrZXlib2FyZCAoaXNzdWUgIzEyODcpXG4gICAgaWYgKGlvcykgaW5wdXQuc3R5bGUuYm9yZGVyID0gXCIxcHggc29saWQgYmxhY2tcIjtcbiAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoXCJhdXRvY29ycmVjdFwiLCBcIm9mZlwiKTsgaW5wdXQuc2V0QXR0cmlidXRlKFwiYXV0b2NhcGl0YWxpemVcIiwgXCJvZmZcIik7IGlucHV0LnNldEF0dHJpYnV0ZShcInNwZWxsY2hlY2tcIiwgXCJmYWxzZVwiKTtcblxuICAgIC8vIFdyYXBzIGFuZCBoaWRlcyBpbnB1dCB0ZXh0YXJlYVxuICAgIGQuaW5wdXREaXYgPSBlbHQoXCJkaXZcIiwgW2lucHV0XSwgbnVsbCwgXCJvdmVyZmxvdzogaGlkZGVuOyBwb3NpdGlvbjogcmVsYXRpdmU7IHdpZHRoOiAzcHg7IGhlaWdodDogMHB4O1wiKTtcbiAgICAvLyBUaGUgZmFrZSBzY3JvbGxiYXIgZWxlbWVudHMuXG4gICAgZC5zY3JvbGxiYXJIID0gZWx0KFwiZGl2XCIsIFtlbHQoXCJkaXZcIiwgbnVsbCwgbnVsbCwgXCJoZWlnaHQ6IDEwMCU7IG1pbi1oZWlnaHQ6IDFweFwiKV0sIFwiQ29kZU1pcnJvci1oc2Nyb2xsYmFyXCIpO1xuICAgIGQuc2Nyb2xsYmFyViA9IGVsdChcImRpdlwiLCBbZWx0KFwiZGl2XCIsIG51bGwsIG51bGwsIFwibWluLXdpZHRoOiAxcHhcIildLCBcIkNvZGVNaXJyb3ItdnNjcm9sbGJhclwiKTtcbiAgICAvLyBDb3ZlcnMgYm90dG9tLXJpZ2h0IHNxdWFyZSB3aGVuIGJvdGggc2Nyb2xsYmFycyBhcmUgcHJlc2VudC5cbiAgICBkLnNjcm9sbGJhckZpbGxlciA9IGVsdChcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3Itc2Nyb2xsYmFyLWZpbGxlclwiKTtcbiAgICAvLyBDb3ZlcnMgYm90dG9tIG9mIGd1dHRlciB3aGVuIGNvdmVyR3V0dGVyTmV4dFRvU2Nyb2xsYmFyIGlzIG9uXG4gICAgLy8gYW5kIGggc2Nyb2xsYmFyIGlzIHByZXNlbnQuXG4gICAgZC5ndXR0ZXJGaWxsZXIgPSBlbHQoXCJkaXZcIiwgbnVsbCwgXCJDb2RlTWlycm9yLWd1dHRlci1maWxsZXJcIik7XG4gICAgLy8gV2lsbCBjb250YWluIHRoZSBhY3R1YWwgY29kZSwgcG9zaXRpb25lZCB0byBjb3ZlciB0aGUgdmlld3BvcnQuXG4gICAgZC5saW5lRGl2ID0gZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1jb2RlXCIpO1xuICAgIC8vIEVsZW1lbnRzIGFyZSBhZGRlZCB0byB0aGVzZSB0byByZXByZXNlbnQgc2VsZWN0aW9uIGFuZCBjdXJzb3JzLlxuICAgIGQuc2VsZWN0aW9uRGl2ID0gZWx0KFwiZGl2XCIsIG51bGwsIG51bGwsIFwicG9zaXRpb246IHJlbGF0aXZlOyB6LWluZGV4OiAxXCIpO1xuICAgIGQuY3Vyc29yRGl2ID0gZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1jdXJzb3JzXCIpO1xuICAgIC8vIEEgdmlzaWJpbGl0eTogaGlkZGVuIGVsZW1lbnQgdXNlZCB0byBmaW5kIHRoZSBzaXplIG9mIHRoaW5ncy5cbiAgICBkLm1lYXN1cmUgPSBlbHQoXCJkaXZcIiwgbnVsbCwgXCJDb2RlTWlycm9yLW1lYXN1cmVcIik7XG4gICAgLy8gV2hlbiBsaW5lcyBvdXRzaWRlIG9mIHRoZSB2aWV3cG9ydCBhcmUgbWVhc3VyZWQsIHRoZXkgYXJlIGRyYXduIGluIHRoaXMuXG4gICAgZC5saW5lTWVhc3VyZSA9IGVsdChcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3ItbWVhc3VyZVwiKTtcbiAgICAvLyBXcmFwcyBldmVyeXRoaW5nIHRoYXQgbmVlZHMgdG8gZXhpc3QgaW5zaWRlIHRoZSB2ZXJ0aWNhbGx5LXBhZGRlZCBjb29yZGluYXRlIHN5c3RlbVxuICAgIGQubGluZVNwYWNlID0gZWx0KFwiZGl2XCIsIFtkLm1lYXN1cmUsIGQubGluZU1lYXN1cmUsIGQuc2VsZWN0aW9uRGl2LCBkLmN1cnNvckRpdiwgZC5saW5lRGl2XSxcbiAgICAgICAgICAgICAgICAgICAgICBudWxsLCBcInBvc2l0aW9uOiByZWxhdGl2ZTsgb3V0bGluZTogbm9uZVwiKTtcbiAgICAvLyBNb3ZlZCBhcm91bmQgaXRzIHBhcmVudCB0byBjb3ZlciB2aXNpYmxlIHZpZXcuXG4gICAgZC5tb3ZlciA9IGVsdChcImRpdlwiLCBbZWx0KFwiZGl2XCIsIFtkLmxpbmVTcGFjZV0sIFwiQ29kZU1pcnJvci1saW5lc1wiKV0sIG51bGwsIFwicG9zaXRpb246IHJlbGF0aXZlXCIpO1xuICAgIC8vIFNldCB0byB0aGUgaGVpZ2h0IG9mIHRoZSBkb2N1bWVudCwgYWxsb3dpbmcgc2Nyb2xsaW5nLlxuICAgIGQuc2l6ZXIgPSBlbHQoXCJkaXZcIiwgW2QubW92ZXJdLCBcIkNvZGVNaXJyb3Itc2l6ZXJcIik7XG4gICAgLy8gQmVoYXZpb3Igb2YgZWx0cyB3aXRoIG92ZXJmbG93OiBhdXRvIGFuZCBwYWRkaW5nIGlzXG4gICAgLy8gaW5jb25zaXN0ZW50IGFjcm9zcyBicm93c2Vycy4gVGhpcyBpcyB1c2VkIHRvIGVuc3VyZSB0aGVcbiAgICAvLyBzY3JvbGxhYmxlIGFyZWEgaXMgYmlnIGVub3VnaC5cbiAgICBkLmhlaWdodEZvcmNlciA9IGVsdChcImRpdlwiLCBudWxsLCBudWxsLCBcInBvc2l0aW9uOiBhYnNvbHV0ZTsgaGVpZ2h0OiBcIiArIHNjcm9sbGVyQ3V0T2ZmICsgXCJweDsgd2lkdGg6IDFweDtcIik7XG4gICAgLy8gV2lsbCBjb250YWluIHRoZSBndXR0ZXJzLCBpZiBhbnkuXG4gICAgZC5ndXR0ZXJzID0gZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1ndXR0ZXJzXCIpO1xuICAgIGQubGluZUd1dHRlciA9IG51bGw7XG4gICAgLy8gQWN0dWFsIHNjcm9sbGFibGUgZWxlbWVudC5cbiAgICBkLnNjcm9sbGVyID0gZWx0KFwiZGl2XCIsIFtkLnNpemVyLCBkLmhlaWdodEZvcmNlciwgZC5ndXR0ZXJzXSwgXCJDb2RlTWlycm9yLXNjcm9sbFwiKTtcbiAgICBkLnNjcm9sbGVyLnNldEF0dHJpYnV0ZShcInRhYkluZGV4XCIsIFwiLTFcIik7XG4gICAgLy8gVGhlIGVsZW1lbnQgaW4gd2hpY2ggdGhlIGVkaXRvciBsaXZlcy5cbiAgICBkLndyYXBwZXIgPSBlbHQoXCJkaXZcIiwgW2QuaW5wdXREaXYsIGQuc2Nyb2xsYmFySCwgZC5zY3JvbGxiYXJWLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQuc2Nyb2xsYmFyRmlsbGVyLCBkLmd1dHRlckZpbGxlciwgZC5zY3JvbGxlcl0sIFwiQ29kZU1pcnJvclwiKTtcblxuICAgIC8vIFdvcmsgYXJvdW5kIElFNyB6LWluZGV4IGJ1ZyAobm90IHBlcmZlY3QsIGhlbmNlIElFNyBub3QgcmVhbGx5IGJlaW5nIHN1cHBvcnRlZClcbiAgICBpZiAoaWVfdXB0bzcpIHsgZC5ndXR0ZXJzLnN0eWxlLnpJbmRleCA9IC0xOyBkLnNjcm9sbGVyLnN0eWxlLnBhZGRpbmdSaWdodCA9IDA7IH1cbiAgICAvLyBOZWVkZWQgdG8gaGlkZSBiaWcgYmx1ZSBibGlua2luZyBjdXJzb3Igb24gTW9iaWxlIFNhZmFyaVxuICAgIGlmIChpb3MpIGlucHV0LnN0eWxlLndpZHRoID0gXCIwcHhcIjtcbiAgICBpZiAoIXdlYmtpdCkgZC5zY3JvbGxlci5kcmFnZ2FibGUgPSB0cnVlO1xuICAgIC8vIE5lZWRlZCB0byBoYW5kbGUgVGFiIGtleSBpbiBLSFRNTFxuICAgIGlmIChraHRtbCkgeyBkLmlucHV0RGl2LnN0eWxlLmhlaWdodCA9IFwiMXB4XCI7IGQuaW5wdXREaXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7IH1cbiAgICAvLyBOZWVkIHRvIHNldCBhIG1pbmltdW0gd2lkdGggdG8gc2VlIHRoZSBzY3JvbGxiYXIgb24gSUU3IChidXQgbXVzdCBub3Qgc2V0IGl0IG9uIElFOCkuXG4gICAgaWYgKGllX3VwdG83KSBkLnNjcm9sbGJhckguc3R5bGUubWluSGVpZ2h0ID0gZC5zY3JvbGxiYXJWLnN0eWxlLm1pbldpZHRoID0gXCIxOHB4XCI7XG5cbiAgICBpZiAocGxhY2UuYXBwZW5kQ2hpbGQpIHBsYWNlLmFwcGVuZENoaWxkKGQud3JhcHBlcik7XG4gICAgZWxzZSBwbGFjZShkLndyYXBwZXIpO1xuXG4gICAgLy8gQ3VycmVudCByZW5kZXJlZCByYW5nZSAobWF5IGJlIGJpZ2dlciB0aGFuIHRoZSB2aWV3IHdpbmRvdykuXG4gICAgZC52aWV3RnJvbSA9IGQudmlld1RvID0gZG9jLmZpcnN0O1xuICAgIC8vIEluZm9ybWF0aW9uIGFib3V0IHRoZSByZW5kZXJlZCBsaW5lcy5cbiAgICBkLnZpZXcgPSBbXTtcbiAgICAvLyBIb2xkcyBpbmZvIGFib3V0IGEgc2luZ2xlIHJlbmRlcmVkIGxpbmUgd2hlbiBpdCB3YXMgcmVuZGVyZWRcbiAgICAvLyBmb3IgbWVhc3VyZW1lbnQsIHdoaWxlIG5vdCBpbiB2aWV3LlxuICAgIGQuZXh0ZXJuYWxNZWFzdXJlZCA9IG51bGw7XG4gICAgLy8gRW1wdHkgc3BhY2UgKGluIHBpeGVscykgYWJvdmUgdGhlIHZpZXdcbiAgICBkLnZpZXdPZmZzZXQgPSAwO1xuICAgIGQubGFzdFNpemVDID0gMDtcbiAgICBkLnVwZGF0ZUxpbmVOdW1iZXJzID0gbnVsbDtcblxuICAgIC8vIFVzZWQgdG8gb25seSByZXNpemUgdGhlIGxpbmUgbnVtYmVyIGd1dHRlciB3aGVuIG5lY2Vzc2FyeSAod2hlblxuICAgIC8vIHRoZSBhbW91bnQgb2YgbGluZXMgY3Jvc3NlcyBhIGJvdW5kYXJ5IHRoYXQgbWFrZXMgaXRzIHdpZHRoIGNoYW5nZSlcbiAgICBkLmxpbmVOdW1XaWR0aCA9IGQubGluZU51bUlubmVyV2lkdGggPSBkLmxpbmVOdW1DaGFycyA9IG51bGw7XG4gICAgLy8gU2VlIHJlYWRJbnB1dCBhbmQgcmVzZXRJbnB1dFxuICAgIGQucHJldklucHV0ID0gXCJcIjtcbiAgICAvLyBTZXQgdG8gdHJ1ZSB3aGVuIGEgbm9uLWhvcml6b250YWwtc2Nyb2xsaW5nIGxpbmUgd2lkZ2V0IGlzXG4gICAgLy8gYWRkZWQuIEFzIGFuIG9wdGltaXphdGlvbiwgbGluZSB3aWRnZXQgYWxpZ25pbmcgaXMgc2tpcHBlZCB3aGVuXG4gICAgLy8gdGhpcyBpcyBmYWxzZS5cbiAgICBkLmFsaWduV2lkZ2V0cyA9IGZhbHNlO1xuICAgIC8vIEZsYWcgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB3ZSBleHBlY3QgaW5wdXQgdG8gYXBwZWFyIHJlYWwgc29vblxuICAgIC8vIG5vdyAoYWZ0ZXIgc29tZSBldmVudCBsaWtlICdrZXlwcmVzcycgb3IgJ2lucHV0JykgYW5kIGFyZVxuICAgIC8vIHBvbGxpbmcgaW50ZW5zaXZlbHkuXG4gICAgZC5wb2xsaW5nRmFzdCA9IGZhbHNlO1xuICAgIC8vIFNlbGYtcmVzZXR0aW5nIHRpbWVvdXQgZm9yIHRoZSBwb2xsZXJcbiAgICBkLnBvbGwgPSBuZXcgRGVsYXllZCgpO1xuXG4gICAgZC5jYWNoZWRDaGFyV2lkdGggPSBkLmNhY2hlZFRleHRIZWlnaHQgPSBkLmNhY2hlZFBhZGRpbmdIID0gbnVsbDtcblxuICAgIC8vIFRyYWNrcyB3aGVuIHJlc2V0SW5wdXQgaGFzIHB1bnRlZCB0byBqdXN0IHB1dHRpbmcgYSBzaG9ydFxuICAgIC8vIHN0cmluZyBpbnRvIHRoZSB0ZXh0YXJlYSBpbnN0ZWFkIG9mIHRoZSBmdWxsIHNlbGVjdGlvbi5cbiAgICBkLmluYWNjdXJhdGVTZWxlY3Rpb24gPSBmYWxzZTtcblxuICAgIC8vIFRyYWNrcyB0aGUgbWF4aW11bSBsaW5lIGxlbmd0aCBzbyB0aGF0IHRoZSBob3Jpem9udGFsIHNjcm9sbGJhclxuICAgIC8vIGNhbiBiZSBrZXB0IHN0YXRpYyB3aGVuIHNjcm9sbGluZy5cbiAgICBkLm1heExpbmUgPSBudWxsO1xuICAgIGQubWF4TGluZUxlbmd0aCA9IDA7XG4gICAgZC5tYXhMaW5lQ2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgLy8gVXNlZCBmb3IgbWVhc3VyaW5nIHdoZWVsIHNjcm9sbGluZyBncmFudWxhcml0eVxuICAgIGQud2hlZWxEWCA9IGQud2hlZWxEWSA9IGQud2hlZWxTdGFydFggPSBkLndoZWVsU3RhcnRZID0gbnVsbDtcblxuICAgIC8vIFRydWUgd2hlbiBzaGlmdCBpcyBoZWxkIGRvd24uXG4gICAgZC5zaGlmdCA9IGZhbHNlO1xuICB9XG5cbiAgLy8gU1RBVEUgVVBEQVRFU1xuXG4gIC8vIFVzZWQgdG8gZ2V0IHRoZSBlZGl0b3IgaW50byBhIGNvbnNpc3RlbnQgc3RhdGUgYWdhaW4gd2hlbiBvcHRpb25zIGNoYW5nZS5cblxuICBmdW5jdGlvbiBsb2FkTW9kZShjbSkge1xuICAgIGNtLmRvYy5tb2RlID0gQ29kZU1pcnJvci5nZXRNb2RlKGNtLm9wdGlvbnMsIGNtLmRvYy5tb2RlT3B0aW9uKTtcbiAgICByZXNldE1vZGVTdGF0ZShjbSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldE1vZGVTdGF0ZShjbSkge1xuICAgIGNtLmRvYy5pdGVyKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIGlmIChsaW5lLnN0YXRlQWZ0ZXIpIGxpbmUuc3RhdGVBZnRlciA9IG51bGw7XG4gICAgICBpZiAobGluZS5zdHlsZXMpIGxpbmUuc3R5bGVzID0gbnVsbDtcbiAgICB9KTtcbiAgICBjbS5kb2MuZnJvbnRpZXIgPSBjbS5kb2MuZmlyc3Q7XG4gICAgc3RhcnRXb3JrZXIoY20sIDEwMCk7XG4gICAgY20uc3RhdGUubW9kZUdlbisrO1xuICAgIGlmIChjbS5jdXJPcCkgcmVnQ2hhbmdlKGNtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXBwaW5nQ2hhbmdlZChjbSkge1xuICAgIGlmIChjbS5vcHRpb25zLmxpbmVXcmFwcGluZykge1xuICAgICAgYWRkQ2xhc3MoY20uZGlzcGxheS53cmFwcGVyLCBcIkNvZGVNaXJyb3Itd3JhcFwiKTtcbiAgICAgIGNtLmRpc3BsYXkuc2l6ZXIuc3R5bGUubWluV2lkdGggPSBcIlwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBybUNsYXNzKGNtLmRpc3BsYXkud3JhcHBlciwgXCJDb2RlTWlycm9yLXdyYXBcIik7XG4gICAgICBmaW5kTWF4TGluZShjbSk7XG4gICAgfVxuICAgIGVzdGltYXRlTGluZUhlaWdodHMoY20pO1xuICAgIHJlZ0NoYW5nZShjbSk7XG4gICAgY2xlYXJDYWNoZXMoY20pO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXt1cGRhdGVTY3JvbGxiYXJzKGNtKTt9LCAxMDApO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgZXN0aW1hdGVzIHRoZSBoZWlnaHQgb2YgYSBsaW5lLCB0byB1c2UgYXNcbiAgLy8gZmlyc3QgYXBwcm94aW1hdGlvbiB1bnRpbCB0aGUgbGluZSBiZWNvbWVzIHZpc2libGUgKGFuZCBpcyB0aHVzXG4gIC8vIHByb3Blcmx5IG1lYXN1cmFibGUpLlxuICBmdW5jdGlvbiBlc3RpbWF0ZUhlaWdodChjbSkge1xuICAgIHZhciB0aCA9IHRleHRIZWlnaHQoY20uZGlzcGxheSksIHdyYXBwaW5nID0gY20ub3B0aW9ucy5saW5lV3JhcHBpbmc7XG4gICAgdmFyIHBlckxpbmUgPSB3cmFwcGluZyAmJiBNYXRoLm1heCg1LCBjbS5kaXNwbGF5LnNjcm9sbGVyLmNsaWVudFdpZHRoIC8gY2hhcldpZHRoKGNtLmRpc3BsYXkpIC0gMyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIGlmIChsaW5lSXNIaWRkZW4oY20uZG9jLCBsaW5lKSkgcmV0dXJuIDA7XG5cbiAgICAgIHZhciB3aWRnZXRzSGVpZ2h0ID0gMDtcbiAgICAgIGlmIChsaW5lLndpZGdldHMpIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS53aWRnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChsaW5lLndpZGdldHNbaV0uaGVpZ2h0KSB3aWRnZXRzSGVpZ2h0ICs9IGxpbmUud2lkZ2V0c1tpXS5oZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh3cmFwcGluZylcbiAgICAgICAgcmV0dXJuIHdpZGdldHNIZWlnaHQgKyAoTWF0aC5jZWlsKGxpbmUudGV4dC5sZW5ndGggLyBwZXJMaW5lKSB8fCAxKSAqIHRoO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gd2lkZ2V0c0hlaWdodCArIHRoO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBlc3RpbWF0ZUxpbmVIZWlnaHRzKGNtKSB7XG4gICAgdmFyIGRvYyA9IGNtLmRvYywgZXN0ID0gZXN0aW1hdGVIZWlnaHQoY20pO1xuICAgIGRvYy5pdGVyKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHZhciBlc3RIZWlnaHQgPSBlc3QobGluZSk7XG4gICAgICBpZiAoZXN0SGVpZ2h0ICE9IGxpbmUuaGVpZ2h0KSB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIGVzdEhlaWdodCk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBrZXlNYXBDaGFuZ2VkKGNtKSB7XG4gICAgdmFyIG1hcCA9IGtleU1hcFtjbS5vcHRpb25zLmtleU1hcF0sIHN0eWxlID0gbWFwLnN0eWxlO1xuICAgIGNtLmRpc3BsYXkud3JhcHBlci5jbGFzc05hbWUgPSBjbS5kaXNwbGF5LndyYXBwZXIuY2xhc3NOYW1lLnJlcGxhY2UoL1xccypjbS1rZXltYXAtXFxTKy9nLCBcIlwiKSArXG4gICAgICAoc3R5bGUgPyBcIiBjbS1rZXltYXAtXCIgKyBzdHlsZSA6IFwiXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGhlbWVDaGFuZ2VkKGNtKSB7XG4gICAgY20uZGlzcGxheS53cmFwcGVyLmNsYXNzTmFtZSA9IGNtLmRpc3BsYXkud3JhcHBlci5jbGFzc05hbWUucmVwbGFjZSgvXFxzKmNtLXMtXFxTKy9nLCBcIlwiKSArXG4gICAgICBjbS5vcHRpb25zLnRoZW1lLnJlcGxhY2UoLyhefFxccylcXHMqL2csIFwiIGNtLXMtXCIpO1xuICAgIGNsZWFyQ2FjaGVzKGNtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGd1dHRlcnNDaGFuZ2VkKGNtKSB7XG4gICAgdXBkYXRlR3V0dGVycyhjbSk7XG4gICAgcmVnQ2hhbmdlKGNtKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YWxpZ25Ib3Jpem9udGFsbHkoY20pO30sIDIwKTtcbiAgfVxuXG4gIC8vIFJlYnVpbGQgdGhlIGd1dHRlciBlbGVtZW50cywgZW5zdXJlIHRoZSBtYXJnaW4gdG8gdGhlIGxlZnQgb2YgdGhlXG4gIC8vIGNvZGUgbWF0Y2hlcyB0aGVpciB3aWR0aC5cbiAgZnVuY3Rpb24gdXBkYXRlR3V0dGVycyhjbSkge1xuICAgIHZhciBndXR0ZXJzID0gY20uZGlzcGxheS5ndXR0ZXJzLCBzcGVjcyA9IGNtLm9wdGlvbnMuZ3V0dGVycztcbiAgICByZW1vdmVDaGlsZHJlbihndXR0ZXJzKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwZWNzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgZ3V0dGVyQ2xhc3MgPSBzcGVjc1tpXTtcbiAgICAgIHZhciBnRWx0ID0gZ3V0dGVycy5hcHBlbmRDaGlsZChlbHQoXCJkaXZcIiwgbnVsbCwgXCJDb2RlTWlycm9yLWd1dHRlciBcIiArIGd1dHRlckNsYXNzKSk7XG4gICAgICBpZiAoZ3V0dGVyQ2xhc3MgPT0gXCJDb2RlTWlycm9yLWxpbmVudW1iZXJzXCIpIHtcbiAgICAgICAgY20uZGlzcGxheS5saW5lR3V0dGVyID0gZ0VsdDtcbiAgICAgICAgZ0VsdC5zdHlsZS53aWR0aCA9IChjbS5kaXNwbGF5LmxpbmVOdW1XaWR0aCB8fCAxKSArIFwicHhcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ3V0dGVycy5zdHlsZS5kaXNwbGF5ID0gaSA/IFwiXCIgOiBcIm5vbmVcIjtcbiAgICB1cGRhdGVHdXR0ZXJTcGFjZShjbSk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVHdXR0ZXJTcGFjZShjbSkge1xuICAgIHZhciB3aWR0aCA9IGNtLmRpc3BsYXkuZ3V0dGVycy5vZmZzZXRXaWR0aDtcbiAgICBjbS5kaXNwbGF5LnNpemVyLnN0eWxlLm1hcmdpbkxlZnQgPSB3aWR0aCArIFwicHhcIjtcbiAgICBjbS5kaXNwbGF5LnNjcm9sbGJhckguc3R5bGUubGVmdCA9IGNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIgPyB3aWR0aCArIFwicHhcIiA6IDA7XG4gIH1cblxuICAvLyBDb21wdXRlIHRoZSBjaGFyYWN0ZXIgbGVuZ3RoIG9mIGEgbGluZSwgdGFraW5nIGludG8gYWNjb3VudFxuICAvLyBjb2xsYXBzZWQgcmFuZ2VzIChzZWUgbWFya1RleHQpIHRoYXQgbWlnaHQgaGlkZSBwYXJ0cywgYW5kIGpvaW5cbiAgLy8gb3RoZXIgbGluZXMgb250byBpdC5cbiAgZnVuY3Rpb24gbGluZUxlbmd0aChsaW5lKSB7XG4gICAgaWYgKGxpbmUuaGVpZ2h0ID09IDApIHJldHVybiAwO1xuICAgIHZhciBsZW4gPSBsaW5lLnRleHQubGVuZ3RoLCBtZXJnZWQsIGN1ciA9IGxpbmU7XG4gICAgd2hpbGUgKG1lcmdlZCA9IGNvbGxhcHNlZFNwYW5BdFN0YXJ0KGN1cikpIHtcbiAgICAgIHZhciBmb3VuZCA9IG1lcmdlZC5maW5kKDAsIHRydWUpO1xuICAgICAgY3VyID0gZm91bmQuZnJvbS5saW5lO1xuICAgICAgbGVuICs9IGZvdW5kLmZyb20uY2ggLSBmb3VuZC50by5jaDtcbiAgICB9XG4gICAgY3VyID0gbGluZTtcbiAgICB3aGlsZSAobWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0RW5kKGN1cikpIHtcbiAgICAgIHZhciBmb3VuZCA9IG1lcmdlZC5maW5kKDAsIHRydWUpO1xuICAgICAgbGVuIC09IGN1ci50ZXh0Lmxlbmd0aCAtIGZvdW5kLmZyb20uY2g7XG4gICAgICBjdXIgPSBmb3VuZC50by5saW5lO1xuICAgICAgbGVuICs9IGN1ci50ZXh0Lmxlbmd0aCAtIGZvdW5kLnRvLmNoO1xuICAgIH1cbiAgICByZXR1cm4gbGVuO1xuICB9XG5cbiAgLy8gRmluZCB0aGUgbG9uZ2VzdCBsaW5lIGluIHRoZSBkb2N1bWVudC5cbiAgZnVuY3Rpb24gZmluZE1heExpbmUoY20pIHtcbiAgICB2YXIgZCA9IGNtLmRpc3BsYXksIGRvYyA9IGNtLmRvYztcbiAgICBkLm1heExpbmUgPSBnZXRMaW5lKGRvYywgZG9jLmZpcnN0KTtcbiAgICBkLm1heExpbmVMZW5ndGggPSBsaW5lTGVuZ3RoKGQubWF4TGluZSk7XG4gICAgZC5tYXhMaW5lQ2hhbmdlZCA9IHRydWU7XG4gICAgZG9jLml0ZXIoZnVuY3Rpb24obGluZSkge1xuICAgICAgdmFyIGxlbiA9IGxpbmVMZW5ndGgobGluZSk7XG4gICAgICBpZiAobGVuID4gZC5tYXhMaW5lTGVuZ3RoKSB7XG4gICAgICAgIGQubWF4TGluZUxlbmd0aCA9IGxlbjtcbiAgICAgICAgZC5tYXhMaW5lID0gbGluZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSB0aGUgZ3V0dGVycyBvcHRpb25zIGNvbnRhaW5zIHRoZSBlbGVtZW50XG4gIC8vIFwiQ29kZU1pcnJvci1saW5lbnVtYmVyc1wiIHdoZW4gdGhlIGxpbmVOdW1iZXJzIG9wdGlvbiBpcyB0cnVlLlxuICBmdW5jdGlvbiBzZXRHdXR0ZXJzRm9yTGluZU51bWJlcnMob3B0aW9ucykge1xuICAgIHZhciBmb3VuZCA9IGluZGV4T2Yob3B0aW9ucy5ndXR0ZXJzLCBcIkNvZGVNaXJyb3ItbGluZW51bWJlcnNcIik7XG4gICAgaWYgKGZvdW5kID09IC0xICYmIG9wdGlvbnMubGluZU51bWJlcnMpIHtcbiAgICAgIG9wdGlvbnMuZ3V0dGVycyA9IG9wdGlvbnMuZ3V0dGVycy5jb25jYXQoW1wiQ29kZU1pcnJvci1saW5lbnVtYmVyc1wiXSk7XG4gICAgfSBlbHNlIGlmIChmb3VuZCA+IC0xICYmICFvcHRpb25zLmxpbmVOdW1iZXJzKSB7XG4gICAgICBvcHRpb25zLmd1dHRlcnMgPSBvcHRpb25zLmd1dHRlcnMuc2xpY2UoMCk7XG4gICAgICBvcHRpb25zLmd1dHRlcnMuc3BsaWNlKGZvdW5kLCAxKTtcbiAgICB9XG4gIH1cblxuICAvLyBTQ1JPTExCQVJTXG5cbiAgLy8gUHJlcGFyZSBET00gcmVhZHMgbmVlZGVkIHRvIHVwZGF0ZSB0aGUgc2Nyb2xsYmFycy4gRG9uZSBpbiBvbmVcbiAgLy8gc2hvdCB0byBtaW5pbWl6ZSB1cGRhdGUvbWVhc3VyZSByb3VuZHRyaXBzLlxuICBmdW5jdGlvbiBtZWFzdXJlRm9yU2Nyb2xsYmFycyhjbSkge1xuICAgIHZhciBzY3JvbGwgPSBjbS5kaXNwbGF5LnNjcm9sbGVyO1xuICAgIHJldHVybiB7XG4gICAgICBjbGllbnRIZWlnaHQ6IHNjcm9sbC5jbGllbnRIZWlnaHQsXG4gICAgICBiYXJIZWlnaHQ6IGNtLmRpc3BsYXkuc2Nyb2xsYmFyVi5jbGllbnRIZWlnaHQsXG4gICAgICBzY3JvbGxXaWR0aDogc2Nyb2xsLnNjcm9sbFdpZHRoLCBjbGllbnRXaWR0aDogc2Nyb2xsLmNsaWVudFdpZHRoLFxuICAgICAgYmFyV2lkdGg6IGNtLmRpc3BsYXkuc2Nyb2xsYmFySC5jbGllbnRXaWR0aCxcbiAgICAgIGRvY0hlaWdodDogTWF0aC5yb3VuZChjbS5kb2MuaGVpZ2h0ICsgcGFkZGluZ1ZlcnQoY20uZGlzcGxheSkpXG4gICAgfTtcbiAgfVxuXG4gIC8vIFJlLXN5bmNocm9uaXplIHRoZSBmYWtlIHNjcm9sbGJhcnMgd2l0aCB0aGUgYWN0dWFsIHNpemUgb2YgdGhlXG4gIC8vIGNvbnRlbnQuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNjcm9sbGJhcnMoY20sIG1lYXN1cmUpIHtcbiAgICBpZiAoIW1lYXN1cmUpIG1lYXN1cmUgPSBtZWFzdXJlRm9yU2Nyb2xsYmFycyhjbSk7XG4gICAgdmFyIGQgPSBjbS5kaXNwbGF5O1xuICAgIHZhciBzY3JvbGxIZWlnaHQgPSBtZWFzdXJlLmRvY0hlaWdodCArIHNjcm9sbGVyQ3V0T2ZmO1xuICAgIHZhciBuZWVkc0ggPSBtZWFzdXJlLnNjcm9sbFdpZHRoID4gbWVhc3VyZS5jbGllbnRXaWR0aDtcbiAgICB2YXIgbmVlZHNWID0gc2Nyb2xsSGVpZ2h0ID4gbWVhc3VyZS5jbGllbnRIZWlnaHQ7XG4gICAgaWYgKG5lZWRzVikge1xuICAgICAgZC5zY3JvbGxiYXJWLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICBkLnNjcm9sbGJhclYuc3R5bGUuYm90dG9tID0gbmVlZHNIID8gc2Nyb2xsYmFyV2lkdGgoZC5tZWFzdXJlKSArIFwicHhcIiA6IFwiMFwiO1xuICAgICAgLy8gQSBidWcgaW4gSUU4IGNhbiBjYXVzZSB0aGlzIHZhbHVlIHRvIGJlIG5lZ2F0aXZlLCBzbyBndWFyZCBpdC5cbiAgICAgIGQuc2Nyb2xsYmFyVi5maXJzdENoaWxkLnN0eWxlLmhlaWdodCA9XG4gICAgICAgIE1hdGgubWF4KDAsIHNjcm9sbEhlaWdodCAtIG1lYXN1cmUuY2xpZW50SGVpZ2h0ICsgKG1lYXN1cmUuYmFySGVpZ2h0IHx8IGQuc2Nyb2xsYmFyVi5jbGllbnRIZWlnaHQpKSArIFwicHhcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgZC5zY3JvbGxiYXJWLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgICAgZC5zY3JvbGxiYXJWLmZpcnN0Q2hpbGQuc3R5bGUuaGVpZ2h0ID0gXCIwXCI7XG4gICAgfVxuICAgIGlmIChuZWVkc0gpIHtcbiAgICAgIGQuc2Nyb2xsYmFySC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgZC5zY3JvbGxiYXJILnN0eWxlLnJpZ2h0ID0gbmVlZHNWID8gc2Nyb2xsYmFyV2lkdGgoZC5tZWFzdXJlKSArIFwicHhcIiA6IFwiMFwiO1xuICAgICAgZC5zY3JvbGxiYXJILmZpcnN0Q2hpbGQuc3R5bGUud2lkdGggPVxuICAgICAgICAobWVhc3VyZS5zY3JvbGxXaWR0aCAtIG1lYXN1cmUuY2xpZW50V2lkdGggKyAobWVhc3VyZS5iYXJXaWR0aCB8fCBkLnNjcm9sbGJhckguY2xpZW50V2lkdGgpKSArIFwicHhcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgZC5zY3JvbGxiYXJILnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgICAgZC5zY3JvbGxiYXJILmZpcnN0Q2hpbGQuc3R5bGUud2lkdGggPSBcIjBcIjtcbiAgICB9XG4gICAgaWYgKG5lZWRzSCAmJiBuZWVkc1YpIHtcbiAgICAgIGQuc2Nyb2xsYmFyRmlsbGVyLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICBkLnNjcm9sbGJhckZpbGxlci5zdHlsZS5oZWlnaHQgPSBkLnNjcm9sbGJhckZpbGxlci5zdHlsZS53aWR0aCA9IHNjcm9sbGJhcldpZHRoKGQubWVhc3VyZSkgKyBcInB4XCI7XG4gICAgfSBlbHNlIGQuc2Nyb2xsYmFyRmlsbGVyLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgIGlmIChuZWVkc0ggJiYgY20ub3B0aW9ucy5jb3Zlckd1dHRlck5leHRUb1Njcm9sbGJhciAmJiBjbS5vcHRpb25zLmZpeGVkR3V0dGVyKSB7XG4gICAgICBkLmd1dHRlckZpbGxlci5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgZC5ndXR0ZXJGaWxsZXIuc3R5bGUuaGVpZ2h0ID0gc2Nyb2xsYmFyV2lkdGgoZC5tZWFzdXJlKSArIFwicHhcIjtcbiAgICAgIGQuZ3V0dGVyRmlsbGVyLnN0eWxlLndpZHRoID0gZC5ndXR0ZXJzLm9mZnNldFdpZHRoICsgXCJweFwiO1xuICAgIH0gZWxzZSBkLmd1dHRlckZpbGxlci5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblxuICAgIGlmICghY20uc3RhdGUuY2hlY2tlZE92ZXJsYXlTY3JvbGxiYXIgJiYgbWVhc3VyZS5jbGllbnRIZWlnaHQgPiAwKSB7XG4gICAgICBpZiAoc2Nyb2xsYmFyV2lkdGgoZC5tZWFzdXJlKSA9PT0gMCkge1xuICAgICAgICB2YXIgdyA9IG1hYyAmJiAhbWFjX2dlTW91bnRhaW5MaW9uID8gXCIxMnB4XCIgOiBcIjE4cHhcIjtcbiAgICAgICAgZC5zY3JvbGxiYXJWLnN0eWxlLm1pbldpZHRoID0gZC5zY3JvbGxiYXJILnN0eWxlLm1pbkhlaWdodCA9IHc7XG4gICAgICAgIHZhciBiYXJNb3VzZURvd24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgaWYgKGVfdGFyZ2V0KGUpICE9IGQuc2Nyb2xsYmFyViAmJiBlX3RhcmdldChlKSAhPSBkLnNjcm9sbGJhckgpXG4gICAgICAgICAgICBvcGVyYXRpb24oY20sIG9uTW91c2VEb3duKShlKTtcbiAgICAgICAgfTtcbiAgICAgICAgb24oZC5zY3JvbGxiYXJWLCBcIm1vdXNlZG93blwiLCBiYXJNb3VzZURvd24pO1xuICAgICAgICBvbihkLnNjcm9sbGJhckgsIFwibW91c2Vkb3duXCIsIGJhck1vdXNlRG93bik7XG4gICAgICB9XG4gICAgICBjbS5zdGF0ZS5jaGVja2VkT3ZlcmxheVNjcm9sbGJhciA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gQ29tcHV0ZSB0aGUgbGluZXMgdGhhdCBhcmUgdmlzaWJsZSBpbiBhIGdpdmVuIHZpZXdwb3J0IChkZWZhdWx0c1xuICAvLyB0aGUgdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uKS4gdmlld1BvcnQgbWF5IGNvbnRhaW4gdG9wLFxuICAvLyBoZWlnaHQsIGFuZCBlbnN1cmUgKHNlZSBvcC5zY3JvbGxUb1BvcykgcHJvcGVydGllcy5cbiAgZnVuY3Rpb24gdmlzaWJsZUxpbmVzKGRpc3BsYXksIGRvYywgdmlld1BvcnQpIHtcbiAgICB2YXIgdG9wID0gdmlld1BvcnQgJiYgdmlld1BvcnQudG9wICE9IG51bGwgPyB2aWV3UG9ydC50b3AgOiBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcDtcbiAgICB0b3AgPSBNYXRoLmZsb29yKHRvcCAtIHBhZGRpbmdUb3AoZGlzcGxheSkpO1xuICAgIHZhciBib3R0b20gPSB2aWV3UG9ydCAmJiB2aWV3UG9ydC5ib3R0b20gIT0gbnVsbCA/IHZpZXdQb3J0LmJvdHRvbSA6IHRvcCArIGRpc3BsYXkud3JhcHBlci5jbGllbnRIZWlnaHQ7XG5cbiAgICB2YXIgZnJvbSA9IGxpbmVBdEhlaWdodChkb2MsIHRvcCksIHRvID0gbGluZUF0SGVpZ2h0KGRvYywgYm90dG9tKTtcbiAgICAvLyBFbnN1cmUgaXMgYSB7ZnJvbToge2xpbmUsIGNofSwgdG86IHtsaW5lLCBjaH19IG9iamVjdCwgYW5kXG4gICAgLy8gZm9yY2VzIHRob3NlIGxpbmVzIGludG8gdGhlIHZpZXdwb3J0IChpZiBwb3NzaWJsZSkuXG4gICAgaWYgKHZpZXdQb3J0ICYmIHZpZXdQb3J0LmVuc3VyZSkge1xuICAgICAgdmFyIGVuc3VyZUZyb20gPSB2aWV3UG9ydC5lbnN1cmUuZnJvbS5saW5lLCBlbnN1cmVUbyA9IHZpZXdQb3J0LmVuc3VyZS50by5saW5lO1xuICAgICAgaWYgKGVuc3VyZUZyb20gPCBmcm9tKVxuICAgICAgICByZXR1cm4ge2Zyb206IGVuc3VyZUZyb20sXG4gICAgICAgICAgICAgICAgdG86IGxpbmVBdEhlaWdodChkb2MsIGhlaWdodEF0TGluZShnZXRMaW5lKGRvYywgZW5zdXJlRnJvbSkpICsgZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodCl9O1xuICAgICAgaWYgKE1hdGgubWluKGVuc3VyZVRvLCBkb2MubGFzdExpbmUoKSkgPj0gdG8pXG4gICAgICAgIHJldHVybiB7ZnJvbTogbGluZUF0SGVpZ2h0KGRvYywgaGVpZ2h0QXRMaW5lKGdldExpbmUoZG9jLCBlbnN1cmVUbykpIC0gZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodCksXG4gICAgICAgICAgICAgICAgdG86IGVuc3VyZVRvfTtcbiAgICB9XG4gICAgcmV0dXJuIHtmcm9tOiBmcm9tLCB0bzogdG99O1xuICB9XG5cbiAgLy8gTElORSBOVU1CRVJTXG5cbiAgLy8gUmUtYWxpZ24gbGluZSBudW1iZXJzIGFuZCBndXR0ZXIgbWFya3MgdG8gY29tcGVuc2F0ZSBmb3JcbiAgLy8gaG9yaXpvbnRhbCBzY3JvbGxpbmcuXG4gIGZ1bmN0aW9uIGFsaWduSG9yaXpvbnRhbGx5KGNtKSB7XG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCB2aWV3ID0gZGlzcGxheS52aWV3O1xuICAgIGlmICghZGlzcGxheS5hbGlnbldpZGdldHMgJiYgKCFkaXNwbGF5Lmd1dHRlcnMuZmlyc3RDaGlsZCB8fCAhY20ub3B0aW9ucy5maXhlZEd1dHRlcikpIHJldHVybjtcbiAgICB2YXIgY29tcCA9IGNvbXBlbnNhdGVGb3JIU2Nyb2xsKGRpc3BsYXkpIC0gZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0ICsgY20uZG9jLnNjcm9sbExlZnQ7XG4gICAgdmFyIGd1dHRlclcgPSBkaXNwbGF5Lmd1dHRlcnMub2Zmc2V0V2lkdGgsIGxlZnQgPSBjb21wICsgXCJweFwiO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykgaWYgKCF2aWV3W2ldLmhpZGRlbikge1xuICAgICAgaWYgKGNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIgJiYgdmlld1tpXS5ndXR0ZXIpXG4gICAgICAgIHZpZXdbaV0uZ3V0dGVyLnN0eWxlLmxlZnQgPSBsZWZ0O1xuICAgICAgdmFyIGFsaWduID0gdmlld1tpXS5hbGlnbmFibGU7XG4gICAgICBpZiAoYWxpZ24pIGZvciAodmFyIGogPSAwOyBqIDwgYWxpZ24ubGVuZ3RoOyBqKyspXG4gICAgICAgIGFsaWduW2pdLnN0eWxlLmxlZnQgPSBsZWZ0O1xuICAgIH1cbiAgICBpZiAoY20ub3B0aW9ucy5maXhlZEd1dHRlcilcbiAgICAgIGRpc3BsYXkuZ3V0dGVycy5zdHlsZS5sZWZ0ID0gKGNvbXAgKyBndXR0ZXJXKSArIFwicHhcIjtcbiAgfVxuXG4gIC8vIFVzZWQgdG8gZW5zdXJlIHRoYXQgdGhlIGxpbmUgbnVtYmVyIGd1dHRlciBpcyBzdGlsbCB0aGUgcmlnaHRcbiAgLy8gc2l6ZSBmb3IgdGhlIGN1cnJlbnQgZG9jdW1lbnQgc2l6ZS4gUmV0dXJucyB0cnVlIHdoZW4gYW4gdXBkYXRlXG4gIC8vIGlzIG5lZWRlZC5cbiAgZnVuY3Rpb24gbWF5YmVVcGRhdGVMaW5lTnVtYmVyV2lkdGgoY20pIHtcbiAgICBpZiAoIWNtLm9wdGlvbnMubGluZU51bWJlcnMpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgZG9jID0gY20uZG9jLCBsYXN0ID0gbGluZU51bWJlckZvcihjbS5vcHRpb25zLCBkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDEpLCBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICBpZiAobGFzdC5sZW5ndGggIT0gZGlzcGxheS5saW5lTnVtQ2hhcnMpIHtcbiAgICAgIHZhciB0ZXN0ID0gZGlzcGxheS5tZWFzdXJlLmFwcGVuZENoaWxkKGVsdChcImRpdlwiLCBbZWx0KFwiZGl2XCIsIGxhc3QpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkNvZGVNaXJyb3ItbGluZW51bWJlciBDb2RlTWlycm9yLWd1dHRlci1lbHRcIikpO1xuICAgICAgdmFyIGlubmVyVyA9IHRlc3QuZmlyc3RDaGlsZC5vZmZzZXRXaWR0aCwgcGFkZGluZyA9IHRlc3Qub2Zmc2V0V2lkdGggLSBpbm5lclc7XG4gICAgICBkaXNwbGF5LmxpbmVHdXR0ZXIuc3R5bGUud2lkdGggPSBcIlwiO1xuICAgICAgZGlzcGxheS5saW5lTnVtSW5uZXJXaWR0aCA9IE1hdGgubWF4KGlubmVyVywgZGlzcGxheS5saW5lR3V0dGVyLm9mZnNldFdpZHRoIC0gcGFkZGluZyk7XG4gICAgICBkaXNwbGF5LmxpbmVOdW1XaWR0aCA9IGRpc3BsYXkubGluZU51bUlubmVyV2lkdGggKyBwYWRkaW5nO1xuICAgICAgZGlzcGxheS5saW5lTnVtQ2hhcnMgPSBkaXNwbGF5LmxpbmVOdW1Jbm5lcldpZHRoID8gbGFzdC5sZW5ndGggOiAtMTtcbiAgICAgIGRpc3BsYXkubGluZUd1dHRlci5zdHlsZS53aWR0aCA9IGRpc3BsYXkubGluZU51bVdpZHRoICsgXCJweFwiO1xuICAgICAgdXBkYXRlR3V0dGVyU3BhY2UoY20pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpbmVOdW1iZXJGb3Iob3B0aW9ucywgaSkge1xuICAgIHJldHVybiBTdHJpbmcob3B0aW9ucy5saW5lTnVtYmVyRm9ybWF0dGVyKGkgKyBvcHRpb25zLmZpcnN0TGluZU51bWJlcikpO1xuICB9XG5cbiAgLy8gQ29tcHV0ZXMgZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0ICsgZGlzcGxheS5ndXR0ZXJzLm9mZnNldFdpZHRoLFxuICAvLyBidXQgdXNpbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IHRvIGdldCBhIHN1Yi1waXhlbC1hY2N1cmF0ZVxuICAvLyByZXN1bHQuXG4gIGZ1bmN0aW9uIGNvbXBlbnNhdGVGb3JIU2Nyb2xsKGRpc3BsYXkpIHtcbiAgICByZXR1cm4gZGlzcGxheS5zY3JvbGxlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC0gZGlzcGxheS5zaXplci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuICB9XG5cbiAgLy8gRElTUExBWSBEUkFXSU5HXG5cbiAgLy8gVXBkYXRlcyB0aGUgZGlzcGxheSwgc2VsZWN0aW9uLCBhbmQgc2Nyb2xsYmFycywgdXNpbmcgdGhlXG4gIC8vIGluZm9ybWF0aW9uIGluIGRpc3BsYXkudmlldyB0byBmaW5kIG91dCB3aGljaCBub2RlcyBhcmUgbm8gbG9uZ2VyXG4gIC8vIHVwLXRvLWRhdGUuIFRyaWVzIHRvIGJhaWwgb3V0IGVhcmx5IHdoZW4gbm8gY2hhbmdlcyBhcmUgbmVlZGVkLFxuICAvLyB1bmxlc3MgZm9yY2VkIGlzIHRydWUuXG4gIC8vIFJldHVybnMgdHJ1ZSBpZiBhbiBhY3R1YWwgdXBkYXRlIGhhcHBlbmVkLCBmYWxzZSBvdGhlcndpc2UuXG4gIGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoY20sIHZpZXdQb3J0LCBmb3JjZWQpIHtcbiAgICB2YXIgb2xkRnJvbSA9IGNtLmRpc3BsYXkudmlld0Zyb20sIG9sZFRvID0gY20uZGlzcGxheS52aWV3VG8sIHVwZGF0ZWQ7XG4gICAgdmFyIHZpc2libGUgPSB2aXNpYmxlTGluZXMoY20uZGlzcGxheSwgY20uZG9jLCB2aWV3UG9ydCk7XG4gICAgZm9yICh2YXIgZmlyc3QgPSB0cnVlOzsgZmlyc3QgPSBmYWxzZSkge1xuICAgICAgdmFyIG9sZFdpZHRoID0gY20uZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aDtcbiAgICAgIGlmICghdXBkYXRlRGlzcGxheUlubmVyKGNtLCB2aXNpYmxlLCBmb3JjZWQpKSBicmVhaztcbiAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuXG4gICAgICAvLyBJZiB0aGUgbWF4IGxpbmUgY2hhbmdlZCBzaW5jZSBpdCB3YXMgbGFzdCBtZWFzdXJlZCwgbWVhc3VyZSBpdCxcbiAgICAgIC8vIGFuZCBlbnN1cmUgdGhlIGRvY3VtZW50J3Mgd2lkdGggbWF0Y2hlcyBpdC5cbiAgICAgIGlmIChjbS5kaXNwbGF5Lm1heExpbmVDaGFuZ2VkICYmICFjbS5vcHRpb25zLmxpbmVXcmFwcGluZylcbiAgICAgICAgYWRqdXN0Q29udGVudFdpZHRoKGNtKTtcblxuICAgICAgdmFyIGJhck1lYXN1cmUgPSBtZWFzdXJlRm9yU2Nyb2xsYmFycyhjbSk7XG4gICAgICB1cGRhdGVTZWxlY3Rpb24oY20pO1xuICAgICAgc2V0RG9jdW1lbnRIZWlnaHQoY20sIGJhck1lYXN1cmUpO1xuICAgICAgdXBkYXRlU2Nyb2xsYmFycyhjbSwgYmFyTWVhc3VyZSk7XG4gICAgICBpZiAod2Via2l0ICYmIGNtLm9wdGlvbnMubGluZVdyYXBwaW5nKVxuICAgICAgICBjaGVja0ZvcldlYmtpdFdpZHRoQnVnKGNtLCBiYXJNZWFzdXJlKTsgLy8gKElzc3VlICMyNDIwKVxuICAgICAgaWYgKGZpcnN0ICYmIGNtLm9wdGlvbnMubGluZVdyYXBwaW5nICYmIG9sZFdpZHRoICE9IGNtLmRpc3BsYXkuc2Nyb2xsZXIuY2xpZW50V2lkdGgpIHtcbiAgICAgICAgZm9yY2VkID0gdHJ1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBmb3JjZWQgPSBmYWxzZTtcblxuICAgICAgLy8gQ2xpcCBmb3JjZWQgdmlld3BvcnQgdG8gYWN0dWFsIHNjcm9sbGFibGUgYXJlYS5cbiAgICAgIGlmICh2aWV3UG9ydCAmJiB2aWV3UG9ydC50b3AgIT0gbnVsbClcbiAgICAgICAgdmlld1BvcnQgPSB7dG9wOiBNYXRoLm1pbihiYXJNZWFzdXJlLmRvY0hlaWdodCAtIHNjcm9sbGVyQ3V0T2ZmIC0gYmFyTWVhc3VyZS5jbGllbnRIZWlnaHQsIHZpZXdQb3J0LnRvcCl9O1xuICAgICAgLy8gVXBkYXRlZCBsaW5lIGhlaWdodHMgbWlnaHQgcmVzdWx0IGluIHRoZSBkcmF3biBhcmVhIG5vdFxuICAgICAgLy8gYWN0dWFsbHkgY292ZXJpbmcgdGhlIHZpZXdwb3J0LiBLZWVwIGxvb3BpbmcgdW50aWwgaXQgZG9lcy5cbiAgICAgIHZpc2libGUgPSB2aXNpYmxlTGluZXMoY20uZGlzcGxheSwgY20uZG9jLCB2aWV3UG9ydCk7XG4gICAgICBpZiAodmlzaWJsZS5mcm9tID49IGNtLmRpc3BsYXkudmlld0Zyb20gJiYgdmlzaWJsZS50byA8PSBjbS5kaXNwbGF5LnZpZXdUbylcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY20uZGlzcGxheS51cGRhdGVMaW5lTnVtYmVycyA9IG51bGw7XG4gICAgaWYgKHVwZGF0ZWQpIHtcbiAgICAgIHNpZ25hbExhdGVyKGNtLCBcInVwZGF0ZVwiLCBjbSk7XG4gICAgICBpZiAoY20uZGlzcGxheS52aWV3RnJvbSAhPSBvbGRGcm9tIHx8IGNtLmRpc3BsYXkudmlld1RvICE9IG9sZFRvKVxuICAgICAgICBzaWduYWxMYXRlcihjbSwgXCJ2aWV3cG9ydENoYW5nZVwiLCBjbSwgY20uZGlzcGxheS52aWV3RnJvbSwgY20uZGlzcGxheS52aWV3VG8pO1xuICAgIH1cbiAgICByZXR1cm4gdXBkYXRlZDtcbiAgfVxuXG4gIC8vIERvZXMgdGhlIGFjdHVhbCB1cGRhdGluZyBvZiB0aGUgbGluZSBkaXNwbGF5LiBCYWlscyBvdXRcbiAgLy8gKHJldHVybmluZyBmYWxzZSkgd2hlbiB0aGVyZSBpcyBub3RoaW5nIHRvIGJlIGRvbmUgYW5kIGZvcmNlZCBpc1xuICAvLyBmYWxzZS5cbiAgZnVuY3Rpb24gdXBkYXRlRGlzcGxheUlubmVyKGNtLCB2aXNpYmxlLCBmb3JjZWQpIHtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIGRvYyA9IGNtLmRvYztcbiAgICBpZiAoIWRpc3BsYXkud3JhcHBlci5vZmZzZXRXaWR0aCkge1xuICAgICAgcmVzZXRWaWV3KGNtKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBCYWlsIG91dCBpZiB0aGUgdmlzaWJsZSBhcmVhIGlzIGFscmVhZHkgcmVuZGVyZWQgYW5kIG5vdGhpbmcgY2hhbmdlZC5cbiAgICBpZiAoIWZvcmNlZCAmJiB2aXNpYmxlLmZyb20gPj0gZGlzcGxheS52aWV3RnJvbSAmJiB2aXNpYmxlLnRvIDw9IGRpc3BsYXkudmlld1RvICYmXG4gICAgICAgIGNvdW50RGlydHlWaWV3KGNtKSA9PSAwKVxuICAgICAgcmV0dXJuO1xuXG4gICAgaWYgKG1heWJlVXBkYXRlTGluZU51bWJlcldpZHRoKGNtKSlcbiAgICAgIHJlc2V0VmlldyhjbSk7XG4gICAgdmFyIGRpbXMgPSBnZXREaW1lbnNpb25zKGNtKTtcblxuICAgIC8vIENvbXB1dGUgYSBzdWl0YWJsZSBuZXcgdmlld3BvcnQgKGZyb20gJiB0bylcbiAgICB2YXIgZW5kID0gZG9jLmZpcnN0ICsgZG9jLnNpemU7XG4gICAgdmFyIGZyb20gPSBNYXRoLm1heCh2aXNpYmxlLmZyb20gLSBjbS5vcHRpb25zLnZpZXdwb3J0TWFyZ2luLCBkb2MuZmlyc3QpO1xuICAgIHZhciB0byA9IE1hdGgubWluKGVuZCwgdmlzaWJsZS50byArIGNtLm9wdGlvbnMudmlld3BvcnRNYXJnaW4pO1xuICAgIGlmIChkaXNwbGF5LnZpZXdGcm9tIDwgZnJvbSAmJiBmcm9tIC0gZGlzcGxheS52aWV3RnJvbSA8IDIwKSBmcm9tID0gTWF0aC5tYXgoZG9jLmZpcnN0LCBkaXNwbGF5LnZpZXdGcm9tKTtcbiAgICBpZiAoZGlzcGxheS52aWV3VG8gPiB0byAmJiBkaXNwbGF5LnZpZXdUbyAtIHRvIDwgMjApIHRvID0gTWF0aC5taW4oZW5kLCBkaXNwbGF5LnZpZXdUbyk7XG4gICAgaWYgKHNhd0NvbGxhcHNlZFNwYW5zKSB7XG4gICAgICBmcm9tID0gdmlzdWFsTGluZU5vKGNtLmRvYywgZnJvbSk7XG4gICAgICB0byA9IHZpc3VhbExpbmVFbmRObyhjbS5kb2MsIHRvKTtcbiAgICB9XG5cbiAgICB2YXIgZGlmZmVyZW50ID0gZnJvbSAhPSBkaXNwbGF5LnZpZXdGcm9tIHx8IHRvICE9IGRpc3BsYXkudmlld1RvIHx8XG4gICAgICBkaXNwbGF5Lmxhc3RTaXplQyAhPSBkaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0O1xuICAgIGFkanVzdFZpZXcoY20sIGZyb20sIHRvKTtcblxuICAgIGRpc3BsYXkudmlld09mZnNldCA9IGhlaWdodEF0TGluZShnZXRMaW5lKGNtLmRvYywgZGlzcGxheS52aWV3RnJvbSkpO1xuICAgIC8vIFBvc2l0aW9uIHRoZSBtb3ZlciBkaXYgdG8gYWxpZ24gd2l0aCB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb25cbiAgICBjbS5kaXNwbGF5Lm1vdmVyLnN0eWxlLnRvcCA9IGRpc3BsYXkudmlld09mZnNldCArIFwicHhcIjtcblxuICAgIHZhciB0b1VwZGF0ZSA9IGNvdW50RGlydHlWaWV3KGNtKTtcbiAgICBpZiAoIWRpZmZlcmVudCAmJiB0b1VwZGF0ZSA9PSAwICYmICFmb3JjZWQpIHJldHVybjtcblxuICAgIC8vIEZvciBiaWcgY2hhbmdlcywgd2UgaGlkZSB0aGUgZW5jbG9zaW5nIGVsZW1lbnQgZHVyaW5nIHRoZVxuICAgIC8vIHVwZGF0ZSwgc2luY2UgdGhhdCBzcGVlZHMgdXAgdGhlIG9wZXJhdGlvbnMgb24gbW9zdCBicm93c2Vycy5cbiAgICB2YXIgZm9jdXNlZCA9IGFjdGl2ZUVsdCgpO1xuICAgIGlmICh0b1VwZGF0ZSA+IDQpIGRpc3BsYXkubGluZURpdi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgcGF0Y2hEaXNwbGF5KGNtLCBkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzLCBkaW1zKTtcbiAgICBpZiAodG9VcGRhdGUgPiA0KSBkaXNwbGF5LmxpbmVEaXYuc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgLy8gVGhlcmUgbWlnaHQgaGF2ZSBiZWVuIGEgd2lkZ2V0IHdpdGggYSBmb2N1c2VkIGVsZW1lbnQgdGhhdCBnb3RcbiAgICAvLyBoaWRkZW4gb3IgdXBkYXRlZCwgaWYgc28gcmUtZm9jdXMgaXQuXG4gICAgaWYgKGZvY3VzZWQgJiYgYWN0aXZlRWx0KCkgIT0gZm9jdXNlZCAmJiBmb2N1c2VkLm9mZnNldEhlaWdodCkgZm9jdXNlZC5mb2N1cygpO1xuXG4gICAgLy8gUHJldmVudCBzZWxlY3Rpb24gYW5kIGN1cnNvcnMgZnJvbSBpbnRlcmZlcmluZyB3aXRoIHRoZSBzY3JvbGxcbiAgICAvLyB3aWR0aC5cbiAgICByZW1vdmVDaGlsZHJlbihkaXNwbGF5LmN1cnNvckRpdik7XG4gICAgcmVtb3ZlQ2hpbGRyZW4oZGlzcGxheS5zZWxlY3Rpb25EaXYpO1xuXG4gICAgaWYgKGRpZmZlcmVudCkge1xuICAgICAgZGlzcGxheS5sYXN0U2l6ZUMgPSBkaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0O1xuICAgICAgc3RhcnRXb3JrZXIoY20sIDQwMCk7XG4gICAgfVxuXG4gICAgdXBkYXRlSGVpZ2h0c0luVmlld3BvcnQoY20pO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBhZGp1c3RDb250ZW50V2lkdGgoY20pIHtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG4gICAgdmFyIHdpZHRoID0gbWVhc3VyZUNoYXIoY20sIGRpc3BsYXkubWF4TGluZSwgZGlzcGxheS5tYXhMaW5lLnRleHQubGVuZ3RoKS5sZWZ0O1xuICAgIGRpc3BsYXkubWF4TGluZUNoYW5nZWQgPSBmYWxzZTtcbiAgICB2YXIgbWluV2lkdGggPSBNYXRoLm1heCgwLCB3aWR0aCArIDMpO1xuICAgIHZhciBtYXhTY3JvbGxMZWZ0ID0gTWF0aC5tYXgoMCwgZGlzcGxheS5zaXplci5vZmZzZXRMZWZ0ICsgbWluV2lkdGggKyBzY3JvbGxlckN1dE9mZiAtIGRpc3BsYXkuc2Nyb2xsZXIuY2xpZW50V2lkdGgpO1xuICAgIGRpc3BsYXkuc2l6ZXIuc3R5bGUubWluV2lkdGggPSBtaW5XaWR0aCArIFwicHhcIjtcbiAgICBpZiAobWF4U2Nyb2xsTGVmdCA8IGNtLmRvYy5zY3JvbGxMZWZ0KVxuICAgICAgc2V0U2Nyb2xsTGVmdChjbSwgTWF0aC5taW4oZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0LCBtYXhTY3JvbGxMZWZ0KSwgdHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXREb2N1bWVudEhlaWdodChjbSwgbWVhc3VyZSkge1xuICAgIGNtLmRpc3BsYXkuc2l6ZXIuc3R5bGUubWluSGVpZ2h0ID0gY20uZGlzcGxheS5oZWlnaHRGb3JjZXIuc3R5bGUudG9wID0gbWVhc3VyZS5kb2NIZWlnaHQgKyBcInB4XCI7XG4gICAgY20uZGlzcGxheS5ndXR0ZXJzLnN0eWxlLmhlaWdodCA9IE1hdGgubWF4KG1lYXN1cmUuZG9jSGVpZ2h0LCBtZWFzdXJlLmNsaWVudEhlaWdodCAtIHNjcm9sbGVyQ3V0T2ZmKSArIFwicHhcIjtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gY2hlY2tGb3JXZWJraXRXaWR0aEJ1ZyhjbSwgbWVhc3VyZSkge1xuICAgIC8vIFdvcmsgYXJvdW5kIFdlYmtpdCBidWcgd2hlcmUgaXQgc29tZXRpbWVzIHJlc2VydmVzIHNwYWNlIGZvciBhXG4gICAgLy8gbm9uLWV4aXN0aW5nIHBoYW50b20gc2Nyb2xsYmFyIGluIHRoZSBzY3JvbGxlciAoSXNzdWUgIzI0MjApXG4gICAgaWYgKGNtLmRpc3BsYXkuc2l6ZXIub2Zmc2V0V2lkdGggKyBjbS5kaXNwbGF5Lmd1dHRlcnMub2Zmc2V0V2lkdGggPCBjbS5kaXNwbGF5LnNjcm9sbGVyLmNsaWVudFdpZHRoIC0gMSkge1xuICAgICAgY20uZGlzcGxheS5zaXplci5zdHlsZS5taW5IZWlnaHQgPSBjbS5kaXNwbGF5LmhlaWdodEZvcmNlci5zdHlsZS50b3AgPSBcIjBweFwiO1xuICAgICAgY20uZGlzcGxheS5ndXR0ZXJzLnN0eWxlLmhlaWdodCA9IG1lYXN1cmUuZG9jSGVpZ2h0ICsgXCJweFwiO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlYWQgdGhlIGFjdHVhbCBoZWlnaHRzIG9mIHRoZSByZW5kZXJlZCBsaW5lcywgYW5kIHVwZGF0ZSB0aGVpclxuICAvLyBzdG9yZWQgaGVpZ2h0cyB0byBtYXRjaC5cbiAgZnVuY3Rpb24gdXBkYXRlSGVpZ2h0c0luVmlld3BvcnQoY20pIHtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG4gICAgdmFyIHByZXZCb3R0b20gPSBkaXNwbGF5LmxpbmVEaXYub2Zmc2V0VG9wO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGxheS52aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY3VyID0gZGlzcGxheS52aWV3W2ldLCBoZWlnaHQ7XG4gICAgICBpZiAoY3VyLmhpZGRlbikgY29udGludWU7XG4gICAgICBpZiAoaWVfdXB0bzcpIHtcbiAgICAgICAgdmFyIGJvdCA9IGN1ci5ub2RlLm9mZnNldFRvcCArIGN1ci5ub2RlLm9mZnNldEhlaWdodDtcbiAgICAgICAgaGVpZ2h0ID0gYm90IC0gcHJldkJvdHRvbTtcbiAgICAgICAgcHJldkJvdHRvbSA9IGJvdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBib3ggPSBjdXIubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaGVpZ2h0ID0gYm94LmJvdHRvbSAtIGJveC50b3A7XG4gICAgICB9XG4gICAgICB2YXIgZGlmZiA9IGN1ci5saW5lLmhlaWdodCAtIGhlaWdodDtcbiAgICAgIGlmIChoZWlnaHQgPCAyKSBoZWlnaHQgPSB0ZXh0SGVpZ2h0KGRpc3BsYXkpO1xuICAgICAgaWYgKGRpZmYgPiAuMDAxIHx8IGRpZmYgPCAtLjAwMSkge1xuICAgICAgICB1cGRhdGVMaW5lSGVpZ2h0KGN1ci5saW5lLCBoZWlnaHQpO1xuICAgICAgICB1cGRhdGVXaWRnZXRIZWlnaHQoY3VyLmxpbmUpO1xuICAgICAgICBpZiAoY3VyLnJlc3QpIGZvciAodmFyIGogPSAwOyBqIDwgY3VyLnJlc3QubGVuZ3RoOyBqKyspXG4gICAgICAgICAgdXBkYXRlV2lkZ2V0SGVpZ2h0KGN1ci5yZXN0W2pdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBSZWFkIGFuZCBzdG9yZSB0aGUgaGVpZ2h0IG9mIGxpbmUgd2lkZ2V0cyBhc3NvY2lhdGVkIHdpdGggdGhlXG4gIC8vIGdpdmVuIGxpbmUuXG4gIGZ1bmN0aW9uIHVwZGF0ZVdpZGdldEhlaWdodChsaW5lKSB7XG4gICAgaWYgKGxpbmUud2lkZ2V0cykgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lLndpZGdldHMubGVuZ3RoOyArK2kpXG4gICAgICBsaW5lLndpZGdldHNbaV0uaGVpZ2h0ID0gbGluZS53aWRnZXRzW2ldLm5vZGUub2Zmc2V0SGVpZ2h0O1xuICB9XG5cbiAgLy8gRG8gYSBidWxrLXJlYWQgb2YgdGhlIERPTSBwb3NpdGlvbnMgYW5kIHNpemVzIG5lZWRlZCB0byBkcmF3IHRoZVxuICAvLyB2aWV3LCBzbyB0aGF0IHdlIGRvbid0IGludGVybGVhdmUgcmVhZGluZyBhbmQgd3JpdGluZyB0byB0aGUgRE9NLlxuICBmdW5jdGlvbiBnZXREaW1lbnNpb25zKGNtKSB7XG4gICAgdmFyIGQgPSBjbS5kaXNwbGF5LCBsZWZ0ID0ge30sIHdpZHRoID0ge307XG4gICAgZm9yICh2YXIgbiA9IGQuZ3V0dGVycy5maXJzdENoaWxkLCBpID0gMDsgbjsgbiA9IG4ubmV4dFNpYmxpbmcsICsraSkge1xuICAgICAgbGVmdFtjbS5vcHRpb25zLmd1dHRlcnNbaV1dID0gbi5vZmZzZXRMZWZ0O1xuICAgICAgd2lkdGhbY20ub3B0aW9ucy5ndXR0ZXJzW2ldXSA9IG4ub2Zmc2V0V2lkdGg7XG4gICAgfVxuICAgIHJldHVybiB7Zml4ZWRQb3M6IGNvbXBlbnNhdGVGb3JIU2Nyb2xsKGQpLFxuICAgICAgICAgICAgZ3V0dGVyVG90YWxXaWR0aDogZC5ndXR0ZXJzLm9mZnNldFdpZHRoLFxuICAgICAgICAgICAgZ3V0dGVyTGVmdDogbGVmdCxcbiAgICAgICAgICAgIGd1dHRlcldpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIHdyYXBwZXJXaWR0aDogZC53cmFwcGVyLmNsaWVudFdpZHRofTtcbiAgfVxuXG4gIC8vIFN5bmMgdGhlIGFjdHVhbCBkaXNwbGF5IERPTSBzdHJ1Y3R1cmUgd2l0aCBkaXNwbGF5LnZpZXcsIHJlbW92aW5nXG4gIC8vIG5vZGVzIGZvciBsaW5lcyB0aGF0IGFyZSBubyBsb25nZXIgaW4gdmlldywgYW5kIGNyZWF0aW5nIHRoZSBvbmVzXG4gIC8vIHRoYXQgYXJlIG5vdCB0aGVyZSB5ZXQsIGFuZCB1cGRhdGluZyB0aGUgb25lcyB0aGF0IGFyZSBvdXQgb2ZcbiAgLy8gZGF0ZS5cbiAgZnVuY3Rpb24gcGF0Y2hEaXNwbGF5KGNtLCB1cGRhdGVOdW1iZXJzRnJvbSwgZGltcykge1xuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgbGluZU51bWJlcnMgPSBjbS5vcHRpb25zLmxpbmVOdW1iZXJzO1xuICAgIHZhciBjb250YWluZXIgPSBkaXNwbGF5LmxpbmVEaXYsIGN1ciA9IGNvbnRhaW5lci5maXJzdENoaWxkO1xuXG4gICAgZnVuY3Rpb24gcm0obm9kZSkge1xuICAgICAgdmFyIG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgLy8gV29ya3MgYXJvdW5kIGEgdGhyb3ctc2Nyb2xsIGJ1ZyBpbiBPUyBYIFdlYmtpdFxuICAgICAgaWYgKHdlYmtpdCAmJiBtYWMgJiYgY20uZGlzcGxheS5jdXJyZW50V2hlZWxUYXJnZXQgPT0gbm9kZSlcbiAgICAgICAgbm9kZS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICBlbHNlXG4gICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH1cblxuICAgIHZhciB2aWV3ID0gZGlzcGxheS52aWV3LCBsaW5lTiA9IGRpc3BsYXkudmlld0Zyb207XG4gICAgLy8gTG9vcCBvdmVyIHRoZSBlbGVtZW50cyBpbiB0aGUgdmlldywgc3luY2luZyBjdXIgKHRoZSBET00gbm9kZXNcbiAgICAvLyBpbiBkaXNwbGF5LmxpbmVEaXYpIHdpdGggdGhlIHZpZXcgYXMgd2UgZ28uXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbGluZVZpZXcgPSB2aWV3W2ldO1xuICAgICAgaWYgKGxpbmVWaWV3LmhpZGRlbikge1xuICAgICAgfSBlbHNlIGlmICghbGluZVZpZXcubm9kZSkgeyAvLyBOb3QgZHJhd24geWV0XG4gICAgICAgIHZhciBub2RlID0gYnVpbGRMaW5lRWxlbWVudChjbSwgbGluZVZpZXcsIGxpbmVOLCBkaW1zKTtcbiAgICAgICAgY29udGFpbmVyLmluc2VydEJlZm9yZShub2RlLCBjdXIpO1xuICAgICAgfSBlbHNlIHsgLy8gQWxyZWFkeSBkcmF3blxuICAgICAgICB3aGlsZSAoY3VyICE9IGxpbmVWaWV3Lm5vZGUpIGN1ciA9IHJtKGN1cik7XG4gICAgICAgIHZhciB1cGRhdGVOdW1iZXIgPSBsaW5lTnVtYmVycyAmJiB1cGRhdGVOdW1iZXJzRnJvbSAhPSBudWxsICYmXG4gICAgICAgICAgdXBkYXRlTnVtYmVyc0Zyb20gPD0gbGluZU4gJiYgbGluZVZpZXcubGluZU51bWJlcjtcbiAgICAgICAgaWYgKGxpbmVWaWV3LmNoYW5nZXMpIHtcbiAgICAgICAgICBpZiAoaW5kZXhPZihsaW5lVmlldy5jaGFuZ2VzLCBcImd1dHRlclwiKSA+IC0xKSB1cGRhdGVOdW1iZXIgPSBmYWxzZTtcbiAgICAgICAgICB1cGRhdGVMaW5lRm9yQ2hhbmdlcyhjbSwgbGluZVZpZXcsIGxpbmVOLCBkaW1zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlTnVtYmVyKSB7XG4gICAgICAgICAgcmVtb3ZlQ2hpbGRyZW4obGluZVZpZXcubGluZU51bWJlcik7XG4gICAgICAgICAgbGluZVZpZXcubGluZU51bWJlci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsaW5lTnVtYmVyRm9yKGNtLm9wdGlvbnMsIGxpbmVOKSkpO1xuICAgICAgICB9XG4gICAgICAgIGN1ciA9IGxpbmVWaWV3Lm5vZGUubmV4dFNpYmxpbmc7XG4gICAgICB9XG4gICAgICBsaW5lTiArPSBsaW5lVmlldy5zaXplO1xuICAgIH1cbiAgICB3aGlsZSAoY3VyKSBjdXIgPSBybShjdXIpO1xuICB9XG5cbiAgLy8gV2hlbiBhbiBhc3BlY3Qgb2YgYSBsaW5lIGNoYW5nZXMsIGEgc3RyaW5nIGlzIGFkZGVkIHRvXG4gIC8vIGxpbmVWaWV3LmNoYW5nZXMuIFRoaXMgdXBkYXRlcyB0aGUgcmVsZXZhbnQgcGFydCBvZiB0aGUgbGluZSdzXG4gIC8vIERPTSBzdHJ1Y3R1cmUuXG4gIGZ1bmN0aW9uIHVwZGF0ZUxpbmVGb3JDaGFuZ2VzKGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxpbmVWaWV3LmNoYW5nZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciB0eXBlID0gbGluZVZpZXcuY2hhbmdlc1tqXTtcbiAgICAgIGlmICh0eXBlID09IFwidGV4dFwiKSB1cGRhdGVMaW5lVGV4dChjbSwgbGluZVZpZXcpO1xuICAgICAgZWxzZSBpZiAodHlwZSA9PSBcImd1dHRlclwiKSB1cGRhdGVMaW5lR3V0dGVyKGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpO1xuICAgICAgZWxzZSBpZiAodHlwZSA9PSBcImNsYXNzXCIpIHVwZGF0ZUxpbmVDbGFzc2VzKGxpbmVWaWV3KTtcbiAgICAgIGVsc2UgaWYgKHR5cGUgPT0gXCJ3aWRnZXRcIikgdXBkYXRlTGluZVdpZGdldHMobGluZVZpZXcsIGRpbXMpO1xuICAgIH1cbiAgICBsaW5lVmlldy5jaGFuZ2VzID0gbnVsbDtcbiAgfVxuXG4gIC8vIExpbmVzIHdpdGggZ3V0dGVyIGVsZW1lbnRzLCB3aWRnZXRzIG9yIGEgYmFja2dyb3VuZCBjbGFzcyBuZWVkIHRvXG4gIC8vIGJlIHdyYXBwZWQsIGFuZCBoYXZlIHRoZSBleHRyYSBlbGVtZW50cyBhZGRlZCB0byB0aGUgd3JhcHBlciBkaXZcbiAgZnVuY3Rpb24gZW5zdXJlTGluZVdyYXBwZWQobGluZVZpZXcpIHtcbiAgICBpZiAobGluZVZpZXcubm9kZSA9PSBsaW5lVmlldy50ZXh0KSB7XG4gICAgICBsaW5lVmlldy5ub2RlID0gZWx0KFwiZGl2XCIsIG51bGwsIG51bGwsIFwicG9zaXRpb246IHJlbGF0aXZlXCIpO1xuICAgICAgaWYgKGxpbmVWaWV3LnRleHQucGFyZW50Tm9kZSlcbiAgICAgICAgbGluZVZpZXcudGV4dC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChsaW5lVmlldy5ub2RlLCBsaW5lVmlldy50ZXh0KTtcbiAgICAgIGxpbmVWaWV3Lm5vZGUuYXBwZW5kQ2hpbGQobGluZVZpZXcudGV4dCk7XG4gICAgICBpZiAoaWVfdXB0bzcpIGxpbmVWaWV3Lm5vZGUuc3R5bGUuekluZGV4ID0gMjtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmVWaWV3Lm5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVMaW5lQmFja2dyb3VuZChsaW5lVmlldykge1xuICAgIHZhciBjbHMgPSBsaW5lVmlldy5iZ0NsYXNzID8gbGluZVZpZXcuYmdDbGFzcyArIFwiIFwiICsgKGxpbmVWaWV3LmxpbmUuYmdDbGFzcyB8fCBcIlwiKSA6IGxpbmVWaWV3LmxpbmUuYmdDbGFzcztcbiAgICBpZiAoY2xzKSBjbHMgKz0gXCIgQ29kZU1pcnJvci1saW5lYmFja2dyb3VuZFwiO1xuICAgIGlmIChsaW5lVmlldy5iYWNrZ3JvdW5kKSB7XG4gICAgICBpZiAoY2xzKSBsaW5lVmlldy5iYWNrZ3JvdW5kLmNsYXNzTmFtZSA9IGNscztcbiAgICAgIGVsc2UgeyBsaW5lVmlldy5iYWNrZ3JvdW5kLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobGluZVZpZXcuYmFja2dyb3VuZCk7IGxpbmVWaWV3LmJhY2tncm91bmQgPSBudWxsOyB9XG4gICAgfSBlbHNlIGlmIChjbHMpIHtcbiAgICAgIHZhciB3cmFwID0gZW5zdXJlTGluZVdyYXBwZWQobGluZVZpZXcpO1xuICAgICAgbGluZVZpZXcuYmFja2dyb3VuZCA9IHdyYXAuaW5zZXJ0QmVmb3JlKGVsdChcImRpdlwiLCBudWxsLCBjbHMpLCB3cmFwLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFdyYXBwZXIgYXJvdW5kIGJ1aWxkTGluZUNvbnRlbnQgd2hpY2ggd2lsbCByZXVzZSB0aGUgc3RydWN0dXJlXG4gIC8vIGluIGRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCB3aGVuIHBvc3NpYmxlLlxuICBmdW5jdGlvbiBnZXRMaW5lQ29udGVudChjbSwgbGluZVZpZXcpIHtcbiAgICB2YXIgZXh0ID0gY20uZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkO1xuICAgIGlmIChleHQgJiYgZXh0LmxpbmUgPT0gbGluZVZpZXcubGluZSkge1xuICAgICAgY20uZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkID0gbnVsbDtcbiAgICAgIGxpbmVWaWV3Lm1lYXN1cmUgPSBleHQubWVhc3VyZTtcbiAgICAgIHJldHVybiBleHQuYnVpbHQ7XG4gICAgfVxuICAgIHJldHVybiBidWlsZExpbmVDb250ZW50KGNtLCBsaW5lVmlldyk7XG4gIH1cblxuICAvLyBSZWRyYXcgdGhlIGxpbmUncyB0ZXh0LiBJbnRlcmFjdHMgd2l0aCB0aGUgYmFja2dyb3VuZCBhbmQgdGV4dFxuICAvLyBjbGFzc2VzIGJlY2F1c2UgdGhlIG1vZGUgbWF5IG91dHB1dCB0b2tlbnMgdGhhdCBpbmZsdWVuY2UgdGhlc2VcbiAgLy8gY2xhc3Nlcy5cbiAgZnVuY3Rpb24gdXBkYXRlTGluZVRleHQoY20sIGxpbmVWaWV3KSB7XG4gICAgdmFyIGNscyA9IGxpbmVWaWV3LnRleHQuY2xhc3NOYW1lO1xuICAgIHZhciBidWlsdCA9IGdldExpbmVDb250ZW50KGNtLCBsaW5lVmlldyk7XG4gICAgaWYgKGxpbmVWaWV3LnRleHQgPT0gbGluZVZpZXcubm9kZSkgbGluZVZpZXcubm9kZSA9IGJ1aWx0LnByZTtcbiAgICBsaW5lVmlldy50ZXh0LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGJ1aWx0LnByZSwgbGluZVZpZXcudGV4dCk7XG4gICAgbGluZVZpZXcudGV4dCA9IGJ1aWx0LnByZTtcbiAgICBpZiAoYnVpbHQuYmdDbGFzcyAhPSBsaW5lVmlldy5iZ0NsYXNzIHx8IGJ1aWx0LnRleHRDbGFzcyAhPSBsaW5lVmlldy50ZXh0Q2xhc3MpIHtcbiAgICAgIGxpbmVWaWV3LmJnQ2xhc3MgPSBidWlsdC5iZ0NsYXNzO1xuICAgICAgbGluZVZpZXcudGV4dENsYXNzID0gYnVpbHQudGV4dENsYXNzO1xuICAgICAgdXBkYXRlTGluZUNsYXNzZXMobGluZVZpZXcpO1xuICAgIH0gZWxzZSBpZiAoY2xzKSB7XG4gICAgICBsaW5lVmlldy50ZXh0LmNsYXNzTmFtZSA9IGNscztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVMaW5lQ2xhc3NlcyhsaW5lVmlldykge1xuICAgIHVwZGF0ZUxpbmVCYWNrZ3JvdW5kKGxpbmVWaWV3KTtcbiAgICBpZiAobGluZVZpZXcubGluZS53cmFwQ2xhc3MpXG4gICAgICBlbnN1cmVMaW5lV3JhcHBlZChsaW5lVmlldykuY2xhc3NOYW1lID0gbGluZVZpZXcubGluZS53cmFwQ2xhc3M7XG4gICAgZWxzZSBpZiAobGluZVZpZXcubm9kZSAhPSBsaW5lVmlldy50ZXh0KVxuICAgICAgbGluZVZpZXcubm9kZS5jbGFzc05hbWUgPSBcIlwiO1xuICAgIHZhciB0ZXh0Q2xhc3MgPSBsaW5lVmlldy50ZXh0Q2xhc3MgPyBsaW5lVmlldy50ZXh0Q2xhc3MgKyBcIiBcIiArIChsaW5lVmlldy5saW5lLnRleHRDbGFzcyB8fCBcIlwiKSA6IGxpbmVWaWV3LmxpbmUudGV4dENsYXNzO1xuICAgIGxpbmVWaWV3LnRleHQuY2xhc3NOYW1lID0gdGV4dENsYXNzIHx8IFwiXCI7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVMaW5lR3V0dGVyKGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpIHtcbiAgICBpZiAobGluZVZpZXcuZ3V0dGVyKSB7XG4gICAgICBsaW5lVmlldy5ub2RlLnJlbW92ZUNoaWxkKGxpbmVWaWV3Lmd1dHRlcik7XG4gICAgICBsaW5lVmlldy5ndXR0ZXIgPSBudWxsO1xuICAgIH1cbiAgICB2YXIgbWFya2VycyA9IGxpbmVWaWV3LmxpbmUuZ3V0dGVyTWFya2VycztcbiAgICBpZiAoY20ub3B0aW9ucy5saW5lTnVtYmVycyB8fCBtYXJrZXJzKSB7XG4gICAgICB2YXIgd3JhcCA9IGVuc3VyZUxpbmVXcmFwcGVkKGxpbmVWaWV3KTtcbiAgICAgIHZhciBndXR0ZXJXcmFwID0gbGluZVZpZXcuZ3V0dGVyID1cbiAgICAgICAgd3JhcC5pbnNlcnRCZWZvcmUoZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1ndXR0ZXItd3JhcHBlclwiLCBcInBvc2l0aW9uOiBhYnNvbHV0ZTsgbGVmdDogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIgPyBkaW1zLmZpeGVkUG9zIDogLWRpbXMuZ3V0dGVyVG90YWxXaWR0aCkgKyBcInB4XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lVmlldy50ZXh0KTtcbiAgICAgIGlmIChjbS5vcHRpb25zLmxpbmVOdW1iZXJzICYmICghbWFya2VycyB8fCAhbWFya2Vyc1tcIkNvZGVNaXJyb3ItbGluZW51bWJlcnNcIl0pKVxuICAgICAgICBsaW5lVmlldy5saW5lTnVtYmVyID0gZ3V0dGVyV3JhcC5hcHBlbmRDaGlsZChcbiAgICAgICAgICBlbHQoXCJkaXZcIiwgbGluZU51bWJlckZvcihjbS5vcHRpb25zLCBsaW5lTiksXG4gICAgICAgICAgICAgIFwiQ29kZU1pcnJvci1saW5lbnVtYmVyIENvZGVNaXJyb3ItZ3V0dGVyLWVsdFwiLFxuICAgICAgICAgICAgICBcImxlZnQ6IFwiICsgZGltcy5ndXR0ZXJMZWZ0W1wiQ29kZU1pcnJvci1saW5lbnVtYmVyc1wiXSArIFwicHg7IHdpZHRoOiBcIlxuICAgICAgICAgICAgICArIGNtLmRpc3BsYXkubGluZU51bUlubmVyV2lkdGggKyBcInB4XCIpKTtcbiAgICAgIGlmIChtYXJrZXJzKSBmb3IgKHZhciBrID0gMDsgayA8IGNtLm9wdGlvbnMuZ3V0dGVycy5sZW5ndGg7ICsraykge1xuICAgICAgICB2YXIgaWQgPSBjbS5vcHRpb25zLmd1dHRlcnNba10sIGZvdW5kID0gbWFya2Vycy5oYXNPd25Qcm9wZXJ0eShpZCkgJiYgbWFya2Vyc1tpZF07XG4gICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICBndXR0ZXJXcmFwLmFwcGVuZENoaWxkKGVsdChcImRpdlwiLCBbZm91bmRdLCBcIkNvZGVNaXJyb3ItZ3V0dGVyLWVsdFwiLCBcImxlZnQ6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaW1zLmd1dHRlckxlZnRbaWRdICsgXCJweDsgd2lkdGg6IFwiICsgZGltcy5ndXR0ZXJXaWR0aFtpZF0gKyBcInB4XCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVMaW5lV2lkZ2V0cyhsaW5lVmlldywgZGltcykge1xuICAgIGlmIChsaW5lVmlldy5hbGlnbmFibGUpIGxpbmVWaWV3LmFsaWduYWJsZSA9IG51bGw7XG4gICAgZm9yICh2YXIgbm9kZSA9IGxpbmVWaWV3Lm5vZGUuZmlyc3RDaGlsZCwgbmV4dDsgbm9kZTsgbm9kZSA9IG5leHQpIHtcbiAgICAgIHZhciBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgIGlmIChub2RlLmNsYXNzTmFtZSA9PSBcIkNvZGVNaXJyb3ItbGluZXdpZGdldFwiKVxuICAgICAgICBsaW5lVmlldy5ub2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgIH1cbiAgICBpbnNlcnRMaW5lV2lkZ2V0cyhsaW5lVmlldywgZGltcyk7XG4gIH1cblxuICAvLyBCdWlsZCBhIGxpbmUncyBET00gcmVwcmVzZW50YXRpb24gZnJvbSBzY3JhdGNoXG4gIGZ1bmN0aW9uIGJ1aWxkTGluZUVsZW1lbnQoY20sIGxpbmVWaWV3LCBsaW5lTiwgZGltcykge1xuICAgIHZhciBidWlsdCA9IGdldExpbmVDb250ZW50KGNtLCBsaW5lVmlldyk7XG4gICAgbGluZVZpZXcudGV4dCA9IGxpbmVWaWV3Lm5vZGUgPSBidWlsdC5wcmU7XG4gICAgaWYgKGJ1aWx0LmJnQ2xhc3MpIGxpbmVWaWV3LmJnQ2xhc3MgPSBidWlsdC5iZ0NsYXNzO1xuICAgIGlmIChidWlsdC50ZXh0Q2xhc3MpIGxpbmVWaWV3LnRleHRDbGFzcyA9IGJ1aWx0LnRleHRDbGFzcztcblxuICAgIHVwZGF0ZUxpbmVDbGFzc2VzKGxpbmVWaWV3KTtcbiAgICB1cGRhdGVMaW5lR3V0dGVyKGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpO1xuICAgIGluc2VydExpbmVXaWRnZXRzKGxpbmVWaWV3LCBkaW1zKTtcbiAgICByZXR1cm4gbGluZVZpZXcubm9kZTtcbiAgfVxuXG4gIC8vIEEgbGluZVZpZXcgbWF5IGNvbnRhaW4gbXVsdGlwbGUgbG9naWNhbCBsaW5lcyAod2hlbiBtZXJnZWQgYnlcbiAgLy8gY29sbGFwc2VkIHNwYW5zKS4gVGhlIHdpZGdldHMgZm9yIGFsbCBvZiB0aGVtIG5lZWQgdG8gYmUgZHJhd24uXG4gIGZ1bmN0aW9uIGluc2VydExpbmVXaWRnZXRzKGxpbmVWaWV3LCBkaW1zKSB7XG4gICAgaW5zZXJ0TGluZVdpZGdldHNGb3IobGluZVZpZXcubGluZSwgbGluZVZpZXcsIGRpbXMsIHRydWUpO1xuICAgIGlmIChsaW5lVmlldy5yZXN0KSBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVWaWV3LnJlc3QubGVuZ3RoOyBpKyspXG4gICAgICBpbnNlcnRMaW5lV2lkZ2V0c0ZvcihsaW5lVmlldy5yZXN0W2ldLCBsaW5lVmlldywgZGltcywgZmFsc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0TGluZVdpZGdldHNGb3IobGluZSwgbGluZVZpZXcsIGRpbXMsIGFsbG93QWJvdmUpIHtcbiAgICBpZiAoIWxpbmUud2lkZ2V0cykgcmV0dXJuO1xuICAgIHZhciB3cmFwID0gZW5zdXJlTGluZVdyYXBwZWQobGluZVZpZXcpO1xuICAgIGZvciAodmFyIGkgPSAwLCB3cyA9IGxpbmUud2lkZ2V0czsgaSA8IHdzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgd2lkZ2V0ID0gd3NbaV0sIG5vZGUgPSBlbHQoXCJkaXZcIiwgW3dpZGdldC5ub2RlXSwgXCJDb2RlTWlycm9yLWxpbmV3aWRnZXRcIik7XG4gICAgICBpZiAoIXdpZGdldC5oYW5kbGVNb3VzZUV2ZW50cykgbm9kZS5pZ25vcmVFdmVudHMgPSB0cnVlO1xuICAgICAgcG9zaXRpb25MaW5lV2lkZ2V0KHdpZGdldCwgbm9kZSwgbGluZVZpZXcsIGRpbXMpO1xuICAgICAgaWYgKGFsbG93QWJvdmUgJiYgd2lkZ2V0LmFib3ZlKVxuICAgICAgICB3cmFwLmluc2VydEJlZm9yZShub2RlLCBsaW5lVmlldy5ndXR0ZXIgfHwgbGluZVZpZXcudGV4dCk7XG4gICAgICBlbHNlXG4gICAgICAgIHdyYXAuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICBzaWduYWxMYXRlcih3aWRnZXQsIFwicmVkcmF3XCIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBvc2l0aW9uTGluZVdpZGdldCh3aWRnZXQsIG5vZGUsIGxpbmVWaWV3LCBkaW1zKSB7XG4gICAgaWYgKHdpZGdldC5ub0hTY3JvbGwpIHtcbiAgICAgIChsaW5lVmlldy5hbGlnbmFibGUgfHwgKGxpbmVWaWV3LmFsaWduYWJsZSA9IFtdKSkucHVzaChub2RlKTtcbiAgICAgIHZhciB3aWR0aCA9IGRpbXMud3JhcHBlcldpZHRoO1xuICAgICAgbm9kZS5zdHlsZS5sZWZ0ID0gZGltcy5maXhlZFBvcyArIFwicHhcIjtcbiAgICAgIGlmICghd2lkZ2V0LmNvdmVyR3V0dGVyKSB7XG4gICAgICAgIHdpZHRoIC09IGRpbXMuZ3V0dGVyVG90YWxXaWR0aDtcbiAgICAgICAgbm9kZS5zdHlsZS5wYWRkaW5nTGVmdCA9IGRpbXMuZ3V0dGVyVG90YWxXaWR0aCArIFwicHhcIjtcbiAgICAgIH1cbiAgICAgIG5vZGUuc3R5bGUud2lkdGggPSB3aWR0aCArIFwicHhcIjtcbiAgICB9XG4gICAgaWYgKHdpZGdldC5jb3Zlckd1dHRlcikge1xuICAgICAgbm9kZS5zdHlsZS56SW5kZXggPSA1O1xuICAgICAgbm9kZS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcbiAgICAgIGlmICghd2lkZ2V0Lm5vSFNjcm9sbCkgbm9kZS5zdHlsZS5tYXJnaW5MZWZ0ID0gLWRpbXMuZ3V0dGVyVG90YWxXaWR0aCArIFwicHhcIjtcbiAgICB9XG4gIH1cblxuICAvLyBQT1NJVElPTiBPQkpFQ1RcblxuICAvLyBBIFBvcyBpbnN0YW5jZSByZXByZXNlbnRzIGEgcG9zaXRpb24gd2l0aGluIHRoZSB0ZXh0LlxuICB2YXIgUG9zID0gQ29kZU1pcnJvci5Qb3MgPSBmdW5jdGlvbihsaW5lLCBjaCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQb3MpKSByZXR1cm4gbmV3IFBvcyhsaW5lLCBjaCk7XG4gICAgdGhpcy5saW5lID0gbGluZTsgdGhpcy5jaCA9IGNoO1xuICB9O1xuXG4gIC8vIENvbXBhcmUgdHdvIHBvc2l0aW9ucywgcmV0dXJuIDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIGEgbmVnYXRpdmVcbiAgLy8gbnVtYmVyIHdoZW4gYSBpcyBsZXNzLCBhbmQgYSBwb3NpdGl2ZSBudW1iZXIgb3RoZXJ3aXNlLlxuICB2YXIgY21wID0gQ29kZU1pcnJvci5jbXBQb3MgPSBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhLmxpbmUgLSBiLmxpbmUgfHwgYS5jaCAtIGIuY2g7IH07XG5cbiAgZnVuY3Rpb24gY29weVBvcyh4KSB7cmV0dXJuIFBvcyh4LmxpbmUsIHguY2gpO31cbiAgZnVuY3Rpb24gbWF4UG9zKGEsIGIpIHsgcmV0dXJuIGNtcChhLCBiKSA8IDAgPyBiIDogYTsgfVxuICBmdW5jdGlvbiBtaW5Qb3MoYSwgYikgeyByZXR1cm4gY21wKGEsIGIpIDwgMCA/IGEgOiBiOyB9XG5cbiAgLy8gU0VMRUNUSU9OIC8gQ1VSU09SXG5cbiAgLy8gU2VsZWN0aW9uIG9iamVjdHMgYXJlIGltbXV0YWJsZS4gQSBuZXcgb25lIGlzIGNyZWF0ZWQgZXZlcnkgdGltZVxuICAvLyB0aGUgc2VsZWN0aW9uIGNoYW5nZXMuIEEgc2VsZWN0aW9uIGlzIG9uZSBvciBtb3JlIG5vbi1vdmVybGFwcGluZ1xuICAvLyAoYW5kIG5vbi10b3VjaGluZykgcmFuZ2VzLCBzb3J0ZWQsIGFuZCBhbiBpbnRlZ2VyIHRoYXQgaW5kaWNhdGVzXG4gIC8vIHdoaWNoIG9uZSBpcyB0aGUgcHJpbWFyeSBzZWxlY3Rpb24gKHRoZSBvbmUgdGhhdCdzIHNjcm9sbGVkIGludG9cbiAgLy8gdmlldywgdGhhdCBnZXRDdXJzb3IgcmV0dXJucywgZXRjKS5cbiAgZnVuY3Rpb24gU2VsZWN0aW9uKHJhbmdlcywgcHJpbUluZGV4KSB7XG4gICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgdGhpcy5wcmltSW5kZXggPSBwcmltSW5kZXg7XG4gIH1cblxuICBTZWxlY3Rpb24ucHJvdG90eXBlID0ge1xuICAgIHByaW1hcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5yYW5nZXNbdGhpcy5wcmltSW5kZXhdOyB9LFxuICAgIGVxdWFsczogZnVuY3Rpb24ob3RoZXIpIHtcbiAgICAgIGlmIChvdGhlciA9PSB0aGlzKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChvdGhlci5wcmltSW5kZXggIT0gdGhpcy5wcmltSW5kZXggfHwgb3RoZXIucmFuZ2VzLmxlbmd0aCAhPSB0aGlzLnJhbmdlcy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGhlcmUgPSB0aGlzLnJhbmdlc1tpXSwgdGhlcmUgPSBvdGhlci5yYW5nZXNbaV07XG4gICAgICAgIGlmIChjbXAoaGVyZS5hbmNob3IsIHRoZXJlLmFuY2hvcikgIT0gMCB8fCBjbXAoaGVyZS5oZWFkLCB0aGVyZS5oZWFkKSAhPSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGRlZXBDb3B5OiBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIG91dCA9IFtdLCBpID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSsrKVxuICAgICAgICBvdXRbaV0gPSBuZXcgUmFuZ2UoY29weVBvcyh0aGlzLnJhbmdlc1tpXS5hbmNob3IpLCBjb3B5UG9zKHRoaXMucmFuZ2VzW2ldLmhlYWQpKTtcbiAgICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKG91dCwgdGhpcy5wcmltSW5kZXgpO1xuICAgIH0sXG4gICAgc29tZXRoaW5nU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKCF0aGlzLnJhbmdlc1tpXS5lbXB0eSgpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGNvbnRhaW5zOiBmdW5jdGlvbihwb3MsIGVuZCkge1xuICAgICAgaWYgKCFlbmQpIGVuZCA9IHBvcztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5yYW5nZXNbaV07XG4gICAgICAgIGlmIChjbXAoZW5kLCByYW5nZS5mcm9tKCkpID49IDAgJiYgY21wKHBvcywgcmFuZ2UudG8oKSkgPD0gMClcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gUmFuZ2UoYW5jaG9yLCBoZWFkKSB7XG4gICAgdGhpcy5hbmNob3IgPSBhbmNob3I7IHRoaXMuaGVhZCA9IGhlYWQ7XG4gIH1cblxuICBSYW5nZS5wcm90b3R5cGUgPSB7XG4gICAgZnJvbTogZnVuY3Rpb24oKSB7IHJldHVybiBtaW5Qb3ModGhpcy5hbmNob3IsIHRoaXMuaGVhZCk7IH0sXG4gICAgdG86IGZ1bmN0aW9uKCkgeyByZXR1cm4gbWF4UG9zKHRoaXMuYW5jaG9yLCB0aGlzLmhlYWQpOyB9LFxuICAgIGVtcHR5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmhlYWQubGluZSA9PSB0aGlzLmFuY2hvci5saW5lICYmIHRoaXMuaGVhZC5jaCA9PSB0aGlzLmFuY2hvci5jaDtcbiAgICB9XG4gIH07XG5cbiAgLy8gVGFrZSBhbiB1bnNvcnRlZCwgcG90ZW50aWFsbHkgb3ZlcmxhcHBpbmcgc2V0IG9mIHJhbmdlcywgYW5kXG4gIC8vIGJ1aWxkIGEgc2VsZWN0aW9uIG91dCBvZiBpdC4gJ0NvbnN1bWVzJyByYW5nZXMgYXJyYXkgKG1vZGlmeWluZ1xuICAvLyBpdCkuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVNlbGVjdGlvbihyYW5nZXMsIHByaW1JbmRleCkge1xuICAgIHZhciBwcmltID0gcmFuZ2VzW3ByaW1JbmRleF07XG4gICAgcmFuZ2VzLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gY21wKGEuZnJvbSgpLCBiLmZyb20oKSk7IH0pO1xuICAgIHByaW1JbmRleCA9IGluZGV4T2YocmFuZ2VzLCBwcmltKTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGN1ciA9IHJhbmdlc1tpXSwgcHJldiA9IHJhbmdlc1tpIC0gMV07XG4gICAgICBpZiAoY21wKHByZXYudG8oKSwgY3VyLmZyb20oKSkgPj0gMCkge1xuICAgICAgICB2YXIgZnJvbSA9IG1pblBvcyhwcmV2LmZyb20oKSwgY3VyLmZyb20oKSksIHRvID0gbWF4UG9zKHByZXYudG8oKSwgY3VyLnRvKCkpO1xuICAgICAgICB2YXIgaW52ID0gcHJldi5lbXB0eSgpID8gY3VyLmZyb20oKSA9PSBjdXIuaGVhZCA6IHByZXYuZnJvbSgpID09IHByZXYuaGVhZDtcbiAgICAgICAgaWYgKGkgPD0gcHJpbUluZGV4KSAtLXByaW1JbmRleDtcbiAgICAgICAgcmFuZ2VzLnNwbGljZSgtLWksIDIsIG5ldyBSYW5nZShpbnYgPyB0byA6IGZyb20sIGludiA/IGZyb20gOiB0bykpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFNlbGVjdGlvbihyYW5nZXMsIHByaW1JbmRleCk7XG4gIH1cblxuICBmdW5jdGlvbiBzaW1wbGVTZWxlY3Rpb24oYW5jaG9yLCBoZWFkKSB7XG4gICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oW25ldyBSYW5nZShhbmNob3IsIGhlYWQgfHwgYW5jaG9yKV0sIDApO1xuICB9XG5cbiAgLy8gTW9zdCBvZiB0aGUgZXh0ZXJuYWwgQVBJIGNsaXBzIGdpdmVuIHBvc2l0aW9ucyB0byBtYWtlIHN1cmUgdGhleVxuICAvLyBhY3R1YWxseSBleGlzdCB3aXRoaW4gdGhlIGRvY3VtZW50LlxuICBmdW5jdGlvbiBjbGlwTGluZShkb2MsIG4pIHtyZXR1cm4gTWF0aC5tYXgoZG9jLmZpcnN0LCBNYXRoLm1pbihuLCBkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDEpKTt9XG4gIGZ1bmN0aW9uIGNsaXBQb3MoZG9jLCBwb3MpIHtcbiAgICBpZiAocG9zLmxpbmUgPCBkb2MuZmlyc3QpIHJldHVybiBQb3MoZG9jLmZpcnN0LCAwKTtcbiAgICB2YXIgbGFzdCA9IGRvYy5maXJzdCArIGRvYy5zaXplIC0gMTtcbiAgICBpZiAocG9zLmxpbmUgPiBsYXN0KSByZXR1cm4gUG9zKGxhc3QsIGdldExpbmUoZG9jLCBsYXN0KS50ZXh0Lmxlbmd0aCk7XG4gICAgcmV0dXJuIGNsaXBUb0xlbihwb3MsIGdldExpbmUoZG9jLCBwb3MubGluZSkudGV4dC5sZW5ndGgpO1xuICB9XG4gIGZ1bmN0aW9uIGNsaXBUb0xlbihwb3MsIGxpbmVsZW4pIHtcbiAgICB2YXIgY2ggPSBwb3MuY2g7XG4gICAgaWYgKGNoID09IG51bGwgfHwgY2ggPiBsaW5lbGVuKSByZXR1cm4gUG9zKHBvcy5saW5lLCBsaW5lbGVuKTtcbiAgICBlbHNlIGlmIChjaCA8IDApIHJldHVybiBQb3MocG9zLmxpbmUsIDApO1xuICAgIGVsc2UgcmV0dXJuIHBvcztcbiAgfVxuICBmdW5jdGlvbiBpc0xpbmUoZG9jLCBsKSB7cmV0dXJuIGwgPj0gZG9jLmZpcnN0ICYmIGwgPCBkb2MuZmlyc3QgKyBkb2Muc2l6ZTt9XG4gIGZ1bmN0aW9uIGNsaXBQb3NBcnJheShkb2MsIGFycmF5KSB7XG4gICAgZm9yICh2YXIgb3V0ID0gW10sIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIG91dFtpXSA9IGNsaXBQb3MoZG9jLCBhcnJheVtpXSk7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG4gIC8vIFNFTEVDVElPTiBVUERBVEVTXG5cbiAgLy8gVGhlICdzY3JvbGwnIHBhcmFtZXRlciBnaXZlbiB0byBtYW55IG9mIHRoZXNlIGluZGljYXRlZCB3aGV0aGVyXG4gIC8vIHRoZSBuZXcgY3Vyc29yIHBvc2l0aW9uIHNob3VsZCBiZSBzY3JvbGxlZCBpbnRvIHZpZXcgYWZ0ZXJcbiAgLy8gbW9kaWZ5aW5nIHRoZSBzZWxlY3Rpb24uXG5cbiAgLy8gSWYgc2hpZnQgaXMgaGVsZCBvciB0aGUgZXh0ZW5kIGZsYWcgaXMgc2V0LCBleHRlbmRzIGEgcmFuZ2UgdG9cbiAgLy8gaW5jbHVkZSBhIGdpdmVuIHBvc2l0aW9uIChhbmQgb3B0aW9uYWxseSBhIHNlY29uZCBwb3NpdGlvbikuXG4gIC8vIE90aGVyd2lzZSwgc2ltcGx5IHJldHVybnMgdGhlIHJhbmdlIGJldHdlZW4gdGhlIGdpdmVuIHBvc2l0aW9ucy5cbiAgLy8gVXNlZCBmb3IgY3Vyc29yIG1vdGlvbiBhbmQgc3VjaC5cbiAgZnVuY3Rpb24gZXh0ZW5kUmFuZ2UoZG9jLCByYW5nZSwgaGVhZCwgb3RoZXIpIHtcbiAgICBpZiAoZG9jLmNtICYmIGRvYy5jbS5kaXNwbGF5LnNoaWZ0IHx8IGRvYy5leHRlbmQpIHtcbiAgICAgIHZhciBhbmNob3IgPSByYW5nZS5hbmNob3I7XG4gICAgICBpZiAob3RoZXIpIHtcbiAgICAgICAgdmFyIHBvc0JlZm9yZSA9IGNtcChoZWFkLCBhbmNob3IpIDwgMDtcbiAgICAgICAgaWYgKHBvc0JlZm9yZSAhPSAoY21wKG90aGVyLCBhbmNob3IpIDwgMCkpIHtcbiAgICAgICAgICBhbmNob3IgPSBoZWFkO1xuICAgICAgICAgIGhlYWQgPSBvdGhlcjtcbiAgICAgICAgfSBlbHNlIGlmIChwb3NCZWZvcmUgIT0gKGNtcChoZWFkLCBvdGhlcikgPCAwKSkge1xuICAgICAgICAgIGhlYWQgPSBvdGhlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBSYW5nZShhbmNob3IsIGhlYWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFJhbmdlKG90aGVyIHx8IGhlYWQsIGhlYWQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEV4dGVuZCB0aGUgcHJpbWFyeSBzZWxlY3Rpb24gcmFuZ2UsIGRpc2NhcmQgdGhlIHJlc3QuXG4gIGZ1bmN0aW9uIGV4dGVuZFNlbGVjdGlvbihkb2MsIGhlYWQsIG90aGVyLCBvcHRpb25zKSB7XG4gICAgc2V0U2VsZWN0aW9uKGRvYywgbmV3IFNlbGVjdGlvbihbZXh0ZW5kUmFuZ2UoZG9jLCBkb2Muc2VsLnByaW1hcnkoKSwgaGVhZCwgb3RoZXIpXSwgMCksIG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gRXh0ZW5kIGFsbCBzZWxlY3Rpb25zIChwb3MgaXMgYW4gYXJyYXkgb2Ygc2VsZWN0aW9ucyB3aXRoIGxlbmd0aFxuICAvLyBlcXVhbCB0aGUgbnVtYmVyIG9mIHNlbGVjdGlvbnMpXG4gIGZ1bmN0aW9uIGV4dGVuZFNlbGVjdGlvbnMoZG9jLCBoZWFkcywgb3B0aW9ucykge1xuICAgIGZvciAodmFyIG91dCA9IFtdLCBpID0gMDsgaSA8IGRvYy5zZWwucmFuZ2VzLmxlbmd0aDsgaSsrKVxuICAgICAgb3V0W2ldID0gZXh0ZW5kUmFuZ2UoZG9jLCBkb2Muc2VsLnJhbmdlc1tpXSwgaGVhZHNbaV0sIG51bGwpO1xuICAgIHZhciBuZXdTZWwgPSBub3JtYWxpemVTZWxlY3Rpb24ob3V0LCBkb2Muc2VsLnByaW1JbmRleCk7XG4gICAgc2V0U2VsZWN0aW9uKGRvYywgbmV3U2VsLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8vIFVwZGF0ZXMgYSBzaW5nbGUgcmFuZ2UgaW4gdGhlIHNlbGVjdGlvbi5cbiAgZnVuY3Rpb24gcmVwbGFjZU9uZVNlbGVjdGlvbihkb2MsIGksIHJhbmdlLCBvcHRpb25zKSB7XG4gICAgdmFyIHJhbmdlcyA9IGRvYy5zZWwucmFuZ2VzLnNsaWNlKDApO1xuICAgIHJhbmdlc1tpXSA9IHJhbmdlO1xuICAgIHNldFNlbGVjdGlvbihkb2MsIG5vcm1hbGl6ZVNlbGVjdGlvbihyYW5nZXMsIGRvYy5zZWwucHJpbUluZGV4KSwgb3B0aW9ucyk7XG4gIH1cblxuICAvLyBSZXNldCB0aGUgc2VsZWN0aW9uIHRvIGEgc2luZ2xlIHJhbmdlLlxuICBmdW5jdGlvbiBzZXRTaW1wbGVTZWxlY3Rpb24oZG9jLCBhbmNob3IsIGhlYWQsIG9wdGlvbnMpIHtcbiAgICBzZXRTZWxlY3Rpb24oZG9jLCBzaW1wbGVTZWxlY3Rpb24oYW5jaG9yLCBoZWFkKSwgb3B0aW9ucyk7XG4gIH1cblxuICAvLyBHaXZlIGJlZm9yZVNlbGVjdGlvbkNoYW5nZSBoYW5kbGVycyBhIGNoYW5nZSB0byBpbmZsdWVuY2UgYVxuICAvLyBzZWxlY3Rpb24gdXBkYXRlLlxuICBmdW5jdGlvbiBmaWx0ZXJTZWxlY3Rpb25DaGFuZ2UoZG9jLCBzZWwpIHtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgcmFuZ2VzOiBzZWwucmFuZ2VzLFxuICAgICAgdXBkYXRlOiBmdW5jdGlvbihyYW5nZXMpIHtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgdGhpcy5yYW5nZXNbaV0gPSBuZXcgUmFuZ2UoY2xpcFBvcyhkb2MsIHJhbmdlc1tpXS5hbmNob3IpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBQb3MoZG9jLCByYW5nZXNbaV0uaGVhZCkpO1xuICAgICAgfVxuICAgIH07XG4gICAgc2lnbmFsKGRvYywgXCJiZWZvcmVTZWxlY3Rpb25DaGFuZ2VcIiwgZG9jLCBvYmopO1xuICAgIGlmIChkb2MuY20pIHNpZ25hbChkb2MuY20sIFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXCIsIGRvYy5jbSwgb2JqKTtcbiAgICBpZiAob2JqLnJhbmdlcyAhPSBzZWwucmFuZ2VzKSByZXR1cm4gbm9ybWFsaXplU2VsZWN0aW9uKG9iai5yYW5nZXMsIG9iai5yYW5nZXMubGVuZ3RoIC0gMSk7XG4gICAgZWxzZSByZXR1cm4gc2VsO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0U2VsZWN0aW9uUmVwbGFjZUhpc3RvcnkoZG9jLCBzZWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgZG9uZSA9IGRvYy5oaXN0b3J5LmRvbmUsIGxhc3QgPSBsc3QoZG9uZSk7XG4gICAgaWYgKGxhc3QgJiYgbGFzdC5yYW5nZXMpIHtcbiAgICAgIGRvbmVbZG9uZS5sZW5ndGggLSAxXSA9IHNlbDtcbiAgICAgIHNldFNlbGVjdGlvbk5vVW5kbyhkb2MsIHNlbCwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFNlbGVjdGlvbihkb2MsIHNlbCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgLy8gU2V0IGEgbmV3IHNlbGVjdGlvbi5cbiAgZnVuY3Rpb24gc2V0U2VsZWN0aW9uKGRvYywgc2VsLCBvcHRpb25zKSB7XG4gICAgc2V0U2VsZWN0aW9uTm9VbmRvKGRvYywgc2VsLCBvcHRpb25zKTtcbiAgICBhZGRTZWxlY3Rpb25Ub0hpc3RvcnkoZG9jLCBkb2Muc2VsLCBkb2MuY20gPyBkb2MuY20uY3VyT3AuaWQgOiBOYU4sIG9wdGlvbnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0U2VsZWN0aW9uTm9VbmRvKGRvYywgc2VsLCBvcHRpb25zKSB7XG4gICAgaWYgKGhhc0hhbmRsZXIoZG9jLCBcImJlZm9yZVNlbGVjdGlvbkNoYW5nZVwiKSB8fCBkb2MuY20gJiYgaGFzSGFuZGxlcihkb2MuY20sIFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXCIpKVxuICAgICAgc2VsID0gZmlsdGVyU2VsZWN0aW9uQ2hhbmdlKGRvYywgc2VsKTtcblxuICAgIHZhciBiaWFzID0gY21wKHNlbC5wcmltYXJ5KCkuaGVhZCwgZG9jLnNlbC5wcmltYXJ5KCkuaGVhZCkgPCAwID8gLTEgOiAxO1xuICAgIHNldFNlbGVjdGlvbklubmVyKGRvYywgc2tpcEF0b21pY0luU2VsZWN0aW9uKGRvYywgc2VsLCBiaWFzLCB0cnVlKSk7XG5cbiAgICBpZiAoIShvcHRpb25zICYmIG9wdGlvbnMuc2Nyb2xsID09PSBmYWxzZSkgJiYgZG9jLmNtKVxuICAgICAgZW5zdXJlQ3Vyc29yVmlzaWJsZShkb2MuY20pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0U2VsZWN0aW9uSW5uZXIoZG9jLCBzZWwpIHtcbiAgICBpZiAoc2VsLmVxdWFscyhkb2Muc2VsKSkgcmV0dXJuO1xuXG4gICAgZG9jLnNlbCA9IHNlbDtcblxuICAgIGlmIChkb2MuY20pIHtcbiAgICAgIGRvYy5jbS5jdXJPcC51cGRhdGVJbnB1dCA9IGRvYy5jbS5jdXJPcC5zZWxlY3Rpb25DaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIHNpZ25hbEN1cnNvckFjdGl2aXR5KGRvYy5jbSk7XG4gICAgfVxuICAgIHNpZ25hbExhdGVyKGRvYywgXCJjdXJzb3JBY3Rpdml0eVwiLCBkb2MpO1xuICB9XG5cbiAgLy8gVmVyaWZ5IHRoYXQgdGhlIHNlbGVjdGlvbiBkb2VzIG5vdCBwYXJ0aWFsbHkgc2VsZWN0IGFueSBhdG9taWNcbiAgLy8gbWFya2VkIHJhbmdlcy5cbiAgZnVuY3Rpb24gcmVDaGVja1NlbGVjdGlvbihkb2MpIHtcbiAgICBzZXRTZWxlY3Rpb25Jbm5lcihkb2MsIHNraXBBdG9taWNJblNlbGVjdGlvbihkb2MsIGRvYy5zZWwsIG51bGwsIGZhbHNlKSwgc2VsX2RvbnRTY3JvbGwpO1xuICB9XG5cbiAgLy8gUmV0dXJuIGEgc2VsZWN0aW9uIHRoYXQgZG9lcyBub3QgcGFydGlhbGx5IHNlbGVjdCBhbnkgYXRvbWljXG4gIC8vIHJhbmdlcy5cbiAgZnVuY3Rpb24gc2tpcEF0b21pY0luU2VsZWN0aW9uKGRvYywgc2VsLCBiaWFzLCBtYXlDbGVhcikge1xuICAgIHZhciBvdXQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWwucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBzZWwucmFuZ2VzW2ldO1xuICAgICAgdmFyIG5ld0FuY2hvciA9IHNraXBBdG9taWMoZG9jLCByYW5nZS5hbmNob3IsIGJpYXMsIG1heUNsZWFyKTtcbiAgICAgIHZhciBuZXdIZWFkID0gc2tpcEF0b21pYyhkb2MsIHJhbmdlLmhlYWQsIGJpYXMsIG1heUNsZWFyKTtcbiAgICAgIGlmIChvdXQgfHwgbmV3QW5jaG9yICE9IHJhbmdlLmFuY2hvciB8fCBuZXdIZWFkICE9IHJhbmdlLmhlYWQpIHtcbiAgICAgICAgaWYgKCFvdXQpIG91dCA9IHNlbC5yYW5nZXMuc2xpY2UoMCwgaSk7XG4gICAgICAgIG91dFtpXSA9IG5ldyBSYW5nZShuZXdBbmNob3IsIG5ld0hlYWQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0ID8gbm9ybWFsaXplU2VsZWN0aW9uKG91dCwgc2VsLnByaW1JbmRleCkgOiBzZWw7XG4gIH1cblxuICAvLyBFbnN1cmUgYSBnaXZlbiBwb3NpdGlvbiBpcyBub3QgaW5zaWRlIGFuIGF0b21pYyByYW5nZS5cbiAgZnVuY3Rpb24gc2tpcEF0b21pYyhkb2MsIHBvcywgYmlhcywgbWF5Q2xlYXIpIHtcbiAgICB2YXIgZmxpcHBlZCA9IGZhbHNlLCBjdXJQb3MgPSBwb3M7XG4gICAgdmFyIGRpciA9IGJpYXMgfHwgMTtcbiAgICBkb2MuY2FudEVkaXQgPSBmYWxzZTtcbiAgICBzZWFyY2g6IGZvciAoOzspIHtcbiAgICAgIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIGN1clBvcy5saW5lKTtcbiAgICAgIGlmIChsaW5lLm1hcmtlZFNwYW5zKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS5tYXJrZWRTcGFucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciBzcCA9IGxpbmUubWFya2VkU3BhbnNbaV0sIG0gPSBzcC5tYXJrZXI7XG4gICAgICAgICAgaWYgKChzcC5mcm9tID09IG51bGwgfHwgKG0uaW5jbHVzaXZlTGVmdCA/IHNwLmZyb20gPD0gY3VyUG9zLmNoIDogc3AuZnJvbSA8IGN1clBvcy5jaCkpICYmXG4gICAgICAgICAgICAgIChzcC50byA9PSBudWxsIHx8IChtLmluY2x1c2l2ZVJpZ2h0ID8gc3AudG8gPj0gY3VyUG9zLmNoIDogc3AudG8gPiBjdXJQb3MuY2gpKSkge1xuICAgICAgICAgICAgaWYgKG1heUNsZWFyKSB7XG4gICAgICAgICAgICAgIHNpZ25hbChtLCBcImJlZm9yZUN1cnNvckVudGVyXCIpO1xuICAgICAgICAgICAgICBpZiAobS5leHBsaWNpdGx5Q2xlYXJlZCkge1xuICAgICAgICAgICAgICAgIGlmICghbGluZS5tYXJrZWRTcGFucykgYnJlYWs7XG4gICAgICAgICAgICAgICAgZWxzZSB7LS1pOyBjb250aW51ZTt9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbS5hdG9taWMpIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIG5ld1BvcyA9IG0uZmluZChkaXIgPCAwID8gLTEgOiAxKTtcbiAgICAgICAgICAgIGlmIChjbXAobmV3UG9zLCBjdXJQb3MpID09IDApIHtcbiAgICAgICAgICAgICAgbmV3UG9zLmNoICs9IGRpcjtcbiAgICAgICAgICAgICAgaWYgKG5ld1Bvcy5jaCA8IDApIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3UG9zLmxpbmUgPiBkb2MuZmlyc3QpIG5ld1BvcyA9IGNsaXBQb3MoZG9jLCBQb3MobmV3UG9zLmxpbmUgLSAxKSk7XG4gICAgICAgICAgICAgICAgZWxzZSBuZXdQb3MgPSBudWxsO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5ld1Bvcy5jaCA+IGxpbmUudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3UG9zLmxpbmUgPCBkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDEpIG5ld1BvcyA9IFBvcyhuZXdQb3MubGluZSArIDEsIDApO1xuICAgICAgICAgICAgICAgIGVsc2UgbmV3UG9zID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIW5ld1Bvcykge1xuICAgICAgICAgICAgICAgIGlmIChmbGlwcGVkKSB7XG4gICAgICAgICAgICAgICAgICAvLyBEcml2ZW4gaW4gYSBjb3JuZXIgLS0gbm8gdmFsaWQgY3Vyc29yIHBvc2l0aW9uIGZvdW5kIGF0IGFsbFxuICAgICAgICAgICAgICAgICAgLy8gLS0gdHJ5IGFnYWluICp3aXRoKiBjbGVhcmluZywgaWYgd2UgZGlkbid0IGFscmVhZHlcbiAgICAgICAgICAgICAgICAgIGlmICghbWF5Q2xlYXIpIHJldHVybiBza2lwQXRvbWljKGRvYywgcG9zLCBiaWFzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdHVybiBvZmYgZWRpdGluZyB1bnRpbCBmdXJ0aGVyIG5vdGljZSwgYW5kIHJldHVybiB0aGUgc3RhcnQgb2YgdGhlIGRvY1xuICAgICAgICAgICAgICAgICAgZG9jLmNhbnRFZGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBQb3MoZG9jLmZpcnN0LCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmxpcHBlZCA9IHRydWU7IG5ld1BvcyA9IHBvczsgZGlyID0gLWRpcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyUG9zID0gbmV3UG9zO1xuICAgICAgICAgICAgY29udGludWUgc2VhcmNoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGN1clBvcztcbiAgICB9XG4gIH1cblxuICAvLyBTRUxFQ1RJT04gRFJBV0lOR1xuXG4gIC8vIFJlZHJhdyB0aGUgc2VsZWN0aW9uIGFuZC9vciBjdXJzb3JcbiAgZnVuY3Rpb24gdXBkYXRlU2VsZWN0aW9uKGNtKSB7XG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBkb2MgPSBjbS5kb2M7XG4gICAgdmFyIGN1ckZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIHZhciBzZWxGcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9jLnNlbC5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciByYW5nZSA9IGRvYy5zZWwucmFuZ2VzW2ldO1xuICAgICAgdmFyIGNvbGxhcHNlZCA9IHJhbmdlLmVtcHR5KCk7XG4gICAgICBpZiAoY29sbGFwc2VkIHx8IGNtLm9wdGlvbnMuc2hvd0N1cnNvcldoZW5TZWxlY3RpbmcpXG4gICAgICAgIGRyYXdTZWxlY3Rpb25DdXJzb3IoY20sIHJhbmdlLCBjdXJGcmFnbWVudCk7XG4gICAgICBpZiAoIWNvbGxhcHNlZClcbiAgICAgICAgZHJhd1NlbGVjdGlvblJhbmdlKGNtLCByYW5nZSwgc2VsRnJhZ21lbnQpO1xuICAgIH1cblxuICAgIC8vIE1vdmUgdGhlIGhpZGRlbiB0ZXh0YXJlYSBuZWFyIHRoZSBjdXJzb3IgdG8gcHJldmVudCBzY3JvbGxpbmcgYXJ0aWZhY3RzXG4gICAgaWYgKGNtLm9wdGlvbnMubW92ZUlucHV0V2l0aEN1cnNvcikge1xuICAgICAgdmFyIGhlYWRQb3MgPSBjdXJzb3JDb29yZHMoY20sIGRvYy5zZWwucHJpbWFyeSgpLmhlYWQsIFwiZGl2XCIpO1xuICAgICAgdmFyIHdyYXBPZmYgPSBkaXNwbGF5LndyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGxpbmVPZmYgPSBkaXNwbGF5LmxpbmVEaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgdG9wID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodCAtIDEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRQb3MudG9wICsgbGluZU9mZi50b3AgLSB3cmFwT2ZmLnRvcCkpO1xuICAgICAgdmFyIGxlZnQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihkaXNwbGF5LndyYXBwZXIuY2xpZW50V2lkdGggLSAxMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZFBvcy5sZWZ0ICsgbGluZU9mZi5sZWZ0IC0gd3JhcE9mZi5sZWZ0KSk7XG4gICAgICBkaXNwbGF5LmlucHV0RGl2LnN0eWxlLnRvcCA9IHRvcCArIFwicHhcIjtcbiAgICAgIGRpc3BsYXkuaW5wdXREaXYuc3R5bGUubGVmdCA9IGxlZnQgKyBcInB4XCI7XG4gICAgfVxuXG4gICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoZGlzcGxheS5jdXJzb3JEaXYsIGN1ckZyYWdtZW50KTtcbiAgICByZW1vdmVDaGlsZHJlbkFuZEFkZChkaXNwbGF5LnNlbGVjdGlvbkRpdiwgc2VsRnJhZ21lbnQpO1xuICB9XG5cbiAgLy8gRHJhd3MgYSBjdXJzb3IgZm9yIHRoZSBnaXZlbiByYW5nZVxuICBmdW5jdGlvbiBkcmF3U2VsZWN0aW9uQ3Vyc29yKGNtLCByYW5nZSwgb3V0cHV0KSB7XG4gICAgdmFyIHBvcyA9IGN1cnNvckNvb3JkcyhjbSwgcmFuZ2UuaGVhZCwgXCJkaXZcIik7XG5cbiAgICB2YXIgY3Vyc29yID0gb3V0cHV0LmFwcGVuZENoaWxkKGVsdChcImRpdlwiLCBcIlxcdTAwYTBcIiwgXCJDb2RlTWlycm9yLWN1cnNvclwiKSk7XG4gICAgY3Vyc29yLnN0eWxlLmxlZnQgPSBwb3MubGVmdCArIFwicHhcIjtcbiAgICBjdXJzb3Iuc3R5bGUudG9wID0gcG9zLnRvcCArIFwicHhcIjtcbiAgICBjdXJzb3Iuc3R5bGUuaGVpZ2h0ID0gTWF0aC5tYXgoMCwgcG9zLmJvdHRvbSAtIHBvcy50b3ApICogY20ub3B0aW9ucy5jdXJzb3JIZWlnaHQgKyBcInB4XCI7XG5cbiAgICBpZiAocG9zLm90aGVyKSB7XG4gICAgICAvLyBTZWNvbmRhcnkgY3Vyc29yLCBzaG93biB3aGVuIG9uIGEgJ2p1bXAnIGluIGJpLWRpcmVjdGlvbmFsIHRleHRcbiAgICAgIHZhciBvdGhlckN1cnNvciA9IG91dHB1dC5hcHBlbmRDaGlsZChlbHQoXCJkaXZcIiwgXCJcXHUwMGEwXCIsIFwiQ29kZU1pcnJvci1jdXJzb3IgQ29kZU1pcnJvci1zZWNvbmRhcnljdXJzb3JcIikpO1xuICAgICAgb3RoZXJDdXJzb3Iuc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgICBvdGhlckN1cnNvci5zdHlsZS5sZWZ0ID0gcG9zLm90aGVyLmxlZnQgKyBcInB4XCI7XG4gICAgICBvdGhlckN1cnNvci5zdHlsZS50b3AgPSBwb3Mub3RoZXIudG9wICsgXCJweFwiO1xuICAgICAgb3RoZXJDdXJzb3Iuc3R5bGUuaGVpZ2h0ID0gKHBvcy5vdGhlci5ib3R0b20gLSBwb3Mub3RoZXIudG9wKSAqIC44NSArIFwicHhcIjtcbiAgICB9XG4gIH1cblxuICAvLyBEcmF3cyB0aGUgZ2l2ZW4gcmFuZ2UgYXMgYSBoaWdobGlnaHRlZCBzZWxlY3Rpb25cbiAgZnVuY3Rpb24gZHJhd1NlbGVjdGlvblJhbmdlKGNtLCByYW5nZSwgb3V0cHV0KSB7XG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBkb2MgPSBjbS5kb2M7XG4gICAgdmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIHZhciBwYWRkaW5nID0gcGFkZGluZ0goY20uZGlzcGxheSksIGxlZnRTaWRlID0gcGFkZGluZy5sZWZ0LCByaWdodFNpZGUgPSBkaXNwbGF5LmxpbmVTcGFjZS5vZmZzZXRXaWR0aCAtIHBhZGRpbmcucmlnaHQ7XG5cbiAgICBmdW5jdGlvbiBhZGQobGVmdCwgdG9wLCB3aWR0aCwgYm90dG9tKSB7XG4gICAgICBpZiAodG9wIDwgMCkgdG9wID0gMDtcbiAgICAgIHRvcCA9IE1hdGgucm91bmQodG9wKTtcbiAgICAgIGJvdHRvbSA9IE1hdGgucm91bmQoYm90dG9tKTtcbiAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGVsdChcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3Itc2VsZWN0ZWRcIiwgXCJwb3NpdGlvbjogYWJzb2x1dGU7IGxlZnQ6IFwiICsgbGVmdCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJweDsgdG9wOiBcIiArIHRvcCArIFwicHg7IHdpZHRoOiBcIiArICh3aWR0aCA9PSBudWxsID8gcmlnaHRTaWRlIC0gbGVmdCA6IHdpZHRoKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJweDsgaGVpZ2h0OiBcIiArIChib3R0b20gLSB0b3ApICsgXCJweFwiKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHJhd0ZvckxpbmUobGluZSwgZnJvbUFyZywgdG9BcmcpIHtcbiAgICAgIHZhciBsaW5lT2JqID0gZ2V0TGluZShkb2MsIGxpbmUpO1xuICAgICAgdmFyIGxpbmVMZW4gPSBsaW5lT2JqLnRleHQubGVuZ3RoO1xuICAgICAgdmFyIHN0YXJ0LCBlbmQ7XG4gICAgICBmdW5jdGlvbiBjb29yZHMoY2gsIGJpYXMpIHtcbiAgICAgICAgcmV0dXJuIGNoYXJDb29yZHMoY20sIFBvcyhsaW5lLCBjaCksIFwiZGl2XCIsIGxpbmVPYmosIGJpYXMpO1xuICAgICAgfVxuXG4gICAgICBpdGVyYXRlQmlkaVNlY3Rpb25zKGdldE9yZGVyKGxpbmVPYmopLCBmcm9tQXJnIHx8IDAsIHRvQXJnID09IG51bGwgPyBsaW5lTGVuIDogdG9BcmcsIGZ1bmN0aW9uKGZyb20sIHRvLCBkaXIpIHtcbiAgICAgICAgdmFyIGxlZnRQb3MgPSBjb29yZHMoZnJvbSwgXCJsZWZ0XCIpLCByaWdodFBvcywgbGVmdCwgcmlnaHQ7XG4gICAgICAgIGlmIChmcm9tID09IHRvKSB7XG4gICAgICAgICAgcmlnaHRQb3MgPSBsZWZ0UG9zO1xuICAgICAgICAgIGxlZnQgPSByaWdodCA9IGxlZnRQb3MubGVmdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByaWdodFBvcyA9IGNvb3Jkcyh0byAtIDEsIFwicmlnaHRcIik7XG4gICAgICAgICAgaWYgKGRpciA9PSBcInJ0bFwiKSB7IHZhciB0bXAgPSBsZWZ0UG9zOyBsZWZ0UG9zID0gcmlnaHRQb3M7IHJpZ2h0UG9zID0gdG1wOyB9XG4gICAgICAgICAgbGVmdCA9IGxlZnRQb3MubGVmdDtcbiAgICAgICAgICByaWdodCA9IHJpZ2h0UG9zLnJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcm9tQXJnID09IG51bGwgJiYgZnJvbSA9PSAwKSBsZWZ0ID0gbGVmdFNpZGU7XG4gICAgICAgIGlmIChyaWdodFBvcy50b3AgLSBsZWZ0UG9zLnRvcCA+IDMpIHsgLy8gRGlmZmVyZW50IGxpbmVzLCBkcmF3IHRvcCBwYXJ0XG4gICAgICAgICAgYWRkKGxlZnQsIGxlZnRQb3MudG9wLCBudWxsLCBsZWZ0UG9zLmJvdHRvbSk7XG4gICAgICAgICAgbGVmdCA9IGxlZnRTaWRlO1xuICAgICAgICAgIGlmIChsZWZ0UG9zLmJvdHRvbSA8IHJpZ2h0UG9zLnRvcCkgYWRkKGxlZnQsIGxlZnRQb3MuYm90dG9tLCBudWxsLCByaWdodFBvcy50b3ApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b0FyZyA9PSBudWxsICYmIHRvID09IGxpbmVMZW4pIHJpZ2h0ID0gcmlnaHRTaWRlO1xuICAgICAgICBpZiAoIXN0YXJ0IHx8IGxlZnRQb3MudG9wIDwgc3RhcnQudG9wIHx8IGxlZnRQb3MudG9wID09IHN0YXJ0LnRvcCAmJiBsZWZ0UG9zLmxlZnQgPCBzdGFydC5sZWZ0KVxuICAgICAgICAgIHN0YXJ0ID0gbGVmdFBvcztcbiAgICAgICAgaWYgKCFlbmQgfHwgcmlnaHRQb3MuYm90dG9tID4gZW5kLmJvdHRvbSB8fCByaWdodFBvcy5ib3R0b20gPT0gZW5kLmJvdHRvbSAmJiByaWdodFBvcy5yaWdodCA+IGVuZC5yaWdodClcbiAgICAgICAgICBlbmQgPSByaWdodFBvcztcbiAgICAgICAgaWYgKGxlZnQgPCBsZWZ0U2lkZSArIDEpIGxlZnQgPSBsZWZ0U2lkZTtcbiAgICAgICAgYWRkKGxlZnQsIHJpZ2h0UG9zLnRvcCwgcmlnaHQgLSBsZWZ0LCByaWdodFBvcy5ib3R0b20pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4ge3N0YXJ0OiBzdGFydCwgZW5kOiBlbmR9O1xuICAgIH1cblxuICAgIHZhciBzRnJvbSA9IHJhbmdlLmZyb20oKSwgc1RvID0gcmFuZ2UudG8oKTtcbiAgICBpZiAoc0Zyb20ubGluZSA9PSBzVG8ubGluZSkge1xuICAgICAgZHJhd0ZvckxpbmUoc0Zyb20ubGluZSwgc0Zyb20uY2gsIHNUby5jaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBmcm9tTGluZSA9IGdldExpbmUoZG9jLCBzRnJvbS5saW5lKSwgdG9MaW5lID0gZ2V0TGluZShkb2MsIHNUby5saW5lKTtcbiAgICAgIHZhciBzaW5nbGVWTGluZSA9IHZpc3VhbExpbmUoZnJvbUxpbmUpID09IHZpc3VhbExpbmUodG9MaW5lKTtcbiAgICAgIHZhciBsZWZ0RW5kID0gZHJhd0ZvckxpbmUoc0Zyb20ubGluZSwgc0Zyb20uY2gsIHNpbmdsZVZMaW5lID8gZnJvbUxpbmUudGV4dC5sZW5ndGggKyAxIDogbnVsbCkuZW5kO1xuICAgICAgdmFyIHJpZ2h0U3RhcnQgPSBkcmF3Rm9yTGluZShzVG8ubGluZSwgc2luZ2xlVkxpbmUgPyAwIDogbnVsbCwgc1RvLmNoKS5zdGFydDtcbiAgICAgIGlmIChzaW5nbGVWTGluZSkge1xuICAgICAgICBpZiAobGVmdEVuZC50b3AgPCByaWdodFN0YXJ0LnRvcCAtIDIpIHtcbiAgICAgICAgICBhZGQobGVmdEVuZC5yaWdodCwgbGVmdEVuZC50b3AsIG51bGwsIGxlZnRFbmQuYm90dG9tKTtcbiAgICAgICAgICBhZGQobGVmdFNpZGUsIHJpZ2h0U3RhcnQudG9wLCByaWdodFN0YXJ0LmxlZnQsIHJpZ2h0U3RhcnQuYm90dG9tKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGQobGVmdEVuZC5yaWdodCwgbGVmdEVuZC50b3AsIHJpZ2h0U3RhcnQubGVmdCAtIGxlZnRFbmQucmlnaHQsIGxlZnRFbmQuYm90dG9tKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxlZnRFbmQuYm90dG9tIDwgcmlnaHRTdGFydC50b3ApXG4gICAgICAgIGFkZChsZWZ0U2lkZSwgbGVmdEVuZC5ib3R0b20sIG51bGwsIHJpZ2h0U3RhcnQudG9wKTtcbiAgICB9XG5cbiAgICBvdXRwdXQuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuICB9XG5cbiAgLy8gQ3Vyc29yLWJsaW5raW5nXG4gIGZ1bmN0aW9uIHJlc3RhcnRCbGluayhjbSkge1xuICAgIGlmICghY20uc3RhdGUuZm9jdXNlZCkgcmV0dXJuO1xuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICBjbGVhckludGVydmFsKGRpc3BsYXkuYmxpbmtlcik7XG4gICAgdmFyIG9uID0gdHJ1ZTtcbiAgICBkaXNwbGF5LmN1cnNvckRpdi5zdHlsZS52aXNpYmlsaXR5ID0gXCJcIjtcbiAgICBpZiAoY20ub3B0aW9ucy5jdXJzb3JCbGlua1JhdGUgPiAwKVxuICAgICAgZGlzcGxheS5ibGlua2VyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgIGRpc3BsYXkuY3Vyc29yRGl2LnN0eWxlLnZpc2liaWxpdHkgPSAob24gPSAhb24pID8gXCJcIiA6IFwiaGlkZGVuXCI7XG4gICAgICB9LCBjbS5vcHRpb25zLmN1cnNvckJsaW5rUmF0ZSk7XG4gIH1cblxuICAvLyBISUdITElHSFQgV09SS0VSXG5cbiAgZnVuY3Rpb24gc3RhcnRXb3JrZXIoY20sIHRpbWUpIHtcbiAgICBpZiAoY20uZG9jLm1vZGUuc3RhcnRTdGF0ZSAmJiBjbS5kb2MuZnJvbnRpZXIgPCBjbS5kaXNwbGF5LnZpZXdUbylcbiAgICAgIGNtLnN0YXRlLmhpZ2hsaWdodC5zZXQodGltZSwgYmluZChoaWdobGlnaHRXb3JrZXIsIGNtKSk7XG4gIH1cblxuICBmdW5jdGlvbiBoaWdobGlnaHRXb3JrZXIoY20pIHtcbiAgICB2YXIgZG9jID0gY20uZG9jO1xuICAgIGlmIChkb2MuZnJvbnRpZXIgPCBkb2MuZmlyc3QpIGRvYy5mcm9udGllciA9IGRvYy5maXJzdDtcbiAgICBpZiAoZG9jLmZyb250aWVyID49IGNtLmRpc3BsYXkudmlld1RvKSByZXR1cm47XG4gICAgdmFyIGVuZCA9ICtuZXcgRGF0ZSArIGNtLm9wdGlvbnMud29ya1RpbWU7XG4gICAgdmFyIHN0YXRlID0gY29weVN0YXRlKGRvYy5tb2RlLCBnZXRTdGF0ZUJlZm9yZShjbSwgZG9jLmZyb250aWVyKSk7XG5cbiAgICBydW5Jbk9wKGNtLCBmdW5jdGlvbigpIHtcbiAgICBkb2MuaXRlcihkb2MuZnJvbnRpZXIsIE1hdGgubWluKGRvYy5maXJzdCArIGRvYy5zaXplLCBjbS5kaXNwbGF5LnZpZXdUbyArIDUwMCksIGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIGlmIChkb2MuZnJvbnRpZXIgPj0gY20uZGlzcGxheS52aWV3RnJvbSkgeyAvLyBWaXNpYmxlXG4gICAgICAgIHZhciBvbGRTdHlsZXMgPSBsaW5lLnN0eWxlcztcbiAgICAgICAgdmFyIGhpZ2hsaWdodGVkID0gaGlnaGxpZ2h0TGluZShjbSwgbGluZSwgc3RhdGUsIHRydWUpO1xuICAgICAgICBsaW5lLnN0eWxlcyA9IGhpZ2hsaWdodGVkLnN0eWxlcztcbiAgICAgICAgaWYgKGhpZ2hsaWdodGVkLmNsYXNzZXMpIGxpbmUuc3R5bGVDbGFzc2VzID0gaGlnaGxpZ2h0ZWQuY2xhc3NlcztcbiAgICAgICAgZWxzZSBpZiAobGluZS5zdHlsZUNsYXNzZXMpIGxpbmUuc3R5bGVDbGFzc2VzID0gbnVsbDtcbiAgICAgICAgdmFyIGlzY2hhbmdlID0gIW9sZFN0eWxlcyB8fCBvbGRTdHlsZXMubGVuZ3RoICE9IGxpbmUuc3R5bGVzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7ICFpc2NoYW5nZSAmJiBpIDwgb2xkU3R5bGVzLmxlbmd0aDsgKytpKSBpc2NoYW5nZSA9IG9sZFN0eWxlc1tpXSAhPSBsaW5lLnN0eWxlc1tpXTtcbiAgICAgICAgaWYgKGlzY2hhbmdlKSByZWdMaW5lQ2hhbmdlKGNtLCBkb2MuZnJvbnRpZXIsIFwidGV4dFwiKTtcbiAgICAgICAgbGluZS5zdGF0ZUFmdGVyID0gY29weVN0YXRlKGRvYy5tb2RlLCBzdGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzTGluZShjbSwgbGluZS50ZXh0LCBzdGF0ZSk7XG4gICAgICAgIGxpbmUuc3RhdGVBZnRlciA9IGRvYy5mcm9udGllciAlIDUgPT0gMCA/IGNvcHlTdGF0ZShkb2MubW9kZSwgc3RhdGUpIDogbnVsbDtcbiAgICAgIH1cbiAgICAgICsrZG9jLmZyb250aWVyO1xuICAgICAgaWYgKCtuZXcgRGF0ZSA+IGVuZCkge1xuICAgICAgICBzdGFydFdvcmtlcihjbSwgY20ub3B0aW9ucy53b3JrRGVsYXkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEZpbmRzIHRoZSBsaW5lIHRvIHN0YXJ0IHdpdGggd2hlbiBzdGFydGluZyBhIHBhcnNlLiBUcmllcyB0b1xuICAvLyBmaW5kIGEgbGluZSB3aXRoIGEgc3RhdGVBZnRlciwgc28gdGhhdCBpdCBjYW4gc3RhcnQgd2l0aCBhXG4gIC8vIHZhbGlkIHN0YXRlLiBJZiB0aGF0IGZhaWxzLCBpdCByZXR1cm5zIHRoZSBsaW5lIHdpdGggdGhlXG4gIC8vIHNtYWxsZXN0IGluZGVudGF0aW9uLCB3aGljaCB0ZW5kcyB0byBuZWVkIHRoZSBsZWFzdCBjb250ZXh0IHRvXG4gIC8vIHBhcnNlIGNvcnJlY3RseS5cbiAgZnVuY3Rpb24gZmluZFN0YXJ0TGluZShjbSwgbiwgcHJlY2lzZSkge1xuICAgIHZhciBtaW5pbmRlbnQsIG1pbmxpbmUsIGRvYyA9IGNtLmRvYztcbiAgICB2YXIgbGltID0gcHJlY2lzZSA/IC0xIDogbiAtIChjbS5kb2MubW9kZS5pbm5lck1vZGUgPyAxMDAwIDogMTAwKTtcbiAgICBmb3IgKHZhciBzZWFyY2ggPSBuOyBzZWFyY2ggPiBsaW07IC0tc2VhcmNoKSB7XG4gICAgICBpZiAoc2VhcmNoIDw9IGRvYy5maXJzdCkgcmV0dXJuIGRvYy5maXJzdDtcbiAgICAgIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIHNlYXJjaCAtIDEpO1xuICAgICAgaWYgKGxpbmUuc3RhdGVBZnRlciAmJiAoIXByZWNpc2UgfHwgc2VhcmNoIDw9IGRvYy5mcm9udGllcikpIHJldHVybiBzZWFyY2g7XG4gICAgICB2YXIgaW5kZW50ZWQgPSBjb3VudENvbHVtbihsaW5lLnRleHQsIG51bGwsIGNtLm9wdGlvbnMudGFiU2l6ZSk7XG4gICAgICBpZiAobWlubGluZSA9PSBudWxsIHx8IG1pbmluZGVudCA+IGluZGVudGVkKSB7XG4gICAgICAgIG1pbmxpbmUgPSBzZWFyY2ggLSAxO1xuICAgICAgICBtaW5pbmRlbnQgPSBpbmRlbnRlZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1pbmxpbmU7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTdGF0ZUJlZm9yZShjbSwgbiwgcHJlY2lzZSkge1xuICAgIHZhciBkb2MgPSBjbS5kb2MsIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xuICAgIGlmICghZG9jLm1vZGUuc3RhcnRTdGF0ZSkgcmV0dXJuIHRydWU7XG4gICAgdmFyIHBvcyA9IGZpbmRTdGFydExpbmUoY20sIG4sIHByZWNpc2UpLCBzdGF0ZSA9IHBvcyA+IGRvYy5maXJzdCAmJiBnZXRMaW5lKGRvYywgcG9zLTEpLnN0YXRlQWZ0ZXI7XG4gICAgaWYgKCFzdGF0ZSkgc3RhdGUgPSBzdGFydFN0YXRlKGRvYy5tb2RlKTtcbiAgICBlbHNlIHN0YXRlID0gY29weVN0YXRlKGRvYy5tb2RlLCBzdGF0ZSk7XG4gICAgZG9jLml0ZXIocG9zLCBuLCBmdW5jdGlvbihsaW5lKSB7XG4gICAgICBwcm9jZXNzTGluZShjbSwgbGluZS50ZXh0LCBzdGF0ZSk7XG4gICAgICB2YXIgc2F2ZSA9IHBvcyA9PSBuIC0gMSB8fCBwb3MgJSA1ID09IDAgfHwgcG9zID49IGRpc3BsYXkudmlld0Zyb20gJiYgcG9zIDwgZGlzcGxheS52aWV3VG87XG4gICAgICBsaW5lLnN0YXRlQWZ0ZXIgPSBzYXZlID8gY29weVN0YXRlKGRvYy5tb2RlLCBzdGF0ZSkgOiBudWxsO1xuICAgICAgKytwb3M7XG4gICAgfSk7XG4gICAgaWYgKHByZWNpc2UpIGRvYy5mcm9udGllciA9IHBvcztcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICAvLyBQT1NJVElPTiBNRUFTVVJFTUVOVFxuXG4gIGZ1bmN0aW9uIHBhZGRpbmdUb3AoZGlzcGxheSkge3JldHVybiBkaXNwbGF5LmxpbmVTcGFjZS5vZmZzZXRUb3A7fVxuICBmdW5jdGlvbiBwYWRkaW5nVmVydChkaXNwbGF5KSB7cmV0dXJuIGRpc3BsYXkubW92ZXIub2Zmc2V0SGVpZ2h0IC0gZGlzcGxheS5saW5lU3BhY2Uub2Zmc2V0SGVpZ2h0O31cbiAgZnVuY3Rpb24gcGFkZGluZ0goZGlzcGxheSkge1xuICAgIGlmIChkaXNwbGF5LmNhY2hlZFBhZGRpbmdIKSByZXR1cm4gZGlzcGxheS5jYWNoZWRQYWRkaW5nSDtcbiAgICB2YXIgZSA9IHJlbW92ZUNoaWxkcmVuQW5kQWRkKGRpc3BsYXkubWVhc3VyZSwgZWx0KFwicHJlXCIsIFwieFwiKSk7XG4gICAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUgPyB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlKSA6IGUuY3VycmVudFN0eWxlO1xuICAgIHZhciBkYXRhID0ge2xlZnQ6IHBhcnNlSW50KHN0eWxlLnBhZGRpbmdMZWZ0KSwgcmlnaHQ6IHBhcnNlSW50KHN0eWxlLnBhZGRpbmdSaWdodCl9O1xuICAgIGlmICghaXNOYU4oZGF0YS5sZWZ0KSAmJiAhaXNOYU4oZGF0YS5yaWdodCkpIGRpc3BsYXkuY2FjaGVkUGFkZGluZ0ggPSBkYXRhO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgLy8gRW5zdXJlIHRoZSBsaW5lVmlldy53cmFwcGluZy5oZWlnaHRzIGFycmF5IGlzIHBvcHVsYXRlZC4gVGhpcyBpc1xuICAvLyBhbiBhcnJheSBvZiBib3R0b20gb2Zmc2V0cyBmb3IgdGhlIGxpbmVzIHRoYXQgbWFrZSB1cCBhIGRyYXduXG4gIC8vIGxpbmUuIFdoZW4gbGluZVdyYXBwaW5nIGlzIG9uLCB0aGVyZSBtaWdodCBiZSBtb3JlIHRoYW4gb25lXG4gIC8vIGhlaWdodC5cbiAgZnVuY3Rpb24gZW5zdXJlTGluZUhlaWdodHMoY20sIGxpbmVWaWV3LCByZWN0KSB7XG4gICAgdmFyIHdyYXBwaW5nID0gY20ub3B0aW9ucy5saW5lV3JhcHBpbmc7XG4gICAgdmFyIGN1cldpZHRoID0gd3JhcHBpbmcgJiYgY20uZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aDtcbiAgICBpZiAoIWxpbmVWaWV3Lm1lYXN1cmUuaGVpZ2h0cyB8fCB3cmFwcGluZyAmJiBsaW5lVmlldy5tZWFzdXJlLndpZHRoICE9IGN1cldpZHRoKSB7XG4gICAgICB2YXIgaGVpZ2h0cyA9IGxpbmVWaWV3Lm1lYXN1cmUuaGVpZ2h0cyA9IFtdO1xuICAgICAgaWYgKHdyYXBwaW5nKSB7XG4gICAgICAgIGxpbmVWaWV3Lm1lYXN1cmUud2lkdGggPSBjdXJXaWR0aDtcbiAgICAgICAgdmFyIHJlY3RzID0gbGluZVZpZXcudGV4dC5maXJzdENoaWxkLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgdmFyIGN1ciA9IHJlY3RzW2ldLCBuZXh0ID0gcmVjdHNbaSArIDFdO1xuICAgICAgICAgIGlmIChNYXRoLmFicyhjdXIuYm90dG9tIC0gbmV4dC5ib3R0b20pID4gMilcbiAgICAgICAgICAgIGhlaWdodHMucHVzaCgoY3VyLmJvdHRvbSArIG5leHQudG9wKSAvIDIgLSByZWN0LnRvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGhlaWdodHMucHVzaChyZWN0LmJvdHRvbSAtIHJlY3QudG9wKTtcbiAgICB9XG4gIH1cblxuICAvLyBGaW5kIGEgbGluZSBtYXAgKG1hcHBpbmcgY2hhcmFjdGVyIG9mZnNldHMgdG8gdGV4dCBub2RlcykgYW5kIGFcbiAgLy8gbWVhc3VyZW1lbnQgY2FjaGUgZm9yIHRoZSBnaXZlbiBsaW5lIG51bWJlci4gKEEgbGluZSB2aWV3IG1pZ2h0XG4gIC8vIGNvbnRhaW4gbXVsdGlwbGUgbGluZXMgd2hlbiBjb2xsYXBzZWQgcmFuZ2VzIGFyZSBwcmVzZW50LilcbiAgZnVuY3Rpb24gbWFwRnJvbUxpbmVWaWV3KGxpbmVWaWV3LCBsaW5lLCBsaW5lTikge1xuICAgIGlmIChsaW5lVmlldy5saW5lID09IGxpbmUpXG4gICAgICByZXR1cm4ge21hcDogbGluZVZpZXcubWVhc3VyZS5tYXAsIGNhY2hlOiBsaW5lVmlldy5tZWFzdXJlLmNhY2hlfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVWaWV3LnJlc3QubGVuZ3RoOyBpKyspXG4gICAgICBpZiAobGluZVZpZXcucmVzdFtpXSA9PSBsaW5lKVxuICAgICAgICByZXR1cm4ge21hcDogbGluZVZpZXcubWVhc3VyZS5tYXBzW2ldLCBjYWNoZTogbGluZVZpZXcubWVhc3VyZS5jYWNoZXNbaV19O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZVZpZXcucmVzdC5sZW5ndGg7IGkrKylcbiAgICAgIGlmIChsaW5lTm8obGluZVZpZXcucmVzdFtpXSkgPiBsaW5lTilcbiAgICAgICAgcmV0dXJuIHttYXA6IGxpbmVWaWV3Lm1lYXN1cmUubWFwc1tpXSwgY2FjaGU6IGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGVzW2ldLCBiZWZvcmU6IHRydWV9O1xuICB9XG5cbiAgLy8gUmVuZGVyIGEgbGluZSBpbnRvIHRoZSBoaWRkZW4gbm9kZSBkaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQuIFVzZWRcbiAgLy8gd2hlbiBtZWFzdXJlbWVudCBpcyBuZWVkZWQgZm9yIGEgbGluZSB0aGF0J3Mgbm90IGluIHRoZSB2aWV3cG9ydC5cbiAgZnVuY3Rpb24gdXBkYXRlRXh0ZXJuYWxNZWFzdXJlbWVudChjbSwgbGluZSkge1xuICAgIGxpbmUgPSB2aXN1YWxMaW5lKGxpbmUpO1xuICAgIHZhciBsaW5lTiA9IGxpbmVObyhsaW5lKTtcbiAgICB2YXIgdmlldyA9IGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCA9IG5ldyBMaW5lVmlldyhjbS5kb2MsIGxpbmUsIGxpbmVOKTtcbiAgICB2aWV3LmxpbmVOID0gbGluZU47XG4gICAgdmFyIGJ1aWx0ID0gdmlldy5idWlsdCA9IGJ1aWxkTGluZUNvbnRlbnQoY20sIHZpZXcpO1xuICAgIHZpZXcudGV4dCA9IGJ1aWx0LnByZTtcbiAgICByZW1vdmVDaGlsZHJlbkFuZEFkZChjbS5kaXNwbGF5LmxpbmVNZWFzdXJlLCBidWlsdC5wcmUpO1xuICAgIHJldHVybiB2aWV3O1xuICB9XG5cbiAgLy8gR2V0IGEge3RvcCwgYm90dG9tLCBsZWZ0LCByaWdodH0gYm94IChpbiBsaW5lLWxvY2FsIGNvb3JkaW5hdGVzKVxuICAvLyBmb3IgYSBnaXZlbiBjaGFyYWN0ZXIuXG4gIGZ1bmN0aW9uIG1lYXN1cmVDaGFyKGNtLCBsaW5lLCBjaCwgYmlhcykge1xuICAgIHJldHVybiBtZWFzdXJlQ2hhclByZXBhcmVkKGNtLCBwcmVwYXJlTWVhc3VyZUZvckxpbmUoY20sIGxpbmUpLCBjaCwgYmlhcyk7XG4gIH1cblxuICAvLyBGaW5kIGEgbGluZSB2aWV3IHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIGdpdmVuIGxpbmUgbnVtYmVyLlxuICBmdW5jdGlvbiBmaW5kVmlld0ZvckxpbmUoY20sIGxpbmVOKSB7XG4gICAgaWYgKGxpbmVOID49IGNtLmRpc3BsYXkudmlld0Zyb20gJiYgbGluZU4gPCBjbS5kaXNwbGF5LnZpZXdUbylcbiAgICAgIHJldHVybiBjbS5kaXNwbGF5LnZpZXdbZmluZFZpZXdJbmRleChjbSwgbGluZU4pXTtcbiAgICB2YXIgZXh0ID0gY20uZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkO1xuICAgIGlmIChleHQgJiYgbGluZU4gPj0gZXh0LmxpbmVOICYmIGxpbmVOIDwgZXh0LmxpbmVOICsgZXh0LnNpemUpXG4gICAgICByZXR1cm4gZXh0O1xuICB9XG5cbiAgLy8gTWVhc3VyZW1lbnQgY2FuIGJlIHNwbGl0IGluIHR3byBzdGVwcywgdGhlIHNldC11cCB3b3JrIHRoYXRcbiAgLy8gYXBwbGllcyB0byB0aGUgd2hvbGUgbGluZSwgYW5kIHRoZSBtZWFzdXJlbWVudCBvZiB0aGUgYWN0dWFsXG4gIC8vIGNoYXJhY3Rlci4gRnVuY3Rpb25zIGxpa2UgY29vcmRzQ2hhciwgdGhhdCBuZWVkIHRvIGRvIGEgbG90IG9mXG4gIC8vIG1lYXN1cmVtZW50cyBpbiBhIHJvdywgY2FuIHRodXMgZW5zdXJlIHRoYXQgdGhlIHNldC11cCB3b3JrIGlzXG4gIC8vIG9ubHkgZG9uZSBvbmNlLlxuICBmdW5jdGlvbiBwcmVwYXJlTWVhc3VyZUZvckxpbmUoY20sIGxpbmUpIHtcbiAgICB2YXIgbGluZU4gPSBsaW5lTm8obGluZSk7XG4gICAgdmFyIHZpZXcgPSBmaW5kVmlld0ZvckxpbmUoY20sIGxpbmVOKTtcbiAgICBpZiAodmlldyAmJiAhdmlldy50ZXh0KVxuICAgICAgdmlldyA9IG51bGw7XG4gICAgZWxzZSBpZiAodmlldyAmJiB2aWV3LmNoYW5nZXMpXG4gICAgICB1cGRhdGVMaW5lRm9yQ2hhbmdlcyhjbSwgdmlldywgbGluZU4sIGdldERpbWVuc2lvbnMoY20pKTtcbiAgICBpZiAoIXZpZXcpXG4gICAgICB2aWV3ID0gdXBkYXRlRXh0ZXJuYWxNZWFzdXJlbWVudChjbSwgbGluZSk7XG5cbiAgICB2YXIgaW5mbyA9IG1hcEZyb21MaW5lVmlldyh2aWV3LCBsaW5lLCBsaW5lTik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmU6IGxpbmUsIHZpZXc6IHZpZXcsIHJlY3Q6IG51bGwsXG4gICAgICBtYXA6IGluZm8ubWFwLCBjYWNoZTogaW5mby5jYWNoZSwgYmVmb3JlOiBpbmZvLmJlZm9yZSxcbiAgICAgIGhhc0hlaWdodHM6IGZhbHNlXG4gICAgfTtcbiAgfVxuXG4gIC8vIEdpdmVuIGEgcHJlcGFyZWQgbWVhc3VyZW1lbnQgb2JqZWN0LCBtZWFzdXJlcyB0aGUgcG9zaXRpb24gb2YgYW5cbiAgLy8gYWN0dWFsIGNoYXJhY3RlciAob3IgZmV0Y2hlcyBpdCBmcm9tIHRoZSBjYWNoZSkuXG4gIGZ1bmN0aW9uIG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXBhcmVkLCBjaCwgYmlhcykge1xuICAgIGlmIChwcmVwYXJlZC5iZWZvcmUpIGNoID0gLTE7XG4gICAgdmFyIGtleSA9IGNoICsgKGJpYXMgfHwgXCJcIiksIGZvdW5kO1xuICAgIGlmIChwcmVwYXJlZC5jYWNoZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBmb3VuZCA9IHByZXBhcmVkLmNhY2hlW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghcHJlcGFyZWQucmVjdClcbiAgICAgICAgcHJlcGFyZWQucmVjdCA9IHByZXBhcmVkLnZpZXcudGV4dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGlmICghcHJlcGFyZWQuaGFzSGVpZ2h0cykge1xuICAgICAgICBlbnN1cmVMaW5lSGVpZ2h0cyhjbSwgcHJlcGFyZWQudmlldywgcHJlcGFyZWQucmVjdCk7XG4gICAgICAgIHByZXBhcmVkLmhhc0hlaWdodHMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgZm91bmQgPSBtZWFzdXJlQ2hhcklubmVyKGNtLCBwcmVwYXJlZCwgY2gsIGJpYXMpO1xuICAgICAgaWYgKCFmb3VuZC5ib2d1cykgcHJlcGFyZWQuY2FjaGVba2V5XSA9IGZvdW5kO1xuICAgIH1cbiAgICByZXR1cm4ge2xlZnQ6IGZvdW5kLmxlZnQsIHJpZ2h0OiBmb3VuZC5yaWdodCwgdG9wOiBmb3VuZC50b3AsIGJvdHRvbTogZm91bmQuYm90dG9tfTtcbiAgfVxuXG4gIHZhciBudWxsUmVjdCA9IHtsZWZ0OiAwLCByaWdodDogMCwgdG9wOiAwLCBib3R0b206IDB9O1xuXG4gIGZ1bmN0aW9uIG1lYXN1cmVDaGFySW5uZXIoY20sIHByZXBhcmVkLCBjaCwgYmlhcykge1xuICAgIHZhciBtYXAgPSBwcmVwYXJlZC5tYXA7XG5cbiAgICB2YXIgbm9kZSwgc3RhcnQsIGVuZCwgY29sbGFwc2U7XG4gICAgLy8gRmlyc3QsIHNlYXJjaCB0aGUgbGluZSBtYXAgZm9yIHRoZSB0ZXh0IG5vZGUgY29ycmVzcG9uZGluZyB0byxcbiAgICAvLyBvciBjbG9zZXN0IHRvLCB0aGUgdGFyZ2V0IGNoYXJhY3Rlci5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcC5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgdmFyIG1TdGFydCA9IG1hcFtpXSwgbUVuZCA9IG1hcFtpICsgMV07XG4gICAgICBpZiAoY2ggPCBtU3RhcnQpIHtcbiAgICAgICAgc3RhcnQgPSAwOyBlbmQgPSAxO1xuICAgICAgICBjb2xsYXBzZSA9IFwibGVmdFwiO1xuICAgICAgfSBlbHNlIGlmIChjaCA8IG1FbmQpIHtcbiAgICAgICAgc3RhcnQgPSBjaCAtIG1TdGFydDtcbiAgICAgICAgZW5kID0gc3RhcnQgKyAxO1xuICAgICAgfSBlbHNlIGlmIChpID09IG1hcC5sZW5ndGggLSAzIHx8IGNoID09IG1FbmQgJiYgbWFwW2kgKyAzXSA+IGNoKSB7XG4gICAgICAgIGVuZCA9IG1FbmQgLSBtU3RhcnQ7XG4gICAgICAgIHN0YXJ0ID0gZW5kIC0gMTtcbiAgICAgICAgaWYgKGNoID49IG1FbmQpIGNvbGxhcHNlID0gXCJyaWdodFwiO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgbm9kZSA9IG1hcFtpICsgMl07XG4gICAgICAgIGlmIChtU3RhcnQgPT0gbUVuZCAmJiBiaWFzID09IChub2RlLmluc2VydExlZnQgPyBcImxlZnRcIiA6IFwicmlnaHRcIikpXG4gICAgICAgICAgY29sbGFwc2UgPSBiaWFzO1xuICAgICAgICBpZiAoYmlhcyA9PSBcImxlZnRcIiAmJiBzdGFydCA9PSAwKVxuICAgICAgICAgIHdoaWxlIChpICYmIG1hcFtpIC0gMl0gPT0gbWFwW2kgLSAzXSAmJiBtYXBbaSAtIDFdLmluc2VydExlZnQpIHtcbiAgICAgICAgICAgIG5vZGUgPSBtYXBbKGkgLT0gMykgKyAyXTtcbiAgICAgICAgICAgIGNvbGxhcHNlID0gXCJsZWZ0XCI7XG4gICAgICAgICAgfVxuICAgICAgICBpZiAoYmlhcyA9PSBcInJpZ2h0XCIgJiYgc3RhcnQgPT0gbUVuZCAtIG1TdGFydClcbiAgICAgICAgICB3aGlsZSAoaSA8IG1hcC5sZW5ndGggLSAzICYmIG1hcFtpICsgM10gPT0gbWFwW2kgKyA0XSAmJiAhbWFwW2kgKyA1XS5pbnNlcnRMZWZ0KSB7XG4gICAgICAgICAgICBub2RlID0gbWFwWyhpICs9IDMpICsgMl07XG4gICAgICAgICAgICBjb2xsYXBzZSA9IFwicmlnaHRcIjtcbiAgICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZWN0O1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMpIHsgLy8gSWYgaXQgaXMgYSB0ZXh0IG5vZGUsIHVzZSBhIHJhbmdlIHRvIHJldHJpZXZlIHRoZSBjb29yZGluYXRlcy5cbiAgICAgIHdoaWxlIChzdGFydCAmJiBpc0V4dGVuZGluZ0NoYXIocHJlcGFyZWQubGluZS50ZXh0LmNoYXJBdChtU3RhcnQgKyBzdGFydCkpKSAtLXN0YXJ0O1xuICAgICAgd2hpbGUgKG1TdGFydCArIGVuZCA8IG1FbmQgJiYgaXNFeHRlbmRpbmdDaGFyKHByZXBhcmVkLmxpbmUudGV4dC5jaGFyQXQobVN0YXJ0ICsgZW5kKSkpICsrZW5kO1xuICAgICAgaWYgKGllX3VwdG84ICYmIHN0YXJ0ID09IDAgJiYgZW5kID09IG1FbmQgLSBtU3RhcnQpIHtcbiAgICAgICAgcmVjdCA9IG5vZGUucGFyZW50Tm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIH0gZWxzZSBpZiAoaWUgJiYgY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHtcbiAgICAgICAgdmFyIHJlY3RzID0gcmFuZ2Uobm9kZSwgc3RhcnQsIGVuZCkuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgICAgaWYgKHJlY3RzLmxlbmd0aClcbiAgICAgICAgICByZWN0ID0gcmVjdHNbYmlhcyA9PSBcInJpZ2h0XCIgPyByZWN0cy5sZW5ndGggLSAxIDogMF07XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZWN0ID0gbnVsbFJlY3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWN0ID0gcmFuZ2Uobm9kZSwgc3RhcnQsIGVuZCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gSWYgaXQgaXMgYSB3aWRnZXQsIHNpbXBseSBnZXQgdGhlIGJveCBmb3IgdGhlIHdob2xlIHdpZGdldC5cbiAgICAgIGlmIChzdGFydCA+IDApIGNvbGxhcHNlID0gYmlhcyA9IFwicmlnaHRcIjtcbiAgICAgIHZhciByZWN0cztcbiAgICAgIGlmIChjbS5vcHRpb25zLmxpbmVXcmFwcGluZyAmJiAocmVjdHMgPSBub2RlLmdldENsaWVudFJlY3RzKCkpLmxlbmd0aCA+IDEpXG4gICAgICAgIHJlY3QgPSByZWN0c1tiaWFzID09IFwicmlnaHRcIiA/IHJlY3RzLmxlbmd0aCAtIDEgOiAwXTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfVxuICAgIGlmIChpZV91cHRvOCAmJiAhc3RhcnQgJiYgKCFyZWN0IHx8ICFyZWN0LmxlZnQgJiYgIXJlY3QucmlnaHQpKSB7XG4gICAgICB2YXIgclNwYW4gPSBub2RlLnBhcmVudE5vZGUuZ2V0Q2xpZW50UmVjdHMoKVswXTtcbiAgICAgIGlmIChyU3BhbilcbiAgICAgICAgcmVjdCA9IHtsZWZ0OiByU3Bhbi5sZWZ0LCByaWdodDogclNwYW4ubGVmdCArIGNoYXJXaWR0aChjbS5kaXNwbGF5KSwgdG9wOiByU3Bhbi50b3AsIGJvdHRvbTogclNwYW4uYm90dG9tfTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmVjdCA9IG51bGxSZWN0O1xuICAgIH1cblxuICAgIHZhciB0b3AsIGJvdCA9IChyZWN0LmJvdHRvbSArIHJlY3QudG9wKSAvIDIgLSBwcmVwYXJlZC5yZWN0LnRvcDtcbiAgICB2YXIgaGVpZ2h0cyA9IHByZXBhcmVkLnZpZXcubWVhc3VyZS5oZWlnaHRzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGVpZ2h0cy5sZW5ndGggLSAxOyBpKyspXG4gICAgICBpZiAoYm90IDwgaGVpZ2h0c1tpXSkgYnJlYWs7XG4gICAgdG9wID0gaSA/IGhlaWdodHNbaSAtIDFdIDogMDsgYm90ID0gaGVpZ2h0c1tpXTtcbiAgICB2YXIgcmVzdWx0ID0ge2xlZnQ6IChjb2xsYXBzZSA9PSBcInJpZ2h0XCIgPyByZWN0LnJpZ2h0IDogcmVjdC5sZWZ0KSAtIHByZXBhcmVkLnJlY3QubGVmdCxcbiAgICAgICAgICAgICAgICAgIHJpZ2h0OiAoY29sbGFwc2UgPT0gXCJsZWZ0XCIgPyByZWN0LmxlZnQgOiByZWN0LnJpZ2h0KSAtIHByZXBhcmVkLnJlY3QubGVmdCxcbiAgICAgICAgICAgICAgICAgIHRvcDogdG9wLCBib3R0b206IGJvdH07XG4gICAgaWYgKCFyZWN0LmxlZnQgJiYgIXJlY3QucmlnaHQpIHJlc3VsdC5ib2d1cyA9IHRydWU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyTGluZU1lYXN1cmVtZW50Q2FjaGVGb3IobGluZVZpZXcpIHtcbiAgICBpZiAobGluZVZpZXcubWVhc3VyZSkge1xuICAgICAgbGluZVZpZXcubWVhc3VyZS5jYWNoZSA9IHt9O1xuICAgICAgbGluZVZpZXcubWVhc3VyZS5oZWlnaHRzID0gbnVsbDtcbiAgICAgIGlmIChsaW5lVmlldy5yZXN0KSBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVWaWV3LnJlc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGVzW2ldID0ge307XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZShjbSkge1xuICAgIGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlID0gbnVsbDtcbiAgICByZW1vdmVDaGlsZHJlbihjbS5kaXNwbGF5LmxpbmVNZWFzdXJlKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNtLmRpc3BsYXkudmlldy5sZW5ndGg7IGkrKylcbiAgICAgIGNsZWFyTGluZU1lYXN1cmVtZW50Q2FjaGVGb3IoY20uZGlzcGxheS52aWV3W2ldKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyQ2FjaGVzKGNtKSB7XG4gICAgY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZShjbSk7XG4gICAgY20uZGlzcGxheS5jYWNoZWRDaGFyV2lkdGggPSBjbS5kaXNwbGF5LmNhY2hlZFRleHRIZWlnaHQgPSBjbS5kaXNwbGF5LmNhY2hlZFBhZGRpbmdIID0gbnVsbDtcbiAgICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSBjbS5kaXNwbGF5Lm1heExpbmVDaGFuZ2VkID0gdHJ1ZTtcbiAgICBjbS5kaXNwbGF5LmxpbmVOdW1DaGFycyA9IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBwYWdlU2Nyb2xsWCgpIHsgcmV0dXJuIHdpbmRvdy5wYWdlWE9mZnNldCB8fCAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IGRvY3VtZW50LmJvZHkpLnNjcm9sbExlZnQ7IH1cbiAgZnVuY3Rpb24gcGFnZVNjcm9sbFkoKSB7IHJldHVybiB3aW5kb3cucGFnZVlPZmZzZXQgfHwgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBkb2N1bWVudC5ib2R5KS5zY3JvbGxUb3A7IH1cblxuICAvLyBDb252ZXJ0cyBhIHt0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHR9IGJveCBmcm9tIGxpbmUtbG9jYWxcbiAgLy8gY29vcmRpbmF0ZXMgaW50byBhbm90aGVyIGNvb3JkaW5hdGUgc3lzdGVtLiBDb250ZXh0IG1heSBiZSBvbmUgb2ZcbiAgLy8gXCJsaW5lXCIsIFwiZGl2XCIgKGRpc3BsYXkubGluZURpdiksIFwibG9jYWxcIi9udWxsIChlZGl0b3IpLCBvciBcInBhZ2VcIi5cbiAgZnVuY3Rpb24gaW50b0Nvb3JkU3lzdGVtKGNtLCBsaW5lT2JqLCByZWN0LCBjb250ZXh0KSB7XG4gICAgaWYgKGxpbmVPYmoud2lkZ2V0cykgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lT2JqLndpZGdldHMubGVuZ3RoOyArK2kpIGlmIChsaW5lT2JqLndpZGdldHNbaV0uYWJvdmUpIHtcbiAgICAgIHZhciBzaXplID0gd2lkZ2V0SGVpZ2h0KGxpbmVPYmoud2lkZ2V0c1tpXSk7XG4gICAgICByZWN0LnRvcCArPSBzaXplOyByZWN0LmJvdHRvbSArPSBzaXplO1xuICAgIH1cbiAgICBpZiAoY29udGV4dCA9PSBcImxpbmVcIikgcmV0dXJuIHJlY3Q7XG4gICAgaWYgKCFjb250ZXh0KSBjb250ZXh0ID0gXCJsb2NhbFwiO1xuICAgIHZhciB5T2ZmID0gaGVpZ2h0QXRMaW5lKGxpbmVPYmopO1xuICAgIGlmIChjb250ZXh0ID09IFwibG9jYWxcIikgeU9mZiArPSBwYWRkaW5nVG9wKGNtLmRpc3BsYXkpO1xuICAgIGVsc2UgeU9mZiAtPSBjbS5kaXNwbGF5LnZpZXdPZmZzZXQ7XG4gICAgaWYgKGNvbnRleHQgPT0gXCJwYWdlXCIgfHwgY29udGV4dCA9PSBcIndpbmRvd1wiKSB7XG4gICAgICB2YXIgbE9mZiA9IGNtLmRpc3BsYXkubGluZVNwYWNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgeU9mZiArPSBsT2ZmLnRvcCArIChjb250ZXh0ID09IFwid2luZG93XCIgPyAwIDogcGFnZVNjcm9sbFkoKSk7XG4gICAgICB2YXIgeE9mZiA9IGxPZmYubGVmdCArIChjb250ZXh0ID09IFwid2luZG93XCIgPyAwIDogcGFnZVNjcm9sbFgoKSk7XG4gICAgICByZWN0LmxlZnQgKz0geE9mZjsgcmVjdC5yaWdodCArPSB4T2ZmO1xuICAgIH1cbiAgICByZWN0LnRvcCArPSB5T2ZmOyByZWN0LmJvdHRvbSArPSB5T2ZmO1xuICAgIHJldHVybiByZWN0O1xuICB9XG5cbiAgLy8gQ292ZXJ0cyBhIGJveCBmcm9tIFwiZGl2XCIgY29vcmRzIHRvIGFub3RoZXIgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gIC8vIENvbnRleHQgbWF5IGJlIFwid2luZG93XCIsIFwicGFnZVwiLCBcImRpdlwiLCBvciBcImxvY2FsXCIvbnVsbC5cbiAgZnVuY3Rpb24gZnJvbUNvb3JkU3lzdGVtKGNtLCBjb29yZHMsIGNvbnRleHQpIHtcbiAgICBpZiAoY29udGV4dCA9PSBcImRpdlwiKSByZXR1cm4gY29vcmRzO1xuICAgIHZhciBsZWZ0ID0gY29vcmRzLmxlZnQsIHRvcCA9IGNvb3Jkcy50b3A7XG4gICAgLy8gRmlyc3QgbW92ZSBpbnRvIFwicGFnZVwiIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgaWYgKGNvbnRleHQgPT0gXCJwYWdlXCIpIHtcbiAgICAgIGxlZnQgLT0gcGFnZVNjcm9sbFgoKTtcbiAgICAgIHRvcCAtPSBwYWdlU2Nyb2xsWSgpO1xuICAgIH0gZWxzZSBpZiAoY29udGV4dCA9PSBcImxvY2FsXCIgfHwgIWNvbnRleHQpIHtcbiAgICAgIHZhciBsb2NhbEJveCA9IGNtLmRpc3BsYXkuc2l6ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBsZWZ0ICs9IGxvY2FsQm94LmxlZnQ7XG4gICAgICB0b3AgKz0gbG9jYWxCb3gudG9wO1xuICAgIH1cblxuICAgIHZhciBsaW5lU3BhY2VCb3ggPSBjbS5kaXNwbGF5LmxpbmVTcGFjZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4ge2xlZnQ6IGxlZnQgLSBsaW5lU3BhY2VCb3gubGVmdCwgdG9wOiB0b3AgLSBsaW5lU3BhY2VCb3gudG9wfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoYXJDb29yZHMoY20sIHBvcywgY29udGV4dCwgbGluZU9iaiwgYmlhcykge1xuICAgIGlmICghbGluZU9iaikgbGluZU9iaiA9IGdldExpbmUoY20uZG9jLCBwb3MubGluZSk7XG4gICAgcmV0dXJuIGludG9Db29yZFN5c3RlbShjbSwgbGluZU9iaiwgbWVhc3VyZUNoYXIoY20sIGxpbmVPYmosIHBvcy5jaCwgYmlhcyksIGNvbnRleHQpO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIGJveCBmb3IgYSBnaXZlbiBjdXJzb3IgcG9zaXRpb24sIHdoaWNoIG1heSBoYXZlIGFuXG4gIC8vICdvdGhlcicgcHJvcGVydHkgY29udGFpbmluZyB0aGUgcG9zaXRpb24gb2YgdGhlIHNlY29uZGFyeSBjdXJzb3JcbiAgLy8gb24gYSBiaWRpIGJvdW5kYXJ5LlxuICBmdW5jdGlvbiBjdXJzb3JDb29yZHMoY20sIHBvcywgY29udGV4dCwgbGluZU9iaiwgcHJlcGFyZWRNZWFzdXJlKSB7XG4gICAgbGluZU9iaiA9IGxpbmVPYmogfHwgZ2V0TGluZShjbS5kb2MsIHBvcy5saW5lKTtcbiAgICBpZiAoIXByZXBhcmVkTWVhc3VyZSkgcHJlcGFyZWRNZWFzdXJlID0gcHJlcGFyZU1lYXN1cmVGb3JMaW5lKGNtLCBsaW5lT2JqKTtcbiAgICBmdW5jdGlvbiBnZXQoY2gsIHJpZ2h0KSB7XG4gICAgICB2YXIgbSA9IG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXBhcmVkTWVhc3VyZSwgY2gsIHJpZ2h0ID8gXCJyaWdodFwiIDogXCJsZWZ0XCIpO1xuICAgICAgaWYgKHJpZ2h0KSBtLmxlZnQgPSBtLnJpZ2h0OyBlbHNlIG0ucmlnaHQgPSBtLmxlZnQ7XG4gICAgICByZXR1cm4gaW50b0Nvb3JkU3lzdGVtKGNtLCBsaW5lT2JqLCBtLCBjb250ZXh0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0QmlkaShjaCwgcGFydFBvcykge1xuICAgICAgdmFyIHBhcnQgPSBvcmRlcltwYXJ0UG9zXSwgcmlnaHQgPSBwYXJ0LmxldmVsICUgMjtcbiAgICAgIGlmIChjaCA9PSBiaWRpTGVmdChwYXJ0KSAmJiBwYXJ0UG9zICYmIHBhcnQubGV2ZWwgPCBvcmRlcltwYXJ0UG9zIC0gMV0ubGV2ZWwpIHtcbiAgICAgICAgcGFydCA9IG9yZGVyWy0tcGFydFBvc107XG4gICAgICAgIGNoID0gYmlkaVJpZ2h0KHBhcnQpIC0gKHBhcnQubGV2ZWwgJSAyID8gMCA6IDEpO1xuICAgICAgICByaWdodCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGNoID09IGJpZGlSaWdodChwYXJ0KSAmJiBwYXJ0UG9zIDwgb3JkZXIubGVuZ3RoIC0gMSAmJiBwYXJ0LmxldmVsIDwgb3JkZXJbcGFydFBvcyArIDFdLmxldmVsKSB7XG4gICAgICAgIHBhcnQgPSBvcmRlclsrK3BhcnRQb3NdO1xuICAgICAgICBjaCA9IGJpZGlMZWZ0KHBhcnQpIC0gcGFydC5sZXZlbCAlIDI7XG4gICAgICAgIHJpZ2h0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAocmlnaHQgJiYgY2ggPT0gcGFydC50byAmJiBjaCA+IHBhcnQuZnJvbSkgcmV0dXJuIGdldChjaCAtIDEpO1xuICAgICAgcmV0dXJuIGdldChjaCwgcmlnaHQpO1xuICAgIH1cbiAgICB2YXIgb3JkZXIgPSBnZXRPcmRlcihsaW5lT2JqKSwgY2ggPSBwb3MuY2g7XG4gICAgaWYgKCFvcmRlcikgcmV0dXJuIGdldChjaCk7XG4gICAgdmFyIHBhcnRQb3MgPSBnZXRCaWRpUGFydEF0KG9yZGVyLCBjaCk7XG4gICAgdmFyIHZhbCA9IGdldEJpZGkoY2gsIHBhcnRQb3MpO1xuICAgIGlmIChiaWRpT3RoZXIgIT0gbnVsbCkgdmFsLm90aGVyID0gZ2V0QmlkaShjaCwgYmlkaU90aGVyKTtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgLy8gVXNlZCB0byBjaGVhcGx5IGVzdGltYXRlIHRoZSBjb29yZGluYXRlcyBmb3IgYSBwb3NpdGlvbi4gVXNlZCBmb3JcbiAgLy8gaW50ZXJtZWRpYXRlIHNjcm9sbCB1cGRhdGVzLlxuICBmdW5jdGlvbiBlc3RpbWF0ZUNvb3JkcyhjbSwgcG9zKSB7XG4gICAgdmFyIGxlZnQgPSAwLCBwb3MgPSBjbGlwUG9zKGNtLmRvYywgcG9zKTtcbiAgICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSBsZWZ0ID0gY2hhcldpZHRoKGNtLmRpc3BsYXkpICogcG9zLmNoO1xuICAgIHZhciBsaW5lT2JqID0gZ2V0TGluZShjbS5kb2MsIHBvcy5saW5lKTtcbiAgICB2YXIgdG9wID0gaGVpZ2h0QXRMaW5lKGxpbmVPYmopICsgcGFkZGluZ1RvcChjbS5kaXNwbGF5KTtcbiAgICByZXR1cm4ge2xlZnQ6IGxlZnQsIHJpZ2h0OiBsZWZ0LCB0b3A6IHRvcCwgYm90dG9tOiB0b3AgKyBsaW5lT2JqLmhlaWdodH07XG4gIH1cblxuICAvLyBQb3NpdGlvbnMgcmV0dXJuZWQgYnkgY29vcmRzQ2hhciBjb250YWluIHNvbWUgZXh0cmEgaW5mb3JtYXRpb24uXG4gIC8vIHhSZWwgaXMgdGhlIHJlbGF0aXZlIHggcG9zaXRpb24gb2YgdGhlIGlucHV0IGNvb3JkaW5hdGVzIGNvbXBhcmVkXG4gIC8vIHRvIHRoZSBmb3VuZCBwb3NpdGlvbiAoc28geFJlbCA+IDAgbWVhbnMgdGhlIGNvb3JkaW5hdGVzIGFyZSB0b1xuICAvLyB0aGUgcmlnaHQgb2YgdGhlIGNoYXJhY3RlciBwb3NpdGlvbiwgZm9yIGV4YW1wbGUpLiBXaGVuIG91dHNpZGVcbiAgLy8gaXMgdHJ1ZSwgdGhhdCBtZWFucyB0aGUgY29vcmRpbmF0ZXMgbGllIG91dHNpZGUgdGhlIGxpbmUnc1xuICAvLyB2ZXJ0aWNhbCByYW5nZS5cbiAgZnVuY3Rpb24gUG9zV2l0aEluZm8obGluZSwgY2gsIG91dHNpZGUsIHhSZWwpIHtcbiAgICB2YXIgcG9zID0gUG9zKGxpbmUsIGNoKTtcbiAgICBwb3MueFJlbCA9IHhSZWw7XG4gICAgaWYgKG91dHNpZGUpIHBvcy5vdXRzaWRlID0gdHJ1ZTtcbiAgICByZXR1cm4gcG9zO1xuICB9XG5cbiAgLy8gQ29tcHV0ZSB0aGUgY2hhcmFjdGVyIHBvc2l0aW9uIGNsb3Nlc3QgdG8gdGhlIGdpdmVuIGNvb3JkaW5hdGVzLlxuICAvLyBJbnB1dCBtdXN0IGJlIGxpbmVTcGFjZS1sb2NhbCAoXCJkaXZcIiBjb29yZGluYXRlIHN5c3RlbSkuXG4gIGZ1bmN0aW9uIGNvb3Jkc0NoYXIoY20sIHgsIHkpIHtcbiAgICB2YXIgZG9jID0gY20uZG9jO1xuICAgIHkgKz0gY20uZGlzcGxheS52aWV3T2Zmc2V0O1xuICAgIGlmICh5IDwgMCkgcmV0dXJuIFBvc1dpdGhJbmZvKGRvYy5maXJzdCwgMCwgdHJ1ZSwgLTEpO1xuICAgIHZhciBsaW5lTiA9IGxpbmVBdEhlaWdodChkb2MsIHkpLCBsYXN0ID0gZG9jLmZpcnN0ICsgZG9jLnNpemUgLSAxO1xuICAgIGlmIChsaW5lTiA+IGxhc3QpXG4gICAgICByZXR1cm4gUG9zV2l0aEluZm8oZG9jLmZpcnN0ICsgZG9jLnNpemUgLSAxLCBnZXRMaW5lKGRvYywgbGFzdCkudGV4dC5sZW5ndGgsIHRydWUsIDEpO1xuICAgIGlmICh4IDwgMCkgeCA9IDA7XG5cbiAgICB2YXIgbGluZU9iaiA9IGdldExpbmUoZG9jLCBsaW5lTik7XG4gICAgZm9yICg7Oykge1xuICAgICAgdmFyIGZvdW5kID0gY29vcmRzQ2hhcklubmVyKGNtLCBsaW5lT2JqLCBsaW5lTiwgeCwgeSk7XG4gICAgICB2YXIgbWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0RW5kKGxpbmVPYmopO1xuICAgICAgdmFyIG1lcmdlZFBvcyA9IG1lcmdlZCAmJiBtZXJnZWQuZmluZCgwLCB0cnVlKTtcbiAgICAgIGlmIChtZXJnZWQgJiYgKGZvdW5kLmNoID4gbWVyZ2VkUG9zLmZyb20uY2ggfHwgZm91bmQuY2ggPT0gbWVyZ2VkUG9zLmZyb20uY2ggJiYgZm91bmQueFJlbCA+IDApKVxuICAgICAgICBsaW5lTiA9IGxpbmVObyhsaW5lT2JqID0gbWVyZ2VkUG9zLnRvLmxpbmUpO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29vcmRzQ2hhcklubmVyKGNtLCBsaW5lT2JqLCBsaW5lTm8sIHgsIHkpIHtcbiAgICB2YXIgaW5uZXJPZmYgPSB5IC0gaGVpZ2h0QXRMaW5lKGxpbmVPYmopO1xuICAgIHZhciB3cm9uZ0xpbmUgPSBmYWxzZSwgYWRqdXN0ID0gMiAqIGNtLmRpc3BsYXkud3JhcHBlci5jbGllbnRXaWR0aDtcbiAgICB2YXIgcHJlcGFyZWRNZWFzdXJlID0gcHJlcGFyZU1lYXN1cmVGb3JMaW5lKGNtLCBsaW5lT2JqKTtcblxuICAgIGZ1bmN0aW9uIGdldFgoY2gpIHtcbiAgICAgIHZhciBzcCA9IGN1cnNvckNvb3JkcyhjbSwgUG9zKGxpbmVObywgY2gpLCBcImxpbmVcIiwgbGluZU9iaiwgcHJlcGFyZWRNZWFzdXJlKTtcbiAgICAgIHdyb25nTGluZSA9IHRydWU7XG4gICAgICBpZiAoaW5uZXJPZmYgPiBzcC5ib3R0b20pIHJldHVybiBzcC5sZWZ0IC0gYWRqdXN0O1xuICAgICAgZWxzZSBpZiAoaW5uZXJPZmYgPCBzcC50b3ApIHJldHVybiBzcC5sZWZ0ICsgYWRqdXN0O1xuICAgICAgZWxzZSB3cm9uZ0xpbmUgPSBmYWxzZTtcbiAgICAgIHJldHVybiBzcC5sZWZ0O1xuICAgIH1cblxuICAgIHZhciBiaWRpID0gZ2V0T3JkZXIobGluZU9iaiksIGRpc3QgPSBsaW5lT2JqLnRleHQubGVuZ3RoO1xuICAgIHZhciBmcm9tID0gbGluZUxlZnQobGluZU9iaiksIHRvID0gbGluZVJpZ2h0KGxpbmVPYmopO1xuICAgIHZhciBmcm9tWCA9IGdldFgoZnJvbSksIGZyb21PdXRzaWRlID0gd3JvbmdMaW5lLCB0b1ggPSBnZXRYKHRvKSwgdG9PdXRzaWRlID0gd3JvbmdMaW5lO1xuXG4gICAgaWYgKHggPiB0b1gpIHJldHVybiBQb3NXaXRoSW5mbyhsaW5lTm8sIHRvLCB0b091dHNpZGUsIDEpO1xuICAgIC8vIERvIGEgYmluYXJ5IHNlYXJjaCBiZXR3ZWVuIHRoZXNlIGJvdW5kcy5cbiAgICBmb3IgKDs7KSB7XG4gICAgICBpZiAoYmlkaSA/IHRvID09IGZyb20gfHwgdG8gPT0gbW92ZVZpc3VhbGx5KGxpbmVPYmosIGZyb20sIDEpIDogdG8gLSBmcm9tIDw9IDEpIHtcbiAgICAgICAgdmFyIGNoID0geCA8IGZyb21YIHx8IHggLSBmcm9tWCA8PSB0b1ggLSB4ID8gZnJvbSA6IHRvO1xuICAgICAgICB2YXIgeERpZmYgPSB4IC0gKGNoID09IGZyb20gPyBmcm9tWCA6IHRvWCk7XG4gICAgICAgIHdoaWxlIChpc0V4dGVuZGluZ0NoYXIobGluZU9iai50ZXh0LmNoYXJBdChjaCkpKSArK2NoO1xuICAgICAgICB2YXIgcG9zID0gUG9zV2l0aEluZm8obGluZU5vLCBjaCwgY2ggPT0gZnJvbSA/IGZyb21PdXRzaWRlIDogdG9PdXRzaWRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeERpZmYgPCAtMSA/IC0xIDogeERpZmYgPiAxID8gMSA6IDApO1xuICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgfVxuICAgICAgdmFyIHN0ZXAgPSBNYXRoLmNlaWwoZGlzdCAvIDIpLCBtaWRkbGUgPSBmcm9tICsgc3RlcDtcbiAgICAgIGlmIChiaWRpKSB7XG4gICAgICAgIG1pZGRsZSA9IGZyb207XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RlcDsgKytpKSBtaWRkbGUgPSBtb3ZlVmlzdWFsbHkobGluZU9iaiwgbWlkZGxlLCAxKTtcbiAgICAgIH1cbiAgICAgIHZhciBtaWRkbGVYID0gZ2V0WChtaWRkbGUpO1xuICAgICAgaWYgKG1pZGRsZVggPiB4KSB7dG8gPSBtaWRkbGU7IHRvWCA9IG1pZGRsZVg7IGlmICh0b091dHNpZGUgPSB3cm9uZ0xpbmUpIHRvWCArPSAxMDAwOyBkaXN0ID0gc3RlcDt9XG4gICAgICBlbHNlIHtmcm9tID0gbWlkZGxlOyBmcm9tWCA9IG1pZGRsZVg7IGZyb21PdXRzaWRlID0gd3JvbmdMaW5lOyBkaXN0IC09IHN0ZXA7fVxuICAgIH1cbiAgfVxuXG4gIHZhciBtZWFzdXJlVGV4dDtcbiAgLy8gQ29tcHV0ZSB0aGUgZGVmYXVsdCB0ZXh0IGhlaWdodC5cbiAgZnVuY3Rpb24gdGV4dEhlaWdodChkaXNwbGF5KSB7XG4gICAgaWYgKGRpc3BsYXkuY2FjaGVkVGV4dEhlaWdodCAhPSBudWxsKSByZXR1cm4gZGlzcGxheS5jYWNoZWRUZXh0SGVpZ2h0O1xuICAgIGlmIChtZWFzdXJlVGV4dCA9PSBudWxsKSB7XG4gICAgICBtZWFzdXJlVGV4dCA9IGVsdChcInByZVwiKTtcbiAgICAgIC8vIE1lYXN1cmUgYSBidW5jaCBvZiBsaW5lcywgZm9yIGJyb3dzZXJzIHRoYXQgY29tcHV0ZVxuICAgICAgLy8gZnJhY3Rpb25hbCBoZWlnaHRzLlxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OTsgKytpKSB7XG4gICAgICAgIG1lYXN1cmVUZXh0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwieFwiKSk7XG4gICAgICAgIG1lYXN1cmVUZXh0LmFwcGVuZENoaWxkKGVsdChcImJyXCIpKTtcbiAgICAgIH1cbiAgICAgIG1lYXN1cmVUZXh0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwieFwiKSk7XG4gICAgfVxuICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKGRpc3BsYXkubWVhc3VyZSwgbWVhc3VyZVRleHQpO1xuICAgIHZhciBoZWlnaHQgPSBtZWFzdXJlVGV4dC5vZmZzZXRIZWlnaHQgLyA1MDtcbiAgICBpZiAoaGVpZ2h0ID4gMykgZGlzcGxheS5jYWNoZWRUZXh0SGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHJlbW92ZUNoaWxkcmVuKGRpc3BsYXkubWVhc3VyZSk7XG4gICAgcmV0dXJuIGhlaWdodCB8fCAxO1xuICB9XG5cbiAgLy8gQ29tcHV0ZSB0aGUgZGVmYXVsdCBjaGFyYWN0ZXIgd2lkdGguXG4gIGZ1bmN0aW9uIGNoYXJXaWR0aChkaXNwbGF5KSB7XG4gICAgaWYgKGRpc3BsYXkuY2FjaGVkQ2hhcldpZHRoICE9IG51bGwpIHJldHVybiBkaXNwbGF5LmNhY2hlZENoYXJXaWR0aDtcbiAgICB2YXIgYW5jaG9yID0gZWx0KFwic3BhblwiLCBcInh4eHh4eHh4eHhcIik7XG4gICAgdmFyIHByZSA9IGVsdChcInByZVwiLCBbYW5jaG9yXSk7XG4gICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoZGlzcGxheS5tZWFzdXJlLCBwcmUpO1xuICAgIHZhciByZWN0ID0gYW5jaG9yLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB3aWR0aCA9IChyZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0KSAvIDEwO1xuICAgIGlmICh3aWR0aCA+IDIpIGRpc3BsYXkuY2FjaGVkQ2hhcldpZHRoID0gd2lkdGg7XG4gICAgcmV0dXJuIHdpZHRoIHx8IDEwO1xuICB9XG5cbiAgLy8gT1BFUkFUSU9OU1xuXG4gIC8vIE9wZXJhdGlvbnMgYXJlIHVzZWQgdG8gd3JhcCBhIHNlcmllcyBvZiBjaGFuZ2VzIHRvIHRoZSBlZGl0b3JcbiAgLy8gc3RhdGUgaW4gc3VjaCBhIHdheSB0aGF0IGVhY2ggY2hhbmdlIHdvbid0IGhhdmUgdG8gdXBkYXRlIHRoZVxuICAvLyBjdXJzb3IgYW5kIGRpc3BsYXkgKHdoaWNoIHdvdWxkIGJlIGF3a3dhcmQsIHNsb3csIGFuZFxuICAvLyBlcnJvci1wcm9uZSkuIEluc3RlYWQsIGRpc3BsYXkgdXBkYXRlcyBhcmUgYmF0Y2hlZCBhbmQgdGhlbiBhbGxcbiAgLy8gY29tYmluZWQgYW5kIGV4ZWN1dGVkIGF0IG9uY2UuXG5cbiAgdmFyIG5leHRPcElkID0gMDtcbiAgLy8gU3RhcnQgYSBuZXcgb3BlcmF0aW9uLlxuICBmdW5jdGlvbiBzdGFydE9wZXJhdGlvbihjbSkge1xuICAgIGNtLmN1ck9wID0ge1xuICAgICAgdmlld0NoYW5nZWQ6IGZhbHNlLCAgICAgIC8vIEZsYWcgdGhhdCBpbmRpY2F0ZXMgdGhhdCBsaW5lcyBtaWdodCBuZWVkIHRvIGJlIHJlZHJhd25cbiAgICAgIHN0YXJ0SGVpZ2h0OiBjbS5kb2MuaGVpZ2h0LCAvLyBVc2VkIHRvIGRldGVjdCBuZWVkIHRvIHVwZGF0ZSBzY3JvbGxiYXJcbiAgICAgIGZvcmNlVXBkYXRlOiBmYWxzZSwgICAgICAvLyBVc2VkIHRvIGZvcmNlIGEgcmVkcmF3XG4gICAgICB1cGRhdGVJbnB1dDogbnVsbCwgICAgICAgLy8gV2hldGhlciB0byByZXNldCB0aGUgaW5wdXQgdGV4dGFyZWFcbiAgICAgIHR5cGluZzogZmFsc2UsICAgICAgICAgICAvLyBXaGV0aGVyIHRoaXMgcmVzZXQgc2hvdWxkIGJlIGNhcmVmdWwgdG8gbGVhdmUgZXhpc3RpbmcgdGV4dCAoZm9yIGNvbXBvc2l0aW5nKVxuICAgICAgY2hhbmdlT2JqczogbnVsbCwgICAgICAgIC8vIEFjY3VtdWxhdGVkIGNoYW5nZXMsIGZvciBmaXJpbmcgY2hhbmdlIGV2ZW50c1xuICAgICAgY3Vyc29yQWN0aXZpdHlIYW5kbGVyczogbnVsbCwgLy8gU2V0IG9mIGhhbmRsZXJzIHRvIGZpcmUgY3Vyc29yQWN0aXZpdHkgb25cbiAgICAgIHNlbGVjdGlvbkNoYW5nZWQ6IGZhbHNlLCAvLyBXaGV0aGVyIHRoZSBzZWxlY3Rpb24gbmVlZHMgdG8gYmUgcmVkcmF3blxuICAgICAgdXBkYXRlTWF4TGluZTogZmFsc2UsICAgIC8vIFNldCB3aGVuIHRoZSB3aWRlc3QgbGluZSBuZWVkcyB0byBiZSBkZXRlcm1pbmVkIGFuZXdcbiAgICAgIHNjcm9sbExlZnQ6IG51bGwsIHNjcm9sbFRvcDogbnVsbCwgLy8gSW50ZXJtZWRpYXRlIHNjcm9sbCBwb3NpdGlvbiwgbm90IHB1c2hlZCB0byBET00geWV0XG4gICAgICBzY3JvbGxUb1BvczogbnVsbCwgICAgICAgLy8gVXNlZCB0byBzY3JvbGwgdG8gYSBzcGVjaWZpYyBwb3NpdGlvblxuICAgICAgaWQ6ICsrbmV4dE9wSWQgICAgICAgICAgIC8vIFVuaXF1ZSBJRFxuICAgIH07XG4gICAgaWYgKCFkZWxheWVkQ2FsbGJhY2tEZXB0aCsrKSBkZWxheWVkQ2FsbGJhY2tzID0gW107XG4gIH1cblxuICAvLyBGaW5pc2ggYW4gb3BlcmF0aW9uLCB1cGRhdGluZyB0aGUgZGlzcGxheSBhbmQgc2lnbmFsbGluZyBkZWxheWVkIGV2ZW50c1xuICBmdW5jdGlvbiBlbmRPcGVyYXRpb24oY20pIHtcbiAgICB2YXIgb3AgPSBjbS5jdXJPcCwgZG9jID0gY20uZG9jLCBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICBjbS5jdXJPcCA9IG51bGw7XG5cbiAgICBpZiAob3AudXBkYXRlTWF4TGluZSkgZmluZE1heExpbmUoY20pO1xuXG4gICAgLy8gSWYgaXQgbG9va3MgbGlrZSBhbiB1cGRhdGUgbWlnaHQgYmUgbmVlZGVkLCBjYWxsIHVwZGF0ZURpc3BsYXlcbiAgICBpZiAob3Audmlld0NoYW5nZWQgfHwgb3AuZm9yY2VVcGRhdGUgfHwgb3Auc2Nyb2xsVG9wICE9IG51bGwgfHxcbiAgICAgICAgb3Auc2Nyb2xsVG9Qb3MgJiYgKG9wLnNjcm9sbFRvUG9zLmZyb20ubGluZSA8IGRpc3BsYXkudmlld0Zyb20gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wLnNjcm9sbFRvUG9zLnRvLmxpbmUgPj0gZGlzcGxheS52aWV3VG8pIHx8XG4gICAgICAgIGRpc3BsYXkubWF4TGluZUNoYW5nZWQgJiYgY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHtcbiAgICAgIHZhciB1cGRhdGVkID0gdXBkYXRlRGlzcGxheShjbSwge3RvcDogb3Auc2Nyb2xsVG9wLCBlbnN1cmU6IG9wLnNjcm9sbFRvUG9zfSwgb3AuZm9yY2VVcGRhdGUpO1xuICAgICAgaWYgKGNtLmRpc3BsYXkuc2Nyb2xsZXIub2Zmc2V0SGVpZ2h0KSBjbS5kb2Muc2Nyb2xsVG9wID0gY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3A7XG4gICAgfVxuICAgIC8vIElmIG5vIHVwZGF0ZSB3YXMgcnVuLCBidXQgdGhlIHNlbGVjdGlvbiBjaGFuZ2VkLCByZWRyYXcgdGhhdC5cbiAgICBpZiAoIXVwZGF0ZWQgJiYgb3Auc2VsZWN0aW9uQ2hhbmdlZCkgdXBkYXRlU2VsZWN0aW9uKGNtKTtcbiAgICBpZiAoIXVwZGF0ZWQgJiYgb3Auc3RhcnRIZWlnaHQgIT0gY20uZG9jLmhlaWdodCkgdXBkYXRlU2Nyb2xsYmFycyhjbSk7XG5cbiAgICAvLyBQcm9wYWdhdGUgdGhlIHNjcm9sbCBwb3NpdGlvbiB0byB0aGUgYWN0dWFsIERPTSBzY3JvbGxlclxuICAgIGlmIChvcC5zY3JvbGxUb3AgIT0gbnVsbCAmJiBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcCAhPSBvcC5zY3JvbGxUb3ApIHtcbiAgICAgIHZhciB0b3AgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbEhlaWdodCAtIGRpc3BsYXkuc2Nyb2xsZXIuY2xpZW50SGVpZ2h0LCBvcC5zY3JvbGxUb3ApKTtcbiAgICAgIGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wID0gZGlzcGxheS5zY3JvbGxiYXJWLnNjcm9sbFRvcCA9IGRvYy5zY3JvbGxUb3AgPSB0b3A7XG4gICAgfVxuICAgIGlmIChvcC5zY3JvbGxMZWZ0ICE9IG51bGwgJiYgZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0ICE9IG9wLnNjcm9sbExlZnQpIHtcbiAgICAgIHZhciBsZWZ0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oZGlzcGxheS5zY3JvbGxlci5zY3JvbGxXaWR0aCAtIGRpc3BsYXkuc2Nyb2xsZXIuY2xpZW50V2lkdGgsIG9wLnNjcm9sbExlZnQpKTtcbiAgICAgIGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsTGVmdCA9IGRpc3BsYXkuc2Nyb2xsYmFySC5zY3JvbGxMZWZ0ID0gZG9jLnNjcm9sbExlZnQgPSBsZWZ0O1xuICAgICAgYWxpZ25Ib3Jpem9udGFsbHkoY20pO1xuICAgIH1cbiAgICAvLyBJZiB3ZSBuZWVkIHRvIHNjcm9sbCBhIHNwZWNpZmljIHBvc2l0aW9uIGludG8gdmlldywgZG8gc28uXG4gICAgaWYgKG9wLnNjcm9sbFRvUG9zKSB7XG4gICAgICB2YXIgY29vcmRzID0gc2Nyb2xsUG9zSW50b1ZpZXcoY20sIGNsaXBQb3MoY20uZG9jLCBvcC5zY3JvbGxUb1Bvcy5mcm9tKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwUG9zKGNtLmRvYywgb3Auc2Nyb2xsVG9Qb3MudG8pLCBvcC5zY3JvbGxUb1Bvcy5tYXJnaW4pO1xuICAgICAgaWYgKG9wLnNjcm9sbFRvUG9zLmlzQ3Vyc29yICYmIGNtLnN0YXRlLmZvY3VzZWQpIG1heWJlU2Nyb2xsV2luZG93KGNtLCBjb29yZHMpO1xuICAgIH1cblxuICAgIGlmIChvcC5zZWxlY3Rpb25DaGFuZ2VkKSByZXN0YXJ0QmxpbmsoY20pO1xuXG4gICAgaWYgKGNtLnN0YXRlLmZvY3VzZWQgJiYgb3AudXBkYXRlSW5wdXQpXG4gICAgICByZXNldElucHV0KGNtLCBvcC50eXBpbmcpO1xuXG4gICAgLy8gRmlyZSBldmVudHMgZm9yIG1hcmtlcnMgdGhhdCBhcmUgaGlkZGVuL3VuaWRkZW4gYnkgZWRpdGluZyBvclxuICAgIC8vIHVuZG9pbmdcbiAgICB2YXIgaGlkZGVuID0gb3AubWF5YmVIaWRkZW5NYXJrZXJzLCB1bmhpZGRlbiA9IG9wLm1heWJlVW5oaWRkZW5NYXJrZXJzO1xuICAgIGlmIChoaWRkZW4pIGZvciAodmFyIGkgPSAwOyBpIDwgaGlkZGVuLmxlbmd0aDsgKytpKVxuICAgICAgaWYgKCFoaWRkZW5baV0ubGluZXMubGVuZ3RoKSBzaWduYWwoaGlkZGVuW2ldLCBcImhpZGVcIik7XG4gICAgaWYgKHVuaGlkZGVuKSBmb3IgKHZhciBpID0gMDsgaSA8IHVuaGlkZGVuLmxlbmd0aDsgKytpKVxuICAgICAgaWYgKHVuaGlkZGVuW2ldLmxpbmVzLmxlbmd0aCkgc2lnbmFsKHVuaGlkZGVuW2ldLCBcInVuaGlkZVwiKTtcblxuICAgIHZhciBkZWxheWVkO1xuICAgIGlmICghLS1kZWxheWVkQ2FsbGJhY2tEZXB0aCkge1xuICAgICAgZGVsYXllZCA9IGRlbGF5ZWRDYWxsYmFja3M7XG4gICAgICBkZWxheWVkQ2FsbGJhY2tzID0gbnVsbDtcbiAgICB9XG4gICAgLy8gRmlyZSBjaGFuZ2UgZXZlbnRzLCBhbmQgZGVsYXllZCBldmVudCBoYW5kbGVyc1xuICAgIGlmIChvcC5jaGFuZ2VPYmpzKVxuICAgICAgc2lnbmFsKGNtLCBcImNoYW5nZXNcIiwgY20sIG9wLmNoYW5nZU9ianMpO1xuICAgIGlmIChkZWxheWVkKSBmb3IgKHZhciBpID0gMDsgaSA8IGRlbGF5ZWQubGVuZ3RoOyArK2kpIGRlbGF5ZWRbaV0oKTtcbiAgICBpZiAob3AuY3Vyc29yQWN0aXZpdHlIYW5kbGVycylcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3AuY3Vyc29yQWN0aXZpdHlIYW5kbGVycy5sZW5ndGg7IGkrKylcbiAgICAgICAgb3AuY3Vyc29yQWN0aXZpdHlIYW5kbGVyc1tpXShjbSk7XG4gIH1cblxuICAvLyBSdW4gdGhlIGdpdmVuIGZ1bmN0aW9uIGluIGFuIG9wZXJhdGlvblxuICBmdW5jdGlvbiBydW5Jbk9wKGNtLCBmKSB7XG4gICAgaWYgKGNtLmN1ck9wKSByZXR1cm4gZigpO1xuICAgIHN0YXJ0T3BlcmF0aW9uKGNtKTtcbiAgICB0cnkgeyByZXR1cm4gZigpOyB9XG4gICAgZmluYWxseSB7IGVuZE9wZXJhdGlvbihjbSk7IH1cbiAgfVxuICAvLyBXcmFwcyBhIGZ1bmN0aW9uIGluIGFuIG9wZXJhdGlvbi4gUmV0dXJucyB0aGUgd3JhcHBlZCBmdW5jdGlvbi5cbiAgZnVuY3Rpb24gb3BlcmF0aW9uKGNtLCBmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGNtLmN1ck9wKSByZXR1cm4gZi5hcHBseShjbSwgYXJndW1lbnRzKTtcbiAgICAgIHN0YXJ0T3BlcmF0aW9uKGNtKTtcbiAgICAgIHRyeSB7IHJldHVybiBmLmFwcGx5KGNtLCBhcmd1bWVudHMpOyB9XG4gICAgICBmaW5hbGx5IHsgZW5kT3BlcmF0aW9uKGNtKTsgfVxuICAgIH07XG4gIH1cbiAgLy8gVXNlZCB0byBhZGQgbWV0aG9kcyB0byBlZGl0b3IgYW5kIGRvYyBpbnN0YW5jZXMsIHdyYXBwaW5nIHRoZW0gaW5cbiAgLy8gb3BlcmF0aW9ucy5cbiAgZnVuY3Rpb24gbWV0aG9kT3AoZikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmN1ck9wKSByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgc3RhcnRPcGVyYXRpb24odGhpcyk7XG4gICAgICB0cnkgeyByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG4gICAgICBmaW5hbGx5IHsgZW5kT3BlcmF0aW9uKHRoaXMpOyB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkb2NNZXRob2RPcChmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNtID0gdGhpcy5jbTtcbiAgICAgIGlmICghY20gfHwgY20uY3VyT3ApIHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBzdGFydE9wZXJhdGlvbihjbSk7XG4gICAgICB0cnkgeyByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG4gICAgICBmaW5hbGx5IHsgZW5kT3BlcmF0aW9uKGNtKTsgfVxuICAgIH07XG4gIH1cblxuICAvLyBWSUVXIFRSQUNLSU5HXG5cbiAgLy8gVGhlc2Ugb2JqZWN0cyBhcmUgdXNlZCB0byByZXByZXNlbnQgdGhlIHZpc2libGUgKGN1cnJlbnRseSBkcmF3bilcbiAgLy8gcGFydCBvZiB0aGUgZG9jdW1lbnQuIEEgTGluZVZpZXcgbWF5IGNvcnJlc3BvbmQgdG8gbXVsdGlwbGVcbiAgLy8gbG9naWNhbCBsaW5lcywgaWYgdGhvc2UgYXJlIGNvbm5lY3RlZCBieSBjb2xsYXBzZWQgcmFuZ2VzLlxuICBmdW5jdGlvbiBMaW5lVmlldyhkb2MsIGxpbmUsIGxpbmVOKSB7XG4gICAgLy8gVGhlIHN0YXJ0aW5nIGxpbmVcbiAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICAgIC8vIENvbnRpbnVpbmcgbGluZXMsIGlmIGFueVxuICAgIHRoaXMucmVzdCA9IHZpc3VhbExpbmVDb250aW51ZWQobGluZSk7XG4gICAgLy8gTnVtYmVyIG9mIGxvZ2ljYWwgbGluZXMgaW4gdGhpcyB2aXN1YWwgbGluZVxuICAgIHRoaXMuc2l6ZSA9IHRoaXMucmVzdCA/IGxpbmVObyhsc3QodGhpcy5yZXN0KSkgLSBsaW5lTiArIDEgOiAxO1xuICAgIHRoaXMubm9kZSA9IHRoaXMudGV4dCA9IG51bGw7XG4gICAgdGhpcy5oaWRkZW4gPSBsaW5lSXNIaWRkZW4oZG9jLCBsaW5lKTtcbiAgfVxuXG4gIC8vIENyZWF0ZSBhIHJhbmdlIG9mIExpbmVWaWV3IG9iamVjdHMgZm9yIHRoZSBnaXZlbiBsaW5lcy5cbiAgZnVuY3Rpb24gYnVpbGRWaWV3QXJyYXkoY20sIGZyb20sIHRvKSB7XG4gICAgdmFyIGFycmF5ID0gW10sIG5leHRQb3M7XG4gICAgZm9yICh2YXIgcG9zID0gZnJvbTsgcG9zIDwgdG87IHBvcyA9IG5leHRQb3MpIHtcbiAgICAgIHZhciB2aWV3ID0gbmV3IExpbmVWaWV3KGNtLmRvYywgZ2V0TGluZShjbS5kb2MsIHBvcyksIHBvcyk7XG4gICAgICBuZXh0UG9zID0gcG9zICsgdmlldy5zaXplO1xuICAgICAgYXJyYXkucHVzaCh2aWV3KTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLy8gVXBkYXRlcyB0aGUgZGlzcGxheS52aWV3IGRhdGEgc3RydWN0dXJlIGZvciBhIGdpdmVuIGNoYW5nZSB0byB0aGVcbiAgLy8gZG9jdW1lbnQuIEZyb20gYW5kIHRvIGFyZSBpbiBwcmUtY2hhbmdlIGNvb3JkaW5hdGVzLiBMZW5kaWZmIGlzXG4gIC8vIHRoZSBhbW91bnQgb2YgbGluZXMgYWRkZWQgb3Igc3VidHJhY3RlZCBieSB0aGUgY2hhbmdlLiBUaGlzIGlzXG4gIC8vIHVzZWQgZm9yIGNoYW5nZXMgdGhhdCBzcGFuIG11bHRpcGxlIGxpbmVzLCBvciBjaGFuZ2UgdGhlIHdheVxuICAvLyBsaW5lcyBhcmUgZGl2aWRlZCBpbnRvIHZpc3VhbCBsaW5lcy4gcmVnTGluZUNoYW5nZSAoYmVsb3cpXG4gIC8vIHJlZ2lzdGVycyBzaW5nbGUtbGluZSBjaGFuZ2VzLlxuICBmdW5jdGlvbiByZWdDaGFuZ2UoY20sIGZyb20sIHRvLCBsZW5kaWZmKSB7XG4gICAgaWYgKGZyb20gPT0gbnVsbCkgZnJvbSA9IGNtLmRvYy5maXJzdDtcbiAgICBpZiAodG8gPT0gbnVsbCkgdG8gPSBjbS5kb2MuZmlyc3QgKyBjbS5kb2Muc2l6ZTtcbiAgICBpZiAoIWxlbmRpZmYpIGxlbmRpZmYgPSAwO1xuXG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xuICAgIGlmIChsZW5kaWZmICYmIHRvIDwgZGlzcGxheS52aWV3VG8gJiZcbiAgICAgICAgKGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMgPT0gbnVsbCB8fCBkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID4gZnJvbSkpXG4gICAgICBkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID0gZnJvbTtcblxuICAgIGNtLmN1ck9wLnZpZXdDaGFuZ2VkID0gdHJ1ZTtcblxuICAgIGlmIChmcm9tID49IGRpc3BsYXkudmlld1RvKSB7IC8vIENoYW5nZSBhZnRlclxuICAgICAgaWYgKHNhd0NvbGxhcHNlZFNwYW5zICYmIHZpc3VhbExpbmVObyhjbS5kb2MsIGZyb20pIDwgZGlzcGxheS52aWV3VG8pXG4gICAgICAgIHJlc2V0VmlldyhjbSk7XG4gICAgfSBlbHNlIGlmICh0byA8PSBkaXNwbGF5LnZpZXdGcm9tKSB7IC8vIENoYW5nZSBiZWZvcmVcbiAgICAgIGlmIChzYXdDb2xsYXBzZWRTcGFucyAmJiB2aXN1YWxMaW5lRW5kTm8oY20uZG9jLCB0byArIGxlbmRpZmYpID4gZGlzcGxheS52aWV3RnJvbSkge1xuICAgICAgICByZXNldFZpZXcoY20pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlzcGxheS52aWV3RnJvbSArPSBsZW5kaWZmO1xuICAgICAgICBkaXNwbGF5LnZpZXdUbyArPSBsZW5kaWZmO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZnJvbSA8PSBkaXNwbGF5LnZpZXdGcm9tICYmIHRvID49IGRpc3BsYXkudmlld1RvKSB7IC8vIEZ1bGwgb3ZlcmxhcFxuICAgICAgcmVzZXRWaWV3KGNtKTtcbiAgICB9IGVsc2UgaWYgKGZyb20gPD0gZGlzcGxheS52aWV3RnJvbSkgeyAvLyBUb3Agb3ZlcmxhcFxuICAgICAgdmFyIGN1dCA9IHZpZXdDdXR0aW5nUG9pbnQoY20sIHRvLCB0byArIGxlbmRpZmYsIDEpO1xuICAgICAgaWYgKGN1dCkge1xuICAgICAgICBkaXNwbGF5LnZpZXcgPSBkaXNwbGF5LnZpZXcuc2xpY2UoY3V0LmluZGV4KTtcbiAgICAgICAgZGlzcGxheS52aWV3RnJvbSA9IGN1dC5saW5lTjtcbiAgICAgICAgZGlzcGxheS52aWV3VG8gKz0gbGVuZGlmZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc2V0VmlldyhjbSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0byA+PSBkaXNwbGF5LnZpZXdUbykgeyAvLyBCb3R0b20gb3ZlcmxhcFxuICAgICAgdmFyIGN1dCA9IHZpZXdDdXR0aW5nUG9pbnQoY20sIGZyb20sIGZyb20sIC0xKTtcbiAgICAgIGlmIChjdXQpIHtcbiAgICAgICAgZGlzcGxheS52aWV3ID0gZGlzcGxheS52aWV3LnNsaWNlKDAsIGN1dC5pbmRleCk7XG4gICAgICAgIGRpc3BsYXkudmlld1RvID0gY3V0LmxpbmVOO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzZXRWaWV3KGNtKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyBHYXAgaW4gdGhlIG1pZGRsZVxuICAgICAgdmFyIGN1dFRvcCA9IHZpZXdDdXR0aW5nUG9pbnQoY20sIGZyb20sIGZyb20sIC0xKTtcbiAgICAgIHZhciBjdXRCb3QgPSB2aWV3Q3V0dGluZ1BvaW50KGNtLCB0bywgdG8gKyBsZW5kaWZmLCAxKTtcbiAgICAgIGlmIChjdXRUb3AgJiYgY3V0Qm90KSB7XG4gICAgICAgIGRpc3BsYXkudmlldyA9IGRpc3BsYXkudmlldy5zbGljZSgwLCBjdXRUb3AuaW5kZXgpXG4gICAgICAgICAgLmNvbmNhdChidWlsZFZpZXdBcnJheShjbSwgY3V0VG9wLmxpbmVOLCBjdXRCb3QubGluZU4pKVxuICAgICAgICAgIC5jb25jYXQoZGlzcGxheS52aWV3LnNsaWNlKGN1dEJvdC5pbmRleCkpO1xuICAgICAgICBkaXNwbGF5LnZpZXdUbyArPSBsZW5kaWZmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzZXRWaWV3KGNtKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZXh0ID0gZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkO1xuICAgIGlmIChleHQpIHtcbiAgICAgIGlmICh0byA8IGV4dC5saW5lTilcbiAgICAgICAgZXh0LmxpbmVOICs9IGxlbmRpZmY7XG4gICAgICBlbHNlIGlmIChmcm9tIDwgZXh0LmxpbmVOICsgZXh0LnNpemUpXG4gICAgICAgIGRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVnaXN0ZXIgYSBjaGFuZ2UgdG8gYSBzaW5nbGUgbGluZS4gVHlwZSBtdXN0IGJlIG9uZSBvZiBcInRleHRcIixcbiAgLy8gXCJndXR0ZXJcIiwgXCJjbGFzc1wiLCBcIndpZGdldFwiXG4gIGZ1bmN0aW9uIHJlZ0xpbmVDaGFuZ2UoY20sIGxpbmUsIHR5cGUpIHtcbiAgICBjbS5jdXJPcC52aWV3Q2hhbmdlZCA9IHRydWU7XG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBleHQgPSBjbS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQ7XG4gICAgaWYgKGV4dCAmJiBsaW5lID49IGV4dC5saW5lTiAmJiBsaW5lIDwgZXh0LmxpbmVOICsgZXh0LnNpemUpXG4gICAgICBkaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQgPSBudWxsO1xuXG4gICAgaWYgKGxpbmUgPCBkaXNwbGF5LnZpZXdGcm9tIHx8IGxpbmUgPj0gZGlzcGxheS52aWV3VG8pIHJldHVybjtcbiAgICB2YXIgbGluZVZpZXcgPSBkaXNwbGF5LnZpZXdbZmluZFZpZXdJbmRleChjbSwgbGluZSldO1xuICAgIGlmIChsaW5lVmlldy5ub2RlID09IG51bGwpIHJldHVybjtcbiAgICB2YXIgYXJyID0gbGluZVZpZXcuY2hhbmdlcyB8fCAobGluZVZpZXcuY2hhbmdlcyA9IFtdKTtcbiAgICBpZiAoaW5kZXhPZihhcnIsIHR5cGUpID09IC0xKSBhcnIucHVzaCh0eXBlKTtcbiAgfVxuXG4gIC8vIENsZWFyIHRoZSB2aWV3LlxuICBmdW5jdGlvbiByZXNldFZpZXcoY20pIHtcbiAgICBjbS5kaXNwbGF5LnZpZXdGcm9tID0gY20uZGlzcGxheS52aWV3VG8gPSBjbS5kb2MuZmlyc3Q7XG4gICAgY20uZGlzcGxheS52aWV3ID0gW107XG4gICAgY20uZGlzcGxheS52aWV3T2Zmc2V0ID0gMDtcbiAgfVxuXG4gIC8vIEZpbmQgdGhlIHZpZXcgZWxlbWVudCBjb3JyZXNwb25kaW5nIHRvIGEgZ2l2ZW4gbGluZS4gUmV0dXJuIG51bGxcbiAgLy8gd2hlbiB0aGUgbGluZSBpc24ndCB2aXNpYmxlLlxuICBmdW5jdGlvbiBmaW5kVmlld0luZGV4KGNtLCBuKSB7XG4gICAgaWYgKG4gPj0gY20uZGlzcGxheS52aWV3VG8pIHJldHVybiBudWxsO1xuICAgIG4gLT0gY20uZGlzcGxheS52aWV3RnJvbTtcbiAgICBpZiAobiA8IDApIHJldHVybiBudWxsO1xuICAgIHZhciB2aWV3ID0gY20uZGlzcGxheS52aWV3O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgbiAtPSB2aWV3W2ldLnNpemU7XG4gICAgICBpZiAobiA8IDApIHJldHVybiBpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHZpZXdDdXR0aW5nUG9pbnQoY20sIG9sZE4sIG5ld04sIGRpcikge1xuICAgIHZhciBpbmRleCA9IGZpbmRWaWV3SW5kZXgoY20sIG9sZE4pLCBkaWZmLCB2aWV3ID0gY20uZGlzcGxheS52aWV3O1xuICAgIGlmICghc2F3Q29sbGFwc2VkU3BhbnMpIHJldHVybiB7aW5kZXg6IGluZGV4LCBsaW5lTjogbmV3Tn07XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBjbS5kaXNwbGF5LnZpZXdGcm9tOyBpIDwgaW5kZXg7IGkrKylcbiAgICAgIG4gKz0gdmlld1tpXS5zaXplO1xuICAgIGlmIChuICE9IG9sZE4pIHtcbiAgICAgIGlmIChkaXIgPiAwKSB7XG4gICAgICAgIGlmIChpbmRleCA9PSB2aWV3Lmxlbmd0aCAtIDEpIHJldHVybiBudWxsO1xuICAgICAgICBkaWZmID0gKG4gKyB2aWV3W2luZGV4XS5zaXplKSAtIG9sZE47XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaWZmID0gbiAtIG9sZE47XG4gICAgICB9XG4gICAgICBvbGROICs9IGRpZmY7IG5ld04gKz0gZGlmZjtcbiAgICB9XG4gICAgd2hpbGUgKHZpc3VhbExpbmVObyhjbS5kb2MsIG5ld04pICE9IG5ld04pIHtcbiAgICAgIGlmIChpbmRleCA9PSAoZGlyIDwgMCA/IDAgOiB2aWV3Lmxlbmd0aCAtIDEpKSByZXR1cm4gbnVsbDtcbiAgICAgIG5ld04gKz0gZGlyICogdmlld1tpbmRleCAtIChkaXIgPCAwID8gMSA6IDApXS5zaXplO1xuICAgICAgaW5kZXggKz0gZGlyO1xuICAgIH1cbiAgICByZXR1cm4ge2luZGV4OiBpbmRleCwgbGluZU46IG5ld059O1xuICB9XG5cbiAgLy8gRm9yY2UgdGhlIHZpZXcgdG8gY292ZXIgYSBnaXZlbiByYW5nZSwgYWRkaW5nIGVtcHR5IHZpZXcgZWxlbWVudFxuICAvLyBvciBjbGlwcGluZyBvZmYgZXhpc3Rpbmcgb25lcyBhcyBuZWVkZWQuXG4gIGZ1bmN0aW9uIGFkanVzdFZpZXcoY20sIGZyb20sIHRvKSB7XG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCB2aWV3ID0gZGlzcGxheS52aWV3O1xuICAgIGlmICh2aWV3Lmxlbmd0aCA9PSAwIHx8IGZyb20gPj0gZGlzcGxheS52aWV3VG8gfHwgdG8gPD0gZGlzcGxheS52aWV3RnJvbSkge1xuICAgICAgZGlzcGxheS52aWV3ID0gYnVpbGRWaWV3QXJyYXkoY20sIGZyb20sIHRvKTtcbiAgICAgIGRpc3BsYXkudmlld0Zyb20gPSBmcm9tO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZGlzcGxheS52aWV3RnJvbSA+IGZyb20pXG4gICAgICAgIGRpc3BsYXkudmlldyA9IGJ1aWxkVmlld0FycmF5KGNtLCBmcm9tLCBkaXNwbGF5LnZpZXdGcm9tKS5jb25jYXQoZGlzcGxheS52aWV3KTtcbiAgICAgIGVsc2UgaWYgKGRpc3BsYXkudmlld0Zyb20gPCBmcm9tKVxuICAgICAgICBkaXNwbGF5LnZpZXcgPSBkaXNwbGF5LnZpZXcuc2xpY2UoZmluZFZpZXdJbmRleChjbSwgZnJvbSkpO1xuICAgICAgZGlzcGxheS52aWV3RnJvbSA9IGZyb207XG4gICAgICBpZiAoZGlzcGxheS52aWV3VG8gPCB0bylcbiAgICAgICAgZGlzcGxheS52aWV3ID0gZGlzcGxheS52aWV3LmNvbmNhdChidWlsZFZpZXdBcnJheShjbSwgZGlzcGxheS52aWV3VG8sIHRvKSk7XG4gICAgICBlbHNlIGlmIChkaXNwbGF5LnZpZXdUbyA+IHRvKVxuICAgICAgICBkaXNwbGF5LnZpZXcgPSBkaXNwbGF5LnZpZXcuc2xpY2UoMCwgZmluZFZpZXdJbmRleChjbSwgdG8pKTtcbiAgICB9XG4gICAgZGlzcGxheS52aWV3VG8gPSB0bztcbiAgfVxuXG4gIC8vIENvdW50IHRoZSBudW1iZXIgb2YgbGluZXMgaW4gdGhlIHZpZXcgd2hvc2UgRE9NIHJlcHJlc2VudGF0aW9uIGlzXG4gIC8vIG91dCBvZiBkYXRlIChvciBub25leGlzdGVudCkuXG4gIGZ1bmN0aW9uIGNvdW50RGlydHlWaWV3KGNtKSB7XG4gICAgdmFyIHZpZXcgPSBjbS5kaXNwbGF5LnZpZXcsIGRpcnR5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBsaW5lVmlldyA9IHZpZXdbaV07XG4gICAgICBpZiAoIWxpbmVWaWV3LmhpZGRlbiAmJiAoIWxpbmVWaWV3Lm5vZGUgfHwgbGluZVZpZXcuY2hhbmdlcykpICsrZGlydHk7XG4gICAgfVxuICAgIHJldHVybiBkaXJ0eTtcbiAgfVxuXG4gIC8vIElOUFVUIEhBTkRMSU5HXG5cbiAgLy8gUG9sbCBmb3IgaW5wdXQgY2hhbmdlcywgdXNpbmcgdGhlIG5vcm1hbCByYXRlIG9mIHBvbGxpbmcuIFRoaXNcbiAgLy8gcnVucyBhcyBsb25nIGFzIHRoZSBlZGl0b3IgaXMgZm9jdXNlZC5cbiAgZnVuY3Rpb24gc2xvd1BvbGwoY20pIHtcbiAgICBpZiAoY20uZGlzcGxheS5wb2xsaW5nRmFzdCkgcmV0dXJuO1xuICAgIGNtLmRpc3BsYXkucG9sbC5zZXQoY20ub3B0aW9ucy5wb2xsSW50ZXJ2YWwsIGZ1bmN0aW9uKCkge1xuICAgICAgcmVhZElucHV0KGNtKTtcbiAgICAgIGlmIChjbS5zdGF0ZS5mb2N1c2VkKSBzbG93UG9sbChjbSk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBXaGVuIGFuIGV2ZW50IGhhcyBqdXN0IGNvbWUgaW4gdGhhdCBpcyBsaWtlbHkgdG8gYWRkIG9yIGNoYW5nZVxuICAvLyBzb21ldGhpbmcgaW4gdGhlIGlucHV0IHRleHRhcmVhLCB3ZSBwb2xsIGZhc3RlciwgdG8gZW5zdXJlIHRoYXRcbiAgLy8gdGhlIGNoYW5nZSBhcHBlYXJzIG9uIHRoZSBzY3JlZW4gcXVpY2tseS5cbiAgZnVuY3Rpb24gZmFzdFBvbGwoY20pIHtcbiAgICB2YXIgbWlzc2VkID0gZmFsc2U7XG4gICAgY20uZGlzcGxheS5wb2xsaW5nRmFzdCA9IHRydWU7XG4gICAgZnVuY3Rpb24gcCgpIHtcbiAgICAgIHZhciBjaGFuZ2VkID0gcmVhZElucHV0KGNtKTtcbiAgICAgIGlmICghY2hhbmdlZCAmJiAhbWlzc2VkKSB7bWlzc2VkID0gdHJ1ZTsgY20uZGlzcGxheS5wb2xsLnNldCg2MCwgcCk7fVxuICAgICAgZWxzZSB7Y20uZGlzcGxheS5wb2xsaW5nRmFzdCA9IGZhbHNlOyBzbG93UG9sbChjbSk7fVxuICAgIH1cbiAgICBjbS5kaXNwbGF5LnBvbGwuc2V0KDIwLCBwKTtcbiAgfVxuXG4gIC8vIFJlYWQgaW5wdXQgZnJvbSB0aGUgdGV4dGFyZWEsIGFuZCB1cGRhdGUgdGhlIGRvY3VtZW50IHRvIG1hdGNoLlxuICAvLyBXaGVuIHNvbWV0aGluZyBpcyBzZWxlY3RlZCwgaXQgaXMgcHJlc2VudCBpbiB0aGUgdGV4dGFyZWEsIGFuZFxuICAvLyBzZWxlY3RlZCAodW5sZXNzIGl0IGlzIGh1Z2UsIGluIHdoaWNoIGNhc2UgYSBwbGFjZWhvbGRlciBpc1xuICAvLyB1c2VkKS4gV2hlbiBub3RoaW5nIGlzIHNlbGVjdGVkLCB0aGUgY3Vyc29yIHNpdHMgYWZ0ZXIgcHJldmlvdXNseVxuICAvLyBzZWVuIHRleHQgKGNhbiBiZSBlbXB0eSksIHdoaWNoIGlzIHN0b3JlZCBpbiBwcmV2SW5wdXQgKHdlIG11c3RcbiAgLy8gbm90IHJlc2V0IHRoZSB0ZXh0YXJlYSB3aGVuIHR5cGluZywgYmVjYXVzZSB0aGF0IGJyZWFrcyBJTUUpLlxuICBmdW5jdGlvbiByZWFkSW5wdXQoY20pIHtcbiAgICB2YXIgaW5wdXQgPSBjbS5kaXNwbGF5LmlucHV0LCBwcmV2SW5wdXQgPSBjbS5kaXNwbGF5LnByZXZJbnB1dCwgZG9jID0gY20uZG9jO1xuICAgIC8vIFNpbmNlIHRoaXMgaXMgY2FsbGVkIGEgKmxvdCosIHRyeSB0byBiYWlsIG91dCBhcyBjaGVhcGx5IGFzXG4gICAgLy8gcG9zc2libGUgd2hlbiBpdCBpcyBjbGVhciB0aGF0IG5vdGhpbmcgaGFwcGVuZWQuIGhhc1NlbGVjdGlvblxuICAgIC8vIHdpbGwgYmUgdGhlIGNhc2Ugd2hlbiB0aGVyZSBpcyBhIGxvdCBvZiB0ZXh0IGluIHRoZSB0ZXh0YXJlYSxcbiAgICAvLyBpbiB3aGljaCBjYXNlIHJlYWRpbmcgaXRzIHZhbHVlIHdvdWxkIGJlIGV4cGVuc2l2ZS5cbiAgICBpZiAoIWNtLnN0YXRlLmZvY3VzZWQgfHwgKGhhc1NlbGVjdGlvbihpbnB1dCkgJiYgIXByZXZJbnB1dCkgfHwgaXNSZWFkT25seShjbSkgfHwgY20ub3B0aW9ucy5kaXNhYmxlSW5wdXQpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gU2VlIHBhc3RlIGhhbmRsZXIgZm9yIG1vcmUgb24gdGhlIGZha2VkTGFzdENoYXIga2x1ZGdlXG4gICAgaWYgKGNtLnN0YXRlLnBhc3RlSW5jb21pbmcgJiYgY20uc3RhdGUuZmFrZWRMYXN0Q2hhcikge1xuICAgICAgaW5wdXQudmFsdWUgPSBpbnB1dC52YWx1ZS5zdWJzdHJpbmcoMCwgaW5wdXQudmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgICBjbS5zdGF0ZS5mYWtlZExhc3RDaGFyID0gZmFsc2U7XG4gICAgfVxuICAgIHZhciB0ZXh0ID0gaW5wdXQudmFsdWU7XG4gICAgLy8gSWYgbm90aGluZyBjaGFuZ2VkLCBiYWlsLlxuICAgIGlmICh0ZXh0ID09IHByZXZJbnB1dCAmJiAhY20uc29tZXRoaW5nU2VsZWN0ZWQoKSkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIFdvcmsgYXJvdW5kIG5vbnNlbnNpY2FsIHNlbGVjdGlvbiByZXNldHRpbmcgaW4gSUU5LzEwXG4gICAgaWYgKGllICYmICFpZV91cHRvOCAmJiBjbS5kaXNwbGF5LmlucHV0SGFzU2VsZWN0aW9uID09PSB0ZXh0KSB7XG4gICAgICByZXNldElucHV0KGNtKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgd2l0aE9wID0gIWNtLmN1ck9wO1xuICAgIGlmICh3aXRoT3ApIHN0YXJ0T3BlcmF0aW9uKGNtKTtcbiAgICBjbS5kaXNwbGF5LnNoaWZ0ID0gZmFsc2U7XG5cbiAgICAvLyBGaW5kIHRoZSBwYXJ0IG9mIHRoZSBpbnB1dCB0aGF0IGlzIGFjdHVhbGx5IG5ld1xuICAgIHZhciBzYW1lID0gMCwgbCA9IE1hdGgubWluKHByZXZJbnB1dC5sZW5ndGgsIHRleHQubGVuZ3RoKTtcbiAgICB3aGlsZSAoc2FtZSA8IGwgJiYgcHJldklucHV0LmNoYXJDb2RlQXQoc2FtZSkgPT0gdGV4dC5jaGFyQ29kZUF0KHNhbWUpKSArK3NhbWU7XG4gICAgdmFyIGluc2VydGVkID0gdGV4dC5zbGljZShzYW1lKSwgdGV4dExpbmVzID0gc3BsaXRMaW5lcyhpbnNlcnRlZCk7XG5cbiAgICAvLyBXaGVuIHBhc2luZyBOIGxpbmVzIGludG8gTiBzZWxlY3Rpb25zLCBpbnNlcnQgb25lIGxpbmUgcGVyIHNlbGVjdGlvblxuICAgIHZhciBtdWx0aVBhc3RlID0gY20uc3RhdGUucGFzdGVJbmNvbWluZyAmJiB0ZXh0TGluZXMubGVuZ3RoID4gMSAmJiBkb2Muc2VsLnJhbmdlcy5sZW5ndGggPT0gdGV4dExpbmVzLmxlbmd0aDtcblxuICAgIC8vIE5vcm1hbCBiZWhhdmlvciBpcyB0byBpbnNlcnQgdGhlIG5ldyB0ZXh0IGludG8gZXZlcnkgc2VsZWN0aW9uXG4gICAgZm9yICh2YXIgaSA9IGRvYy5zZWwucmFuZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBkb2Muc2VsLnJhbmdlc1tpXTtcbiAgICAgIHZhciBmcm9tID0gcmFuZ2UuZnJvbSgpLCB0byA9IHJhbmdlLnRvKCk7XG4gICAgICAvLyBIYW5kbGUgZGVsZXRpb25cbiAgICAgIGlmIChzYW1lIDwgcHJldklucHV0Lmxlbmd0aClcbiAgICAgICAgZnJvbSA9IFBvcyhmcm9tLmxpbmUsIGZyb20uY2ggLSAocHJldklucHV0Lmxlbmd0aCAtIHNhbWUpKTtcbiAgICAgIC8vIEhhbmRsZSBvdmVyd3JpdGVcbiAgICAgIGVsc2UgaWYgKGNtLnN0YXRlLm92ZXJ3cml0ZSAmJiByYW5nZS5lbXB0eSgpICYmICFjbS5zdGF0ZS5wYXN0ZUluY29taW5nKVxuICAgICAgICB0byA9IFBvcyh0by5saW5lLCBNYXRoLm1pbihnZXRMaW5lKGRvYywgdG8ubGluZSkudGV4dC5sZW5ndGgsIHRvLmNoICsgbHN0KHRleHRMaW5lcykubGVuZ3RoKSk7XG4gICAgICB2YXIgdXBkYXRlSW5wdXQgPSBjbS5jdXJPcC51cGRhdGVJbnB1dDtcbiAgICAgIHZhciBjaGFuZ2VFdmVudCA9IHtmcm9tOiBmcm9tLCB0bzogdG8sIHRleHQ6IG11bHRpUGFzdGUgPyBbdGV4dExpbmVzW2ldXSA6IHRleHRMaW5lcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IGNtLnN0YXRlLnBhc3RlSW5jb21pbmcgPyBcInBhc3RlXCIgOiBjbS5zdGF0ZS5jdXRJbmNvbWluZyA/IFwiY3V0XCIgOiBcIitpbnB1dFwifTtcbiAgICAgIG1ha2VDaGFuZ2UoY20uZG9jLCBjaGFuZ2VFdmVudCk7XG4gICAgICBzaWduYWxMYXRlcihjbSwgXCJpbnB1dFJlYWRcIiwgY20sIGNoYW5nZUV2ZW50KTtcbiAgICAgIC8vIFdoZW4gYW4gJ2VsZWN0cmljJyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQsIGltbWVkaWF0ZWx5IHRyaWdnZXIgYSByZWluZGVudFxuICAgICAgaWYgKGluc2VydGVkICYmICFjbS5zdGF0ZS5wYXN0ZUluY29taW5nICYmIGNtLm9wdGlvbnMuZWxlY3RyaWNDaGFycyAmJlxuICAgICAgICAgIGNtLm9wdGlvbnMuc21hcnRJbmRlbnQgJiYgcmFuZ2UuaGVhZC5jaCA8IDEwMCAmJlxuICAgICAgICAgICghaSB8fCBkb2Muc2VsLnJhbmdlc1tpIC0gMV0uaGVhZC5saW5lICE9IHJhbmdlLmhlYWQubGluZSkpIHtcbiAgICAgICAgdmFyIG1vZGUgPSBjbS5nZXRNb2RlQXQocmFuZ2UuaGVhZCk7XG4gICAgICAgIGlmIChtb2RlLmVsZWN0cmljQ2hhcnMpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1vZGUuZWxlY3RyaWNDaGFycy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgIGlmIChpbnNlcnRlZC5pbmRleE9mKG1vZGUuZWxlY3RyaWNDaGFycy5jaGFyQXQoaikpID4gLTEpIHtcbiAgICAgICAgICAgICAgaW5kZW50TGluZShjbSwgcmFuZ2UuaGVhZC5saW5lLCBcInNtYXJ0XCIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtb2RlLmVsZWN0cmljSW5wdXQpIHtcbiAgICAgICAgICB2YXIgZW5kID0gY2hhbmdlRW5kKGNoYW5nZUV2ZW50KTtcbiAgICAgICAgICBpZiAobW9kZS5lbGVjdHJpY0lucHV0LnRlc3QoZ2V0TGluZShkb2MsIGVuZC5saW5lKS50ZXh0LnNsaWNlKDAsIGVuZC5jaCkpKVxuICAgICAgICAgICAgaW5kZW50TGluZShjbSwgcmFuZ2UuaGVhZC5saW5lLCBcInNtYXJ0XCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGVuc3VyZUN1cnNvclZpc2libGUoY20pO1xuICAgIGNtLmN1ck9wLnVwZGF0ZUlucHV0ID0gdXBkYXRlSW5wdXQ7XG4gICAgY20uY3VyT3AudHlwaW5nID0gdHJ1ZTtcblxuICAgIC8vIERvbid0IGxlYXZlIGxvbmcgdGV4dCBpbiB0aGUgdGV4dGFyZWEsIHNpbmNlIGl0IG1ha2VzIGZ1cnRoZXIgcG9sbGluZyBzbG93XG4gICAgaWYgKHRleHQubGVuZ3RoID4gMTAwMCB8fCB0ZXh0LmluZGV4T2YoXCJcXG5cIikgPiAtMSkgaW5wdXQudmFsdWUgPSBjbS5kaXNwbGF5LnByZXZJbnB1dCA9IFwiXCI7XG4gICAgZWxzZSBjbS5kaXNwbGF5LnByZXZJbnB1dCA9IHRleHQ7XG4gICAgaWYgKHdpdGhPcCkgZW5kT3BlcmF0aW9uKGNtKTtcbiAgICBjbS5zdGF0ZS5wYXN0ZUluY29taW5nID0gY20uc3RhdGUuY3V0SW5jb21pbmcgPSBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIFJlc2V0IHRoZSBpbnB1dCB0byBjb3JyZXNwb25kIHRvIHRoZSBzZWxlY3Rpb24gKG9yIHRvIGJlIGVtcHR5LFxuICAvLyB3aGVuIG5vdCB0eXBpbmcgYW5kIG5vdGhpbmcgaXMgc2VsZWN0ZWQpXG4gIGZ1bmN0aW9uIHJlc2V0SW5wdXQoY20sIHR5cGluZykge1xuICAgIHZhciBtaW5pbWFsLCBzZWxlY3RlZCwgZG9jID0gY20uZG9jO1xuICAgIGlmIChjbS5zb21ldGhpbmdTZWxlY3RlZCgpKSB7XG4gICAgICBjbS5kaXNwbGF5LnByZXZJbnB1dCA9IFwiXCI7XG4gICAgICB2YXIgcmFuZ2UgPSBkb2Muc2VsLnByaW1hcnkoKTtcbiAgICAgIG1pbmltYWwgPSBoYXNDb3B5RXZlbnQgJiZcbiAgICAgICAgKHJhbmdlLnRvKCkubGluZSAtIHJhbmdlLmZyb20oKS5saW5lID4gMTAwIHx8IChzZWxlY3RlZCA9IGNtLmdldFNlbGVjdGlvbigpKS5sZW5ndGggPiAxMDAwKTtcbiAgICAgIHZhciBjb250ZW50ID0gbWluaW1hbCA/IFwiLVwiIDogc2VsZWN0ZWQgfHwgY20uZ2V0U2VsZWN0aW9uKCk7XG4gICAgICBjbS5kaXNwbGF5LmlucHV0LnZhbHVlID0gY29udGVudDtcbiAgICAgIGlmIChjbS5zdGF0ZS5mb2N1c2VkKSBzZWxlY3RJbnB1dChjbS5kaXNwbGF5LmlucHV0KTtcbiAgICAgIGlmIChpZSAmJiAhaWVfdXB0bzgpIGNtLmRpc3BsYXkuaW5wdXRIYXNTZWxlY3Rpb24gPSBjb250ZW50O1xuICAgIH0gZWxzZSBpZiAoIXR5cGluZykge1xuICAgICAgY20uZGlzcGxheS5wcmV2SW5wdXQgPSBjbS5kaXNwbGF5LmlucHV0LnZhbHVlID0gXCJcIjtcbiAgICAgIGlmIChpZSAmJiAhaWVfdXB0bzgpIGNtLmRpc3BsYXkuaW5wdXRIYXNTZWxlY3Rpb24gPSBudWxsO1xuICAgIH1cbiAgICBjbS5kaXNwbGF5LmluYWNjdXJhdGVTZWxlY3Rpb24gPSBtaW5pbWFsO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9jdXNJbnB1dChjbSkge1xuICAgIGlmIChjbS5vcHRpb25zLnJlYWRPbmx5ICE9IFwibm9jdXJzb3JcIiAmJiAoIW1vYmlsZSB8fCBhY3RpdmVFbHQoKSAhPSBjbS5kaXNwbGF5LmlucHV0KSlcbiAgICAgIGNtLmRpc3BsYXkuaW5wdXQuZm9jdXMoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuc3VyZUZvY3VzKGNtKSB7XG4gICAgaWYgKCFjbS5zdGF0ZS5mb2N1c2VkKSB7IGZvY3VzSW5wdXQoY20pOyBvbkZvY3VzKGNtKTsgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNSZWFkT25seShjbSkge1xuICAgIHJldHVybiBjbS5vcHRpb25zLnJlYWRPbmx5IHx8IGNtLmRvYy5jYW50RWRpdDtcbiAgfVxuXG4gIC8vIEVWRU5UIEhBTkRMRVJTXG5cbiAgLy8gQXR0YWNoIHRoZSBuZWNlc3NhcnkgZXZlbnQgaGFuZGxlcnMgd2hlbiBpbml0aWFsaXppbmcgdGhlIGVkaXRvclxuICBmdW5jdGlvbiByZWdpc3RlckV2ZW50SGFuZGxlcnMoY20pIHtcbiAgICB2YXIgZCA9IGNtLmRpc3BsYXk7XG4gICAgb24oZC5zY3JvbGxlciwgXCJtb3VzZWRvd25cIiwgb3BlcmF0aW9uKGNtLCBvbk1vdXNlRG93bikpO1xuICAgIC8vIE9sZGVyIElFJ3Mgd2lsbCBub3QgZmlyZSBhIHNlY29uZCBtb3VzZWRvd24gZm9yIGEgZG91YmxlIGNsaWNrXG4gICAgaWYgKGllX3VwdG8xMClcbiAgICAgIG9uKGQuc2Nyb2xsZXIsIFwiZGJsY2xpY2tcIiwgb3BlcmF0aW9uKGNtLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChzaWduYWxET01FdmVudChjbSwgZSkpIHJldHVybjtcbiAgICAgICAgdmFyIHBvcyA9IHBvc0Zyb21Nb3VzZShjbSwgZSk7XG4gICAgICAgIGlmICghcG9zIHx8IGNsaWNrSW5HdXR0ZXIoY20sIGUpIHx8IGV2ZW50SW5XaWRnZXQoY20uZGlzcGxheSwgZSkpIHJldHVybjtcbiAgICAgICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgdmFyIHdvcmQgPSBmaW5kV29yZEF0KGNtLmRvYywgcG9zKTtcbiAgICAgICAgZXh0ZW5kU2VsZWN0aW9uKGNtLmRvYywgd29yZC5hbmNob3IsIHdvcmQuaGVhZCk7XG4gICAgICB9KSk7XG4gICAgZWxzZVxuICAgICAgb24oZC5zY3JvbGxlciwgXCJkYmxjbGlja1wiLCBmdW5jdGlvbihlKSB7IHNpZ25hbERPTUV2ZW50KGNtLCBlKSB8fCBlX3ByZXZlbnREZWZhdWx0KGUpOyB9KTtcbiAgICAvLyBQcmV2ZW50IG5vcm1hbCBzZWxlY3Rpb24gaW4gdGhlIGVkaXRvciAod2UgaGFuZGxlIG91ciBvd24pXG4gICAgb24oZC5saW5lU3BhY2UsIFwic2VsZWN0c3RhcnRcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKCFldmVudEluV2lkZ2V0KGQsIGUpKSBlX3ByZXZlbnREZWZhdWx0KGUpO1xuICAgIH0pO1xuICAgIC8vIFNvbWUgYnJvd3NlcnMgZmlyZSBjb250ZXh0bWVudSAqYWZ0ZXIqIG9wZW5pbmcgdGhlIG1lbnUsIGF0XG4gICAgLy8gd2hpY2ggcG9pbnQgd2UgY2FuJ3QgbWVzcyB3aXRoIGl0IGFueW1vcmUuIENvbnRleHQgbWVudSBpc1xuICAgIC8vIGhhbmRsZWQgaW4gb25Nb3VzZURvd24gZm9yIHRoZXNlIGJyb3dzZXJzLlxuICAgIGlmICghY2FwdHVyZVJpZ2h0Q2xpY2spIG9uKGQuc2Nyb2xsZXIsIFwiY29udGV4dG1lbnVcIiwgZnVuY3Rpb24oZSkge29uQ29udGV4dE1lbnUoY20sIGUpO30pO1xuXG4gICAgLy8gU3luYyBzY3JvbGxpbmcgYmV0d2VlbiBmYWtlIHNjcm9sbGJhcnMgYW5kIHJlYWwgc2Nyb2xsYWJsZVxuICAgIC8vIGFyZWEsIGVuc3VyZSB2aWV3cG9ydCBpcyB1cGRhdGVkIHdoZW4gc2Nyb2xsaW5nLlxuICAgIG9uKGQuc2Nyb2xsZXIsIFwic2Nyb2xsXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGQuc2Nyb2xsZXIuY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgIHNldFNjcm9sbFRvcChjbSwgZC5zY3JvbGxlci5zY3JvbGxUb3ApO1xuICAgICAgICBzZXRTY3JvbGxMZWZ0KGNtLCBkLnNjcm9sbGVyLnNjcm9sbExlZnQsIHRydWUpO1xuICAgICAgICBzaWduYWwoY20sIFwic2Nyb2xsXCIsIGNtKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBvbihkLnNjcm9sbGJhclYsIFwic2Nyb2xsXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGQuc2Nyb2xsZXIuY2xpZW50SGVpZ2h0KSBzZXRTY3JvbGxUb3AoY20sIGQuc2Nyb2xsYmFyVi5zY3JvbGxUb3ApO1xuICAgIH0pO1xuICAgIG9uKGQuc2Nyb2xsYmFySCwgXCJzY3JvbGxcIiwgZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoZC5zY3JvbGxlci5jbGllbnRIZWlnaHQpIHNldFNjcm9sbExlZnQoY20sIGQuc2Nyb2xsYmFySC5zY3JvbGxMZWZ0KTtcbiAgICB9KTtcblxuICAgIC8vIExpc3RlbiB0byB3aGVlbCBldmVudHMgaW4gb3JkZXIgdG8gdHJ5IGFuZCB1cGRhdGUgdGhlIHZpZXdwb3J0IG9uIHRpbWUuXG4gICAgb24oZC5zY3JvbGxlciwgXCJtb3VzZXdoZWVsXCIsIGZ1bmN0aW9uKGUpe29uU2Nyb2xsV2hlZWwoY20sIGUpO30pO1xuICAgIG9uKGQuc2Nyb2xsZXIsIFwiRE9NTW91c2VTY3JvbGxcIiwgZnVuY3Rpb24oZSl7b25TY3JvbGxXaGVlbChjbSwgZSk7fSk7XG5cbiAgICAvLyBQcmV2ZW50IGNsaWNrcyBpbiB0aGUgc2Nyb2xsYmFycyBmcm9tIGtpbGxpbmcgZm9jdXNcbiAgICBmdW5jdGlvbiByZUZvY3VzKCkgeyBpZiAoY20uc3RhdGUuZm9jdXNlZCkgc2V0VGltZW91dChiaW5kKGZvY3VzSW5wdXQsIGNtKSwgMCk7IH1cbiAgICBvbihkLnNjcm9sbGJhckgsIFwibW91c2Vkb3duXCIsIHJlRm9jdXMpO1xuICAgIG9uKGQuc2Nyb2xsYmFyViwgXCJtb3VzZWRvd25cIiwgcmVGb2N1cyk7XG4gICAgLy8gUHJldmVudCB3cmFwcGVyIGZyb20gZXZlciBzY3JvbGxpbmdcbiAgICBvbihkLndyYXBwZXIsIFwic2Nyb2xsXCIsIGZ1bmN0aW9uKCkgeyBkLndyYXBwZXIuc2Nyb2xsVG9wID0gZC53cmFwcGVyLnNjcm9sbExlZnQgPSAwOyB9KTtcblxuICAgIC8vIFdoZW4gdGhlIHdpbmRvdyByZXNpemVzLCB3ZSBuZWVkIHRvIHJlZnJlc2ggYWN0aXZlIGVkaXRvcnMuXG4gICAgdmFyIHJlc2l6ZVRpbWVyO1xuICAgIGZ1bmN0aW9uIG9uUmVzaXplKCkge1xuICAgICAgaWYgKHJlc2l6ZVRpbWVyID09IG51bGwpIHJlc2l6ZVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgcmVzaXplVGltZXIgPSBudWxsO1xuICAgICAgICAvLyBNaWdodCBiZSBhIHRleHQgc2NhbGluZyBvcGVyYXRpb24sIGNsZWFyIHNpemUgY2FjaGVzLlxuICAgICAgICBkLmNhY2hlZENoYXJXaWR0aCA9IGQuY2FjaGVkVGV4dEhlaWdodCA9IGQuY2FjaGVkUGFkZGluZ0ggPSBrbm93blNjcm9sbGJhcldpZHRoID0gbnVsbDtcbiAgICAgICAgY20uc2V0U2l6ZSgpO1xuICAgICAgfSwgMTAwKTtcbiAgICB9XG4gICAgb24od2luZG93LCBcInJlc2l6ZVwiLCBvblJlc2l6ZSk7XG4gICAgLy8gVGhlIGFib3ZlIGhhbmRsZXIgaG9sZHMgb24gdG8gdGhlIGVkaXRvciBhbmQgaXRzIGRhdGFcbiAgICAvLyBzdHJ1Y3R1cmVzLiBIZXJlIHdlIHBvbGwgdG8gdW5yZWdpc3RlciBpdCB3aGVuIHRoZSBlZGl0b3IgaXMgbm9cbiAgICAvLyBsb25nZXIgaW4gdGhlIGRvY3VtZW50LCBzbyB0aGF0IGl0IGNhbiBiZSBnYXJiYWdlLWNvbGxlY3RlZC5cbiAgICBmdW5jdGlvbiB1bnJlZ2lzdGVyKCkge1xuICAgICAgaWYgKGNvbnRhaW5zKGRvY3VtZW50LmJvZHksIGQud3JhcHBlcikpIHNldFRpbWVvdXQodW5yZWdpc3RlciwgNTAwMCk7XG4gICAgICBlbHNlIG9mZih3aW5kb3csIFwicmVzaXplXCIsIG9uUmVzaXplKTtcbiAgICB9XG4gICAgc2V0VGltZW91dCh1bnJlZ2lzdGVyLCA1MDAwKTtcblxuICAgIG9uKGQuaW5wdXQsIFwia2V5dXBcIiwgb3BlcmF0aW9uKGNtLCBvbktleVVwKSk7XG4gICAgb24oZC5pbnB1dCwgXCJpbnB1dFwiLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChpZSAmJiAhaWVfdXB0bzggJiYgY20uZGlzcGxheS5pbnB1dEhhc1NlbGVjdGlvbikgY20uZGlzcGxheS5pbnB1dEhhc1NlbGVjdGlvbiA9IG51bGw7XG4gICAgICBmYXN0UG9sbChjbSk7XG4gICAgfSk7XG4gICAgb24oZC5pbnB1dCwgXCJrZXlkb3duXCIsIG9wZXJhdGlvbihjbSwgb25LZXlEb3duKSk7XG4gICAgb24oZC5pbnB1dCwgXCJrZXlwcmVzc1wiLCBvcGVyYXRpb24oY20sIG9uS2V5UHJlc3MpKTtcbiAgICBvbihkLmlucHV0LCBcImZvY3VzXCIsIGJpbmQob25Gb2N1cywgY20pKTtcbiAgICBvbihkLmlucHV0LCBcImJsdXJcIiwgYmluZChvbkJsdXIsIGNtKSk7XG5cbiAgICBmdW5jdGlvbiBkcmFnXyhlKSB7XG4gICAgICBpZiAoIXNpZ25hbERPTUV2ZW50KGNtLCBlKSkgZV9zdG9wKGUpO1xuICAgIH1cbiAgICBpZiAoY20ub3B0aW9ucy5kcmFnRHJvcCkge1xuICAgICAgb24oZC5zY3JvbGxlciwgXCJkcmFnc3RhcnRcIiwgZnVuY3Rpb24oZSl7b25EcmFnU3RhcnQoY20sIGUpO30pO1xuICAgICAgb24oZC5zY3JvbGxlciwgXCJkcmFnZW50ZXJcIiwgZHJhZ18pO1xuICAgICAgb24oZC5zY3JvbGxlciwgXCJkcmFnb3ZlclwiLCBkcmFnXyk7XG4gICAgICBvbihkLnNjcm9sbGVyLCBcImRyb3BcIiwgb3BlcmF0aW9uKGNtLCBvbkRyb3ApKTtcbiAgICB9XG4gICAgb24oZC5zY3JvbGxlciwgXCJwYXN0ZVwiLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoZXZlbnRJbldpZGdldChkLCBlKSkgcmV0dXJuO1xuICAgICAgY20uc3RhdGUucGFzdGVJbmNvbWluZyA9IHRydWU7XG4gICAgICBmb2N1c0lucHV0KGNtKTtcbiAgICAgIGZhc3RQb2xsKGNtKTtcbiAgICB9KTtcbiAgICBvbihkLmlucHV0LCBcInBhc3RlXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgLy8gV29ya2Fyb3VuZCBmb3Igd2Via2l0IGJ1ZyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9OTAyMDZcbiAgICAgIC8vIEFkZCBhIGNoYXIgdG8gdGhlIGVuZCBvZiB0ZXh0YXJlYSBiZWZvcmUgcGFzdGUgb2NjdXIgc28gdGhhdFxuICAgICAgLy8gc2VsZWN0aW9uIGRvZXNuJ3Qgc3BhbiB0byB0aGUgZW5kIG9mIHRleHRhcmVhLlxuICAgICAgaWYgKHdlYmtpdCAmJiAhY20uc3RhdGUuZmFrZWRMYXN0Q2hhciAmJiAhKG5ldyBEYXRlIC0gY20uc3RhdGUubGFzdE1pZGRsZURvd24gPCAyMDApKSB7XG4gICAgICAgIHZhciBzdGFydCA9IGQuaW5wdXQuc2VsZWN0aW9uU3RhcnQsIGVuZCA9IGQuaW5wdXQuc2VsZWN0aW9uRW5kO1xuICAgICAgICBkLmlucHV0LnZhbHVlICs9IFwiJFwiO1xuICAgICAgICBkLmlucHV0LnNlbGVjdGlvblN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIGQuaW5wdXQuc2VsZWN0aW9uRW5kID0gZW5kO1xuICAgICAgICBjbS5zdGF0ZS5mYWtlZExhc3RDaGFyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNtLnN0YXRlLnBhc3RlSW5jb21pbmcgPSB0cnVlO1xuICAgICAgZmFzdFBvbGwoY20pO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gcHJlcGFyZUNvcHlDdXQoZSkge1xuICAgICAgaWYgKGNtLnNvbWV0aGluZ1NlbGVjdGVkKCkpIHtcbiAgICAgICAgaWYgKGQuaW5hY2N1cmF0ZVNlbGVjdGlvbikge1xuICAgICAgICAgIGQucHJldklucHV0ID0gXCJcIjtcbiAgICAgICAgICBkLmluYWNjdXJhdGVTZWxlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgICBkLmlucHV0LnZhbHVlID0gY20uZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgc2VsZWN0SW5wdXQoZC5pbnB1dCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0ZXh0ID0gXCJcIiwgcmFuZ2VzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY20uZG9jLnNlbC5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbGluZSA9IGNtLmRvYy5zZWwucmFuZ2VzW2ldLmhlYWQubGluZTtcbiAgICAgICAgICB2YXIgbGluZVJhbmdlID0ge2FuY2hvcjogUG9zKGxpbmUsIDApLCBoZWFkOiBQb3MobGluZSArIDEsIDApfTtcbiAgICAgICAgICByYW5nZXMucHVzaChsaW5lUmFuZ2UpO1xuICAgICAgICAgIHRleHQgKz0gY20uZ2V0UmFuZ2UobGluZVJhbmdlLmFuY2hvciwgbGluZVJhbmdlLmhlYWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlLnR5cGUgPT0gXCJjdXRcIikge1xuICAgICAgICAgIGNtLnNldFNlbGVjdGlvbnMocmFuZ2VzLCBudWxsLCBzZWxfZG9udFNjcm9sbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZC5wcmV2SW5wdXQgPSBcIlwiO1xuICAgICAgICAgIGQuaW5wdXQudmFsdWUgPSB0ZXh0O1xuICAgICAgICAgIHNlbGVjdElucHV0KGQuaW5wdXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZS50eXBlID09IFwiY3V0XCIpIGNtLnN0YXRlLmN1dEluY29taW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgb24oZC5pbnB1dCwgXCJjdXRcIiwgcHJlcGFyZUNvcHlDdXQpO1xuICAgIG9uKGQuaW5wdXQsIFwiY29weVwiLCBwcmVwYXJlQ29weUN1dCk7XG5cbiAgICAvLyBOZWVkZWQgdG8gaGFuZGxlIFRhYiBrZXkgaW4gS0hUTUxcbiAgICBpZiAoa2h0bWwpIG9uKGQuc2l6ZXIsIFwibW91c2V1cFwiLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChhY3RpdmVFbHQoKSA9PSBkLmlucHV0KSBkLmlucHV0LmJsdXIoKTtcbiAgICAgIGZvY3VzSW5wdXQoY20pO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gTU9VU0UgRVZFTlRTXG5cbiAgLy8gUmV0dXJuIHRydWUgd2hlbiB0aGUgZ2l2ZW4gbW91c2UgZXZlbnQgaGFwcGVuZWQgaW4gYSB3aWRnZXRcbiAgZnVuY3Rpb24gZXZlbnRJbldpZGdldChkaXNwbGF5LCBlKSB7XG4gICAgZm9yICh2YXIgbiA9IGVfdGFyZ2V0KGUpOyBuICE9IGRpc3BsYXkud3JhcHBlcjsgbiA9IG4ucGFyZW50Tm9kZSkge1xuICAgICAgaWYgKCFuIHx8IG4uaWdub3JlRXZlbnRzIHx8IG4ucGFyZW50Tm9kZSA9PSBkaXNwbGF5LnNpemVyICYmIG4gIT0gZGlzcGxheS5tb3ZlcikgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gR2l2ZW4gYSBtb3VzZSBldmVudCwgZmluZCB0aGUgY29ycmVzcG9uZGluZyBwb3NpdGlvbi4gSWYgbGliZXJhbFxuICAvLyBpcyBmYWxzZSwgaXQgY2hlY2tzIHdoZXRoZXIgYSBndXR0ZXIgb3Igc2Nyb2xsYmFyIHdhcyBjbGlja2VkLFxuICAvLyBhbmQgcmV0dXJucyBudWxsIGlmIGl0IHdhcy4gZm9yUmVjdCBpcyB1c2VkIGJ5IHJlY3Rhbmd1bGFyXG4gIC8vIHNlbGVjdGlvbnMsIGFuZCB0cmllcyB0byBlc3RpbWF0ZSBhIGNoYXJhY3RlciBwb3NpdGlvbiBldmVuIGZvclxuICAvLyBjb29yZGluYXRlcyBiZXlvbmQgdGhlIHJpZ2h0IG9mIHRoZSB0ZXh0LlxuICBmdW5jdGlvbiBwb3NGcm9tTW91c2UoY20sIGUsIGxpYmVyYWwsIGZvclJlY3QpIHtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG4gICAgaWYgKCFsaWJlcmFsKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gZV90YXJnZXQoZSk7XG4gICAgICBpZiAodGFyZ2V0ID09IGRpc3BsYXkuc2Nyb2xsYmFySCB8fCB0YXJnZXQgPT0gZGlzcGxheS5zY3JvbGxiYXJWIHx8XG4gICAgICAgICAgdGFyZ2V0ID09IGRpc3BsYXkuc2Nyb2xsYmFyRmlsbGVyIHx8IHRhcmdldCA9PSBkaXNwbGF5Lmd1dHRlckZpbGxlcikgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciB4LCB5LCBzcGFjZSA9IGRpc3BsYXkubGluZVNwYWNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIC8vIEZhaWxzIHVucHJlZGljdGFibHkgb24gSUVbNjddIHdoZW4gbW91c2UgaXMgZHJhZ2dlZCBhcm91bmQgcXVpY2tseS5cbiAgICB0cnkgeyB4ID0gZS5jbGllbnRYIC0gc3BhY2UubGVmdDsgeSA9IGUuY2xpZW50WSAtIHNwYWNlLnRvcDsgfVxuICAgIGNhdGNoIChlKSB7IHJldHVybiBudWxsOyB9XG4gICAgdmFyIGNvb3JkcyA9IGNvb3Jkc0NoYXIoY20sIHgsIHkpLCBsaW5lO1xuICAgIGlmIChmb3JSZWN0ICYmIGNvb3Jkcy54UmVsID09IDEgJiYgKGxpbmUgPSBnZXRMaW5lKGNtLmRvYywgY29vcmRzLmxpbmUpLnRleHQpLmxlbmd0aCA9PSBjb29yZHMuY2gpIHtcbiAgICAgIHZhciBjb2xEaWZmID0gY291bnRDb2x1bW4obGluZSwgbGluZS5sZW5ndGgsIGNtLm9wdGlvbnMudGFiU2l6ZSkgLSBsaW5lLmxlbmd0aDtcbiAgICAgIGNvb3JkcyA9IFBvcyhjb29yZHMubGluZSwgTWF0aC5tYXgoMCwgTWF0aC5yb3VuZCgoeCAtIHBhZGRpbmdIKGNtLmRpc3BsYXkpLmxlZnQpIC8gY2hhcldpZHRoKGNtLmRpc3BsYXkpKSAtIGNvbERpZmYpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvb3JkcztcbiAgfVxuXG4gIC8vIEEgbW91c2UgZG93biBjYW4gYmUgYSBzaW5nbGUgY2xpY2ssIGRvdWJsZSBjbGljaywgdHJpcGxlIGNsaWNrLFxuICAvLyBzdGFydCBvZiBzZWxlY3Rpb24gZHJhZywgc3RhcnQgb2YgdGV4dCBkcmFnLCBuZXcgY3Vyc29yXG4gIC8vIChjdHJsLWNsaWNrKSwgcmVjdGFuZ2xlIGRyYWcgKGFsdC1kcmFnKSwgb3IgeHdpblxuICAvLyBtaWRkbGUtY2xpY2stcGFzdGUuIE9yIGl0IG1pZ2h0IGJlIGEgY2xpY2sgb24gc29tZXRoaW5nIHdlIHNob3VsZFxuICAvLyBub3QgaW50ZXJmZXJlIHdpdGgsIHN1Y2ggYXMgYSBzY3JvbGxiYXIgb3Igd2lkZ2V0LlxuICBmdW5jdGlvbiBvbk1vdXNlRG93bihlKSB7XG4gICAgaWYgKHNpZ25hbERPTUV2ZW50KHRoaXMsIGUpKSByZXR1cm47XG4gICAgdmFyIGNtID0gdGhpcywgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG4gICAgZGlzcGxheS5zaGlmdCA9IGUuc2hpZnRLZXk7XG5cbiAgICBpZiAoZXZlbnRJbldpZGdldChkaXNwbGF5LCBlKSkge1xuICAgICAgaWYgKCF3ZWJraXQpIHtcbiAgICAgICAgLy8gQnJpZWZseSB0dXJuIG9mZiBkcmFnZ2FiaWxpdHksIHRvIGFsbG93IHdpZGdldHMgdG8gZG9cbiAgICAgICAgLy8gbm9ybWFsIGRyYWdnaW5nIHRoaW5ncy5cbiAgICAgICAgZGlzcGxheS5zY3JvbGxlci5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe2Rpc3BsYXkuc2Nyb2xsZXIuZHJhZ2dhYmxlID0gdHJ1ZTt9LCAxMDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY2xpY2tJbkd1dHRlcihjbSwgZSkpIHJldHVybjtcbiAgICB2YXIgc3RhcnQgPSBwb3NGcm9tTW91c2UoY20sIGUpO1xuICAgIHdpbmRvdy5mb2N1cygpO1xuXG4gICAgc3dpdGNoIChlX2J1dHRvbihlKSkge1xuICAgIGNhc2UgMTpcbiAgICAgIGlmIChzdGFydClcbiAgICAgICAgbGVmdEJ1dHRvbkRvd24oY20sIGUsIHN0YXJ0KTtcbiAgICAgIGVsc2UgaWYgKGVfdGFyZ2V0KGUpID09IGRpc3BsYXkuc2Nyb2xsZXIpXG4gICAgICAgIGVfcHJldmVudERlZmF1bHQoZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI6XG4gICAgICBpZiAod2Via2l0KSBjbS5zdGF0ZS5sYXN0TWlkZGxlRG93biA9ICtuZXcgRGF0ZTtcbiAgICAgIGlmIChzdGFydCkgZXh0ZW5kU2VsZWN0aW9uKGNtLmRvYywgc3RhcnQpO1xuICAgICAgc2V0VGltZW91dChiaW5kKGZvY3VzSW5wdXQsIGNtKSwgMjApO1xuICAgICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzpcbiAgICAgIGlmIChjYXB0dXJlUmlnaHRDbGljaykgb25Db250ZXh0TWVudShjbSwgZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgbGFzdENsaWNrLCBsYXN0RG91YmxlQ2xpY2s7XG4gIGZ1bmN0aW9uIGxlZnRCdXR0b25Eb3duKGNtLCBlLCBzdGFydCkge1xuICAgIHNldFRpbWVvdXQoYmluZChlbnN1cmVGb2N1cywgY20pLCAwKTtcblxuICAgIHZhciBub3cgPSArbmV3IERhdGUsIHR5cGU7XG4gICAgaWYgKGxhc3REb3VibGVDbGljayAmJiBsYXN0RG91YmxlQ2xpY2sudGltZSA+IG5vdyAtIDQwMCAmJiBjbXAobGFzdERvdWJsZUNsaWNrLnBvcywgc3RhcnQpID09IDApIHtcbiAgICAgIHR5cGUgPSBcInRyaXBsZVwiO1xuICAgIH0gZWxzZSBpZiAobGFzdENsaWNrICYmIGxhc3RDbGljay50aW1lID4gbm93IC0gNDAwICYmIGNtcChsYXN0Q2xpY2sucG9zLCBzdGFydCkgPT0gMCkge1xuICAgICAgdHlwZSA9IFwiZG91YmxlXCI7XG4gICAgICBsYXN0RG91YmxlQ2xpY2sgPSB7dGltZTogbm93LCBwb3M6IHN0YXJ0fTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZSA9IFwic2luZ2xlXCI7XG4gICAgICBsYXN0Q2xpY2sgPSB7dGltZTogbm93LCBwb3M6IHN0YXJ0fTtcbiAgICB9XG5cbiAgICB2YXIgc2VsID0gY20uZG9jLnNlbCwgYWRkTmV3ID0gbWFjID8gZS5tZXRhS2V5IDogZS5jdHJsS2V5O1xuICAgIGlmIChjbS5vcHRpb25zLmRyYWdEcm9wICYmIGRyYWdBbmREcm9wICYmICFhZGROZXcgJiYgIWlzUmVhZE9ubHkoY20pICYmXG4gICAgICAgIHR5cGUgPT0gXCJzaW5nbGVcIiAmJiBzZWwuY29udGFpbnMoc3RhcnQpID4gLTEgJiYgc2VsLnNvbWV0aGluZ1NlbGVjdGVkKCkpXG4gICAgICBsZWZ0QnV0dG9uU3RhcnREcmFnKGNtLCBlLCBzdGFydCk7XG4gICAgZWxzZVxuICAgICAgbGVmdEJ1dHRvblNlbGVjdChjbSwgZSwgc3RhcnQsIHR5cGUsIGFkZE5ldyk7XG4gIH1cblxuICAvLyBTdGFydCBhIHRleHQgZHJhZy4gV2hlbiBpdCBlbmRzLCBzZWUgaWYgYW55IGRyYWdnaW5nIGFjdHVhbGx5XG4gIC8vIGhhcHBlbiwgYW5kIHRyZWF0IGFzIGEgY2xpY2sgaWYgaXQgZGlkbid0LlxuICBmdW5jdGlvbiBsZWZ0QnV0dG9uU3RhcnREcmFnKGNtLCBlLCBzdGFydCkge1xuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICB2YXIgZHJhZ0VuZCA9IG9wZXJhdGlvbihjbSwgZnVuY3Rpb24oZTIpIHtcbiAgICAgIGlmICh3ZWJraXQpIGRpc3BsYXkuc2Nyb2xsZXIuZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICBjbS5zdGF0ZS5kcmFnZ2luZ1RleHQgPSBmYWxzZTtcbiAgICAgIG9mZihkb2N1bWVudCwgXCJtb3VzZXVwXCIsIGRyYWdFbmQpO1xuICAgICAgb2ZmKGRpc3BsYXkuc2Nyb2xsZXIsIFwiZHJvcFwiLCBkcmFnRW5kKTtcbiAgICAgIGlmIChNYXRoLmFicyhlLmNsaWVudFggLSBlMi5jbGllbnRYKSArIE1hdGguYWJzKGUuY2xpZW50WSAtIGUyLmNsaWVudFkpIDwgMTApIHtcbiAgICAgICAgZV9wcmV2ZW50RGVmYXVsdChlMik7XG4gICAgICAgIGV4dGVuZFNlbGVjdGlvbihjbS5kb2MsIHN0YXJ0KTtcbiAgICAgICAgZm9jdXNJbnB1dChjbSk7XG4gICAgICAgIC8vIFdvcmsgYXJvdW5kIHVuZXhwbGFpbmFibGUgZm9jdXMgcHJvYmxlbSBpbiBJRTkgKCMyMTI3KVxuICAgICAgICBpZiAoaWVfdXB0bzEwICYmICFpZV91cHRvOClcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge2RvY3VtZW50LmJvZHkuZm9jdXMoKTsgZm9jdXNJbnB1dChjbSk7fSwgMjApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIExldCB0aGUgZHJhZyBoYW5kbGVyIGhhbmRsZSB0aGlzLlxuICAgIGlmICh3ZWJraXQpIGRpc3BsYXkuc2Nyb2xsZXIuZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICBjbS5zdGF0ZS5kcmFnZ2luZ1RleHQgPSBkcmFnRW5kO1xuICAgIC8vIElFJ3MgYXBwcm9hY2ggdG8gZHJhZ2dhYmxlXG4gICAgaWYgKGRpc3BsYXkuc2Nyb2xsZXIuZHJhZ0Ryb3ApIGRpc3BsYXkuc2Nyb2xsZXIuZHJhZ0Ryb3AoKTtcbiAgICBvbihkb2N1bWVudCwgXCJtb3VzZXVwXCIsIGRyYWdFbmQpO1xuICAgIG9uKGRpc3BsYXkuc2Nyb2xsZXIsIFwiZHJvcFwiLCBkcmFnRW5kKTtcbiAgfVxuXG4gIC8vIE5vcm1hbCBzZWxlY3Rpb24sIGFzIG9wcG9zZWQgdG8gdGV4dCBkcmFnZ2luZy5cbiAgZnVuY3Rpb24gbGVmdEJ1dHRvblNlbGVjdChjbSwgZSwgc3RhcnQsIHR5cGUsIGFkZE5ldykge1xuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgZG9jID0gY20uZG9jO1xuICAgIGVfcHJldmVudERlZmF1bHQoZSk7XG5cbiAgICB2YXIgb3VyUmFuZ2UsIG91ckluZGV4LCBzdGFydFNlbCA9IGRvYy5zZWw7XG4gICAgaWYgKGFkZE5ldyAmJiAhZS5zaGlmdEtleSkge1xuICAgICAgb3VySW5kZXggPSBkb2Muc2VsLmNvbnRhaW5zKHN0YXJ0KTtcbiAgICAgIGlmIChvdXJJbmRleCA+IC0xKVxuICAgICAgICBvdXJSYW5nZSA9IGRvYy5zZWwucmFuZ2VzW291ckluZGV4XTtcbiAgICAgIGVsc2VcbiAgICAgICAgb3VyUmFuZ2UgPSBuZXcgUmFuZ2Uoc3RhcnQsIHN0YXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3VyUmFuZ2UgPSBkb2Muc2VsLnByaW1hcnkoKTtcbiAgICB9XG5cbiAgICBpZiAoZS5hbHRLZXkpIHtcbiAgICAgIHR5cGUgPSBcInJlY3RcIjtcbiAgICAgIGlmICghYWRkTmV3KSBvdXJSYW5nZSA9IG5ldyBSYW5nZShzdGFydCwgc3RhcnQpO1xuICAgICAgc3RhcnQgPSBwb3NGcm9tTW91c2UoY20sIGUsIHRydWUsIHRydWUpO1xuICAgICAgb3VySW5kZXggPSAtMTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJkb3VibGVcIikge1xuICAgICAgdmFyIHdvcmQgPSBmaW5kV29yZEF0KGRvYywgc3RhcnQpO1xuICAgICAgaWYgKGNtLmRpc3BsYXkuc2hpZnQgfHwgZG9jLmV4dGVuZClcbiAgICAgICAgb3VyUmFuZ2UgPSBleHRlbmRSYW5nZShkb2MsIG91clJhbmdlLCB3b3JkLmFuY2hvciwgd29yZC5oZWFkKTtcbiAgICAgIGVsc2VcbiAgICAgICAgb3VyUmFuZ2UgPSB3b3JkO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcInRyaXBsZVwiKSB7XG4gICAgICB2YXIgbGluZSA9IG5ldyBSYW5nZShQb3Moc3RhcnQubGluZSwgMCksIGNsaXBQb3MoZG9jLCBQb3Moc3RhcnQubGluZSArIDEsIDApKSk7XG4gICAgICBpZiAoY20uZGlzcGxheS5zaGlmdCB8fCBkb2MuZXh0ZW5kKVxuICAgICAgICBvdXJSYW5nZSA9IGV4dGVuZFJhbmdlKGRvYywgb3VyUmFuZ2UsIGxpbmUuYW5jaG9yLCBsaW5lLmhlYWQpO1xuICAgICAgZWxzZVxuICAgICAgICBvdXJSYW5nZSA9IGxpbmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91clJhbmdlID0gZXh0ZW5kUmFuZ2UoZG9jLCBvdXJSYW5nZSwgc3RhcnQpO1xuICAgIH1cblxuICAgIGlmICghYWRkTmV3KSB7XG4gICAgICBvdXJJbmRleCA9IDA7XG4gICAgICBzZXRTZWxlY3Rpb24oZG9jLCBuZXcgU2VsZWN0aW9uKFtvdXJSYW5nZV0sIDApLCBzZWxfbW91c2UpO1xuICAgICAgc3RhcnRTZWwgPSBkb2Muc2VsO1xuICAgIH0gZWxzZSBpZiAob3VySW5kZXggPiAtMSkge1xuICAgICAgcmVwbGFjZU9uZVNlbGVjdGlvbihkb2MsIG91ckluZGV4LCBvdXJSYW5nZSwgc2VsX21vdXNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3VySW5kZXggPSBkb2Muc2VsLnJhbmdlcy5sZW5ndGg7XG4gICAgICBzZXRTZWxlY3Rpb24oZG9jLCBub3JtYWxpemVTZWxlY3Rpb24oZG9jLnNlbC5yYW5nZXMuY29uY2F0KFtvdXJSYW5nZV0pLCBvdXJJbmRleCksXG4gICAgICAgICAgICAgICAgICAge3Njcm9sbDogZmFsc2UsIG9yaWdpbjogXCIqbW91c2VcIn0pO1xuICAgIH1cblxuICAgIHZhciBsYXN0UG9zID0gc3RhcnQ7XG4gICAgZnVuY3Rpb24gZXh0ZW5kVG8ocG9zKSB7XG4gICAgICBpZiAoY21wKGxhc3RQb3MsIHBvcykgPT0gMCkgcmV0dXJuO1xuICAgICAgbGFzdFBvcyA9IHBvcztcblxuICAgICAgaWYgKHR5cGUgPT0gXCJyZWN0XCIpIHtcbiAgICAgICAgdmFyIHJhbmdlcyA9IFtdLCB0YWJTaXplID0gY20ub3B0aW9ucy50YWJTaXplO1xuICAgICAgICB2YXIgc3RhcnRDb2wgPSBjb3VudENvbHVtbihnZXRMaW5lKGRvYywgc3RhcnQubGluZSkudGV4dCwgc3RhcnQuY2gsIHRhYlNpemUpO1xuICAgICAgICB2YXIgcG9zQ29sID0gY291bnRDb2x1bW4oZ2V0TGluZShkb2MsIHBvcy5saW5lKS50ZXh0LCBwb3MuY2gsIHRhYlNpemUpO1xuICAgICAgICB2YXIgbGVmdCA9IE1hdGgubWluKHN0YXJ0Q29sLCBwb3NDb2wpLCByaWdodCA9IE1hdGgubWF4KHN0YXJ0Q29sLCBwb3NDb2wpO1xuICAgICAgICBmb3IgKHZhciBsaW5lID0gTWF0aC5taW4oc3RhcnQubGluZSwgcG9zLmxpbmUpLCBlbmQgPSBNYXRoLm1pbihjbS5sYXN0TGluZSgpLCBNYXRoLm1heChzdGFydC5saW5lLCBwb3MubGluZSkpO1xuICAgICAgICAgICAgIGxpbmUgPD0gZW5kOyBsaW5lKyspIHtcbiAgICAgICAgICB2YXIgdGV4dCA9IGdldExpbmUoZG9jLCBsaW5lKS50ZXh0LCBsZWZ0UG9zID0gZmluZENvbHVtbih0ZXh0LCBsZWZ0LCB0YWJTaXplKTtcbiAgICAgICAgICBpZiAobGVmdCA9PSByaWdodClcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKG5ldyBSYW5nZShQb3MobGluZSwgbGVmdFBvcyksIFBvcyhsaW5lLCBsZWZ0UG9zKSkpO1xuICAgICAgICAgIGVsc2UgaWYgKHRleHQubGVuZ3RoID4gbGVmdFBvcylcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKG5ldyBSYW5nZShQb3MobGluZSwgbGVmdFBvcyksIFBvcyhsaW5lLCBmaW5kQ29sdW1uKHRleHQsIHJpZ2h0LCB0YWJTaXplKSkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJhbmdlcy5sZW5ndGgpIHJhbmdlcy5wdXNoKG5ldyBSYW5nZShzdGFydCwgc3RhcnQpKTtcbiAgICAgICAgc2V0U2VsZWN0aW9uKGRvYywgbm9ybWFsaXplU2VsZWN0aW9uKHN0YXJ0U2VsLnJhbmdlcy5zbGljZSgwLCBvdXJJbmRleCkuY29uY2F0KHJhbmdlcyksIG91ckluZGV4KSwgc2VsX21vdXNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvbGRSYW5nZSA9IG91clJhbmdlO1xuICAgICAgICB2YXIgYW5jaG9yID0gb2xkUmFuZ2UuYW5jaG9yLCBoZWFkID0gcG9zO1xuICAgICAgICBpZiAodHlwZSAhPSBcInNpbmdsZVwiKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT0gXCJkb3VibGVcIilcbiAgICAgICAgICAgIHZhciByYW5nZSA9IGZpbmRXb3JkQXQoZG9jLCBwb3MpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHZhciByYW5nZSA9IG5ldyBSYW5nZShQb3MocG9zLmxpbmUsIDApLCBjbGlwUG9zKGRvYywgUG9zKHBvcy5saW5lICsgMSwgMCkpKTtcbiAgICAgICAgICBpZiAoY21wKHJhbmdlLmFuY2hvciwgYW5jaG9yKSA+IDApIHtcbiAgICAgICAgICAgIGhlYWQgPSByYW5nZS5oZWFkO1xuICAgICAgICAgICAgYW5jaG9yID0gbWluUG9zKG9sZFJhbmdlLmZyb20oKSwgcmFuZ2UuYW5jaG9yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGVhZCA9IHJhbmdlLmFuY2hvcjtcbiAgICAgICAgICAgIGFuY2hvciA9IG1heFBvcyhvbGRSYW5nZS50bygpLCByYW5nZS5oZWFkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJhbmdlcyA9IHN0YXJ0U2VsLnJhbmdlcy5zbGljZSgwKTtcbiAgICAgICAgcmFuZ2VzW291ckluZGV4XSA9IG5ldyBSYW5nZShjbGlwUG9zKGRvYywgYW5jaG9yKSwgaGVhZCk7XG4gICAgICAgIHNldFNlbGVjdGlvbihkb2MsIG5vcm1hbGl6ZVNlbGVjdGlvbihyYW5nZXMsIG91ckluZGV4KSwgc2VsX21vdXNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZWRpdG9yU2l6ZSA9IGRpc3BsYXkud3JhcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAvLyBVc2VkIHRvIGVuc3VyZSB0aW1lb3V0IHJlLXRyaWVzIGRvbid0IGZpcmUgd2hlbiBhbm90aGVyIGV4dGVuZFxuICAgIC8vIGhhcHBlbmVkIGluIHRoZSBtZWFudGltZSAoY2xlYXJUaW1lb3V0IGlzbid0IHJlbGlhYmxlIC0tIGF0XG4gICAgLy8gbGVhc3Qgb24gQ2hyb21lLCB0aGUgdGltZW91dHMgc3RpbGwgaGFwcGVuIGV2ZW4gd2hlbiBjbGVhcmVkLFxuICAgIC8vIGlmIHRoZSBjbGVhciBoYXBwZW5zIGFmdGVyIHRoZWlyIHNjaGVkdWxlZCBmaXJpbmcgdGltZSkuXG4gICAgdmFyIGNvdW50ZXIgPSAwO1xuXG4gICAgZnVuY3Rpb24gZXh0ZW5kKGUpIHtcbiAgICAgIHZhciBjdXJDb3VudCA9ICsrY291bnRlcjtcbiAgICAgIHZhciBjdXIgPSBwb3NGcm9tTW91c2UoY20sIGUsIHRydWUsIHR5cGUgPT0gXCJyZWN0XCIpO1xuICAgICAgaWYgKCFjdXIpIHJldHVybjtcbiAgICAgIGlmIChjbXAoY3VyLCBsYXN0UG9zKSAhPSAwKSB7XG4gICAgICAgIGVuc3VyZUZvY3VzKGNtKTtcbiAgICAgICAgZXh0ZW5kVG8oY3VyKTtcbiAgICAgICAgdmFyIHZpc2libGUgPSB2aXNpYmxlTGluZXMoZGlzcGxheSwgZG9jKTtcbiAgICAgICAgaWYgKGN1ci5saW5lID49IHZpc2libGUudG8gfHwgY3VyLmxpbmUgPCB2aXNpYmxlLmZyb20pXG4gICAgICAgICAgc2V0VGltZW91dChvcGVyYXRpb24oY20sIGZ1bmN0aW9uKCl7aWYgKGNvdW50ZXIgPT0gY3VyQ291bnQpIGV4dGVuZChlKTt9KSwgMTUwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvdXRzaWRlID0gZS5jbGllbnRZIDwgZWRpdG9yU2l6ZS50b3AgPyAtMjAgOiBlLmNsaWVudFkgPiBlZGl0b3JTaXplLmJvdHRvbSA/IDIwIDogMDtcbiAgICAgICAgaWYgKG91dHNpZGUpIHNldFRpbWVvdXQob3BlcmF0aW9uKGNtLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoY291bnRlciAhPSBjdXJDb3VudCkgcmV0dXJuO1xuICAgICAgICAgIGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wICs9IG91dHNpZGU7XG4gICAgICAgICAgZXh0ZW5kKGUpO1xuICAgICAgICB9KSwgNTApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRvbmUoZSkge1xuICAgICAgY291bnRlciA9IEluZmluaXR5O1xuICAgICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgIGZvY3VzSW5wdXQoY20pO1xuICAgICAgb2ZmKGRvY3VtZW50LCBcIm1vdXNlbW92ZVwiLCBtb3ZlKTtcbiAgICAgIG9mZihkb2N1bWVudCwgXCJtb3VzZXVwXCIsIHVwKTtcbiAgICAgIGRvYy5oaXN0b3J5Lmxhc3RTZWxPcmlnaW4gPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBtb3ZlID0gb3BlcmF0aW9uKGNtLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoKGllICYmICFpZV91cHRvOSkgPyAgIWUuYnV0dG9ucyA6ICFlX2J1dHRvbihlKSkgZG9uZShlKTtcbiAgICAgIGVsc2UgZXh0ZW5kKGUpO1xuICAgIH0pO1xuICAgIHZhciB1cCA9IG9wZXJhdGlvbihjbSwgZG9uZSk7XG4gICAgb24oZG9jdW1lbnQsIFwibW91c2Vtb3ZlXCIsIG1vdmUpO1xuICAgIG9uKGRvY3VtZW50LCBcIm1vdXNldXBcIiwgdXApO1xuICB9XG5cbiAgLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIGFuIGV2ZW50IGhhcHBlbmVkIGluIHRoZSBndXR0ZXIsIGFuZCBmaXJlcyB0aGVcbiAgLy8gaGFuZGxlcnMgZm9yIHRoZSBjb3JyZXNwb25kaW5nIGV2ZW50LlxuICBmdW5jdGlvbiBndXR0ZXJFdmVudChjbSwgZSwgdHlwZSwgcHJldmVudCwgc2lnbmFsZm4pIHtcbiAgICB0cnkgeyB2YXIgbVggPSBlLmNsaWVudFgsIG1ZID0gZS5jbGllbnRZOyB9XG4gICAgY2F0Y2goZSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpZiAobVggPj0gTWF0aC5mbG9vcihjbS5kaXNwbGF5Lmd1dHRlcnMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkucmlnaHQpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHByZXZlbnQpIGVfcHJldmVudERlZmF1bHQoZSk7XG5cbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG4gICAgdmFyIGxpbmVCb3ggPSBkaXNwbGF5LmxpbmVEaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICBpZiAobVkgPiBsaW5lQm94LmJvdHRvbSB8fCAhaGFzSGFuZGxlcihjbSwgdHlwZSkpIHJldHVybiBlX2RlZmF1bHRQcmV2ZW50ZWQoZSk7XG4gICAgbVkgLT0gbGluZUJveC50b3AgLSBkaXNwbGF5LnZpZXdPZmZzZXQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNtLm9wdGlvbnMuZ3V0dGVycy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGcgPSBkaXNwbGF5Lmd1dHRlcnMuY2hpbGROb2Rlc1tpXTtcbiAgICAgIGlmIChnICYmIGcuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkucmlnaHQgPj0gbVgpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBsaW5lQXRIZWlnaHQoY20uZG9jLCBtWSk7XG4gICAgICAgIHZhciBndXR0ZXIgPSBjbS5vcHRpb25zLmd1dHRlcnNbaV07XG4gICAgICAgIHNpZ25hbGZuKGNtLCB0eXBlLCBjbSwgbGluZSwgZ3V0dGVyLCBlKTtcbiAgICAgICAgcmV0dXJuIGVfZGVmYXVsdFByZXZlbnRlZChlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbGlja0luR3V0dGVyKGNtLCBlKSB7XG4gICAgcmV0dXJuIGd1dHRlckV2ZW50KGNtLCBlLCBcImd1dHRlckNsaWNrXCIsIHRydWUsIHNpZ25hbExhdGVyKTtcbiAgfVxuXG4gIC8vIEtsdWRnZSB0byB3b3JrIGFyb3VuZCBzdHJhbmdlIElFIGJlaGF2aW9yIHdoZXJlIGl0J2xsIHNvbWV0aW1lc1xuICAvLyByZS1maXJlIGEgc2VyaWVzIG9mIGRyYWctcmVsYXRlZCBldmVudHMgcmlnaHQgYWZ0ZXIgdGhlIGRyb3AgKCMxNTUxKVxuICB2YXIgbGFzdERyb3AgPSAwO1xuXG4gIGZ1bmN0aW9uIG9uRHJvcChlKSB7XG4gICAgdmFyIGNtID0gdGhpcztcbiAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGV2ZW50SW5XaWRnZXQoY20uZGlzcGxheSwgZSkpXG4gICAgICByZXR1cm47XG4gICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcbiAgICBpZiAoaWUpIGxhc3REcm9wID0gK25ldyBEYXRlO1xuICAgIHZhciBwb3MgPSBwb3NGcm9tTW91c2UoY20sIGUsIHRydWUpLCBmaWxlcyA9IGUuZGF0YVRyYW5zZmVyLmZpbGVzO1xuICAgIGlmICghcG9zIHx8IGlzUmVhZE9ubHkoY20pKSByZXR1cm47XG4gICAgLy8gTWlnaHQgYmUgYSBmaWxlIGRyb3AsIGluIHdoaWNoIGNhc2Ugd2Ugc2ltcGx5IGV4dHJhY3QgdGhlIHRleHRcbiAgICAvLyBhbmQgaW5zZXJ0IGl0LlxuICAgIGlmIChmaWxlcyAmJiBmaWxlcy5sZW5ndGggJiYgd2luZG93LkZpbGVSZWFkZXIgJiYgd2luZG93LkZpbGUpIHtcbiAgICAgIHZhciBuID0gZmlsZXMubGVuZ3RoLCB0ZXh0ID0gQXJyYXkobiksIHJlYWQgPSAwO1xuICAgICAgdmFyIGxvYWRGaWxlID0gZnVuY3Rpb24oZmlsZSwgaSkge1xuICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXI7XG4gICAgICAgIHJlYWRlci5vbmxvYWQgPSBvcGVyYXRpb24oY20sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRleHRbaV0gPSByZWFkZXIucmVzdWx0O1xuICAgICAgICAgIGlmICgrK3JlYWQgPT0gbikge1xuICAgICAgICAgICAgcG9zID0gY2xpcFBvcyhjbS5kb2MsIHBvcyk7XG4gICAgICAgICAgICB2YXIgY2hhbmdlID0ge2Zyb206IHBvcywgdG86IHBvcywgdGV4dDogc3BsaXRMaW5lcyh0ZXh0LmpvaW4oXCJcXG5cIikpLCBvcmlnaW46IFwicGFzdGVcIn07XG4gICAgICAgICAgICBtYWtlQ2hhbmdlKGNtLmRvYywgY2hhbmdlKTtcbiAgICAgICAgICAgIHNldFNlbGVjdGlvblJlcGxhY2VIaXN0b3J5KGNtLmRvYywgc2ltcGxlU2VsZWN0aW9uKHBvcywgY2hhbmdlRW5kKGNoYW5nZSkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlKTtcbiAgICAgIH07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkgbG9hZEZpbGUoZmlsZXNbaV0sIGkpO1xuICAgIH0gZWxzZSB7IC8vIE5vcm1hbCBkcm9wXG4gICAgICAvLyBEb24ndCBkbyBhIHJlcGxhY2UgaWYgdGhlIGRyb3AgaGFwcGVuZWQgaW5zaWRlIG9mIHRoZSBzZWxlY3RlZCB0ZXh0LlxuICAgICAgaWYgKGNtLnN0YXRlLmRyYWdnaW5nVGV4dCAmJiBjbS5kb2Muc2VsLmNvbnRhaW5zKHBvcykgPiAtMSkge1xuICAgICAgICBjbS5zdGF0ZS5kcmFnZ2luZ1RleHQoZSk7XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgZWRpdG9yIGlzIHJlLWZvY3VzZWRcbiAgICAgICAgc2V0VGltZW91dChiaW5kKGZvY3VzSW5wdXQsIGNtKSwgMjApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgdGV4dCA9IGUuZGF0YVRyYW5zZmVyLmdldERhdGEoXCJUZXh0XCIpO1xuICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgIHZhciBzZWxlY3RlZCA9IGNtLnN0YXRlLmRyYWdnaW5nVGV4dCAmJiBjbS5saXN0U2VsZWN0aW9ucygpO1xuICAgICAgICAgIHNldFNlbGVjdGlvbk5vVW5kbyhjbS5kb2MsIHNpbXBsZVNlbGVjdGlvbihwb3MsIHBvcykpO1xuICAgICAgICAgIGlmIChzZWxlY3RlZCkgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RlZC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIHJlcGxhY2VSYW5nZShjbS5kb2MsIFwiXCIsIHNlbGVjdGVkW2ldLmFuY2hvciwgc2VsZWN0ZWRbaV0uaGVhZCwgXCJkcmFnXCIpO1xuICAgICAgICAgIGNtLnJlcGxhY2VTZWxlY3Rpb24odGV4dCwgXCJhcm91bmRcIiwgXCJwYXN0ZVwiKTtcbiAgICAgICAgICBmb2N1c0lucHV0KGNtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2F0Y2goZSl7fVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRHJhZ1N0YXJ0KGNtLCBlKSB7XG4gICAgaWYgKGllICYmICghY20uc3RhdGUuZHJhZ2dpbmdUZXh0IHx8ICtuZXcgRGF0ZSAtIGxhc3REcm9wIDwgMTAwKSkgeyBlX3N0b3AoZSk7IHJldHVybjsgfVxuICAgIGlmIChzaWduYWxET01FdmVudChjbSwgZSkgfHwgZXZlbnRJbldpZGdldChjbS5kaXNwbGF5LCBlKSkgcmV0dXJuO1xuXG4gICAgZS5kYXRhVHJhbnNmZXIuc2V0RGF0YShcIlRleHRcIiwgY20uZ2V0U2VsZWN0aW9uKCkpO1xuXG4gICAgLy8gVXNlIGR1bW15IGltYWdlIGluc3RlYWQgb2YgZGVmYXVsdCBicm93c2VycyBpbWFnZS5cbiAgICAvLyBSZWNlbnQgU2FmYXJpICh+Ni4wLjIpIGhhdmUgYSB0ZW5kZW5jeSB0byBzZWdmYXVsdCB3aGVuIHRoaXMgaGFwcGVucywgc28gd2UgZG9uJ3QgZG8gaXQgdGhlcmUuXG4gICAgaWYgKGUuZGF0YVRyYW5zZmVyLnNldERyYWdJbWFnZSAmJiAhc2FmYXJpKSB7XG4gICAgICB2YXIgaW1nID0gZWx0KFwiaW1nXCIsIG51bGwsIG51bGwsIFwicG9zaXRpb246IGZpeGVkOyBsZWZ0OiAwOyB0b3A6IDA7XCIpO1xuICAgICAgaW1nLnNyYyA9IFwiZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFBQUFBQ0g1QkFFS0FBRUFMQUFBQUFBQkFBRUFBQUlDVEFFQU93PT1cIjtcbiAgICAgIGlmIChwcmVzdG8pIHtcbiAgICAgICAgaW1nLndpZHRoID0gaW1nLmhlaWdodCA9IDE7XG4gICAgICAgIGNtLmRpc3BsYXkud3JhcHBlci5hcHBlbmRDaGlsZChpbWcpO1xuICAgICAgICAvLyBGb3JjZSBhIHJlbGF5b3V0LCBvciBPcGVyYSB3b24ndCB1c2Ugb3VyIGltYWdlIGZvciBzb21lIG9ic2N1cmUgcmVhc29uXG4gICAgICAgIGltZy5fdG9wID0gaW1nLm9mZnNldFRvcDtcbiAgICAgIH1cbiAgICAgIGUuZGF0YVRyYW5zZmVyLnNldERyYWdJbWFnZShpbWcsIDAsIDApO1xuICAgICAgaWYgKHByZXN0bykgaW1nLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaW1nKTtcbiAgICB9XG4gIH1cblxuICAvLyBTQ1JPTEwgRVZFTlRTXG5cbiAgLy8gU3luYyB0aGUgc2Nyb2xsYWJsZSBhcmVhIGFuZCBzY3JvbGxiYXJzLCBlbnN1cmUgdGhlIHZpZXdwb3J0XG4gIC8vIGNvdmVycyB0aGUgdmlzaWJsZSBhcmVhLlxuICBmdW5jdGlvbiBzZXRTY3JvbGxUb3AoY20sIHZhbCkge1xuICAgIGlmIChNYXRoLmFicyhjbS5kb2Muc2Nyb2xsVG9wIC0gdmFsKSA8IDIpIHJldHVybjtcbiAgICBjbS5kb2Muc2Nyb2xsVG9wID0gdmFsO1xuICAgIGlmICghZ2Vja28pIHVwZGF0ZURpc3BsYXkoY20sIHt0b3A6IHZhbH0pO1xuICAgIGlmIChjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcCAhPSB2YWwpIGNtLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wID0gdmFsO1xuICAgIGlmIChjbS5kaXNwbGF5LnNjcm9sbGJhclYuc2Nyb2xsVG9wICE9IHZhbCkgY20uZGlzcGxheS5zY3JvbGxiYXJWLnNjcm9sbFRvcCA9IHZhbDtcbiAgICBpZiAoZ2Vja28pIHVwZGF0ZURpc3BsYXkoY20pO1xuICAgIHN0YXJ0V29ya2VyKGNtLCAxMDApO1xuICB9XG4gIC8vIFN5bmMgc2Nyb2xsZXIgYW5kIHNjcm9sbGJhciwgZW5zdXJlIHRoZSBndXR0ZXIgZWxlbWVudHMgYXJlXG4gIC8vIGFsaWduZWQuXG4gIGZ1bmN0aW9uIHNldFNjcm9sbExlZnQoY20sIHZhbCwgaXNTY3JvbGxlcikge1xuICAgIGlmIChpc1Njcm9sbGVyID8gdmFsID09IGNtLmRvYy5zY3JvbGxMZWZ0IDogTWF0aC5hYnMoY20uZG9jLnNjcm9sbExlZnQgLSB2YWwpIDwgMikgcmV0dXJuO1xuICAgIHZhbCA9IE1hdGgubWluKHZhbCwgY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxXaWR0aCAtIGNtLmRpc3BsYXkuc2Nyb2xsZXIuY2xpZW50V2lkdGgpO1xuICAgIGNtLmRvYy5zY3JvbGxMZWZ0ID0gdmFsO1xuICAgIGFsaWduSG9yaXpvbnRhbGx5KGNtKTtcbiAgICBpZiAoY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0ICE9IHZhbCkgY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0ID0gdmFsO1xuICAgIGlmIChjbS5kaXNwbGF5LnNjcm9sbGJhckguc2Nyb2xsTGVmdCAhPSB2YWwpIGNtLmRpc3BsYXkuc2Nyb2xsYmFySC5zY3JvbGxMZWZ0ID0gdmFsO1xuICB9XG5cbiAgLy8gU2luY2UgdGhlIGRlbHRhIHZhbHVlcyByZXBvcnRlZCBvbiBtb3VzZSB3aGVlbCBldmVudHMgYXJlXG4gIC8vIHVuc3RhbmRhcmRpemVkIGJldHdlZW4gYnJvd3NlcnMgYW5kIGV2ZW4gYnJvd3NlciB2ZXJzaW9ucywgYW5kXG4gIC8vIGdlbmVyYWxseSBob3JyaWJseSB1bnByZWRpY3RhYmxlLCB0aGlzIGNvZGUgc3RhcnRzIGJ5IG1lYXN1cmluZ1xuICAvLyB0aGUgc2Nyb2xsIGVmZmVjdCB0aGF0IHRoZSBmaXJzdCBmZXcgbW91c2Ugd2hlZWwgZXZlbnRzIGhhdmUsXG4gIC8vIGFuZCwgZnJvbSB0aGF0LCBkZXRlY3RzIHRoZSB3YXkgaXQgY2FuIGNvbnZlcnQgZGVsdGFzIHRvIHBpeGVsXG4gIC8vIG9mZnNldHMgYWZ0ZXJ3YXJkcy5cbiAgLy9cbiAgLy8gVGhlIHJlYXNvbiB3ZSB3YW50IHRvIGtub3cgdGhlIGFtb3VudCBhIHdoZWVsIGV2ZW50IHdpbGwgc2Nyb2xsXG4gIC8vIGlzIHRoYXQgaXQgZ2l2ZXMgdXMgYSBjaGFuY2UgdG8gdXBkYXRlIHRoZSBkaXNwbGF5IGJlZm9yZSB0aGVcbiAgLy8gYWN0dWFsIHNjcm9sbGluZyBoYXBwZW5zLCByZWR1Y2luZyBmbGlja2VyaW5nLlxuXG4gIHZhciB3aGVlbFNhbXBsZXMgPSAwLCB3aGVlbFBpeGVsc1BlclVuaXQgPSBudWxsO1xuICAvLyBGaWxsIGluIGEgYnJvd3Nlci1kZXRlY3RlZCBzdGFydGluZyB2YWx1ZSBvbiBicm93c2VycyB3aGVyZSB3ZVxuICAvLyBrbm93IG9uZS4gVGhlc2UgZG9uJ3QgaGF2ZSB0byBiZSBhY2N1cmF0ZSAtLSB0aGUgcmVzdWx0IG9mIHRoZW1cbiAgLy8gYmVpbmcgd3Jvbmcgd291bGQganVzdCBiZSBhIHNsaWdodCBmbGlja2VyIG9uIHRoZSBmaXJzdCB3aGVlbFxuICAvLyBzY3JvbGwgKGlmIGl0IGlzIGxhcmdlIGVub3VnaCkuXG4gIGlmIChpZSkgd2hlZWxQaXhlbHNQZXJVbml0ID0gLS41MztcbiAgZWxzZSBpZiAoZ2Vja28pIHdoZWVsUGl4ZWxzUGVyVW5pdCA9IDE1O1xuICBlbHNlIGlmIChjaHJvbWUpIHdoZWVsUGl4ZWxzUGVyVW5pdCA9IC0uNztcbiAgZWxzZSBpZiAoc2FmYXJpKSB3aGVlbFBpeGVsc1BlclVuaXQgPSAtMS8zO1xuXG4gIGZ1bmN0aW9uIG9uU2Nyb2xsV2hlZWwoY20sIGUpIHtcbiAgICB2YXIgZHggPSBlLndoZWVsRGVsdGFYLCBkeSA9IGUud2hlZWxEZWx0YVk7XG4gICAgaWYgKGR4ID09IG51bGwgJiYgZS5kZXRhaWwgJiYgZS5heGlzID09IGUuSE9SSVpPTlRBTF9BWElTKSBkeCA9IGUuZGV0YWlsO1xuICAgIGlmIChkeSA9PSBudWxsICYmIGUuZGV0YWlsICYmIGUuYXhpcyA9PSBlLlZFUlRJQ0FMX0FYSVMpIGR5ID0gZS5kZXRhaWw7XG4gICAgZWxzZSBpZiAoZHkgPT0gbnVsbCkgZHkgPSBlLndoZWVsRGVsdGE7XG5cbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIHNjcm9sbCA9IGRpc3BsYXkuc2Nyb2xsZXI7XG4gICAgLy8gUXVpdCBpZiB0aGVyZSdzIG5vdGhpbmcgdG8gc2Nyb2xsIGhlcmVcbiAgICBpZiAoIShkeCAmJiBzY3JvbGwuc2Nyb2xsV2lkdGggPiBzY3JvbGwuY2xpZW50V2lkdGggfHxcbiAgICAgICAgICBkeSAmJiBzY3JvbGwuc2Nyb2xsSGVpZ2h0ID4gc2Nyb2xsLmNsaWVudEhlaWdodCkpIHJldHVybjtcblxuICAgIC8vIFdlYmtpdCBicm93c2VycyBvbiBPUyBYIGFib3J0IG1vbWVudHVtIHNjcm9sbHMgd2hlbiB0aGUgdGFyZ2V0XG4gICAgLy8gb2YgdGhlIHNjcm9sbCBldmVudCBpcyByZW1vdmVkIGZyb20gdGhlIHNjcm9sbGFibGUgZWxlbWVudC5cbiAgICAvLyBUaGlzIGhhY2sgKHNlZSByZWxhdGVkIGNvZGUgaW4gcGF0Y2hEaXNwbGF5KSBtYWtlcyBzdXJlIHRoZVxuICAgIC8vIGVsZW1lbnQgaXMga2VwdCBhcm91bmQuXG4gICAgaWYgKGR5ICYmIG1hYyAmJiB3ZWJraXQpIHtcbiAgICAgIG91dGVyOiBmb3IgKHZhciBjdXIgPSBlLnRhcmdldCwgdmlldyA9IGRpc3BsYXkudmlldzsgY3VyICE9IHNjcm9sbDsgY3VyID0gY3VyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHZpZXdbaV0ubm9kZSA9PSBjdXIpIHtcbiAgICAgICAgICAgIGNtLmRpc3BsYXkuY3VycmVudFdoZWVsVGFyZ2V0ID0gY3VyO1xuICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT24gc29tZSBicm93c2VycywgaG9yaXpvbnRhbCBzY3JvbGxpbmcgd2lsbCBjYXVzZSByZWRyYXdzIHRvXG4gICAgLy8gaGFwcGVuIGJlZm9yZSB0aGUgZ3V0dGVyIGhhcyBiZWVuIHJlYWxpZ25lZCwgY2F1c2luZyBpdCB0b1xuICAgIC8vIHdyaWdnbGUgYXJvdW5kIGluIGEgbW9zdCB1bnNlZW1seSB3YXkuIFdoZW4gd2UgaGF2ZSBhblxuICAgIC8vIGVzdGltYXRlZCBwaXhlbHMvZGVsdGEgdmFsdWUsIHdlIGp1c3QgaGFuZGxlIGhvcml6b250YWxcbiAgICAvLyBzY3JvbGxpbmcgZW50aXJlbHkgaGVyZS4gSXQnbGwgYmUgc2xpZ2h0bHkgb2ZmIGZyb20gbmF0aXZlLCBidXRcbiAgICAvLyBiZXR0ZXIgdGhhbiBnbGl0Y2hpbmcgb3V0LlxuICAgIGlmIChkeCAmJiAhZ2Vja28gJiYgIXByZXN0byAmJiB3aGVlbFBpeGVsc1BlclVuaXQgIT0gbnVsbCkge1xuICAgICAgaWYgKGR5KVxuICAgICAgICBzZXRTY3JvbGxUb3AoY20sIE1hdGgubWF4KDAsIE1hdGgubWluKHNjcm9sbC5zY3JvbGxUb3AgKyBkeSAqIHdoZWVsUGl4ZWxzUGVyVW5pdCwgc2Nyb2xsLnNjcm9sbEhlaWdodCAtIHNjcm9sbC5jbGllbnRIZWlnaHQpKSk7XG4gICAgICBzZXRTY3JvbGxMZWZ0KGNtLCBNYXRoLm1heCgwLCBNYXRoLm1pbihzY3JvbGwuc2Nyb2xsTGVmdCArIGR4ICogd2hlZWxQaXhlbHNQZXJVbml0LCBzY3JvbGwuc2Nyb2xsV2lkdGggLSBzY3JvbGwuY2xpZW50V2lkdGgpKSk7XG4gICAgICBlX3ByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgZGlzcGxheS53aGVlbFN0YXJ0WCA9IG51bGw7IC8vIEFib3J0IG1lYXN1cmVtZW50LCBpZiBpbiBwcm9ncmVzc1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vICdQcm9qZWN0JyB0aGUgdmlzaWJsZSB2aWV3cG9ydCB0byBjb3ZlciB0aGUgYXJlYSB0aGF0IGlzIGJlaW5nXG4gICAgLy8gc2Nyb2xsZWQgaW50byB2aWV3IChpZiB3ZSBrbm93IGVub3VnaCB0byBlc3RpbWF0ZSBpdCkuXG4gICAgaWYgKGR5ICYmIHdoZWVsUGl4ZWxzUGVyVW5pdCAhPSBudWxsKSB7XG4gICAgICB2YXIgcGl4ZWxzID0gZHkgKiB3aGVlbFBpeGVsc1BlclVuaXQ7XG4gICAgICB2YXIgdG9wID0gY20uZG9jLnNjcm9sbFRvcCwgYm90ID0gdG9wICsgZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodDtcbiAgICAgIGlmIChwaXhlbHMgPCAwKSB0b3AgPSBNYXRoLm1heCgwLCB0b3AgKyBwaXhlbHMgLSA1MCk7XG4gICAgICBlbHNlIGJvdCA9IE1hdGgubWluKGNtLmRvYy5oZWlnaHQsIGJvdCArIHBpeGVscyArIDUwKTtcbiAgICAgIHVwZGF0ZURpc3BsYXkoY20sIHt0b3A6IHRvcCwgYm90dG9tOiBib3R9KTtcbiAgICB9XG5cbiAgICBpZiAod2hlZWxTYW1wbGVzIDwgMjApIHtcbiAgICAgIGlmIChkaXNwbGF5LndoZWVsU3RhcnRYID09IG51bGwpIHtcbiAgICAgICAgZGlzcGxheS53aGVlbFN0YXJ0WCA9IHNjcm9sbC5zY3JvbGxMZWZ0OyBkaXNwbGF5LndoZWVsU3RhcnRZID0gc2Nyb2xsLnNjcm9sbFRvcDtcbiAgICAgICAgZGlzcGxheS53aGVlbERYID0gZHg7IGRpc3BsYXkud2hlZWxEWSA9IGR5O1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChkaXNwbGF5LndoZWVsU3RhcnRYID09IG51bGwpIHJldHVybjtcbiAgICAgICAgICB2YXIgbW92ZWRYID0gc2Nyb2xsLnNjcm9sbExlZnQgLSBkaXNwbGF5LndoZWVsU3RhcnRYO1xuICAgICAgICAgIHZhciBtb3ZlZFkgPSBzY3JvbGwuc2Nyb2xsVG9wIC0gZGlzcGxheS53aGVlbFN0YXJ0WTtcbiAgICAgICAgICB2YXIgc2FtcGxlID0gKG1vdmVkWSAmJiBkaXNwbGF5LndoZWVsRFkgJiYgbW92ZWRZIC8gZGlzcGxheS53aGVlbERZKSB8fFxuICAgICAgICAgICAgKG1vdmVkWCAmJiBkaXNwbGF5LndoZWVsRFggJiYgbW92ZWRYIC8gZGlzcGxheS53aGVlbERYKTtcbiAgICAgICAgICBkaXNwbGF5LndoZWVsU3RhcnRYID0gZGlzcGxheS53aGVlbFN0YXJ0WSA9IG51bGw7XG4gICAgICAgICAgaWYgKCFzYW1wbGUpIHJldHVybjtcbiAgICAgICAgICB3aGVlbFBpeGVsc1BlclVuaXQgPSAod2hlZWxQaXhlbHNQZXJVbml0ICogd2hlZWxTYW1wbGVzICsgc2FtcGxlKSAvICh3aGVlbFNhbXBsZXMgKyAxKTtcbiAgICAgICAgICArK3doZWVsU2FtcGxlcztcbiAgICAgICAgfSwgMjAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpc3BsYXkud2hlZWxEWCArPSBkeDsgZGlzcGxheS53aGVlbERZICs9IGR5O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEtFWSBFVkVOVFNcblxuICAvLyBSdW4gYSBoYW5kbGVyIHRoYXQgd2FzIGJvdW5kIHRvIGEga2V5LlxuICBmdW5jdGlvbiBkb0hhbmRsZUJpbmRpbmcoY20sIGJvdW5kLCBkcm9wU2hpZnQpIHtcbiAgICBpZiAodHlwZW9mIGJvdW5kID09IFwic3RyaW5nXCIpIHtcbiAgICAgIGJvdW5kID0gY29tbWFuZHNbYm91bmRdO1xuICAgICAgaWYgKCFib3VuZCkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBFbnN1cmUgcHJldmlvdXMgaW5wdXQgaGFzIGJlZW4gcmVhZCwgc28gdGhhdCB0aGUgaGFuZGxlciBzZWVzIGFcbiAgICAvLyBjb25zaXN0ZW50IHZpZXcgb2YgdGhlIGRvY3VtZW50XG4gICAgaWYgKGNtLmRpc3BsYXkucG9sbGluZ0Zhc3QgJiYgcmVhZElucHV0KGNtKSkgY20uZGlzcGxheS5wb2xsaW5nRmFzdCA9IGZhbHNlO1xuICAgIHZhciBwcmV2U2hpZnQgPSBjbS5kaXNwbGF5LnNoaWZ0LCBkb25lID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChpc1JlYWRPbmx5KGNtKSkgY20uc3RhdGUuc3VwcHJlc3NFZGl0cyA9IHRydWU7XG4gICAgICBpZiAoZHJvcFNoaWZ0KSBjbS5kaXNwbGF5LnNoaWZ0ID0gZmFsc2U7XG4gICAgICBkb25lID0gYm91bmQoY20pICE9IFBhc3M7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGNtLmRpc3BsYXkuc2hpZnQgPSBwcmV2U2hpZnQ7XG4gICAgICBjbS5zdGF0ZS5zdXBwcmVzc0VkaXRzID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBkb25lO1xuICB9XG5cbiAgLy8gQ29sbGVjdCB0aGUgY3VycmVudGx5IGFjdGl2ZSBrZXltYXBzLlxuICBmdW5jdGlvbiBhbGxLZXlNYXBzKGNtKSB7XG4gICAgdmFyIG1hcHMgPSBjbS5zdGF0ZS5rZXlNYXBzLnNsaWNlKDApO1xuICAgIGlmIChjbS5vcHRpb25zLmV4dHJhS2V5cykgbWFwcy5wdXNoKGNtLm9wdGlvbnMuZXh0cmFLZXlzKTtcbiAgICBtYXBzLnB1c2goY20ub3B0aW9ucy5rZXlNYXApO1xuICAgIHJldHVybiBtYXBzO1xuICB9XG5cbiAgdmFyIG1heWJlVHJhbnNpdGlvbjtcbiAgLy8gSGFuZGxlIGEga2V5IGZyb20gdGhlIGtleWRvd24gZXZlbnQuXG4gIGZ1bmN0aW9uIGhhbmRsZUtleUJpbmRpbmcoY20sIGUpIHtcbiAgICAvLyBIYW5kbGUgYXV0b21hdGljIGtleW1hcCB0cmFuc2l0aW9uc1xuICAgIHZhciBzdGFydE1hcCA9IGdldEtleU1hcChjbS5vcHRpb25zLmtleU1hcCksIG5leHQgPSBzdGFydE1hcC5hdXRvO1xuICAgIGNsZWFyVGltZW91dChtYXliZVRyYW5zaXRpb24pO1xuICAgIGlmIChuZXh0ICYmICFpc01vZGlmaWVyS2V5KGUpKSBtYXliZVRyYW5zaXRpb24gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGdldEtleU1hcChjbS5vcHRpb25zLmtleU1hcCkgPT0gc3RhcnRNYXApIHtcbiAgICAgICAgY20ub3B0aW9ucy5rZXlNYXAgPSAobmV4dC5jYWxsID8gbmV4dC5jYWxsKG51bGwsIGNtKSA6IG5leHQpO1xuICAgICAgICBrZXlNYXBDaGFuZ2VkKGNtKTtcbiAgICAgIH1cbiAgICB9LCA1MCk7XG5cbiAgICB2YXIgbmFtZSA9IGtleU5hbWUoZSwgdHJ1ZSksIGhhbmRsZWQgPSBmYWxzZTtcbiAgICBpZiAoIW5hbWUpIHJldHVybiBmYWxzZTtcbiAgICB2YXIga2V5bWFwcyA9IGFsbEtleU1hcHMoY20pO1xuXG4gICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgIC8vIEZpcnN0IHRyeSB0byByZXNvbHZlIGZ1bGwgbmFtZSAoaW5jbHVkaW5nICdTaGlmdC0nKS4gRmFpbGluZ1xuICAgICAgLy8gdGhhdCwgc2VlIGlmIHRoZXJlIGlzIGEgY3Vyc29yLW1vdGlvbiBjb21tYW5kIChzdGFydGluZyB3aXRoXG4gICAgICAvLyAnZ28nKSBib3VuZCB0byB0aGUga2V5bmFtZSB3aXRob3V0ICdTaGlmdC0nLlxuICAgICAgaGFuZGxlZCA9IGxvb2t1cEtleShcIlNoaWZ0LVwiICsgbmFtZSwga2V5bWFwcywgZnVuY3Rpb24oYikge3JldHVybiBkb0hhbmRsZUJpbmRpbmcoY20sIGIsIHRydWUpO30pXG4gICAgICAgICAgICAgfHwgbG9va3VwS2V5KG5hbWUsIGtleW1hcHMsIGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYiA9PSBcInN0cmluZ1wiID8gL15nb1tBLVpdLy50ZXN0KGIpIDogYi5tb3Rpb24pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb0hhbmRsZUJpbmRpbmcoY20sIGIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGVkID0gbG9va3VwS2V5KG5hbWUsIGtleW1hcHMsIGZ1bmN0aW9uKGIpIHsgcmV0dXJuIGRvSGFuZGxlQmluZGluZyhjbSwgYik7IH0pO1xuICAgIH1cblxuICAgIGlmIChoYW5kbGVkKSB7XG4gICAgICBlX3ByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgcmVzdGFydEJsaW5rKGNtKTtcbiAgICAgIHNpZ25hbExhdGVyKGNtLCBcImtleUhhbmRsZWRcIiwgY20sIG5hbWUsIGUpO1xuICAgIH1cbiAgICByZXR1cm4gaGFuZGxlZDtcbiAgfVxuXG4gIC8vIEhhbmRsZSBhIGtleSBmcm9tIHRoZSBrZXlwcmVzcyBldmVudFxuICBmdW5jdGlvbiBoYW5kbGVDaGFyQmluZGluZyhjbSwgZSwgY2gpIHtcbiAgICB2YXIgaGFuZGxlZCA9IGxvb2t1cEtleShcIidcIiArIGNoICsgXCInXCIsIGFsbEtleU1hcHMoY20pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGIpIHsgcmV0dXJuIGRvSGFuZGxlQmluZGluZyhjbSwgYiwgdHJ1ZSk7IH0pO1xuICAgIGlmIChoYW5kbGVkKSB7XG4gICAgICBlX3ByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgcmVzdGFydEJsaW5rKGNtKTtcbiAgICAgIHNpZ25hbExhdGVyKGNtLCBcImtleUhhbmRsZWRcIiwgY20sIFwiJ1wiICsgY2ggKyBcIidcIiwgZSk7XG4gICAgfVxuICAgIHJldHVybiBoYW5kbGVkO1xuICB9XG5cbiAgdmFyIGxhc3RTdG9wcGVkS2V5ID0gbnVsbDtcbiAgZnVuY3Rpb24gb25LZXlEb3duKGUpIHtcbiAgICB2YXIgY20gPSB0aGlzO1xuICAgIGVuc3VyZUZvY3VzKGNtKTtcbiAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpKSByZXR1cm47XG4gICAgLy8gSUUgZG9lcyBzdHJhbmdlIHRoaW5ncyB3aXRoIGVzY2FwZS5cbiAgICBpZiAoaWVfdXB0bzEwICYmIGUua2V5Q29kZSA9PSAyNykgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgIHZhciBjb2RlID0gZS5rZXlDb2RlO1xuICAgIGNtLmRpc3BsYXkuc2hpZnQgPSBjb2RlID09IDE2IHx8IGUuc2hpZnRLZXk7XG4gICAgdmFyIGhhbmRsZWQgPSBoYW5kbGVLZXlCaW5kaW5nKGNtLCBlKTtcbiAgICBpZiAocHJlc3RvKSB7XG4gICAgICBsYXN0U3RvcHBlZEtleSA9IGhhbmRsZWQgPyBjb2RlIDogbnVsbDtcbiAgICAgIC8vIE9wZXJhIGhhcyBubyBjdXQgZXZlbnQuLi4gd2UgdHJ5IHRvIGF0IGxlYXN0IGNhdGNoIHRoZSBrZXkgY29tYm9cbiAgICAgIGlmICghaGFuZGxlZCAmJiBjb2RlID09IDg4ICYmICFoYXNDb3B5RXZlbnQgJiYgKG1hYyA/IGUubWV0YUtleSA6IGUuY3RybEtleSkpXG4gICAgICAgIGNtLnJlcGxhY2VTZWxlY3Rpb24oXCJcIiwgbnVsbCwgXCJjdXRcIik7XG4gICAgfVxuXG4gICAgLy8gVHVybiBtb3VzZSBpbnRvIGNyb3NzaGFpciB3aGVuIEFsdCBpcyBoZWxkIG9uIE1hYy5cbiAgICBpZiAoY29kZSA9PSAxOCAmJiAhL1xcYkNvZGVNaXJyb3ItY3Jvc3NoYWlyXFxiLy50ZXN0KGNtLmRpc3BsYXkubGluZURpdi5jbGFzc05hbWUpKVxuICAgICAgc2hvd0Nyb3NzSGFpcihjbSk7XG4gIH1cblxuICBmdW5jdGlvbiBzaG93Q3Jvc3NIYWlyKGNtKSB7XG4gICAgdmFyIGxpbmVEaXYgPSBjbS5kaXNwbGF5LmxpbmVEaXY7XG4gICAgYWRkQ2xhc3MobGluZURpdiwgXCJDb2RlTWlycm9yLWNyb3NzaGFpclwiKTtcblxuICAgIGZ1bmN0aW9uIHVwKGUpIHtcbiAgICAgIGlmIChlLmtleUNvZGUgPT0gMTggfHwgIWUuYWx0S2V5KSB7XG4gICAgICAgIHJtQ2xhc3MobGluZURpdiwgXCJDb2RlTWlycm9yLWNyb3NzaGFpclwiKTtcbiAgICAgICAgb2ZmKGRvY3VtZW50LCBcImtleXVwXCIsIHVwKTtcbiAgICAgICAgb2ZmKGRvY3VtZW50LCBcIm1vdXNlb3ZlclwiLCB1cCk7XG4gICAgICB9XG4gICAgfVxuICAgIG9uKGRvY3VtZW50LCBcImtleXVwXCIsIHVwKTtcbiAgICBvbihkb2N1bWVudCwgXCJtb3VzZW92ZXJcIiwgdXApO1xuICB9XG5cbiAgZnVuY3Rpb24gb25LZXlVcChlKSB7XG4gICAgaWYgKHNpZ25hbERPTUV2ZW50KHRoaXMsIGUpKSByZXR1cm47XG4gICAgaWYgKGUua2V5Q29kZSA9PSAxNikgdGhpcy5kb2Muc2VsLnNoaWZ0ID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBvbktleVByZXNzKGUpIHtcbiAgICB2YXIgY20gPSB0aGlzO1xuICAgIGlmIChzaWduYWxET01FdmVudChjbSwgZSkpIHJldHVybjtcbiAgICB2YXIga2V5Q29kZSA9IGUua2V5Q29kZSwgY2hhckNvZGUgPSBlLmNoYXJDb2RlO1xuICAgIGlmIChwcmVzdG8gJiYga2V5Q29kZSA9PSBsYXN0U3RvcHBlZEtleSkge2xhc3RTdG9wcGVkS2V5ID0gbnVsbDsgZV9wcmV2ZW50RGVmYXVsdChlKTsgcmV0dXJuO31cbiAgICBpZiAoKChwcmVzdG8gJiYgKCFlLndoaWNoIHx8IGUud2hpY2ggPCAxMCkpIHx8IGtodG1sKSAmJiBoYW5kbGVLZXlCaW5kaW5nKGNtLCBlKSkgcmV0dXJuO1xuICAgIHZhciBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUgPT0gbnVsbCA/IGtleUNvZGUgOiBjaGFyQ29kZSk7XG4gICAgaWYgKGhhbmRsZUNoYXJCaW5kaW5nKGNtLCBlLCBjaCkpIHJldHVybjtcbiAgICBpZiAoaWUgJiYgIWllX3VwdG84KSBjbS5kaXNwbGF5LmlucHV0SGFzU2VsZWN0aW9uID0gbnVsbDtcbiAgICBmYXN0UG9sbChjbSk7XG4gIH1cblxuICAvLyBGT0NVUy9CTFVSIEVWRU5UU1xuXG4gIGZ1bmN0aW9uIG9uRm9jdXMoY20pIHtcbiAgICBpZiAoY20ub3B0aW9ucy5yZWFkT25seSA9PSBcIm5vY3Vyc29yXCIpIHJldHVybjtcbiAgICBpZiAoIWNtLnN0YXRlLmZvY3VzZWQpIHtcbiAgICAgIHNpZ25hbChjbSwgXCJmb2N1c1wiLCBjbSk7XG4gICAgICBjbS5zdGF0ZS5mb2N1c2VkID0gdHJ1ZTtcbiAgICAgIGFkZENsYXNzKGNtLmRpc3BsYXkud3JhcHBlciwgXCJDb2RlTWlycm9yLWZvY3VzZWRcIik7XG4gICAgICAvLyBUaGUgcHJldklucHV0IHRlc3QgcHJldmVudHMgdGhpcyBmcm9tIGZpcmluZyB3aGVuIGEgY29udGV4dFxuICAgICAgLy8gbWVudSBpcyBjbG9zZWQgKHNpbmNlIHRoZSByZXNldElucHV0IHdvdWxkIGtpbGwgdGhlXG4gICAgICAvLyBzZWxlY3QtYWxsIGRldGVjdGlvbiBoYWNrKVxuICAgICAgaWYgKCFjbS5jdXJPcCAmJiBjbS5kaXNwbGF5LnNlbEZvckNvbnRleHRNZW51ID09IGNtLmRvYy5zZWwpIHtcbiAgICAgICAgcmVzZXRJbnB1dChjbSk7XG4gICAgICAgIGlmICh3ZWJraXQpIHNldFRpbWVvdXQoYmluZChyZXNldElucHV0LCBjbSwgdHJ1ZSksIDApOyAvLyBJc3N1ZSAjMTczMFxuICAgICAgfVxuICAgIH1cbiAgICBzbG93UG9sbChjbSk7XG4gICAgcmVzdGFydEJsaW5rKGNtKTtcbiAgfVxuICBmdW5jdGlvbiBvbkJsdXIoY20pIHtcbiAgICBpZiAoY20uc3RhdGUuZm9jdXNlZCkge1xuICAgICAgc2lnbmFsKGNtLCBcImJsdXJcIiwgY20pO1xuICAgICAgY20uc3RhdGUuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgcm1DbGFzcyhjbS5kaXNwbGF5LndyYXBwZXIsIFwiQ29kZU1pcnJvci1mb2N1c2VkXCIpO1xuICAgIH1cbiAgICBjbGVhckludGVydmFsKGNtLmRpc3BsYXkuYmxpbmtlcik7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtpZiAoIWNtLnN0YXRlLmZvY3VzZWQpIGNtLmRpc3BsYXkuc2hpZnQgPSBmYWxzZTt9LCAxNTApO1xuICB9XG5cbiAgLy8gQ09OVEVYVCBNRU5VIEhBTkRMSU5HXG5cbiAgdmFyIGRldGVjdGluZ1NlbGVjdEFsbDtcbiAgLy8gVG8gbWFrZSB0aGUgY29udGV4dCBtZW51IHdvcmssIHdlIG5lZWQgdG8gYnJpZWZseSB1bmhpZGUgdGhlXG4gIC8vIHRleHRhcmVhIChtYWtpbmcgaXQgYXMgdW5vYnRydXNpdmUgYXMgcG9zc2libGUpIHRvIGxldCB0aGVcbiAgLy8gcmlnaHQtY2xpY2sgdGFrZSBlZmZlY3Qgb24gaXQuXG4gIGZ1bmN0aW9uIG9uQ29udGV4dE1lbnUoY20sIGUpIHtcbiAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUsIFwiY29udGV4dG1lbnVcIikpIHJldHVybjtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG4gICAgaWYgKGV2ZW50SW5XaWRnZXQoZGlzcGxheSwgZSkgfHwgY29udGV4dE1lbnVJbkd1dHRlcihjbSwgZSkpIHJldHVybjtcblxuICAgIHZhciBwb3MgPSBwb3NGcm9tTW91c2UoY20sIGUpLCBzY3JvbGxQb3MgPSBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcDtcbiAgICBpZiAoIXBvcyB8fCBwcmVzdG8pIHJldHVybjsgLy8gT3BlcmEgaXMgZGlmZmljdWx0LlxuXG4gICAgLy8gUmVzZXQgdGhlIGN1cnJlbnQgdGV4dCBzZWxlY3Rpb24gb25seSBpZiB0aGUgY2xpY2sgaXMgZG9uZSBvdXRzaWRlIG9mIHRoZSBzZWxlY3Rpb25cbiAgICAvLyBhbmQgJ3Jlc2V0U2VsZWN0aW9uT25Db250ZXh0TWVudScgb3B0aW9uIGlzIHRydWUuXG4gICAgdmFyIHJlc2V0ID0gY20ub3B0aW9ucy5yZXNldFNlbGVjdGlvbk9uQ29udGV4dE1lbnU7XG4gICAgaWYgKHJlc2V0ICYmIGNtLmRvYy5zZWwuY29udGFpbnMocG9zKSA9PSAtMSlcbiAgICAgIG9wZXJhdGlvbihjbSwgc2V0U2VsZWN0aW9uKShjbS5kb2MsIHNpbXBsZVNlbGVjdGlvbihwb3MpLCBzZWxfZG9udFNjcm9sbCk7XG5cbiAgICB2YXIgb2xkQ1NTID0gZGlzcGxheS5pbnB1dC5zdHlsZS5jc3NUZXh0O1xuICAgIGRpc3BsYXkuaW5wdXREaXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgZGlzcGxheS5pbnB1dC5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjogZml4ZWQ7IHdpZHRoOiAzMHB4OyBoZWlnaHQ6IDMwcHg7IHRvcDogXCIgKyAoZS5jbGllbnRZIC0gNSkgK1xuICAgICAgXCJweDsgbGVmdDogXCIgKyAoZS5jbGllbnRYIC0gNSkgKyBcInB4OyB6LWluZGV4OiAxMDAwOyBiYWNrZ3JvdW5kOiBcIiArXG4gICAgICAoaWUgPyBcInJnYmEoMjU1LCAyNTUsIDI1NSwgLjA1KVwiIDogXCJ0cmFuc3BhcmVudFwiKSArXG4gICAgICBcIjsgb3V0bGluZTogbm9uZTsgYm9yZGVyLXdpZHRoOiAwOyBvdXRsaW5lOiBub25lOyBvdmVyZmxvdzogaGlkZGVuOyBvcGFjaXR5OiAuMDU7IGZpbHRlcjogYWxwaGEob3BhY2l0eT01KTtcIjtcbiAgICBmb2N1c0lucHV0KGNtKTtcbiAgICByZXNldElucHV0KGNtKTtcbiAgICAvLyBBZGRzIFwiU2VsZWN0IGFsbFwiIHRvIGNvbnRleHQgbWVudSBpbiBGRlxuICAgIGlmICghY20uc29tZXRoaW5nU2VsZWN0ZWQoKSkgZGlzcGxheS5pbnB1dC52YWx1ZSA9IGRpc3BsYXkucHJldklucHV0ID0gXCIgXCI7XG4gICAgZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudSA9IGNtLmRvYy5zZWw7XG5cbiAgICAvLyBTZWxlY3QtYWxsIHdpbGwgYmUgZ3JleWVkIG91dCBpZiB0aGVyZSdzIG5vdGhpbmcgdG8gc2VsZWN0LCBzb1xuICAgIC8vIHRoaXMgYWRkcyBhIHplcm8td2lkdGggc3BhY2Ugc28gdGhhdCB3ZSBjYW4gbGF0ZXIgY2hlY2sgd2hldGhlclxuICAgIC8vIGl0IGdvdCBzZWxlY3RlZC5cbiAgICBmdW5jdGlvbiBwcmVwYXJlU2VsZWN0QWxsSGFjaygpIHtcbiAgICAgIGlmIChkaXNwbGF5LmlucHV0LnNlbGVjdGlvblN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgdmFyIHNlbGVjdGVkID0gY20uc29tZXRoaW5nU2VsZWN0ZWQoKTtcbiAgICAgICAgdmFyIGV4dHZhbCA9IGRpc3BsYXkuaW5wdXQudmFsdWUgPSBcIlxcdTIwMGJcIiArIChzZWxlY3RlZCA/IGRpc3BsYXkuaW5wdXQudmFsdWUgOiBcIlwiKTtcbiAgICAgICAgZGlzcGxheS5wcmV2SW5wdXQgPSBzZWxlY3RlZCA/IFwiXCIgOiBcIlxcdTIwMGJcIjtcbiAgICAgICAgZGlzcGxheS5pbnB1dC5zZWxlY3Rpb25TdGFydCA9IDE7IGRpc3BsYXkuaW5wdXQuc2VsZWN0aW9uRW5kID0gZXh0dmFsLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVoaWRlKCkge1xuICAgICAgZGlzcGxheS5pbnB1dERpdi5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcbiAgICAgIGRpc3BsYXkuaW5wdXQuc3R5bGUuY3NzVGV4dCA9IG9sZENTUztcbiAgICAgIGlmIChpZV91cHRvOCkgZGlzcGxheS5zY3JvbGxiYXJWLnNjcm9sbFRvcCA9IGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wID0gc2Nyb2xsUG9zO1xuICAgICAgc2xvd1BvbGwoY20pO1xuXG4gICAgICAvLyBUcnkgdG8gZGV0ZWN0IHRoZSB1c2VyIGNob29zaW5nIHNlbGVjdC1hbGxcbiAgICAgIGlmIChkaXNwbGF5LmlucHV0LnNlbGVjdGlvblN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKCFpZSB8fCBpZV91cHRvOCkgcHJlcGFyZVNlbGVjdEFsbEhhY2soKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGRldGVjdGluZ1NlbGVjdEFsbCk7XG4gICAgICAgIHZhciBpID0gMCwgcG9sbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChkaXNwbGF5LnNlbEZvckNvbnRleHRNZW51ID09IGNtLmRvYy5zZWwgJiYgZGlzcGxheS5pbnB1dC5zZWxlY3Rpb25TdGFydCA9PSAwKVxuICAgICAgICAgICAgb3BlcmF0aW9uKGNtLCBjb21tYW5kcy5zZWxlY3RBbGwpKGNtKTtcbiAgICAgICAgICBlbHNlIGlmIChpKysgPCAxMCkgZGV0ZWN0aW5nU2VsZWN0QWxsID0gc2V0VGltZW91dChwb2xsLCA1MDApO1xuICAgICAgICAgIGVsc2UgcmVzZXRJbnB1dChjbSk7XG4gICAgICAgIH07XG4gICAgICAgIGRldGVjdGluZ1NlbGVjdEFsbCA9IHNldFRpbWVvdXQocG9sbCwgMjAwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaWUgJiYgIWllX3VwdG84KSBwcmVwYXJlU2VsZWN0QWxsSGFjaygpO1xuICAgIGlmIChjYXB0dXJlUmlnaHRDbGljaykge1xuICAgICAgZV9zdG9wKGUpO1xuICAgICAgdmFyIG1vdXNldXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgb2ZmKHdpbmRvdywgXCJtb3VzZXVwXCIsIG1vdXNldXApO1xuICAgICAgICBzZXRUaW1lb3V0KHJlaGlkZSwgMjApO1xuICAgICAgfTtcbiAgICAgIG9uKHdpbmRvdywgXCJtb3VzZXVwXCIsIG1vdXNldXApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRUaW1lb3V0KHJlaGlkZSwgNTApO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnRleHRNZW51SW5HdXR0ZXIoY20sIGUpIHtcbiAgICBpZiAoIWhhc0hhbmRsZXIoY20sIFwiZ3V0dGVyQ29udGV4dE1lbnVcIikpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gZ3V0dGVyRXZlbnQoY20sIGUsIFwiZ3V0dGVyQ29udGV4dE1lbnVcIiwgZmFsc2UsIHNpZ25hbCk7XG4gIH1cblxuICAvLyBVUERBVElOR1xuXG4gIC8vIENvbXB1dGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBlbmQgb2YgYSBjaGFuZ2UgKGl0cyAndG8nIHByb3BlcnR5XG4gIC8vIHJlZmVycyB0byB0aGUgcHJlLWNoYW5nZSBlbmQpLlxuICB2YXIgY2hhbmdlRW5kID0gQ29kZU1pcnJvci5jaGFuZ2VFbmQgPSBmdW5jdGlvbihjaGFuZ2UpIHtcbiAgICBpZiAoIWNoYW5nZS50ZXh0KSByZXR1cm4gY2hhbmdlLnRvO1xuICAgIHJldHVybiBQb3MoY2hhbmdlLmZyb20ubGluZSArIGNoYW5nZS50ZXh0Lmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgICBsc3QoY2hhbmdlLnRleHQpLmxlbmd0aCArIChjaGFuZ2UudGV4dC5sZW5ndGggPT0gMSA/IGNoYW5nZS5mcm9tLmNoIDogMCkpO1xuICB9O1xuXG4gIC8vIEFkanVzdCBhIHBvc2l0aW9uIHRvIHJlZmVyIHRvIHRoZSBwb3N0LWNoYW5nZSBwb3NpdGlvbiBvZiB0aGVcbiAgLy8gc2FtZSB0ZXh0LCBvciB0aGUgZW5kIG9mIHRoZSBjaGFuZ2UgaWYgdGhlIGNoYW5nZSBjb3ZlcnMgaXQuXG4gIGZ1bmN0aW9uIGFkanVzdEZvckNoYW5nZShwb3MsIGNoYW5nZSkge1xuICAgIGlmIChjbXAocG9zLCBjaGFuZ2UuZnJvbSkgPCAwKSByZXR1cm4gcG9zO1xuICAgIGlmIChjbXAocG9zLCBjaGFuZ2UudG8pIDw9IDApIHJldHVybiBjaGFuZ2VFbmQoY2hhbmdlKTtcblxuICAgIHZhciBsaW5lID0gcG9zLmxpbmUgKyBjaGFuZ2UudGV4dC5sZW5ndGggLSAoY2hhbmdlLnRvLmxpbmUgLSBjaGFuZ2UuZnJvbS5saW5lKSAtIDEsIGNoID0gcG9zLmNoO1xuICAgIGlmIChwb3MubGluZSA9PSBjaGFuZ2UudG8ubGluZSkgY2ggKz0gY2hhbmdlRW5kKGNoYW5nZSkuY2ggLSBjaGFuZ2UudG8uY2g7XG4gICAgcmV0dXJuIFBvcyhsaW5lLCBjaCk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wdXRlU2VsQWZ0ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpIHtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2Muc2VsLnJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJhbmdlID0gZG9jLnNlbC5yYW5nZXNbaV07XG4gICAgICBvdXQucHVzaChuZXcgUmFuZ2UoYWRqdXN0Rm9yQ2hhbmdlKHJhbmdlLmFuY2hvciwgY2hhbmdlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBhZGp1c3RGb3JDaGFuZ2UocmFuZ2UuaGVhZCwgY2hhbmdlKSkpO1xuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplU2VsZWN0aW9uKG91dCwgZG9jLnNlbC5wcmltSW5kZXgpO1xuICB9XG5cbiAgZnVuY3Rpb24gb2Zmc2V0UG9zKHBvcywgb2xkLCBudykge1xuICAgIGlmIChwb3MubGluZSA9PSBvbGQubGluZSlcbiAgICAgIHJldHVybiBQb3MobncubGluZSwgcG9zLmNoIC0gb2xkLmNoICsgbncuY2gpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBQb3MobncubGluZSArIChwb3MubGluZSAtIG9sZC5saW5lKSwgcG9zLmNoKTtcbiAgfVxuXG4gIC8vIFVzZWQgYnkgcmVwbGFjZVNlbGVjdGlvbnMgdG8gYWxsb3cgbW92aW5nIHRoZSBzZWxlY3Rpb24gdG8gdGhlXG4gIC8vIHN0YXJ0IG9yIGFyb3VuZCB0aGUgcmVwbGFjZWQgdGVzdC4gSGludCBtYXkgYmUgXCJzdGFydFwiIG9yIFwiYXJvdW5kXCIuXG4gIGZ1bmN0aW9uIGNvbXB1dGVSZXBsYWNlZFNlbChkb2MsIGNoYW5nZXMsIGhpbnQpIHtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgdmFyIG9sZFByZXYgPSBQb3MoZG9jLmZpcnN0LCAwKSwgbmV3UHJldiA9IG9sZFByZXY7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hhbmdlID0gY2hhbmdlc1tpXTtcbiAgICAgIHZhciBmcm9tID0gb2Zmc2V0UG9zKGNoYW5nZS5mcm9tLCBvbGRQcmV2LCBuZXdQcmV2KTtcbiAgICAgIHZhciB0byA9IG9mZnNldFBvcyhjaGFuZ2VFbmQoY2hhbmdlKSwgb2xkUHJldiwgbmV3UHJldik7XG4gICAgICBvbGRQcmV2ID0gY2hhbmdlLnRvO1xuICAgICAgbmV3UHJldiA9IHRvO1xuICAgICAgaWYgKGhpbnQgPT0gXCJhcm91bmRcIikge1xuICAgICAgICB2YXIgcmFuZ2UgPSBkb2Muc2VsLnJhbmdlc1tpXSwgaW52ID0gY21wKHJhbmdlLmhlYWQsIHJhbmdlLmFuY2hvcikgPCAwO1xuICAgICAgICBvdXRbaV0gPSBuZXcgUmFuZ2UoaW52ID8gdG8gOiBmcm9tLCBpbnYgPyBmcm9tIDogdG8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0W2ldID0gbmV3IFJhbmdlKGZyb20sIGZyb20pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFNlbGVjdGlvbihvdXQsIGRvYy5zZWwucHJpbUluZGV4KTtcbiAgfVxuXG4gIC8vIEFsbG93IFwiYmVmb3JlQ2hhbmdlXCIgZXZlbnQgaGFuZGxlcnMgdG8gaW5mbHVlbmNlIGEgY2hhbmdlXG4gIGZ1bmN0aW9uIGZpbHRlckNoYW5nZShkb2MsIGNoYW5nZSwgdXBkYXRlKSB7XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIGNhbmNlbGVkOiBmYWxzZSxcbiAgICAgIGZyb206IGNoYW5nZS5mcm9tLFxuICAgICAgdG86IGNoYW5nZS50byxcbiAgICAgIHRleHQ6IGNoYW5nZS50ZXh0LFxuICAgICAgb3JpZ2luOiBjaGFuZ2Uub3JpZ2luLFxuICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHsgdGhpcy5jYW5jZWxlZCA9IHRydWU7IH1cbiAgICB9O1xuICAgIGlmICh1cGRhdGUpIG9iai51cGRhdGUgPSBmdW5jdGlvbihmcm9tLCB0bywgdGV4dCwgb3JpZ2luKSB7XG4gICAgICBpZiAoZnJvbSkgdGhpcy5mcm9tID0gY2xpcFBvcyhkb2MsIGZyb20pO1xuICAgICAgaWYgKHRvKSB0aGlzLnRvID0gY2xpcFBvcyhkb2MsIHRvKTtcbiAgICAgIGlmICh0ZXh0KSB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgaWYgKG9yaWdpbiAhPT0gdW5kZWZpbmVkKSB0aGlzLm9yaWdpbiA9IG9yaWdpbjtcbiAgICB9O1xuICAgIHNpZ25hbChkb2MsIFwiYmVmb3JlQ2hhbmdlXCIsIGRvYywgb2JqKTtcbiAgICBpZiAoZG9jLmNtKSBzaWduYWwoZG9jLmNtLCBcImJlZm9yZUNoYW5nZVwiLCBkb2MuY20sIG9iaik7XG5cbiAgICBpZiAob2JqLmNhbmNlbGVkKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4ge2Zyb206IG9iai5mcm9tLCB0bzogb2JqLnRvLCB0ZXh0OiBvYmoudGV4dCwgb3JpZ2luOiBvYmoub3JpZ2lufTtcbiAgfVxuXG4gIC8vIEFwcGx5IGEgY2hhbmdlIHRvIGEgZG9jdW1lbnQsIGFuZCBhZGQgaXQgdG8gdGhlIGRvY3VtZW50J3NcbiAgLy8gaGlzdG9yeSwgYW5kIHByb3BhZ2F0aW5nIGl0IHRvIGFsbCBsaW5rZWQgZG9jdW1lbnRzLlxuICBmdW5jdGlvbiBtYWtlQ2hhbmdlKGRvYywgY2hhbmdlLCBpZ25vcmVSZWFkT25seSkge1xuICAgIGlmIChkb2MuY20pIHtcbiAgICAgIGlmICghZG9jLmNtLmN1ck9wKSByZXR1cm4gb3BlcmF0aW9uKGRvYy5jbSwgbWFrZUNoYW5nZSkoZG9jLCBjaGFuZ2UsIGlnbm9yZVJlYWRPbmx5KTtcbiAgICAgIGlmIChkb2MuY20uc3RhdGUuc3VwcHJlc3NFZGl0cykgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChoYXNIYW5kbGVyKGRvYywgXCJiZWZvcmVDaGFuZ2VcIikgfHwgZG9jLmNtICYmIGhhc0hhbmRsZXIoZG9jLmNtLCBcImJlZm9yZUNoYW5nZVwiKSkge1xuICAgICAgY2hhbmdlID0gZmlsdGVyQ2hhbmdlKGRvYywgY2hhbmdlLCB0cnVlKTtcbiAgICAgIGlmICghY2hhbmdlKSByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUG9zc2libHkgc3BsaXQgb3Igc3VwcHJlc3MgdGhlIHVwZGF0ZSBiYXNlZCBvbiB0aGUgcHJlc2VuY2VcbiAgICAvLyBvZiByZWFkLW9ubHkgc3BhbnMgaW4gaXRzIHJhbmdlLlxuICAgIHZhciBzcGxpdCA9IHNhd1JlYWRPbmx5U3BhbnMgJiYgIWlnbm9yZVJlYWRPbmx5ICYmIHJlbW92ZVJlYWRPbmx5UmFuZ2VzKGRvYywgY2hhbmdlLmZyb20sIGNoYW5nZS50byk7XG4gICAgaWYgKHNwbGl0KSB7XG4gICAgICBmb3IgKHZhciBpID0gc3BsaXQubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpXG4gICAgICAgIG1ha2VDaGFuZ2VJbm5lcihkb2MsIHtmcm9tOiBzcGxpdFtpXS5mcm9tLCB0bzogc3BsaXRbaV0udG8sIHRleHQ6IGkgPyBbXCJcIl0gOiBjaGFuZ2UudGV4dH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYWtlQ2hhbmdlSW5uZXIoZG9jLCBjaGFuZ2UpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VDaGFuZ2VJbm5lcihkb2MsIGNoYW5nZSkge1xuICAgIGlmIChjaGFuZ2UudGV4dC5sZW5ndGggPT0gMSAmJiBjaGFuZ2UudGV4dFswXSA9PSBcIlwiICYmIGNtcChjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKSA9PSAwKSByZXR1cm47XG4gICAgdmFyIHNlbEFmdGVyID0gY29tcHV0ZVNlbEFmdGVyQ2hhbmdlKGRvYywgY2hhbmdlKTtcbiAgICBhZGRDaGFuZ2VUb0hpc3RvcnkoZG9jLCBjaGFuZ2UsIHNlbEFmdGVyLCBkb2MuY20gPyBkb2MuY20uY3VyT3AuaWQgOiBOYU4pO1xuXG4gICAgbWFrZUNoYW5nZVNpbmdsZURvYyhkb2MsIGNoYW5nZSwgc2VsQWZ0ZXIsIHN0cmV0Y2hTcGFuc092ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpKTtcbiAgICB2YXIgcmViYXNlZCA9IFtdO1xuXG4gICAgbGlua2VkRG9jcyhkb2MsIGZ1bmN0aW9uKGRvYywgc2hhcmVkSGlzdCkge1xuICAgICAgaWYgKCFzaGFyZWRIaXN0ICYmIGluZGV4T2YocmViYXNlZCwgZG9jLmhpc3RvcnkpID09IC0xKSB7XG4gICAgICAgIHJlYmFzZUhpc3QoZG9jLmhpc3RvcnksIGNoYW5nZSk7XG4gICAgICAgIHJlYmFzZWQucHVzaChkb2MuaGlzdG9yeSk7XG4gICAgICB9XG4gICAgICBtYWtlQ2hhbmdlU2luZ2xlRG9jKGRvYywgY2hhbmdlLCBudWxsLCBzdHJldGNoU3BhbnNPdmVyQ2hhbmdlKGRvYywgY2hhbmdlKSk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBSZXZlcnQgYSBjaGFuZ2Ugc3RvcmVkIGluIGEgZG9jdW1lbnQncyBoaXN0b3J5LlxuICBmdW5jdGlvbiBtYWtlQ2hhbmdlRnJvbUhpc3RvcnkoZG9jLCB0eXBlLCBhbGxvd1NlbGVjdGlvbk9ubHkpIHtcbiAgICBpZiAoZG9jLmNtICYmIGRvYy5jbS5zdGF0ZS5zdXBwcmVzc0VkaXRzKSByZXR1cm47XG5cbiAgICB2YXIgaGlzdCA9IGRvYy5oaXN0b3J5LCBldmVudCwgc2VsQWZ0ZXIgPSBkb2Muc2VsO1xuICAgIHZhciBzb3VyY2UgPSB0eXBlID09IFwidW5kb1wiID8gaGlzdC5kb25lIDogaGlzdC51bmRvbmUsIGRlc3QgPSB0eXBlID09IFwidW5kb1wiID8gaGlzdC51bmRvbmUgOiBoaXN0LmRvbmU7XG5cbiAgICAvLyBWZXJpZnkgdGhhdCB0aGVyZSBpcyBhIHVzZWFibGUgZXZlbnQgKHNvIHRoYXQgY3RybC16IHdvbid0XG4gICAgLy8gbmVlZGxlc3NseSBjbGVhciBzZWxlY3Rpb24gZXZlbnRzKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBldmVudCA9IHNvdXJjZVtpXTtcbiAgICAgIGlmIChhbGxvd1NlbGVjdGlvbk9ubHkgPyBldmVudC5yYW5nZXMgJiYgIWV2ZW50LmVxdWFscyhkb2Muc2VsKSA6ICFldmVudC5yYW5nZXMpXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoaSA9PSBzb3VyY2UubGVuZ3RoKSByZXR1cm47XG4gICAgaGlzdC5sYXN0T3JpZ2luID0gaGlzdC5sYXN0U2VsT3JpZ2luID0gbnVsbDtcblxuICAgIGZvciAoOzspIHtcbiAgICAgIGV2ZW50ID0gc291cmNlLnBvcCgpO1xuICAgICAgaWYgKGV2ZW50LnJhbmdlcykge1xuICAgICAgICBwdXNoU2VsZWN0aW9uVG9IaXN0b3J5KGV2ZW50LCBkZXN0KTtcbiAgICAgICAgaWYgKGFsbG93U2VsZWN0aW9uT25seSAmJiAhZXZlbnQuZXF1YWxzKGRvYy5zZWwpKSB7XG4gICAgICAgICAgc2V0U2VsZWN0aW9uKGRvYywgZXZlbnQsIHtjbGVhclJlZG86IGZhbHNlfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNlbEFmdGVyID0gZXZlbnQ7XG4gICAgICB9XG4gICAgICBlbHNlIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIEJ1aWxkIHVwIGEgcmV2ZXJzZSBjaGFuZ2Ugb2JqZWN0IHRvIGFkZCB0byB0aGUgb3Bwb3NpdGUgaGlzdG9yeVxuICAgIC8vIHN0YWNrIChyZWRvIHdoZW4gdW5kb2luZywgYW5kIHZpY2UgdmVyc2EpLlxuICAgIHZhciBhbnRpQ2hhbmdlcyA9IFtdO1xuICAgIHB1c2hTZWxlY3Rpb25Ub0hpc3Rvcnkoc2VsQWZ0ZXIsIGRlc3QpO1xuICAgIGRlc3QucHVzaCh7Y2hhbmdlczogYW50aUNoYW5nZXMsIGdlbmVyYXRpb246IGhpc3QuZ2VuZXJhdGlvbn0pO1xuICAgIGhpc3QuZ2VuZXJhdGlvbiA9IGV2ZW50LmdlbmVyYXRpb24gfHwgKytoaXN0Lm1heEdlbmVyYXRpb247XG5cbiAgICB2YXIgZmlsdGVyID0gaGFzSGFuZGxlcihkb2MsIFwiYmVmb3JlQ2hhbmdlXCIpIHx8IGRvYy5jbSAmJiBoYXNIYW5kbGVyKGRvYy5jbSwgXCJiZWZvcmVDaGFuZ2VcIik7XG5cbiAgICBmb3IgKHZhciBpID0gZXZlbnQuY2hhbmdlcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdmFyIGNoYW5nZSA9IGV2ZW50LmNoYW5nZXNbaV07XG4gICAgICBjaGFuZ2Uub3JpZ2luID0gdHlwZTtcbiAgICAgIGlmIChmaWx0ZXIgJiYgIWZpbHRlckNoYW5nZShkb2MsIGNoYW5nZSwgZmFsc2UpKSB7XG4gICAgICAgIHNvdXJjZS5sZW5ndGggPSAwO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGFudGlDaGFuZ2VzLnB1c2goaGlzdG9yeUNoYW5nZUZyb21DaGFuZ2UoZG9jLCBjaGFuZ2UpKTtcblxuICAgICAgdmFyIGFmdGVyID0gaSA/IGNvbXB1dGVTZWxBZnRlckNoYW5nZShkb2MsIGNoYW5nZSwgbnVsbCkgOiBsc3Qoc291cmNlKTtcbiAgICAgIG1ha2VDaGFuZ2VTaW5nbGVEb2MoZG9jLCBjaGFuZ2UsIGFmdGVyLCBtZXJnZU9sZFNwYW5zKGRvYywgY2hhbmdlKSk7XG4gICAgICBpZiAoZG9jLmNtKSBlbnN1cmVDdXJzb3JWaXNpYmxlKGRvYy5jbSk7XG4gICAgICB2YXIgcmViYXNlZCA9IFtdO1xuXG4gICAgICAvLyBQcm9wYWdhdGUgdG8gdGhlIGxpbmtlZCBkb2N1bWVudHNcbiAgICAgIGxpbmtlZERvY3MoZG9jLCBmdW5jdGlvbihkb2MsIHNoYXJlZEhpc3QpIHtcbiAgICAgICAgaWYgKCFzaGFyZWRIaXN0ICYmIGluZGV4T2YocmViYXNlZCwgZG9jLmhpc3RvcnkpID09IC0xKSB7XG4gICAgICAgICAgcmViYXNlSGlzdChkb2MuaGlzdG9yeSwgY2hhbmdlKTtcbiAgICAgICAgICByZWJhc2VkLnB1c2goZG9jLmhpc3RvcnkpO1xuICAgICAgICB9XG4gICAgICAgIG1ha2VDaGFuZ2VTaW5nbGVEb2MoZG9jLCBjaGFuZ2UsIG51bGwsIG1lcmdlT2xkU3BhbnMoZG9jLCBjaGFuZ2UpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIFN1Yi12aWV3cyBuZWVkIHRoZWlyIGxpbmUgbnVtYmVycyBzaGlmdGVkIHdoZW4gdGV4dCBpcyBhZGRlZFxuICAvLyBhYm92ZSBvciBiZWxvdyB0aGVtIGluIHRoZSBwYXJlbnQgZG9jdW1lbnQuXG4gIGZ1bmN0aW9uIHNoaWZ0RG9jKGRvYywgZGlzdGFuY2UpIHtcbiAgICBkb2MuZmlyc3QgKz0gZGlzdGFuY2U7XG4gICAgZG9jLnNlbCA9IG5ldyBTZWxlY3Rpb24obWFwKGRvYy5zZWwucmFuZ2VzLCBmdW5jdGlvbihyYW5nZSkge1xuICAgICAgcmV0dXJuIG5ldyBSYW5nZShQb3MocmFuZ2UuYW5jaG9yLmxpbmUgKyBkaXN0YW5jZSwgcmFuZ2UuYW5jaG9yLmNoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgUG9zKHJhbmdlLmhlYWQubGluZSArIGRpc3RhbmNlLCByYW5nZS5oZWFkLmNoKSk7XG4gICAgfSksIGRvYy5zZWwucHJpbUluZGV4KTtcbiAgICBpZiAoZG9jLmNtKSByZWdDaGFuZ2UoZG9jLmNtLCBkb2MuZmlyc3QsIGRvYy5maXJzdCAtIGRpc3RhbmNlLCBkaXN0YW5jZSk7XG4gIH1cblxuICAvLyBNb3JlIGxvd2VyLWxldmVsIGNoYW5nZSBmdW5jdGlvbiwgaGFuZGxpbmcgb25seSBhIHNpbmdsZSBkb2N1bWVudFxuICAvLyAobm90IGxpbmtlZCBvbmVzKS5cbiAgZnVuY3Rpb24gbWFrZUNoYW5nZVNpbmdsZURvYyhkb2MsIGNoYW5nZSwgc2VsQWZ0ZXIsIHNwYW5zKSB7XG4gICAgaWYgKGRvYy5jbSAmJiAhZG9jLmNtLmN1ck9wKVxuICAgICAgcmV0dXJuIG9wZXJhdGlvbihkb2MuY20sIG1ha2VDaGFuZ2VTaW5nbGVEb2MpKGRvYywgY2hhbmdlLCBzZWxBZnRlciwgc3BhbnMpO1xuXG4gICAgaWYgKGNoYW5nZS50by5saW5lIDwgZG9jLmZpcnN0KSB7XG4gICAgICBzaGlmdERvYyhkb2MsIGNoYW5nZS50ZXh0Lmxlbmd0aCAtIDEgLSAoY2hhbmdlLnRvLmxpbmUgLSBjaGFuZ2UuZnJvbS5saW5lKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjaGFuZ2UuZnJvbS5saW5lID4gZG9jLmxhc3RMaW5lKCkpIHJldHVybjtcblxuICAgIC8vIENsaXAgdGhlIGNoYW5nZSB0byB0aGUgc2l6ZSBvZiB0aGlzIGRvY1xuICAgIGlmIChjaGFuZ2UuZnJvbS5saW5lIDwgZG9jLmZpcnN0KSB7XG4gICAgICB2YXIgc2hpZnQgPSBjaGFuZ2UudGV4dC5sZW5ndGggLSAxIC0gKGRvYy5maXJzdCAtIGNoYW5nZS5mcm9tLmxpbmUpO1xuICAgICAgc2hpZnREb2MoZG9jLCBzaGlmdCk7XG4gICAgICBjaGFuZ2UgPSB7ZnJvbTogUG9zKGRvYy5maXJzdCwgMCksIHRvOiBQb3MoY2hhbmdlLnRvLmxpbmUgKyBzaGlmdCwgY2hhbmdlLnRvLmNoKSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBbbHN0KGNoYW5nZS50ZXh0KV0sIG9yaWdpbjogY2hhbmdlLm9yaWdpbn07XG4gICAgfVxuICAgIHZhciBsYXN0ID0gZG9jLmxhc3RMaW5lKCk7XG4gICAgaWYgKGNoYW5nZS50by5saW5lID4gbGFzdCkge1xuICAgICAgY2hhbmdlID0ge2Zyb206IGNoYW5nZS5mcm9tLCB0bzogUG9zKGxhc3QsIGdldExpbmUoZG9jLCBsYXN0KS50ZXh0Lmxlbmd0aCksXG4gICAgICAgICAgICAgICAgdGV4dDogW2NoYW5nZS50ZXh0WzBdXSwgb3JpZ2luOiBjaGFuZ2Uub3JpZ2lufTtcbiAgICB9XG5cbiAgICBjaGFuZ2UucmVtb3ZlZCA9IGdldEJldHdlZW4oZG9jLCBjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKTtcblxuICAgIGlmICghc2VsQWZ0ZXIpIHNlbEFmdGVyID0gY29tcHV0ZVNlbEFmdGVyQ2hhbmdlKGRvYywgY2hhbmdlLCBudWxsKTtcbiAgICBpZiAoZG9jLmNtKSBtYWtlQ2hhbmdlU2luZ2xlRG9jSW5FZGl0b3IoZG9jLmNtLCBjaGFuZ2UsIHNwYW5zKTtcbiAgICBlbHNlIHVwZGF0ZURvYyhkb2MsIGNoYW5nZSwgc3BhbnMpO1xuICAgIHNldFNlbGVjdGlvbk5vVW5kbyhkb2MsIHNlbEFmdGVyLCBzZWxfZG9udFNjcm9sbCk7XG4gIH1cblxuICAvLyBIYW5kbGUgdGhlIGludGVyYWN0aW9uIG9mIGEgY2hhbmdlIHRvIGEgZG9jdW1lbnQgd2l0aCB0aGUgZWRpdG9yXG4gIC8vIHRoYXQgdGhpcyBkb2N1bWVudCBpcyBwYXJ0IG9mLlxuICBmdW5jdGlvbiBtYWtlQ2hhbmdlU2luZ2xlRG9jSW5FZGl0b3IoY20sIGNoYW5nZSwgc3BhbnMpIHtcbiAgICB2YXIgZG9jID0gY20uZG9jLCBkaXNwbGF5ID0gY20uZGlzcGxheSwgZnJvbSA9IGNoYW5nZS5mcm9tLCB0byA9IGNoYW5nZS50bztcblxuICAgIHZhciByZWNvbXB1dGVNYXhMZW5ndGggPSBmYWxzZSwgY2hlY2tXaWR0aFN0YXJ0ID0gZnJvbS5saW5lO1xuICAgIGlmICghY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHtcbiAgICAgIGNoZWNrV2lkdGhTdGFydCA9IGxpbmVObyh2aXN1YWxMaW5lKGdldExpbmUoZG9jLCBmcm9tLmxpbmUpKSk7XG4gICAgICBkb2MuaXRlcihjaGVja1dpZHRoU3RhcnQsIHRvLmxpbmUgKyAxLCBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgIGlmIChsaW5lID09IGRpc3BsYXkubWF4TGluZSkge1xuICAgICAgICAgIHJlY29tcHV0ZU1heExlbmd0aCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChkb2Muc2VsLmNvbnRhaW5zKGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8pID4gLTEpXG4gICAgICBzaWduYWxDdXJzb3JBY3Rpdml0eShjbSk7XG5cbiAgICB1cGRhdGVEb2MoZG9jLCBjaGFuZ2UsIHNwYW5zLCBlc3RpbWF0ZUhlaWdodChjbSkpO1xuXG4gICAgaWYgKCFjbS5vcHRpb25zLmxpbmVXcmFwcGluZykge1xuICAgICAgZG9jLml0ZXIoY2hlY2tXaWR0aFN0YXJ0LCBmcm9tLmxpbmUgKyBjaGFuZ2UudGV4dC5sZW5ndGgsIGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgdmFyIGxlbiA9IGxpbmVMZW5ndGgobGluZSk7XG4gICAgICAgIGlmIChsZW4gPiBkaXNwbGF5Lm1heExpbmVMZW5ndGgpIHtcbiAgICAgICAgICBkaXNwbGF5Lm1heExpbmUgPSBsaW5lO1xuICAgICAgICAgIGRpc3BsYXkubWF4TGluZUxlbmd0aCA9IGxlbjtcbiAgICAgICAgICBkaXNwbGF5Lm1heExpbmVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICByZWNvbXB1dGVNYXhMZW5ndGggPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAocmVjb21wdXRlTWF4TGVuZ3RoKSBjbS5jdXJPcC51cGRhdGVNYXhMaW5lID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBBZGp1c3QgZnJvbnRpZXIsIHNjaGVkdWxlIHdvcmtlclxuICAgIGRvYy5mcm9udGllciA9IE1hdGgubWluKGRvYy5mcm9udGllciwgZnJvbS5saW5lKTtcbiAgICBzdGFydFdvcmtlcihjbSwgNDAwKTtcblxuICAgIHZhciBsZW5kaWZmID0gY2hhbmdlLnRleHQubGVuZ3RoIC0gKHRvLmxpbmUgLSBmcm9tLmxpbmUpIC0gMTtcbiAgICAvLyBSZW1lbWJlciB0aGF0IHRoZXNlIGxpbmVzIGNoYW5nZWQsIGZvciB1cGRhdGluZyB0aGUgZGlzcGxheVxuICAgIGlmIChmcm9tLmxpbmUgPT0gdG8ubGluZSAmJiBjaGFuZ2UudGV4dC5sZW5ndGggPT0gMSAmJiAhaXNXaG9sZUxpbmVVcGRhdGUoY20uZG9jLCBjaGFuZ2UpKVxuICAgICAgcmVnTGluZUNoYW5nZShjbSwgZnJvbS5saW5lLCBcInRleHRcIik7XG4gICAgZWxzZVxuICAgICAgcmVnQ2hhbmdlKGNtLCBmcm9tLmxpbmUsIHRvLmxpbmUgKyAxLCBsZW5kaWZmKTtcblxuICAgIHZhciBjaGFuZ2VzSGFuZGxlciA9IGhhc0hhbmRsZXIoY20sIFwiY2hhbmdlc1wiKSwgY2hhbmdlSGFuZGxlciA9IGhhc0hhbmRsZXIoY20sIFwiY2hhbmdlXCIpO1xuICAgIGlmIChjaGFuZ2VIYW5kbGVyIHx8IGNoYW5nZXNIYW5kbGVyKSB7XG4gICAgICB2YXIgb2JqID0ge1xuICAgICAgICBmcm9tOiBmcm9tLCB0bzogdG8sXG4gICAgICAgIHRleHQ6IGNoYW5nZS50ZXh0LFxuICAgICAgICByZW1vdmVkOiBjaGFuZ2UucmVtb3ZlZCxcbiAgICAgICAgb3JpZ2luOiBjaGFuZ2Uub3JpZ2luXG4gICAgICB9O1xuICAgICAgaWYgKGNoYW5nZUhhbmRsZXIpIHNpZ25hbExhdGVyKGNtLCBcImNoYW5nZVwiLCBjbSwgb2JqKTtcbiAgICAgIGlmIChjaGFuZ2VzSGFuZGxlcikgKGNtLmN1ck9wLmNoYW5nZU9ianMgfHwgKGNtLmN1ck9wLmNoYW5nZU9ianMgPSBbXSkpLnB1c2gob2JqKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlUmFuZ2UoZG9jLCBjb2RlLCBmcm9tLCB0bywgb3JpZ2luKSB7XG4gICAgaWYgKCF0bykgdG8gPSBmcm9tO1xuICAgIGlmIChjbXAodG8sIGZyb20pIDwgMCkgeyB2YXIgdG1wID0gdG87IHRvID0gZnJvbTsgZnJvbSA9IHRtcDsgfVxuICAgIGlmICh0eXBlb2YgY29kZSA9PSBcInN0cmluZ1wiKSBjb2RlID0gc3BsaXRMaW5lcyhjb2RlKTtcbiAgICBtYWtlQ2hhbmdlKGRvYywge2Zyb206IGZyb20sIHRvOiB0bywgdGV4dDogY29kZSwgb3JpZ2luOiBvcmlnaW59KTtcbiAgfVxuXG4gIC8vIFNDUk9MTElORyBUSElOR1MgSU5UTyBWSUVXXG5cbiAgLy8gSWYgYW4gZWRpdG9yIHNpdHMgb24gdGhlIHRvcCBvciBib3R0b20gb2YgdGhlIHdpbmRvdywgcGFydGlhbGx5XG4gIC8vIHNjcm9sbGVkIG91dCBvZiB2aWV3LCB0aGlzIGVuc3VyZXMgdGhhdCB0aGUgY3Vyc29yIGlzIHZpc2libGUuXG4gIGZ1bmN0aW9uIG1heWJlU2Nyb2xsV2luZG93KGNtLCBjb29yZHMpIHtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIGJveCA9IGRpc3BsYXkuc2l6ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGRvU2Nyb2xsID0gbnVsbDtcbiAgICBpZiAoY29vcmRzLnRvcCArIGJveC50b3AgPCAwKSBkb1Njcm9sbCA9IHRydWU7XG4gICAgZWxzZSBpZiAoY29vcmRzLmJvdHRvbSArIGJveC50b3AgPiAod2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpKSBkb1Njcm9sbCA9IGZhbHNlO1xuICAgIGlmIChkb1Njcm9sbCAhPSBudWxsICYmICFwaGFudG9tKSB7XG4gICAgICB2YXIgc2Nyb2xsTm9kZSA9IGVsdChcImRpdlwiLCBcIlxcdTIwMGJcIiwgbnVsbCwgXCJwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNvb3Jkcy50b3AgLSBkaXNwbGF5LnZpZXdPZmZzZXQgLSBwYWRkaW5nVG9wKGNtLmRpc3BsYXkpKSArIFwicHg7IGhlaWdodDogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNvb3Jkcy5ib3R0b20gLSBjb29yZHMudG9wICsgc2Nyb2xsZXJDdXRPZmYpICsgXCJweDsgbGVmdDogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRzLmxlZnQgKyBcInB4OyB3aWR0aDogMnB4O1wiKTtcbiAgICAgIGNtLmRpc3BsYXkubGluZVNwYWNlLmFwcGVuZENoaWxkKHNjcm9sbE5vZGUpO1xuICAgICAgc2Nyb2xsTm9kZS5zY3JvbGxJbnRvVmlldyhkb1Njcm9sbCk7XG4gICAgICBjbS5kaXNwbGF5LmxpbmVTcGFjZS5yZW1vdmVDaGlsZChzY3JvbGxOb2RlKTtcbiAgICB9XG4gIH1cblxuICAvLyBTY3JvbGwgYSBnaXZlbiBwb3NpdGlvbiBpbnRvIHZpZXcgKGltbWVkaWF0ZWx5KSwgdmVyaWZ5aW5nIHRoYXRcbiAgLy8gaXQgYWN0dWFsbHkgYmVjYW1lIHZpc2libGUgKGFzIGxpbmUgaGVpZ2h0cyBhcmUgYWNjdXJhdGVseVxuICAvLyBtZWFzdXJlZCwgdGhlIHBvc2l0aW9uIG9mIHNvbWV0aGluZyBtYXkgJ2RyaWZ0JyBkdXJpbmcgZHJhd2luZykuXG4gIGZ1bmN0aW9uIHNjcm9sbFBvc0ludG9WaWV3KGNtLCBwb3MsIGVuZCwgbWFyZ2luKSB7XG4gICAgaWYgKG1hcmdpbiA9PSBudWxsKSBtYXJnaW4gPSAwO1xuICAgIGZvciAoOzspIHtcbiAgICAgIHZhciBjaGFuZ2VkID0gZmFsc2UsIGNvb3JkcyA9IGN1cnNvckNvb3JkcyhjbSwgcG9zKTtcbiAgICAgIHZhciBlbmRDb29yZHMgPSAhZW5kIHx8IGVuZCA9PSBwb3MgPyBjb29yZHMgOiBjdXJzb3JDb29yZHMoY20sIGVuZCk7XG4gICAgICB2YXIgc2Nyb2xsUG9zID0gY2FsY3VsYXRlU2Nyb2xsUG9zKGNtLCBNYXRoLm1pbihjb29yZHMubGVmdCwgZW5kQ29vcmRzLmxlZnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihjb29yZHMudG9wLCBlbmRDb29yZHMudG9wKSAtIG1hcmdpbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoY29vcmRzLmxlZnQsIGVuZENvb3Jkcy5sZWZ0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoY29vcmRzLmJvdHRvbSwgZW5kQ29vcmRzLmJvdHRvbSkgKyBtYXJnaW4pO1xuICAgICAgdmFyIHN0YXJ0VG9wID0gY20uZG9jLnNjcm9sbFRvcCwgc3RhcnRMZWZ0ID0gY20uZG9jLnNjcm9sbExlZnQ7XG4gICAgICBpZiAoc2Nyb2xsUG9zLnNjcm9sbFRvcCAhPSBudWxsKSB7XG4gICAgICAgIHNldFNjcm9sbFRvcChjbSwgc2Nyb2xsUG9zLnNjcm9sbFRvcCk7XG4gICAgICAgIGlmIChNYXRoLmFicyhjbS5kb2Muc2Nyb2xsVG9wIC0gc3RhcnRUb3ApID4gMSkgY2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoc2Nyb2xsUG9zLnNjcm9sbExlZnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRTY3JvbGxMZWZ0KGNtLCBzY3JvbGxQb3Muc2Nyb2xsTGVmdCk7XG4gICAgICAgIGlmIChNYXRoLmFicyhjbS5kb2Muc2Nyb2xsTGVmdCAtIHN0YXJ0TGVmdCkgPiAxKSBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghY2hhbmdlZCkgcmV0dXJuIGNvb3JkcztcbiAgICB9XG4gIH1cblxuICAvLyBTY3JvbGwgYSBnaXZlbiBzZXQgb2YgY29vcmRpbmF0ZXMgaW50byB2aWV3IChpbW1lZGlhdGVseSkuXG4gIGZ1bmN0aW9uIHNjcm9sbEludG9WaWV3KGNtLCB4MSwgeTEsIHgyLCB5Mikge1xuICAgIHZhciBzY3JvbGxQb3MgPSBjYWxjdWxhdGVTY3JvbGxQb3MoY20sIHgxLCB5MSwgeDIsIHkyKTtcbiAgICBpZiAoc2Nyb2xsUG9zLnNjcm9sbFRvcCAhPSBudWxsKSBzZXRTY3JvbGxUb3AoY20sIHNjcm9sbFBvcy5zY3JvbGxUb3ApO1xuICAgIGlmIChzY3JvbGxQb3Muc2Nyb2xsTGVmdCAhPSBudWxsKSBzZXRTY3JvbGxMZWZ0KGNtLCBzY3JvbGxQb3Muc2Nyb2xsTGVmdCk7XG4gIH1cblxuICAvLyBDYWxjdWxhdGUgYSBuZXcgc2Nyb2xsIHBvc2l0aW9uIG5lZWRlZCB0byBzY3JvbGwgdGhlIGdpdmVuXG4gIC8vIHJlY3RhbmdsZSBpbnRvIHZpZXcuIFJldHVybnMgYW4gb2JqZWN0IHdpdGggc2Nyb2xsVG9wIGFuZFxuICAvLyBzY3JvbGxMZWZ0IHByb3BlcnRpZXMuIFdoZW4gdGhlc2UgYXJlIHVuZGVmaW5lZCwgdGhlXG4gIC8vIHZlcnRpY2FsL2hvcml6b250YWwgcG9zaXRpb24gZG9lcyBub3QgbmVlZCB0byBiZSBhZGp1c3RlZC5cbiAgZnVuY3Rpb24gY2FsY3VsYXRlU2Nyb2xsUG9zKGNtLCB4MSwgeTEsIHgyLCB5Mikge1xuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgc25hcE1hcmdpbiA9IHRleHRIZWlnaHQoY20uZGlzcGxheSk7XG4gICAgaWYgKHkxIDwgMCkgeTEgPSAwO1xuICAgIHZhciBzY3JlZW50b3AgPSBjbS5jdXJPcCAmJiBjbS5jdXJPcC5zY3JvbGxUb3AgIT0gbnVsbCA/IGNtLmN1ck9wLnNjcm9sbFRvcCA6IGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wO1xuICAgIHZhciBzY3JlZW4gPSBkaXNwbGF5LnNjcm9sbGVyLmNsaWVudEhlaWdodCAtIHNjcm9sbGVyQ3V0T2ZmLCByZXN1bHQgPSB7fTtcbiAgICB2YXIgZG9jQm90dG9tID0gY20uZG9jLmhlaWdodCArIHBhZGRpbmdWZXJ0KGRpc3BsYXkpO1xuICAgIHZhciBhdFRvcCA9IHkxIDwgc25hcE1hcmdpbiwgYXRCb3R0b20gPSB5MiA+IGRvY0JvdHRvbSAtIHNuYXBNYXJnaW47XG4gICAgaWYgKHkxIDwgc2NyZWVudG9wKSB7XG4gICAgICByZXN1bHQuc2Nyb2xsVG9wID0gYXRUb3AgPyAwIDogeTE7XG4gICAgfSBlbHNlIGlmICh5MiA+IHNjcmVlbnRvcCArIHNjcmVlbikge1xuICAgICAgdmFyIG5ld1RvcCA9IE1hdGgubWluKHkxLCAoYXRCb3R0b20gPyBkb2NCb3R0b20gOiB5MikgLSBzY3JlZW4pO1xuICAgICAgaWYgKG5ld1RvcCAhPSBzY3JlZW50b3ApIHJlc3VsdC5zY3JvbGxUb3AgPSBuZXdUb3A7XG4gICAgfVxuXG4gICAgdmFyIHNjcmVlbmxlZnQgPSBjbS5jdXJPcCAmJiBjbS5jdXJPcC5zY3JvbGxMZWZ0ICE9IG51bGwgPyBjbS5jdXJPcC5zY3JvbGxMZWZ0IDogZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0O1xuICAgIHZhciBzY3JlZW53ID0gZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aCAtIHNjcm9sbGVyQ3V0T2ZmO1xuICAgIHgxICs9IGRpc3BsYXkuZ3V0dGVycy5vZmZzZXRXaWR0aDsgeDIgKz0gZGlzcGxheS5ndXR0ZXJzLm9mZnNldFdpZHRoO1xuICAgIHZhciBndXR0ZXJ3ID0gZGlzcGxheS5ndXR0ZXJzLm9mZnNldFdpZHRoO1xuICAgIHZhciBhdExlZnQgPSB4MSA8IGd1dHRlcncgKyAxMDtcbiAgICBpZiAoeDEgPCBzY3JlZW5sZWZ0ICsgZ3V0dGVydyB8fCBhdExlZnQpIHtcbiAgICAgIGlmIChhdExlZnQpIHgxID0gMDtcbiAgICAgIHJlc3VsdC5zY3JvbGxMZWZ0ID0gTWF0aC5tYXgoMCwgeDEgLSAxMCAtIGd1dHRlcncpO1xuICAgIH0gZWxzZSBpZiAoeDIgPiBzY3JlZW53ICsgc2NyZWVubGVmdCAtIDMpIHtcbiAgICAgIHJlc3VsdC5zY3JvbGxMZWZ0ID0geDIgKyAxMCAtIHNjcmVlbnc7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBTdG9yZSBhIHJlbGF0aXZlIGFkanVzdG1lbnQgdG8gdGhlIHNjcm9sbCBwb3NpdGlvbiBpbiB0aGUgY3VycmVudFxuICAvLyBvcGVyYXRpb24gKHRvIGJlIGFwcGxpZWQgd2hlbiB0aGUgb3BlcmF0aW9uIGZpbmlzaGVzKS5cbiAgZnVuY3Rpb24gYWRkVG9TY3JvbGxQb3MoY20sIGxlZnQsIHRvcCkge1xuICAgIGlmIChsZWZ0ICE9IG51bGwgfHwgdG9wICE9IG51bGwpIHJlc29sdmVTY3JvbGxUb1BvcyhjbSk7XG4gICAgaWYgKGxlZnQgIT0gbnVsbClcbiAgICAgIGNtLmN1ck9wLnNjcm9sbExlZnQgPSAoY20uY3VyT3Auc2Nyb2xsTGVmdCA9PSBudWxsID8gY20uZG9jLnNjcm9sbExlZnQgOiBjbS5jdXJPcC5zY3JvbGxMZWZ0KSArIGxlZnQ7XG4gICAgaWYgKHRvcCAhPSBudWxsKVxuICAgICAgY20uY3VyT3Auc2Nyb2xsVG9wID0gKGNtLmN1ck9wLnNjcm9sbFRvcCA9PSBudWxsID8gY20uZG9jLnNjcm9sbFRvcCA6IGNtLmN1ck9wLnNjcm9sbFRvcCkgKyB0b3A7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgdGhhdCBhdCB0aGUgZW5kIG9mIHRoZSBvcGVyYXRpb24gdGhlIGN1cnJlbnQgY3Vyc29yIGlzXG4gIC8vIHNob3duLlxuICBmdW5jdGlvbiBlbnN1cmVDdXJzb3JWaXNpYmxlKGNtKSB7XG4gICAgcmVzb2x2ZVNjcm9sbFRvUG9zKGNtKTtcbiAgICB2YXIgY3VyID0gY20uZ2V0Q3Vyc29yKCksIGZyb20gPSBjdXIsIHRvID0gY3VyO1xuICAgIGlmICghY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHtcbiAgICAgIGZyb20gPSBjdXIuY2ggPyBQb3MoY3VyLmxpbmUsIGN1ci5jaCAtIDEpIDogY3VyO1xuICAgICAgdG8gPSBQb3MoY3VyLmxpbmUsIGN1ci5jaCArIDEpO1xuICAgIH1cbiAgICBjbS5jdXJPcC5zY3JvbGxUb1BvcyA9IHtmcm9tOiBmcm9tLCB0bzogdG8sIG1hcmdpbjogY20ub3B0aW9ucy5jdXJzb3JTY3JvbGxNYXJnaW4sIGlzQ3Vyc29yOiB0cnVlfTtcbiAgfVxuXG4gIC8vIFdoZW4gYW4gb3BlcmF0aW9uIGhhcyBpdHMgc2Nyb2xsVG9Qb3MgcHJvcGVydHkgc2V0LCBhbmQgYW5vdGhlclxuICAvLyBzY3JvbGwgYWN0aW9uIGlzIGFwcGxpZWQgYmVmb3JlIHRoZSBlbmQgb2YgdGhlIG9wZXJhdGlvbiwgdGhpc1xuICAvLyAnc2ltdWxhdGVzJyBzY3JvbGxpbmcgdGhhdCBwb3NpdGlvbiBpbnRvIHZpZXcgaW4gYSBjaGVhcCB3YXksIHNvXG4gIC8vIHRoYXQgdGhlIGVmZmVjdCBvZiBpbnRlcm1lZGlhdGUgc2Nyb2xsIGNvbW1hbmRzIGlzIG5vdCBpZ25vcmVkLlxuICBmdW5jdGlvbiByZXNvbHZlU2Nyb2xsVG9Qb3MoY20pIHtcbiAgICB2YXIgcmFuZ2UgPSBjbS5jdXJPcC5zY3JvbGxUb1BvcztcbiAgICBpZiAocmFuZ2UpIHtcbiAgICAgIGNtLmN1ck9wLnNjcm9sbFRvUG9zID0gbnVsbDtcbiAgICAgIHZhciBmcm9tID0gZXN0aW1hdGVDb29yZHMoY20sIHJhbmdlLmZyb20pLCB0byA9IGVzdGltYXRlQ29vcmRzKGNtLCByYW5nZS50byk7XG4gICAgICB2YXIgc1BvcyA9IGNhbGN1bGF0ZVNjcm9sbFBvcyhjbSwgTWF0aC5taW4oZnJvbS5sZWZ0LCB0by5sZWZ0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWluKGZyb20udG9wLCB0by50b3ApIC0gcmFuZ2UubWFyZ2luLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoZnJvbS5yaWdodCwgdG8ucmlnaHQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoZnJvbS5ib3R0b20sIHRvLmJvdHRvbSkgKyByYW5nZS5tYXJnaW4pO1xuICAgICAgY20uc2Nyb2xsVG8oc1Bvcy5zY3JvbGxMZWZ0LCBzUG9zLnNjcm9sbFRvcCk7XG4gICAgfVxuICB9XG5cbiAgLy8gQVBJIFVUSUxJVElFU1xuXG4gIC8vIEluZGVudCB0aGUgZ2l2ZW4gbGluZS4gVGhlIGhvdyBwYXJhbWV0ZXIgY2FuIGJlIFwic21hcnRcIixcbiAgLy8gXCJhZGRcIi9udWxsLCBcInN1YnRyYWN0XCIsIG9yIFwicHJldlwiLiBXaGVuIGFnZ3Jlc3NpdmUgaXMgZmFsc2VcbiAgLy8gKHR5cGljYWxseSBzZXQgdG8gdHJ1ZSBmb3IgZm9yY2VkIHNpbmdsZS1saW5lIGluZGVudHMpLCBlbXB0eVxuICAvLyBsaW5lcyBhcmUgbm90IGluZGVudGVkLCBhbmQgcGxhY2VzIHdoZXJlIHRoZSBtb2RlIHJldHVybnMgUGFzc1xuICAvLyBhcmUgbGVmdCBhbG9uZS5cbiAgZnVuY3Rpb24gaW5kZW50TGluZShjbSwgbiwgaG93LCBhZ2dyZXNzaXZlKSB7XG4gICAgdmFyIGRvYyA9IGNtLmRvYywgc3RhdGU7XG4gICAgaWYgKGhvdyA9PSBudWxsKSBob3cgPSBcImFkZFwiO1xuICAgIGlmIChob3cgPT0gXCJzbWFydFwiKSB7XG4gICAgICAvLyBGYWxsIGJhY2sgdG8gXCJwcmV2XCIgd2hlbiB0aGUgbW9kZSBkb2Vzbid0IGhhdmUgYW4gaW5kZW50YXRpb25cbiAgICAgIC8vIG1ldGhvZC5cbiAgICAgIGlmICghY20uZG9jLm1vZGUuaW5kZW50KSBob3cgPSBcInByZXZcIjtcbiAgICAgIGVsc2Ugc3RhdGUgPSBnZXRTdGF0ZUJlZm9yZShjbSwgbik7XG4gICAgfVxuXG4gICAgdmFyIHRhYlNpemUgPSBjbS5vcHRpb25zLnRhYlNpemU7XG4gICAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgbiksIGN1clNwYWNlID0gY291bnRDb2x1bW4obGluZS50ZXh0LCBudWxsLCB0YWJTaXplKTtcbiAgICBpZiAobGluZS5zdGF0ZUFmdGVyKSBsaW5lLnN0YXRlQWZ0ZXIgPSBudWxsO1xuICAgIHZhciBjdXJTcGFjZVN0cmluZyA9IGxpbmUudGV4dC5tYXRjaCgvXlxccyovKVswXSwgaW5kZW50YXRpb247XG4gICAgaWYgKCFhZ2dyZXNzaXZlICYmICEvXFxTLy50ZXN0KGxpbmUudGV4dCkpIHtcbiAgICAgIGluZGVudGF0aW9uID0gMDtcbiAgICAgIGhvdyA9IFwibm90XCI7XG4gICAgfSBlbHNlIGlmIChob3cgPT0gXCJzbWFydFwiKSB7XG4gICAgICBpbmRlbnRhdGlvbiA9IGNtLmRvYy5tb2RlLmluZGVudChzdGF0ZSwgbGluZS50ZXh0LnNsaWNlKGN1clNwYWNlU3RyaW5nLmxlbmd0aCksIGxpbmUudGV4dCk7XG4gICAgICBpZiAoaW5kZW50YXRpb24gPT0gUGFzcykge1xuICAgICAgICBpZiAoIWFnZ3Jlc3NpdmUpIHJldHVybjtcbiAgICAgICAgaG93ID0gXCJwcmV2XCI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChob3cgPT0gXCJwcmV2XCIpIHtcbiAgICAgIGlmIChuID4gZG9jLmZpcnN0KSBpbmRlbnRhdGlvbiA9IGNvdW50Q29sdW1uKGdldExpbmUoZG9jLCBuLTEpLnRleHQsIG51bGwsIHRhYlNpemUpO1xuICAgICAgZWxzZSBpbmRlbnRhdGlvbiA9IDA7XG4gICAgfSBlbHNlIGlmIChob3cgPT0gXCJhZGRcIikge1xuICAgICAgaW5kZW50YXRpb24gPSBjdXJTcGFjZSArIGNtLm9wdGlvbnMuaW5kZW50VW5pdDtcbiAgICB9IGVsc2UgaWYgKGhvdyA9PSBcInN1YnRyYWN0XCIpIHtcbiAgICAgIGluZGVudGF0aW9uID0gY3VyU3BhY2UgLSBjbS5vcHRpb25zLmluZGVudFVuaXQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaG93ID09IFwibnVtYmVyXCIpIHtcbiAgICAgIGluZGVudGF0aW9uID0gY3VyU3BhY2UgKyBob3c7XG4gICAgfVxuICAgIGluZGVudGF0aW9uID0gTWF0aC5tYXgoMCwgaW5kZW50YXRpb24pO1xuXG4gICAgdmFyIGluZGVudFN0cmluZyA9IFwiXCIsIHBvcyA9IDA7XG4gICAgaWYgKGNtLm9wdGlvbnMuaW5kZW50V2l0aFRhYnMpXG4gICAgICBmb3IgKHZhciBpID0gTWF0aC5mbG9vcihpbmRlbnRhdGlvbiAvIHRhYlNpemUpOyBpOyAtLWkpIHtwb3MgKz0gdGFiU2l6ZTsgaW5kZW50U3RyaW5nICs9IFwiXFx0XCI7fVxuICAgIGlmIChwb3MgPCBpbmRlbnRhdGlvbikgaW5kZW50U3RyaW5nICs9IHNwYWNlU3RyKGluZGVudGF0aW9uIC0gcG9zKTtcblxuICAgIGlmIChpbmRlbnRTdHJpbmcgIT0gY3VyU3BhY2VTdHJpbmcpIHtcbiAgICAgIHJlcGxhY2VSYW5nZShjbS5kb2MsIGluZGVudFN0cmluZywgUG9zKG4sIDApLCBQb3MobiwgY3VyU3BhY2VTdHJpbmcubGVuZ3RoKSwgXCIraW5wdXRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEVuc3VyZSB0aGF0LCBpZiB0aGUgY3Vyc29yIHdhcyBpbiB0aGUgd2hpdGVzcGFjZSBhdCB0aGUgc3RhcnRcbiAgICAgIC8vIG9mIHRoZSBsaW5lLCBpdCBpcyBtb3ZlZCB0byB0aGUgZW5kIG9mIHRoYXQgc3BhY2UuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvYy5zZWwucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByYW5nZSA9IGRvYy5zZWwucmFuZ2VzW2ldO1xuICAgICAgICBpZiAocmFuZ2UuaGVhZC5saW5lID09IG4gJiYgcmFuZ2UuaGVhZC5jaCA8IGN1clNwYWNlU3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBwb3MgPSBQb3MobiwgY3VyU3BhY2VTdHJpbmcubGVuZ3RoKTtcbiAgICAgICAgICByZXBsYWNlT25lU2VsZWN0aW9uKGRvYywgaSwgbmV3IFJhbmdlKHBvcywgcG9zKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbGluZS5zdGF0ZUFmdGVyID0gbnVsbDtcbiAgfVxuXG4gIC8vIFV0aWxpdHkgZm9yIGFwcGx5aW5nIGEgY2hhbmdlIHRvIGEgbGluZSBieSBoYW5kbGUgb3IgbnVtYmVyLFxuICAvLyByZXR1cm5pbmcgdGhlIG51bWJlciBhbmQgb3B0aW9uYWxseSByZWdpc3RlcmluZyB0aGUgbGluZSBhc1xuICAvLyBjaGFuZ2VkLlxuICBmdW5jdGlvbiBjaGFuZ2VMaW5lKGNtLCBoYW5kbGUsIGNoYW5nZVR5cGUsIG9wKSB7XG4gICAgdmFyIG5vID0gaGFuZGxlLCBsaW5lID0gaGFuZGxlLCBkb2MgPSBjbS5kb2M7XG4gICAgaWYgKHR5cGVvZiBoYW5kbGUgPT0gXCJudW1iZXJcIikgbGluZSA9IGdldExpbmUoZG9jLCBjbGlwTGluZShkb2MsIGhhbmRsZSkpO1xuICAgIGVsc2Ugbm8gPSBsaW5lTm8oaGFuZGxlKTtcbiAgICBpZiAobm8gPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgaWYgKG9wKGxpbmUsIG5vKSkgcmVnTGluZUNoYW5nZShjbSwgbm8sIGNoYW5nZVR5cGUpO1xuICAgIHJldHVybiBsaW5lO1xuICB9XG5cbiAgLy8gSGVscGVyIGZvciBkZWxldGluZyB0ZXh0IG5lYXIgdGhlIHNlbGVjdGlvbihzKSwgdXNlZCB0byBpbXBsZW1lbnRcbiAgLy8gYmFja3NwYWNlLCBkZWxldGUsIGFuZCBzaW1pbGFyIGZ1bmN0aW9uYWxpdHkuXG4gIGZ1bmN0aW9uIGRlbGV0ZU5lYXJTZWxlY3Rpb24oY20sIGNvbXB1dGUpIHtcbiAgICB2YXIgcmFuZ2VzID0gY20uZG9jLnNlbC5yYW5nZXMsIGtpbGwgPSBbXTtcbiAgICAvLyBCdWlsZCB1cCBhIHNldCBvZiByYW5nZXMgdG8ga2lsbCBmaXJzdCwgbWVyZ2luZyBvdmVybGFwcGluZ1xuICAgIC8vIHJhbmdlcy5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRvS2lsbCA9IGNvbXB1dGUocmFuZ2VzW2ldKTtcbiAgICAgIHdoaWxlIChraWxsLmxlbmd0aCAmJiBjbXAodG9LaWxsLmZyb20sIGxzdChraWxsKS50bykgPD0gMCkge1xuICAgICAgICB2YXIgcmVwbGFjZWQgPSBraWxsLnBvcCgpO1xuICAgICAgICBpZiAoY21wKHJlcGxhY2VkLmZyb20sIHRvS2lsbC5mcm9tKSA8IDApIHtcbiAgICAgICAgICB0b0tpbGwuZnJvbSA9IHJlcGxhY2VkLmZyb207XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGtpbGwucHVzaCh0b0tpbGwpO1xuICAgIH1cbiAgICAvLyBOZXh0LCByZW1vdmUgdGhvc2UgYWN0dWFsIHJhbmdlcy5cbiAgICBydW5Jbk9wKGNtLCBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIGkgPSBraWxsLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICByZXBsYWNlUmFuZ2UoY20uZG9jLCBcIlwiLCBraWxsW2ldLmZyb20sIGtpbGxbaV0udG8sIFwiK2RlbGV0ZVwiKTtcbiAgICAgIGVuc3VyZUN1cnNvclZpc2libGUoY20pO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gVXNlZCBmb3IgaG9yaXpvbnRhbCByZWxhdGl2ZSBtb3Rpb24uIERpciBpcyAtMSBvciAxIChsZWZ0IG9yXG4gIC8vIHJpZ2h0KSwgdW5pdCBjYW4gYmUgXCJjaGFyXCIsIFwiY29sdW1uXCIgKGxpa2UgY2hhciwgYnV0IGRvZXNuJ3RcbiAgLy8gY3Jvc3MgbGluZSBib3VuZGFyaWVzKSwgXCJ3b3JkXCIgKGFjcm9zcyBuZXh0IHdvcmQpLCBvciBcImdyb3VwXCIgKHRvXG4gIC8vIHRoZSBzdGFydCBvZiBuZXh0IGdyb3VwIG9mIHdvcmQgb3Igbm9uLXdvcmQtbm9uLXdoaXRlc3BhY2VcbiAgLy8gY2hhcnMpLiBUaGUgdmlzdWFsbHkgcGFyYW0gY29udHJvbHMgd2hldGhlciwgaW4gcmlnaHQtdG8tbGVmdFxuICAvLyB0ZXh0LCBkaXJlY3Rpb24gMSBtZWFucyB0byBtb3ZlIHRvd2FyZHMgdGhlIG5leHQgaW5kZXggaW4gdGhlXG4gIC8vIHN0cmluZywgb3IgdG93YXJkcyB0aGUgY2hhcmFjdGVyIHRvIHRoZSByaWdodCBvZiB0aGUgY3VycmVudFxuICAvLyBwb3NpdGlvbi4gVGhlIHJlc3VsdGluZyBwb3NpdGlvbiB3aWxsIGhhdmUgYSBoaXRTaWRlPXRydWVcbiAgLy8gcHJvcGVydHkgaWYgaXQgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudC5cbiAgZnVuY3Rpb24gZmluZFBvc0goZG9jLCBwb3MsIGRpciwgdW5pdCwgdmlzdWFsbHkpIHtcbiAgICB2YXIgbGluZSA9IHBvcy5saW5lLCBjaCA9IHBvcy5jaCwgb3JpZ0RpciA9IGRpcjtcbiAgICB2YXIgbGluZU9iaiA9IGdldExpbmUoZG9jLCBsaW5lKTtcbiAgICB2YXIgcG9zc2libGUgPSB0cnVlO1xuICAgIGZ1bmN0aW9uIGZpbmROZXh0TGluZSgpIHtcbiAgICAgIHZhciBsID0gbGluZSArIGRpcjtcbiAgICAgIGlmIChsIDwgZG9jLmZpcnN0IHx8IGwgPj0gZG9jLmZpcnN0ICsgZG9jLnNpemUpIHJldHVybiAocG9zc2libGUgPSBmYWxzZSk7XG4gICAgICBsaW5lID0gbDtcbiAgICAgIHJldHVybiBsaW5lT2JqID0gZ2V0TGluZShkb2MsIGwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3ZlT25jZShib3VuZFRvTGluZSkge1xuICAgICAgdmFyIG5leHQgPSAodmlzdWFsbHkgPyBtb3ZlVmlzdWFsbHkgOiBtb3ZlTG9naWNhbGx5KShsaW5lT2JqLCBjaCwgZGlyLCB0cnVlKTtcbiAgICAgIGlmIChuZXh0ID09IG51bGwpIHtcbiAgICAgICAgaWYgKCFib3VuZFRvTGluZSAmJiBmaW5kTmV4dExpbmUoKSkge1xuICAgICAgICAgIGlmICh2aXN1YWxseSkgY2ggPSAoZGlyIDwgMCA/IGxpbmVSaWdodCA6IGxpbmVMZWZ0KShsaW5lT2JqKTtcbiAgICAgICAgICBlbHNlIGNoID0gZGlyIDwgMCA/IGxpbmVPYmoudGV4dC5sZW5ndGggOiAwO1xuICAgICAgICB9IGVsc2UgcmV0dXJuIChwb3NzaWJsZSA9IGZhbHNlKTtcbiAgICAgIH0gZWxzZSBjaCA9IG5leHQ7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodW5pdCA9PSBcImNoYXJcIikgbW92ZU9uY2UoKTtcbiAgICBlbHNlIGlmICh1bml0ID09IFwiY29sdW1uXCIpIG1vdmVPbmNlKHRydWUpO1xuICAgIGVsc2UgaWYgKHVuaXQgPT0gXCJ3b3JkXCIgfHwgdW5pdCA9PSBcImdyb3VwXCIpIHtcbiAgICAgIHZhciBzYXdUeXBlID0gbnVsbCwgZ3JvdXAgPSB1bml0ID09IFwiZ3JvdXBcIjtcbiAgICAgIGZvciAodmFyIGZpcnN0ID0gdHJ1ZTs7IGZpcnN0ID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGRpciA8IDAgJiYgIW1vdmVPbmNlKCFmaXJzdCkpIGJyZWFrO1xuICAgICAgICB2YXIgY3VyID0gbGluZU9iai50ZXh0LmNoYXJBdChjaCkgfHwgXCJcXG5cIjtcbiAgICAgICAgdmFyIHR5cGUgPSBpc1dvcmRDaGFyKGN1cikgPyBcIndcIlxuICAgICAgICAgIDogZ3JvdXAgJiYgY3VyID09IFwiXFxuXCIgPyBcIm5cIlxuICAgICAgICAgIDogIWdyb3VwIHx8IC9cXHMvLnRlc3QoY3VyKSA/IG51bGxcbiAgICAgICAgICA6IFwicFwiO1xuICAgICAgICBpZiAoZ3JvdXAgJiYgIWZpcnN0ICYmICF0eXBlKSB0eXBlID0gXCJzXCI7XG4gICAgICAgIGlmIChzYXdUeXBlICYmIHNhd1R5cGUgIT0gdHlwZSkge1xuICAgICAgICAgIGlmIChkaXIgPCAwKSB7ZGlyID0gMTsgbW92ZU9uY2UoKTt9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZSkgc2F3VHlwZSA9IHR5cGU7XG4gICAgICAgIGlmIChkaXIgPiAwICYmICFtb3ZlT25jZSghZmlyc3QpKSBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHNraXBBdG9taWMoZG9jLCBQb3MobGluZSwgY2gpLCBvcmlnRGlyLCB0cnVlKTtcbiAgICBpZiAoIXBvc3NpYmxlKSByZXN1bHQuaGl0U2lkZSA9IHRydWU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIEZvciByZWxhdGl2ZSB2ZXJ0aWNhbCBtb3ZlbWVudC4gRGlyIG1heSBiZSAtMSBvciAxLiBVbml0IGNhbiBiZVxuICAvLyBcInBhZ2VcIiBvciBcImxpbmVcIi4gVGhlIHJlc3VsdGluZyBwb3NpdGlvbiB3aWxsIGhhdmUgYSBoaXRTaWRlPXRydWVcbiAgLy8gcHJvcGVydHkgaWYgaXQgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudC5cbiAgZnVuY3Rpb24gZmluZFBvc1YoY20sIHBvcywgZGlyLCB1bml0KSB7XG4gICAgdmFyIGRvYyA9IGNtLmRvYywgeCA9IHBvcy5sZWZ0LCB5O1xuICAgIGlmICh1bml0ID09IFwicGFnZVwiKSB7XG4gICAgICB2YXIgcGFnZVNpemUgPSBNYXRoLm1pbihjbS5kaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0LCB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCk7XG4gICAgICB5ID0gcG9zLnRvcCArIGRpciAqIChwYWdlU2l6ZSAtIChkaXIgPCAwID8gMS41IDogLjUpICogdGV4dEhlaWdodChjbS5kaXNwbGF5KSk7XG4gICAgfSBlbHNlIGlmICh1bml0ID09IFwibGluZVwiKSB7XG4gICAgICB5ID0gZGlyID4gMCA/IHBvcy5ib3R0b20gKyAzIDogcG9zLnRvcCAtIDM7XG4gICAgfVxuICAgIGZvciAoOzspIHtcbiAgICAgIHZhciB0YXJnZXQgPSBjb29yZHNDaGFyKGNtLCB4LCB5KTtcbiAgICAgIGlmICghdGFyZ2V0Lm91dHNpZGUpIGJyZWFrO1xuICAgICAgaWYgKGRpciA8IDAgPyB5IDw9IDAgOiB5ID49IGRvYy5oZWlnaHQpIHsgdGFyZ2V0LmhpdFNpZGUgPSB0cnVlOyBicmVhazsgfVxuICAgICAgeSArPSBkaXIgKiA1O1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgLy8gRmluZCB0aGUgd29yZCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gKGFzIHJldHVybmVkIGJ5IGNvb3Jkc0NoYXIpLlxuICBmdW5jdGlvbiBmaW5kV29yZEF0KGRvYywgcG9zKSB7XG4gICAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgcG9zLmxpbmUpLnRleHQ7XG4gICAgdmFyIHN0YXJ0ID0gcG9zLmNoLCBlbmQgPSBwb3MuY2g7XG4gICAgaWYgKGxpbmUpIHtcbiAgICAgIGlmICgocG9zLnhSZWwgPCAwIHx8IGVuZCA9PSBsaW5lLmxlbmd0aCkgJiYgc3RhcnQpIC0tc3RhcnQ7IGVsc2UgKytlbmQ7XG4gICAgICB2YXIgc3RhcnRDaGFyID0gbGluZS5jaGFyQXQoc3RhcnQpO1xuICAgICAgdmFyIGNoZWNrID0gaXNXb3JkQ2hhcihzdGFydENoYXIpID8gaXNXb3JkQ2hhclxuICAgICAgICA6IC9cXHMvLnRlc3Qoc3RhcnRDaGFyKSA/IGZ1bmN0aW9uKGNoKSB7cmV0dXJuIC9cXHMvLnRlc3QoY2gpO31cbiAgICAgICAgOiBmdW5jdGlvbihjaCkge3JldHVybiAhL1xccy8udGVzdChjaCkgJiYgIWlzV29yZENoYXIoY2gpO307XG4gICAgICB3aGlsZSAoc3RhcnQgPiAwICYmIGNoZWNrKGxpbmUuY2hhckF0KHN0YXJ0IC0gMSkpKSAtLXN0YXJ0O1xuICAgICAgd2hpbGUgKGVuZCA8IGxpbmUubGVuZ3RoICYmIGNoZWNrKGxpbmUuY2hhckF0KGVuZCkpKSArK2VuZDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSYW5nZShQb3MocG9zLmxpbmUsIHN0YXJ0KSwgUG9zKHBvcy5saW5lLCBlbmQpKTtcbiAgfVxuXG4gIC8vIEVESVRPUiBNRVRIT0RTXG5cbiAgLy8gVGhlIHB1YmxpY2x5IHZpc2libGUgQVBJLiBOb3RlIHRoYXQgbWV0aG9kT3AoZikgbWVhbnNcbiAgLy8gJ3dyYXAgZiBpbiBhbiBvcGVyYXRpb24sIHBlcmZvcm1lZCBvbiBpdHMgYHRoaXNgIHBhcmFtZXRlcicuXG5cbiAgLy8gVGhpcyBpcyBub3QgdGhlIGNvbXBsZXRlIHNldCBvZiBlZGl0b3IgbWV0aG9kcy4gTW9zdCBvZiB0aGVcbiAgLy8gbWV0aG9kcyBkZWZpbmVkIG9uIHRoZSBEb2MgdHlwZSBhcmUgYWxzbyBpbmplY3RlZCBpbnRvXG4gIC8vIENvZGVNaXJyb3IucHJvdG90eXBlLCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgYW5kXG4gIC8vIGNvbnZlbmllbmNlLlxuXG4gIENvZGVNaXJyb3IucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb2RlTWlycm9yLFxuICAgIGZvY3VzOiBmdW5jdGlvbigpe3dpbmRvdy5mb2N1cygpOyBmb2N1c0lucHV0KHRoaXMpOyBmYXN0UG9sbCh0aGlzKTt9LFxuXG4gICAgc2V0T3B0aW9uOiBmdW5jdGlvbihvcHRpb24sIHZhbHVlKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucywgb2xkID0gb3B0aW9uc1tvcHRpb25dO1xuICAgICAgaWYgKG9wdGlvbnNbb3B0aW9uXSA9PSB2YWx1ZSAmJiBvcHRpb24gIT0gXCJtb2RlXCIpIHJldHVybjtcbiAgICAgIG9wdGlvbnNbb3B0aW9uXSA9IHZhbHVlO1xuICAgICAgaWYgKG9wdGlvbkhhbmRsZXJzLmhhc093blByb3BlcnR5KG9wdGlvbikpXG4gICAgICAgIG9wZXJhdGlvbih0aGlzLCBvcHRpb25IYW5kbGVyc1tvcHRpb25dKSh0aGlzLCB2YWx1ZSwgb2xkKTtcbiAgICB9LFxuXG4gICAgZ2V0T3B0aW9uOiBmdW5jdGlvbihvcHRpb24pIHtyZXR1cm4gdGhpcy5vcHRpb25zW29wdGlvbl07fSxcbiAgICBnZXREb2M6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLmRvYzt9LFxuXG4gICAgYWRkS2V5TWFwOiBmdW5jdGlvbihtYXAsIGJvdHRvbSkge1xuICAgICAgdGhpcy5zdGF0ZS5rZXlNYXBzW2JvdHRvbSA/IFwicHVzaFwiIDogXCJ1bnNoaWZ0XCJdKG1hcCk7XG4gICAgfSxcbiAgICByZW1vdmVLZXlNYXA6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgdmFyIG1hcHMgPSB0aGlzLnN0YXRlLmtleU1hcHM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcHMubGVuZ3RoOyArK2kpXG4gICAgICAgIGlmIChtYXBzW2ldID09IG1hcCB8fCAodHlwZW9mIG1hcHNbaV0gIT0gXCJzdHJpbmdcIiAmJiBtYXBzW2ldLm5hbWUgPT0gbWFwKSkge1xuICAgICAgICAgIG1hcHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGFkZE92ZXJsYXk6IG1ldGhvZE9wKGZ1bmN0aW9uKHNwZWMsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBtb2RlID0gc3BlYy50b2tlbiA/IHNwZWMgOiBDb2RlTWlycm9yLmdldE1vZGUodGhpcy5vcHRpb25zLCBzcGVjKTtcbiAgICAgIGlmIChtb2RlLnN0YXJ0U3RhdGUpIHRocm93IG5ldyBFcnJvcihcIk92ZXJsYXlzIG1heSBub3QgYmUgc3RhdGVmdWwuXCIpO1xuICAgICAgdGhpcy5zdGF0ZS5vdmVybGF5cy5wdXNoKHttb2RlOiBtb2RlLCBtb2RlU3BlYzogc3BlYywgb3BhcXVlOiBvcHRpb25zICYmIG9wdGlvbnMub3BhcXVlfSk7XG4gICAgICB0aGlzLnN0YXRlLm1vZGVHZW4rKztcbiAgICAgIHJlZ0NoYW5nZSh0aGlzKTtcbiAgICB9KSxcbiAgICByZW1vdmVPdmVybGF5OiBtZXRob2RPcChmdW5jdGlvbihzcGVjKSB7XG4gICAgICB2YXIgb3ZlcmxheXMgPSB0aGlzLnN0YXRlLm92ZXJsYXlzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdmVybGF5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgY3VyID0gb3ZlcmxheXNbaV0ubW9kZVNwZWM7XG4gICAgICAgIGlmIChjdXIgPT0gc3BlYyB8fCB0eXBlb2Ygc3BlYyA9PSBcInN0cmluZ1wiICYmIGN1ci5uYW1lID09IHNwZWMpIHtcbiAgICAgICAgICBvdmVybGF5cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgdGhpcy5zdGF0ZS5tb2RlR2VuKys7XG4gICAgICAgICAgcmVnQ2hhbmdlKHRoaXMpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLFxuXG4gICAgaW5kZW50TGluZTogbWV0aG9kT3AoZnVuY3Rpb24obiwgZGlyLCBhZ2dyZXNzaXZlKSB7XG4gICAgICBpZiAodHlwZW9mIGRpciAhPSBcInN0cmluZ1wiICYmIHR5cGVvZiBkaXIgIT0gXCJudW1iZXJcIikge1xuICAgICAgICBpZiAoZGlyID09IG51bGwpIGRpciA9IHRoaXMub3B0aW9ucy5zbWFydEluZGVudCA/IFwic21hcnRcIiA6IFwicHJldlwiO1xuICAgICAgICBlbHNlIGRpciA9IGRpciA/IFwiYWRkXCIgOiBcInN1YnRyYWN0XCI7XG4gICAgICB9XG4gICAgICBpZiAoaXNMaW5lKHRoaXMuZG9jLCBuKSkgaW5kZW50TGluZSh0aGlzLCBuLCBkaXIsIGFnZ3Jlc3NpdmUpO1xuICAgIH0pLFxuICAgIGluZGVudFNlbGVjdGlvbjogbWV0aG9kT3AoZnVuY3Rpb24oaG93KSB7XG4gICAgICB2YXIgcmFuZ2VzID0gdGhpcy5kb2Muc2VsLnJhbmdlcywgZW5kID0gLTE7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkoKSkge1xuICAgICAgICAgIHZhciBzdGFydCA9IE1hdGgubWF4KGVuZCwgcmFuZ2UuZnJvbSgpLmxpbmUpO1xuICAgICAgICAgIHZhciB0byA9IHJhbmdlLnRvKCk7XG4gICAgICAgICAgZW5kID0gTWF0aC5taW4odGhpcy5sYXN0TGluZSgpLCB0by5saW5lIC0gKHRvLmNoID8gMCA6IDEpKSArIDE7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IHN0YXJ0OyBqIDwgZW5kOyArK2opXG4gICAgICAgICAgICBpbmRlbnRMaW5lKHRoaXMsIGosIGhvdyk7XG4gICAgICAgIH0gZWxzZSBpZiAocmFuZ2UuaGVhZC5saW5lID4gZW5kKSB7XG4gICAgICAgICAgaW5kZW50TGluZSh0aGlzLCByYW5nZS5oZWFkLmxpbmUsIGhvdywgdHJ1ZSk7XG4gICAgICAgICAgZW5kID0gcmFuZ2UuaGVhZC5saW5lO1xuICAgICAgICAgIGlmIChpID09IHRoaXMuZG9jLnNlbC5wcmltSW5kZXgpIGVuc3VyZUN1cnNvclZpc2libGUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSxcblxuICAgIC8vIEZldGNoIHRoZSBwYXJzZXIgdG9rZW4gZm9yIGEgZ2l2ZW4gY2hhcmFjdGVyLiBVc2VmdWwgZm9yIGhhY2tzXG4gICAgLy8gdGhhdCB3YW50IHRvIGluc3BlY3QgdGhlIG1vZGUgc3RhdGUgKHNheSwgZm9yIGNvbXBsZXRpb24pLlxuICAgIGdldFRva2VuQXQ6IGZ1bmN0aW9uKHBvcywgcHJlY2lzZSkge1xuICAgICAgdmFyIGRvYyA9IHRoaXMuZG9jO1xuICAgICAgcG9zID0gY2xpcFBvcyhkb2MsIHBvcyk7XG4gICAgICB2YXIgc3RhdGUgPSBnZXRTdGF0ZUJlZm9yZSh0aGlzLCBwb3MubGluZSwgcHJlY2lzZSksIG1vZGUgPSB0aGlzLmRvYy5tb2RlO1xuICAgICAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgcG9zLmxpbmUpO1xuICAgICAgdmFyIHN0cmVhbSA9IG5ldyBTdHJpbmdTdHJlYW0obGluZS50ZXh0LCB0aGlzLm9wdGlvbnMudGFiU2l6ZSk7XG4gICAgICB3aGlsZSAoc3RyZWFtLnBvcyA8IHBvcy5jaCAmJiAhc3RyZWFtLmVvbCgpKSB7XG4gICAgICAgIHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3M7XG4gICAgICAgIHZhciBzdHlsZSA9IHJlYWRUb2tlbihtb2RlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7c3RhcnQ6IHN0cmVhbS5zdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBzdHJlYW0ucG9zLFxuICAgICAgICAgICAgICBzdHJpbmc6IHN0cmVhbS5jdXJyZW50KCksXG4gICAgICAgICAgICAgIHR5cGU6IHN0eWxlIHx8IG51bGwsXG4gICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZX07XG4gICAgfSxcblxuICAgIGdldFRva2VuVHlwZUF0OiBmdW5jdGlvbihwb3MpIHtcbiAgICAgIHBvcyA9IGNsaXBQb3ModGhpcy5kb2MsIHBvcyk7XG4gICAgICB2YXIgc3R5bGVzID0gZ2V0TGluZVN0eWxlcyh0aGlzLCBnZXRMaW5lKHRoaXMuZG9jLCBwb3MubGluZSkpO1xuICAgICAgdmFyIGJlZm9yZSA9IDAsIGFmdGVyID0gKHN0eWxlcy5sZW5ndGggLSAxKSAvIDIsIGNoID0gcG9zLmNoO1xuICAgICAgdmFyIHR5cGU7XG4gICAgICBpZiAoY2ggPT0gMCkgdHlwZSA9IHN0eWxlc1syXTtcbiAgICAgIGVsc2UgZm9yICg7Oykge1xuICAgICAgICB2YXIgbWlkID0gKGJlZm9yZSArIGFmdGVyKSA+PiAxO1xuICAgICAgICBpZiAoKG1pZCA/IHN0eWxlc1ttaWQgKiAyIC0gMV0gOiAwKSA+PSBjaCkgYWZ0ZXIgPSBtaWQ7XG4gICAgICAgIGVsc2UgaWYgKHN0eWxlc1ttaWQgKiAyICsgMV0gPCBjaCkgYmVmb3JlID0gbWlkICsgMTtcbiAgICAgICAgZWxzZSB7IHR5cGUgPSBzdHlsZXNbbWlkICogMiArIDJdOyBicmVhazsgfVxuICAgICAgfVxuICAgICAgdmFyIGN1dCA9IHR5cGUgPyB0eXBlLmluZGV4T2YoXCJjbS1vdmVybGF5IFwiKSA6IC0xO1xuICAgICAgcmV0dXJuIGN1dCA8IDAgPyB0eXBlIDogY3V0ID09IDAgPyBudWxsIDogdHlwZS5zbGljZSgwLCBjdXQgLSAxKTtcbiAgICB9LFxuXG4gICAgZ2V0TW9kZUF0OiBmdW5jdGlvbihwb3MpIHtcbiAgICAgIHZhciBtb2RlID0gdGhpcy5kb2MubW9kZTtcbiAgICAgIGlmICghbW9kZS5pbm5lck1vZGUpIHJldHVybiBtb2RlO1xuICAgICAgcmV0dXJuIENvZGVNaXJyb3IuaW5uZXJNb2RlKG1vZGUsIHRoaXMuZ2V0VG9rZW5BdChwb3MpLnN0YXRlKS5tb2RlO1xuICAgIH0sXG5cbiAgICBnZXRIZWxwZXI6IGZ1bmN0aW9uKHBvcywgdHlwZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0SGVscGVycyhwb3MsIHR5cGUpWzBdO1xuICAgIH0sXG5cbiAgICBnZXRIZWxwZXJzOiBmdW5jdGlvbihwb3MsIHR5cGUpIHtcbiAgICAgIHZhciBmb3VuZCA9IFtdO1xuICAgICAgaWYgKCFoZWxwZXJzLmhhc093blByb3BlcnR5KHR5cGUpKSByZXR1cm4gaGVscGVycztcbiAgICAgIHZhciBoZWxwID0gaGVscGVyc1t0eXBlXSwgbW9kZSA9IHRoaXMuZ2V0TW9kZUF0KHBvcyk7XG4gICAgICBpZiAodHlwZW9mIG1vZGVbdHlwZV0gPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoaGVscFttb2RlW3R5cGVdXSkgZm91bmQucHVzaChoZWxwW21vZGVbdHlwZV1dKTtcbiAgICAgIH0gZWxzZSBpZiAobW9kZVt0eXBlXSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1vZGVbdHlwZV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgdmFsID0gaGVscFttb2RlW3R5cGVdW2ldXTtcbiAgICAgICAgICBpZiAodmFsKSBmb3VuZC5wdXNoKHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobW9kZS5oZWxwZXJUeXBlICYmIGhlbHBbbW9kZS5oZWxwZXJUeXBlXSkge1xuICAgICAgICBmb3VuZC5wdXNoKGhlbHBbbW9kZS5oZWxwZXJUeXBlXSk7XG4gICAgICB9IGVsc2UgaWYgKGhlbHBbbW9kZS5uYW1lXSkge1xuICAgICAgICBmb3VuZC5wdXNoKGhlbHBbbW9kZS5uYW1lXSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhlbHAuX2dsb2JhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY3VyID0gaGVscC5fZ2xvYmFsW2ldO1xuICAgICAgICBpZiAoY3VyLnByZWQobW9kZSwgdGhpcykgJiYgaW5kZXhPZihmb3VuZCwgY3VyLnZhbCkgPT0gLTEpXG4gICAgICAgICAgZm91bmQucHVzaChjdXIudmFsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9LFxuXG4gICAgZ2V0U3RhdGVBZnRlcjogZnVuY3Rpb24obGluZSwgcHJlY2lzZSkge1xuICAgICAgdmFyIGRvYyA9IHRoaXMuZG9jO1xuICAgICAgbGluZSA9IGNsaXBMaW5lKGRvYywgbGluZSA9PSBudWxsID8gZG9jLmZpcnN0ICsgZG9jLnNpemUgLSAxOiBsaW5lKTtcbiAgICAgIHJldHVybiBnZXRTdGF0ZUJlZm9yZSh0aGlzLCBsaW5lICsgMSwgcHJlY2lzZSk7XG4gICAgfSxcblxuICAgIGN1cnNvckNvb3JkczogZnVuY3Rpb24oc3RhcnQsIG1vZGUpIHtcbiAgICAgIHZhciBwb3MsIHJhbmdlID0gdGhpcy5kb2Muc2VsLnByaW1hcnkoKTtcbiAgICAgIGlmIChzdGFydCA9PSBudWxsKSBwb3MgPSByYW5nZS5oZWFkO1xuICAgICAgZWxzZSBpZiAodHlwZW9mIHN0YXJ0ID09IFwib2JqZWN0XCIpIHBvcyA9IGNsaXBQb3ModGhpcy5kb2MsIHN0YXJ0KTtcbiAgICAgIGVsc2UgcG9zID0gc3RhcnQgPyByYW5nZS5mcm9tKCkgOiByYW5nZS50bygpO1xuICAgICAgcmV0dXJuIGN1cnNvckNvb3Jkcyh0aGlzLCBwb3MsIG1vZGUgfHwgXCJwYWdlXCIpO1xuICAgIH0sXG5cbiAgICBjaGFyQ29vcmRzOiBmdW5jdGlvbihwb3MsIG1vZGUpIHtcbiAgICAgIHJldHVybiBjaGFyQ29vcmRzKHRoaXMsIGNsaXBQb3ModGhpcy5kb2MsIHBvcyksIG1vZGUgfHwgXCJwYWdlXCIpO1xuICAgIH0sXG5cbiAgICBjb29yZHNDaGFyOiBmdW5jdGlvbihjb29yZHMsIG1vZGUpIHtcbiAgICAgIGNvb3JkcyA9IGZyb21Db29yZFN5c3RlbSh0aGlzLCBjb29yZHMsIG1vZGUgfHwgXCJwYWdlXCIpO1xuICAgICAgcmV0dXJuIGNvb3Jkc0NoYXIodGhpcywgY29vcmRzLmxlZnQsIGNvb3Jkcy50b3ApO1xuICAgIH0sXG5cbiAgICBsaW5lQXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCwgbW9kZSkge1xuICAgICAgaGVpZ2h0ID0gZnJvbUNvb3JkU3lzdGVtKHRoaXMsIHt0b3A6IGhlaWdodCwgbGVmdDogMH0sIG1vZGUgfHwgXCJwYWdlXCIpLnRvcDtcbiAgICAgIHJldHVybiBsaW5lQXRIZWlnaHQodGhpcy5kb2MsIGhlaWdodCArIHRoaXMuZGlzcGxheS52aWV3T2Zmc2V0KTtcbiAgICB9LFxuICAgIGhlaWdodEF0TGluZTogZnVuY3Rpb24obGluZSwgbW9kZSkge1xuICAgICAgdmFyIGVuZCA9IGZhbHNlLCBsYXN0ID0gdGhpcy5kb2MuZmlyc3QgKyB0aGlzLmRvYy5zaXplIC0gMTtcbiAgICAgIGlmIChsaW5lIDwgdGhpcy5kb2MuZmlyc3QpIGxpbmUgPSB0aGlzLmRvYy5maXJzdDtcbiAgICAgIGVsc2UgaWYgKGxpbmUgPiBsYXN0KSB7IGxpbmUgPSBsYXN0OyBlbmQgPSB0cnVlOyB9XG4gICAgICB2YXIgbGluZU9iaiA9IGdldExpbmUodGhpcy5kb2MsIGxpbmUpO1xuICAgICAgcmV0dXJuIGludG9Db29yZFN5c3RlbSh0aGlzLCBsaW5lT2JqLCB7dG9wOiAwLCBsZWZ0OiAwfSwgbW9kZSB8fCBcInBhZ2VcIikudG9wICtcbiAgICAgICAgKGVuZCA/IHRoaXMuZG9jLmhlaWdodCAtIGhlaWdodEF0TGluZShsaW5lT2JqKSA6IDApO1xuICAgIH0sXG5cbiAgICBkZWZhdWx0VGV4dEhlaWdodDogZnVuY3Rpb24oKSB7IHJldHVybiB0ZXh0SGVpZ2h0KHRoaXMuZGlzcGxheSk7IH0sXG4gICAgZGVmYXVsdENoYXJXaWR0aDogZnVuY3Rpb24oKSB7IHJldHVybiBjaGFyV2lkdGgodGhpcy5kaXNwbGF5KTsgfSxcblxuICAgIHNldEd1dHRlck1hcmtlcjogbWV0aG9kT3AoZnVuY3Rpb24obGluZSwgZ3V0dGVySUQsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gY2hhbmdlTGluZSh0aGlzLCBsaW5lLCBcImd1dHRlclwiLCBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgIHZhciBtYXJrZXJzID0gbGluZS5ndXR0ZXJNYXJrZXJzIHx8IChsaW5lLmd1dHRlck1hcmtlcnMgPSB7fSk7XG4gICAgICAgIG1hcmtlcnNbZ3V0dGVySURdID0gdmFsdWU7XG4gICAgICAgIGlmICghdmFsdWUgJiYgaXNFbXB0eShtYXJrZXJzKSkgbGluZS5ndXR0ZXJNYXJrZXJzID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcbiAgICB9KSxcblxuICAgIGNsZWFyR3V0dGVyOiBtZXRob2RPcChmdW5jdGlvbihndXR0ZXJJRCkge1xuICAgICAgdmFyIGNtID0gdGhpcywgZG9jID0gY20uZG9jLCBpID0gZG9jLmZpcnN0O1xuICAgICAgZG9jLml0ZXIoZnVuY3Rpb24obGluZSkge1xuICAgICAgICBpZiAobGluZS5ndXR0ZXJNYXJrZXJzICYmIGxpbmUuZ3V0dGVyTWFya2Vyc1tndXR0ZXJJRF0pIHtcbiAgICAgICAgICBsaW5lLmd1dHRlck1hcmtlcnNbZ3V0dGVySURdID0gbnVsbDtcbiAgICAgICAgICByZWdMaW5lQ2hhbmdlKGNtLCBpLCBcImd1dHRlclwiKTtcbiAgICAgICAgICBpZiAoaXNFbXB0eShsaW5lLmd1dHRlck1hcmtlcnMpKSBsaW5lLmd1dHRlck1hcmtlcnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgICsraTtcbiAgICAgIH0pO1xuICAgIH0pLFxuXG4gICAgYWRkTGluZUNsYXNzOiBtZXRob2RPcChmdW5jdGlvbihoYW5kbGUsIHdoZXJlLCBjbHMpIHtcbiAgICAgIHJldHVybiBjaGFuZ2VMaW5lKHRoaXMsIGhhbmRsZSwgXCJjbGFzc1wiLCBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgIHZhciBwcm9wID0gd2hlcmUgPT0gXCJ0ZXh0XCIgPyBcInRleHRDbGFzc1wiIDogd2hlcmUgPT0gXCJiYWNrZ3JvdW5kXCIgPyBcImJnQ2xhc3NcIiA6IFwid3JhcENsYXNzXCI7XG4gICAgICAgIGlmICghbGluZVtwcm9wXSkgbGluZVtwcm9wXSA9IGNscztcbiAgICAgICAgZWxzZSBpZiAobmV3IFJlZ0V4cChcIig/Ol58XFxcXHMpXCIgKyBjbHMgKyBcIig/OiR8XFxcXHMpXCIpLnRlc3QobGluZVtwcm9wXSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgZWxzZSBsaW5lW3Byb3BdICs9IFwiIFwiICsgY2xzO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH0pLFxuXG4gICAgcmVtb3ZlTGluZUNsYXNzOiBtZXRob2RPcChmdW5jdGlvbihoYW5kbGUsIHdoZXJlLCBjbHMpIHtcbiAgICAgIHJldHVybiBjaGFuZ2VMaW5lKHRoaXMsIGhhbmRsZSwgXCJjbGFzc1wiLCBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgIHZhciBwcm9wID0gd2hlcmUgPT0gXCJ0ZXh0XCIgPyBcInRleHRDbGFzc1wiIDogd2hlcmUgPT0gXCJiYWNrZ3JvdW5kXCIgPyBcImJnQ2xhc3NcIiA6IFwid3JhcENsYXNzXCI7XG4gICAgICAgIHZhciBjdXIgPSBsaW5lW3Byb3BdO1xuICAgICAgICBpZiAoIWN1cikgcmV0dXJuIGZhbHNlO1xuICAgICAgICBlbHNlIGlmIChjbHMgPT0gbnVsbCkgbGluZVtwcm9wXSA9IG51bGw7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBmb3VuZCA9IGN1ci5tYXRjaChuZXcgUmVnRXhwKFwiKD86XnxcXFxccyspXCIgKyBjbHMgKyBcIig/OiR8XFxcXHMrKVwiKSk7XG4gICAgICAgICAgaWYgKCFmb3VuZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIHZhciBlbmQgPSBmb3VuZC5pbmRleCArIGZvdW5kWzBdLmxlbmd0aDtcbiAgICAgICAgICBsaW5lW3Byb3BdID0gY3VyLnNsaWNlKDAsIGZvdW5kLmluZGV4KSArICghZm91bmQuaW5kZXggfHwgZW5kID09IGN1ci5sZW5ndGggPyBcIlwiIDogXCIgXCIpICsgY3VyLnNsaWNlKGVuZCkgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH0pLFxuXG4gICAgYWRkTGluZVdpZGdldDogbWV0aG9kT3AoZnVuY3Rpb24oaGFuZGxlLCBub2RlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gYWRkTGluZVdpZGdldCh0aGlzLCBoYW5kbGUsIG5vZGUsIG9wdGlvbnMpO1xuICAgIH0pLFxuXG4gICAgcmVtb3ZlTGluZVdpZGdldDogZnVuY3Rpb24od2lkZ2V0KSB7IHdpZGdldC5jbGVhcigpOyB9LFxuXG4gICAgbGluZUluZm86IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIGlmICh0eXBlb2YgbGluZSA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGlmICghaXNMaW5lKHRoaXMuZG9jLCBsaW5lKSkgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBuID0gbGluZTtcbiAgICAgICAgbGluZSA9IGdldExpbmUodGhpcy5kb2MsIGxpbmUpO1xuICAgICAgICBpZiAoIWxpbmUpIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG4gPSBsaW5lTm8obGluZSk7XG4gICAgICAgIGlmIChuID09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtsaW5lOiBuLCBoYW5kbGU6IGxpbmUsIHRleHQ6IGxpbmUudGV4dCwgZ3V0dGVyTWFya2VyczogbGluZS5ndXR0ZXJNYXJrZXJzLFxuICAgICAgICAgICAgICB0ZXh0Q2xhc3M6IGxpbmUudGV4dENsYXNzLCBiZ0NsYXNzOiBsaW5lLmJnQ2xhc3MsIHdyYXBDbGFzczogbGluZS53cmFwQ2xhc3MsXG4gICAgICAgICAgICAgIHdpZGdldHM6IGxpbmUud2lkZ2V0c307XG4gICAgfSxcblxuICAgIGdldFZpZXdwb3J0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHtmcm9tOiB0aGlzLmRpc3BsYXkudmlld0Zyb20sIHRvOiB0aGlzLmRpc3BsYXkudmlld1RvfTt9LFxuXG4gICAgYWRkV2lkZ2V0OiBmdW5jdGlvbihwb3MsIG5vZGUsIHNjcm9sbCwgdmVydCwgaG9yaXopIHtcbiAgICAgIHZhciBkaXNwbGF5ID0gdGhpcy5kaXNwbGF5O1xuICAgICAgcG9zID0gY3Vyc29yQ29vcmRzKHRoaXMsIGNsaXBQb3ModGhpcy5kb2MsIHBvcykpO1xuICAgICAgdmFyIHRvcCA9IHBvcy5ib3R0b20sIGxlZnQgPSBwb3MubGVmdDtcbiAgICAgIG5vZGUuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICBkaXNwbGF5LnNpemVyLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgaWYgKHZlcnQgPT0gXCJvdmVyXCIpIHtcbiAgICAgICAgdG9wID0gcG9zLnRvcDtcbiAgICAgIH0gZWxzZSBpZiAodmVydCA9PSBcImFib3ZlXCIgfHwgdmVydCA9PSBcIm5lYXJcIikge1xuICAgICAgICB2YXIgdnNwYWNlID0gTWF0aC5tYXgoZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodCwgdGhpcy5kb2MuaGVpZ2h0KSxcbiAgICAgICAgaHNwYWNlID0gTWF0aC5tYXgoZGlzcGxheS5zaXplci5jbGllbnRXaWR0aCwgZGlzcGxheS5saW5lU3BhY2UuY2xpZW50V2lkdGgpO1xuICAgICAgICAvLyBEZWZhdWx0IHRvIHBvc2l0aW9uaW5nIGFib3ZlIChpZiBzcGVjaWZpZWQgYW5kIHBvc3NpYmxlKTsgb3RoZXJ3aXNlIGRlZmF1bHQgdG8gcG9zaXRpb25pbmcgYmVsb3dcbiAgICAgICAgaWYgKCh2ZXJ0ID09ICdhYm92ZScgfHwgcG9zLmJvdHRvbSArIG5vZGUub2Zmc2V0SGVpZ2h0ID4gdnNwYWNlKSAmJiBwb3MudG9wID4gbm9kZS5vZmZzZXRIZWlnaHQpXG4gICAgICAgICAgdG9wID0gcG9zLnRvcCAtIG5vZGUub2Zmc2V0SGVpZ2h0O1xuICAgICAgICBlbHNlIGlmIChwb3MuYm90dG9tICsgbm9kZS5vZmZzZXRIZWlnaHQgPD0gdnNwYWNlKVxuICAgICAgICAgIHRvcCA9IHBvcy5ib3R0b207XG4gICAgICAgIGlmIChsZWZ0ICsgbm9kZS5vZmZzZXRXaWR0aCA+IGhzcGFjZSlcbiAgICAgICAgICBsZWZ0ID0gaHNwYWNlIC0gbm9kZS5vZmZzZXRXaWR0aDtcbiAgICAgIH1cbiAgICAgIG5vZGUuc3R5bGUudG9wID0gdG9wICsgXCJweFwiO1xuICAgICAgbm9kZS5zdHlsZS5sZWZ0ID0gbm9kZS5zdHlsZS5yaWdodCA9IFwiXCI7XG4gICAgICBpZiAoaG9yaXogPT0gXCJyaWdodFwiKSB7XG4gICAgICAgIGxlZnQgPSBkaXNwbGF5LnNpemVyLmNsaWVudFdpZHRoIC0gbm9kZS5vZmZzZXRXaWR0aDtcbiAgICAgICAgbm9kZS5zdHlsZS5yaWdodCA9IFwiMHB4XCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaG9yaXogPT0gXCJsZWZ0XCIpIGxlZnQgPSAwO1xuICAgICAgICBlbHNlIGlmIChob3JpeiA9PSBcIm1pZGRsZVwiKSBsZWZ0ID0gKGRpc3BsYXkuc2l6ZXIuY2xpZW50V2lkdGggLSBub2RlLm9mZnNldFdpZHRoKSAvIDI7XG4gICAgICAgIG5vZGUuc3R5bGUubGVmdCA9IGxlZnQgKyBcInB4XCI7XG4gICAgICB9XG4gICAgICBpZiAoc2Nyb2xsKVxuICAgICAgICBzY3JvbGxJbnRvVmlldyh0aGlzLCBsZWZ0LCB0b3AsIGxlZnQgKyBub2RlLm9mZnNldFdpZHRoLCB0b3AgKyBub2RlLm9mZnNldEhlaWdodCk7XG4gICAgfSxcblxuICAgIHRyaWdnZXJPbktleURvd246IG1ldGhvZE9wKG9uS2V5RG93biksXG4gICAgdHJpZ2dlck9uS2V5UHJlc3M6IG1ldGhvZE9wKG9uS2V5UHJlc3MpLFxuICAgIHRyaWdnZXJPbktleVVwOiBtZXRob2RPcChvbktleVVwKSxcblxuICAgIGV4ZWNDb21tYW5kOiBmdW5jdGlvbihjbWQpIHtcbiAgICAgIGlmIChjb21tYW5kcy5oYXNPd25Qcm9wZXJ0eShjbWQpKVxuICAgICAgICByZXR1cm4gY29tbWFuZHNbY21kXSh0aGlzKTtcbiAgICB9LFxuXG4gICAgZmluZFBvc0g6IGZ1bmN0aW9uKGZyb20sIGFtb3VudCwgdW5pdCwgdmlzdWFsbHkpIHtcbiAgICAgIHZhciBkaXIgPSAxO1xuICAgICAgaWYgKGFtb3VudCA8IDApIHsgZGlyID0gLTE7IGFtb3VudCA9IC1hbW91bnQ7IH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBjdXIgPSBjbGlwUG9zKHRoaXMuZG9jLCBmcm9tKTsgaSA8IGFtb3VudDsgKytpKSB7XG4gICAgICAgIGN1ciA9IGZpbmRQb3NIKHRoaXMuZG9jLCBjdXIsIGRpciwgdW5pdCwgdmlzdWFsbHkpO1xuICAgICAgICBpZiAoY3VyLmhpdFNpZGUpIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGN1cjtcbiAgICB9LFxuXG4gICAgbW92ZUg6IG1ldGhvZE9wKGZ1bmN0aW9uKGRpciwgdW5pdCkge1xuICAgICAgdmFyIGNtID0gdGhpcztcbiAgICAgIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICBpZiAoY20uZGlzcGxheS5zaGlmdCB8fCBjbS5kb2MuZXh0ZW5kIHx8IHJhbmdlLmVtcHR5KCkpXG4gICAgICAgICAgcmV0dXJuIGZpbmRQb3NIKGNtLmRvYywgcmFuZ2UuaGVhZCwgZGlyLCB1bml0LCBjbS5vcHRpb25zLnJ0bE1vdmVWaXN1YWxseSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXR1cm4gZGlyIDwgMCA/IHJhbmdlLmZyb20oKSA6IHJhbmdlLnRvKCk7XG4gICAgICB9LCBzZWxfbW92ZSk7XG4gICAgfSksXG5cbiAgICBkZWxldGVIOiBtZXRob2RPcChmdW5jdGlvbihkaXIsIHVuaXQpIHtcbiAgICAgIHZhciBzZWwgPSB0aGlzLmRvYy5zZWwsIGRvYyA9IHRoaXMuZG9jO1xuICAgICAgaWYgKHNlbC5zb21ldGhpbmdTZWxlY3RlZCgpKVxuICAgICAgICBkb2MucmVwbGFjZVNlbGVjdGlvbihcIlwiLCBudWxsLCBcIitkZWxldGVcIik7XG4gICAgICBlbHNlXG4gICAgICAgIGRlbGV0ZU5lYXJTZWxlY3Rpb24odGhpcywgZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgICB2YXIgb3RoZXIgPSBmaW5kUG9zSChkb2MsIHJhbmdlLmhlYWQsIGRpciwgdW5pdCwgZmFsc2UpO1xuICAgICAgICAgIHJldHVybiBkaXIgPCAwID8ge2Zyb206IG90aGVyLCB0bzogcmFuZ2UuaGVhZH0gOiB7ZnJvbTogcmFuZ2UuaGVhZCwgdG86IG90aGVyfTtcbiAgICAgICAgfSk7XG4gICAgfSksXG5cbiAgICBmaW5kUG9zVjogZnVuY3Rpb24oZnJvbSwgYW1vdW50LCB1bml0LCBnb2FsQ29sdW1uKSB7XG4gICAgICB2YXIgZGlyID0gMSwgeCA9IGdvYWxDb2x1bW47XG4gICAgICBpZiAoYW1vdW50IDwgMCkgeyBkaXIgPSAtMTsgYW1vdW50ID0gLWFtb3VudDsgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGN1ciA9IGNsaXBQb3ModGhpcy5kb2MsIGZyb20pOyBpIDwgYW1vdW50OyArK2kpIHtcbiAgICAgICAgdmFyIGNvb3JkcyA9IGN1cnNvckNvb3Jkcyh0aGlzLCBjdXIsIFwiZGl2XCIpO1xuICAgICAgICBpZiAoeCA9PSBudWxsKSB4ID0gY29vcmRzLmxlZnQ7XG4gICAgICAgIGVsc2UgY29vcmRzLmxlZnQgPSB4O1xuICAgICAgICBjdXIgPSBmaW5kUG9zVih0aGlzLCBjb29yZHMsIGRpciwgdW5pdCk7XG4gICAgICAgIGlmIChjdXIuaGl0U2lkZSkgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VyO1xuICAgIH0sXG5cbiAgICBtb3ZlVjogbWV0aG9kT3AoZnVuY3Rpb24oZGlyLCB1bml0KSB7XG4gICAgICB2YXIgY20gPSB0aGlzLCBkb2MgPSB0aGlzLmRvYywgZ29hbHMgPSBbXTtcbiAgICAgIHZhciBjb2xsYXBzZSA9ICFjbS5kaXNwbGF5LnNoaWZ0ICYmICFkb2MuZXh0ZW5kICYmIGRvYy5zZWwuc29tZXRoaW5nU2VsZWN0ZWQoKTtcbiAgICAgIGRvYy5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgaWYgKGNvbGxhcHNlKVxuICAgICAgICAgIHJldHVybiBkaXIgPCAwID8gcmFuZ2UuZnJvbSgpIDogcmFuZ2UudG8oKTtcbiAgICAgICAgdmFyIGhlYWRQb3MgPSBjdXJzb3JDb29yZHMoY20sIHJhbmdlLmhlYWQsIFwiZGl2XCIpO1xuICAgICAgICBpZiAocmFuZ2UuZ29hbENvbHVtbiAhPSBudWxsKSBoZWFkUG9zLmxlZnQgPSByYW5nZS5nb2FsQ29sdW1uO1xuICAgICAgICBnb2Fscy5wdXNoKGhlYWRQb3MubGVmdCk7XG4gICAgICAgIHZhciBwb3MgPSBmaW5kUG9zVihjbSwgaGVhZFBvcywgZGlyLCB1bml0KTtcbiAgICAgICAgaWYgKHVuaXQgPT0gXCJwYWdlXCIgJiYgcmFuZ2UgPT0gZG9jLnNlbC5wcmltYXJ5KCkpXG4gICAgICAgICAgYWRkVG9TY3JvbGxQb3MoY20sIG51bGwsIGNoYXJDb29yZHMoY20sIHBvcywgXCJkaXZcIikudG9wIC0gaGVhZFBvcy50b3ApO1xuICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgfSwgc2VsX21vdmUpO1xuICAgICAgaWYgKGdvYWxzLmxlbmd0aCkgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2Muc2VsLnJhbmdlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgZG9jLnNlbC5yYW5nZXNbaV0uZ29hbENvbHVtbiA9IGdvYWxzW2ldO1xuICAgIH0pLFxuXG4gICAgdG9nZ2xlT3ZlcndyaXRlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgPT0gdGhpcy5zdGF0ZS5vdmVyd3JpdGUpIHJldHVybjtcbiAgICAgIGlmICh0aGlzLnN0YXRlLm92ZXJ3cml0ZSA9ICF0aGlzLnN0YXRlLm92ZXJ3cml0ZSlcbiAgICAgICAgYWRkQ2xhc3ModGhpcy5kaXNwbGF5LmN1cnNvckRpdiwgXCJDb2RlTWlycm9yLW92ZXJ3cml0ZVwiKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcm1DbGFzcyh0aGlzLmRpc3BsYXkuY3Vyc29yRGl2LCBcIkNvZGVNaXJyb3Itb3ZlcndyaXRlXCIpO1xuXG4gICAgICBzaWduYWwodGhpcywgXCJvdmVyd3JpdGVUb2dnbGVcIiwgdGhpcywgdGhpcy5zdGF0ZS5vdmVyd3JpdGUpO1xuICAgIH0sXG4gICAgaGFzRm9jdXM6IGZ1bmN0aW9uKCkgeyByZXR1cm4gYWN0aXZlRWx0KCkgPT0gdGhpcy5kaXNwbGF5LmlucHV0OyB9LFxuXG4gICAgc2Nyb2xsVG86IG1ldGhvZE9wKGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIGlmICh4ICE9IG51bGwgfHwgeSAhPSBudWxsKSByZXNvbHZlU2Nyb2xsVG9Qb3ModGhpcyk7XG4gICAgICBpZiAoeCAhPSBudWxsKSB0aGlzLmN1ck9wLnNjcm9sbExlZnQgPSB4O1xuICAgICAgaWYgKHkgIT0gbnVsbCkgdGhpcy5jdXJPcC5zY3JvbGxUb3AgPSB5O1xuICAgIH0pLFxuICAgIGdldFNjcm9sbEluZm86IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNjcm9sbGVyID0gdGhpcy5kaXNwbGF5LnNjcm9sbGVyLCBjbyA9IHNjcm9sbGVyQ3V0T2ZmO1xuICAgICAgcmV0dXJuIHtsZWZ0OiBzY3JvbGxlci5zY3JvbGxMZWZ0LCB0b3A6IHNjcm9sbGVyLnNjcm9sbFRvcCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBzY3JvbGxlci5zY3JvbGxIZWlnaHQgLSBjbywgd2lkdGg6IHNjcm9sbGVyLnNjcm9sbFdpZHRoIC0gY28sXG4gICAgICAgICAgICAgIGNsaWVudEhlaWdodDogc2Nyb2xsZXIuY2xpZW50SGVpZ2h0IC0gY28sIGNsaWVudFdpZHRoOiBzY3JvbGxlci5jbGllbnRXaWR0aCAtIGNvfTtcbiAgICB9LFxuXG4gICAgc2Nyb2xsSW50b1ZpZXc6IG1ldGhvZE9wKGZ1bmN0aW9uKHJhbmdlLCBtYXJnaW4pIHtcbiAgICAgIGlmIChyYW5nZSA9PSBudWxsKSB7XG4gICAgICAgIHJhbmdlID0ge2Zyb206IHRoaXMuZG9jLnNlbC5wcmltYXJ5KCkuaGVhZCwgdG86IG51bGx9O1xuICAgICAgICBpZiAobWFyZ2luID09IG51bGwpIG1hcmdpbiA9IHRoaXMub3B0aW9ucy5jdXJzb3JTY3JvbGxNYXJnaW47XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiByYW5nZSA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJhbmdlID0ge2Zyb206IFBvcyhyYW5nZSwgMCksIHRvOiBudWxsfTtcbiAgICAgIH0gZWxzZSBpZiAocmFuZ2UuZnJvbSA9PSBudWxsKSB7XG4gICAgICAgIHJhbmdlID0ge2Zyb206IHJhbmdlLCB0bzogbnVsbH07XG4gICAgICB9XG4gICAgICBpZiAoIXJhbmdlLnRvKSByYW5nZS50byA9IHJhbmdlLmZyb207XG4gICAgICByYW5nZS5tYXJnaW4gPSBtYXJnaW4gfHwgMDtcblxuICAgICAgaWYgKHJhbmdlLmZyb20ubGluZSAhPSBudWxsKSB7XG4gICAgICAgIHJlc29sdmVTY3JvbGxUb1Bvcyh0aGlzKTtcbiAgICAgICAgdGhpcy5jdXJPcC5zY3JvbGxUb1BvcyA9IHJhbmdlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNQb3MgPSBjYWxjdWxhdGVTY3JvbGxQb3ModGhpcywgTWF0aC5taW4ocmFuZ2UuZnJvbS5sZWZ0LCByYW5nZS50by5sZWZ0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4ocmFuZ2UuZnJvbS50b3AsIHJhbmdlLnRvLnRvcCkgLSByYW5nZS5tYXJnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KHJhbmdlLmZyb20ucmlnaHQsIHJhbmdlLnRvLnJpZ2h0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgocmFuZ2UuZnJvbS5ib3R0b20sIHJhbmdlLnRvLmJvdHRvbSkgKyByYW5nZS5tYXJnaW4pO1xuICAgICAgICB0aGlzLnNjcm9sbFRvKHNQb3Muc2Nyb2xsTGVmdCwgc1Bvcy5zY3JvbGxUb3ApO1xuICAgICAgfVxuICAgIH0pLFxuXG4gICAgc2V0U2l6ZTogbWV0aG9kT3AoZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgZnVuY3Rpb24gaW50ZXJwcmV0KHZhbCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PSBcIm51bWJlclwiIHx8IC9eXFxkKyQvLnRlc3QoU3RyaW5nKHZhbCkpID8gdmFsICsgXCJweFwiIDogdmFsO1xuICAgICAgfVxuICAgICAgaWYgKHdpZHRoICE9IG51bGwpIHRoaXMuZGlzcGxheS53cmFwcGVyLnN0eWxlLndpZHRoID0gaW50ZXJwcmV0KHdpZHRoKTtcbiAgICAgIGlmIChoZWlnaHQgIT0gbnVsbCkgdGhpcy5kaXNwbGF5LndyYXBwZXIuc3R5bGUuaGVpZ2h0ID0gaW50ZXJwcmV0KGhlaWdodCk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxpbmVXcmFwcGluZykgY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZSh0aGlzKTtcbiAgICAgIHRoaXMuY3VyT3AuZm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgc2lnbmFsKHRoaXMsIFwicmVmcmVzaFwiLCB0aGlzKTtcbiAgICB9KSxcblxuICAgIG9wZXJhdGlvbjogZnVuY3Rpb24oZil7cmV0dXJuIHJ1bkluT3AodGhpcywgZik7fSxcblxuICAgIHJlZnJlc2g6IG1ldGhvZE9wKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9sZEhlaWdodCA9IHRoaXMuZGlzcGxheS5jYWNoZWRUZXh0SGVpZ2h0O1xuICAgICAgcmVnQ2hhbmdlKHRoaXMpO1xuICAgICAgdGhpcy5jdXJPcC5mb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgICBjbGVhckNhY2hlcyh0aGlzKTtcbiAgICAgIHRoaXMuc2Nyb2xsVG8odGhpcy5kb2Muc2Nyb2xsTGVmdCwgdGhpcy5kb2Muc2Nyb2xsVG9wKTtcbiAgICAgIHVwZGF0ZUd1dHRlclNwYWNlKHRoaXMpO1xuICAgICAgaWYgKG9sZEhlaWdodCA9PSBudWxsIHx8IE1hdGguYWJzKG9sZEhlaWdodCAtIHRleHRIZWlnaHQodGhpcy5kaXNwbGF5KSkgPiAuNSlcbiAgICAgICAgZXN0aW1hdGVMaW5lSGVpZ2h0cyh0aGlzKTtcbiAgICAgIHNpZ25hbCh0aGlzLCBcInJlZnJlc2hcIiwgdGhpcyk7XG4gICAgfSksXG5cbiAgICBzd2FwRG9jOiBtZXRob2RPcChmdW5jdGlvbihkb2MpIHtcbiAgICAgIHZhciBvbGQgPSB0aGlzLmRvYztcbiAgICAgIG9sZC5jbSA9IG51bGw7XG4gICAgICBhdHRhY2hEb2ModGhpcywgZG9jKTtcbiAgICAgIGNsZWFyQ2FjaGVzKHRoaXMpO1xuICAgICAgcmVzZXRJbnB1dCh0aGlzKTtcbiAgICAgIHRoaXMuc2Nyb2xsVG8oZG9jLnNjcm9sbExlZnQsIGRvYy5zY3JvbGxUb3ApO1xuICAgICAgc2lnbmFsTGF0ZXIodGhpcywgXCJzd2FwRG9jXCIsIHRoaXMsIG9sZCk7XG4gICAgICByZXR1cm4gb2xkO1xuICAgIH0pLFxuXG4gICAgZ2V0SW5wdXRGaWVsZDogZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXNwbGF5LmlucHV0O30sXG4gICAgZ2V0V3JhcHBlckVsZW1lbnQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGlzcGxheS53cmFwcGVyO30sXG4gICAgZ2V0U2Nyb2xsZXJFbGVtZW50OiBmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpc3BsYXkuc2Nyb2xsZXI7fSxcbiAgICBnZXRHdXR0ZXJFbGVtZW50OiBmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpc3BsYXkuZ3V0dGVyczt9XG4gIH07XG4gIGV2ZW50TWl4aW4oQ29kZU1pcnJvcik7XG5cbiAgLy8gT1BUSU9OIERFRkFVTFRTXG5cbiAgLy8gVGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICB2YXIgZGVmYXVsdHMgPSBDb2RlTWlycm9yLmRlZmF1bHRzID0ge307XG4gIC8vIEZ1bmN0aW9ucyB0byBydW4gd2hlbiBvcHRpb25zIGFyZSBjaGFuZ2VkLlxuICB2YXIgb3B0aW9uSGFuZGxlcnMgPSBDb2RlTWlycm9yLm9wdGlvbkhhbmRsZXJzID0ge307XG5cbiAgZnVuY3Rpb24gb3B0aW9uKG5hbWUsIGRlZmx0LCBoYW5kbGUsIG5vdE9uSW5pdCkge1xuICAgIENvZGVNaXJyb3IuZGVmYXVsdHNbbmFtZV0gPSBkZWZsdDtcbiAgICBpZiAoaGFuZGxlKSBvcHRpb25IYW5kbGVyc1tuYW1lXSA9XG4gICAgICBub3RPbkluaXQgPyBmdW5jdGlvbihjbSwgdmFsLCBvbGQpIHtpZiAob2xkICE9IEluaXQpIGhhbmRsZShjbSwgdmFsLCBvbGQpO30gOiBoYW5kbGU7XG4gIH1cblxuICAvLyBQYXNzZWQgdG8gb3B0aW9uIGhhbmRsZXJzIHdoZW4gdGhlcmUgaXMgbm8gb2xkIHZhbHVlLlxuICB2YXIgSW5pdCA9IENvZGVNaXJyb3IuSW5pdCA9IHt0b1N0cmluZzogZnVuY3Rpb24oKXtyZXR1cm4gXCJDb2RlTWlycm9yLkluaXRcIjt9fTtcblxuICAvLyBUaGVzZSB0d28gYXJlLCBvbiBpbml0LCBjYWxsZWQgZnJvbSB0aGUgY29uc3RydWN0b3IgYmVjYXVzZSB0aGV5XG4gIC8vIGhhdmUgdG8gYmUgaW5pdGlhbGl6ZWQgYmVmb3JlIHRoZSBlZGl0b3IgY2FuIHN0YXJ0IGF0IGFsbC5cbiAgb3B0aW9uKFwidmFsdWVcIiwgXCJcIiwgZnVuY3Rpb24oY20sIHZhbCkge1xuICAgIGNtLnNldFZhbHVlKHZhbCk7XG4gIH0sIHRydWUpO1xuICBvcHRpb24oXCJtb2RlXCIsIG51bGwsIGZ1bmN0aW9uKGNtLCB2YWwpIHtcbiAgICBjbS5kb2MubW9kZU9wdGlvbiA9IHZhbDtcbiAgICBsb2FkTW9kZShjbSk7XG4gIH0sIHRydWUpO1xuXG4gIG9wdGlvbihcImluZGVudFVuaXRcIiwgMiwgbG9hZE1vZGUsIHRydWUpO1xuICBvcHRpb24oXCJpbmRlbnRXaXRoVGFic1wiLCBmYWxzZSk7XG4gIG9wdGlvbihcInNtYXJ0SW5kZW50XCIsIHRydWUpO1xuICBvcHRpb24oXCJ0YWJTaXplXCIsIDQsIGZ1bmN0aW9uKGNtKSB7XG4gICAgcmVzZXRNb2RlU3RhdGUoY20pO1xuICAgIGNsZWFyQ2FjaGVzKGNtKTtcbiAgICByZWdDaGFuZ2UoY20pO1xuICB9LCB0cnVlKTtcbiAgb3B0aW9uKFwic3BlY2lhbENoYXJzXCIsIC9bXFx0XFx1MDAwMC1cXHUwMDE5XFx1MDBhZFxcdTIwMGJcXHUyMDI4XFx1MjAyOVxcdWZlZmZdL2csIGZ1bmN0aW9uKGNtLCB2YWwpIHtcbiAgICBjbS5vcHRpb25zLnNwZWNpYWxDaGFycyA9IG5ldyBSZWdFeHAodmFsLnNvdXJjZSArICh2YWwudGVzdChcIlxcdFwiKSA/IFwiXCIgOiBcInxcXHRcIiksIFwiZ1wiKTtcbiAgICBjbS5yZWZyZXNoKCk7XG4gIH0sIHRydWUpO1xuICBvcHRpb24oXCJzcGVjaWFsQ2hhclBsYWNlaG9sZGVyXCIsIGRlZmF1bHRTcGVjaWFsQ2hhclBsYWNlaG9sZGVyLCBmdW5jdGlvbihjbSkge2NtLnJlZnJlc2goKTt9LCB0cnVlKTtcbiAgb3B0aW9uKFwiZWxlY3RyaWNDaGFyc1wiLCB0cnVlKTtcbiAgb3B0aW9uKFwicnRsTW92ZVZpc3VhbGx5XCIsICF3aW5kb3dzKTtcbiAgb3B0aW9uKFwid2hvbGVMaW5lVXBkYXRlQmVmb3JlXCIsIHRydWUpO1xuXG4gIG9wdGlvbihcInRoZW1lXCIsIFwiZGVmYXVsdFwiLCBmdW5jdGlvbihjbSkge1xuICAgIHRoZW1lQ2hhbmdlZChjbSk7XG4gICAgZ3V0dGVyc0NoYW5nZWQoY20pO1xuICB9LCB0cnVlKTtcbiAgb3B0aW9uKFwia2V5TWFwXCIsIFwiZGVmYXVsdFwiLCBrZXlNYXBDaGFuZ2VkKTtcbiAgb3B0aW9uKFwiZXh0cmFLZXlzXCIsIG51bGwpO1xuXG4gIG9wdGlvbihcImxpbmVXcmFwcGluZ1wiLCBmYWxzZSwgd3JhcHBpbmdDaGFuZ2VkLCB0cnVlKTtcbiAgb3B0aW9uKFwiZ3V0dGVyc1wiLCBbXSwgZnVuY3Rpb24oY20pIHtcbiAgICBzZXRHdXR0ZXJzRm9yTGluZU51bWJlcnMoY20ub3B0aW9ucyk7XG4gICAgZ3V0dGVyc0NoYW5nZWQoY20pO1xuICB9LCB0cnVlKTtcbiAgb3B0aW9uKFwiZml4ZWRHdXR0ZXJcIiwgdHJ1ZSwgZnVuY3Rpb24oY20sIHZhbCkge1xuICAgIGNtLmRpc3BsYXkuZ3V0dGVycy5zdHlsZS5sZWZ0ID0gdmFsID8gY29tcGVuc2F0ZUZvckhTY3JvbGwoY20uZGlzcGxheSkgKyBcInB4XCIgOiBcIjBcIjtcbiAgICBjbS5yZWZyZXNoKCk7XG4gIH0sIHRydWUpO1xuICBvcHRpb24oXCJjb3Zlckd1dHRlck5leHRUb1Njcm9sbGJhclwiLCBmYWxzZSwgdXBkYXRlU2Nyb2xsYmFycywgdHJ1ZSk7XG4gIG9wdGlvbihcImxpbmVOdW1iZXJzXCIsIGZhbHNlLCBmdW5jdGlvbihjbSkge1xuICAgIHNldEd1dHRlcnNGb3JMaW5lTnVtYmVycyhjbS5vcHRpb25zKTtcbiAgICBndXR0ZXJzQ2hhbmdlZChjbSk7XG4gIH0sIHRydWUpO1xuICBvcHRpb24oXCJmaXJzdExpbmVOdW1iZXJcIiwgMSwgZ3V0dGVyc0NoYW5nZWQsIHRydWUpO1xuICBvcHRpb24oXCJsaW5lTnVtYmVyRm9ybWF0dGVyXCIsIGZ1bmN0aW9uKGludGVnZXIpIHtyZXR1cm4gaW50ZWdlcjt9LCBndXR0ZXJzQ2hhbmdlZCwgdHJ1ZSk7XG4gIG9wdGlvbihcInNob3dDdXJzb3JXaGVuU2VsZWN0aW5nXCIsIGZhbHNlLCB1cGRhdGVTZWxlY3Rpb24sIHRydWUpO1xuXG4gIG9wdGlvbihcInJlc2V0U2VsZWN0aW9uT25Db250ZXh0TWVudVwiLCB0cnVlKTtcblxuICBvcHRpb24oXCJyZWFkT25seVwiLCBmYWxzZSwgZnVuY3Rpb24oY20sIHZhbCkge1xuICAgIGlmICh2YWwgPT0gXCJub2N1cnNvclwiKSB7XG4gICAgICBvbkJsdXIoY20pO1xuICAgICAgY20uZGlzcGxheS5pbnB1dC5ibHVyKCk7XG4gICAgICBjbS5kaXNwbGF5LmRpc2FibGVkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY20uZGlzcGxheS5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgaWYgKCF2YWwpIHJlc2V0SW5wdXQoY20pO1xuICAgIH1cbiAgfSk7XG4gIG9wdGlvbihcImRpc2FibGVJbnB1dFwiLCBmYWxzZSwgZnVuY3Rpb24oY20sIHZhbCkge2lmICghdmFsKSByZXNldElucHV0KGNtKTt9LCB0cnVlKTtcbiAgb3B0aW9uKFwiZHJhZ0Ryb3BcIiwgdHJ1ZSk7XG5cbiAgb3B0aW9uKFwiY3Vyc29yQmxpbmtSYXRlXCIsIDUzMCk7XG4gIG9wdGlvbihcImN1cnNvclNjcm9sbE1hcmdpblwiLCAwKTtcbiAgb3B0aW9uKFwiY3Vyc29ySGVpZ2h0XCIsIDEpO1xuICBvcHRpb24oXCJ3b3JrVGltZVwiLCAxMDApO1xuICBvcHRpb24oXCJ3b3JrRGVsYXlcIiwgMTAwKTtcbiAgb3B0aW9uKFwiZmxhdHRlblNwYW5zXCIsIHRydWUsIHJlc2V0TW9kZVN0YXRlLCB0cnVlKTtcbiAgb3B0aW9uKFwiYWRkTW9kZUNsYXNzXCIsIGZhbHNlLCByZXNldE1vZGVTdGF0ZSwgdHJ1ZSk7XG4gIG9wdGlvbihcInBvbGxJbnRlcnZhbFwiLCAxMDApO1xuICBvcHRpb24oXCJ1bmRvRGVwdGhcIiwgMjAwLCBmdW5jdGlvbihjbSwgdmFsKXtjbS5kb2MuaGlzdG9yeS51bmRvRGVwdGggPSB2YWw7fSk7XG4gIG9wdGlvbihcImhpc3RvcnlFdmVudERlbGF5XCIsIDEyNTApO1xuICBvcHRpb24oXCJ2aWV3cG9ydE1hcmdpblwiLCAxMCwgZnVuY3Rpb24oY20pe2NtLnJlZnJlc2goKTt9LCB0cnVlKTtcbiAgb3B0aW9uKFwibWF4SGlnaGxpZ2h0TGVuZ3RoXCIsIDEwMDAwLCByZXNldE1vZGVTdGF0ZSwgdHJ1ZSk7XG4gIG9wdGlvbihcIm1vdmVJbnB1dFdpdGhDdXJzb3JcIiwgdHJ1ZSwgZnVuY3Rpb24oY20sIHZhbCkge1xuICAgIGlmICghdmFsKSBjbS5kaXNwbGF5LmlucHV0RGl2LnN0eWxlLnRvcCA9IGNtLmRpc3BsYXkuaW5wdXREaXYuc3R5bGUubGVmdCA9IDA7XG4gIH0pO1xuXG4gIG9wdGlvbihcInRhYmluZGV4XCIsIG51bGwsIGZ1bmN0aW9uKGNtLCB2YWwpIHtcbiAgICBjbS5kaXNwbGF5LmlucHV0LnRhYkluZGV4ID0gdmFsIHx8IFwiXCI7XG4gIH0pO1xuICBvcHRpb24oXCJhdXRvZm9jdXNcIiwgbnVsbCk7XG5cbiAgLy8gTU9ERSBERUZJTklUSU9OIEFORCBRVUVSWUlOR1xuXG4gIC8vIEtub3duIG1vZGVzLCBieSBuYW1lIGFuZCBieSBNSU1FXG4gIHZhciBtb2RlcyA9IENvZGVNaXJyb3IubW9kZXMgPSB7fSwgbWltZU1vZGVzID0gQ29kZU1pcnJvci5taW1lTW9kZXMgPSB7fTtcblxuICAvLyBFeHRyYSBhcmd1bWVudHMgYXJlIHN0b3JlZCBhcyB0aGUgbW9kZSdzIGRlcGVuZGVuY2llcywgd2hpY2ggaXNcbiAgLy8gdXNlZCBieSAobGVnYWN5KSBtZWNoYW5pc21zIGxpa2UgbG9hZG1vZGUuanMgdG8gYXV0b21hdGljYWxseVxuICAvLyBsb2FkIGEgbW9kZS4gKFByZWZlcnJlZCBtZWNoYW5pc20gaXMgdGhlIHJlcXVpcmUvZGVmaW5lIGNhbGxzLilcbiAgQ29kZU1pcnJvci5kZWZpbmVNb2RlID0gZnVuY3Rpb24obmFtZSwgbW9kZSkge1xuICAgIGlmICghQ29kZU1pcnJvci5kZWZhdWx0cy5tb2RlICYmIG5hbWUgIT0gXCJudWxsXCIpIENvZGVNaXJyb3IuZGVmYXVsdHMubW9kZSA9IG5hbWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICBtb2RlLmRlcGVuZGVuY2llcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyArK2kpIG1vZGUuZGVwZW5kZW5jaWVzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG4gICAgbW9kZXNbbmFtZV0gPSBtb2RlO1xuICB9O1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRSA9IGZ1bmN0aW9uKG1pbWUsIHNwZWMpIHtcbiAgICBtaW1lTW9kZXNbbWltZV0gPSBzcGVjO1xuICB9O1xuXG4gIC8vIEdpdmVuIGEgTUlNRSB0eXBlLCBhIHtuYW1lLCAuLi5vcHRpb25zfSBjb25maWcgb2JqZWN0LCBvciBhIG5hbWVcbiAgLy8gc3RyaW5nLCByZXR1cm4gYSBtb2RlIGNvbmZpZyBvYmplY3QuXG4gIENvZGVNaXJyb3IucmVzb2x2ZU1vZGUgPSBmdW5jdGlvbihzcGVjKSB7XG4gICAgaWYgKHR5cGVvZiBzcGVjID09IFwic3RyaW5nXCIgJiYgbWltZU1vZGVzLmhhc093blByb3BlcnR5KHNwZWMpKSB7XG4gICAgICBzcGVjID0gbWltZU1vZGVzW3NwZWNdO1xuICAgIH0gZWxzZSBpZiAoc3BlYyAmJiB0eXBlb2Ygc3BlYy5uYW1lID09IFwic3RyaW5nXCIgJiYgbWltZU1vZGVzLmhhc093blByb3BlcnR5KHNwZWMubmFtZSkpIHtcbiAgICAgIHZhciBmb3VuZCA9IG1pbWVNb2Rlc1tzcGVjLm5hbWVdO1xuICAgICAgaWYgKHR5cGVvZiBmb3VuZCA9PSBcInN0cmluZ1wiKSBmb3VuZCA9IHtuYW1lOiBmb3VuZH07XG4gICAgICBzcGVjID0gY3JlYXRlT2JqKGZvdW5kLCBzcGVjKTtcbiAgICAgIHNwZWMubmFtZSA9IGZvdW5kLm5hbWU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc3BlYyA9PSBcInN0cmluZ1wiICYmIC9eW1xcd1xcLV0rXFwvW1xcd1xcLV0rXFwreG1sJC8udGVzdChzcGVjKSkge1xuICAgICAgcmV0dXJuIENvZGVNaXJyb3IucmVzb2x2ZU1vZGUoXCJhcHBsaWNhdGlvbi94bWxcIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc3BlYyA9PSBcInN0cmluZ1wiKSByZXR1cm4ge25hbWU6IHNwZWN9O1xuICAgIGVsc2UgcmV0dXJuIHNwZWMgfHwge25hbWU6IFwibnVsbFwifTtcbiAgfTtcblxuICAvLyBHaXZlbiBhIG1vZGUgc3BlYyAoYW55dGhpbmcgdGhhdCByZXNvbHZlTW9kZSBhY2NlcHRzKSwgZmluZCBhbmRcbiAgLy8gaW5pdGlhbGl6ZSBhbiBhY3R1YWwgbW9kZSBvYmplY3QuXG4gIENvZGVNaXJyb3IuZ2V0TW9kZSA9IGZ1bmN0aW9uKG9wdGlvbnMsIHNwZWMpIHtcbiAgICB2YXIgc3BlYyA9IENvZGVNaXJyb3IucmVzb2x2ZU1vZGUoc3BlYyk7XG4gICAgdmFyIG1mYWN0b3J5ID0gbW9kZXNbc3BlYy5uYW1lXTtcbiAgICBpZiAoIW1mYWN0b3J5KSByZXR1cm4gQ29kZU1pcnJvci5nZXRNb2RlKG9wdGlvbnMsIFwidGV4dC9wbGFpblwiKTtcbiAgICB2YXIgbW9kZU9iaiA9IG1mYWN0b3J5KG9wdGlvbnMsIHNwZWMpO1xuICAgIGlmIChtb2RlRXh0ZW5zaW9ucy5oYXNPd25Qcm9wZXJ0eShzcGVjLm5hbWUpKSB7XG4gICAgICB2YXIgZXh0cyA9IG1vZGVFeHRlbnNpb25zW3NwZWMubmFtZV07XG4gICAgICBmb3IgKHZhciBwcm9wIGluIGV4dHMpIHtcbiAgICAgICAgaWYgKCFleHRzLmhhc093blByb3BlcnR5KHByb3ApKSBjb250aW51ZTtcbiAgICAgICAgaWYgKG1vZGVPYmouaGFzT3duUHJvcGVydHkocHJvcCkpIG1vZGVPYmpbXCJfXCIgKyBwcm9wXSA9IG1vZGVPYmpbcHJvcF07XG4gICAgICAgIG1vZGVPYmpbcHJvcF0gPSBleHRzW3Byb3BdO1xuICAgICAgfVxuICAgIH1cbiAgICBtb2RlT2JqLm5hbWUgPSBzcGVjLm5hbWU7XG4gICAgaWYgKHNwZWMuaGVscGVyVHlwZSkgbW9kZU9iai5oZWxwZXJUeXBlID0gc3BlYy5oZWxwZXJUeXBlO1xuICAgIGlmIChzcGVjLm1vZGVQcm9wcykgZm9yICh2YXIgcHJvcCBpbiBzcGVjLm1vZGVQcm9wcylcbiAgICAgIG1vZGVPYmpbcHJvcF0gPSBzcGVjLm1vZGVQcm9wc1twcm9wXTtcblxuICAgIHJldHVybiBtb2RlT2JqO1xuICB9O1xuXG4gIC8vIE1pbmltYWwgZGVmYXVsdCBtb2RlLlxuICBDb2RlTWlycm9yLmRlZmluZU1vZGUoXCJudWxsXCIsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7dG9rZW46IGZ1bmN0aW9uKHN0cmVhbSkge3N0cmVhbS5za2lwVG9FbmQoKTt9fTtcbiAgfSk7XG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQvcGxhaW5cIiwgXCJudWxsXCIpO1xuXG4gIC8vIFRoaXMgY2FuIGJlIHVzZWQgdG8gYXR0YWNoIHByb3BlcnRpZXMgdG8gbW9kZSBvYmplY3RzIGZyb21cbiAgLy8gb3V0c2lkZSB0aGUgYWN0dWFsIG1vZGUgZGVmaW5pdGlvbi5cbiAgdmFyIG1vZGVFeHRlbnNpb25zID0gQ29kZU1pcnJvci5tb2RlRXh0ZW5zaW9ucyA9IHt9O1xuICBDb2RlTWlycm9yLmV4dGVuZE1vZGUgPSBmdW5jdGlvbihtb2RlLCBwcm9wZXJ0aWVzKSB7XG4gICAgdmFyIGV4dHMgPSBtb2RlRXh0ZW5zaW9ucy5oYXNPd25Qcm9wZXJ0eShtb2RlKSA/IG1vZGVFeHRlbnNpb25zW21vZGVdIDogKG1vZGVFeHRlbnNpb25zW21vZGVdID0ge30pO1xuICAgIGNvcHlPYmoocHJvcGVydGllcywgZXh0cyk7XG4gIH07XG5cbiAgLy8gRVhURU5TSU9OU1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lRXh0ZW5zaW9uID0gZnVuY3Rpb24obmFtZSwgZnVuYykge1xuICAgIENvZGVNaXJyb3IucHJvdG90eXBlW25hbWVdID0gZnVuYztcbiAgfTtcbiAgQ29kZU1pcnJvci5kZWZpbmVEb2NFeHRlbnNpb24gPSBmdW5jdGlvbihuYW1lLCBmdW5jKSB7XG4gICAgRG9jLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmM7XG4gIH07XG4gIENvZGVNaXJyb3IuZGVmaW5lT3B0aW9uID0gb3B0aW9uO1xuXG4gIHZhciBpbml0SG9va3MgPSBbXTtcbiAgQ29kZU1pcnJvci5kZWZpbmVJbml0SG9vayA9IGZ1bmN0aW9uKGYpIHtpbml0SG9va3MucHVzaChmKTt9O1xuXG4gIHZhciBoZWxwZXJzID0gQ29kZU1pcnJvci5oZWxwZXJzID0ge307XG4gIENvZGVNaXJyb3IucmVnaXN0ZXJIZWxwZXIgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCB2YWx1ZSkge1xuICAgIGlmICghaGVscGVycy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgaGVscGVyc1t0eXBlXSA9IENvZGVNaXJyb3JbdHlwZV0gPSB7X2dsb2JhbDogW119O1xuICAgIGhlbHBlcnNbdHlwZV1bbmFtZV0gPSB2YWx1ZTtcbiAgfTtcbiAgQ29kZU1pcnJvci5yZWdpc3Rlckdsb2JhbEhlbHBlciA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIHByZWRpY2F0ZSwgdmFsdWUpIHtcbiAgICBDb2RlTWlycm9yLnJlZ2lzdGVySGVscGVyKHR5cGUsIG5hbWUsIHZhbHVlKTtcbiAgICBoZWxwZXJzW3R5cGVdLl9nbG9iYWwucHVzaCh7cHJlZDogcHJlZGljYXRlLCB2YWw6IHZhbHVlfSk7XG4gIH07XG5cbiAgLy8gTU9ERSBTVEFURSBIQU5ETElOR1xuXG4gIC8vIFV0aWxpdHkgZnVuY3Rpb25zIGZvciB3b3JraW5nIHdpdGggc3RhdGUuIEV4cG9ydGVkIGJlY2F1c2UgbmVzdGVkXG4gIC8vIG1vZGVzIG5lZWQgdG8gZG8gdGhpcyBmb3IgdGhlaXIgaW5uZXIgbW9kZXMuXG5cbiAgdmFyIGNvcHlTdGF0ZSA9IENvZGVNaXJyb3IuY29weVN0YXRlID0gZnVuY3Rpb24obW9kZSwgc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUgPT09IHRydWUpIHJldHVybiBzdGF0ZTtcbiAgICBpZiAobW9kZS5jb3B5U3RhdGUpIHJldHVybiBtb2RlLmNvcHlTdGF0ZShzdGF0ZSk7XG4gICAgdmFyIG5zdGF0ZSA9IHt9O1xuICAgIGZvciAodmFyIG4gaW4gc3RhdGUpIHtcbiAgICAgIHZhciB2YWwgPSBzdGF0ZVtuXTtcbiAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBBcnJheSkgdmFsID0gdmFsLmNvbmNhdChbXSk7XG4gICAgICBuc3RhdGVbbl0gPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiBuc3RhdGU7XG4gIH07XG5cbiAgdmFyIHN0YXJ0U3RhdGUgPSBDb2RlTWlycm9yLnN0YXJ0U3RhdGUgPSBmdW5jdGlvbihtb2RlLCBhMSwgYTIpIHtcbiAgICByZXR1cm4gbW9kZS5zdGFydFN0YXRlID8gbW9kZS5zdGFydFN0YXRlKGExLCBhMikgOiB0cnVlO1xuICB9O1xuXG4gIC8vIEdpdmVuIGEgbW9kZSBhbmQgYSBzdGF0ZSAoZm9yIHRoYXQgbW9kZSksIGZpbmQgdGhlIGlubmVyIG1vZGUgYW5kXG4gIC8vIHN0YXRlIGF0IHRoZSBwb3NpdGlvbiB0aGF0IHRoZSBzdGF0ZSByZWZlcnMgdG8uXG4gIENvZGVNaXJyb3IuaW5uZXJNb2RlID0gZnVuY3Rpb24obW9kZSwgc3RhdGUpIHtcbiAgICB3aGlsZSAobW9kZS5pbm5lck1vZGUpIHtcbiAgICAgIHZhciBpbmZvID0gbW9kZS5pbm5lck1vZGUoc3RhdGUpO1xuICAgICAgaWYgKCFpbmZvIHx8IGluZm8ubW9kZSA9PSBtb2RlKSBicmVhaztcbiAgICAgIHN0YXRlID0gaW5mby5zdGF0ZTtcbiAgICAgIG1vZGUgPSBpbmZvLm1vZGU7XG4gICAgfVxuICAgIHJldHVybiBpbmZvIHx8IHttb2RlOiBtb2RlLCBzdGF0ZTogc3RhdGV9O1xuICB9O1xuXG4gIC8vIFNUQU5EQVJEIENPTU1BTkRTXG5cbiAgLy8gQ29tbWFuZHMgYXJlIHBhcmFtZXRlci1sZXNzIGFjdGlvbnMgdGhhdCBjYW4gYmUgcGVyZm9ybWVkIG9uIGFuXG4gIC8vIGVkaXRvciwgbW9zdGx5IHVzZWQgZm9yIGtleWJpbmRpbmdzLlxuICB2YXIgY29tbWFuZHMgPSBDb2RlTWlycm9yLmNvbW1hbmRzID0ge1xuICAgIHNlbGVjdEFsbDogZnVuY3Rpb24oY20pIHtjbS5zZXRTZWxlY3Rpb24oUG9zKGNtLmZpcnN0TGluZSgpLCAwKSwgUG9zKGNtLmxhc3RMaW5lKCkpLCBzZWxfZG9udFNjcm9sbCk7fSxcbiAgICBzaW5nbGVTZWxlY3Rpb246IGZ1bmN0aW9uKGNtKSB7XG4gICAgICBjbS5zZXRTZWxlY3Rpb24oY20uZ2V0Q3Vyc29yKFwiYW5jaG9yXCIpLCBjbS5nZXRDdXJzb3IoXCJoZWFkXCIpLCBzZWxfZG9udFNjcm9sbCk7XG4gICAgfSxcbiAgICBraWxsTGluZTogZnVuY3Rpb24oY20pIHtcbiAgICAgIGRlbGV0ZU5lYXJTZWxlY3Rpb24oY20sIGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgIGlmIChyYW5nZS5lbXB0eSgpKSB7XG4gICAgICAgICAgdmFyIGxlbiA9IGdldExpbmUoY20uZG9jLCByYW5nZS5oZWFkLmxpbmUpLnRleHQubGVuZ3RoO1xuICAgICAgICAgIGlmIChyYW5nZS5oZWFkLmNoID09IGxlbiAmJiByYW5nZS5oZWFkLmxpbmUgPCBjbS5sYXN0TGluZSgpKVxuICAgICAgICAgICAgcmV0dXJuIHtmcm9tOiByYW5nZS5oZWFkLCB0bzogUG9zKHJhbmdlLmhlYWQubGluZSArIDEsIDApfTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4ge2Zyb206IHJhbmdlLmhlYWQsIHRvOiBQb3MocmFuZ2UuaGVhZC5saW5lLCBsZW4pfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4ge2Zyb206IHJhbmdlLmZyb20oKSwgdG86IHJhbmdlLnRvKCl9O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGRlbGV0ZUxpbmU6IGZ1bmN0aW9uKGNtKSB7XG4gICAgICBkZWxldGVOZWFyU2VsZWN0aW9uKGNtLCBmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICByZXR1cm4ge2Zyb206IFBvcyhyYW5nZS5mcm9tKCkubGluZSwgMCksXG4gICAgICAgICAgICAgICAgdG86IGNsaXBQb3MoY20uZG9jLCBQb3MocmFuZ2UudG8oKS5saW5lICsgMSwgMCkpfTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZGVsTGluZUxlZnQ6IGZ1bmN0aW9uKGNtKSB7XG4gICAgICBkZWxldGVOZWFyU2VsZWN0aW9uKGNtLCBmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICByZXR1cm4ge2Zyb206IFBvcyhyYW5nZS5mcm9tKCkubGluZSwgMCksIHRvOiByYW5nZS5mcm9tKCl9O1xuICAgICAgfSk7XG4gICAgfSxcbiAgICB1bmRvOiBmdW5jdGlvbihjbSkge2NtLnVuZG8oKTt9LFxuICAgIHJlZG86IGZ1bmN0aW9uKGNtKSB7Y20ucmVkbygpO30sXG4gICAgdW5kb1NlbGVjdGlvbjogZnVuY3Rpb24oY20pIHtjbS51bmRvU2VsZWN0aW9uKCk7fSxcbiAgICByZWRvU2VsZWN0aW9uOiBmdW5jdGlvbihjbSkge2NtLnJlZG9TZWxlY3Rpb24oKTt9LFxuICAgIGdvRG9jU3RhcnQ6IGZ1bmN0aW9uKGNtKSB7Y20uZXh0ZW5kU2VsZWN0aW9uKFBvcyhjbS5maXJzdExpbmUoKSwgMCkpO30sXG4gICAgZ29Eb2NFbmQ6IGZ1bmN0aW9uKGNtKSB7Y20uZXh0ZW5kU2VsZWN0aW9uKFBvcyhjbS5sYXN0TGluZSgpKSk7fSxcbiAgICBnb0xpbmVTdGFydDogZnVuY3Rpb24oY20pIHtcbiAgICAgIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbihyYW5nZSkgeyByZXR1cm4gbGluZVN0YXJ0KGNtLCByYW5nZS5oZWFkLmxpbmUpOyB9LCBzZWxfbW92ZSk7XG4gICAgfSxcbiAgICBnb0xpbmVTdGFydFNtYXJ0OiBmdW5jdGlvbihjbSkge1xuICAgICAgY20uZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgIHZhciBzdGFydCA9IGxpbmVTdGFydChjbSwgcmFuZ2UuaGVhZC5saW5lKTtcbiAgICAgICAgdmFyIGxpbmUgPSBjbS5nZXRMaW5lSGFuZGxlKHN0YXJ0LmxpbmUpO1xuICAgICAgICB2YXIgb3JkZXIgPSBnZXRPcmRlcihsaW5lKTtcbiAgICAgICAgaWYgKCFvcmRlciB8fCBvcmRlclswXS5sZXZlbCA9PSAwKSB7XG4gICAgICAgICAgdmFyIGZpcnN0Tm9uV1MgPSBNYXRoLm1heCgwLCBsaW5lLnRleHQuc2VhcmNoKC9cXFMvKSk7XG4gICAgICAgICAgdmFyIGluV1MgPSByYW5nZS5oZWFkLmxpbmUgPT0gc3RhcnQubGluZSAmJiByYW5nZS5oZWFkLmNoIDw9IGZpcnN0Tm9uV1MgJiYgcmFuZ2UuaGVhZC5jaDtcbiAgICAgICAgICByZXR1cm4gUG9zKHN0YXJ0LmxpbmUsIGluV1MgPyAwIDogZmlyc3ROb25XUyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXJ0O1xuICAgICAgfSwgc2VsX21vdmUpO1xuICAgIH0sXG4gICAgZ29MaW5lRW5kOiBmdW5jdGlvbihjbSkge1xuICAgICAgY20uZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uKHJhbmdlKSB7IHJldHVybiBsaW5lRW5kKGNtLCByYW5nZS5oZWFkLmxpbmUpOyB9LCBzZWxfbW92ZSk7XG4gICAgfSxcbiAgICBnb0xpbmVSaWdodDogZnVuY3Rpb24oY20pIHtcbiAgICAgIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICB2YXIgdG9wID0gY20uY2hhckNvb3JkcyhyYW5nZS5oZWFkLCBcImRpdlwiKS50b3AgKyA1O1xuICAgICAgICByZXR1cm4gY20uY29vcmRzQ2hhcih7bGVmdDogY20uZGlzcGxheS5saW5lRGl2Lm9mZnNldFdpZHRoICsgMTAwLCB0b3A6IHRvcH0sIFwiZGl2XCIpO1xuICAgICAgfSwgc2VsX21vdmUpO1xuICAgIH0sXG4gICAgZ29MaW5lTGVmdDogZnVuY3Rpb24oY20pIHtcbiAgICAgIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICB2YXIgdG9wID0gY20uY2hhckNvb3JkcyhyYW5nZS5oZWFkLCBcImRpdlwiKS50b3AgKyA1O1xuICAgICAgICByZXR1cm4gY20uY29vcmRzQ2hhcih7bGVmdDogMCwgdG9wOiB0b3B9LCBcImRpdlwiKTtcbiAgICAgIH0sIHNlbF9tb3ZlKTtcbiAgICB9LFxuICAgIGdvTGluZVVwOiBmdW5jdGlvbihjbSkge2NtLm1vdmVWKC0xLCBcImxpbmVcIik7fSxcbiAgICBnb0xpbmVEb3duOiBmdW5jdGlvbihjbSkge2NtLm1vdmVWKDEsIFwibGluZVwiKTt9LFxuICAgIGdvUGFnZVVwOiBmdW5jdGlvbihjbSkge2NtLm1vdmVWKC0xLCBcInBhZ2VcIik7fSxcbiAgICBnb1BhZ2VEb3duOiBmdW5jdGlvbihjbSkge2NtLm1vdmVWKDEsIFwicGFnZVwiKTt9LFxuICAgIGdvQ2hhckxlZnQ6IGZ1bmN0aW9uKGNtKSB7Y20ubW92ZUgoLTEsIFwiY2hhclwiKTt9LFxuICAgIGdvQ2hhclJpZ2h0OiBmdW5jdGlvbihjbSkge2NtLm1vdmVIKDEsIFwiY2hhclwiKTt9LFxuICAgIGdvQ29sdW1uTGVmdDogZnVuY3Rpb24oY20pIHtjbS5tb3ZlSCgtMSwgXCJjb2x1bW5cIik7fSxcbiAgICBnb0NvbHVtblJpZ2h0OiBmdW5jdGlvbihjbSkge2NtLm1vdmVIKDEsIFwiY29sdW1uXCIpO30sXG4gICAgZ29Xb3JkTGVmdDogZnVuY3Rpb24oY20pIHtjbS5tb3ZlSCgtMSwgXCJ3b3JkXCIpO30sXG4gICAgZ29Hcm91cFJpZ2h0OiBmdW5jdGlvbihjbSkge2NtLm1vdmVIKDEsIFwiZ3JvdXBcIik7fSxcbiAgICBnb0dyb3VwTGVmdDogZnVuY3Rpb24oY20pIHtjbS5tb3ZlSCgtMSwgXCJncm91cFwiKTt9LFxuICAgIGdvV29yZFJpZ2h0OiBmdW5jdGlvbihjbSkge2NtLm1vdmVIKDEsIFwid29yZFwiKTt9LFxuICAgIGRlbENoYXJCZWZvcmU6IGZ1bmN0aW9uKGNtKSB7Y20uZGVsZXRlSCgtMSwgXCJjaGFyXCIpO30sXG4gICAgZGVsQ2hhckFmdGVyOiBmdW5jdGlvbihjbSkge2NtLmRlbGV0ZUgoMSwgXCJjaGFyXCIpO30sXG4gICAgZGVsV29yZEJlZm9yZTogZnVuY3Rpb24oY20pIHtjbS5kZWxldGVIKC0xLCBcIndvcmRcIik7fSxcbiAgICBkZWxXb3JkQWZ0ZXI6IGZ1bmN0aW9uKGNtKSB7Y20uZGVsZXRlSCgxLCBcIndvcmRcIik7fSxcbiAgICBkZWxHcm91cEJlZm9yZTogZnVuY3Rpb24oY20pIHtjbS5kZWxldGVIKC0xLCBcImdyb3VwXCIpO30sXG4gICAgZGVsR3JvdXBBZnRlcjogZnVuY3Rpb24oY20pIHtjbS5kZWxldGVIKDEsIFwiZ3JvdXBcIik7fSxcbiAgICBpbmRlbnRBdXRvOiBmdW5jdGlvbihjbSkge2NtLmluZGVudFNlbGVjdGlvbihcInNtYXJ0XCIpO30sXG4gICAgaW5kZW50TW9yZTogZnVuY3Rpb24oY20pIHtjbS5pbmRlbnRTZWxlY3Rpb24oXCJhZGRcIik7fSxcbiAgICBpbmRlbnRMZXNzOiBmdW5jdGlvbihjbSkge2NtLmluZGVudFNlbGVjdGlvbihcInN1YnRyYWN0XCIpO30sXG4gICAgaW5zZXJ0VGFiOiBmdW5jdGlvbihjbSkge2NtLnJlcGxhY2VTZWxlY3Rpb24oXCJcXHRcIik7fSxcbiAgICBpbnNlcnRTb2Z0VGFiOiBmdW5jdGlvbihjbSkge1xuICAgICAgdmFyIHNwYWNlcyA9IFtdLCByYW5nZXMgPSBjbS5saXN0U2VsZWN0aW9ucygpLCB0YWJTaXplID0gY20ub3B0aW9ucy50YWJTaXplO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBvcyA9IHJhbmdlc1tpXS5mcm9tKCk7XG4gICAgICAgIHZhciBjb2wgPSBjb3VudENvbHVtbihjbS5nZXRMaW5lKHBvcy5saW5lKSwgcG9zLmNoLCB0YWJTaXplKTtcbiAgICAgICAgc3BhY2VzLnB1c2gobmV3IEFycmF5KHRhYlNpemUgLSBjb2wgJSB0YWJTaXplICsgMSkuam9pbihcIiBcIikpO1xuICAgICAgfVxuICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbnMoc3BhY2VzKTtcbiAgICB9LFxuICAgIGRlZmF1bHRUYWI6IGZ1bmN0aW9uKGNtKSB7XG4gICAgICBpZiAoY20uc29tZXRoaW5nU2VsZWN0ZWQoKSkgY20uaW5kZW50U2VsZWN0aW9uKFwiYWRkXCIpO1xuICAgICAgZWxzZSBjbS5leGVjQ29tbWFuZChcImluc2VydFRhYlwiKTtcbiAgICB9LFxuICAgIHRyYW5zcG9zZUNoYXJzOiBmdW5jdGlvbihjbSkge1xuICAgICAgcnVuSW5PcChjbSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByYW5nZXMgPSBjbS5saXN0U2VsZWN0aW9ucygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBjdXIgPSByYW5nZXNbaV0uaGVhZCwgbGluZSA9IGdldExpbmUoY20uZG9jLCBjdXIubGluZSkudGV4dDtcbiAgICAgICAgICBpZiAoY3VyLmNoID4gMCAmJiBjdXIuY2ggPCBsaW5lLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UobGluZS5jaGFyQXQoY3VyLmNoKSArIGxpbmUuY2hhckF0KGN1ci5jaCAtIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvcyhjdXIubGluZSwgY3VyLmNoIC0gMSksIFBvcyhjdXIubGluZSwgY3VyLmNoICsgMSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIG5ld2xpbmVBbmRJbmRlbnQ6IGZ1bmN0aW9uKGNtKSB7XG4gICAgICBydW5Jbk9wKGNtLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxlbiA9IGNtLmxpc3RTZWxlY3Rpb25zKCkubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIHJhbmdlID0gY20ubGlzdFNlbGVjdGlvbnMoKVtpXTtcbiAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UoXCJcXG5cIiwgcmFuZ2UuYW5jaG9yLCByYW5nZS5oZWFkLCBcIitpbnB1dFwiKTtcbiAgICAgICAgICBjbS5pbmRlbnRMaW5lKHJhbmdlLmZyb20oKS5saW5lICsgMSwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgZW5zdXJlQ3Vyc29yVmlzaWJsZShjbSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdG9nZ2xlT3ZlcndyaXRlOiBmdW5jdGlvbihjbSkge2NtLnRvZ2dsZU92ZXJ3cml0ZSgpO31cbiAgfTtcblxuICAvLyBTVEFOREFSRCBLRVlNQVBTXG5cbiAgdmFyIGtleU1hcCA9IENvZGVNaXJyb3Iua2V5TWFwID0ge307XG4gIGtleU1hcC5iYXNpYyA9IHtcbiAgICBcIkxlZnRcIjogXCJnb0NoYXJMZWZ0XCIsIFwiUmlnaHRcIjogXCJnb0NoYXJSaWdodFwiLCBcIlVwXCI6IFwiZ29MaW5lVXBcIiwgXCJEb3duXCI6IFwiZ29MaW5lRG93blwiLFxuICAgIFwiRW5kXCI6IFwiZ29MaW5lRW5kXCIsIFwiSG9tZVwiOiBcImdvTGluZVN0YXJ0U21hcnRcIiwgXCJQYWdlVXBcIjogXCJnb1BhZ2VVcFwiLCBcIlBhZ2VEb3duXCI6IFwiZ29QYWdlRG93blwiLFxuICAgIFwiRGVsZXRlXCI6IFwiZGVsQ2hhckFmdGVyXCIsIFwiQmFja3NwYWNlXCI6IFwiZGVsQ2hhckJlZm9yZVwiLCBcIlNoaWZ0LUJhY2tzcGFjZVwiOiBcImRlbENoYXJCZWZvcmVcIixcbiAgICBcIlRhYlwiOiBcImRlZmF1bHRUYWJcIiwgXCJTaGlmdC1UYWJcIjogXCJpbmRlbnRBdXRvXCIsXG4gICAgXCJFbnRlclwiOiBcIm5ld2xpbmVBbmRJbmRlbnRcIiwgXCJJbnNlcnRcIjogXCJ0b2dnbGVPdmVyd3JpdGVcIixcbiAgICBcIkVzY1wiOiBcInNpbmdsZVNlbGVjdGlvblwiXG4gIH07XG4gIC8vIE5vdGUgdGhhdCB0aGUgc2F2ZSBhbmQgZmluZC1yZWxhdGVkIGNvbW1hbmRzIGFyZW4ndCBkZWZpbmVkIGJ5XG4gIC8vIGRlZmF1bHQuIFVzZXIgY29kZSBvciBhZGRvbnMgY2FuIGRlZmluZSB0aGVtLiBVbmtub3duIGNvbW1hbmRzXG4gIC8vIGFyZSBzaW1wbHkgaWdub3JlZC5cbiAga2V5TWFwLnBjRGVmYXVsdCA9IHtcbiAgICBcIkN0cmwtQVwiOiBcInNlbGVjdEFsbFwiLCBcIkN0cmwtRFwiOiBcImRlbGV0ZUxpbmVcIiwgXCJDdHJsLVpcIjogXCJ1bmRvXCIsIFwiU2hpZnQtQ3RybC1aXCI6IFwicmVkb1wiLCBcIkN0cmwtWVwiOiBcInJlZG9cIixcbiAgICBcIkN0cmwtSG9tZVwiOiBcImdvRG9jU3RhcnRcIiwgXCJDdHJsLVVwXCI6IFwiZ29Eb2NTdGFydFwiLCBcIkN0cmwtRW5kXCI6IFwiZ29Eb2NFbmRcIiwgXCJDdHJsLURvd25cIjogXCJnb0RvY0VuZFwiLFxuICAgIFwiQ3RybC1MZWZ0XCI6IFwiZ29Hcm91cExlZnRcIiwgXCJDdHJsLVJpZ2h0XCI6IFwiZ29Hcm91cFJpZ2h0XCIsIFwiQWx0LUxlZnRcIjogXCJnb0xpbmVTdGFydFwiLCBcIkFsdC1SaWdodFwiOiBcImdvTGluZUVuZFwiLFxuICAgIFwiQ3RybC1CYWNrc3BhY2VcIjogXCJkZWxHcm91cEJlZm9yZVwiLCBcIkN0cmwtRGVsZXRlXCI6IFwiZGVsR3JvdXBBZnRlclwiLCBcIkN0cmwtU1wiOiBcInNhdmVcIiwgXCJDdHJsLUZcIjogXCJmaW5kXCIsXG4gICAgXCJDdHJsLUdcIjogXCJmaW5kTmV4dFwiLCBcIlNoaWZ0LUN0cmwtR1wiOiBcImZpbmRQcmV2XCIsIFwiU2hpZnQtQ3RybC1GXCI6IFwicmVwbGFjZVwiLCBcIlNoaWZ0LUN0cmwtUlwiOiBcInJlcGxhY2VBbGxcIixcbiAgICBcIkN0cmwtW1wiOiBcImluZGVudExlc3NcIiwgXCJDdHJsLV1cIjogXCJpbmRlbnRNb3JlXCIsXG4gICAgXCJDdHJsLVVcIjogXCJ1bmRvU2VsZWN0aW9uXCIsIFwiU2hpZnQtQ3RybC1VXCI6IFwicmVkb1NlbGVjdGlvblwiLCBcIkFsdC1VXCI6IFwicmVkb1NlbGVjdGlvblwiLFxuICAgIGZhbGx0aHJvdWdoOiBcImJhc2ljXCJcbiAgfTtcbiAga2V5TWFwLm1hY0RlZmF1bHQgPSB7XG4gICAgXCJDbWQtQVwiOiBcInNlbGVjdEFsbFwiLCBcIkNtZC1EXCI6IFwiZGVsZXRlTGluZVwiLCBcIkNtZC1aXCI6IFwidW5kb1wiLCBcIlNoaWZ0LUNtZC1aXCI6IFwicmVkb1wiLCBcIkNtZC1ZXCI6IFwicmVkb1wiLFxuICAgIFwiQ21kLVVwXCI6IFwiZ29Eb2NTdGFydFwiLCBcIkNtZC1FbmRcIjogXCJnb0RvY0VuZFwiLCBcIkNtZC1Eb3duXCI6IFwiZ29Eb2NFbmRcIiwgXCJBbHQtTGVmdFwiOiBcImdvR3JvdXBMZWZ0XCIsXG4gICAgXCJBbHQtUmlnaHRcIjogXCJnb0dyb3VwUmlnaHRcIiwgXCJDbWQtTGVmdFwiOiBcImdvTGluZVN0YXJ0XCIsIFwiQ21kLVJpZ2h0XCI6IFwiZ29MaW5lRW5kXCIsIFwiQWx0LUJhY2tzcGFjZVwiOiBcImRlbEdyb3VwQmVmb3JlXCIsXG4gICAgXCJDdHJsLUFsdC1CYWNrc3BhY2VcIjogXCJkZWxHcm91cEFmdGVyXCIsIFwiQWx0LURlbGV0ZVwiOiBcImRlbEdyb3VwQWZ0ZXJcIiwgXCJDbWQtU1wiOiBcInNhdmVcIiwgXCJDbWQtRlwiOiBcImZpbmRcIixcbiAgICBcIkNtZC1HXCI6IFwiZmluZE5leHRcIiwgXCJTaGlmdC1DbWQtR1wiOiBcImZpbmRQcmV2XCIsIFwiQ21kLUFsdC1GXCI6IFwicmVwbGFjZVwiLCBcIlNoaWZ0LUNtZC1BbHQtRlwiOiBcInJlcGxhY2VBbGxcIixcbiAgICBcIkNtZC1bXCI6IFwiaW5kZW50TGVzc1wiLCBcIkNtZC1dXCI6IFwiaW5kZW50TW9yZVwiLCBcIkNtZC1CYWNrc3BhY2VcIjogXCJkZWxMaW5lTGVmdFwiLFxuICAgIFwiQ21kLVVcIjogXCJ1bmRvU2VsZWN0aW9uXCIsIFwiU2hpZnQtQ21kLVVcIjogXCJyZWRvU2VsZWN0aW9uXCIsXG4gICAgZmFsbHRocm91Z2g6IFtcImJhc2ljXCIsIFwiZW1hY3N5XCJdXG4gIH07XG4gIC8vIFZlcnkgYmFzaWMgcmVhZGxpbmUvZW1hY3Mtc3R5bGUgYmluZGluZ3MsIHdoaWNoIGFyZSBzdGFuZGFyZCBvbiBNYWMuXG4gIGtleU1hcC5lbWFjc3kgPSB7XG4gICAgXCJDdHJsLUZcIjogXCJnb0NoYXJSaWdodFwiLCBcIkN0cmwtQlwiOiBcImdvQ2hhckxlZnRcIiwgXCJDdHJsLVBcIjogXCJnb0xpbmVVcFwiLCBcIkN0cmwtTlwiOiBcImdvTGluZURvd25cIixcbiAgICBcIkFsdC1GXCI6IFwiZ29Xb3JkUmlnaHRcIiwgXCJBbHQtQlwiOiBcImdvV29yZExlZnRcIiwgXCJDdHJsLUFcIjogXCJnb0xpbmVTdGFydFwiLCBcIkN0cmwtRVwiOiBcImdvTGluZUVuZFwiLFxuICAgIFwiQ3RybC1WXCI6IFwiZ29QYWdlRG93blwiLCBcIlNoaWZ0LUN0cmwtVlwiOiBcImdvUGFnZVVwXCIsIFwiQ3RybC1EXCI6IFwiZGVsQ2hhckFmdGVyXCIsIFwiQ3RybC1IXCI6IFwiZGVsQ2hhckJlZm9yZVwiLFxuICAgIFwiQWx0LURcIjogXCJkZWxXb3JkQWZ0ZXJcIiwgXCJBbHQtQmFja3NwYWNlXCI6IFwiZGVsV29yZEJlZm9yZVwiLCBcIkN0cmwtS1wiOiBcImtpbGxMaW5lXCIsIFwiQ3RybC1UXCI6IFwidHJhbnNwb3NlQ2hhcnNcIlxuICB9O1xuICBrZXlNYXBbXCJkZWZhdWx0XCJdID0gbWFjID8ga2V5TWFwLm1hY0RlZmF1bHQgOiBrZXlNYXAucGNEZWZhdWx0O1xuXG4gIC8vIEtFWU1BUCBESVNQQVRDSFxuXG4gIGZ1bmN0aW9uIGdldEtleU1hcCh2YWwpIHtcbiAgICBpZiAodHlwZW9mIHZhbCA9PSBcInN0cmluZ1wiKSByZXR1cm4ga2V5TWFwW3ZhbF07XG4gICAgZWxzZSByZXR1cm4gdmFsO1xuICB9XG5cbiAgLy8gR2l2ZW4gYW4gYXJyYXkgb2Yga2V5bWFwcyBhbmQgYSBrZXkgbmFtZSwgY2FsbCBoYW5kbGUgb24gYW55XG4gIC8vIGJpbmRpbmdzIGZvdW5kLCB1bnRpbCB0aGF0IHJldHVybnMgYSB0cnV0aHkgdmFsdWUsIGF0IHdoaWNoIHBvaW50XG4gIC8vIHdlIGNvbnNpZGVyIHRoZSBrZXkgaGFuZGxlZC4gSW1wbGVtZW50cyB0aGluZ3MgbGlrZSBiaW5kaW5nIGEga2V5XG4gIC8vIHRvIGZhbHNlIHN0b3BwaW5nIGZ1cnRoZXIgaGFuZGxpbmcgYW5kIGtleW1hcCBmYWxsdGhyb3VnaC5cbiAgdmFyIGxvb2t1cEtleSA9IENvZGVNaXJyb3IubG9va3VwS2V5ID0gZnVuY3Rpb24obmFtZSwgbWFwcywgaGFuZGxlKSB7XG4gICAgZnVuY3Rpb24gbG9va3VwKG1hcCkge1xuICAgICAgbWFwID0gZ2V0S2V5TWFwKG1hcCk7XG4gICAgICB2YXIgZm91bmQgPSBtYXBbbmFtZV07XG4gICAgICBpZiAoZm91bmQgPT09IGZhbHNlKSByZXR1cm4gXCJzdG9wXCI7XG4gICAgICBpZiAoZm91bmQgIT0gbnVsbCAmJiBoYW5kbGUoZm91bmQpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChtYXAubm9mYWxsdGhyb3VnaCkgcmV0dXJuIFwic3RvcFwiO1xuXG4gICAgICB2YXIgZmFsbHRocm91Z2ggPSBtYXAuZmFsbHRocm91Z2g7XG4gICAgICBpZiAoZmFsbHRocm91Z2ggPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChmYWxsdGhyb3VnaCkgIT0gXCJbb2JqZWN0IEFycmF5XVwiKVxuICAgICAgICByZXR1cm4gbG9va3VwKGZhbGx0aHJvdWdoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmFsbHRocm91Z2gubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGRvbmUgPSBsb29rdXAoZmFsbHRocm91Z2hbaV0pO1xuICAgICAgICBpZiAoZG9uZSkgcmV0dXJuIGRvbmU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXBzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgZG9uZSA9IGxvb2t1cChtYXBzW2ldKTtcbiAgICAgIGlmIChkb25lKSByZXR1cm4gZG9uZSAhPSBcInN0b3BcIjtcbiAgICB9XG4gIH07XG5cbiAgLy8gTW9kaWZpZXIga2V5IHByZXNzZXMgZG9uJ3QgY291bnQgYXMgJ3JlYWwnIGtleSBwcmVzc2VzIGZvciB0aGVcbiAgLy8gcHVycG9zZSBvZiBrZXltYXAgZmFsbHRocm91Z2guXG4gIHZhciBpc01vZGlmaWVyS2V5ID0gQ29kZU1pcnJvci5pc01vZGlmaWVyS2V5ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgbmFtZSA9IGtleU5hbWVzW2V2ZW50LmtleUNvZGVdO1xuICAgIHJldHVybiBuYW1lID09IFwiQ3RybFwiIHx8IG5hbWUgPT0gXCJBbHRcIiB8fCBuYW1lID09IFwiU2hpZnRcIiB8fCBuYW1lID09IFwiTW9kXCI7XG4gIH07XG5cbiAgLy8gTG9vayB1cCB0aGUgbmFtZSBvZiBhIGtleSBhcyBpbmRpY2F0ZWQgYnkgYW4gZXZlbnQgb2JqZWN0LlxuICB2YXIga2V5TmFtZSA9IENvZGVNaXJyb3Iua2V5TmFtZSA9IGZ1bmN0aW9uKGV2ZW50LCBub1NoaWZ0KSB7XG4gICAgaWYgKHByZXN0byAmJiBldmVudC5rZXlDb2RlID09IDM0ICYmIGV2ZW50W1wiY2hhclwiXSkgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBuYW1lID0ga2V5TmFtZXNbZXZlbnQua2V5Q29kZV07XG4gICAgaWYgKG5hbWUgPT0gbnVsbCB8fCBldmVudC5hbHRHcmFwaEtleSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChldmVudC5hbHRLZXkpIG5hbWUgPSBcIkFsdC1cIiArIG5hbWU7XG4gICAgaWYgKGZsaXBDdHJsQ21kID8gZXZlbnQubWV0YUtleSA6IGV2ZW50LmN0cmxLZXkpIG5hbWUgPSBcIkN0cmwtXCIgKyBuYW1lO1xuICAgIGlmIChmbGlwQ3RybENtZCA/IGV2ZW50LmN0cmxLZXkgOiBldmVudC5tZXRhS2V5KSBuYW1lID0gXCJDbWQtXCIgKyBuYW1lO1xuICAgIGlmICghbm9TaGlmdCAmJiBldmVudC5zaGlmdEtleSkgbmFtZSA9IFwiU2hpZnQtXCIgKyBuYW1lO1xuICAgIHJldHVybiBuYW1lO1xuICB9O1xuXG4gIC8vIEZST01URVhUQVJFQVxuXG4gIENvZGVNaXJyb3IuZnJvbVRleHRBcmVhID0gZnVuY3Rpb24odGV4dGFyZWEsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICBvcHRpb25zLnZhbHVlID0gdGV4dGFyZWEudmFsdWU7XG4gICAgaWYgKCFvcHRpb25zLnRhYmluZGV4ICYmIHRleHRhcmVhLnRhYmluZGV4KVxuICAgICAgb3B0aW9ucy50YWJpbmRleCA9IHRleHRhcmVhLnRhYmluZGV4O1xuICAgIGlmICghb3B0aW9ucy5wbGFjZWhvbGRlciAmJiB0ZXh0YXJlYS5wbGFjZWhvbGRlcilcbiAgICAgIG9wdGlvbnMucGxhY2Vob2xkZXIgPSB0ZXh0YXJlYS5wbGFjZWhvbGRlcjtcbiAgICAvLyBTZXQgYXV0b2ZvY3VzIHRvIHRydWUgaWYgdGhpcyB0ZXh0YXJlYSBpcyBmb2N1c2VkLCBvciBpZiBpdCBoYXNcbiAgICAvLyBhdXRvZm9jdXMgYW5kIG5vIG90aGVyIGVsZW1lbnQgaXMgZm9jdXNlZC5cbiAgICBpZiAob3B0aW9ucy5hdXRvZm9jdXMgPT0gbnVsbCkge1xuICAgICAgdmFyIGhhc0ZvY3VzID0gYWN0aXZlRWx0KCk7XG4gICAgICBvcHRpb25zLmF1dG9mb2N1cyA9IGhhc0ZvY3VzID09IHRleHRhcmVhIHx8XG4gICAgICAgIHRleHRhcmVhLmdldEF0dHJpYnV0ZShcImF1dG9mb2N1c1wiKSAhPSBudWxsICYmIGhhc0ZvY3VzID09IGRvY3VtZW50LmJvZHk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2F2ZSgpIHt0ZXh0YXJlYS52YWx1ZSA9IGNtLmdldFZhbHVlKCk7fVxuICAgIGlmICh0ZXh0YXJlYS5mb3JtKSB7XG4gICAgICBvbih0ZXh0YXJlYS5mb3JtLCBcInN1Ym1pdFwiLCBzYXZlKTtcbiAgICAgIC8vIERlcGxvcmFibGUgaGFjayB0byBtYWtlIHRoZSBzdWJtaXQgbWV0aG9kIGRvIHRoZSByaWdodCB0aGluZy5cbiAgICAgIGlmICghb3B0aW9ucy5sZWF2ZVN1Ym1pdE1ldGhvZEFsb25lKSB7XG4gICAgICAgIHZhciBmb3JtID0gdGV4dGFyZWEuZm9ybSwgcmVhbFN1Ym1pdCA9IGZvcm0uc3VibWl0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciB3cmFwcGVkU3VibWl0ID0gZm9ybS5zdWJtaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNhdmUoKTtcbiAgICAgICAgICAgIGZvcm0uc3VibWl0ID0gcmVhbFN1Ym1pdDtcbiAgICAgICAgICAgIGZvcm0uc3VibWl0KCk7XG4gICAgICAgICAgICBmb3JtLnN1Ym1pdCA9IHdyYXBwZWRTdWJtaXQ7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBjYXRjaChlKSB7fVxuICAgICAgfVxuICAgIH1cblxuICAgIHRleHRhcmVhLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICB2YXIgY20gPSBDb2RlTWlycm9yKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHRleHRhcmVhLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIHRleHRhcmVhLm5leHRTaWJsaW5nKTtcbiAgICB9LCBvcHRpb25zKTtcbiAgICBjbS5zYXZlID0gc2F2ZTtcbiAgICBjbS5nZXRUZXh0QXJlYSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGV4dGFyZWE7IH07XG4gICAgY20udG9UZXh0QXJlYSA9IGZ1bmN0aW9uKCkge1xuICAgICAgc2F2ZSgpO1xuICAgICAgdGV4dGFyZWEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjbS5nZXRXcmFwcGVyRWxlbWVudCgpKTtcbiAgICAgIHRleHRhcmVhLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgICAgaWYgKHRleHRhcmVhLmZvcm0pIHtcbiAgICAgICAgb2ZmKHRleHRhcmVhLmZvcm0sIFwic3VibWl0XCIsIHNhdmUpO1xuICAgICAgICBpZiAodHlwZW9mIHRleHRhcmVhLmZvcm0uc3VibWl0ID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICB0ZXh0YXJlYS5mb3JtLnN1Ym1pdCA9IHJlYWxTdWJtaXQ7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gY207XG4gIH07XG5cbiAgLy8gU1RSSU5HIFNUUkVBTVxuXG4gIC8vIEZlZCB0byB0aGUgbW9kZSBwYXJzZXJzLCBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIG1ha2VcbiAgLy8gcGFyc2VycyBtb3JlIHN1Y2NpbmN0LlxuXG4gIHZhciBTdHJpbmdTdHJlYW0gPSBDb2RlTWlycm9yLlN0cmluZ1N0cmVhbSA9IGZ1bmN0aW9uKHN0cmluZywgdGFiU2l6ZSkge1xuICAgIHRoaXMucG9zID0gdGhpcy5zdGFydCA9IDA7XG4gICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgdGhpcy50YWJTaXplID0gdGFiU2l6ZSB8fCA4O1xuICAgIHRoaXMubGFzdENvbHVtblBvcyA9IHRoaXMubGFzdENvbHVtblZhbHVlID0gMDtcbiAgICB0aGlzLmxpbmVTdGFydCA9IDA7XG4gIH07XG5cbiAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZSA9IHtcbiAgICBlb2w6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLnBvcyA+PSB0aGlzLnN0cmluZy5sZW5ndGg7fSxcbiAgICBzb2w6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLnBvcyA9PSB0aGlzLmxpbmVTdGFydDt9LFxuICAgIHBlZWs6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpIHx8IHVuZGVmaW5lZDt9LFxuICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMucG9zIDwgdGhpcy5zdHJpbmcubGVuZ3RoKVxuICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKyspO1xuICAgIH0sXG4gICAgZWF0OiBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgdmFyIGNoID0gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKTtcbiAgICAgIGlmICh0eXBlb2YgbWF0Y2ggPT0gXCJzdHJpbmdcIikgdmFyIG9rID0gY2ggPT0gbWF0Y2g7XG4gICAgICBlbHNlIHZhciBvayA9IGNoICYmIChtYXRjaC50ZXN0ID8gbWF0Y2gudGVzdChjaCkgOiBtYXRjaChjaCkpO1xuICAgICAgaWYgKG9rKSB7Kyt0aGlzLnBvczsgcmV0dXJuIGNoO31cbiAgICB9LFxuICAgIGVhdFdoaWxlOiBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICB3aGlsZSAodGhpcy5lYXQobWF0Y2gpKXt9XG4gICAgICByZXR1cm4gdGhpcy5wb3MgPiBzdGFydDtcbiAgICB9LFxuICAgIGVhdFNwYWNlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzdGFydCA9IHRoaXMucG9zO1xuICAgICAgd2hpbGUgKC9bXFxzXFx1MDBhMF0vLnRlc3QodGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKSkpICsrdGhpcy5wb3M7XG4gICAgICByZXR1cm4gdGhpcy5wb3MgPiBzdGFydDtcbiAgICB9LFxuICAgIHNraXBUb0VuZDogZnVuY3Rpb24oKSB7dGhpcy5wb3MgPSB0aGlzLnN0cmluZy5sZW5ndGg7fSxcbiAgICBza2lwVG86IGZ1bmN0aW9uKGNoKSB7XG4gICAgICB2YXIgZm91bmQgPSB0aGlzLnN0cmluZy5pbmRleE9mKGNoLCB0aGlzLnBvcyk7XG4gICAgICBpZiAoZm91bmQgPiAtMSkge3RoaXMucG9zID0gZm91bmQ7IHJldHVybiB0cnVlO31cbiAgICB9LFxuICAgIGJhY2tVcDogZnVuY3Rpb24obikge3RoaXMucG9zIC09IG47fSxcbiAgICBjb2x1bW46IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMubGFzdENvbHVtblBvcyA8IHRoaXMuc3RhcnQpIHtcbiAgICAgICAgdGhpcy5sYXN0Q29sdW1uVmFsdWUgPSBjb3VudENvbHVtbih0aGlzLnN0cmluZywgdGhpcy5zdGFydCwgdGhpcy50YWJTaXplLCB0aGlzLmxhc3RDb2x1bW5Qb3MsIHRoaXMubGFzdENvbHVtblZhbHVlKTtcbiAgICAgICAgdGhpcy5sYXN0Q29sdW1uUG9zID0gdGhpcy5zdGFydDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmxhc3RDb2x1bW5WYWx1ZSAtICh0aGlzLmxpbmVTdGFydCA/IGNvdW50Q29sdW1uKHRoaXMuc3RyaW5nLCB0aGlzLmxpbmVTdGFydCwgdGhpcy50YWJTaXplKSA6IDApO1xuICAgIH0sXG4gICAgaW5kZW50YXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNvdW50Q29sdW1uKHRoaXMuc3RyaW5nLCBudWxsLCB0aGlzLnRhYlNpemUpIC1cbiAgICAgICAgKHRoaXMubGluZVN0YXJ0ID8gY291bnRDb2x1bW4odGhpcy5zdHJpbmcsIHRoaXMubGluZVN0YXJ0LCB0aGlzLnRhYlNpemUpIDogMCk7XG4gICAgfSxcbiAgICBtYXRjaDogZnVuY3Rpb24ocGF0dGVybiwgY29uc3VtZSwgY2FzZUluc2Vuc2l0aXZlKSB7XG4gICAgICBpZiAodHlwZW9mIHBhdHRlcm4gPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YXIgY2FzZWQgPSBmdW5jdGlvbihzdHIpIHtyZXR1cm4gY2FzZUluc2Vuc2l0aXZlID8gc3RyLnRvTG93ZXJDYXNlKCkgOiBzdHI7fTtcbiAgICAgICAgdmFyIHN1YnN0ciA9IHRoaXMuc3RyaW5nLnN1YnN0cih0aGlzLnBvcywgcGF0dGVybi5sZW5ndGgpO1xuICAgICAgICBpZiAoY2FzZWQoc3Vic3RyKSA9PSBjYXNlZChwYXR0ZXJuKSkge1xuICAgICAgICAgIGlmIChjb25zdW1lICE9PSBmYWxzZSkgdGhpcy5wb3MgKz0gcGF0dGVybi5sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHRoaXMuc3RyaW5nLnNsaWNlKHRoaXMucG9zKS5tYXRjaChwYXR0ZXJuKTtcbiAgICAgICAgaWYgKG1hdGNoICYmIG1hdGNoLmluZGV4ID4gMCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChtYXRjaCAmJiBjb25zdW1lICE9PSBmYWxzZSkgdGhpcy5wb3MgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICB9XG4gICAgfSxcbiAgICBjdXJyZW50OiBmdW5jdGlvbigpe3JldHVybiB0aGlzLnN0cmluZy5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLnBvcyk7fSxcbiAgICBoaWRlRmlyc3RDaGFyczogZnVuY3Rpb24obiwgaW5uZXIpIHtcbiAgICAgIHRoaXMubGluZVN0YXJ0ICs9IG47XG4gICAgICB0cnkgeyByZXR1cm4gaW5uZXIoKTsgfVxuICAgICAgZmluYWxseSB7IHRoaXMubGluZVN0YXJ0IC09IG47IH1cbiAgICB9XG4gIH07XG5cbiAgLy8gVEVYVE1BUktFUlNcblxuICAvLyBDcmVhdGVkIHdpdGggbWFya1RleHQgYW5kIHNldEJvb2ttYXJrIG1ldGhvZHMuIEEgVGV4dE1hcmtlciBpcyBhXG4gIC8vIGhhbmRsZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGNsZWFyIG9yIGZpbmQgYSBtYXJrZWQgcG9zaXRpb24gaW4gdGhlXG4gIC8vIGRvY3VtZW50LiBMaW5lIG9iamVjdHMgaG9sZCBhcnJheXMgKG1hcmtlZFNwYW5zKSBjb250YWluaW5nXG4gIC8vIHtmcm9tLCB0bywgbWFya2VyfSBvYmplY3QgcG9pbnRpbmcgdG8gc3VjaCBtYXJrZXIgb2JqZWN0cywgYW5kXG4gIC8vIGluZGljYXRpbmcgdGhhdCBzdWNoIGEgbWFya2VyIGlzIHByZXNlbnQgb24gdGhhdCBsaW5lLiBNdWx0aXBsZVxuICAvLyBsaW5lcyBtYXkgcG9pbnQgdG8gdGhlIHNhbWUgbWFya2VyIHdoZW4gaXQgc3BhbnMgYWNyb3NzIGxpbmVzLlxuICAvLyBUaGUgc3BhbnMgd2lsbCBoYXZlIG51bGwgZm9yIHRoZWlyIGZyb20vdG8gcHJvcGVydGllcyB3aGVuIHRoZVxuICAvLyBtYXJrZXIgY29udGludWVzIGJleW9uZCB0aGUgc3RhcnQvZW5kIG9mIHRoZSBsaW5lLiBNYXJrZXJzIGhhdmVcbiAgLy8gbGlua3MgYmFjayB0byB0aGUgbGluZXMgdGhleSBjdXJyZW50bHkgdG91Y2guXG5cbiAgdmFyIFRleHRNYXJrZXIgPSBDb2RlTWlycm9yLlRleHRNYXJrZXIgPSBmdW5jdGlvbihkb2MsIHR5cGUpIHtcbiAgICB0aGlzLmxpbmVzID0gW107XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmRvYyA9IGRvYztcbiAgfTtcbiAgZXZlbnRNaXhpbihUZXh0TWFya2VyKTtcblxuICAvLyBDbGVhciB0aGUgbWFya2VyLlxuICBUZXh0TWFya2VyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmV4cGxpY2l0bHlDbGVhcmVkKSByZXR1cm47XG4gICAgdmFyIGNtID0gdGhpcy5kb2MuY20sIHdpdGhPcCA9IGNtICYmICFjbS5jdXJPcDtcbiAgICBpZiAod2l0aE9wKSBzdGFydE9wZXJhdGlvbihjbSk7XG4gICAgaWYgKGhhc0hhbmRsZXIodGhpcywgXCJjbGVhclwiKSkge1xuICAgICAgdmFyIGZvdW5kID0gdGhpcy5maW5kKCk7XG4gICAgICBpZiAoZm91bmQpIHNpZ25hbExhdGVyKHRoaXMsIFwiY2xlYXJcIiwgZm91bmQuZnJvbSwgZm91bmQudG8pO1xuICAgIH1cbiAgICB2YXIgbWluID0gbnVsbCwgbWF4ID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBsaW5lID0gdGhpcy5saW5lc1tpXTtcbiAgICAgIHZhciBzcGFuID0gZ2V0TWFya2VkU3BhbkZvcihsaW5lLm1hcmtlZFNwYW5zLCB0aGlzKTtcbiAgICAgIGlmIChjbSAmJiAhdGhpcy5jb2xsYXBzZWQpIHJlZ0xpbmVDaGFuZ2UoY20sIGxpbmVObyhsaW5lKSwgXCJ0ZXh0XCIpO1xuICAgICAgZWxzZSBpZiAoY20pIHtcbiAgICAgICAgaWYgKHNwYW4udG8gIT0gbnVsbCkgbWF4ID0gbGluZU5vKGxpbmUpO1xuICAgICAgICBpZiAoc3Bhbi5mcm9tICE9IG51bGwpIG1pbiA9IGxpbmVObyhsaW5lKTtcbiAgICAgIH1cbiAgICAgIGxpbmUubWFya2VkU3BhbnMgPSByZW1vdmVNYXJrZWRTcGFuKGxpbmUubWFya2VkU3BhbnMsIHNwYW4pO1xuICAgICAgaWYgKHNwYW4uZnJvbSA9PSBudWxsICYmIHRoaXMuY29sbGFwc2VkICYmICFsaW5lSXNIaWRkZW4odGhpcy5kb2MsIGxpbmUpICYmIGNtKVxuICAgICAgICB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIHRleHRIZWlnaHQoY20uZGlzcGxheSkpO1xuICAgIH1cbiAgICBpZiAoY20gJiYgdGhpcy5jb2xsYXBzZWQgJiYgIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciB2aXN1YWwgPSB2aXN1YWxMaW5lKHRoaXMubGluZXNbaV0pLCBsZW4gPSBsaW5lTGVuZ3RoKHZpc3VhbCk7XG4gICAgICBpZiAobGVuID4gY20uZGlzcGxheS5tYXhMaW5lTGVuZ3RoKSB7XG4gICAgICAgIGNtLmRpc3BsYXkubWF4TGluZSA9IHZpc3VhbDtcbiAgICAgICAgY20uZGlzcGxheS5tYXhMaW5lTGVuZ3RoID0gbGVuO1xuICAgICAgICBjbS5kaXNwbGF5Lm1heExpbmVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWluICE9IG51bGwgJiYgY20gJiYgdGhpcy5jb2xsYXBzZWQpIHJlZ0NoYW5nZShjbSwgbWluLCBtYXggKyAxKTtcbiAgICB0aGlzLmxpbmVzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5leHBsaWNpdGx5Q2xlYXJlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMuYXRvbWljICYmIHRoaXMuZG9jLmNhbnRFZGl0KSB7XG4gICAgICB0aGlzLmRvYy5jYW50RWRpdCA9IGZhbHNlO1xuICAgICAgaWYgKGNtKSByZUNoZWNrU2VsZWN0aW9uKGNtLmRvYyk7XG4gICAgfVxuICAgIGlmIChjbSkgc2lnbmFsTGF0ZXIoY20sIFwibWFya2VyQ2xlYXJlZFwiLCBjbSwgdGhpcyk7XG4gICAgaWYgKHdpdGhPcCkgZW5kT3BlcmF0aW9uKGNtKTtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHRoaXMucGFyZW50LmNsZWFyKCk7XG4gIH07XG5cbiAgLy8gRmluZCB0aGUgcG9zaXRpb24gb2YgdGhlIG1hcmtlciBpbiB0aGUgZG9jdW1lbnQuIFJldHVybnMgYSB7ZnJvbSxcbiAgLy8gdG99IG9iamVjdCBieSBkZWZhdWx0LiBTaWRlIGNhbiBiZSBwYXNzZWQgdG8gZ2V0IGEgc3BlY2lmaWMgc2lkZVxuICAvLyAtLSAwIChib3RoKSwgLTEgKGxlZnQpLCBvciAxIChyaWdodCkuIFdoZW4gbGluZU9iaiBpcyB0cnVlLCB0aGVcbiAgLy8gUG9zIG9iamVjdHMgcmV0dXJuZWQgY29udGFpbiBhIGxpbmUgb2JqZWN0LCByYXRoZXIgdGhhbiBhIGxpbmVcbiAgLy8gbnVtYmVyICh1c2VkIHRvIHByZXZlbnQgbG9va2luZyB1cCB0aGUgc2FtZSBsaW5lIHR3aWNlKS5cbiAgVGV4dE1hcmtlci5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKHNpZGUsIGxpbmVPYmopIHtcbiAgICBpZiAoc2lkZSA9PSBudWxsICYmIHRoaXMudHlwZSA9PSBcImJvb2ttYXJrXCIpIHNpZGUgPSAxO1xuICAgIHZhciBmcm9tLCB0bztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBsaW5lID0gdGhpcy5saW5lc1tpXTtcbiAgICAgIHZhciBzcGFuID0gZ2V0TWFya2VkU3BhbkZvcihsaW5lLm1hcmtlZFNwYW5zLCB0aGlzKTtcbiAgICAgIGlmIChzcGFuLmZyb20gIT0gbnVsbCkge1xuICAgICAgICBmcm9tID0gUG9zKGxpbmVPYmogPyBsaW5lIDogbGluZU5vKGxpbmUpLCBzcGFuLmZyb20pO1xuICAgICAgICBpZiAoc2lkZSA9PSAtMSkgcmV0dXJuIGZyb207XG4gICAgICB9XG4gICAgICBpZiAoc3Bhbi50byAhPSBudWxsKSB7XG4gICAgICAgIHRvID0gUG9zKGxpbmVPYmogPyBsaW5lIDogbGluZU5vKGxpbmUpLCBzcGFuLnRvKTtcbiAgICAgICAgaWYgKHNpZGUgPT0gMSkgcmV0dXJuIHRvO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnJvbSAmJiB7ZnJvbTogZnJvbSwgdG86IHRvfTtcbiAgfTtcblxuICAvLyBTaWduYWxzIHRoYXQgdGhlIG1hcmtlcidzIHdpZGdldCBjaGFuZ2VkLCBhbmQgc3Vycm91bmRpbmcgbGF5b3V0XG4gIC8vIHNob3VsZCBiZSByZWNvbXB1dGVkLlxuICBUZXh0TWFya2VyLnByb3RvdHlwZS5jaGFuZ2VkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHBvcyA9IHRoaXMuZmluZCgtMSwgdHJ1ZSksIHdpZGdldCA9IHRoaXMsIGNtID0gdGhpcy5kb2MuY207XG4gICAgaWYgKCFwb3MgfHwgIWNtKSByZXR1cm47XG4gICAgcnVuSW5PcChjbSwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGluZSA9IHBvcy5saW5lLCBsaW5lTiA9IGxpbmVObyhwb3MubGluZSk7XG4gICAgICB2YXIgdmlldyA9IGZpbmRWaWV3Rm9yTGluZShjbSwgbGluZU4pO1xuICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZUZvcih2aWV3KTtcbiAgICAgICAgY20uY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZCA9IGNtLmN1ck9wLmZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNtLmN1ck9wLnVwZGF0ZU1heExpbmUgPSB0cnVlO1xuICAgICAgaWYgKCFsaW5lSXNIaWRkZW4od2lkZ2V0LmRvYywgbGluZSkgJiYgd2lkZ2V0LmhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgIHZhciBvbGRIZWlnaHQgPSB3aWRnZXQuaGVpZ2h0O1xuICAgICAgICB3aWRnZXQuaGVpZ2h0ID0gbnVsbDtcbiAgICAgICAgdmFyIGRIZWlnaHQgPSB3aWRnZXRIZWlnaHQod2lkZ2V0KSAtIG9sZEhlaWdodDtcbiAgICAgICAgaWYgKGRIZWlnaHQpXG4gICAgICAgICAgdXBkYXRlTGluZUhlaWdodChsaW5lLCBsaW5lLmhlaWdodCArIGRIZWlnaHQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIFRleHRNYXJrZXIucHJvdG90eXBlLmF0dGFjaExpbmUgPSBmdW5jdGlvbihsaW5lKSB7XG4gICAgaWYgKCF0aGlzLmxpbmVzLmxlbmd0aCAmJiB0aGlzLmRvYy5jbSkge1xuICAgICAgdmFyIG9wID0gdGhpcy5kb2MuY20uY3VyT3A7XG4gICAgICBpZiAoIW9wLm1heWJlSGlkZGVuTWFya2VycyB8fCBpbmRleE9mKG9wLm1heWJlSGlkZGVuTWFya2VycywgdGhpcykgPT0gLTEpXG4gICAgICAgIChvcC5tYXliZVVuaGlkZGVuTWFya2VycyB8fCAob3AubWF5YmVVbmhpZGRlbk1hcmtlcnMgPSBbXSkpLnB1c2godGhpcyk7XG4gICAgfVxuICAgIHRoaXMubGluZXMucHVzaChsaW5lKTtcbiAgfTtcbiAgVGV4dE1hcmtlci5wcm90b3R5cGUuZGV0YWNoTGluZSA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICB0aGlzLmxpbmVzLnNwbGljZShpbmRleE9mKHRoaXMubGluZXMsIGxpbmUpLCAxKTtcbiAgICBpZiAoIXRoaXMubGluZXMubGVuZ3RoICYmIHRoaXMuZG9jLmNtKSB7XG4gICAgICB2YXIgb3AgPSB0aGlzLmRvYy5jbS5jdXJPcDtcbiAgICAgIChvcC5tYXliZUhpZGRlbk1hcmtlcnMgfHwgKG9wLm1heWJlSGlkZGVuTWFya2VycyA9IFtdKSkucHVzaCh0aGlzKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQ29sbGFwc2VkIG1hcmtlcnMgaGF2ZSB1bmlxdWUgaWRzLCBpbiBvcmRlciB0byBiZSBhYmxlIHRvIG9yZGVyXG4gIC8vIHRoZW0sIHdoaWNoIGlzIG5lZWRlZCBmb3IgdW5pcXVlbHkgZGV0ZXJtaW5pbmcgYW4gb3V0ZXIgbWFya2VyXG4gIC8vIHdoZW4gdGhleSBvdmVybGFwICh0aGV5IG1heSBuZXN0LCBidXQgbm90IHBhcnRpYWxseSBvdmVybGFwKS5cbiAgdmFyIG5leHRNYXJrZXJJZCA9IDA7XG5cbiAgLy8gQ3JlYXRlIGEgbWFya2VyLCB3aXJlIGl0IHVwIHRvIHRoZSByaWdodCBsaW5lcywgYW5kXG4gIGZ1bmN0aW9uIG1hcmtUZXh0KGRvYywgZnJvbSwgdG8sIG9wdGlvbnMsIHR5cGUpIHtcbiAgICAvLyBTaGFyZWQgbWFya2VycyAoYWNyb3NzIGxpbmtlZCBkb2N1bWVudHMpIGFyZSBoYW5kbGVkIHNlcGFyYXRlbHlcbiAgICAvLyAobWFya1RleHRTaGFyZWQgd2lsbCBjYWxsIG91dCB0byB0aGlzIGFnYWluLCBvbmNlIHBlclxuICAgIC8vIGRvY3VtZW50KS5cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnNoYXJlZCkgcmV0dXJuIG1hcmtUZXh0U2hhcmVkKGRvYywgZnJvbSwgdG8sIG9wdGlvbnMsIHR5cGUpO1xuICAgIC8vIEVuc3VyZSB3ZSBhcmUgaW4gYW4gb3BlcmF0aW9uLlxuICAgIGlmIChkb2MuY20gJiYgIWRvYy5jbS5jdXJPcCkgcmV0dXJuIG9wZXJhdGlvbihkb2MuY20sIG1hcmtUZXh0KShkb2MsIGZyb20sIHRvLCBvcHRpb25zLCB0eXBlKTtcblxuICAgIHZhciBtYXJrZXIgPSBuZXcgVGV4dE1hcmtlcihkb2MsIHR5cGUpLCBkaWZmID0gY21wKGZyb20sIHRvKTtcbiAgICBpZiAob3B0aW9ucykgY29weU9iaihvcHRpb25zLCBtYXJrZXIsIGZhbHNlKTtcbiAgICAvLyBEb24ndCBjb25uZWN0IGVtcHR5IG1hcmtlcnMgdW5sZXNzIGNsZWFyV2hlbkVtcHR5IGlzIGZhbHNlXG4gICAgaWYgKGRpZmYgPiAwIHx8IGRpZmYgPT0gMCAmJiBtYXJrZXIuY2xlYXJXaGVuRW1wdHkgIT09IGZhbHNlKVxuICAgICAgcmV0dXJuIG1hcmtlcjtcbiAgICBpZiAobWFya2VyLnJlcGxhY2VkV2l0aCkge1xuICAgICAgLy8gU2hvd2luZyB1cCBhcyBhIHdpZGdldCBpbXBsaWVzIGNvbGxhcHNlZCAod2lkZ2V0IHJlcGxhY2VzIHRleHQpXG4gICAgICBtYXJrZXIuY29sbGFwc2VkID0gdHJ1ZTtcbiAgICAgIG1hcmtlci53aWRnZXROb2RlID0gZWx0KFwic3BhblwiLCBbbWFya2VyLnJlcGxhY2VkV2l0aF0sIFwiQ29kZU1pcnJvci13aWRnZXRcIik7XG4gICAgICBpZiAoIW9wdGlvbnMuaGFuZGxlTW91c2VFdmVudHMpIG1hcmtlci53aWRnZXROb2RlLmlnbm9yZUV2ZW50cyA9IHRydWU7XG4gICAgICBpZiAob3B0aW9ucy5pbnNlcnRMZWZ0KSBtYXJrZXIud2lkZ2V0Tm9kZS5pbnNlcnRMZWZ0ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG1hcmtlci5jb2xsYXBzZWQpIHtcbiAgICAgIGlmIChjb25mbGljdGluZ0NvbGxhcHNlZFJhbmdlKGRvYywgZnJvbS5saW5lLCBmcm9tLCB0bywgbWFya2VyKSB8fFxuICAgICAgICAgIGZyb20ubGluZSAhPSB0by5saW5lICYmIGNvbmZsaWN0aW5nQ29sbGFwc2VkUmFuZ2UoZG9jLCB0by5saW5lLCBmcm9tLCB0bywgbWFya2VyKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5zZXJ0aW5nIGNvbGxhcHNlZCBtYXJrZXIgcGFydGlhbGx5IG92ZXJsYXBwaW5nIGFuIGV4aXN0aW5nIG9uZVwiKTtcbiAgICAgIHNhd0NvbGxhcHNlZFNwYW5zID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobWFya2VyLmFkZFRvSGlzdG9yeSlcbiAgICAgIGFkZENoYW5nZVRvSGlzdG9yeShkb2MsIHtmcm9tOiBmcm9tLCB0bzogdG8sIG9yaWdpbjogXCJtYXJrVGV4dFwifSwgZG9jLnNlbCwgTmFOKTtcblxuICAgIHZhciBjdXJMaW5lID0gZnJvbS5saW5lLCBjbSA9IGRvYy5jbSwgdXBkYXRlTWF4TGluZTtcbiAgICBkb2MuaXRlcihjdXJMaW5lLCB0by5saW5lICsgMSwgZnVuY3Rpb24obGluZSkge1xuICAgICAgaWYgKGNtICYmIG1hcmtlci5jb2xsYXBzZWQgJiYgIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nICYmIHZpc3VhbExpbmUobGluZSkgPT0gY20uZGlzcGxheS5tYXhMaW5lKVxuICAgICAgICB1cGRhdGVNYXhMaW5lID0gdHJ1ZTtcbiAgICAgIGlmIChtYXJrZXIuY29sbGFwc2VkICYmIGN1ckxpbmUgIT0gZnJvbS5saW5lKSB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIDApO1xuICAgICAgYWRkTWFya2VkU3BhbihsaW5lLCBuZXcgTWFya2VkU3BhbihtYXJrZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ckxpbmUgPT0gZnJvbS5saW5lID8gZnJvbS5jaCA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ckxpbmUgPT0gdG8ubGluZSA/IHRvLmNoIDogbnVsbCkpO1xuICAgICAgKytjdXJMaW5lO1xuICAgIH0pO1xuICAgIC8vIGxpbmVJc0hpZGRlbiBkZXBlbmRzIG9uIHRoZSBwcmVzZW5jZSBvZiB0aGUgc3BhbnMsIHNvIG5lZWRzIGEgc2Vjb25kIHBhc3NcbiAgICBpZiAobWFya2VyLmNvbGxhcHNlZCkgZG9jLml0ZXIoZnJvbS5saW5lLCB0by5saW5lICsgMSwgZnVuY3Rpb24obGluZSkge1xuICAgICAgaWYgKGxpbmVJc0hpZGRlbihkb2MsIGxpbmUpKSB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIDApO1xuICAgIH0pO1xuXG4gICAgaWYgKG1hcmtlci5jbGVhck9uRW50ZXIpIG9uKG1hcmtlciwgXCJiZWZvcmVDdXJzb3JFbnRlclwiLCBmdW5jdGlvbigpIHsgbWFya2VyLmNsZWFyKCk7IH0pO1xuXG4gICAgaWYgKG1hcmtlci5yZWFkT25seSkge1xuICAgICAgc2F3UmVhZE9ubHlTcGFucyA9IHRydWU7XG4gICAgICBpZiAoZG9jLmhpc3RvcnkuZG9uZS5sZW5ndGggfHwgZG9jLmhpc3RvcnkudW5kb25lLmxlbmd0aClcbiAgICAgICAgZG9jLmNsZWFySGlzdG9yeSgpO1xuICAgIH1cbiAgICBpZiAobWFya2VyLmNvbGxhcHNlZCkge1xuICAgICAgbWFya2VyLmlkID0gKytuZXh0TWFya2VySWQ7XG4gICAgICBtYXJrZXIuYXRvbWljID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGNtKSB7XG4gICAgICAvLyBTeW5jIGVkaXRvciBzdGF0ZVxuICAgICAgaWYgKHVwZGF0ZU1heExpbmUpIGNtLmN1ck9wLnVwZGF0ZU1heExpbmUgPSB0cnVlO1xuICAgICAgaWYgKG1hcmtlci5jb2xsYXBzZWQpXG4gICAgICAgIHJlZ0NoYW5nZShjbSwgZnJvbS5saW5lLCB0by5saW5lICsgMSk7XG4gICAgICBlbHNlIGlmIChtYXJrZXIuY2xhc3NOYW1lIHx8IG1hcmtlci50aXRsZSB8fCBtYXJrZXIuc3RhcnRTdHlsZSB8fCBtYXJrZXIuZW5kU3R5bGUpXG4gICAgICAgIGZvciAodmFyIGkgPSBmcm9tLmxpbmU7IGkgPD0gdG8ubGluZTsgaSsrKSByZWdMaW5lQ2hhbmdlKGNtLCBpLCBcInRleHRcIik7XG4gICAgICBpZiAobWFya2VyLmF0b21pYykgcmVDaGVja1NlbGVjdGlvbihjbS5kb2MpO1xuICAgICAgc2lnbmFsTGF0ZXIoY20sIFwibWFya2VyQWRkZWRcIiwgY20sIG1hcmtlcik7XG4gICAgfVxuICAgIHJldHVybiBtYXJrZXI7XG4gIH1cblxuICAvLyBTSEFSRUQgVEVYVE1BUktFUlNcblxuICAvLyBBIHNoYXJlZCBtYXJrZXIgc3BhbnMgbXVsdGlwbGUgbGlua2VkIGRvY3VtZW50cy4gSXQgaXNcbiAgLy8gaW1wbGVtZW50ZWQgYXMgYSBtZXRhLW1hcmtlci1vYmplY3QgY29udHJvbGxpbmcgbXVsdGlwbGUgbm9ybWFsXG4gIC8vIG1hcmtlcnMuXG4gIHZhciBTaGFyZWRUZXh0TWFya2VyID0gQ29kZU1pcnJvci5TaGFyZWRUZXh0TWFya2VyID0gZnVuY3Rpb24obWFya2VycywgcHJpbWFyeSkge1xuICAgIHRoaXMubWFya2VycyA9IG1hcmtlcnM7XG4gICAgdGhpcy5wcmltYXJ5ID0gcHJpbWFyeTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtlcnMubGVuZ3RoOyArK2kpXG4gICAgICBtYXJrZXJzW2ldLnBhcmVudCA9IHRoaXM7XG4gIH07XG4gIGV2ZW50TWl4aW4oU2hhcmVkVGV4dE1hcmtlcik7XG5cbiAgU2hhcmVkVGV4dE1hcmtlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5leHBsaWNpdGx5Q2xlYXJlZCkgcmV0dXJuO1xuICAgIHRoaXMuZXhwbGljaXRseUNsZWFyZWQgPSB0cnVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tYXJrZXJzLmxlbmd0aDsgKytpKVxuICAgICAgdGhpcy5tYXJrZXJzW2ldLmNsZWFyKCk7XG4gICAgc2lnbmFsTGF0ZXIodGhpcywgXCJjbGVhclwiKTtcbiAgfTtcbiAgU2hhcmVkVGV4dE1hcmtlci5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKHNpZGUsIGxpbmVPYmopIHtcbiAgICByZXR1cm4gdGhpcy5wcmltYXJ5LmZpbmQoc2lkZSwgbGluZU9iaik7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFya1RleHRTaGFyZWQoZG9jLCBmcm9tLCB0bywgb3B0aW9ucywgdHlwZSkge1xuICAgIG9wdGlvbnMgPSBjb3B5T2JqKG9wdGlvbnMpO1xuICAgIG9wdGlvbnMuc2hhcmVkID0gZmFsc2U7XG4gICAgdmFyIG1hcmtlcnMgPSBbbWFya1RleHQoZG9jLCBmcm9tLCB0bywgb3B0aW9ucywgdHlwZSldLCBwcmltYXJ5ID0gbWFya2Vyc1swXTtcbiAgICB2YXIgd2lkZ2V0ID0gb3B0aW9ucy53aWRnZXROb2RlO1xuICAgIGxpbmtlZERvY3MoZG9jLCBmdW5jdGlvbihkb2MpIHtcbiAgICAgIGlmICh3aWRnZXQpIG9wdGlvbnMud2lkZ2V0Tm9kZSA9IHdpZGdldC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICBtYXJrZXJzLnB1c2gobWFya1RleHQoZG9jLCBjbGlwUG9zKGRvYywgZnJvbSksIGNsaXBQb3MoZG9jLCB0byksIG9wdGlvbnMsIHR5cGUpKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9jLmxpbmtlZC5sZW5ndGg7ICsraSlcbiAgICAgICAgaWYgKGRvYy5saW5rZWRbaV0uaXNQYXJlbnQpIHJldHVybjtcbiAgICAgIHByaW1hcnkgPSBsc3QobWFya2Vycyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBTaGFyZWRUZXh0TWFya2VyKG1hcmtlcnMsIHByaW1hcnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZFNoYXJlZE1hcmtlcnMoZG9jKSB7XG4gICAgcmV0dXJuIGRvYy5maW5kTWFya3MoUG9zKGRvYy5maXJzdCwgMCksIGRvYy5jbGlwUG9zKFBvcyhkb2MubGFzdExpbmUoKSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKG0pIHsgcmV0dXJuIG0ucGFyZW50OyB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvcHlTaGFyZWRNYXJrZXJzKGRvYywgbWFya2Vycykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG1hcmtlciA9IG1hcmtlcnNbaV0sIHBvcyA9IG1hcmtlci5maW5kKCk7XG4gICAgICB2YXIgbUZyb20gPSBkb2MuY2xpcFBvcyhwb3MuZnJvbSksIG1UbyA9IGRvYy5jbGlwUG9zKHBvcy50byk7XG4gICAgICBpZiAoY21wKG1Gcm9tLCBtVG8pKSB7XG4gICAgICAgIHZhciBzdWJNYXJrID0gbWFya1RleHQoZG9jLCBtRnJvbSwgbVRvLCBtYXJrZXIucHJpbWFyeSwgbWFya2VyLnByaW1hcnkudHlwZSk7XG4gICAgICAgIG1hcmtlci5tYXJrZXJzLnB1c2goc3ViTWFyayk7XG4gICAgICAgIHN1Yk1hcmsucGFyZW50ID0gbWFya2VyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRldGFjaFNoYXJlZE1hcmtlcnMobWFya2Vycykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG1hcmtlciA9IG1hcmtlcnNbaV0sIGxpbmtlZCA9IFttYXJrZXIucHJpbWFyeS5kb2NdOztcbiAgICAgIGxpbmtlZERvY3MobWFya2VyLnByaW1hcnkuZG9jLCBmdW5jdGlvbihkKSB7IGxpbmtlZC5wdXNoKGQpOyB9KTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWFya2VyLm1hcmtlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIHN1Yk1hcmtlciA9IG1hcmtlci5tYXJrZXJzW2pdO1xuICAgICAgICBpZiAoaW5kZXhPZihsaW5rZWQsIHN1Yk1hcmtlci5kb2MpID09IC0xKSB7XG4gICAgICAgICAgc3ViTWFya2VyLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgbWFya2VyLm1hcmtlcnMuc3BsaWNlKGotLSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBURVhUTUFSS0VSIFNQQU5TXG5cbiAgZnVuY3Rpb24gTWFya2VkU3BhbihtYXJrZXIsIGZyb20sIHRvKSB7XG4gICAgdGhpcy5tYXJrZXIgPSBtYXJrZXI7XG4gICAgdGhpcy5mcm9tID0gZnJvbTsgdGhpcy50byA9IHRvO1xuICB9XG5cbiAgLy8gU2VhcmNoIGFuIGFycmF5IG9mIHNwYW5zIGZvciBhIHNwYW4gbWF0Y2hpbmcgdGhlIGdpdmVuIG1hcmtlci5cbiAgZnVuY3Rpb24gZ2V0TWFya2VkU3BhbkZvcihzcGFucywgbWFya2VyKSB7XG4gICAgaWYgKHNwYW5zKSBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgc3BhbiA9IHNwYW5zW2ldO1xuICAgICAgaWYgKHNwYW4ubWFya2VyID09IG1hcmtlcikgcmV0dXJuIHNwYW47XG4gICAgfVxuICB9XG4gIC8vIFJlbW92ZSBhIHNwYW4gZnJvbSBhbiBhcnJheSwgcmV0dXJuaW5nIHVuZGVmaW5lZCBpZiBubyBzcGFucyBhcmVcbiAgLy8gbGVmdCAod2UgZG9uJ3Qgc3RvcmUgYXJyYXlzIGZvciBsaW5lcyB3aXRob3V0IHNwYW5zKS5cbiAgZnVuY3Rpb24gcmVtb3ZlTWFya2VkU3BhbihzcGFucywgc3Bhbikge1xuICAgIGZvciAodmFyIHIsIGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyArK2kpXG4gICAgICBpZiAoc3BhbnNbaV0gIT0gc3BhbikgKHIgfHwgKHIgPSBbXSkpLnB1c2goc3BhbnNbaV0pO1xuICAgIHJldHVybiByO1xuICB9XG4gIC8vIEFkZCBhIHNwYW4gdG8gYSBsaW5lLlxuICBmdW5jdGlvbiBhZGRNYXJrZWRTcGFuKGxpbmUsIHNwYW4pIHtcbiAgICBsaW5lLm1hcmtlZFNwYW5zID0gbGluZS5tYXJrZWRTcGFucyA/IGxpbmUubWFya2VkU3BhbnMuY29uY2F0KFtzcGFuXSkgOiBbc3Bhbl07XG4gICAgc3Bhbi5tYXJrZXIuYXR0YWNoTGluZShsaW5lKTtcbiAgfVxuXG4gIC8vIFVzZWQgZm9yIHRoZSBhbGdvcml0aG0gdGhhdCBhZGp1c3RzIG1hcmtlcnMgZm9yIGEgY2hhbmdlIGluIHRoZVxuICAvLyBkb2N1bWVudC4gVGhlc2UgZnVuY3Rpb25zIGN1dCBhbiBhcnJheSBvZiBzcGFucyBhdCBhIGdpdmVuXG4gIC8vIGNoYXJhY3RlciBwb3NpdGlvbiwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIHJlbWFpbmluZyBjaHVua3MgKG9yXG4gIC8vIHVuZGVmaW5lZCBpZiBub3RoaW5nIHJlbWFpbnMpLlxuICBmdW5jdGlvbiBtYXJrZWRTcGFuc0JlZm9yZShvbGQsIHN0YXJ0Q2gsIGlzSW5zZXJ0KSB7XG4gICAgaWYgKG9sZCkgZm9yICh2YXIgaSA9IDAsIG53OyBpIDwgb2xkLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgc3BhbiA9IG9sZFtpXSwgbWFya2VyID0gc3Bhbi5tYXJrZXI7XG4gICAgICB2YXIgc3RhcnRzQmVmb3JlID0gc3Bhbi5mcm9tID09IG51bGwgfHwgKG1hcmtlci5pbmNsdXNpdmVMZWZ0ID8gc3Bhbi5mcm9tIDw9IHN0YXJ0Q2ggOiBzcGFuLmZyb20gPCBzdGFydENoKTtcbiAgICAgIGlmIChzdGFydHNCZWZvcmUgfHwgc3Bhbi5mcm9tID09IHN0YXJ0Q2ggJiYgbWFya2VyLnR5cGUgPT0gXCJib29rbWFya1wiICYmICghaXNJbnNlcnQgfHwgIXNwYW4ubWFya2VyLmluc2VydExlZnQpKSB7XG4gICAgICAgIHZhciBlbmRzQWZ0ZXIgPSBzcGFuLnRvID09IG51bGwgfHwgKG1hcmtlci5pbmNsdXNpdmVSaWdodCA/IHNwYW4udG8gPj0gc3RhcnRDaCA6IHNwYW4udG8gPiBzdGFydENoKTtcbiAgICAgICAgKG53IHx8IChudyA9IFtdKSkucHVzaChuZXcgTWFya2VkU3BhbihtYXJrZXIsIHNwYW4uZnJvbSwgZW5kc0FmdGVyID8gbnVsbCA6IHNwYW4udG8pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG53O1xuICB9XG4gIGZ1bmN0aW9uIG1hcmtlZFNwYW5zQWZ0ZXIob2xkLCBlbmRDaCwgaXNJbnNlcnQpIHtcbiAgICBpZiAob2xkKSBmb3IgKHZhciBpID0gMCwgbnc7IGkgPCBvbGQubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBzcGFuID0gb2xkW2ldLCBtYXJrZXIgPSBzcGFuLm1hcmtlcjtcbiAgICAgIHZhciBlbmRzQWZ0ZXIgPSBzcGFuLnRvID09IG51bGwgfHwgKG1hcmtlci5pbmNsdXNpdmVSaWdodCA/IHNwYW4udG8gPj0gZW5kQ2ggOiBzcGFuLnRvID4gZW5kQ2gpO1xuICAgICAgaWYgKGVuZHNBZnRlciB8fCBzcGFuLmZyb20gPT0gZW5kQ2ggJiYgbWFya2VyLnR5cGUgPT0gXCJib29rbWFya1wiICYmICghaXNJbnNlcnQgfHwgc3Bhbi5tYXJrZXIuaW5zZXJ0TGVmdCkpIHtcbiAgICAgICAgdmFyIHN0YXJ0c0JlZm9yZSA9IHNwYW4uZnJvbSA9PSBudWxsIHx8IChtYXJrZXIuaW5jbHVzaXZlTGVmdCA/IHNwYW4uZnJvbSA8PSBlbmRDaCA6IHNwYW4uZnJvbSA8IGVuZENoKTtcbiAgICAgICAgKG53IHx8IChudyA9IFtdKSkucHVzaChuZXcgTWFya2VkU3BhbihtYXJrZXIsIHN0YXJ0c0JlZm9yZSA/IG51bGwgOiBzcGFuLmZyb20gLSBlbmRDaCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuLnRvID09IG51bGwgPyBudWxsIDogc3Bhbi50byAtIGVuZENoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudztcbiAgfVxuXG4gIC8vIEdpdmVuIGEgY2hhbmdlIG9iamVjdCwgY29tcHV0ZSB0aGUgbmV3IHNldCBvZiBtYXJrZXIgc3BhbnMgdGhhdFxuICAvLyBjb3ZlciB0aGUgbGluZSBpbiB3aGljaCB0aGUgY2hhbmdlIHRvb2sgcGxhY2UuIFJlbW92ZXMgc3BhbnNcbiAgLy8gZW50aXJlbHkgd2l0aGluIHRoZSBjaGFuZ2UsIHJlY29ubmVjdHMgc3BhbnMgYmVsb25naW5nIHRvIHRoZVxuICAvLyBzYW1lIG1hcmtlciB0aGF0IGFwcGVhciBvbiBib3RoIHNpZGVzIG9mIHRoZSBjaGFuZ2UsIGFuZCBjdXRzIG9mZlxuICAvLyBzcGFucyBwYXJ0aWFsbHkgd2l0aGluIHRoZSBjaGFuZ2UuIFJldHVybnMgYW4gYXJyYXkgb2Ygc3BhblxuICAvLyBhcnJheXMgd2l0aCBvbmUgZWxlbWVudCBmb3IgZWFjaCBsaW5lIGluIChhZnRlcikgdGhlIGNoYW5nZS5cbiAgZnVuY3Rpb24gc3RyZXRjaFNwYW5zT3ZlckNoYW5nZShkb2MsIGNoYW5nZSkge1xuICAgIHZhciBvbGRGaXJzdCA9IGlzTGluZShkb2MsIGNoYW5nZS5mcm9tLmxpbmUpICYmIGdldExpbmUoZG9jLCBjaGFuZ2UuZnJvbS5saW5lKS5tYXJrZWRTcGFucztcbiAgICB2YXIgb2xkTGFzdCA9IGlzTGluZShkb2MsIGNoYW5nZS50by5saW5lKSAmJiBnZXRMaW5lKGRvYywgY2hhbmdlLnRvLmxpbmUpLm1hcmtlZFNwYW5zO1xuICAgIGlmICghb2xkRmlyc3QgJiYgIW9sZExhc3QpIHJldHVybiBudWxsO1xuXG4gICAgdmFyIHN0YXJ0Q2ggPSBjaGFuZ2UuZnJvbS5jaCwgZW5kQ2ggPSBjaGFuZ2UudG8uY2gsIGlzSW5zZXJ0ID0gY21wKGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8pID09IDA7XG4gICAgLy8gR2V0IHRoZSBzcGFucyB0aGF0ICdzdGljayBvdXQnIG9uIGJvdGggc2lkZXNcbiAgICB2YXIgZmlyc3QgPSBtYXJrZWRTcGFuc0JlZm9yZShvbGRGaXJzdCwgc3RhcnRDaCwgaXNJbnNlcnQpO1xuICAgIHZhciBsYXN0ID0gbWFya2VkU3BhbnNBZnRlcihvbGRMYXN0LCBlbmRDaCwgaXNJbnNlcnQpO1xuXG4gICAgLy8gTmV4dCwgbWVyZ2UgdGhvc2UgdHdvIGVuZHNcbiAgICB2YXIgc2FtZUxpbmUgPSBjaGFuZ2UudGV4dC5sZW5ndGggPT0gMSwgb2Zmc2V0ID0gbHN0KGNoYW5nZS50ZXh0KS5sZW5ndGggKyAoc2FtZUxpbmUgPyBzdGFydENoIDogMCk7XG4gICAgaWYgKGZpcnN0KSB7XG4gICAgICAvLyBGaXggdXAgLnRvIHByb3BlcnRpZXMgb2YgZmlyc3RcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlyc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHNwYW4gPSBmaXJzdFtpXTtcbiAgICAgICAgaWYgKHNwYW4udG8gPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBmb3VuZCA9IGdldE1hcmtlZFNwYW5Gb3IobGFzdCwgc3Bhbi5tYXJrZXIpO1xuICAgICAgICAgIGlmICghZm91bmQpIHNwYW4udG8gPSBzdGFydENoO1xuICAgICAgICAgIGVsc2UgaWYgKHNhbWVMaW5lKSBzcGFuLnRvID0gZm91bmQudG8gPT0gbnVsbCA/IG51bGwgOiBmb3VuZC50byArIG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGFzdCkge1xuICAgICAgLy8gRml4IHVwIC5mcm9tIGluIGxhc3QgKG9yIG1vdmUgdGhlbSBpbnRvIGZpcnN0IGluIGNhc2Ugb2Ygc2FtZUxpbmUpXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHNwYW4gPSBsYXN0W2ldO1xuICAgICAgICBpZiAoc3Bhbi50byAhPSBudWxsKSBzcGFuLnRvICs9IG9mZnNldDtcbiAgICAgICAgaWYgKHNwYW4uZnJvbSA9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGZvdW5kID0gZ2V0TWFya2VkU3BhbkZvcihmaXJzdCwgc3Bhbi5tYXJrZXIpO1xuICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgIHNwYW4uZnJvbSA9IG9mZnNldDtcbiAgICAgICAgICAgIGlmIChzYW1lTGluZSkgKGZpcnN0IHx8IChmaXJzdCA9IFtdKSkucHVzaChzcGFuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3Bhbi5mcm9tICs9IG9mZnNldDtcbiAgICAgICAgICBpZiAoc2FtZUxpbmUpIChmaXJzdCB8fCAoZmlyc3QgPSBbXSkpLnB1c2goc3Bhbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIHdlIGRpZG4ndCBjcmVhdGUgYW55IHplcm8tbGVuZ3RoIHNwYW5zXG4gICAgaWYgKGZpcnN0KSBmaXJzdCA9IGNsZWFyRW1wdHlTcGFucyhmaXJzdCk7XG4gICAgaWYgKGxhc3QgJiYgbGFzdCAhPSBmaXJzdCkgbGFzdCA9IGNsZWFyRW1wdHlTcGFucyhsYXN0KTtcblxuICAgIHZhciBuZXdNYXJrZXJzID0gW2ZpcnN0XTtcbiAgICBpZiAoIXNhbWVMaW5lKSB7XG4gICAgICAvLyBGaWxsIGdhcCB3aXRoIHdob2xlLWxpbmUtc3BhbnNcbiAgICAgIHZhciBnYXAgPSBjaGFuZ2UudGV4dC5sZW5ndGggLSAyLCBnYXBNYXJrZXJzO1xuICAgICAgaWYgKGdhcCA+IDAgJiYgZmlyc3QpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlyc3QubGVuZ3RoOyArK2kpXG4gICAgICAgICAgaWYgKGZpcnN0W2ldLnRvID09IG51bGwpXG4gICAgICAgICAgICAoZ2FwTWFya2VycyB8fCAoZ2FwTWFya2VycyA9IFtdKSkucHVzaChuZXcgTWFya2VkU3BhbihmaXJzdFtpXS5tYXJrZXIsIG51bGwsIG51bGwpKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2FwOyArK2kpXG4gICAgICAgIG5ld01hcmtlcnMucHVzaChnYXBNYXJrZXJzKTtcbiAgICAgIG5ld01hcmtlcnMucHVzaChsYXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld01hcmtlcnM7XG4gIH1cblxuICAvLyBSZW1vdmUgc3BhbnMgdGhhdCBhcmUgZW1wdHkgYW5kIGRvbid0IGhhdmUgYSBjbGVhcldoZW5FbXB0eVxuICAvLyBvcHRpb24gb2YgZmFsc2UuXG4gIGZ1bmN0aW9uIGNsZWFyRW1wdHlTcGFucyhzcGFucykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBzcGFuID0gc3BhbnNbaV07XG4gICAgICBpZiAoc3Bhbi5mcm9tICE9IG51bGwgJiYgc3Bhbi5mcm9tID09IHNwYW4udG8gJiYgc3Bhbi5tYXJrZXIuY2xlYXJXaGVuRW1wdHkgIT09IGZhbHNlKVxuICAgICAgICBzcGFucy5zcGxpY2UoaS0tLCAxKTtcbiAgICB9XG4gICAgaWYgKCFzcGFucy5sZW5ndGgpIHJldHVybiBudWxsO1xuICAgIHJldHVybiBzcGFucztcbiAgfVxuXG4gIC8vIFVzZWQgZm9yIHVuL3JlLWRvaW5nIGNoYW5nZXMgZnJvbSB0aGUgaGlzdG9yeS4gQ29tYmluZXMgdGhlXG4gIC8vIHJlc3VsdCBvZiBjb21wdXRpbmcgdGhlIGV4aXN0aW5nIHNwYW5zIHdpdGggdGhlIHNldCBvZiBzcGFucyB0aGF0XG4gIC8vIGV4aXN0ZWQgaW4gdGhlIGhpc3RvcnkgKHNvIHRoYXQgZGVsZXRpbmcgYXJvdW5kIGEgc3BhbiBhbmQgdGhlblxuICAvLyB1bmRvaW5nIGJyaW5ncyBiYWNrIHRoZSBzcGFuKS5cbiAgZnVuY3Rpb24gbWVyZ2VPbGRTcGFucyhkb2MsIGNoYW5nZSkge1xuICAgIHZhciBvbGQgPSBnZXRPbGRTcGFucyhkb2MsIGNoYW5nZSk7XG4gICAgdmFyIHN0cmV0Y2hlZCA9IHN0cmV0Y2hTcGFuc092ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpO1xuICAgIGlmICghb2xkKSByZXR1cm4gc3RyZXRjaGVkO1xuICAgIGlmICghc3RyZXRjaGVkKSByZXR1cm4gb2xkO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvbGQubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBvbGRDdXIgPSBvbGRbaV0sIHN0cmV0Y2hDdXIgPSBzdHJldGNoZWRbaV07XG4gICAgICBpZiAob2xkQ3VyICYmIHN0cmV0Y2hDdXIpIHtcbiAgICAgICAgc3BhbnM6IGZvciAodmFyIGogPSAwOyBqIDwgc3RyZXRjaEN1ci5sZW5ndGg7ICsraikge1xuICAgICAgICAgIHZhciBzcGFuID0gc3RyZXRjaEN1cltqXTtcbiAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IG9sZEN1ci5sZW5ndGg7ICsraylcbiAgICAgICAgICAgIGlmIChvbGRDdXJba10ubWFya2VyID09IHNwYW4ubWFya2VyKSBjb250aW51ZSBzcGFucztcbiAgICAgICAgICBvbGRDdXIucHVzaChzcGFuKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzdHJldGNoQ3VyKSB7XG4gICAgICAgIG9sZFtpXSA9IHN0cmV0Y2hDdXI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvbGQ7XG4gIH1cblxuICAvLyBVc2VkIHRvICdjbGlwJyBvdXQgcmVhZE9ubHkgcmFuZ2VzIHdoZW4gbWFraW5nIGEgY2hhbmdlLlxuICBmdW5jdGlvbiByZW1vdmVSZWFkT25seVJhbmdlcyhkb2MsIGZyb20sIHRvKSB7XG4gICAgdmFyIG1hcmtlcnMgPSBudWxsO1xuICAgIGRvYy5pdGVyKGZyb20ubGluZSwgdG8ubGluZSArIDEsIGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIGlmIChsaW5lLm1hcmtlZFNwYW5zKSBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmUubWFya2VkU3BhbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIG1hcmsgPSBsaW5lLm1hcmtlZFNwYW5zW2ldLm1hcmtlcjtcbiAgICAgICAgaWYgKG1hcmsucmVhZE9ubHkgJiYgKCFtYXJrZXJzIHx8IGluZGV4T2YobWFya2VycywgbWFyaykgPT0gLTEpKVxuICAgICAgICAgIChtYXJrZXJzIHx8IChtYXJrZXJzID0gW10pKS5wdXNoKG1hcmspO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghbWFya2VycykgcmV0dXJuIG51bGw7XG4gICAgdmFyIHBhcnRzID0gW3tmcm9tOiBmcm9tLCB0bzogdG99XTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBtayA9IG1hcmtlcnNbaV0sIG0gPSBtay5maW5kKDApO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXJ0cy5sZW5ndGg7ICsraikge1xuICAgICAgICB2YXIgcCA9IHBhcnRzW2pdO1xuICAgICAgICBpZiAoY21wKHAudG8sIG0uZnJvbSkgPCAwIHx8IGNtcChwLmZyb20sIG0udG8pID4gMCkgY29udGludWU7XG4gICAgICAgIHZhciBuZXdQYXJ0cyA9IFtqLCAxXSwgZGZyb20gPSBjbXAocC5mcm9tLCBtLmZyb20pLCBkdG8gPSBjbXAocC50bywgbS50byk7XG4gICAgICAgIGlmIChkZnJvbSA8IDAgfHwgIW1rLmluY2x1c2l2ZUxlZnQgJiYgIWRmcm9tKVxuICAgICAgICAgIG5ld1BhcnRzLnB1c2goe2Zyb206IHAuZnJvbSwgdG86IG0uZnJvbX0pO1xuICAgICAgICBpZiAoZHRvID4gMCB8fCAhbWsuaW5jbHVzaXZlUmlnaHQgJiYgIWR0bylcbiAgICAgICAgICBuZXdQYXJ0cy5wdXNoKHtmcm9tOiBtLnRvLCB0bzogcC50b30pO1xuICAgICAgICBwYXJ0cy5zcGxpY2UuYXBwbHkocGFydHMsIG5ld1BhcnRzKTtcbiAgICAgICAgaiArPSBuZXdQYXJ0cy5sZW5ndGggLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFydHM7XG4gIH1cblxuICAvLyBDb25uZWN0IG9yIGRpc2Nvbm5lY3Qgc3BhbnMgZnJvbSBhIGxpbmUuXG4gIGZ1bmN0aW9uIGRldGFjaE1hcmtlZFNwYW5zKGxpbmUpIHtcbiAgICB2YXIgc3BhbnMgPSBsaW5lLm1hcmtlZFNwYW5zO1xuICAgIGlmICghc3BhbnMpIHJldHVybjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgKytpKVxuICAgICAgc3BhbnNbaV0ubWFya2VyLmRldGFjaExpbmUobGluZSk7XG4gICAgbGluZS5tYXJrZWRTcGFucyA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gYXR0YWNoTWFya2VkU3BhbnMobGluZSwgc3BhbnMpIHtcbiAgICBpZiAoIXNwYW5zKSByZXR1cm47XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7ICsraSlcbiAgICAgIHNwYW5zW2ldLm1hcmtlci5hdHRhY2hMaW5lKGxpbmUpO1xuICAgIGxpbmUubWFya2VkU3BhbnMgPSBzcGFucztcbiAgfVxuXG4gIC8vIEhlbHBlcnMgdXNlZCB3aGVuIGNvbXB1dGluZyB3aGljaCBvdmVybGFwcGluZyBjb2xsYXBzZWQgc3BhblxuICAvLyBjb3VudHMgYXMgdGhlIGxhcmdlciBvbmUuXG4gIGZ1bmN0aW9uIGV4dHJhTGVmdChtYXJrZXIpIHsgcmV0dXJuIG1hcmtlci5pbmNsdXNpdmVMZWZ0ID8gLTEgOiAwOyB9XG4gIGZ1bmN0aW9uIGV4dHJhUmlnaHQobWFya2VyKSB7IHJldHVybiBtYXJrZXIuaW5jbHVzaXZlUmlnaHQgPyAxIDogMDsgfVxuXG4gIC8vIFJldHVybnMgYSBudW1iZXIgaW5kaWNhdGluZyB3aGljaCBvZiB0d28gb3ZlcmxhcHBpbmcgY29sbGFwc2VkXG4gIC8vIHNwYW5zIGlzIGxhcmdlciAoYW5kIHRodXMgaW5jbHVkZXMgdGhlIG90aGVyKS4gRmFsbHMgYmFjayB0b1xuICAvLyBjb21wYXJpbmcgaWRzIHdoZW4gdGhlIHNwYW5zIGNvdmVyIGV4YWN0bHkgdGhlIHNhbWUgcmFuZ2UuXG4gIGZ1bmN0aW9uIGNvbXBhcmVDb2xsYXBzZWRNYXJrZXJzKGEsIGIpIHtcbiAgICB2YXIgbGVuRGlmZiA9IGEubGluZXMubGVuZ3RoIC0gYi5saW5lcy5sZW5ndGg7XG4gICAgaWYgKGxlbkRpZmYgIT0gMCkgcmV0dXJuIGxlbkRpZmY7XG4gICAgdmFyIGFQb3MgPSBhLmZpbmQoKSwgYlBvcyA9IGIuZmluZCgpO1xuICAgIHZhciBmcm9tQ21wID0gY21wKGFQb3MuZnJvbSwgYlBvcy5mcm9tKSB8fCBleHRyYUxlZnQoYSkgLSBleHRyYUxlZnQoYik7XG4gICAgaWYgKGZyb21DbXApIHJldHVybiAtZnJvbUNtcDtcbiAgICB2YXIgdG9DbXAgPSBjbXAoYVBvcy50bywgYlBvcy50bykgfHwgZXh0cmFSaWdodChhKSAtIGV4dHJhUmlnaHQoYik7XG4gICAgaWYgKHRvQ21wKSByZXR1cm4gdG9DbXA7XG4gICAgcmV0dXJuIGIuaWQgLSBhLmlkO1xuICB9XG5cbiAgLy8gRmluZCBvdXQgd2hldGhlciBhIGxpbmUgZW5kcyBvciBzdGFydHMgaW4gYSBjb2xsYXBzZWQgc3Bhbi4gSWZcbiAgLy8gc28sIHJldHVybiB0aGUgbWFya2VyIGZvciB0aGF0IHNwYW4uXG4gIGZ1bmN0aW9uIGNvbGxhcHNlZFNwYW5BdFNpZGUobGluZSwgc3RhcnQpIHtcbiAgICB2YXIgc3BzID0gc2F3Q29sbGFwc2VkU3BhbnMgJiYgbGluZS5tYXJrZWRTcGFucywgZm91bmQ7XG4gICAgaWYgKHNwcykgZm9yICh2YXIgc3AsIGkgPSAwOyBpIDwgc3BzLmxlbmd0aDsgKytpKSB7XG4gICAgICBzcCA9IHNwc1tpXTtcbiAgICAgIGlmIChzcC5tYXJrZXIuY29sbGFwc2VkICYmIChzdGFydCA/IHNwLmZyb20gOiBzcC50bykgPT0gbnVsbCAmJlxuICAgICAgICAgICghZm91bmQgfHwgY29tcGFyZUNvbGxhcHNlZE1hcmtlcnMoZm91bmQsIHNwLm1hcmtlcikgPCAwKSlcbiAgICAgICAgZm91bmQgPSBzcC5tYXJrZXI7XG4gICAgfVxuICAgIHJldHVybiBmb3VuZDtcbiAgfVxuICBmdW5jdGlvbiBjb2xsYXBzZWRTcGFuQXRTdGFydChsaW5lKSB7IHJldHVybiBjb2xsYXBzZWRTcGFuQXRTaWRlKGxpbmUsIHRydWUpOyB9XG4gIGZ1bmN0aW9uIGNvbGxhcHNlZFNwYW5BdEVuZChsaW5lKSB7IHJldHVybiBjb2xsYXBzZWRTcGFuQXRTaWRlKGxpbmUsIGZhbHNlKTsgfVxuXG4gIC8vIFRlc3Qgd2hldGhlciB0aGVyZSBleGlzdHMgYSBjb2xsYXBzZWQgc3BhbiB0aGF0IHBhcnRpYWxseVxuICAvLyBvdmVybGFwcyAoY292ZXJzIHRoZSBzdGFydCBvciBlbmQsIGJ1dCBub3QgYm90aCkgb2YgYSBuZXcgc3Bhbi5cbiAgLy8gU3VjaCBvdmVybGFwIGlzIG5vdCBhbGxvd2VkLlxuICBmdW5jdGlvbiBjb25mbGljdGluZ0NvbGxhcHNlZFJhbmdlKGRvYywgbGluZU5vLCBmcm9tLCB0bywgbWFya2VyKSB7XG4gICAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgbGluZU5vKTtcbiAgICB2YXIgc3BzID0gc2F3Q29sbGFwc2VkU3BhbnMgJiYgbGluZS5tYXJrZWRTcGFucztcbiAgICBpZiAoc3BzKSBmb3IgKHZhciBpID0gMDsgaSA8IHNwcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHNwID0gc3BzW2ldO1xuICAgICAgaWYgKCFzcC5tYXJrZXIuY29sbGFwc2VkKSBjb250aW51ZTtcbiAgICAgIHZhciBmb3VuZCA9IHNwLm1hcmtlci5maW5kKDApO1xuICAgICAgdmFyIGZyb21DbXAgPSBjbXAoZm91bmQuZnJvbSwgZnJvbSkgfHwgZXh0cmFMZWZ0KHNwLm1hcmtlcikgLSBleHRyYUxlZnQobWFya2VyKTtcbiAgICAgIHZhciB0b0NtcCA9IGNtcChmb3VuZC50bywgdG8pIHx8IGV4dHJhUmlnaHQoc3AubWFya2VyKSAtIGV4dHJhUmlnaHQobWFya2VyKTtcbiAgICAgIGlmIChmcm9tQ21wID49IDAgJiYgdG9DbXAgPD0gMCB8fCBmcm9tQ21wIDw9IDAgJiYgdG9DbXAgPj0gMCkgY29udGludWU7XG4gICAgICBpZiAoZnJvbUNtcCA8PSAwICYmIChjbXAoZm91bmQudG8sIGZyb20pIHx8IGV4dHJhUmlnaHQoc3AubWFya2VyKSAtIGV4dHJhTGVmdChtYXJrZXIpKSA+IDAgfHxcbiAgICAgICAgICBmcm9tQ21wID49IDAgJiYgKGNtcChmb3VuZC5mcm9tLCB0bykgfHwgZXh0cmFMZWZ0KHNwLm1hcmtlcikgLSBleHRyYVJpZ2h0KG1hcmtlcikpIDwgMClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gQSB2aXN1YWwgbGluZSBpcyBhIGxpbmUgYXMgZHJhd24gb24gdGhlIHNjcmVlbi4gRm9sZGluZywgZm9yXG4gIC8vIGV4YW1wbGUsIGNhbiBjYXVzZSBtdWx0aXBsZSBsb2dpY2FsIGxpbmVzIHRvIGFwcGVhciBvbiB0aGUgc2FtZVxuICAvLyB2aXN1YWwgbGluZS4gVGhpcyBmaW5kcyB0aGUgc3RhcnQgb2YgdGhlIHZpc3VhbCBsaW5lIHRoYXQgdGhlXG4gIC8vIGdpdmVuIGxpbmUgaXMgcGFydCBvZiAodXN1YWxseSB0aGF0IGlzIHRoZSBsaW5lIGl0c2VsZikuXG4gIGZ1bmN0aW9uIHZpc3VhbExpbmUobGluZSkge1xuICAgIHZhciBtZXJnZWQ7XG4gICAgd2hpbGUgKG1lcmdlZCA9IGNvbGxhcHNlZFNwYW5BdFN0YXJ0KGxpbmUpKVxuICAgICAgbGluZSA9IG1lcmdlZC5maW5kKC0xLCB0cnVlKS5saW5lO1xuICAgIHJldHVybiBsaW5lO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhbiBhcnJheSBvZiBsb2dpY2FsIGxpbmVzIHRoYXQgY29udGludWUgdGhlIHZpc3VhbCBsaW5lXG4gIC8vIHN0YXJ0ZWQgYnkgdGhlIGFyZ3VtZW50LCBvciB1bmRlZmluZWQgaWYgdGhlcmUgYXJlIG5vIHN1Y2ggbGluZXMuXG4gIGZ1bmN0aW9uIHZpc3VhbExpbmVDb250aW51ZWQobGluZSkge1xuICAgIHZhciBtZXJnZWQsIGxpbmVzO1xuICAgIHdoaWxlIChtZXJnZWQgPSBjb2xsYXBzZWRTcGFuQXRFbmQobGluZSkpIHtcbiAgICAgIGxpbmUgPSBtZXJnZWQuZmluZCgxLCB0cnVlKS5saW5lO1xuICAgICAgKGxpbmVzIHx8IChsaW5lcyA9IFtdKSkucHVzaChsaW5lKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmVzO1xuICB9XG5cbiAgLy8gR2V0IHRoZSBsaW5lIG51bWJlciBvZiB0aGUgc3RhcnQgb2YgdGhlIHZpc3VhbCBsaW5lIHRoYXQgdGhlXG4gIC8vIGdpdmVuIGxpbmUgbnVtYmVyIGlzIHBhcnQgb2YuXG4gIGZ1bmN0aW9uIHZpc3VhbExpbmVObyhkb2MsIGxpbmVOKSB7XG4gICAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgbGluZU4pLCB2aXMgPSB2aXN1YWxMaW5lKGxpbmUpO1xuICAgIGlmIChsaW5lID09IHZpcykgcmV0dXJuIGxpbmVOO1xuICAgIHJldHVybiBsaW5lTm8odmlzKTtcbiAgfVxuICAvLyBHZXQgdGhlIGxpbmUgbnVtYmVyIG9mIHRoZSBzdGFydCBvZiB0aGUgbmV4dCB2aXN1YWwgbGluZSBhZnRlclxuICAvLyB0aGUgZ2l2ZW4gbGluZS5cbiAgZnVuY3Rpb24gdmlzdWFsTGluZUVuZE5vKGRvYywgbGluZU4pIHtcbiAgICBpZiAobGluZU4gPiBkb2MubGFzdExpbmUoKSkgcmV0dXJuIGxpbmVOO1xuICAgIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIGxpbmVOKSwgbWVyZ2VkO1xuICAgIGlmICghbGluZUlzSGlkZGVuKGRvYywgbGluZSkpIHJldHVybiBsaW5lTjtcbiAgICB3aGlsZSAobWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0RW5kKGxpbmUpKVxuICAgICAgbGluZSA9IG1lcmdlZC5maW5kKDEsIHRydWUpLmxpbmU7XG4gICAgcmV0dXJuIGxpbmVObyhsaW5lKSArIDE7XG4gIH1cblxuICAvLyBDb21wdXRlIHdoZXRoZXIgYSBsaW5lIGlzIGhpZGRlbi4gTGluZXMgY291bnQgYXMgaGlkZGVuIHdoZW4gdGhleVxuICAvLyBhcmUgcGFydCBvZiBhIHZpc3VhbCBsaW5lIHRoYXQgc3RhcnRzIHdpdGggYW5vdGhlciBsaW5lLCBvciB3aGVuXG4gIC8vIHRoZXkgYXJlIGVudGlyZWx5IGNvdmVyZWQgYnkgY29sbGFwc2VkLCBub24td2lkZ2V0IHNwYW4uXG4gIGZ1bmN0aW9uIGxpbmVJc0hpZGRlbihkb2MsIGxpbmUpIHtcbiAgICB2YXIgc3BzID0gc2F3Q29sbGFwc2VkU3BhbnMgJiYgbGluZS5tYXJrZWRTcGFucztcbiAgICBpZiAoc3BzKSBmb3IgKHZhciBzcCwgaSA9IDA7IGkgPCBzcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHNwID0gc3BzW2ldO1xuICAgICAgaWYgKCFzcC5tYXJrZXIuY29sbGFwc2VkKSBjb250aW51ZTtcbiAgICAgIGlmIChzcC5mcm9tID09IG51bGwpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHNwLm1hcmtlci53aWRnZXROb2RlKSBjb250aW51ZTtcbiAgICAgIGlmIChzcC5mcm9tID09IDAgJiYgc3AubWFya2VyLmluY2x1c2l2ZUxlZnQgJiYgbGluZUlzSGlkZGVuSW5uZXIoZG9jLCBsaW5lLCBzcCkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBsaW5lSXNIaWRkZW5Jbm5lcihkb2MsIGxpbmUsIHNwYW4pIHtcbiAgICBpZiAoc3Bhbi50byA9PSBudWxsKSB7XG4gICAgICB2YXIgZW5kID0gc3Bhbi5tYXJrZXIuZmluZCgxLCB0cnVlKTtcbiAgICAgIHJldHVybiBsaW5lSXNIaWRkZW5Jbm5lcihkb2MsIGVuZC5saW5lLCBnZXRNYXJrZWRTcGFuRm9yKGVuZC5saW5lLm1hcmtlZFNwYW5zLCBzcGFuLm1hcmtlcikpO1xuICAgIH1cbiAgICBpZiAoc3Bhbi5tYXJrZXIuaW5jbHVzaXZlUmlnaHQgJiYgc3Bhbi50byA9PSBsaW5lLnRleHQubGVuZ3RoKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZm9yICh2YXIgc3AsIGkgPSAwOyBpIDwgbGluZS5tYXJrZWRTcGFucy5sZW5ndGg7ICsraSkge1xuICAgICAgc3AgPSBsaW5lLm1hcmtlZFNwYW5zW2ldO1xuICAgICAgaWYgKHNwLm1hcmtlci5jb2xsYXBzZWQgJiYgIXNwLm1hcmtlci53aWRnZXROb2RlICYmIHNwLmZyb20gPT0gc3Bhbi50byAmJlxuICAgICAgICAgIChzcC50byA9PSBudWxsIHx8IHNwLnRvICE9IHNwYW4uZnJvbSkgJiZcbiAgICAgICAgICAoc3AubWFya2VyLmluY2x1c2l2ZUxlZnQgfHwgc3Bhbi5tYXJrZXIuaW5jbHVzaXZlUmlnaHQpICYmXG4gICAgICAgICAgbGluZUlzSGlkZGVuSW5uZXIoZG9jLCBsaW5lLCBzcCkpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIExJTkUgV0lER0VUU1xuXG4gIC8vIExpbmUgd2lkZ2V0cyBhcmUgYmxvY2sgZWxlbWVudHMgZGlzcGxheWVkIGFib3ZlIG9yIGJlbG93IGEgbGluZS5cblxuICB2YXIgTGluZVdpZGdldCA9IENvZGVNaXJyb3IuTGluZVdpZGdldCA9IGZ1bmN0aW9uKGNtLCBub2RlLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMpIGZvciAodmFyIG9wdCBpbiBvcHRpb25zKSBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShvcHQpKVxuICAgICAgdGhpc1tvcHRdID0gb3B0aW9uc1tvcHRdO1xuICAgIHRoaXMuY20gPSBjbTtcbiAgICB0aGlzLm5vZGUgPSBub2RlO1xuICB9O1xuICBldmVudE1peGluKExpbmVXaWRnZXQpO1xuXG4gIGZ1bmN0aW9uIGFkanVzdFNjcm9sbFdoZW5BYm92ZVZpc2libGUoY20sIGxpbmUsIGRpZmYpIHtcbiAgICBpZiAoaGVpZ2h0QXRMaW5lKGxpbmUpIDwgKChjbS5jdXJPcCAmJiBjbS5jdXJPcC5zY3JvbGxUb3ApIHx8IGNtLmRvYy5zY3JvbGxUb3ApKVxuICAgICAgYWRkVG9TY3JvbGxQb3MoY20sIG51bGwsIGRpZmYpO1xuICB9XG5cbiAgTGluZVdpZGdldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY20gPSB0aGlzLmNtLCB3cyA9IHRoaXMubGluZS53aWRnZXRzLCBsaW5lID0gdGhpcy5saW5lLCBubyA9IGxpbmVObyhsaW5lKTtcbiAgICBpZiAobm8gPT0gbnVsbCB8fCAhd3MpIHJldHVybjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdzLmxlbmd0aDsgKytpKSBpZiAod3NbaV0gPT0gdGhpcykgd3Muc3BsaWNlKGktLSwgMSk7XG4gICAgaWYgKCF3cy5sZW5ndGgpIGxpbmUud2lkZ2V0cyA9IG51bGw7XG4gICAgdmFyIGhlaWdodCA9IHdpZGdldEhlaWdodCh0aGlzKTtcbiAgICBydW5Jbk9wKGNtLCBmdW5jdGlvbigpIHtcbiAgICAgIGFkanVzdFNjcm9sbFdoZW5BYm92ZVZpc2libGUoY20sIGxpbmUsIC1oZWlnaHQpO1xuICAgICAgcmVnTGluZUNoYW5nZShjbSwgbm8sIFwid2lkZ2V0XCIpO1xuICAgICAgdXBkYXRlTGluZUhlaWdodChsaW5lLCBNYXRoLm1heCgwLCBsaW5lLmhlaWdodCAtIGhlaWdodCkpO1xuICAgIH0pO1xuICB9O1xuICBMaW5lV2lkZ2V0LnByb3RvdHlwZS5jaGFuZ2VkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9sZEggPSB0aGlzLmhlaWdodCwgY20gPSB0aGlzLmNtLCBsaW5lID0gdGhpcy5saW5lO1xuICAgIHRoaXMuaGVpZ2h0ID0gbnVsbDtcbiAgICB2YXIgZGlmZiA9IHdpZGdldEhlaWdodCh0aGlzKSAtIG9sZEg7XG4gICAgaWYgKCFkaWZmKSByZXR1cm47XG4gICAgcnVuSW5PcChjbSwgZnVuY3Rpb24oKSB7XG4gICAgICBjbS5jdXJPcC5mb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgICBhZGp1c3RTY3JvbGxXaGVuQWJvdmVWaXNpYmxlKGNtLCBsaW5lLCBkaWZmKTtcbiAgICAgIHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgbGluZS5oZWlnaHQgKyBkaWZmKTtcbiAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiB3aWRnZXRIZWlnaHQod2lkZ2V0KSB7XG4gICAgaWYgKHdpZGdldC5oZWlnaHQgIT0gbnVsbCkgcmV0dXJuIHdpZGdldC5oZWlnaHQ7XG4gICAgaWYgKCFjb250YWlucyhkb2N1bWVudC5ib2R5LCB3aWRnZXQubm9kZSkpXG4gICAgICByZW1vdmVDaGlsZHJlbkFuZEFkZCh3aWRnZXQuY20uZGlzcGxheS5tZWFzdXJlLCBlbHQoXCJkaXZcIiwgW3dpZGdldC5ub2RlXSwgbnVsbCwgXCJwb3NpdGlvbjogcmVsYXRpdmVcIikpO1xuICAgIHJldHVybiB3aWRnZXQuaGVpZ2h0ID0gd2lkZ2V0Lm5vZGUub2Zmc2V0SGVpZ2h0O1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkTGluZVdpZGdldChjbSwgaGFuZGxlLCBub2RlLCBvcHRpb25zKSB7XG4gICAgdmFyIHdpZGdldCA9IG5ldyBMaW5lV2lkZ2V0KGNtLCBub2RlLCBvcHRpb25zKTtcbiAgICBpZiAod2lkZ2V0Lm5vSFNjcm9sbCkgY20uZGlzcGxheS5hbGlnbldpZGdldHMgPSB0cnVlO1xuICAgIGNoYW5nZUxpbmUoY20sIGhhbmRsZSwgXCJ3aWRnZXRcIiwgZnVuY3Rpb24obGluZSkge1xuICAgICAgdmFyIHdpZGdldHMgPSBsaW5lLndpZGdldHMgfHwgKGxpbmUud2lkZ2V0cyA9IFtdKTtcbiAgICAgIGlmICh3aWRnZXQuaW5zZXJ0QXQgPT0gbnVsbCkgd2lkZ2V0cy5wdXNoKHdpZGdldCk7XG4gICAgICBlbHNlIHdpZGdldHMuc3BsaWNlKE1hdGgubWluKHdpZGdldHMubGVuZ3RoIC0gMSwgTWF0aC5tYXgoMCwgd2lkZ2V0Lmluc2VydEF0KSksIDAsIHdpZGdldCk7XG4gICAgICB3aWRnZXQubGluZSA9IGxpbmU7XG4gICAgICBpZiAoIWxpbmVJc0hpZGRlbihjbS5kb2MsIGxpbmUpKSB7XG4gICAgICAgIHZhciBhYm92ZVZpc2libGUgPSBoZWlnaHRBdExpbmUobGluZSkgPCBjbS5kb2Muc2Nyb2xsVG9wO1xuICAgICAgICB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIGxpbmUuaGVpZ2h0ICsgd2lkZ2V0SGVpZ2h0KHdpZGdldCkpO1xuICAgICAgICBpZiAoYWJvdmVWaXNpYmxlKSBhZGRUb1Njcm9sbFBvcyhjbSwgbnVsbCwgd2lkZ2V0LmhlaWdodCk7XG4gICAgICAgIGNtLmN1ck9wLmZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiB3aWRnZXQ7XG4gIH1cblxuICAvLyBMSU5FIERBVEEgU1RSVUNUVVJFXG5cbiAgLy8gTGluZSBvYmplY3RzLiBUaGVzZSBob2xkIHN0YXRlIHJlbGF0ZWQgdG8gYSBsaW5lLCBpbmNsdWRpbmdcbiAgLy8gaGlnaGxpZ2h0aW5nIGluZm8gKHRoZSBzdHlsZXMgYXJyYXkpLlxuICB2YXIgTGluZSA9IENvZGVNaXJyb3IuTGluZSA9IGZ1bmN0aW9uKHRleHQsIG1hcmtlZFNwYW5zLCBlc3RpbWF0ZUhlaWdodCkge1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgYXR0YWNoTWFya2VkU3BhbnModGhpcywgbWFya2VkU3BhbnMpO1xuICAgIHRoaXMuaGVpZ2h0ID0gZXN0aW1hdGVIZWlnaHQgPyBlc3RpbWF0ZUhlaWdodCh0aGlzKSA6IDE7XG4gIH07XG4gIGV2ZW50TWl4aW4oTGluZSk7XG4gIExpbmUucHJvdG90eXBlLmxpbmVObyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gbGluZU5vKHRoaXMpOyB9O1xuXG4gIC8vIENoYW5nZSB0aGUgY29udGVudCAodGV4dCwgbWFya2Vycykgb2YgYSBsaW5lLiBBdXRvbWF0aWNhbGx5XG4gIC8vIGludmFsaWRhdGVzIGNhY2hlZCBpbmZvcm1hdGlvbiBhbmQgdHJpZXMgdG8gcmUtZXN0aW1hdGUgdGhlXG4gIC8vIGxpbmUncyBoZWlnaHQuXG4gIGZ1bmN0aW9uIHVwZGF0ZUxpbmUobGluZSwgdGV4dCwgbWFya2VkU3BhbnMsIGVzdGltYXRlSGVpZ2h0KSB7XG4gICAgbGluZS50ZXh0ID0gdGV4dDtcbiAgICBpZiAobGluZS5zdGF0ZUFmdGVyKSBsaW5lLnN0YXRlQWZ0ZXIgPSBudWxsO1xuICAgIGlmIChsaW5lLnN0eWxlcykgbGluZS5zdHlsZXMgPSBudWxsO1xuICAgIGlmIChsaW5lLm9yZGVyICE9IG51bGwpIGxpbmUub3JkZXIgPSBudWxsO1xuICAgIGRldGFjaE1hcmtlZFNwYW5zKGxpbmUpO1xuICAgIGF0dGFjaE1hcmtlZFNwYW5zKGxpbmUsIG1hcmtlZFNwYW5zKTtcbiAgICB2YXIgZXN0SGVpZ2h0ID0gZXN0aW1hdGVIZWlnaHQgPyBlc3RpbWF0ZUhlaWdodChsaW5lKSA6IDE7XG4gICAgaWYgKGVzdEhlaWdodCAhPSBsaW5lLmhlaWdodCkgdXBkYXRlTGluZUhlaWdodChsaW5lLCBlc3RIZWlnaHQpO1xuICB9XG5cbiAgLy8gRGV0YWNoIGEgbGluZSBmcm9tIHRoZSBkb2N1bWVudCB0cmVlIGFuZCBpdHMgbWFya2Vycy5cbiAgZnVuY3Rpb24gY2xlYW5VcExpbmUobGluZSkge1xuICAgIGxpbmUucGFyZW50ID0gbnVsbDtcbiAgICBkZXRhY2hNYXJrZWRTcGFucyhsaW5lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dHJhY3RMaW5lQ2xhc3Nlcyh0eXBlLCBvdXRwdXQpIHtcbiAgICBpZiAodHlwZSkgZm9yICg7Oykge1xuICAgICAgdmFyIGxpbmVDbGFzcyA9IHR5cGUubWF0Y2goLyg/Ol58XFxzKylsaW5lLShiYWNrZ3JvdW5kLSk/KFxcUyspLyk7XG4gICAgICBpZiAoIWxpbmVDbGFzcykgYnJlYWs7XG4gICAgICB0eXBlID0gdHlwZS5zbGljZSgwLCBsaW5lQ2xhc3MuaW5kZXgpICsgdHlwZS5zbGljZShsaW5lQ2xhc3MuaW5kZXggKyBsaW5lQ2xhc3NbMF0ubGVuZ3RoKTtcbiAgICAgIHZhciBwcm9wID0gbGluZUNsYXNzWzFdID8gXCJiZ0NsYXNzXCIgOiBcInRleHRDbGFzc1wiO1xuICAgICAgaWYgKG91dHB1dFtwcm9wXSA9PSBudWxsKVxuICAgICAgICBvdXRwdXRbcHJvcF0gPSBsaW5lQ2xhc3NbMl07XG4gICAgICBlbHNlIGlmICghKG5ldyBSZWdFeHAoXCIoPzpefFxccylcIiArIGxpbmVDbGFzc1syXSArIFwiKD86JHxcXHMpXCIpKS50ZXN0KG91dHB1dFtwcm9wXSkpXG4gICAgICAgIG91dHB1dFtwcm9wXSArPSBcIiBcIiArIGxpbmVDbGFzc1syXTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjYWxsQmxhbmtMaW5lKG1vZGUsIHN0YXRlKSB7XG4gICAgaWYgKG1vZGUuYmxhbmtMaW5lKSByZXR1cm4gbW9kZS5ibGFua0xpbmUoc3RhdGUpO1xuICAgIGlmICghbW9kZS5pbm5lck1vZGUpIHJldHVybjtcbiAgICB2YXIgaW5uZXIgPSBDb2RlTWlycm9yLmlubmVyTW9kZShtb2RlLCBzdGF0ZSk7XG4gICAgaWYgKGlubmVyLm1vZGUuYmxhbmtMaW5lKSByZXR1cm4gaW5uZXIubW9kZS5ibGFua0xpbmUoaW5uZXIuc3RhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFRva2VuKG1vZGUsIHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgc3R5bGUgPSBtb2RlLnRva2VuKHN0cmVhbSwgc3RhdGUpO1xuICAgIGlmIChzdHJlYW0ucG9zIDw9IHN0cmVhbS5zdGFydClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1vZGUgXCIgKyBtb2RlLm5hbWUgKyBcIiBmYWlsZWQgdG8gYWR2YW5jZSBzdHJlYW0uXCIpO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuXG4gIC8vIFJ1biB0aGUgZ2l2ZW4gbW9kZSdzIHBhcnNlciBvdmVyIGEgbGluZSwgY2FsbGluZyBmIGZvciBlYWNoIHRva2VuLlxuICBmdW5jdGlvbiBydW5Nb2RlKGNtLCB0ZXh0LCBtb2RlLCBzdGF0ZSwgZiwgbGluZUNsYXNzZXMsIGZvcmNlVG9FbmQpIHtcbiAgICB2YXIgZmxhdHRlblNwYW5zID0gbW9kZS5mbGF0dGVuU3BhbnM7XG4gICAgaWYgKGZsYXR0ZW5TcGFucyA9PSBudWxsKSBmbGF0dGVuU3BhbnMgPSBjbS5vcHRpb25zLmZsYXR0ZW5TcGFucztcbiAgICB2YXIgY3VyU3RhcnQgPSAwLCBjdXJTdHlsZSA9IG51bGw7XG4gICAgdmFyIHN0cmVhbSA9IG5ldyBTdHJpbmdTdHJlYW0odGV4dCwgY20ub3B0aW9ucy50YWJTaXplKSwgc3R5bGU7XG4gICAgaWYgKHRleHQgPT0gXCJcIikgZXh0cmFjdExpbmVDbGFzc2VzKGNhbGxCbGFua0xpbmUobW9kZSwgc3RhdGUpLCBsaW5lQ2xhc3Nlcyk7XG4gICAgd2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcbiAgICAgIGlmIChzdHJlYW0ucG9zID4gY20ub3B0aW9ucy5tYXhIaWdobGlnaHRMZW5ndGgpIHtcbiAgICAgICAgZmxhdHRlblNwYW5zID0gZmFsc2U7XG4gICAgICAgIGlmIChmb3JjZVRvRW5kKSBwcm9jZXNzTGluZShjbSwgdGV4dCwgc3RhdGUsIHN0cmVhbS5wb3MpO1xuICAgICAgICBzdHJlYW0ucG9zID0gdGV4dC5sZW5ndGg7XG4gICAgICAgIHN0eWxlID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlID0gZXh0cmFjdExpbmVDbGFzc2VzKHJlYWRUb2tlbihtb2RlLCBzdHJlYW0sIHN0YXRlKSwgbGluZUNsYXNzZXMpO1xuICAgICAgfVxuICAgICAgaWYgKGNtLm9wdGlvbnMuYWRkTW9kZUNsYXNzKSB7XG4gICAgICAgIHZhciBtTmFtZSA9IENvZGVNaXJyb3IuaW5uZXJNb2RlKG1vZGUsIHN0YXRlKS5tb2RlLm5hbWU7XG4gICAgICAgIGlmIChtTmFtZSkgc3R5bGUgPSBcIm0tXCIgKyAoc3R5bGUgPyBtTmFtZSArIFwiIFwiICsgc3R5bGUgOiBtTmFtZSk7XG4gICAgICB9XG4gICAgICBpZiAoIWZsYXR0ZW5TcGFucyB8fCBjdXJTdHlsZSAhPSBzdHlsZSkge1xuICAgICAgICBpZiAoY3VyU3RhcnQgPCBzdHJlYW0uc3RhcnQpIGYoc3RyZWFtLnN0YXJ0LCBjdXJTdHlsZSk7XG4gICAgICAgIGN1clN0YXJ0ID0gc3RyZWFtLnN0YXJ0OyBjdXJTdHlsZSA9IHN0eWxlO1xuICAgICAgfVxuICAgICAgc3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvcztcbiAgICB9XG4gICAgd2hpbGUgKGN1clN0YXJ0IDwgc3RyZWFtLnBvcykge1xuICAgICAgLy8gV2Via2l0IHNlZW1zIHRvIHJlZnVzZSB0byByZW5kZXIgdGV4dCBub2RlcyBsb25nZXIgdGhhbiA1NzQ0NCBjaGFyYWN0ZXJzXG4gICAgICB2YXIgcG9zID0gTWF0aC5taW4oc3RyZWFtLnBvcywgY3VyU3RhcnQgKyA1MDAwMCk7XG4gICAgICBmKHBvcywgY3VyU3R5bGUpO1xuICAgICAgY3VyU3RhcnQgPSBwb3M7XG4gICAgfVxuICB9XG5cbiAgLy8gQ29tcHV0ZSBhIHN0eWxlIGFycmF5IChhbiBhcnJheSBzdGFydGluZyB3aXRoIGEgbW9kZSBnZW5lcmF0aW9uXG4gIC8vIC0tIGZvciBpbnZhbGlkYXRpb24gLS0gZm9sbG93ZWQgYnkgcGFpcnMgb2YgZW5kIHBvc2l0aW9ucyBhbmRcbiAgLy8gc3R5bGUgc3RyaW5ncyksIHdoaWNoIGlzIHVzZWQgdG8gaGlnaGxpZ2h0IHRoZSB0b2tlbnMgb24gdGhlXG4gIC8vIGxpbmUuXG4gIGZ1bmN0aW9uIGhpZ2hsaWdodExpbmUoY20sIGxpbmUsIHN0YXRlLCBmb3JjZVRvRW5kKSB7XG4gICAgLy8gQSBzdHlsZXMgYXJyYXkgYWx3YXlzIHN0YXJ0cyB3aXRoIGEgbnVtYmVyIGlkZW50aWZ5aW5nIHRoZVxuICAgIC8vIG1vZGUvb3ZlcmxheXMgdGhhdCBpdCBpcyBiYXNlZCBvbiAoZm9yIGVhc3kgaW52YWxpZGF0aW9uKS5cbiAgICB2YXIgc3QgPSBbY20uc3RhdGUubW9kZUdlbl0sIGxpbmVDbGFzc2VzID0ge307XG4gICAgLy8gQ29tcHV0ZSB0aGUgYmFzZSBhcnJheSBvZiBzdHlsZXNcbiAgICBydW5Nb2RlKGNtLCBsaW5lLnRleHQsIGNtLmRvYy5tb2RlLCBzdGF0ZSwgZnVuY3Rpb24oZW5kLCBzdHlsZSkge1xuICAgICAgc3QucHVzaChlbmQsIHN0eWxlKTtcbiAgICB9LCBsaW5lQ2xhc3NlcywgZm9yY2VUb0VuZCk7XG5cbiAgICAvLyBSdW4gb3ZlcmxheXMsIGFkanVzdCBzdHlsZSBhcnJheS5cbiAgICBmb3IgKHZhciBvID0gMDsgbyA8IGNtLnN0YXRlLm92ZXJsYXlzLmxlbmd0aDsgKytvKSB7XG4gICAgICB2YXIgb3ZlcmxheSA9IGNtLnN0YXRlLm92ZXJsYXlzW29dLCBpID0gMSwgYXQgPSAwO1xuICAgICAgcnVuTW9kZShjbSwgbGluZS50ZXh0LCBvdmVybGF5Lm1vZGUsIHRydWUsIGZ1bmN0aW9uKGVuZCwgc3R5bGUpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gaTtcbiAgICAgICAgLy8gRW5zdXJlIHRoZXJlJ3MgYSB0b2tlbiBlbmQgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24sIGFuZCB0aGF0IGkgcG9pbnRzIGF0IGl0XG4gICAgICAgIHdoaWxlIChhdCA8IGVuZCkge1xuICAgICAgICAgIHZhciBpX2VuZCA9IHN0W2ldO1xuICAgICAgICAgIGlmIChpX2VuZCA+IGVuZClcbiAgICAgICAgICAgIHN0LnNwbGljZShpLCAxLCBlbmQsIHN0W2krMV0sIGlfZW5kKTtcbiAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgYXQgPSBNYXRoLm1pbihlbmQsIGlfZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0eWxlKSByZXR1cm47XG4gICAgICAgIGlmIChvdmVybGF5Lm9wYXF1ZSkge1xuICAgICAgICAgIHN0LnNwbGljZShzdGFydCwgaSAtIHN0YXJ0LCBlbmQsIFwiY20tb3ZlcmxheSBcIiArIHN0eWxlKTtcbiAgICAgICAgICBpID0gc3RhcnQgKyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoOyBzdGFydCA8IGk7IHN0YXJ0ICs9IDIpIHtcbiAgICAgICAgICAgIHZhciBjdXIgPSBzdFtzdGFydCsxXTtcbiAgICAgICAgICAgIHN0W3N0YXJ0KzFdID0gKGN1ciA/IGN1ciArIFwiIFwiIDogXCJcIikgKyBcImNtLW92ZXJsYXkgXCIgKyBzdHlsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIGxpbmVDbGFzc2VzKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge3N0eWxlczogc3QsIGNsYXNzZXM6IGxpbmVDbGFzc2VzLmJnQ2xhc3MgfHwgbGluZUNsYXNzZXMudGV4dENsYXNzID8gbGluZUNsYXNzZXMgOiBudWxsfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldExpbmVTdHlsZXMoY20sIGxpbmUpIHtcbiAgICBpZiAoIWxpbmUuc3R5bGVzIHx8IGxpbmUuc3R5bGVzWzBdICE9IGNtLnN0YXRlLm1vZGVHZW4pIHtcbiAgICAgIHZhciByZXN1bHQgPSBoaWdobGlnaHRMaW5lKGNtLCBsaW5lLCBsaW5lLnN0YXRlQWZ0ZXIgPSBnZXRTdGF0ZUJlZm9yZShjbSwgbGluZU5vKGxpbmUpKSk7XG4gICAgICBsaW5lLnN0eWxlcyA9IHJlc3VsdC5zdHlsZXM7XG4gICAgICBpZiAocmVzdWx0LmNsYXNzZXMpIGxpbmUuc3R5bGVDbGFzc2VzID0gcmVzdWx0LmNsYXNzZXM7XG4gICAgICBlbHNlIGlmIChsaW5lLnN0eWxlQ2xhc3NlcykgbGluZS5zdHlsZUNsYXNzZXMgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbGluZS5zdHlsZXM7XG4gIH1cblxuICAvLyBMaWdodHdlaWdodCBmb3JtIG9mIGhpZ2hsaWdodCAtLSBwcm9jZWVkIG92ZXIgdGhpcyBsaW5lIGFuZFxuICAvLyB1cGRhdGUgc3RhdGUsIGJ1dCBkb24ndCBzYXZlIGEgc3R5bGUgYXJyYXkuIFVzZWQgZm9yIGxpbmVzIHRoYXRcbiAgLy8gYXJlbid0IGN1cnJlbnRseSB2aXNpYmxlLlxuICBmdW5jdGlvbiBwcm9jZXNzTGluZShjbSwgdGV4dCwgc3RhdGUsIHN0YXJ0QXQpIHtcbiAgICB2YXIgbW9kZSA9IGNtLmRvYy5tb2RlO1xuICAgIHZhciBzdHJlYW0gPSBuZXcgU3RyaW5nU3RyZWFtKHRleHQsIGNtLm9wdGlvbnMudGFiU2l6ZSk7XG4gICAgc3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvcyA9IHN0YXJ0QXQgfHwgMDtcbiAgICBpZiAodGV4dCA9PSBcIlwiKSBjYWxsQmxhbmtMaW5lKG1vZGUsIHN0YXRlKTtcbiAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSAmJiBzdHJlYW0ucG9zIDw9IGNtLm9wdGlvbnMubWF4SGlnaGxpZ2h0TGVuZ3RoKSB7XG4gICAgICByZWFkVG9rZW4obW9kZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBzdHJlYW0uc3RhcnQgPSBzdHJlYW0ucG9zO1xuICAgIH1cbiAgfVxuXG4gIC8vIENvbnZlcnQgYSBzdHlsZSBhcyByZXR1cm5lZCBieSBhIG1vZGUgKGVpdGhlciBudWxsLCBvciBhIHN0cmluZ1xuICAvLyBjb250YWluaW5nIG9uZSBvciBtb3JlIHN0eWxlcykgdG8gYSBDU1Mgc3R5bGUuIFRoaXMgaXMgY2FjaGVkLFxuICAvLyBhbmQgYWxzbyBsb29rcyBmb3IgbGluZS13aWRlIHN0eWxlcy5cbiAgdmFyIHN0eWxlVG9DbGFzc0NhY2hlID0ge30sIHN0eWxlVG9DbGFzc0NhY2hlV2l0aE1vZGUgPSB7fTtcbiAgZnVuY3Rpb24gaW50ZXJwcmV0VG9rZW5TdHlsZShzdHlsZSwgb3B0aW9ucykge1xuICAgIGlmICghc3R5bGUgfHwgL15cXHMqJC8udGVzdChzdHlsZSkpIHJldHVybiBudWxsO1xuICAgIHZhciBjYWNoZSA9IG9wdGlvbnMuYWRkTW9kZUNsYXNzID8gc3R5bGVUb0NsYXNzQ2FjaGVXaXRoTW9kZSA6IHN0eWxlVG9DbGFzc0NhY2hlO1xuICAgIHJldHVybiBjYWNoZVtzdHlsZV0gfHxcbiAgICAgIChjYWNoZVtzdHlsZV0gPSBzdHlsZS5yZXBsYWNlKC9cXFMrL2csIFwiY20tJCZcIikpO1xuICB9XG5cbiAgLy8gUmVuZGVyIHRoZSBET00gcmVwcmVzZW50YXRpb24gb2YgdGhlIHRleHQgb2YgYSBsaW5lLiBBbHNvIGJ1aWxkc1xuICAvLyB1cCBhICdsaW5lIG1hcCcsIHdoaWNoIHBvaW50cyBhdCB0aGUgRE9NIG5vZGVzIHRoYXQgcmVwcmVzZW50XG4gIC8vIHNwZWNpZmljIHN0cmV0Y2hlcyBvZiB0ZXh0LCBhbmQgaXMgdXNlZCBieSB0aGUgbWVhc3VyaW5nIGNvZGUuXG4gIC8vIFRoZSByZXR1cm5lZCBvYmplY3QgY29udGFpbnMgdGhlIERPTSBub2RlLCB0aGlzIG1hcCwgYW5kXG4gIC8vIGluZm9ybWF0aW9uIGFib3V0IGxpbmUtd2lkZSBzdHlsZXMgdGhhdCB3ZXJlIHNldCBieSB0aGUgbW9kZS5cbiAgZnVuY3Rpb24gYnVpbGRMaW5lQ29udGVudChjbSwgbGluZVZpZXcpIHtcbiAgICAvLyBUaGUgcGFkZGluZy1yaWdodCBmb3JjZXMgdGhlIGVsZW1lbnQgdG8gaGF2ZSBhICdib3JkZXInLCB3aGljaFxuICAgIC8vIGlzIG5lZWRlZCBvbiBXZWJraXQgdG8gYmUgYWJsZSB0byBnZXQgbGluZS1sZXZlbCBib3VuZGluZ1xuICAgIC8vIHJlY3RhbmdsZXMgZm9yIGl0IChpbiBtZWFzdXJlQ2hhcikuXG4gICAgdmFyIGNvbnRlbnQgPSBlbHQoXCJzcGFuXCIsIG51bGwsIG51bGwsIHdlYmtpdCA/IFwicGFkZGluZy1yaWdodDogLjFweFwiIDogbnVsbCk7XG4gICAgdmFyIGJ1aWxkZXIgPSB7cHJlOiBlbHQoXCJwcmVcIiwgW2NvbnRlbnRdKSwgY29udGVudDogY29udGVudCwgY29sOiAwLCBwb3M6IDAsIGNtOiBjbX07XG4gICAgbGluZVZpZXcubWVhc3VyZSA9IHt9O1xuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBsb2dpY2FsIGxpbmVzIHRoYXQgbWFrZSB1cCB0aGlzIHZpc3VhbCBsaW5lLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IChsaW5lVmlldy5yZXN0ID8gbGluZVZpZXcucmVzdC5sZW5ndGggOiAwKTsgaSsrKSB7XG4gICAgICB2YXIgbGluZSA9IGkgPyBsaW5lVmlldy5yZXN0W2kgLSAxXSA6IGxpbmVWaWV3LmxpbmUsIG9yZGVyO1xuICAgICAgYnVpbGRlci5wb3MgPSAwO1xuICAgICAgYnVpbGRlci5hZGRUb2tlbiA9IGJ1aWxkVG9rZW47XG4gICAgICAvLyBPcHRpb25hbGx5IHdpcmUgaW4gc29tZSBoYWNrcyBpbnRvIHRoZSB0b2tlbi1yZW5kZXJpbmdcbiAgICAgIC8vIGFsZ29yaXRobSwgdG8gZGVhbCB3aXRoIGJyb3dzZXIgcXVpcmtzLlxuICAgICAgaWYgKChpZSB8fCB3ZWJraXQpICYmIGNtLmdldE9wdGlvbihcImxpbmVXcmFwcGluZ1wiKSlcbiAgICAgICAgYnVpbGRlci5hZGRUb2tlbiA9IGJ1aWxkVG9rZW5TcGxpdFNwYWNlcyhidWlsZGVyLmFkZFRva2VuKTtcbiAgICAgIGlmIChoYXNCYWRCaWRpUmVjdHMoY20uZGlzcGxheS5tZWFzdXJlKSAmJiAob3JkZXIgPSBnZXRPcmRlcihsaW5lKSkpXG4gICAgICAgIGJ1aWxkZXIuYWRkVG9rZW4gPSBidWlsZFRva2VuQmFkQmlkaShidWlsZGVyLmFkZFRva2VuLCBvcmRlcik7XG4gICAgICBidWlsZGVyLm1hcCA9IFtdO1xuICAgICAgaW5zZXJ0TGluZUNvbnRlbnQobGluZSwgYnVpbGRlciwgZ2V0TGluZVN0eWxlcyhjbSwgbGluZSkpO1xuICAgICAgaWYgKGxpbmUuc3R5bGVDbGFzc2VzKSB7XG4gICAgICAgIGlmIChsaW5lLnN0eWxlQ2xhc3Nlcy5iZ0NsYXNzKVxuICAgICAgICAgIGJ1aWxkZXIuYmdDbGFzcyA9IGpvaW5DbGFzc2VzKGxpbmUuc3R5bGVDbGFzc2VzLmJnQ2xhc3MsIGJ1aWxkZXIuYmdDbGFzcyB8fCBcIlwiKTtcbiAgICAgICAgaWYgKGxpbmUuc3R5bGVDbGFzc2VzLnRleHRDbGFzcylcbiAgICAgICAgICBidWlsZGVyLnRleHRDbGFzcyA9IGpvaW5DbGFzc2VzKGxpbmUuc3R5bGVDbGFzc2VzLnRleHRDbGFzcywgYnVpbGRlci50ZXh0Q2xhc3MgfHwgXCJcIik7XG4gICAgICB9XG5cbiAgICAgIC8vIEVuc3VyZSBhdCBsZWFzdCBhIHNpbmdsZSBub2RlIGlzIHByZXNlbnQsIGZvciBtZWFzdXJpbmcuXG4gICAgICBpZiAoYnVpbGRlci5tYXAubGVuZ3RoID09IDApXG4gICAgICAgIGJ1aWxkZXIubWFwLnB1c2goMCwgMCwgYnVpbGRlci5jb250ZW50LmFwcGVuZENoaWxkKHplcm9XaWR0aEVsZW1lbnQoY20uZGlzcGxheS5tZWFzdXJlKSkpO1xuXG4gICAgICAvLyBTdG9yZSB0aGUgbWFwIGFuZCBhIGNhY2hlIG9iamVjdCBmb3IgdGhlIGN1cnJlbnQgbG9naWNhbCBsaW5lXG4gICAgICBpZiAoaSA9PSAwKSB7XG4gICAgICAgIGxpbmVWaWV3Lm1lYXN1cmUubWFwID0gYnVpbGRlci5tYXA7XG4gICAgICAgIGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGUgPSB7fTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIChsaW5lVmlldy5tZWFzdXJlLm1hcHMgfHwgKGxpbmVWaWV3Lm1lYXN1cmUubWFwcyA9IFtdKSkucHVzaChidWlsZGVyLm1hcCk7XG4gICAgICAgIChsaW5lVmlldy5tZWFzdXJlLmNhY2hlcyB8fCAobGluZVZpZXcubWVhc3VyZS5jYWNoZXMgPSBbXSkpLnB1c2goe30pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNpZ25hbChjbSwgXCJyZW5kZXJMaW5lXCIsIGNtLCBsaW5lVmlldy5saW5lLCBidWlsZGVyLnByZSk7XG4gICAgcmV0dXJuIGJ1aWxkZXI7XG4gIH1cblxuICBmdW5jdGlvbiBkZWZhdWx0U3BlY2lhbENoYXJQbGFjZWhvbGRlcihjaCkge1xuICAgIHZhciB0b2tlbiA9IGVsdChcInNwYW5cIiwgXCJcXHUyMDIyXCIsIFwiY20taW52YWxpZGNoYXJcIik7XG4gICAgdG9rZW4udGl0bGUgPSBcIlxcXFx1XCIgKyBjaC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gdG9rZW47XG4gIH1cblxuICAvLyBCdWlsZCB1cCB0aGUgRE9NIHJlcHJlc2VudGF0aW9uIGZvciBhIHNpbmdsZSB0b2tlbiwgYW5kIGFkZCBpdCB0b1xuICAvLyB0aGUgbGluZSBtYXAuIFRha2VzIGNhcmUgdG8gcmVuZGVyIHNwZWNpYWwgY2hhcmFjdGVycyBzZXBhcmF0ZWx5LlxuICBmdW5jdGlvbiBidWlsZFRva2VuKGJ1aWxkZXIsIHRleHQsIHN0eWxlLCBzdGFydFN0eWxlLCBlbmRTdHlsZSwgdGl0bGUpIHtcbiAgICBpZiAoIXRleHQpIHJldHVybjtcbiAgICB2YXIgc3BlY2lhbCA9IGJ1aWxkZXIuY20ub3B0aW9ucy5zcGVjaWFsQ2hhcnMsIG11c3RXcmFwID0gZmFsc2U7XG4gICAgaWYgKCFzcGVjaWFsLnRlc3QodGV4dCkpIHtcbiAgICAgIGJ1aWxkZXIuY29sICs9IHRleHQubGVuZ3RoO1xuICAgICAgdmFyIGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbiAgICAgIGJ1aWxkZXIubWFwLnB1c2goYnVpbGRlci5wb3MsIGJ1aWxkZXIucG9zICsgdGV4dC5sZW5ndGgsIGNvbnRlbnQpO1xuICAgICAgaWYgKGllX3VwdG84KSBtdXN0V3JhcCA9IHRydWU7XG4gICAgICBidWlsZGVyLnBvcyArPSB0ZXh0Lmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIHBvcyA9IDA7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBzcGVjaWFsLmxhc3RJbmRleCA9IHBvcztcbiAgICAgICAgdmFyIG0gPSBzcGVjaWFsLmV4ZWModGV4dCk7XG4gICAgICAgIHZhciBza2lwcGVkID0gbSA/IG0uaW5kZXggLSBwb3MgOiB0ZXh0Lmxlbmd0aCAtIHBvcztcbiAgICAgICAgaWYgKHNraXBwZWQpIHtcbiAgICAgICAgICB2YXIgdHh0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dC5zbGljZShwb3MsIHBvcyArIHNraXBwZWQpKTtcbiAgICAgICAgICBpZiAoaWVfdXB0bzgpIGNvbnRlbnQuYXBwZW5kQ2hpbGQoZWx0KFwic3BhblwiLCBbdHh0XSkpO1xuICAgICAgICAgIGVsc2UgY29udGVudC5hcHBlbmRDaGlsZCh0eHQpO1xuICAgICAgICAgIGJ1aWxkZXIubWFwLnB1c2goYnVpbGRlci5wb3MsIGJ1aWxkZXIucG9zICsgc2tpcHBlZCwgdHh0KTtcbiAgICAgICAgICBidWlsZGVyLmNvbCArPSBza2lwcGVkO1xuICAgICAgICAgIGJ1aWxkZXIucG9zICs9IHNraXBwZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtKSBicmVhaztcbiAgICAgICAgcG9zICs9IHNraXBwZWQgKyAxO1xuICAgICAgICBpZiAobVswXSA9PSBcIlxcdFwiKSB7XG4gICAgICAgICAgdmFyIHRhYlNpemUgPSBidWlsZGVyLmNtLm9wdGlvbnMudGFiU2l6ZSwgdGFiV2lkdGggPSB0YWJTaXplIC0gYnVpbGRlci5jb2wgJSB0YWJTaXplO1xuICAgICAgICAgIHZhciB0eHQgPSBjb250ZW50LmFwcGVuZENoaWxkKGVsdChcInNwYW5cIiwgc3BhY2VTdHIodGFiV2lkdGgpLCBcImNtLXRhYlwiKSk7XG4gICAgICAgICAgYnVpbGRlci5jb2wgKz0gdGFiV2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHR4dCA9IGJ1aWxkZXIuY20ub3B0aW9ucy5zcGVjaWFsQ2hhclBsYWNlaG9sZGVyKG1bMF0pO1xuICAgICAgICAgIGlmIChpZV91cHRvOCkgY29udGVudC5hcHBlbmRDaGlsZChlbHQoXCJzcGFuXCIsIFt0eHRdKSk7XG4gICAgICAgICAgZWxzZSBjb250ZW50LmFwcGVuZENoaWxkKHR4dCk7XG4gICAgICAgICAgYnVpbGRlci5jb2wgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBidWlsZGVyLm1hcC5wdXNoKGJ1aWxkZXIucG9zLCBidWlsZGVyLnBvcyArIDEsIHR4dCk7XG4gICAgICAgIGJ1aWxkZXIucG9zKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdHlsZSB8fCBzdGFydFN0eWxlIHx8IGVuZFN0eWxlIHx8IG11c3RXcmFwKSB7XG4gICAgICB2YXIgZnVsbFN0eWxlID0gc3R5bGUgfHwgXCJcIjtcbiAgICAgIGlmIChzdGFydFN0eWxlKSBmdWxsU3R5bGUgKz0gc3RhcnRTdHlsZTtcbiAgICAgIGlmIChlbmRTdHlsZSkgZnVsbFN0eWxlICs9IGVuZFN0eWxlO1xuICAgICAgdmFyIHRva2VuID0gZWx0KFwic3BhblwiLCBbY29udGVudF0sIGZ1bGxTdHlsZSk7XG4gICAgICBpZiAodGl0bGUpIHRva2VuLnRpdGxlID0gdGl0bGU7XG4gICAgICByZXR1cm4gYnVpbGRlci5jb250ZW50LmFwcGVuZENoaWxkKHRva2VuKTtcbiAgICB9XG4gICAgYnVpbGRlci5jb250ZW50LmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gYnVpbGRUb2tlblNwbGl0U3BhY2VzKGlubmVyKSB7XG4gICAgZnVuY3Rpb24gc3BsaXQob2xkKSB7XG4gICAgICB2YXIgb3V0ID0gXCIgXCI7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9sZC5sZW5ndGggLSAyOyArK2kpIG91dCArPSBpICUgMiA/IFwiIFwiIDogXCJcXHUwMGEwXCI7XG4gICAgICBvdXQgKz0gXCIgXCI7XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oYnVpbGRlciwgdGV4dCwgc3R5bGUsIHN0YXJ0U3R5bGUsIGVuZFN0eWxlLCB0aXRsZSkge1xuICAgICAgaW5uZXIoYnVpbGRlciwgdGV4dC5yZXBsYWNlKC8gezMsfS9nLCBzcGxpdCksIHN0eWxlLCBzdGFydFN0eWxlLCBlbmRTdHlsZSwgdGl0bGUpO1xuICAgIH07XG4gIH1cblxuICAvLyBXb3JrIGFyb3VuZCBub25zZW5zZSBkaW1lbnNpb25zIGJlaW5nIHJlcG9ydGVkIGZvciBzdHJldGNoZXMgb2ZcbiAgLy8gcmlnaHQtdG8tbGVmdCB0ZXh0LlxuICBmdW5jdGlvbiBidWlsZFRva2VuQmFkQmlkaShpbm5lciwgb3JkZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYnVpbGRlciwgdGV4dCwgc3R5bGUsIHN0YXJ0U3R5bGUsIGVuZFN0eWxlLCB0aXRsZSkge1xuICAgICAgc3R5bGUgPSBzdHlsZSA/IHN0eWxlICsgXCIgY20tZm9yY2UtYm9yZGVyXCIgOiBcImNtLWZvcmNlLWJvcmRlclwiO1xuICAgICAgdmFyIHN0YXJ0ID0gYnVpbGRlci5wb3MsIGVuZCA9IHN0YXJ0ICsgdGV4dC5sZW5ndGg7XG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgIC8vIEZpbmQgdGhlIHBhcnQgdGhhdCBvdmVybGFwcyB3aXRoIHRoZSBzdGFydCBvZiB0aGlzIHRleHRcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwYXJ0ID0gb3JkZXJbaV07XG4gICAgICAgICAgaWYgKHBhcnQudG8gPiBzdGFydCAmJiBwYXJ0LmZyb20gPD0gc3RhcnQpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnRvID49IGVuZCkgcmV0dXJuIGlubmVyKGJ1aWxkZXIsIHRleHQsIHN0eWxlLCBzdGFydFN0eWxlLCBlbmRTdHlsZSwgdGl0bGUpO1xuICAgICAgICBpbm5lcihidWlsZGVyLCB0ZXh0LnNsaWNlKDAsIHBhcnQudG8gLSBzdGFydCksIHN0eWxlLCBzdGFydFN0eWxlLCBudWxsLCB0aXRsZSk7XG4gICAgICAgIHN0YXJ0U3R5bGUgPSBudWxsO1xuICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZShwYXJ0LnRvIC0gc3RhcnQpO1xuICAgICAgICBzdGFydCA9IHBhcnQudG87XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkQ29sbGFwc2VkU3BhbihidWlsZGVyLCBzaXplLCBtYXJrZXIsIGlnbm9yZVdpZGdldCkge1xuICAgIHZhciB3aWRnZXQgPSAhaWdub3JlV2lkZ2V0ICYmIG1hcmtlci53aWRnZXROb2RlO1xuICAgIGlmICh3aWRnZXQpIHtcbiAgICAgIGJ1aWxkZXIubWFwLnB1c2goYnVpbGRlci5wb3MsIGJ1aWxkZXIucG9zICsgc2l6ZSwgd2lkZ2V0KTtcbiAgICAgIGJ1aWxkZXIuY29udGVudC5hcHBlbmRDaGlsZCh3aWRnZXQpO1xuICAgIH1cbiAgICBidWlsZGVyLnBvcyArPSBzaXplO1xuICB9XG5cbiAgLy8gT3V0cHV0cyBhIG51bWJlciBvZiBzcGFucyB0byBtYWtlIHVwIGEgbGluZSwgdGFraW5nIGhpZ2hsaWdodGluZ1xuICAvLyBhbmQgbWFya2VkIHRleHQgaW50byBhY2NvdW50LlxuICBmdW5jdGlvbiBpbnNlcnRMaW5lQ29udGVudChsaW5lLCBidWlsZGVyLCBzdHlsZXMpIHtcbiAgICB2YXIgc3BhbnMgPSBsaW5lLm1hcmtlZFNwYW5zLCBhbGxUZXh0ID0gbGluZS50ZXh0LCBhdCA9IDA7XG4gICAgaWYgKCFzcGFucykge1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKz0yKVxuICAgICAgICBidWlsZGVyLmFkZFRva2VuKGJ1aWxkZXIsIGFsbFRleHQuc2xpY2UoYXQsIGF0ID0gc3R5bGVzW2ldKSwgaW50ZXJwcmV0VG9rZW5TdHlsZShzdHlsZXNbaSsxXSwgYnVpbGRlci5jbS5vcHRpb25zKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGxlbiA9IGFsbFRleHQubGVuZ3RoLCBwb3MgPSAwLCBpID0gMSwgdGV4dCA9IFwiXCIsIHN0eWxlO1xuICAgIHZhciBuZXh0Q2hhbmdlID0gMCwgc3BhblN0eWxlLCBzcGFuRW5kU3R5bGUsIHNwYW5TdGFydFN0eWxlLCB0aXRsZSwgY29sbGFwc2VkO1xuICAgIGZvciAoOzspIHtcbiAgICAgIGlmIChuZXh0Q2hhbmdlID09IHBvcykgeyAvLyBVcGRhdGUgY3VycmVudCBtYXJrZXIgc2V0XG4gICAgICAgIHNwYW5TdHlsZSA9IHNwYW5FbmRTdHlsZSA9IHNwYW5TdGFydFN0eWxlID0gdGl0bGUgPSBcIlwiO1xuICAgICAgICBjb2xsYXBzZWQgPSBudWxsOyBuZXh0Q2hhbmdlID0gSW5maW5pdHk7XG4gICAgICAgIHZhciBmb3VuZEJvb2ttYXJrcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNwYW5zLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgdmFyIHNwID0gc3BhbnNbal0sIG0gPSBzcC5tYXJrZXI7XG4gICAgICAgICAgaWYgKHNwLmZyb20gPD0gcG9zICYmIChzcC50byA9PSBudWxsIHx8IHNwLnRvID4gcG9zKSkge1xuICAgICAgICAgICAgaWYgKHNwLnRvICE9IG51bGwgJiYgbmV4dENoYW5nZSA+IHNwLnRvKSB7IG5leHRDaGFuZ2UgPSBzcC50bzsgc3BhbkVuZFN0eWxlID0gXCJcIjsgfVxuICAgICAgICAgICAgaWYgKG0uY2xhc3NOYW1lKSBzcGFuU3R5bGUgKz0gXCIgXCIgKyBtLmNsYXNzTmFtZTtcbiAgICAgICAgICAgIGlmIChtLnN0YXJ0U3R5bGUgJiYgc3AuZnJvbSA9PSBwb3MpIHNwYW5TdGFydFN0eWxlICs9IFwiIFwiICsgbS5zdGFydFN0eWxlO1xuICAgICAgICAgICAgaWYgKG0uZW5kU3R5bGUgJiYgc3AudG8gPT0gbmV4dENoYW5nZSkgc3BhbkVuZFN0eWxlICs9IFwiIFwiICsgbS5lbmRTdHlsZTtcbiAgICAgICAgICAgIGlmIChtLnRpdGxlICYmICF0aXRsZSkgdGl0bGUgPSBtLnRpdGxlO1xuICAgICAgICAgICAgaWYgKG0uY29sbGFwc2VkICYmICghY29sbGFwc2VkIHx8IGNvbXBhcmVDb2xsYXBzZWRNYXJrZXJzKGNvbGxhcHNlZC5tYXJrZXIsIG0pIDwgMCkpXG4gICAgICAgICAgICAgIGNvbGxhcHNlZCA9IHNwO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3AuZnJvbSA+IHBvcyAmJiBuZXh0Q2hhbmdlID4gc3AuZnJvbSkge1xuICAgICAgICAgICAgbmV4dENoYW5nZSA9IHNwLmZyb207XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtLnR5cGUgPT0gXCJib29rbWFya1wiICYmIHNwLmZyb20gPT0gcG9zICYmIG0ud2lkZ2V0Tm9kZSkgZm91bmRCb29rbWFya3MucHVzaChtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sbGFwc2VkICYmIChjb2xsYXBzZWQuZnJvbSB8fCAwKSA9PSBwb3MpIHtcbiAgICAgICAgICBidWlsZENvbGxhcHNlZFNwYW4oYnVpbGRlciwgKGNvbGxhcHNlZC50byA9PSBudWxsID8gbGVuICsgMSA6IGNvbGxhcHNlZC50bykgLSBwb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxhcHNlZC5tYXJrZXIsIGNvbGxhcHNlZC5mcm9tID09IG51bGwpO1xuICAgICAgICAgIGlmIChjb2xsYXBzZWQudG8gPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29sbGFwc2VkICYmIGZvdW5kQm9va21hcmtzLmxlbmd0aCkgZm9yICh2YXIgaiA9IDA7IGogPCBmb3VuZEJvb2ttYXJrcy5sZW5ndGg7ICsrailcbiAgICAgICAgICBidWlsZENvbGxhcHNlZFNwYW4oYnVpbGRlciwgMCwgZm91bmRCb29rbWFya3Nbal0pO1xuICAgICAgfVxuICAgICAgaWYgKHBvcyA+PSBsZW4pIGJyZWFrO1xuXG4gICAgICB2YXIgdXB0byA9IE1hdGgubWluKGxlbiwgbmV4dENoYW5nZSk7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgIHZhciBlbmQgPSBwb3MgKyB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoIWNvbGxhcHNlZCkge1xuICAgICAgICAgICAgdmFyIHRva2VuVGV4dCA9IGVuZCA+IHVwdG8gPyB0ZXh0LnNsaWNlKDAsIHVwdG8gLSBwb3MpIDogdGV4dDtcbiAgICAgICAgICAgIGJ1aWxkZXIuYWRkVG9rZW4oYnVpbGRlciwgdG9rZW5UZXh0LCBzdHlsZSA/IHN0eWxlICsgc3BhblN0eWxlIDogc3BhblN0eWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuU3RhcnRTdHlsZSwgcG9zICsgdG9rZW5UZXh0Lmxlbmd0aCA9PSBuZXh0Q2hhbmdlID8gc3BhbkVuZFN0eWxlIDogXCJcIiwgdGl0bGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZW5kID49IHVwdG8pIHt0ZXh0ID0gdGV4dC5zbGljZSh1cHRvIC0gcG9zKTsgcG9zID0gdXB0bzsgYnJlYWs7fVxuICAgICAgICAgIHBvcyA9IGVuZDtcbiAgICAgICAgICBzcGFuU3RhcnRTdHlsZSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dCA9IGFsbFRleHQuc2xpY2UoYXQsIGF0ID0gc3R5bGVzW2krK10pO1xuICAgICAgICBzdHlsZSA9IGludGVycHJldFRva2VuU3R5bGUoc3R5bGVzW2krK10sIGJ1aWxkZXIuY20ub3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gRE9DVU1FTlQgREFUQSBTVFJVQ1RVUkVcblxuICAvLyBCeSBkZWZhdWx0LCB1cGRhdGVzIHRoYXQgc3RhcnQgYW5kIGVuZCBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgbGluZVxuICAvLyBhcmUgdHJlYXRlZCBzcGVjaWFsbHksIGluIG9yZGVyIHRvIG1ha2UgdGhlIGFzc29jaWF0aW9uIG9mIGxpbmVcbiAgLy8gd2lkZ2V0cyBhbmQgbWFya2VyIGVsZW1lbnRzIHdpdGggdGhlIHRleHQgYmVoYXZlIG1vcmUgaW50dWl0aXZlLlxuICBmdW5jdGlvbiBpc1dob2xlTGluZVVwZGF0ZShkb2MsIGNoYW5nZSkge1xuICAgIHJldHVybiBjaGFuZ2UuZnJvbS5jaCA9PSAwICYmIGNoYW5nZS50by5jaCA9PSAwICYmIGxzdChjaGFuZ2UudGV4dCkgPT0gXCJcIiAmJlxuICAgICAgKCFkb2MuY20gfHwgZG9jLmNtLm9wdGlvbnMud2hvbGVMaW5lVXBkYXRlQmVmb3JlKTtcbiAgfVxuXG4gIC8vIFBlcmZvcm0gYSBjaGFuZ2Ugb24gdGhlIGRvY3VtZW50IGRhdGEgc3RydWN0dXJlLlxuICBmdW5jdGlvbiB1cGRhdGVEb2MoZG9jLCBjaGFuZ2UsIG1hcmtlZFNwYW5zLCBlc3RpbWF0ZUhlaWdodCkge1xuICAgIGZ1bmN0aW9uIHNwYW5zRm9yKG4pIHtyZXR1cm4gbWFya2VkU3BhbnMgPyBtYXJrZWRTcGFuc1tuXSA6IG51bGw7fVxuICAgIGZ1bmN0aW9uIHVwZGF0ZShsaW5lLCB0ZXh0LCBzcGFucykge1xuICAgICAgdXBkYXRlTGluZShsaW5lLCB0ZXh0LCBzcGFucywgZXN0aW1hdGVIZWlnaHQpO1xuICAgICAgc2lnbmFsTGF0ZXIobGluZSwgXCJjaGFuZ2VcIiwgbGluZSwgY2hhbmdlKTtcbiAgICB9XG5cbiAgICB2YXIgZnJvbSA9IGNoYW5nZS5mcm9tLCB0byA9IGNoYW5nZS50bywgdGV4dCA9IGNoYW5nZS50ZXh0O1xuICAgIHZhciBmaXJzdExpbmUgPSBnZXRMaW5lKGRvYywgZnJvbS5saW5lKSwgbGFzdExpbmUgPSBnZXRMaW5lKGRvYywgdG8ubGluZSk7XG4gICAgdmFyIGxhc3RUZXh0ID0gbHN0KHRleHQpLCBsYXN0U3BhbnMgPSBzcGFuc0Zvcih0ZXh0Lmxlbmd0aCAtIDEpLCBubGluZXMgPSB0by5saW5lIC0gZnJvbS5saW5lO1xuXG4gICAgLy8gQWRqdXN0IHRoZSBsaW5lIHN0cnVjdHVyZVxuICAgIGlmIChpc1dob2xlTGluZVVwZGF0ZShkb2MsIGNoYW5nZSkpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB3aG9sZS1saW5lIHJlcGxhY2UuIFRyZWF0ZWQgc3BlY2lhbGx5IHRvIG1ha2VcbiAgICAgIC8vIHN1cmUgbGluZSBvYmplY3RzIG1vdmUgdGhlIHdheSB0aGV5IGFyZSBzdXBwb3NlZCB0by5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBhZGRlZCA9IFtdOyBpIDwgdGV4dC5sZW5ndGggLSAxOyArK2kpXG4gICAgICAgIGFkZGVkLnB1c2gobmV3IExpbmUodGV4dFtpXSwgc3BhbnNGb3IoaSksIGVzdGltYXRlSGVpZ2h0KSk7XG4gICAgICB1cGRhdGUobGFzdExpbmUsIGxhc3RMaW5lLnRleHQsIGxhc3RTcGFucyk7XG4gICAgICBpZiAobmxpbmVzKSBkb2MucmVtb3ZlKGZyb20ubGluZSwgbmxpbmVzKTtcbiAgICAgIGlmIChhZGRlZC5sZW5ndGgpIGRvYy5pbnNlcnQoZnJvbS5saW5lLCBhZGRlZCk7XG4gICAgfSBlbHNlIGlmIChmaXJzdExpbmUgPT0gbGFzdExpbmUpIHtcbiAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHVwZGF0ZShmaXJzdExpbmUsIGZpcnN0TGluZS50ZXh0LnNsaWNlKDAsIGZyb20uY2gpICsgbGFzdFRleHQgKyBmaXJzdExpbmUudGV4dC5zbGljZSh0by5jaCksIGxhc3RTcGFucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBhZGRlZCA9IFtdLCBpID0gMTsgaSA8IHRleHQubGVuZ3RoIC0gMTsgKytpKVxuICAgICAgICAgIGFkZGVkLnB1c2gobmV3IExpbmUodGV4dFtpXSwgc3BhbnNGb3IoaSksIGVzdGltYXRlSGVpZ2h0KSk7XG4gICAgICAgIGFkZGVkLnB1c2gobmV3IExpbmUobGFzdFRleHQgKyBmaXJzdExpbmUudGV4dC5zbGljZSh0by5jaCksIGxhc3RTcGFucywgZXN0aW1hdGVIZWlnaHQpKTtcbiAgICAgICAgdXBkYXRlKGZpcnN0TGluZSwgZmlyc3RMaW5lLnRleHQuc2xpY2UoMCwgZnJvbS5jaCkgKyB0ZXh0WzBdLCBzcGFuc0ZvcigwKSk7XG4gICAgICAgIGRvYy5pbnNlcnQoZnJvbS5saW5lICsgMSwgYWRkZWQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGV4dC5sZW5ndGggPT0gMSkge1xuICAgICAgdXBkYXRlKGZpcnN0TGluZSwgZmlyc3RMaW5lLnRleHQuc2xpY2UoMCwgZnJvbS5jaCkgKyB0ZXh0WzBdICsgbGFzdExpbmUudGV4dC5zbGljZSh0by5jaCksIHNwYW5zRm9yKDApKTtcbiAgICAgIGRvYy5yZW1vdmUoZnJvbS5saW5lICsgMSwgbmxpbmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXBkYXRlKGZpcnN0TGluZSwgZmlyc3RMaW5lLnRleHQuc2xpY2UoMCwgZnJvbS5jaCkgKyB0ZXh0WzBdLCBzcGFuc0ZvcigwKSk7XG4gICAgICB1cGRhdGUobGFzdExpbmUsIGxhc3RUZXh0ICsgbGFzdExpbmUudGV4dC5zbGljZSh0by5jaCksIGxhc3RTcGFucyk7XG4gICAgICBmb3IgKHZhciBpID0gMSwgYWRkZWQgPSBbXTsgaSA8IHRleHQubGVuZ3RoIC0gMTsgKytpKVxuICAgICAgICBhZGRlZC5wdXNoKG5ldyBMaW5lKHRleHRbaV0sIHNwYW5zRm9yKGkpLCBlc3RpbWF0ZUhlaWdodCkpO1xuICAgICAgaWYgKG5saW5lcyA+IDEpIGRvYy5yZW1vdmUoZnJvbS5saW5lICsgMSwgbmxpbmVzIC0gMSk7XG4gICAgICBkb2MuaW5zZXJ0KGZyb20ubGluZSArIDEsIGFkZGVkKTtcbiAgICB9XG5cbiAgICBzaWduYWxMYXRlcihkb2MsIFwiY2hhbmdlXCIsIGRvYywgY2hhbmdlKTtcbiAgfVxuXG4gIC8vIFRoZSBkb2N1bWVudCBpcyByZXByZXNlbnRlZCBhcyBhIEJUcmVlIGNvbnNpc3Rpbmcgb2YgbGVhdmVzLCB3aXRoXG4gIC8vIGNodW5rIG9mIGxpbmVzIGluIHRoZW0sIGFuZCBicmFuY2hlcywgd2l0aCB1cCB0byB0ZW4gbGVhdmVzIG9yXG4gIC8vIG90aGVyIGJyYW5jaCBub2RlcyBiZWxvdyB0aGVtLiBUaGUgdG9wIG5vZGUgaXMgYWx3YXlzIGEgYnJhbmNoXG4gIC8vIG5vZGUsIGFuZCBpcyB0aGUgZG9jdW1lbnQgb2JqZWN0IGl0c2VsZiAobWVhbmluZyBpdCBoYXNcbiAgLy8gYWRkaXRpb25hbCBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzKS5cbiAgLy9cbiAgLy8gQWxsIG5vZGVzIGhhdmUgcGFyZW50IGxpbmtzLiBUaGUgdHJlZSBpcyB1c2VkIGJvdGggdG8gZ28gZnJvbVxuICAvLyBsaW5lIG51bWJlcnMgdG8gbGluZSBvYmplY3RzLCBhbmQgdG8gZ28gZnJvbSBvYmplY3RzIHRvIG51bWJlcnMuXG4gIC8vIEl0IGFsc28gaW5kZXhlcyBieSBoZWlnaHQsIGFuZCBpcyB1c2VkIHRvIGNvbnZlcnQgYmV0d2VlbiBoZWlnaHRcbiAgLy8gYW5kIGxpbmUgb2JqZWN0LCBhbmQgdG8gZmluZCB0aGUgdG90YWwgaGVpZ2h0IG9mIHRoZSBkb2N1bWVudC5cbiAgLy9cbiAgLy8gU2VlIGFsc28gaHR0cDovL21hcmlqbmhhdmVyYmVrZS5ubC9ibG9nL2NvZGVtaXJyb3ItbGluZS10cmVlLmh0bWxcblxuICBmdW5jdGlvbiBMZWFmQ2h1bmsobGluZXMpIHtcbiAgICB0aGlzLmxpbmVzID0gbGluZXM7XG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSAwLCBoZWlnaHQgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxpbmVzW2ldLnBhcmVudCA9IHRoaXM7XG4gICAgICBoZWlnaHQgKz0gbGluZXNbaV0uaGVpZ2h0O1xuICAgIH1cbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgfVxuXG4gIExlYWZDaHVuay5wcm90b3R5cGUgPSB7XG4gICAgY2h1bmtTaXplOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMubGluZXMubGVuZ3RoOyB9LFxuICAgIC8vIFJlbW92ZSB0aGUgbiBsaW5lcyBhdCBvZmZzZXQgJ2F0Jy5cbiAgICByZW1vdmVJbm5lcjogZnVuY3Rpb24oYXQsIG4pIHtcbiAgICAgIGZvciAodmFyIGkgPSBhdCwgZSA9IGF0ICsgbjsgaSA8IGU7ICsraSkge1xuICAgICAgICB2YXIgbGluZSA9IHRoaXMubGluZXNbaV07XG4gICAgICAgIHRoaXMuaGVpZ2h0IC09IGxpbmUuaGVpZ2h0O1xuICAgICAgICBjbGVhblVwTGluZShsaW5lKTtcbiAgICAgICAgc2lnbmFsTGF0ZXIobGluZSwgXCJkZWxldGVcIik7XG4gICAgICB9XG4gICAgICB0aGlzLmxpbmVzLnNwbGljZShhdCwgbik7XG4gICAgfSxcbiAgICAvLyBIZWxwZXIgdXNlZCB0byBjb2xsYXBzZSBhIHNtYWxsIGJyYW5jaCBpbnRvIGEgc2luZ2xlIGxlYWYuXG4gICAgY29sbGFwc2U6IGZ1bmN0aW9uKGxpbmVzKSB7XG4gICAgICBsaW5lcy5wdXNoLmFwcGx5KGxpbmVzLCB0aGlzLmxpbmVzKTtcbiAgICB9LFxuICAgIC8vIEluc2VydCB0aGUgZ2l2ZW4gYXJyYXkgb2YgbGluZXMgYXQgb2Zmc2V0ICdhdCcsIGNvdW50IHRoZW0gYXNcbiAgICAvLyBoYXZpbmcgdGhlIGdpdmVuIGhlaWdodC5cbiAgICBpbnNlcnRJbm5lcjogZnVuY3Rpb24oYXQsIGxpbmVzLCBoZWlnaHQpIHtcbiAgICAgIHRoaXMuaGVpZ2h0ICs9IGhlaWdodDtcbiAgICAgIHRoaXMubGluZXMgPSB0aGlzLmxpbmVzLnNsaWNlKDAsIGF0KS5jb25jYXQobGluZXMpLmNvbmNhdCh0aGlzLmxpbmVzLnNsaWNlKGF0KSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSBsaW5lc1tpXS5wYXJlbnQgPSB0aGlzO1xuICAgIH0sXG4gICAgLy8gVXNlZCB0byBpdGVyYXRlIG92ZXIgYSBwYXJ0IG9mIHRoZSB0cmVlLlxuICAgIGl0ZXJOOiBmdW5jdGlvbihhdCwgbiwgb3ApIHtcbiAgICAgIGZvciAodmFyIGUgPSBhdCArIG47IGF0IDwgZTsgKythdClcbiAgICAgICAgaWYgKG9wKHRoaXMubGluZXNbYXRdKSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIEJyYW5jaENodW5rKGNoaWxkcmVuKSB7XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIHZhciBzaXplID0gMCwgaGVpZ2h0ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgY2ggPSBjaGlsZHJlbltpXTtcbiAgICAgIHNpemUgKz0gY2guY2h1bmtTaXplKCk7IGhlaWdodCArPSBjaC5oZWlnaHQ7XG4gICAgICBjaC5wYXJlbnQgPSB0aGlzO1xuICAgIH1cbiAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgfVxuXG4gIEJyYW5jaENodW5rLnByb3RvdHlwZSA9IHtcbiAgICBjaHVua1NpemU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5zaXplOyB9LFxuICAgIHJlbW92ZUlubmVyOiBmdW5jdGlvbihhdCwgbikge1xuICAgICAgdGhpcy5zaXplIC09IG47XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgc3ogPSBjaGlsZC5jaHVua1NpemUoKTtcbiAgICAgICAgaWYgKGF0IDwgc3opIHtcbiAgICAgICAgICB2YXIgcm0gPSBNYXRoLm1pbihuLCBzeiAtIGF0KSwgb2xkSGVpZ2h0ID0gY2hpbGQuaGVpZ2h0O1xuICAgICAgICAgIGNoaWxkLnJlbW92ZUlubmVyKGF0LCBybSk7XG4gICAgICAgICAgdGhpcy5oZWlnaHQgLT0gb2xkSGVpZ2h0IC0gY2hpbGQuaGVpZ2h0O1xuICAgICAgICAgIGlmIChzeiA9PSBybSkgeyB0aGlzLmNoaWxkcmVuLnNwbGljZShpLS0sIDEpOyBjaGlsZC5wYXJlbnQgPSBudWxsOyB9XG4gICAgICAgICAgaWYgKChuIC09IHJtKSA9PSAwKSBicmVhaztcbiAgICAgICAgICBhdCA9IDA7XG4gICAgICAgIH0gZWxzZSBhdCAtPSBzejtcbiAgICAgIH1cbiAgICAgIC8vIElmIHRoZSByZXN1bHQgaXMgc21hbGxlciB0aGFuIDI1IGxpbmVzLCBlbnN1cmUgdGhhdCBpdCBpcyBhXG4gICAgICAvLyBzaW5nbGUgbGVhZiBub2RlLlxuICAgICAgaWYgKHRoaXMuc2l6ZSAtIG4gPCAyNSAmJlxuICAgICAgICAgICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDEgfHwgISh0aGlzLmNoaWxkcmVuWzBdIGluc3RhbmNlb2YgTGVhZkNodW5rKSkpIHtcbiAgICAgICAgdmFyIGxpbmVzID0gW107XG4gICAgICAgIHRoaXMuY29sbGFwc2UobGluZXMpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW25ldyBMZWFmQ2h1bmsobGluZXMpXTtcbiAgICAgICAgdGhpcy5jaGlsZHJlblswXS5wYXJlbnQgPSB0aGlzO1xuICAgICAgfVxuICAgIH0sXG4gICAgY29sbGFwc2U6IGZ1bmN0aW9uKGxpbmVzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHRoaXMuY2hpbGRyZW5baV0uY29sbGFwc2UobGluZXMpO1xuICAgIH0sXG4gICAgaW5zZXJ0SW5uZXI6IGZ1bmN0aW9uKGF0LCBsaW5lcywgaGVpZ2h0KSB7XG4gICAgICB0aGlzLnNpemUgKz0gbGluZXMubGVuZ3RoO1xuICAgICAgdGhpcy5oZWlnaHQgKz0gaGVpZ2h0O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIHN6ID0gY2hpbGQuY2h1bmtTaXplKCk7XG4gICAgICAgIGlmIChhdCA8PSBzeikge1xuICAgICAgICAgIGNoaWxkLmluc2VydElubmVyKGF0LCBsaW5lcywgaGVpZ2h0KTtcbiAgICAgICAgICBpZiAoY2hpbGQubGluZXMgJiYgY2hpbGQubGluZXMubGVuZ3RoID4gNTApIHtcbiAgICAgICAgICAgIHdoaWxlIChjaGlsZC5saW5lcy5sZW5ndGggPiA1MCkge1xuICAgICAgICAgICAgICB2YXIgc3BpbGxlZCA9IGNoaWxkLmxpbmVzLnNwbGljZShjaGlsZC5saW5lcy5sZW5ndGggLSAyNSwgMjUpO1xuICAgICAgICAgICAgICB2YXIgbmV3bGVhZiA9IG5ldyBMZWFmQ2h1bmsoc3BpbGxlZCk7XG4gICAgICAgICAgICAgIGNoaWxkLmhlaWdodCAtPSBuZXdsZWFmLmhlaWdodDtcbiAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaSArIDEsIDAsIG5ld2xlYWYpO1xuICAgICAgICAgICAgICBuZXdsZWFmLnBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1heWJlU3BpbGwoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYXQgLT0gc3o7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBXaGVuIGEgbm9kZSBoYXMgZ3Jvd24sIGNoZWNrIHdoZXRoZXIgaXQgc2hvdWxkIGJlIHNwbGl0LlxuICAgIG1heWJlU3BpbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoIDw9IDEwKSByZXR1cm47XG4gICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgZG8ge1xuICAgICAgICB2YXIgc3BpbGxlZCA9IG1lLmNoaWxkcmVuLnNwbGljZShtZS5jaGlsZHJlbi5sZW5ndGggLSA1LCA1KTtcbiAgICAgICAgdmFyIHNpYmxpbmcgPSBuZXcgQnJhbmNoQ2h1bmsoc3BpbGxlZCk7XG4gICAgICAgIGlmICghbWUucGFyZW50KSB7IC8vIEJlY29tZSB0aGUgcGFyZW50IG5vZGVcbiAgICAgICAgICB2YXIgY29weSA9IG5ldyBCcmFuY2hDaHVuayhtZS5jaGlsZHJlbik7XG4gICAgICAgICAgY29weS5wYXJlbnQgPSBtZTtcbiAgICAgICAgICBtZS5jaGlsZHJlbiA9IFtjb3B5LCBzaWJsaW5nXTtcbiAgICAgICAgICBtZSA9IGNvcHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWUuc2l6ZSAtPSBzaWJsaW5nLnNpemU7XG4gICAgICAgICAgbWUuaGVpZ2h0IC09IHNpYmxpbmcuaGVpZ2h0O1xuICAgICAgICAgIHZhciBteUluZGV4ID0gaW5kZXhPZihtZS5wYXJlbnQuY2hpbGRyZW4sIG1lKTtcbiAgICAgICAgICBtZS5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKG15SW5kZXggKyAxLCAwLCBzaWJsaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBzaWJsaW5nLnBhcmVudCA9IG1lLnBhcmVudDtcbiAgICAgIH0gd2hpbGUgKG1lLmNoaWxkcmVuLmxlbmd0aCA+IDEwKTtcbiAgICAgIG1lLnBhcmVudC5tYXliZVNwaWxsKCk7XG4gICAgfSxcbiAgICBpdGVyTjogZnVuY3Rpb24oYXQsIG4sIG9wKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgc3ogPSBjaGlsZC5jaHVua1NpemUoKTtcbiAgICAgICAgaWYgKGF0IDwgc3opIHtcbiAgICAgICAgICB2YXIgdXNlZCA9IE1hdGgubWluKG4sIHN6IC0gYXQpO1xuICAgICAgICAgIGlmIChjaGlsZC5pdGVyTihhdCwgdXNlZCwgb3ApKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICBpZiAoKG4gLT0gdXNlZCkgPT0gMCkgYnJlYWs7XG4gICAgICAgICAgYXQgPSAwO1xuICAgICAgICB9IGVsc2UgYXQgLT0gc3o7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBuZXh0RG9jSWQgPSAwO1xuICB2YXIgRG9jID0gQ29kZU1pcnJvci5Eb2MgPSBmdW5jdGlvbih0ZXh0LCBtb2RlLCBmaXJzdExpbmUpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRG9jKSkgcmV0dXJuIG5ldyBEb2ModGV4dCwgbW9kZSwgZmlyc3RMaW5lKTtcbiAgICBpZiAoZmlyc3RMaW5lID09IG51bGwpIGZpcnN0TGluZSA9IDA7XG5cbiAgICBCcmFuY2hDaHVuay5jYWxsKHRoaXMsIFtuZXcgTGVhZkNodW5rKFtuZXcgTGluZShcIlwiLCBudWxsKV0pXSk7XG4gICAgdGhpcy5maXJzdCA9IGZpcnN0TGluZTtcbiAgICB0aGlzLnNjcm9sbFRvcCA9IHRoaXMuc2Nyb2xsTGVmdCA9IDA7XG4gICAgdGhpcy5jYW50RWRpdCA9IGZhbHNlO1xuICAgIHRoaXMuY2xlYW5HZW5lcmF0aW9uID0gMTtcbiAgICB0aGlzLmZyb250aWVyID0gZmlyc3RMaW5lO1xuICAgIHZhciBzdGFydCA9IFBvcyhmaXJzdExpbmUsIDApO1xuICAgIHRoaXMuc2VsID0gc2ltcGxlU2VsZWN0aW9uKHN0YXJ0KTtcbiAgICB0aGlzLmhpc3RvcnkgPSBuZXcgSGlzdG9yeShudWxsKTtcbiAgICB0aGlzLmlkID0gKytuZXh0RG9jSWQ7XG4gICAgdGhpcy5tb2RlT3B0aW9uID0gbW9kZTtcblxuICAgIGlmICh0eXBlb2YgdGV4dCA9PSBcInN0cmluZ1wiKSB0ZXh0ID0gc3BsaXRMaW5lcyh0ZXh0KTtcbiAgICB1cGRhdGVEb2ModGhpcywge2Zyb206IHN0YXJ0LCB0bzogc3RhcnQsIHRleHQ6IHRleHR9KTtcbiAgICBzZXRTZWxlY3Rpb24odGhpcywgc2ltcGxlU2VsZWN0aW9uKHN0YXJ0KSwgc2VsX2RvbnRTY3JvbGwpO1xuICB9O1xuXG4gIERvYy5wcm90b3R5cGUgPSBjcmVhdGVPYmooQnJhbmNoQ2h1bmsucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IERvYyxcbiAgICAvLyBJdGVyYXRlIG92ZXIgdGhlIGRvY3VtZW50LiBTdXBwb3J0cyB0d28gZm9ybXMgLS0gd2l0aCBvbmx5IG9uZVxuICAgIC8vIGFyZ3VtZW50LCBpdCBjYWxscyB0aGF0IGZvciBlYWNoIGxpbmUgaW4gdGhlIGRvY3VtZW50LiBXaXRoXG4gICAgLy8gdGhyZWUsIGl0IGl0ZXJhdGVzIG92ZXIgdGhlIHJhbmdlIGdpdmVuIGJ5IHRoZSBmaXJzdCB0d28gKHdpdGhcbiAgICAvLyB0aGUgc2Vjb25kIGJlaW5nIG5vbi1pbmNsdXNpdmUpLlxuICAgIGl0ZXI6IGZ1bmN0aW9uKGZyb20sIHRvLCBvcCkge1xuICAgICAgaWYgKG9wKSB0aGlzLml0ZXJOKGZyb20gLSB0aGlzLmZpcnN0LCB0byAtIGZyb20sIG9wKTtcbiAgICAgIGVsc2UgdGhpcy5pdGVyTih0aGlzLmZpcnN0LCB0aGlzLmZpcnN0ICsgdGhpcy5zaXplLCBmcm9tKTtcbiAgICB9LFxuXG4gICAgLy8gTm9uLXB1YmxpYyBpbnRlcmZhY2UgZm9yIGFkZGluZyBhbmQgcmVtb3ZpbmcgbGluZXMuXG4gICAgaW5zZXJ0OiBmdW5jdGlvbihhdCwgbGluZXMpIHtcbiAgICAgIHZhciBoZWlnaHQgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkgaGVpZ2h0ICs9IGxpbmVzW2ldLmhlaWdodDtcbiAgICAgIHRoaXMuaW5zZXJ0SW5uZXIoYXQgLSB0aGlzLmZpcnN0LCBsaW5lcywgaGVpZ2h0KTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24oYXQsIG4pIHsgdGhpcy5yZW1vdmVJbm5lcihhdCAtIHRoaXMuZmlyc3QsIG4pOyB9LFxuXG4gICAgLy8gRnJvbSBoZXJlLCB0aGUgbWV0aG9kcyBhcmUgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS4gTW9zdFxuICAgIC8vIGFyZSBhbHNvIGF2YWlsYWJsZSBmcm9tIENvZGVNaXJyb3IgKGVkaXRvcikgaW5zdGFuY2VzLlxuXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKGxpbmVTZXApIHtcbiAgICAgIHZhciBsaW5lcyA9IGdldExpbmVzKHRoaXMsIHRoaXMuZmlyc3QsIHRoaXMuZmlyc3QgKyB0aGlzLnNpemUpO1xuICAgICAgaWYgKGxpbmVTZXAgPT09IGZhbHNlKSByZXR1cm4gbGluZXM7XG4gICAgICByZXR1cm4gbGluZXMuam9pbihsaW5lU2VwIHx8IFwiXFxuXCIpO1xuICAgIH0sXG4gICAgc2V0VmFsdWU6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGNvZGUpIHtcbiAgICAgIHZhciB0b3AgPSBQb3ModGhpcy5maXJzdCwgMCksIGxhc3QgPSB0aGlzLmZpcnN0ICsgdGhpcy5zaXplIC0gMTtcbiAgICAgIG1ha2VDaGFuZ2UodGhpcywge2Zyb206IHRvcCwgdG86IFBvcyhsYXN0LCBnZXRMaW5lKHRoaXMsIGxhc3QpLnRleHQubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHNwbGl0TGluZXMoY29kZSksIG9yaWdpbjogXCJzZXRWYWx1ZVwifSwgdHJ1ZSk7XG4gICAgICBzZXRTZWxlY3Rpb24odGhpcywgc2ltcGxlU2VsZWN0aW9uKHRvcCkpO1xuICAgIH0pLFxuICAgIHJlcGxhY2VSYW5nZTogZnVuY3Rpb24oY29kZSwgZnJvbSwgdG8sIG9yaWdpbikge1xuICAgICAgZnJvbSA9IGNsaXBQb3ModGhpcywgZnJvbSk7XG4gICAgICB0byA9IHRvID8gY2xpcFBvcyh0aGlzLCB0bykgOiBmcm9tO1xuICAgICAgcmVwbGFjZVJhbmdlKHRoaXMsIGNvZGUsIGZyb20sIHRvLCBvcmlnaW4pO1xuICAgIH0sXG4gICAgZ2V0UmFuZ2U6IGZ1bmN0aW9uKGZyb20sIHRvLCBsaW5lU2VwKSB7XG4gICAgICB2YXIgbGluZXMgPSBnZXRCZXR3ZWVuKHRoaXMsIGNsaXBQb3ModGhpcywgZnJvbSksIGNsaXBQb3ModGhpcywgdG8pKTtcbiAgICAgIGlmIChsaW5lU2VwID09PSBmYWxzZSkgcmV0dXJuIGxpbmVzO1xuICAgICAgcmV0dXJuIGxpbmVzLmpvaW4obGluZVNlcCB8fCBcIlxcblwiKTtcbiAgICB9LFxuXG4gICAgZ2V0TGluZTogZnVuY3Rpb24obGluZSkge3ZhciBsID0gdGhpcy5nZXRMaW5lSGFuZGxlKGxpbmUpOyByZXR1cm4gbCAmJiBsLnRleHQ7fSxcblxuICAgIGdldExpbmVIYW5kbGU6IGZ1bmN0aW9uKGxpbmUpIHtpZiAoaXNMaW5lKHRoaXMsIGxpbmUpKSByZXR1cm4gZ2V0TGluZSh0aGlzLCBsaW5lKTt9LFxuICAgIGdldExpbmVOdW1iZXI6IGZ1bmN0aW9uKGxpbmUpIHtyZXR1cm4gbGluZU5vKGxpbmUpO30sXG5cbiAgICBnZXRMaW5lSGFuZGxlVmlzdWFsU3RhcnQ6IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIGlmICh0eXBlb2YgbGluZSA9PSBcIm51bWJlclwiKSBsaW5lID0gZ2V0TGluZSh0aGlzLCBsaW5lKTtcbiAgICAgIHJldHVybiB2aXN1YWxMaW5lKGxpbmUpO1xuICAgIH0sXG5cbiAgICBsaW5lQ291bnQ6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLnNpemU7fSxcbiAgICBmaXJzdExpbmU6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLmZpcnN0O30sXG4gICAgbGFzdExpbmU6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLmZpcnN0ICsgdGhpcy5zaXplIC0gMTt9LFxuXG4gICAgY2xpcFBvczogZnVuY3Rpb24ocG9zKSB7cmV0dXJuIGNsaXBQb3ModGhpcywgcG9zKTt9LFxuXG4gICAgZ2V0Q3Vyc29yOiBmdW5jdGlvbihzdGFydCkge1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5zZWwucHJpbWFyeSgpLCBwb3M7XG4gICAgICBpZiAoc3RhcnQgPT0gbnVsbCB8fCBzdGFydCA9PSBcImhlYWRcIikgcG9zID0gcmFuZ2UuaGVhZDtcbiAgICAgIGVsc2UgaWYgKHN0YXJ0ID09IFwiYW5jaG9yXCIpIHBvcyA9IHJhbmdlLmFuY2hvcjtcbiAgICAgIGVsc2UgaWYgKHN0YXJ0ID09IFwiZW5kXCIgfHwgc3RhcnQgPT0gXCJ0b1wiIHx8IHN0YXJ0ID09PSBmYWxzZSkgcG9zID0gcmFuZ2UudG8oKTtcbiAgICAgIGVsc2UgcG9zID0gcmFuZ2UuZnJvbSgpO1xuICAgICAgcmV0dXJuIHBvcztcbiAgICB9LFxuICAgIGxpc3RTZWxlY3Rpb25zOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuc2VsLnJhbmdlczsgfSxcbiAgICBzb21ldGhpbmdTZWxlY3RlZDogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuc2VsLnNvbWV0aGluZ1NlbGVjdGVkKCk7fSxcblxuICAgIHNldEN1cnNvcjogZG9jTWV0aG9kT3AoZnVuY3Rpb24obGluZSwgY2gsIG9wdGlvbnMpIHtcbiAgICAgIHNldFNpbXBsZVNlbGVjdGlvbih0aGlzLCBjbGlwUG9zKHRoaXMsIHR5cGVvZiBsaW5lID09IFwibnVtYmVyXCIgPyBQb3MobGluZSwgY2ggfHwgMCkgOiBsaW5lKSwgbnVsbCwgb3B0aW9ucyk7XG4gICAgfSksXG4gICAgc2V0U2VsZWN0aW9uOiBkb2NNZXRob2RPcChmdW5jdGlvbihhbmNob3IsIGhlYWQsIG9wdGlvbnMpIHtcbiAgICAgIHNldFNpbXBsZVNlbGVjdGlvbih0aGlzLCBjbGlwUG9zKHRoaXMsIGFuY2hvciksIGNsaXBQb3ModGhpcywgaGVhZCB8fCBhbmNob3IpLCBvcHRpb25zKTtcbiAgICB9KSxcbiAgICBleHRlbmRTZWxlY3Rpb246IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGhlYWQsIG90aGVyLCBvcHRpb25zKSB7XG4gICAgICBleHRlbmRTZWxlY3Rpb24odGhpcywgY2xpcFBvcyh0aGlzLCBoZWFkKSwgb3RoZXIgJiYgY2xpcFBvcyh0aGlzLCBvdGhlciksIG9wdGlvbnMpO1xuICAgIH0pLFxuICAgIGV4dGVuZFNlbGVjdGlvbnM6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGhlYWRzLCBvcHRpb25zKSB7XG4gICAgICBleHRlbmRTZWxlY3Rpb25zKHRoaXMsIGNsaXBQb3NBcnJheSh0aGlzLCBoZWFkcywgb3B0aW9ucykpO1xuICAgIH0pLFxuICAgIGV4dGVuZFNlbGVjdGlvbnNCeTogZG9jTWV0aG9kT3AoZnVuY3Rpb24oZiwgb3B0aW9ucykge1xuICAgICAgZXh0ZW5kU2VsZWN0aW9ucyh0aGlzLCBtYXAodGhpcy5zZWwucmFuZ2VzLCBmKSwgb3B0aW9ucyk7XG4gICAgfSksXG4gICAgc2V0U2VsZWN0aW9uczogZG9jTWV0aG9kT3AoZnVuY3Rpb24ocmFuZ2VzLCBwcmltYXJ5LCBvcHRpb25zKSB7XG4gICAgICBpZiAoIXJhbmdlcy5sZW5ndGgpIHJldHVybjtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBvdXQgPSBbXTsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgb3V0W2ldID0gbmV3IFJhbmdlKGNsaXBQb3ModGhpcywgcmFuZ2VzW2ldLmFuY2hvciksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwUG9zKHRoaXMsIHJhbmdlc1tpXS5oZWFkKSk7XG4gICAgICBpZiAocHJpbWFyeSA9PSBudWxsKSBwcmltYXJ5ID0gTWF0aC5taW4ocmFuZ2VzLmxlbmd0aCAtIDEsIHRoaXMuc2VsLnByaW1JbmRleCk7XG4gICAgICBzZXRTZWxlY3Rpb24odGhpcywgbm9ybWFsaXplU2VsZWN0aW9uKG91dCwgcHJpbWFyeSksIG9wdGlvbnMpO1xuICAgIH0pLFxuICAgIGFkZFNlbGVjdGlvbjogZG9jTWV0aG9kT3AoZnVuY3Rpb24oYW5jaG9yLCBoZWFkLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcmFuZ2VzID0gdGhpcy5zZWwucmFuZ2VzLnNsaWNlKDApO1xuICAgICAgcmFuZ2VzLnB1c2gobmV3IFJhbmdlKGNsaXBQb3ModGhpcywgYW5jaG9yKSwgY2xpcFBvcyh0aGlzLCBoZWFkIHx8IGFuY2hvcikpKTtcbiAgICAgIHNldFNlbGVjdGlvbih0aGlzLCBub3JtYWxpemVTZWxlY3Rpb24ocmFuZ2VzLCByYW5nZXMubGVuZ3RoIC0gMSksIG9wdGlvbnMpO1xuICAgIH0pLFxuXG4gICAgZ2V0U2VsZWN0aW9uOiBmdW5jdGlvbihsaW5lU2VwKSB7XG4gICAgICB2YXIgcmFuZ2VzID0gdGhpcy5zZWwucmFuZ2VzLCBsaW5lcztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzZWwgPSBnZXRCZXR3ZWVuKHRoaXMsIHJhbmdlc1tpXS5mcm9tKCksIHJhbmdlc1tpXS50bygpKTtcbiAgICAgICAgbGluZXMgPSBsaW5lcyA/IGxpbmVzLmNvbmNhdChzZWwpIDogc2VsO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmVTZXAgPT09IGZhbHNlKSByZXR1cm4gbGluZXM7XG4gICAgICBlbHNlIHJldHVybiBsaW5lcy5qb2luKGxpbmVTZXAgfHwgXCJcXG5cIik7XG4gICAgfSxcbiAgICBnZXRTZWxlY3Rpb25zOiBmdW5jdGlvbihsaW5lU2VwKSB7XG4gICAgICB2YXIgcGFydHMgPSBbXSwgcmFuZ2VzID0gdGhpcy5zZWwucmFuZ2VzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNlbCA9IGdldEJldHdlZW4odGhpcywgcmFuZ2VzW2ldLmZyb20oKSwgcmFuZ2VzW2ldLnRvKCkpO1xuICAgICAgICBpZiAobGluZVNlcCAhPT0gZmFsc2UpIHNlbCA9IHNlbC5qb2luKGxpbmVTZXAgfHwgXCJcXG5cIik7XG4gICAgICAgIHBhcnRzW2ldID0gc2VsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnRzO1xuICAgIH0sXG4gICAgcmVwbGFjZVNlbGVjdGlvbjogZnVuY3Rpb24oY29kZSwgY29sbGFwc2UsIG9yaWdpbikge1xuICAgICAgdmFyIGR1cCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNlbC5yYW5nZXMubGVuZ3RoOyBpKyspXG4gICAgICAgIGR1cFtpXSA9IGNvZGU7XG4gICAgICB0aGlzLnJlcGxhY2VTZWxlY3Rpb25zKGR1cCwgY29sbGFwc2UsIG9yaWdpbiB8fCBcIitpbnB1dFwiKTtcbiAgICB9LFxuICAgIHJlcGxhY2VTZWxlY3Rpb25zOiBkb2NNZXRob2RPcChmdW5jdGlvbihjb2RlLCBjb2xsYXBzZSwgb3JpZ2luKSB7XG4gICAgICB2YXIgY2hhbmdlcyA9IFtdLCBzZWwgPSB0aGlzLnNlbDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsLnJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcmFuZ2UgPSBzZWwucmFuZ2VzW2ldO1xuICAgICAgICBjaGFuZ2VzW2ldID0ge2Zyb206IHJhbmdlLmZyb20oKSwgdG86IHJhbmdlLnRvKCksIHRleHQ6IHNwbGl0TGluZXMoY29kZVtpXSksIG9yaWdpbjogb3JpZ2lufTtcbiAgICAgIH1cbiAgICAgIHZhciBuZXdTZWwgPSBjb2xsYXBzZSAmJiBjb2xsYXBzZSAhPSBcImVuZFwiICYmIGNvbXB1dGVSZXBsYWNlZFNlbCh0aGlzLCBjaGFuZ2VzLCBjb2xsYXBzZSk7XG4gICAgICBmb3IgKHZhciBpID0gY2hhbmdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgbWFrZUNoYW5nZSh0aGlzLCBjaGFuZ2VzW2ldKTtcbiAgICAgIGlmIChuZXdTZWwpIHNldFNlbGVjdGlvblJlcGxhY2VIaXN0b3J5KHRoaXMsIG5ld1NlbCk7XG4gICAgICBlbHNlIGlmICh0aGlzLmNtKSBlbnN1cmVDdXJzb3JWaXNpYmxlKHRoaXMuY20pO1xuICAgIH0pLFxuICAgIHVuZG86IGRvY01ldGhvZE9wKGZ1bmN0aW9uKCkge21ha2VDaGFuZ2VGcm9tSGlzdG9yeSh0aGlzLCBcInVuZG9cIik7fSksXG4gICAgcmVkbzogZG9jTWV0aG9kT3AoZnVuY3Rpb24oKSB7bWFrZUNoYW5nZUZyb21IaXN0b3J5KHRoaXMsIFwicmVkb1wiKTt9KSxcbiAgICB1bmRvU2VsZWN0aW9uOiBkb2NNZXRob2RPcChmdW5jdGlvbigpIHttYWtlQ2hhbmdlRnJvbUhpc3RvcnkodGhpcywgXCJ1bmRvXCIsIHRydWUpO30pLFxuICAgIHJlZG9TZWxlY3Rpb246IGRvY01ldGhvZE9wKGZ1bmN0aW9uKCkge21ha2VDaGFuZ2VGcm9tSGlzdG9yeSh0aGlzLCBcInJlZG9cIiwgdHJ1ZSk7fSksXG5cbiAgICBzZXRFeHRlbmRpbmc6IGZ1bmN0aW9uKHZhbCkge3RoaXMuZXh0ZW5kID0gdmFsO30sXG4gICAgZ2V0RXh0ZW5kaW5nOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5leHRlbmQ7fSxcblxuICAgIGhpc3RvcnlTaXplOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBoaXN0ID0gdGhpcy5oaXN0b3J5LCBkb25lID0gMCwgdW5kb25lID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGlzdC5kb25lLmxlbmd0aDsgaSsrKSBpZiAoIWhpc3QuZG9uZVtpXS5yYW5nZXMpICsrZG9uZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGlzdC51bmRvbmUubGVuZ3RoOyBpKyspIGlmICghaGlzdC51bmRvbmVbaV0ucmFuZ2VzKSArK3VuZG9uZTtcbiAgICAgIHJldHVybiB7dW5kbzogZG9uZSwgcmVkbzogdW5kb25lfTtcbiAgICB9LFxuICAgIGNsZWFySGlzdG9yeTogZnVuY3Rpb24oKSB7dGhpcy5oaXN0b3J5ID0gbmV3IEhpc3RvcnkodGhpcy5oaXN0b3J5Lm1heEdlbmVyYXRpb24pO30sXG5cbiAgICBtYXJrQ2xlYW46IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5jbGVhbkdlbmVyYXRpb24gPSB0aGlzLmNoYW5nZUdlbmVyYXRpb24odHJ1ZSk7XG4gICAgfSxcbiAgICBjaGFuZ2VHZW5lcmF0aW9uOiBmdW5jdGlvbihmb3JjZVNwbGl0KSB7XG4gICAgICBpZiAoZm9yY2VTcGxpdClcbiAgICAgICAgdGhpcy5oaXN0b3J5Lmxhc3RPcCA9IHRoaXMuaGlzdG9yeS5sYXN0T3JpZ2luID0gbnVsbDtcbiAgICAgIHJldHVybiB0aGlzLmhpc3RvcnkuZ2VuZXJhdGlvbjtcbiAgICB9LFxuICAgIGlzQ2xlYW46IGZ1bmN0aW9uIChnZW4pIHtcbiAgICAgIHJldHVybiB0aGlzLmhpc3RvcnkuZ2VuZXJhdGlvbiA9PSAoZ2VuIHx8IHRoaXMuY2xlYW5HZW5lcmF0aW9uKTtcbiAgICB9LFxuXG4gICAgZ2V0SGlzdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge2RvbmU6IGNvcHlIaXN0b3J5QXJyYXkodGhpcy5oaXN0b3J5LmRvbmUpLFxuICAgICAgICAgICAgICB1bmRvbmU6IGNvcHlIaXN0b3J5QXJyYXkodGhpcy5oaXN0b3J5LnVuZG9uZSl9O1xuICAgIH0sXG4gICAgc2V0SGlzdG9yeTogZnVuY3Rpb24oaGlzdERhdGEpIHtcbiAgICAgIHZhciBoaXN0ID0gdGhpcy5oaXN0b3J5ID0gbmV3IEhpc3RvcnkodGhpcy5oaXN0b3J5Lm1heEdlbmVyYXRpb24pO1xuICAgICAgaGlzdC5kb25lID0gY29weUhpc3RvcnlBcnJheShoaXN0RGF0YS5kb25lLnNsaWNlKDApLCBudWxsLCB0cnVlKTtcbiAgICAgIGhpc3QudW5kb25lID0gY29weUhpc3RvcnlBcnJheShoaXN0RGF0YS51bmRvbmUuc2xpY2UoMCksIG51bGwsIHRydWUpO1xuICAgIH0sXG5cbiAgICBtYXJrVGV4dDogZnVuY3Rpb24oZnJvbSwgdG8sIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBtYXJrVGV4dCh0aGlzLCBjbGlwUG9zKHRoaXMsIGZyb20pLCBjbGlwUG9zKHRoaXMsIHRvKSwgb3B0aW9ucywgXCJyYW5nZVwiKTtcbiAgICB9LFxuICAgIHNldEJvb2ttYXJrOiBmdW5jdGlvbihwb3MsIG9wdGlvbnMpIHtcbiAgICAgIHZhciByZWFsT3B0cyA9IHtyZXBsYWNlZFdpdGg6IG9wdGlvbnMgJiYgKG9wdGlvbnMubm9kZVR5cGUgPT0gbnVsbCA/IG9wdGlvbnMud2lkZ2V0IDogb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0TGVmdDogb3B0aW9ucyAmJiBvcHRpb25zLmluc2VydExlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgY2xlYXJXaGVuRW1wdHk6IGZhbHNlLCBzaGFyZWQ6IG9wdGlvbnMgJiYgb3B0aW9ucy5zaGFyZWR9O1xuICAgICAgcG9zID0gY2xpcFBvcyh0aGlzLCBwb3MpO1xuICAgICAgcmV0dXJuIG1hcmtUZXh0KHRoaXMsIHBvcywgcG9zLCByZWFsT3B0cywgXCJib29rbWFya1wiKTtcbiAgICB9LFxuICAgIGZpbmRNYXJrc0F0OiBmdW5jdGlvbihwb3MpIHtcbiAgICAgIHBvcyA9IGNsaXBQb3ModGhpcywgcG9zKTtcbiAgICAgIHZhciBtYXJrZXJzID0gW10sIHNwYW5zID0gZ2V0TGluZSh0aGlzLCBwb3MubGluZSkubWFya2VkU3BhbnM7XG4gICAgICBpZiAoc3BhbnMpIGZvciAodmFyIGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHNwYW4gPSBzcGFuc1tpXTtcbiAgICAgICAgaWYgKChzcGFuLmZyb20gPT0gbnVsbCB8fCBzcGFuLmZyb20gPD0gcG9zLmNoKSAmJlxuICAgICAgICAgICAgKHNwYW4udG8gPT0gbnVsbCB8fCBzcGFuLnRvID49IHBvcy5jaCkpXG4gICAgICAgICAgbWFya2Vycy5wdXNoKHNwYW4ubWFya2VyLnBhcmVudCB8fCBzcGFuLm1hcmtlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFya2VycztcbiAgICB9LFxuICAgIGZpbmRNYXJrczogZnVuY3Rpb24oZnJvbSwgdG8sIGZpbHRlcikge1xuICAgICAgZnJvbSA9IGNsaXBQb3ModGhpcywgZnJvbSk7IHRvID0gY2xpcFBvcyh0aGlzLCB0byk7XG4gICAgICB2YXIgZm91bmQgPSBbXSwgbGluZU5vID0gZnJvbS5saW5lO1xuICAgICAgdGhpcy5pdGVyKGZyb20ubGluZSwgdG8ubGluZSArIDEsIGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgdmFyIHNwYW5zID0gbGluZS5tYXJrZWRTcGFucztcbiAgICAgICAgaWYgKHNwYW5zKSBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHNwYW4gPSBzcGFuc1tpXTtcbiAgICAgICAgICBpZiAoIShsaW5lTm8gPT0gZnJvbS5saW5lICYmIGZyb20uY2ggPiBzcGFuLnRvIHx8XG4gICAgICAgICAgICAgICAgc3Bhbi5mcm9tID09IG51bGwgJiYgbGluZU5vICE9IGZyb20ubGluZXx8XG4gICAgICAgICAgICAgICAgbGluZU5vID09IHRvLmxpbmUgJiYgc3Bhbi5mcm9tID4gdG8uY2gpICYmXG4gICAgICAgICAgICAgICghZmlsdGVyIHx8IGZpbHRlcihzcGFuLm1hcmtlcikpKVxuICAgICAgICAgICAgZm91bmQucHVzaChzcGFuLm1hcmtlci5wYXJlbnQgfHwgc3Bhbi5tYXJrZXIpO1xuICAgICAgICB9XG4gICAgICAgICsrbGluZU5vO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZm91bmQ7XG4gICAgfSxcbiAgICBnZXRBbGxNYXJrczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbWFya2VycyA9IFtdO1xuICAgICAgdGhpcy5pdGVyKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgdmFyIHNwcyA9IGxpbmUubWFya2VkU3BhbnM7XG4gICAgICAgIGlmIChzcHMpIGZvciAodmFyIGkgPSAwOyBpIDwgc3BzLmxlbmd0aDsgKytpKVxuICAgICAgICAgIGlmIChzcHNbaV0uZnJvbSAhPSBudWxsKSBtYXJrZXJzLnB1c2goc3BzW2ldLm1hcmtlcik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBtYXJrZXJzO1xuICAgIH0sXG5cbiAgICBwb3NGcm9tSW5kZXg6IGZ1bmN0aW9uKG9mZikge1xuICAgICAgdmFyIGNoLCBsaW5lTm8gPSB0aGlzLmZpcnN0O1xuICAgICAgdGhpcy5pdGVyKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgdmFyIHN6ID0gbGluZS50ZXh0Lmxlbmd0aCArIDE7XG4gICAgICAgIGlmIChzeiA+IG9mZikgeyBjaCA9IG9mZjsgcmV0dXJuIHRydWU7IH1cbiAgICAgICAgb2ZmIC09IHN6O1xuICAgICAgICArK2xpbmVObztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNsaXBQb3ModGhpcywgUG9zKGxpbmVObywgY2gpKTtcbiAgICB9LFxuICAgIGluZGV4RnJvbVBvczogZnVuY3Rpb24gKGNvb3Jkcykge1xuICAgICAgY29vcmRzID0gY2xpcFBvcyh0aGlzLCBjb29yZHMpO1xuICAgICAgdmFyIGluZGV4ID0gY29vcmRzLmNoO1xuICAgICAgaWYgKGNvb3Jkcy5saW5lIDwgdGhpcy5maXJzdCB8fCBjb29yZHMuY2ggPCAwKSByZXR1cm4gMDtcbiAgICAgIHRoaXMuaXRlcih0aGlzLmZpcnN0LCBjb29yZHMubGluZSwgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgaW5kZXggKz0gbGluZS50ZXh0Lmxlbmd0aCArIDE7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9LFxuXG4gICAgY29weTogZnVuY3Rpb24oY29weUhpc3RvcnkpIHtcbiAgICAgIHZhciBkb2MgPSBuZXcgRG9jKGdldExpbmVzKHRoaXMsIHRoaXMuZmlyc3QsIHRoaXMuZmlyc3QgKyB0aGlzLnNpemUpLCB0aGlzLm1vZGVPcHRpb24sIHRoaXMuZmlyc3QpO1xuICAgICAgZG9jLnNjcm9sbFRvcCA9IHRoaXMuc2Nyb2xsVG9wOyBkb2Muc2Nyb2xsTGVmdCA9IHRoaXMuc2Nyb2xsTGVmdDtcbiAgICAgIGRvYy5zZWwgPSB0aGlzLnNlbDtcbiAgICAgIGRvYy5leHRlbmQgPSBmYWxzZTtcbiAgICAgIGlmIChjb3B5SGlzdG9yeSkge1xuICAgICAgICBkb2MuaGlzdG9yeS51bmRvRGVwdGggPSB0aGlzLmhpc3RvcnkudW5kb0RlcHRoO1xuICAgICAgICBkb2Muc2V0SGlzdG9yeSh0aGlzLmdldEhpc3RvcnkoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZG9jO1xuICAgIH0sXG5cbiAgICBsaW5rZWREb2M6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICAgICAgdmFyIGZyb20gPSB0aGlzLmZpcnN0LCB0byA9IHRoaXMuZmlyc3QgKyB0aGlzLnNpemU7XG4gICAgICBpZiAob3B0aW9ucy5mcm9tICE9IG51bGwgJiYgb3B0aW9ucy5mcm9tID4gZnJvbSkgZnJvbSA9IG9wdGlvbnMuZnJvbTtcbiAgICAgIGlmIChvcHRpb25zLnRvICE9IG51bGwgJiYgb3B0aW9ucy50byA8IHRvKSB0byA9IG9wdGlvbnMudG87XG4gICAgICB2YXIgY29weSA9IG5ldyBEb2MoZ2V0TGluZXModGhpcywgZnJvbSwgdG8pLCBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlT3B0aW9uLCBmcm9tKTtcbiAgICAgIGlmIChvcHRpb25zLnNoYXJlZEhpc3QpIGNvcHkuaGlzdG9yeSA9IHRoaXMuaGlzdG9yeTtcbiAgICAgICh0aGlzLmxpbmtlZCB8fCAodGhpcy5saW5rZWQgPSBbXSkpLnB1c2goe2RvYzogY29weSwgc2hhcmVkSGlzdDogb3B0aW9ucy5zaGFyZWRIaXN0fSk7XG4gICAgICBjb3B5LmxpbmtlZCA9IFt7ZG9jOiB0aGlzLCBpc1BhcmVudDogdHJ1ZSwgc2hhcmVkSGlzdDogb3B0aW9ucy5zaGFyZWRIaXN0fV07XG4gICAgICBjb3B5U2hhcmVkTWFya2Vycyhjb3B5LCBmaW5kU2hhcmVkTWFya2Vycyh0aGlzKSk7XG4gICAgICByZXR1cm4gY29weTtcbiAgICB9LFxuICAgIHVubGlua0RvYzogZnVuY3Rpb24ob3RoZXIpIHtcbiAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIENvZGVNaXJyb3IpIG90aGVyID0gb3RoZXIuZG9jO1xuICAgICAgaWYgKHRoaXMubGlua2VkKSBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGlua2VkLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBsaW5rID0gdGhpcy5saW5rZWRbaV07XG4gICAgICAgIGlmIChsaW5rLmRvYyAhPSBvdGhlcikgY29udGludWU7XG4gICAgICAgIHRoaXMubGlua2VkLnNwbGljZShpLCAxKTtcbiAgICAgICAgb3RoZXIudW5saW5rRG9jKHRoaXMpO1xuICAgICAgICBkZXRhY2hTaGFyZWRNYXJrZXJzKGZpbmRTaGFyZWRNYXJrZXJzKHRoaXMpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBJZiB0aGUgaGlzdG9yaWVzIHdlcmUgc2hhcmVkLCBzcGxpdCB0aGVtIGFnYWluXG4gICAgICBpZiAob3RoZXIuaGlzdG9yeSA9PSB0aGlzLmhpc3RvcnkpIHtcbiAgICAgICAgdmFyIHNwbGl0SWRzID0gW290aGVyLmlkXTtcbiAgICAgICAgbGlua2VkRG9jcyhvdGhlciwgZnVuY3Rpb24oZG9jKSB7c3BsaXRJZHMucHVzaChkb2MuaWQpO30sIHRydWUpO1xuICAgICAgICBvdGhlci5oaXN0b3J5ID0gbmV3IEhpc3RvcnkobnVsbCk7XG4gICAgICAgIG90aGVyLmhpc3RvcnkuZG9uZSA9IGNvcHlIaXN0b3J5QXJyYXkodGhpcy5oaXN0b3J5LmRvbmUsIHNwbGl0SWRzKTtcbiAgICAgICAgb3RoZXIuaGlzdG9yeS51bmRvbmUgPSBjb3B5SGlzdG9yeUFycmF5KHRoaXMuaGlzdG9yeS51bmRvbmUsIHNwbGl0SWRzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGl0ZXJMaW5rZWREb2NzOiBmdW5jdGlvbihmKSB7bGlua2VkRG9jcyh0aGlzLCBmKTt9LFxuXG4gICAgZ2V0TW9kZTogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMubW9kZTt9LFxuICAgIGdldEVkaXRvcjogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuY207fVxuICB9KTtcblxuICAvLyBQdWJsaWMgYWxpYXMuXG4gIERvYy5wcm90b3R5cGUuZWFjaExpbmUgPSBEb2MucHJvdG90eXBlLml0ZXI7XG5cbiAgLy8gU2V0IHVwIG1ldGhvZHMgb24gQ29kZU1pcnJvcidzIHByb3RvdHlwZSB0byByZWRpcmVjdCB0byB0aGUgZWRpdG9yJ3MgZG9jdW1lbnQuXG4gIHZhciBkb250RGVsZWdhdGUgPSBcIml0ZXIgaW5zZXJ0IHJlbW92ZSBjb3B5IGdldEVkaXRvclwiLnNwbGl0KFwiIFwiKTtcbiAgZm9yICh2YXIgcHJvcCBpbiBEb2MucHJvdG90eXBlKSBpZiAoRG9jLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiBpbmRleE9mKGRvbnREZWxlZ2F0ZSwgcHJvcCkgPCAwKVxuICAgIENvZGVNaXJyb3IucHJvdG90eXBlW3Byb3BdID0gKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge3JldHVybiBtZXRob2QuYXBwbHkodGhpcy5kb2MsIGFyZ3VtZW50cyk7fTtcbiAgICB9KShEb2MucHJvdG90eXBlW3Byb3BdKTtcblxuICBldmVudE1peGluKERvYyk7XG5cbiAgLy8gQ2FsbCBmIGZvciBhbGwgbGlua2VkIGRvY3VtZW50cy5cbiAgZnVuY3Rpb24gbGlua2VkRG9jcyhkb2MsIGYsIHNoYXJlZEhpc3RPbmx5KSB7XG4gICAgZnVuY3Rpb24gcHJvcGFnYXRlKGRvYywgc2tpcCwgc2hhcmVkSGlzdCkge1xuICAgICAgaWYgKGRvYy5saW5rZWQpIGZvciAodmFyIGkgPSAwOyBpIDwgZG9jLmxpbmtlZC5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcmVsID0gZG9jLmxpbmtlZFtpXTtcbiAgICAgICAgaWYgKHJlbC5kb2MgPT0gc2tpcCkgY29udGludWU7XG4gICAgICAgIHZhciBzaGFyZWQgPSBzaGFyZWRIaXN0ICYmIHJlbC5zaGFyZWRIaXN0O1xuICAgICAgICBpZiAoc2hhcmVkSGlzdE9ubHkgJiYgIXNoYXJlZCkgY29udGludWU7XG4gICAgICAgIGYocmVsLmRvYywgc2hhcmVkKTtcbiAgICAgICAgcHJvcGFnYXRlKHJlbC5kb2MsIGRvYywgc2hhcmVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcHJvcGFnYXRlKGRvYywgbnVsbCwgdHJ1ZSk7XG4gIH1cblxuICAvLyBBdHRhY2ggYSBkb2N1bWVudCB0byBhbiBlZGl0b3IuXG4gIGZ1bmN0aW9uIGF0dGFjaERvYyhjbSwgZG9jKSB7XG4gICAgaWYgKGRvYy5jbSkgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBkb2N1bWVudCBpcyBhbHJlYWR5IGluIHVzZS5cIik7XG4gICAgY20uZG9jID0gZG9jO1xuICAgIGRvYy5jbSA9IGNtO1xuICAgIGVzdGltYXRlTGluZUhlaWdodHMoY20pO1xuICAgIGxvYWRNb2RlKGNtKTtcbiAgICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSBmaW5kTWF4TGluZShjbSk7XG4gICAgY20ub3B0aW9ucy5tb2RlID0gZG9jLm1vZGVPcHRpb247XG4gICAgcmVnQ2hhbmdlKGNtKTtcbiAgfVxuXG4gIC8vIExJTkUgVVRJTElUSUVTXG5cbiAgLy8gRmluZCB0aGUgbGluZSBvYmplY3QgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gbGluZSBudW1iZXIuXG4gIGZ1bmN0aW9uIGdldExpbmUoZG9jLCBuKSB7XG4gICAgbiAtPSBkb2MuZmlyc3Q7XG4gICAgaWYgKG4gPCAwIHx8IG4gPj0gZG9jLnNpemUpIHRocm93IG5ldyBFcnJvcihcIlRoZXJlIGlzIG5vIGxpbmUgXCIgKyAobiArIGRvYy5maXJzdCkgKyBcIiBpbiB0aGUgZG9jdW1lbnQuXCIpO1xuICAgIGZvciAodmFyIGNodW5rID0gZG9jOyAhY2h1bmsubGluZXM7KSB7XG4gICAgICBmb3IgKHZhciBpID0gMDs7ICsraSkge1xuICAgICAgICB2YXIgY2hpbGQgPSBjaHVuay5jaGlsZHJlbltpXSwgc3ogPSBjaGlsZC5jaHVua1NpemUoKTtcbiAgICAgICAgaWYgKG4gPCBzeikgeyBjaHVuayA9IGNoaWxkOyBicmVhazsgfVxuICAgICAgICBuIC09IHN6O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2h1bmsubGluZXNbbl07XG4gIH1cblxuICAvLyBHZXQgdGhlIHBhcnQgb2YgYSBkb2N1bWVudCBiZXR3ZWVuIHR3byBwb3NpdGlvbnMsIGFzIGFuIGFycmF5IG9mXG4gIC8vIHN0cmluZ3MuXG4gIGZ1bmN0aW9uIGdldEJldHdlZW4oZG9jLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIG91dCA9IFtdLCBuID0gc3RhcnQubGluZTtcbiAgICBkb2MuaXRlcihzdGFydC5saW5lLCBlbmQubGluZSArIDEsIGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHZhciB0ZXh0ID0gbGluZS50ZXh0O1xuICAgICAgaWYgKG4gPT0gZW5kLmxpbmUpIHRleHQgPSB0ZXh0LnNsaWNlKDAsIGVuZC5jaCk7XG4gICAgICBpZiAobiA9PSBzdGFydC5saW5lKSB0ZXh0ID0gdGV4dC5zbGljZShzdGFydC5jaCk7XG4gICAgICBvdXQucHVzaCh0ZXh0KTtcbiAgICAgICsrbjtcbiAgICB9KTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIC8vIEdldCB0aGUgbGluZXMgYmV0d2VlbiBmcm9tIGFuZCB0bywgYXMgYXJyYXkgb2Ygc3RyaW5ncy5cbiAgZnVuY3Rpb24gZ2V0TGluZXMoZG9jLCBmcm9tLCB0bykge1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICBkb2MuaXRlcihmcm9tLCB0bywgZnVuY3Rpb24obGluZSkgeyBvdXQucHVzaChsaW5lLnRleHQpOyB9KTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgLy8gVXBkYXRlIHRoZSBoZWlnaHQgb2YgYSBsaW5lLCBwcm9wYWdhdGluZyB0aGUgaGVpZ2h0IGNoYW5nZVxuICAvLyB1cHdhcmRzIHRvIHBhcmVudCBub2Rlcy5cbiAgZnVuY3Rpb24gdXBkYXRlTGluZUhlaWdodChsaW5lLCBoZWlnaHQpIHtcbiAgICB2YXIgZGlmZiA9IGhlaWdodCAtIGxpbmUuaGVpZ2h0O1xuICAgIGlmIChkaWZmKSBmb3IgKHZhciBuID0gbGluZTsgbjsgbiA9IG4ucGFyZW50KSBuLmhlaWdodCArPSBkaWZmO1xuICB9XG5cbiAgLy8gR2l2ZW4gYSBsaW5lIG9iamVjdCwgZmluZCBpdHMgbGluZSBudW1iZXIgYnkgd2Fsa2luZyB1cCB0aHJvdWdoXG4gIC8vIGl0cyBwYXJlbnQgbGlua3MuXG4gIGZ1bmN0aW9uIGxpbmVObyhsaW5lKSB7XG4gICAgaWYgKGxpbmUucGFyZW50ID09IG51bGwpIHJldHVybiBudWxsO1xuICAgIHZhciBjdXIgPSBsaW5lLnBhcmVudCwgbm8gPSBpbmRleE9mKGN1ci5saW5lcywgbGluZSk7XG4gICAgZm9yICh2YXIgY2h1bmsgPSBjdXIucGFyZW50OyBjaHVuazsgY3VyID0gY2h1bmssIGNodW5rID0gY2h1bmsucGFyZW50KSB7XG4gICAgICBmb3IgKHZhciBpID0gMDs7ICsraSkge1xuICAgICAgICBpZiAoY2h1bmsuY2hpbGRyZW5baV0gPT0gY3VyKSBicmVhaztcbiAgICAgICAgbm8gKz0gY2h1bmsuY2hpbGRyZW5baV0uY2h1bmtTaXplKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBubyArIGN1ci5maXJzdDtcbiAgfVxuXG4gIC8vIEZpbmQgdGhlIGxpbmUgYXQgdGhlIGdpdmVuIHZlcnRpY2FsIHBvc2l0aW9uLCB1c2luZyB0aGUgaGVpZ2h0XG4gIC8vIGluZm9ybWF0aW9uIGluIHRoZSBkb2N1bWVudCB0cmVlLlxuICBmdW5jdGlvbiBsaW5lQXRIZWlnaHQoY2h1bmssIGgpIHtcbiAgICB2YXIgbiA9IGNodW5rLmZpcnN0O1xuICAgIG91dGVyOiBkbyB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNodW5rLmNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNodW5rLmNoaWxkcmVuW2ldLCBjaCA9IGNoaWxkLmhlaWdodDtcbiAgICAgICAgaWYgKGggPCBjaCkgeyBjaHVuayA9IGNoaWxkOyBjb250aW51ZSBvdXRlcjsgfVxuICAgICAgICBoIC09IGNoO1xuICAgICAgICBuICs9IGNoaWxkLmNodW5rU2l6ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG47XG4gICAgfSB3aGlsZSAoIWNodW5rLmxpbmVzKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNodW5rLmxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgbGluZSA9IGNodW5rLmxpbmVzW2ldLCBsaCA9IGxpbmUuaGVpZ2h0O1xuICAgICAgaWYgKGggPCBsaCkgYnJlYWs7XG4gICAgICBoIC09IGxoO1xuICAgIH1cbiAgICByZXR1cm4gbiArIGk7XG4gIH1cblxuXG4gIC8vIEZpbmQgdGhlIGhlaWdodCBhYm92ZSB0aGUgZ2l2ZW4gbGluZS5cbiAgZnVuY3Rpb24gaGVpZ2h0QXRMaW5lKGxpbmVPYmopIHtcbiAgICBsaW5lT2JqID0gdmlzdWFsTGluZShsaW5lT2JqKTtcblxuICAgIHZhciBoID0gMCwgY2h1bmsgPSBsaW5lT2JqLnBhcmVudDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNodW5rLmxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgbGluZSA9IGNodW5rLmxpbmVzW2ldO1xuICAgICAgaWYgKGxpbmUgPT0gbGluZU9iaikgYnJlYWs7XG4gICAgICBlbHNlIGggKz0gbGluZS5oZWlnaHQ7XG4gICAgfVxuICAgIGZvciAodmFyIHAgPSBjaHVuay5wYXJlbnQ7IHA7IGNodW5rID0gcCwgcCA9IGNodW5rLnBhcmVudCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjdXIgPSBwLmNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoY3VyID09IGNodW5rKSBicmVhaztcbiAgICAgICAgZWxzZSBoICs9IGN1ci5oZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoO1xuICB9XG5cbiAgLy8gR2V0IHRoZSBiaWRpIG9yZGVyaW5nIGZvciB0aGUgZ2l2ZW4gbGluZSAoYW5kIGNhY2hlIGl0KS4gUmV0dXJuc1xuICAvLyBmYWxzZSBmb3IgbGluZXMgdGhhdCBhcmUgZnVsbHkgbGVmdC10by1yaWdodCwgYW5kIGFuIGFycmF5IG9mXG4gIC8vIEJpZGlTcGFuIG9iamVjdHMgb3RoZXJ3aXNlLlxuICBmdW5jdGlvbiBnZXRPcmRlcihsaW5lKSB7XG4gICAgdmFyIG9yZGVyID0gbGluZS5vcmRlcjtcbiAgICBpZiAob3JkZXIgPT0gbnVsbCkgb3JkZXIgPSBsaW5lLm9yZGVyID0gYmlkaU9yZGVyaW5nKGxpbmUudGV4dCk7XG4gICAgcmV0dXJuIG9yZGVyO1xuICB9XG5cbiAgLy8gSElTVE9SWVxuXG4gIGZ1bmN0aW9uIEhpc3Rvcnkoc3RhcnRHZW4pIHtcbiAgICAvLyBBcnJheXMgb2YgY2hhbmdlIGV2ZW50cyBhbmQgc2VsZWN0aW9ucy4gRG9pbmcgc29tZXRoaW5nIGFkZHMgYW5cbiAgICAvLyBldmVudCB0byBkb25lIGFuZCBjbGVhcnMgdW5kby4gVW5kb2luZyBtb3ZlcyBldmVudHMgZnJvbSBkb25lXG4gICAgLy8gdG8gdW5kb25lLCByZWRvaW5nIG1vdmVzIHRoZW0gaW4gdGhlIG90aGVyIGRpcmVjdGlvbi5cbiAgICB0aGlzLmRvbmUgPSBbXTsgdGhpcy51bmRvbmUgPSBbXTtcbiAgICB0aGlzLnVuZG9EZXB0aCA9IEluZmluaXR5O1xuICAgIC8vIFVzZWQgdG8gdHJhY2sgd2hlbiBjaGFuZ2VzIGNhbiBiZSBtZXJnZWQgaW50byBhIHNpbmdsZSB1bmRvXG4gICAgLy8gZXZlbnRcbiAgICB0aGlzLmxhc3RNb2RUaW1lID0gdGhpcy5sYXN0U2VsVGltZSA9IDA7XG4gICAgdGhpcy5sYXN0T3AgPSBudWxsO1xuICAgIHRoaXMubGFzdE9yaWdpbiA9IHRoaXMubGFzdFNlbE9yaWdpbiA9IG51bGw7XG4gICAgLy8gVXNlZCBieSB0aGUgaXNDbGVhbigpIG1ldGhvZFxuICAgIHRoaXMuZ2VuZXJhdGlvbiA9IHRoaXMubWF4R2VuZXJhdGlvbiA9IHN0YXJ0R2VuIHx8IDE7XG4gIH1cblxuICAvLyBDcmVhdGUgYSBoaXN0b3J5IGNoYW5nZSBldmVudCBmcm9tIGFuIHVwZGF0ZURvYy1zdHlsZSBjaGFuZ2VcbiAgLy8gb2JqZWN0LlxuICBmdW5jdGlvbiBoaXN0b3J5Q2hhbmdlRnJvbUNoYW5nZShkb2MsIGNoYW5nZSkge1xuICAgIHZhciBoaXN0Q2hhbmdlID0ge2Zyb206IGNvcHlQb3MoY2hhbmdlLmZyb20pLCB0bzogY2hhbmdlRW5kKGNoYW5nZSksIHRleHQ6IGdldEJldHdlZW4oZG9jLCBjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKX07XG4gICAgYXR0YWNoTG9jYWxTcGFucyhkb2MsIGhpc3RDaGFuZ2UsIGNoYW5nZS5mcm9tLmxpbmUsIGNoYW5nZS50by5saW5lICsgMSk7XG4gICAgbGlua2VkRG9jcyhkb2MsIGZ1bmN0aW9uKGRvYykge2F0dGFjaExvY2FsU3BhbnMoZG9jLCBoaXN0Q2hhbmdlLCBjaGFuZ2UuZnJvbS5saW5lLCBjaGFuZ2UudG8ubGluZSArIDEpO30sIHRydWUpO1xuICAgIHJldHVybiBoaXN0Q2hhbmdlO1xuICB9XG5cbiAgLy8gUG9wIGFsbCBzZWxlY3Rpb24gZXZlbnRzIG9mZiB0aGUgZW5kIG9mIGEgaGlzdG9yeSBhcnJheS4gU3RvcCBhdFxuICAvLyBhIGNoYW5nZSBldmVudC5cbiAgZnVuY3Rpb24gY2xlYXJTZWxlY3Rpb25FdmVudHMoYXJyYXkpIHtcbiAgICB3aGlsZSAoYXJyYXkubGVuZ3RoKSB7XG4gICAgICB2YXIgbGFzdCA9IGxzdChhcnJheSk7XG4gICAgICBpZiAobGFzdC5yYW5nZXMpIGFycmF5LnBvcCgpO1xuICAgICAgZWxzZSBicmVhaztcbiAgICB9XG4gIH1cblxuICAvLyBGaW5kIHRoZSB0b3AgY2hhbmdlIGV2ZW50IGluIHRoZSBoaXN0b3J5LiBQb3Agb2ZmIHNlbGVjdGlvblxuICAvLyBldmVudHMgdGhhdCBhcmUgaW4gdGhlIHdheS5cbiAgZnVuY3Rpb24gbGFzdENoYW5nZUV2ZW50KGhpc3QsIGZvcmNlKSB7XG4gICAgaWYgKGZvcmNlKSB7XG4gICAgICBjbGVhclNlbGVjdGlvbkV2ZW50cyhoaXN0LmRvbmUpO1xuICAgICAgcmV0dXJuIGxzdChoaXN0LmRvbmUpO1xuICAgIH0gZWxzZSBpZiAoaGlzdC5kb25lLmxlbmd0aCAmJiAhbHN0KGhpc3QuZG9uZSkucmFuZ2VzKSB7XG4gICAgICByZXR1cm4gbHN0KGhpc3QuZG9uZSk7XG4gICAgfSBlbHNlIGlmIChoaXN0LmRvbmUubGVuZ3RoID4gMSAmJiAhaGlzdC5kb25lW2hpc3QuZG9uZS5sZW5ndGggLSAyXS5yYW5nZXMpIHtcbiAgICAgIGhpc3QuZG9uZS5wb3AoKTtcbiAgICAgIHJldHVybiBsc3QoaGlzdC5kb25lKTtcbiAgICB9XG4gIH1cblxuICAvLyBSZWdpc3RlciBhIGNoYW5nZSBpbiB0aGUgaGlzdG9yeS4gTWVyZ2VzIGNoYW5nZXMgdGhhdCBhcmUgd2l0aGluXG4gIC8vIGEgc2luZ2xlIG9wZXJhdGlvbiwgb3JlIGFyZSBjbG9zZSB0b2dldGhlciB3aXRoIGFuIG9yaWdpbiB0aGF0XG4gIC8vIGFsbG93cyBtZXJnaW5nIChzdGFydGluZyB3aXRoIFwiK1wiKSBpbnRvIGEgc2luZ2xlIGV2ZW50LlxuICBmdW5jdGlvbiBhZGRDaGFuZ2VUb0hpc3RvcnkoZG9jLCBjaGFuZ2UsIHNlbEFmdGVyLCBvcElkKSB7XG4gICAgdmFyIGhpc3QgPSBkb2MuaGlzdG9yeTtcbiAgICBoaXN0LnVuZG9uZS5sZW5ndGggPSAwO1xuICAgIHZhciB0aW1lID0gK25ldyBEYXRlLCBjdXI7XG5cbiAgICBpZiAoKGhpc3QubGFzdE9wID09IG9wSWQgfHxcbiAgICAgICAgIGhpc3QubGFzdE9yaWdpbiA9PSBjaGFuZ2Uub3JpZ2luICYmIGNoYW5nZS5vcmlnaW4gJiZcbiAgICAgICAgICgoY2hhbmdlLm9yaWdpbi5jaGFyQXQoMCkgPT0gXCIrXCIgJiYgZG9jLmNtICYmIGhpc3QubGFzdE1vZFRpbWUgPiB0aW1lIC0gZG9jLmNtLm9wdGlvbnMuaGlzdG9yeUV2ZW50RGVsYXkpIHx8XG4gICAgICAgICAgY2hhbmdlLm9yaWdpbi5jaGFyQXQoMCkgPT0gXCIqXCIpKSAmJlxuICAgICAgICAoY3VyID0gbGFzdENoYW5nZUV2ZW50KGhpc3QsIGhpc3QubGFzdE9wID09IG9wSWQpKSkge1xuICAgICAgLy8gTWVyZ2UgdGhpcyBjaGFuZ2UgaW50byB0aGUgbGFzdCBldmVudFxuICAgICAgdmFyIGxhc3QgPSBsc3QoY3VyLmNoYW5nZXMpO1xuICAgICAgaWYgKGNtcChjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKSA9PSAwICYmIGNtcChjaGFuZ2UuZnJvbSwgbGFzdC50bykgPT0gMCkge1xuICAgICAgICAvLyBPcHRpbWl6ZWQgY2FzZSBmb3Igc2ltcGxlIGluc2VydGlvbiAtLSBkb24ndCB3YW50IHRvIGFkZFxuICAgICAgICAvLyBuZXcgY2hhbmdlc2V0cyBmb3IgZXZlcnkgY2hhcmFjdGVyIHR5cGVkXG4gICAgICAgIGxhc3QudG8gPSBjaGFuZ2VFbmQoY2hhbmdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFkZCBuZXcgc3ViLWV2ZW50XG4gICAgICAgIGN1ci5jaGFuZ2VzLnB1c2goaGlzdG9yeUNoYW5nZUZyb21DaGFuZ2UoZG9jLCBjaGFuZ2UpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2FuIG5vdCBiZSBtZXJnZWQsIHN0YXJ0IGEgbmV3IGV2ZW50LlxuICAgICAgdmFyIGJlZm9yZSA9IGxzdChoaXN0LmRvbmUpO1xuICAgICAgaWYgKCFiZWZvcmUgfHwgIWJlZm9yZS5yYW5nZXMpXG4gICAgICAgIHB1c2hTZWxlY3Rpb25Ub0hpc3RvcnkoZG9jLnNlbCwgaGlzdC5kb25lKTtcbiAgICAgIGN1ciA9IHtjaGFuZ2VzOiBbaGlzdG9yeUNoYW5nZUZyb21DaGFuZ2UoZG9jLCBjaGFuZ2UpXSxcbiAgICAgICAgICAgICBnZW5lcmF0aW9uOiBoaXN0LmdlbmVyYXRpb259O1xuICAgICAgaGlzdC5kb25lLnB1c2goY3VyKTtcbiAgICAgIHdoaWxlIChoaXN0LmRvbmUubGVuZ3RoID4gaGlzdC51bmRvRGVwdGgpIHtcbiAgICAgICAgaGlzdC5kb25lLnNoaWZ0KCk7XG4gICAgICAgIGlmICghaGlzdC5kb25lWzBdLnJhbmdlcykgaGlzdC5kb25lLnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIGhpc3QuZG9uZS5wdXNoKHNlbEFmdGVyKTtcbiAgICBoaXN0LmdlbmVyYXRpb24gPSArK2hpc3QubWF4R2VuZXJhdGlvbjtcbiAgICBoaXN0Lmxhc3RNb2RUaW1lID0gaGlzdC5sYXN0U2VsVGltZSA9IHRpbWU7XG4gICAgaGlzdC5sYXN0T3AgPSBvcElkO1xuICAgIGhpc3QubGFzdE9yaWdpbiA9IGhpc3QubGFzdFNlbE9yaWdpbiA9IGNoYW5nZS5vcmlnaW47XG5cbiAgICBpZiAoIWxhc3QpIHNpZ25hbChkb2MsIFwiaGlzdG9yeUFkZGVkXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0aW9uRXZlbnRDYW5CZU1lcmdlZChkb2MsIG9yaWdpbiwgcHJldiwgc2VsKSB7XG4gICAgdmFyIGNoID0gb3JpZ2luLmNoYXJBdCgwKTtcbiAgICByZXR1cm4gY2ggPT0gXCIqXCIgfHxcbiAgICAgIGNoID09IFwiK1wiICYmXG4gICAgICBwcmV2LnJhbmdlcy5sZW5ndGggPT0gc2VsLnJhbmdlcy5sZW5ndGggJiZcbiAgICAgIHByZXYuc29tZXRoaW5nU2VsZWN0ZWQoKSA9PSBzZWwuc29tZXRoaW5nU2VsZWN0ZWQoKSAmJlxuICAgICAgbmV3IERhdGUgLSBkb2MuaGlzdG9yeS5sYXN0U2VsVGltZSA8PSAoZG9jLmNtID8gZG9jLmNtLm9wdGlvbnMuaGlzdG9yeUV2ZW50RGVsYXkgOiA1MDApO1xuICB9XG5cbiAgLy8gQ2FsbGVkIHdoZW5ldmVyIHRoZSBzZWxlY3Rpb24gY2hhbmdlcywgc2V0cyB0aGUgbmV3IHNlbGVjdGlvbiBhc1xuICAvLyB0aGUgcGVuZGluZyBzZWxlY3Rpb24gaW4gdGhlIGhpc3RvcnksIGFuZCBwdXNoZXMgdGhlIG9sZCBwZW5kaW5nXG4gIC8vIHNlbGVjdGlvbiBpbnRvIHRoZSAnZG9uZScgYXJyYXkgd2hlbiBpdCB3YXMgc2lnbmlmaWNhbnRseVxuICAvLyBkaWZmZXJlbnQgKGluIG51bWJlciBvZiBzZWxlY3RlZCByYW5nZXMsIGVtcHRpbmVzcywgb3IgdGltZSkuXG4gIGZ1bmN0aW9uIGFkZFNlbGVjdGlvblRvSGlzdG9yeShkb2MsIHNlbCwgb3BJZCwgb3B0aW9ucykge1xuICAgIHZhciBoaXN0ID0gZG9jLmhpc3RvcnksIG9yaWdpbiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5vcmlnaW47XG5cbiAgICAvLyBBIG5ldyBldmVudCBpcyBzdGFydGVkIHdoZW4gdGhlIHByZXZpb3VzIG9yaWdpbiBkb2VzIG5vdCBtYXRjaFxuICAgIC8vIHRoZSBjdXJyZW50LCBvciB0aGUgb3JpZ2lucyBkb24ndCBhbGxvdyBtYXRjaGluZy4gT3JpZ2luc1xuICAgIC8vIHN0YXJ0aW5nIHdpdGggKiBhcmUgYWx3YXlzIG1lcmdlZCwgdGhvc2Ugc3RhcnRpbmcgd2l0aCArIGFyZVxuICAgIC8vIG1lcmdlZCB3aGVuIHNpbWlsYXIgYW5kIGNsb3NlIHRvZ2V0aGVyIGluIHRpbWUuXG4gICAgaWYgKG9wSWQgPT0gaGlzdC5sYXN0T3AgfHxcbiAgICAgICAgKG9yaWdpbiAmJiBoaXN0Lmxhc3RTZWxPcmlnaW4gPT0gb3JpZ2luICYmXG4gICAgICAgICAoaGlzdC5sYXN0TW9kVGltZSA9PSBoaXN0Lmxhc3RTZWxUaW1lICYmIGhpc3QubGFzdE9yaWdpbiA9PSBvcmlnaW4gfHxcbiAgICAgICAgICBzZWxlY3Rpb25FdmVudENhbkJlTWVyZ2VkKGRvYywgb3JpZ2luLCBsc3QoaGlzdC5kb25lKSwgc2VsKSkpKVxuICAgICAgaGlzdC5kb25lW2hpc3QuZG9uZS5sZW5ndGggLSAxXSA9IHNlbDtcbiAgICBlbHNlXG4gICAgICBwdXNoU2VsZWN0aW9uVG9IaXN0b3J5KHNlbCwgaGlzdC5kb25lKTtcblxuICAgIGhpc3QubGFzdFNlbFRpbWUgPSArbmV3IERhdGU7XG4gICAgaGlzdC5sYXN0U2VsT3JpZ2luID0gb3JpZ2luO1xuICAgIGhpc3QubGFzdE9wID0gb3BJZDtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmNsZWFyUmVkbyAhPT0gZmFsc2UpXG4gICAgICBjbGVhclNlbGVjdGlvbkV2ZW50cyhoaXN0LnVuZG9uZSk7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoU2VsZWN0aW9uVG9IaXN0b3J5KHNlbCwgZGVzdCkge1xuICAgIHZhciB0b3AgPSBsc3QoZGVzdCk7XG4gICAgaWYgKCEodG9wICYmIHRvcC5yYW5nZXMgJiYgdG9wLmVxdWFscyhzZWwpKSlcbiAgICAgIGRlc3QucHVzaChzZWwpO1xuICB9XG5cbiAgLy8gVXNlZCB0byBzdG9yZSBtYXJrZWQgc3BhbiBpbmZvcm1hdGlvbiBpbiB0aGUgaGlzdG9yeS5cbiAgZnVuY3Rpb24gYXR0YWNoTG9jYWxTcGFucyhkb2MsIGNoYW5nZSwgZnJvbSwgdG8pIHtcbiAgICB2YXIgZXhpc3RpbmcgPSBjaGFuZ2VbXCJzcGFuc19cIiArIGRvYy5pZF0sIG4gPSAwO1xuICAgIGRvYy5pdGVyKE1hdGgubWF4KGRvYy5maXJzdCwgZnJvbSksIE1hdGgubWluKGRvYy5maXJzdCArIGRvYy5zaXplLCB0byksIGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIGlmIChsaW5lLm1hcmtlZFNwYW5zKVxuICAgICAgICAoZXhpc3RpbmcgfHwgKGV4aXN0aW5nID0gY2hhbmdlW1wic3BhbnNfXCIgKyBkb2MuaWRdID0ge30pKVtuXSA9IGxpbmUubWFya2VkU3BhbnM7XG4gICAgICArK247XG4gICAgfSk7XG4gIH1cblxuICAvLyBXaGVuIHVuL3JlLWRvaW5nIHJlc3RvcmVzIHRleHQgY29udGFpbmluZyBtYXJrZWQgc3BhbnMsIHRob3NlXG4gIC8vIHRoYXQgaGF2ZSBiZWVuIGV4cGxpY2l0bHkgY2xlYXJlZCBzaG91bGQgbm90IGJlIHJlc3RvcmVkLlxuICBmdW5jdGlvbiByZW1vdmVDbGVhcmVkU3BhbnMoc3BhbnMpIHtcbiAgICBpZiAoIXNwYW5zKSByZXR1cm4gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gMCwgb3V0OyBpIDwgc3BhbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChzcGFuc1tpXS5tYXJrZXIuZXhwbGljaXRseUNsZWFyZWQpIHsgaWYgKCFvdXQpIG91dCA9IHNwYW5zLnNsaWNlKDAsIGkpOyB9XG4gICAgICBlbHNlIGlmIChvdXQpIG91dC5wdXNoKHNwYW5zW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuICFvdXQgPyBzcGFucyA6IG91dC5sZW5ndGggPyBvdXQgOiBudWxsO1xuICB9XG5cbiAgLy8gUmV0cmlldmUgYW5kIGZpbHRlciB0aGUgb2xkIG1hcmtlZCBzcGFucyBzdG9yZWQgaW4gYSBjaGFuZ2UgZXZlbnQuXG4gIGZ1bmN0aW9uIGdldE9sZFNwYW5zKGRvYywgY2hhbmdlKSB7XG4gICAgdmFyIGZvdW5kID0gY2hhbmdlW1wic3BhbnNfXCIgKyBkb2MuaWRdO1xuICAgIGlmICghZm91bmQpIHJldHVybiBudWxsO1xuICAgIGZvciAodmFyIGkgPSAwLCBudyA9IFtdOyBpIDwgY2hhbmdlLnRleHQubGVuZ3RoOyArK2kpXG4gICAgICBudy5wdXNoKHJlbW92ZUNsZWFyZWRTcGFucyhmb3VuZFtpXSkpO1xuICAgIHJldHVybiBudztcbiAgfVxuXG4gIC8vIFVzZWQgYm90aCB0byBwcm92aWRlIGEgSlNPTi1zYWZlIG9iamVjdCBpbiAuZ2V0SGlzdG9yeSwgYW5kLCB3aGVuXG4gIC8vIGRldGFjaGluZyBhIGRvY3VtZW50LCB0byBzcGxpdCB0aGUgaGlzdG9yeSBpbiB0d29cbiAgZnVuY3Rpb24gY29weUhpc3RvcnlBcnJheShldmVudHMsIG5ld0dyb3VwLCBpbnN0YW50aWF0ZVNlbCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBjb3B5ID0gW107IGkgPCBldmVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBldmVudCA9IGV2ZW50c1tpXTtcbiAgICAgIGlmIChldmVudC5yYW5nZXMpIHtcbiAgICAgICAgY29weS5wdXNoKGluc3RhbnRpYXRlU2VsID8gU2VsZWN0aW9uLnByb3RvdHlwZS5kZWVwQ29weS5jYWxsKGV2ZW50KSA6IGV2ZW50KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgY2hhbmdlcyA9IGV2ZW50LmNoYW5nZXMsIG5ld0NoYW5nZXMgPSBbXTtcbiAgICAgIGNvcHkucHVzaCh7Y2hhbmdlczogbmV3Q2hhbmdlc30pO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjaGFuZ2VzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIHZhciBjaGFuZ2UgPSBjaGFuZ2VzW2pdLCBtO1xuICAgICAgICBuZXdDaGFuZ2VzLnB1c2goe2Zyb206IGNoYW5nZS5mcm9tLCB0bzogY2hhbmdlLnRvLCB0ZXh0OiBjaGFuZ2UudGV4dH0pO1xuICAgICAgICBpZiAobmV3R3JvdXApIGZvciAodmFyIHByb3AgaW4gY2hhbmdlKSBpZiAobSA9IHByb3AubWF0Y2goL15zcGFuc18oXFxkKykkLykpIHtcbiAgICAgICAgICBpZiAoaW5kZXhPZihuZXdHcm91cCwgTnVtYmVyKG1bMV0pKSA+IC0xKSB7XG4gICAgICAgICAgICBsc3QobmV3Q2hhbmdlcylbcHJvcF0gPSBjaGFuZ2VbcHJvcF07XG4gICAgICAgICAgICBkZWxldGUgY2hhbmdlW3Byb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29weTtcbiAgfVxuXG4gIC8vIFJlYmFzaW5nL3Jlc2V0dGluZyBoaXN0b3J5IHRvIGRlYWwgd2l0aCBleHRlcm5hbGx5LXNvdXJjZWQgY2hhbmdlc1xuXG4gIGZ1bmN0aW9uIHJlYmFzZUhpc3RTZWxTaW5nbGUocG9zLCBmcm9tLCB0bywgZGlmZikge1xuICAgIGlmICh0byA8IHBvcy5saW5lKSB7XG4gICAgICBwb3MubGluZSArPSBkaWZmO1xuICAgIH0gZWxzZSBpZiAoZnJvbSA8IHBvcy5saW5lKSB7XG4gICAgICBwb3MubGluZSA9IGZyb207XG4gICAgICBwb3MuY2ggPSAwO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRyaWVzIHRvIHJlYmFzZSBhbiBhcnJheSBvZiBoaXN0b3J5IGV2ZW50cyBnaXZlbiBhIGNoYW5nZSBpbiB0aGVcbiAgLy8gZG9jdW1lbnQuIElmIHRoZSBjaGFuZ2UgdG91Y2hlcyB0aGUgc2FtZSBsaW5lcyBhcyB0aGUgZXZlbnQsIHRoZVxuICAvLyBldmVudCwgYW5kIGV2ZXJ5dGhpbmcgJ2JlaGluZCcgaXQsIGlzIGRpc2NhcmRlZC4gSWYgdGhlIGNoYW5nZSBpc1xuICAvLyBiZWZvcmUgdGhlIGV2ZW50LCB0aGUgZXZlbnQncyBwb3NpdGlvbnMgYXJlIHVwZGF0ZWQuIFVzZXMgYVxuICAvLyBjb3B5LW9uLXdyaXRlIHNjaGVtZSBmb3IgdGhlIHBvc2l0aW9ucywgdG8gYXZvaWQgaGF2aW5nIHRvXG4gIC8vIHJlYWxsb2NhdGUgdGhlbSBhbGwgb24gZXZlcnkgcmViYXNlLCBidXQgYWxzbyBhdm9pZCBwcm9ibGVtcyB3aXRoXG4gIC8vIHNoYXJlZCBwb3NpdGlvbiBvYmplY3RzIGJlaW5nIHVuc2FmZWx5IHVwZGF0ZWQuXG4gIGZ1bmN0aW9uIHJlYmFzZUhpc3RBcnJheShhcnJheSwgZnJvbSwgdG8sIGRpZmYpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgc3ViID0gYXJyYXlbaV0sIG9rID0gdHJ1ZTtcbiAgICAgIGlmIChzdWIucmFuZ2VzKSB7XG4gICAgICAgIGlmICghc3ViLmNvcGllZCkgeyBzdWIgPSBhcnJheVtpXSA9IHN1Yi5kZWVwQ29weSgpOyBzdWIuY29waWVkID0gdHJ1ZTsgfVxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN1Yi5yYW5nZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICByZWJhc2VIaXN0U2VsU2luZ2xlKHN1Yi5yYW5nZXNbal0uYW5jaG9yLCBmcm9tLCB0bywgZGlmZik7XG4gICAgICAgICAgcmViYXNlSGlzdFNlbFNpbmdsZShzdWIucmFuZ2VzW2pdLmhlYWQsIGZyb20sIHRvLCBkaWZmKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3ViLmNoYW5nZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgdmFyIGN1ciA9IHN1Yi5jaGFuZ2VzW2pdO1xuICAgICAgICBpZiAodG8gPCBjdXIuZnJvbS5saW5lKSB7XG4gICAgICAgICAgY3VyLmZyb20gPSBQb3MoY3VyLmZyb20ubGluZSArIGRpZmYsIGN1ci5mcm9tLmNoKTtcbiAgICAgICAgICBjdXIudG8gPSBQb3MoY3VyLnRvLmxpbmUgKyBkaWZmLCBjdXIudG8uY2gpO1xuICAgICAgICB9IGVsc2UgaWYgKGZyb20gPD0gY3VyLnRvLmxpbmUpIHtcbiAgICAgICAgICBvayA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIW9rKSB7XG4gICAgICAgIGFycmF5LnNwbGljZSgwLCBpICsgMSk7XG4gICAgICAgIGkgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYmFzZUhpc3QoaGlzdCwgY2hhbmdlKSB7XG4gICAgdmFyIGZyb20gPSBjaGFuZ2UuZnJvbS5saW5lLCB0byA9IGNoYW5nZS50by5saW5lLCBkaWZmID0gY2hhbmdlLnRleHQubGVuZ3RoIC0gKHRvIC0gZnJvbSkgLSAxO1xuICAgIHJlYmFzZUhpc3RBcnJheShoaXN0LmRvbmUsIGZyb20sIHRvLCBkaWZmKTtcbiAgICByZWJhc2VIaXN0QXJyYXkoaGlzdC51bmRvbmUsIGZyb20sIHRvLCBkaWZmKTtcbiAgfVxuXG4gIC8vIEVWRU5UIFVUSUxJVElFU1xuXG4gIC8vIER1ZSB0byB0aGUgZmFjdCB0aGF0IHdlIHN0aWxsIHN1cHBvcnQganVyYXNzaWMgSUUgdmVyc2lvbnMsIHNvbWVcbiAgLy8gY29tcGF0aWJpbGl0eSB3cmFwcGVycyBhcmUgbmVlZGVkLlxuXG4gIHZhciBlX3ByZXZlbnREZWZhdWx0ID0gQ29kZU1pcnJvci5lX3ByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgZWxzZSBlLnJldHVyblZhbHVlID0gZmFsc2U7XG4gIH07XG4gIHZhciBlX3N0b3BQcm9wYWdhdGlvbiA9IENvZGVNaXJyb3IuZV9zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgaWYgKGUuc3RvcFByb3BhZ2F0aW9uKSBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGVsc2UgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICB9O1xuICBmdW5jdGlvbiBlX2RlZmF1bHRQcmV2ZW50ZWQoZSkge1xuICAgIHJldHVybiBlLmRlZmF1bHRQcmV2ZW50ZWQgIT0gbnVsbCA/IGUuZGVmYXVsdFByZXZlbnRlZCA6IGUucmV0dXJuVmFsdWUgPT0gZmFsc2U7XG4gIH1cbiAgdmFyIGVfc3RvcCA9IENvZGVNaXJyb3IuZV9zdG9wID0gZnVuY3Rpb24oZSkge2VfcHJldmVudERlZmF1bHQoZSk7IGVfc3RvcFByb3BhZ2F0aW9uKGUpO307XG5cbiAgZnVuY3Rpb24gZV90YXJnZXQoZSkge3JldHVybiBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7fVxuICBmdW5jdGlvbiBlX2J1dHRvbihlKSB7XG4gICAgdmFyIGIgPSBlLndoaWNoO1xuICAgIGlmIChiID09IG51bGwpIHtcbiAgICAgIGlmIChlLmJ1dHRvbiAmIDEpIGIgPSAxO1xuICAgICAgZWxzZSBpZiAoZS5idXR0b24gJiAyKSBiID0gMztcbiAgICAgIGVsc2UgaWYgKGUuYnV0dG9uICYgNCkgYiA9IDI7XG4gICAgfVxuICAgIGlmIChtYWMgJiYgZS5jdHJsS2V5ICYmIGIgPT0gMSkgYiA9IDM7XG4gICAgcmV0dXJuIGI7XG4gIH1cblxuICAvLyBFVkVOVCBIQU5ETElOR1xuXG4gIC8vIExpZ2h0d2VpZ2h0IGV2ZW50IGZyYW1ld29yay4gb24vb2ZmIGFsc28gd29yayBvbiBET00gbm9kZXMsXG4gIC8vIHJlZ2lzdGVyaW5nIG5hdGl2ZSBET00gaGFuZGxlcnMuXG5cbiAgdmFyIG9uID0gQ29kZU1pcnJvci5vbiA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUsIGYpIHtcbiAgICBpZiAoZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKVxuICAgICAgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGYsIGZhbHNlKTtcbiAgICBlbHNlIGlmIChlbWl0dGVyLmF0dGFjaEV2ZW50KVxuICAgICAgZW1pdHRlci5hdHRhY2hFdmVudChcIm9uXCIgKyB0eXBlLCBmKTtcbiAgICBlbHNlIHtcbiAgICAgIHZhciBtYXAgPSBlbWl0dGVyLl9oYW5kbGVycyB8fCAoZW1pdHRlci5faGFuZGxlcnMgPSB7fSk7XG4gICAgICB2YXIgYXJyID0gbWFwW3R5cGVdIHx8IChtYXBbdHlwZV0gPSBbXSk7XG4gICAgICBhcnIucHVzaChmKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIG9mZiA9IENvZGVNaXJyb3Iub2ZmID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSwgZikge1xuICAgIGlmIChlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIpXG4gICAgICBlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZiwgZmFsc2UpO1xuICAgIGVsc2UgaWYgKGVtaXR0ZXIuZGV0YWNoRXZlbnQpXG4gICAgICBlbWl0dGVyLmRldGFjaEV2ZW50KFwib25cIiArIHR5cGUsIGYpO1xuICAgIGVsc2Uge1xuICAgICAgdmFyIGFyciA9IGVtaXR0ZXIuX2hhbmRsZXJzICYmIGVtaXR0ZXIuX2hhbmRsZXJzW3R5cGVdO1xuICAgICAgaWYgKCFhcnIpIHJldHVybjtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKVxuICAgICAgICBpZiAoYXJyW2ldID09IGYpIHsgYXJyLnNwbGljZShpLCAxKTsgYnJlYWs7IH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIHNpZ25hbCA9IENvZGVNaXJyb3Iuc2lnbmFsID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSAvKiwgdmFsdWVzLi4uKi8pIHtcbiAgICB2YXIgYXJyID0gZW1pdHRlci5faGFuZGxlcnMgJiYgZW1pdHRlci5faGFuZGxlcnNbdHlwZV07XG4gICAgaWYgKCFhcnIpIHJldHVybjtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIGFycltpXS5hcHBseShudWxsLCBhcmdzKTtcbiAgfTtcblxuICAvLyBPZnRlbiwgd2Ugd2FudCB0byBzaWduYWwgZXZlbnRzIGF0IGEgcG9pbnQgd2hlcmUgd2UgYXJlIGluIHRoZVxuICAvLyBtaWRkbGUgb2Ygc29tZSB3b3JrLCBidXQgZG9uJ3Qgd2FudCB0aGUgaGFuZGxlciB0byBzdGFydCBjYWxsaW5nXG4gIC8vIG90aGVyIG1ldGhvZHMgb24gdGhlIGVkaXRvciwgd2hpY2ggbWlnaHQgYmUgaW4gYW4gaW5jb25zaXN0ZW50XG4gIC8vIHN0YXRlIG9yIHNpbXBseSBub3QgZXhwZWN0IGFueSBvdGhlciBldmVudHMgdG8gaGFwcGVuLlxuICAvLyBzaWduYWxMYXRlciBsb29rcyB3aGV0aGVyIHRoZXJlIGFyZSBhbnkgaGFuZGxlcnMsIGFuZCBzY2hlZHVsZXNcbiAgLy8gdGhlbSB0byBiZSBleGVjdXRlZCB3aGVuIHRoZSBsYXN0IG9wZXJhdGlvbiBlbmRzLCBvciwgaWYgbm9cbiAgLy8gb3BlcmF0aW9uIGlzIGFjdGl2ZSwgd2hlbiBhIHRpbWVvdXQgZmlyZXMuXG4gIHZhciBkZWxheWVkQ2FsbGJhY2tzLCBkZWxheWVkQ2FsbGJhY2tEZXB0aCA9IDA7XG4gIGZ1bmN0aW9uIHNpZ25hbExhdGVyKGVtaXR0ZXIsIHR5cGUgLyosIHZhbHVlcy4uLiovKSB7XG4gICAgdmFyIGFyciA9IGVtaXR0ZXIuX2hhbmRsZXJzICYmIGVtaXR0ZXIuX2hhbmRsZXJzW3R5cGVdO1xuICAgIGlmICghYXJyKSByZXR1cm47XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIGlmICghZGVsYXllZENhbGxiYWNrcykge1xuICAgICAgKytkZWxheWVkQ2FsbGJhY2tEZXB0aDtcbiAgICAgIGRlbGF5ZWRDYWxsYmFja3MgPSBbXTtcbiAgICAgIHNldFRpbWVvdXQoZmlyZURlbGF5ZWQsIDApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBibmQoZikge3JldHVybiBmdW5jdGlvbigpe2YuYXBwbHkobnVsbCwgYXJncyk7fTt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKVxuICAgICAgZGVsYXllZENhbGxiYWNrcy5wdXNoKGJuZChhcnJbaV0pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpcmVEZWxheWVkKCkge1xuICAgIC0tZGVsYXllZENhbGxiYWNrRGVwdGg7XG4gICAgdmFyIGRlbGF5ZWQgPSBkZWxheWVkQ2FsbGJhY2tzO1xuICAgIGRlbGF5ZWRDYWxsYmFja3MgPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsYXllZC5sZW5ndGg7ICsraSkgZGVsYXllZFtpXSgpO1xuICB9XG5cbiAgLy8gVGhlIERPTSBldmVudHMgdGhhdCBDb2RlTWlycm9yIGhhbmRsZXMgY2FuIGJlIG92ZXJyaWRkZW4gYnlcbiAgLy8gcmVnaXN0ZXJpbmcgYSAobm9uLURPTSkgaGFuZGxlciBvbiB0aGUgZWRpdG9yIGZvciB0aGUgZXZlbnQgbmFtZSxcbiAgLy8gYW5kIHByZXZlbnREZWZhdWx0LWluZyB0aGUgZXZlbnQgaW4gdGhhdCBoYW5kbGVyLlxuICBmdW5jdGlvbiBzaWduYWxET01FdmVudChjbSwgZSwgb3ZlcnJpZGUpIHtcbiAgICBzaWduYWwoY20sIG92ZXJyaWRlIHx8IGUudHlwZSwgY20sIGUpO1xuICAgIHJldHVybiBlX2RlZmF1bHRQcmV2ZW50ZWQoZSkgfHwgZS5jb2RlbWlycm9ySWdub3JlO1xuICB9XG5cbiAgZnVuY3Rpb24gc2lnbmFsQ3Vyc29yQWN0aXZpdHkoY20pIHtcbiAgICB2YXIgYXJyID0gY20uX2hhbmRsZXJzICYmIGNtLl9oYW5kbGVycy5jdXJzb3JBY3Rpdml0eTtcbiAgICBpZiAoIWFycikgcmV0dXJuO1xuICAgIHZhciBzZXQgPSBjbS5jdXJPcC5jdXJzb3JBY3Rpdml0eUhhbmRsZXJzIHx8IChjbS5jdXJPcC5jdXJzb3JBY3Rpdml0eUhhbmRsZXJzID0gW10pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSBpZiAoaW5kZXhPZihzZXQsIGFycltpXSkgPT0gLTEpXG4gICAgICBzZXQucHVzaChhcnJbaV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzSGFuZGxlcihlbWl0dGVyLCB0eXBlKSB7XG4gICAgdmFyIGFyciA9IGVtaXR0ZXIuX2hhbmRsZXJzICYmIGVtaXR0ZXIuX2hhbmRsZXJzW3R5cGVdO1xuICAgIHJldHVybiBhcnIgJiYgYXJyLmxlbmd0aCA+IDA7XG4gIH1cblxuICAvLyBBZGQgb24gYW5kIG9mZiBtZXRob2RzIHRvIGEgY29uc3RydWN0b3IncyBwcm90b3R5cGUsIHRvIG1ha2VcbiAgLy8gcmVnaXN0ZXJpbmcgZXZlbnRzIG9uIHN1Y2ggb2JqZWN0cyBtb3JlIGNvbnZlbmllbnQuXG4gIGZ1bmN0aW9uIGV2ZW50TWl4aW4oY3Rvcikge1xuICAgIGN0b3IucHJvdG90eXBlLm9uID0gZnVuY3Rpb24odHlwZSwgZikge29uKHRoaXMsIHR5cGUsIGYpO307XG4gICAgY3Rvci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24odHlwZSwgZikge29mZih0aGlzLCB0eXBlLCBmKTt9O1xuICB9XG5cbiAgLy8gTUlTQyBVVElMSVRJRVNcblxuICAvLyBOdW1iZXIgb2YgcGl4ZWxzIGFkZGVkIHRvIHNjcm9sbGVyIGFuZCBzaXplciB0byBoaWRlIHNjcm9sbGJhclxuICB2YXIgc2Nyb2xsZXJDdXRPZmYgPSAzMDtcblxuICAvLyBSZXR1cm5lZCBvciB0aHJvd24gYnkgdmFyaW91cyBwcm90b2NvbHMgdG8gc2lnbmFsICdJJ20gbm90XG4gIC8vIGhhbmRsaW5nIHRoaXMnLlxuICB2YXIgUGFzcyA9IENvZGVNaXJyb3IuUGFzcyA9IHt0b1N0cmluZzogZnVuY3Rpb24oKXtyZXR1cm4gXCJDb2RlTWlycm9yLlBhc3NcIjt9fTtcblxuICAvLyBSZXVzZWQgb3B0aW9uIG9iamVjdHMgZm9yIHNldFNlbGVjdGlvbiAmIGZyaWVuZHNcbiAgdmFyIHNlbF9kb250U2Nyb2xsID0ge3Njcm9sbDogZmFsc2V9LCBzZWxfbW91c2UgPSB7b3JpZ2luOiBcIiptb3VzZVwifSwgc2VsX21vdmUgPSB7b3JpZ2luOiBcIittb3ZlXCJ9O1xuXG4gIGZ1bmN0aW9uIERlbGF5ZWQoKSB7dGhpcy5pZCA9IG51bGw7fVxuICBEZWxheWVkLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihtcywgZikge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmlkKTtcbiAgICB0aGlzLmlkID0gc2V0VGltZW91dChmLCBtcyk7XG4gIH07XG5cbiAgLy8gQ291bnRzIHRoZSBjb2x1bW4gb2Zmc2V0IGluIGEgc3RyaW5nLCB0YWtpbmcgdGFicyBpbnRvIGFjY291bnQuXG4gIC8vIFVzZWQgbW9zdGx5IHRvIGZpbmQgaW5kZW50YXRpb24uXG4gIHZhciBjb3VudENvbHVtbiA9IENvZGVNaXJyb3IuY291bnRDb2x1bW4gPSBmdW5jdGlvbihzdHJpbmcsIGVuZCwgdGFiU2l6ZSwgc3RhcnRJbmRleCwgc3RhcnRWYWx1ZSkge1xuICAgIGlmIChlbmQgPT0gbnVsbCkge1xuICAgICAgZW5kID0gc3RyaW5nLnNlYXJjaCgvW15cXHNcXHUwMGEwXS8pO1xuICAgICAgaWYgKGVuZCA9PSAtMSkgZW5kID0gc3RyaW5nLmxlbmd0aDtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXggfHwgMCwgbiA9IHN0YXJ0VmFsdWUgfHwgMDs7KSB7XG4gICAgICB2YXIgbmV4dFRhYiA9IHN0cmluZy5pbmRleE9mKFwiXFx0XCIsIGkpO1xuICAgICAgaWYgKG5leHRUYWIgPCAwIHx8IG5leHRUYWIgPj0gZW5kKVxuICAgICAgICByZXR1cm4gbiArIChlbmQgLSBpKTtcbiAgICAgIG4gKz0gbmV4dFRhYiAtIGk7XG4gICAgICBuICs9IHRhYlNpemUgLSAobiAlIHRhYlNpemUpO1xuICAgICAgaSA9IG5leHRUYWIgKyAxO1xuICAgIH1cbiAgfTtcblxuICAvLyBUaGUgaW52ZXJzZSBvZiBjb3VudENvbHVtbiAtLSBmaW5kIHRoZSBvZmZzZXQgdGhhdCBjb3JyZXNwb25kcyB0b1xuICAvLyBhIHBhcnRpY3VsYXIgY29sdW1uLlxuICBmdW5jdGlvbiBmaW5kQ29sdW1uKHN0cmluZywgZ29hbCwgdGFiU2l6ZSkge1xuICAgIGZvciAodmFyIHBvcyA9IDAsIGNvbCA9IDA7Oykge1xuICAgICAgdmFyIG5leHRUYWIgPSBzdHJpbmcuaW5kZXhPZihcIlxcdFwiLCBwb3MpO1xuICAgICAgaWYgKG5leHRUYWIgPT0gLTEpIG5leHRUYWIgPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgdmFyIHNraXBwZWQgPSBuZXh0VGFiIC0gcG9zO1xuICAgICAgaWYgKG5leHRUYWIgPT0gc3RyaW5nLmxlbmd0aCB8fCBjb2wgKyBza2lwcGVkID49IGdvYWwpXG4gICAgICAgIHJldHVybiBwb3MgKyBNYXRoLm1pbihza2lwcGVkLCBnb2FsIC0gY29sKTtcbiAgICAgIGNvbCArPSBuZXh0VGFiIC0gcG9zO1xuICAgICAgY29sICs9IHRhYlNpemUgLSAoY29sICUgdGFiU2l6ZSk7XG4gICAgICBwb3MgPSBuZXh0VGFiICsgMTtcbiAgICAgIGlmIChjb2wgPj0gZ29hbCkgcmV0dXJuIHBvcztcbiAgICB9XG4gIH1cblxuICB2YXIgc3BhY2VTdHJzID0gW1wiXCJdO1xuICBmdW5jdGlvbiBzcGFjZVN0cihuKSB7XG4gICAgd2hpbGUgKHNwYWNlU3Rycy5sZW5ndGggPD0gbilcbiAgICAgIHNwYWNlU3Rycy5wdXNoKGxzdChzcGFjZVN0cnMpICsgXCIgXCIpO1xuICAgIHJldHVybiBzcGFjZVN0cnNbbl07XG4gIH1cblxuICBmdW5jdGlvbiBsc3QoYXJyKSB7IHJldHVybiBhcnJbYXJyLmxlbmd0aC0xXTsgfVxuXG4gIHZhciBzZWxlY3RJbnB1dCA9IGZ1bmN0aW9uKG5vZGUpIHsgbm9kZS5zZWxlY3QoKTsgfTtcbiAgaWYgKGlvcykgLy8gTW9iaWxlIFNhZmFyaSBhcHBhcmVudGx5IGhhcyBhIGJ1ZyB3aGVyZSBzZWxlY3QoKSBpcyBicm9rZW4uXG4gICAgc2VsZWN0SW5wdXQgPSBmdW5jdGlvbihub2RlKSB7IG5vZGUuc2VsZWN0aW9uU3RhcnQgPSAwOyBub2RlLnNlbGVjdGlvbkVuZCA9IG5vZGUudmFsdWUubGVuZ3RoOyB9O1xuICBlbHNlIGlmIChpZSkgLy8gU3VwcHJlc3MgbXlzdGVyaW91cyBJRTEwIGVycm9yc1xuICAgIHNlbGVjdElucHV0ID0gZnVuY3Rpb24obm9kZSkgeyB0cnkgeyBub2RlLnNlbGVjdCgpOyB9IGNhdGNoKF9lKSB7fSB9O1xuXG4gIGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIGVsdCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpXG4gICAgICBpZiAoYXJyYXlbaV0gPT0gZWx0KSByZXR1cm4gaTtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKFtdLmluZGV4T2YpIGluZGV4T2YgPSBmdW5jdGlvbihhcnJheSwgZWx0KSB7IHJldHVybiBhcnJheS5pbmRleE9mKGVsdCk7IH07XG4gIGZ1bmN0aW9uIG1hcChhcnJheSwgZikge1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSBvdXRbaV0gPSBmKGFycmF5W2ldLCBpKTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIGlmIChbXS5tYXApIG1hcCA9IGZ1bmN0aW9uKGFycmF5LCBmKSB7IHJldHVybiBhcnJheS5tYXAoZik7IH07XG5cbiAgZnVuY3Rpb24gY3JlYXRlT2JqKGJhc2UsIHByb3BzKSB7XG4gICAgdmFyIGluc3Q7XG4gICAgaWYgKE9iamVjdC5jcmVhdGUpIHtcbiAgICAgIGluc3QgPSBPYmplY3QuY3JlYXRlKGJhc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY3RvciA9IGZ1bmN0aW9uKCkge307XG4gICAgICBjdG9yLnByb3RvdHlwZSA9IGJhc2U7XG4gICAgICBpbnN0ID0gbmV3IGN0b3IoKTtcbiAgICB9XG4gICAgaWYgKHByb3BzKSBjb3B5T2JqKHByb3BzLCBpbnN0KTtcbiAgICByZXR1cm4gaW5zdDtcbiAgfTtcblxuICBmdW5jdGlvbiBjb3B5T2JqKG9iaiwgdGFyZ2V0LCBvdmVyd3JpdGUpIHtcbiAgICBpZiAoIXRhcmdldCkgdGFyZ2V0ID0ge307XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvYmopXG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApICYmIChvdmVyd3JpdGUgIT09IGZhbHNlIHx8ICF0YXJnZXQuaGFzT3duUHJvcGVydHkocHJvcCkpKVxuICAgICAgICB0YXJnZXRbcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJpbmQoZikge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gZi5hcHBseShudWxsLCBhcmdzKTt9O1xuICB9XG5cbiAgdmFyIG5vbkFTQ0lJU2luZ2xlQ2FzZVdvcmRDaGFyID0gL1tcXHUwMGRmXFx1MzA0MC1cXHUzMDlmXFx1MzBhMC1cXHUzMGZmXFx1MzQwMC1cXHU0ZGI1XFx1NGUwMC1cXHU5ZmNjXFx1YWMwMC1cXHVkN2FmXS87XG4gIHZhciBpc1dvcmRDaGFyID0gQ29kZU1pcnJvci5pc1dvcmRDaGFyID0gZnVuY3Rpb24oY2gpIHtcbiAgICByZXR1cm4gL1xcdy8udGVzdChjaCkgfHwgY2ggPiBcIlxceDgwXCIgJiZcbiAgICAgIChjaC50b1VwcGVyQ2FzZSgpICE9IGNoLnRvTG93ZXJDYXNlKCkgfHwgbm9uQVNDSUlTaW5nbGVDYXNlV29yZENoYXIudGVzdChjaCkpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XG4gICAgZm9yICh2YXIgbiBpbiBvYmopIGlmIChvYmouaGFzT3duUHJvcGVydHkobikgJiYgb2JqW25dKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBFeHRlbmRpbmcgdW5pY29kZSBjaGFyYWN0ZXJzLiBBIHNlcmllcyBvZiBhIG5vbi1leHRlbmRpbmcgY2hhciArXG4gIC8vIGFueSBudW1iZXIgb2YgZXh0ZW5kaW5nIGNoYXJzIGlzIHRyZWF0ZWQgYXMgYSBzaW5nbGUgdW5pdCBhcyBmYXJcbiAgLy8gYXMgZWRpdGluZyBhbmQgbWVhc3VyaW5nIGlzIGNvbmNlcm5lZC4gVGhpcyBpcyBub3QgZnVsbHkgY29ycmVjdCxcbiAgLy8gc2luY2Ugc29tZSBzY3JpcHRzL2ZvbnRzL2Jyb3dzZXJzIGFsc28gdHJlYXQgb3RoZXIgY29uZmlndXJhdGlvbnNcbiAgLy8gb2YgY29kZSBwb2ludHMgYXMgYSBncm91cC5cbiAgdmFyIGV4dGVuZGluZ0NoYXJzID0gL1tcXHUwMzAwLVxcdTAzNmZcXHUwNDgzLVxcdTA0ODlcXHUwNTkxLVxcdTA1YmRcXHUwNWJmXFx1MDVjMVxcdTA1YzJcXHUwNWM0XFx1MDVjNVxcdTA1YzdcXHUwNjEwLVxcdTA2MWFcXHUwNjRiLVxcdTA2NWVcXHUwNjcwXFx1MDZkNi1cXHUwNmRjXFx1MDZkZS1cXHUwNmU0XFx1MDZlN1xcdTA2ZThcXHUwNmVhLVxcdTA2ZWRcXHUwNzExXFx1MDczMC1cXHUwNzRhXFx1MDdhNi1cXHUwN2IwXFx1MDdlYi1cXHUwN2YzXFx1MDgxNi1cXHUwODE5XFx1MDgxYi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJkXFx1MDkwMC1cXHUwOTAyXFx1MDkzY1xcdTA5NDEtXFx1MDk0OFxcdTA5NGRcXHUwOTUxLVxcdTA5NTVcXHUwOTYyXFx1MDk2M1xcdTA5ODFcXHUwOWJjXFx1MDliZVxcdTA5YzEtXFx1MDljNFxcdTA5Y2RcXHUwOWQ3XFx1MDllMlxcdTA5ZTNcXHUwYTAxXFx1MGEwMlxcdTBhM2NcXHUwYTQxXFx1MGE0MlxcdTBhNDdcXHUwYTQ4XFx1MGE0Yi1cXHUwYTRkXFx1MGE1MVxcdTBhNzBcXHUwYTcxXFx1MGE3NVxcdTBhODFcXHUwYTgyXFx1MGFiY1xcdTBhYzEtXFx1MGFjNVxcdTBhYzdcXHUwYWM4XFx1MGFjZFxcdTBhZTJcXHUwYWUzXFx1MGIwMVxcdTBiM2NcXHUwYjNlXFx1MGIzZlxcdTBiNDEtXFx1MGI0NFxcdTBiNGRcXHUwYjU2XFx1MGI1N1xcdTBiNjJcXHUwYjYzXFx1MGI4MlxcdTBiYmVcXHUwYmMwXFx1MGJjZFxcdTBiZDdcXHUwYzNlLVxcdTBjNDBcXHUwYzQ2LVxcdTBjNDhcXHUwYzRhLVxcdTBjNGRcXHUwYzU1XFx1MGM1NlxcdTBjNjJcXHUwYzYzXFx1MGNiY1xcdTBjYmZcXHUwY2MyXFx1MGNjNlxcdTBjY2NcXHUwY2NkXFx1MGNkNVxcdTBjZDZcXHUwY2UyXFx1MGNlM1xcdTBkM2VcXHUwZDQxLVxcdTBkNDRcXHUwZDRkXFx1MGQ1N1xcdTBkNjJcXHUwZDYzXFx1MGRjYVxcdTBkY2ZcXHUwZGQyLVxcdTBkZDRcXHUwZGQ2XFx1MGRkZlxcdTBlMzFcXHUwZTM0LVxcdTBlM2FcXHUwZTQ3LVxcdTBlNGVcXHUwZWIxXFx1MGViNC1cXHUwZWI5XFx1MGViYlxcdTBlYmNcXHUwZWM4LVxcdTBlY2RcXHUwZjE4XFx1MGYxOVxcdTBmMzVcXHUwZjM3XFx1MGYzOVxcdTBmNzEtXFx1MGY3ZVxcdTBmODAtXFx1MGY4NFxcdTBmODZcXHUwZjg3XFx1MGY5MC1cXHUwZjk3XFx1MGY5OS1cXHUwZmJjXFx1MGZjNlxcdTEwMmQtXFx1MTAzMFxcdTEwMzItXFx1MTAzN1xcdTEwMzlcXHUxMDNhXFx1MTAzZFxcdTEwM2VcXHUxMDU4XFx1MTA1OVxcdTEwNWUtXFx1MTA2MFxcdTEwNzEtXFx1MTA3NFxcdTEwODJcXHUxMDg1XFx1MTA4NlxcdTEwOGRcXHUxMDlkXFx1MTM1ZlxcdTE3MTItXFx1MTcxNFxcdTE3MzItXFx1MTczNFxcdTE3NTJcXHUxNzUzXFx1MTc3MlxcdTE3NzNcXHUxN2I3LVxcdTE3YmRcXHUxN2M2XFx1MTdjOS1cXHUxN2QzXFx1MTdkZFxcdTE4MGItXFx1MTgwZFxcdTE4YTlcXHUxOTIwLVxcdTE5MjJcXHUxOTI3XFx1MTkyOFxcdTE5MzJcXHUxOTM5LVxcdTE5M2JcXHUxYTE3XFx1MWExOFxcdTFhNTZcXHUxYTU4LVxcdTFhNWVcXHUxYTYwXFx1MWE2MlxcdTFhNjUtXFx1MWE2Y1xcdTFhNzMtXFx1MWE3Y1xcdTFhN2ZcXHUxYjAwLVxcdTFiMDNcXHUxYjM0XFx1MWIzNi1cXHUxYjNhXFx1MWIzY1xcdTFiNDJcXHUxYjZiLVxcdTFiNzNcXHUxYjgwXFx1MWI4MVxcdTFiYTItXFx1MWJhNVxcdTFiYThcXHUxYmE5XFx1MWMyYy1cXHUxYzMzXFx1MWMzNlxcdTFjMzdcXHUxY2QwLVxcdTFjZDJcXHUxY2Q0LVxcdTFjZTBcXHUxY2UyLVxcdTFjZThcXHUxY2VkXFx1MWRjMC1cXHUxZGU2XFx1MWRmZC1cXHUxZGZmXFx1MjAwY1xcdTIwMGRcXHUyMGQwLVxcdTIwZjBcXHUyY2VmLVxcdTJjZjFcXHUyZGUwLVxcdTJkZmZcXHUzMDJhLVxcdTMwMmZcXHUzMDk5XFx1MzA5YVxcdWE2NmYtXFx1YTY3MlxcdWE2N2NcXHVhNjdkXFx1YTZmMFxcdWE2ZjFcXHVhODAyXFx1YTgwNlxcdWE4MGJcXHVhODI1XFx1YTgyNlxcdWE4YzRcXHVhOGUwLVxcdWE4ZjFcXHVhOTI2LVxcdWE5MmRcXHVhOTQ3LVxcdWE5NTFcXHVhOTgwLVxcdWE5ODJcXHVhOWIzXFx1YTliNi1cXHVhOWI5XFx1YTliY1xcdWFhMjktXFx1YWEyZVxcdWFhMzFcXHVhYTMyXFx1YWEzNVxcdWFhMzZcXHVhYTQzXFx1YWE0Y1xcdWFhYjBcXHVhYWIyLVxcdWFhYjRcXHVhYWI3XFx1YWFiOFxcdWFhYmVcXHVhYWJmXFx1YWFjMVxcdWFiZTVcXHVhYmU4XFx1YWJlZFxcdWRjMDAtXFx1ZGZmZlxcdWZiMWVcXHVmZTAwLVxcdWZlMGZcXHVmZTIwLVxcdWZlMjZcXHVmZjllXFx1ZmY5Zl0vO1xuICBmdW5jdGlvbiBpc0V4dGVuZGluZ0NoYXIoY2gpIHsgcmV0dXJuIGNoLmNoYXJDb2RlQXQoMCkgPj0gNzY4ICYmIGV4dGVuZGluZ0NoYXJzLnRlc3QoY2gpOyB9XG5cbiAgLy8gRE9NIFVUSUxJVElFU1xuXG4gIGZ1bmN0aW9uIGVsdCh0YWcsIGNvbnRlbnQsIGNsYXNzTmFtZSwgc3R5bGUpIHtcbiAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICBpZiAoY2xhc3NOYW1lKSBlLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICBpZiAoc3R5bGUpIGUuc3R5bGUuY3NzVGV4dCA9IHN0eWxlO1xuICAgIGlmICh0eXBlb2YgY29udGVudCA9PSBcInN0cmluZ1wiKSBlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNvbnRlbnQpKTtcbiAgICBlbHNlIGlmIChjb250ZW50KSBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRlbnQubGVuZ3RoOyArK2kpIGUuYXBwZW5kQ2hpbGQoY29udGVudFtpXSk7XG4gICAgcmV0dXJuIGU7XG4gIH1cblxuICB2YXIgcmFuZ2U7XG4gIGlmIChkb2N1bWVudC5jcmVhdGVSYW5nZSkgcmFuZ2UgPSBmdW5jdGlvbihub2RlLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHIgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIHIuc2V0RW5kKG5vZGUsIGVuZCk7XG4gICAgci5zZXRTdGFydChub2RlLCBzdGFydCk7XG4gICAgcmV0dXJuIHI7XG4gIH07XG4gIGVsc2UgcmFuZ2UgPSBmdW5jdGlvbihub2RlLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHIgPSBkb2N1bWVudC5ib2R5LmNyZWF0ZVRleHRSYW5nZSgpO1xuICAgIHIubW92ZVRvRWxlbWVudFRleHQobm9kZS5wYXJlbnROb2RlKTtcbiAgICByLmNvbGxhcHNlKHRydWUpO1xuICAgIHIubW92ZUVuZChcImNoYXJhY3RlclwiLCBlbmQpO1xuICAgIHIubW92ZVN0YXJ0KFwiY2hhcmFjdGVyXCIsIHN0YXJ0KTtcbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBmdW5jdGlvbiByZW1vdmVDaGlsZHJlbihlKSB7XG4gICAgZm9yICh2YXIgY291bnQgPSBlLmNoaWxkTm9kZXMubGVuZ3RoOyBjb3VudCA+IDA7IC0tY291bnQpXG4gICAgICBlLnJlbW92ZUNoaWxkKGUuZmlyc3RDaGlsZCk7XG4gICAgcmV0dXJuIGU7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVDaGlsZHJlbkFuZEFkZChwYXJlbnQsIGUpIHtcbiAgICByZXR1cm4gcmVtb3ZlQ2hpbGRyZW4ocGFyZW50KS5hcHBlbmRDaGlsZChlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnRhaW5zKHBhcmVudCwgY2hpbGQpIHtcbiAgICBpZiAocGFyZW50LmNvbnRhaW5zKVxuICAgICAgcmV0dXJuIHBhcmVudC5jb250YWlucyhjaGlsZCk7XG4gICAgd2hpbGUgKGNoaWxkID0gY2hpbGQucGFyZW50Tm9kZSlcbiAgICAgIGlmIChjaGlsZCA9PSBwYXJlbnQpIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gYWN0aXZlRWx0KCkgeyByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDsgfVxuICAvLyBPbGRlciB2ZXJzaW9ucyBvZiBJRSB0aHJvd3MgdW5zcGVjaWZpZWQgZXJyb3Igd2hlbiB0b3VjaGluZ1xuICAvLyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGluIHNvbWUgY2FzZXMgKGR1cmluZyBsb2FkaW5nLCBpbiBpZnJhbWUpXG4gIGlmIChpZV91cHRvMTApIGFjdGl2ZUVsdCA9IGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7IHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50OyB9XG4gICAgY2F0Y2goZSkgeyByZXR1cm4gZG9jdW1lbnQuYm9keTsgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGNsYXNzVGVzdChjbHMpIHsgcmV0dXJuIG5ldyBSZWdFeHAoXCJcXFxcYlwiICsgY2xzICsgXCJcXFxcYlxcXFxzKlwiKTsgfVxuICBmdW5jdGlvbiBybUNsYXNzKG5vZGUsIGNscykge1xuICAgIHZhciB0ZXN0ID0gY2xhc3NUZXN0KGNscyk7XG4gICAgaWYgKHRlc3QudGVzdChub2RlLmNsYXNzTmFtZSkpIG5vZGUuY2xhc3NOYW1lID0gbm9kZS5jbGFzc05hbWUucmVwbGFjZSh0ZXN0LCBcIlwiKTtcbiAgfVxuICBmdW5jdGlvbiBhZGRDbGFzcyhub2RlLCBjbHMpIHtcbiAgICBpZiAoIWNsYXNzVGVzdChjbHMpLnRlc3Qobm9kZS5jbGFzc05hbWUpKSBub2RlLmNsYXNzTmFtZSArPSBcIiBcIiArIGNscztcbiAgfVxuICBmdW5jdGlvbiBqb2luQ2xhc3NlcyhhLCBiKSB7XG4gICAgdmFyIGFzID0gYS5zcGxpdChcIiBcIik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcy5sZW5ndGg7IGkrKylcbiAgICAgIGlmIChhc1tpXSAmJiAhY2xhc3NUZXN0KGFzW2ldKS50ZXN0KGIpKSBiICs9IFwiIFwiICsgYXNbaV07XG4gICAgcmV0dXJuIGI7XG4gIH1cblxuICAvLyBGRUFUVVJFIERFVEVDVElPTlxuXG4gIC8vIERldGVjdCBkcmFnLWFuZC1kcm9wXG4gIHZhciBkcmFnQW5kRHJvcCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIFRoZXJlIGlzICpzb21lKiBraW5kIG9mIGRyYWctYW5kLWRyb3Agc3VwcG9ydCBpbiBJRTYtOCwgYnV0IElcbiAgICAvLyBjb3VsZG4ndCBnZXQgaXQgdG8gd29yayB5ZXQuXG4gICAgaWYgKGllX3VwdG84KSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIGRpdiA9IGVsdCgnZGl2Jyk7XG4gICAgcmV0dXJuIFwiZHJhZ2dhYmxlXCIgaW4gZGl2IHx8IFwiZHJhZ0Ryb3BcIiBpbiBkaXY7XG4gIH0oKTtcblxuICB2YXIga25vd25TY3JvbGxiYXJXaWR0aDtcbiAgZnVuY3Rpb24gc2Nyb2xsYmFyV2lkdGgobWVhc3VyZSkge1xuICAgIGlmIChrbm93blNjcm9sbGJhcldpZHRoICE9IG51bGwpIHJldHVybiBrbm93blNjcm9sbGJhcldpZHRoO1xuICAgIHZhciB0ZXN0ID0gZWx0KFwiZGl2XCIsIG51bGwsIG51bGwsIFwid2lkdGg6IDUwcHg7IGhlaWdodDogNTBweDsgb3ZlcmZsb3cteDogc2Nyb2xsXCIpO1xuICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKG1lYXN1cmUsIHRlc3QpO1xuICAgIGlmICh0ZXN0Lm9mZnNldFdpZHRoKVxuICAgICAga25vd25TY3JvbGxiYXJXaWR0aCA9IHRlc3Qub2Zmc2V0SGVpZ2h0IC0gdGVzdC5jbGllbnRIZWlnaHQ7XG4gICAgcmV0dXJuIGtub3duU2Nyb2xsYmFyV2lkdGggfHwgMDtcbiAgfVxuXG4gIHZhciB6d3NwU3VwcG9ydGVkO1xuICBmdW5jdGlvbiB6ZXJvV2lkdGhFbGVtZW50KG1lYXN1cmUpIHtcbiAgICBpZiAoendzcFN1cHBvcnRlZCA9PSBudWxsKSB7XG4gICAgICB2YXIgdGVzdCA9IGVsdChcInNwYW5cIiwgXCJcXHUyMDBiXCIpO1xuICAgICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQobWVhc3VyZSwgZWx0KFwic3BhblwiLCBbdGVzdCwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJ4XCIpXSkpO1xuICAgICAgaWYgKG1lYXN1cmUuZmlyc3RDaGlsZC5vZmZzZXRIZWlnaHQgIT0gMClcbiAgICAgICAgendzcFN1cHBvcnRlZCA9IHRlc3Qub2Zmc2V0V2lkdGggPD0gMSAmJiB0ZXN0Lm9mZnNldEhlaWdodCA+IDIgJiYgIWllX3VwdG83O1xuICAgIH1cbiAgICBpZiAoendzcFN1cHBvcnRlZCkgcmV0dXJuIGVsdChcInNwYW5cIiwgXCJcXHUyMDBiXCIpO1xuICAgIGVsc2UgcmV0dXJuIGVsdChcInNwYW5cIiwgXCJcXHUwMGEwXCIsIG51bGwsIFwiZGlzcGxheTogaW5saW5lLWJsb2NrOyB3aWR0aDogMXB4OyBtYXJnaW4tcmlnaHQ6IC0xcHhcIik7XG4gIH1cblxuICAvLyBGZWF0dXJlLWRldGVjdCBJRSdzIGNydW1teSBjbGllbnQgcmVjdCByZXBvcnRpbmcgZm9yIGJpZGkgdGV4dFxuICB2YXIgYmFkQmlkaVJlY3RzO1xuICBmdW5jdGlvbiBoYXNCYWRCaWRpUmVjdHMobWVhc3VyZSkge1xuICAgIGlmIChiYWRCaWRpUmVjdHMgIT0gbnVsbCkgcmV0dXJuIGJhZEJpZGlSZWN0cztcbiAgICB2YXIgdHh0ID0gcmVtb3ZlQ2hpbGRyZW5BbmRBZGQobWVhc3VyZSwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJBXFx1MDYyZUFcIikpO1xuICAgIHZhciByMCA9IHJhbmdlKHR4dCwgMCwgMSkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKHIwLmxlZnQgPT0gcjAucmlnaHQpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgcjEgPSByYW5nZSh0eHQsIDEsIDIpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiBiYWRCaWRpUmVjdHMgPSAocjEucmlnaHQgLSByMC5yaWdodCA8IDMpO1xuICB9XG5cbiAgLy8gU2VlIGlmIFwiXCIuc3BsaXQgaXMgdGhlIGJyb2tlbiBJRSB2ZXJzaW9uLCBpZiBzbywgcHJvdmlkZSBhblxuICAvLyBhbHRlcm5hdGl2ZSB3YXkgdG8gc3BsaXQgbGluZXMuXG4gIHZhciBzcGxpdExpbmVzID0gQ29kZU1pcnJvci5zcGxpdExpbmVzID0gXCJcXG5cXG5iXCIuc3BsaXQoL1xcbi8pLmxlbmd0aCAhPSAzID8gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIHBvcyA9IDAsIHJlc3VsdCA9IFtdLCBsID0gc3RyaW5nLmxlbmd0aDtcbiAgICB3aGlsZSAocG9zIDw9IGwpIHtcbiAgICAgIHZhciBubCA9IHN0cmluZy5pbmRleE9mKFwiXFxuXCIsIHBvcyk7XG4gICAgICBpZiAobmwgPT0gLTEpIG5sID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgIHZhciBsaW5lID0gc3RyaW5nLnNsaWNlKHBvcywgc3RyaW5nLmNoYXJBdChubCAtIDEpID09IFwiXFxyXCIgPyBubCAtIDEgOiBubCk7XG4gICAgICB2YXIgcnQgPSBsaW5lLmluZGV4T2YoXCJcXHJcIik7XG4gICAgICBpZiAocnQgIT0gLTEpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobGluZS5zbGljZSgwLCBydCkpO1xuICAgICAgICBwb3MgKz0gcnQgKyAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobGluZSk7XG4gICAgICAgIHBvcyA9IG5sICsgMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSA6IGZ1bmN0aW9uKHN0cmluZyl7cmV0dXJuIHN0cmluZy5zcGxpdCgvXFxyXFxuP3xcXG4vKTt9O1xuXG4gIHZhciBoYXNTZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uID8gZnVuY3Rpb24odGUpIHtcbiAgICB0cnkgeyByZXR1cm4gdGUuc2VsZWN0aW9uU3RhcnQgIT0gdGUuc2VsZWN0aW9uRW5kOyB9XG4gICAgY2F0Y2goZSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgfSA6IGZ1bmN0aW9uKHRlKSB7XG4gICAgdHJ5IHt2YXIgcmFuZ2UgPSB0ZS5vd25lckRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO31cbiAgICBjYXRjaChlKSB7fVxuICAgIGlmICghcmFuZ2UgfHwgcmFuZ2UucGFyZW50RWxlbWVudCgpICE9IHRlKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHJhbmdlLmNvbXBhcmVFbmRQb2ludHMoXCJTdGFydFRvRW5kXCIsIHJhbmdlKSAhPSAwO1xuICB9O1xuXG4gIHZhciBoYXNDb3B5RXZlbnQgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGUgPSBlbHQoXCJkaXZcIik7XG4gICAgaWYgKFwib25jb3B5XCIgaW4gZSkgcmV0dXJuIHRydWU7XG4gICAgZS5zZXRBdHRyaWJ1dGUoXCJvbmNvcHlcIiwgXCJyZXR1cm47XCIpO1xuICAgIHJldHVybiB0eXBlb2YgZS5vbmNvcHkgPT0gXCJmdW5jdGlvblwiO1xuICB9KSgpO1xuXG4gIC8vIEtFWSBOQU1FU1xuXG4gIHZhciBrZXlOYW1lcyA9IHszOiBcIkVudGVyXCIsIDg6IFwiQmFja3NwYWNlXCIsIDk6IFwiVGFiXCIsIDEzOiBcIkVudGVyXCIsIDE2OiBcIlNoaWZ0XCIsIDE3OiBcIkN0cmxcIiwgMTg6IFwiQWx0XCIsXG4gICAgICAgICAgICAgICAgICAxOTogXCJQYXVzZVwiLCAyMDogXCJDYXBzTG9ja1wiLCAyNzogXCJFc2NcIiwgMzI6IFwiU3BhY2VcIiwgMzM6IFwiUGFnZVVwXCIsIDM0OiBcIlBhZ2VEb3duXCIsIDM1OiBcIkVuZFwiLFxuICAgICAgICAgICAgICAgICAgMzY6IFwiSG9tZVwiLCAzNzogXCJMZWZ0XCIsIDM4OiBcIlVwXCIsIDM5OiBcIlJpZ2h0XCIsIDQwOiBcIkRvd25cIiwgNDQ6IFwiUHJpbnRTY3JuXCIsIDQ1OiBcIkluc2VydFwiLFxuICAgICAgICAgICAgICAgICAgNDY6IFwiRGVsZXRlXCIsIDU5OiBcIjtcIiwgNjE6IFwiPVwiLCA5MTogXCJNb2RcIiwgOTI6IFwiTW9kXCIsIDkzOiBcIk1vZFwiLCAxMDc6IFwiPVwiLCAxMDk6IFwiLVwiLCAxMjc6IFwiRGVsZXRlXCIsXG4gICAgICAgICAgICAgICAgICAxNzM6IFwiLVwiLCAxODY6IFwiO1wiLCAxODc6IFwiPVwiLCAxODg6IFwiLFwiLCAxODk6IFwiLVwiLCAxOTA6IFwiLlwiLCAxOTE6IFwiL1wiLCAxOTI6IFwiYFwiLCAyMTk6IFwiW1wiLCAyMjA6IFwiXFxcXFwiLFxuICAgICAgICAgICAgICAgICAgMjIxOiBcIl1cIiwgMjIyOiBcIidcIiwgNjMyMzI6IFwiVXBcIiwgNjMyMzM6IFwiRG93blwiLCA2MzIzNDogXCJMZWZ0XCIsIDYzMjM1OiBcIlJpZ2h0XCIsIDYzMjcyOiBcIkRlbGV0ZVwiLFxuICAgICAgICAgICAgICAgICAgNjMyNzM6IFwiSG9tZVwiLCA2MzI3NTogXCJFbmRcIiwgNjMyNzY6IFwiUGFnZVVwXCIsIDYzMjc3OiBcIlBhZ2VEb3duXCIsIDYzMzAyOiBcIkluc2VydFwifTtcbiAgQ29kZU1pcnJvci5rZXlOYW1lcyA9IGtleU5hbWVzO1xuICAoZnVuY3Rpb24oKSB7XG4gICAgLy8gTnVtYmVyIGtleXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIGtleU5hbWVzW2kgKyA0OF0gPSBrZXlOYW1lc1tpICsgOTZdID0gU3RyaW5nKGkpO1xuICAgIC8vIEFscGhhYmV0aWMga2V5c1xuICAgIGZvciAodmFyIGkgPSA2NTsgaSA8PSA5MDsgaSsrKSBrZXlOYW1lc1tpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSk7XG4gICAgLy8gRnVuY3Rpb24ga2V5c1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IDEyOyBpKyspIGtleU5hbWVzW2kgKyAxMTFdID0ga2V5TmFtZXNbaSArIDYzMjM1XSA9IFwiRlwiICsgaTtcbiAgfSkoKTtcblxuICAvLyBCSURJIEhFTFBFUlNcblxuICBmdW5jdGlvbiBpdGVyYXRlQmlkaVNlY3Rpb25zKG9yZGVyLCBmcm9tLCB0bywgZikge1xuICAgIGlmICghb3JkZXIpIHJldHVybiBmKGZyb20sIHRvLCBcImx0clwiKTtcbiAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgcGFydCA9IG9yZGVyW2ldO1xuICAgICAgaWYgKHBhcnQuZnJvbSA8IHRvICYmIHBhcnQudG8gPiBmcm9tIHx8IGZyb20gPT0gdG8gJiYgcGFydC50byA9PSBmcm9tKSB7XG4gICAgICAgIGYoTWF0aC5tYXgocGFydC5mcm9tLCBmcm9tKSwgTWF0aC5taW4ocGFydC50bywgdG8pLCBwYXJ0LmxldmVsID09IDEgPyBcInJ0bFwiIDogXCJsdHJcIik7XG4gICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFmb3VuZCkgZihmcm9tLCB0bywgXCJsdHJcIik7XG4gIH1cblxuICBmdW5jdGlvbiBiaWRpTGVmdChwYXJ0KSB7IHJldHVybiBwYXJ0LmxldmVsICUgMiA/IHBhcnQudG8gOiBwYXJ0LmZyb207IH1cbiAgZnVuY3Rpb24gYmlkaVJpZ2h0KHBhcnQpIHsgcmV0dXJuIHBhcnQubGV2ZWwgJSAyID8gcGFydC5mcm9tIDogcGFydC50bzsgfVxuXG4gIGZ1bmN0aW9uIGxpbmVMZWZ0KGxpbmUpIHsgdmFyIG9yZGVyID0gZ2V0T3JkZXIobGluZSk7IHJldHVybiBvcmRlciA/IGJpZGlMZWZ0KG9yZGVyWzBdKSA6IDA7IH1cbiAgZnVuY3Rpb24gbGluZVJpZ2h0KGxpbmUpIHtcbiAgICB2YXIgb3JkZXIgPSBnZXRPcmRlcihsaW5lKTtcbiAgICBpZiAoIW9yZGVyKSByZXR1cm4gbGluZS50ZXh0Lmxlbmd0aDtcbiAgICByZXR1cm4gYmlkaVJpZ2h0KGxzdChvcmRlcikpO1xuICB9XG5cbiAgZnVuY3Rpb24gbGluZVN0YXJ0KGNtLCBsaW5lTikge1xuICAgIHZhciBsaW5lID0gZ2V0TGluZShjbS5kb2MsIGxpbmVOKTtcbiAgICB2YXIgdmlzdWFsID0gdmlzdWFsTGluZShsaW5lKTtcbiAgICBpZiAodmlzdWFsICE9IGxpbmUpIGxpbmVOID0gbGluZU5vKHZpc3VhbCk7XG4gICAgdmFyIG9yZGVyID0gZ2V0T3JkZXIodmlzdWFsKTtcbiAgICB2YXIgY2ggPSAhb3JkZXIgPyAwIDogb3JkZXJbMF0ubGV2ZWwgJSAyID8gbGluZVJpZ2h0KHZpc3VhbCkgOiBsaW5lTGVmdCh2aXN1YWwpO1xuICAgIHJldHVybiBQb3MobGluZU4sIGNoKTtcbiAgfVxuICBmdW5jdGlvbiBsaW5lRW5kKGNtLCBsaW5lTikge1xuICAgIHZhciBtZXJnZWQsIGxpbmUgPSBnZXRMaW5lKGNtLmRvYywgbGluZU4pO1xuICAgIHdoaWxlIChtZXJnZWQgPSBjb2xsYXBzZWRTcGFuQXRFbmQobGluZSkpIHtcbiAgICAgIGxpbmUgPSBtZXJnZWQuZmluZCgxLCB0cnVlKS5saW5lO1xuICAgICAgbGluZU4gPSBudWxsO1xuICAgIH1cbiAgICB2YXIgb3JkZXIgPSBnZXRPcmRlcihsaW5lKTtcbiAgICB2YXIgY2ggPSAhb3JkZXIgPyBsaW5lLnRleHQubGVuZ3RoIDogb3JkZXJbMF0ubGV2ZWwgJSAyID8gbGluZUxlZnQobGluZSkgOiBsaW5lUmlnaHQobGluZSk7XG4gICAgcmV0dXJuIFBvcyhsaW5lTiA9PSBudWxsID8gbGluZU5vKGxpbmUpIDogbGluZU4sIGNoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBhcmVCaWRpTGV2ZWwob3JkZXIsIGEsIGIpIHtcbiAgICB2YXIgbGluZWRpciA9IG9yZGVyWzBdLmxldmVsO1xuICAgIGlmIChhID09IGxpbmVkaXIpIHJldHVybiB0cnVlO1xuICAgIGlmIChiID09IGxpbmVkaXIpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gYSA8IGI7XG4gIH1cbiAgdmFyIGJpZGlPdGhlcjtcbiAgZnVuY3Rpb24gZ2V0QmlkaVBhcnRBdChvcmRlciwgcG9zKSB7XG4gICAgYmlkaU90aGVyID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gMCwgZm91bmQ7IGkgPCBvcmRlci5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGN1ciA9IG9yZGVyW2ldO1xuICAgICAgaWYgKGN1ci5mcm9tIDwgcG9zICYmIGN1ci50byA+IHBvcykgcmV0dXJuIGk7XG4gICAgICBpZiAoKGN1ci5mcm9tID09IHBvcyB8fCBjdXIudG8gPT0gcG9zKSkge1xuICAgICAgICBpZiAoZm91bmQgPT0gbnVsbCkge1xuICAgICAgICAgIGZvdW5kID0gaTtcbiAgICAgICAgfSBlbHNlIGlmIChjb21wYXJlQmlkaUxldmVsKG9yZGVyLCBjdXIubGV2ZWwsIG9yZGVyW2ZvdW5kXS5sZXZlbCkpIHtcbiAgICAgICAgICBpZiAoY3VyLmZyb20gIT0gY3VyLnRvKSBiaWRpT3RoZXIgPSBmb3VuZDtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY3VyLmZyb20gIT0gY3VyLnRvKSBiaWRpT3RoZXIgPSBpO1xuICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm91bmQ7XG4gIH1cblxuICBmdW5jdGlvbiBtb3ZlSW5MaW5lKGxpbmUsIHBvcywgZGlyLCBieVVuaXQpIHtcbiAgICBpZiAoIWJ5VW5pdCkgcmV0dXJuIHBvcyArIGRpcjtcbiAgICBkbyBwb3MgKz0gZGlyO1xuICAgIHdoaWxlIChwb3MgPiAwICYmIGlzRXh0ZW5kaW5nQ2hhcihsaW5lLnRleHQuY2hhckF0KHBvcykpKTtcbiAgICByZXR1cm4gcG9zO1xuICB9XG5cbiAgLy8gVGhpcyBpcyBuZWVkZWQgaW4gb3JkZXIgdG8gbW92ZSAndmlzdWFsbHknIHRocm91Z2ggYmktZGlyZWN0aW9uYWxcbiAgLy8gdGV4dCAtLSBpLmUuLCBwcmVzc2luZyBsZWZ0IHNob3VsZCBtYWtlIHRoZSBjdXJzb3IgZ28gbGVmdCwgZXZlblxuICAvLyB3aGVuIGluIFJUTCB0ZXh0LiBUaGUgdHJpY2t5IHBhcnQgaXMgdGhlICdqdW1wcycsIHdoZXJlIFJUTCBhbmRcbiAgLy8gTFRSIHRleHQgdG91Y2ggZWFjaCBvdGhlci4gVGhpcyBvZnRlbiByZXF1aXJlcyB0aGUgY3Vyc29yIG9mZnNldFxuICAvLyB0byBtb3ZlIG1vcmUgdGhhbiBvbmUgdW5pdCwgaW4gb3JkZXIgdG8gdmlzdWFsbHkgbW92ZSBvbmUgdW5pdC5cbiAgZnVuY3Rpb24gbW92ZVZpc3VhbGx5KGxpbmUsIHN0YXJ0LCBkaXIsIGJ5VW5pdCkge1xuICAgIHZhciBiaWRpID0gZ2V0T3JkZXIobGluZSk7XG4gICAgaWYgKCFiaWRpKSByZXR1cm4gbW92ZUxvZ2ljYWxseShsaW5lLCBzdGFydCwgZGlyLCBieVVuaXQpO1xuICAgIHZhciBwb3MgPSBnZXRCaWRpUGFydEF0KGJpZGksIHN0YXJ0KSwgcGFydCA9IGJpZGlbcG9zXTtcbiAgICB2YXIgdGFyZ2V0ID0gbW92ZUluTGluZShsaW5lLCBzdGFydCwgcGFydC5sZXZlbCAlIDIgPyAtZGlyIDogZGlyLCBieVVuaXQpO1xuXG4gICAgZm9yICg7Oykge1xuICAgICAgaWYgKHRhcmdldCA+IHBhcnQuZnJvbSAmJiB0YXJnZXQgPCBwYXJ0LnRvKSByZXR1cm4gdGFyZ2V0O1xuICAgICAgaWYgKHRhcmdldCA9PSBwYXJ0LmZyb20gfHwgdGFyZ2V0ID09IHBhcnQudG8pIHtcbiAgICAgICAgaWYgKGdldEJpZGlQYXJ0QXQoYmlkaSwgdGFyZ2V0KSA9PSBwb3MpIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIHBhcnQgPSBiaWRpW3BvcyArPSBkaXJdO1xuICAgICAgICByZXR1cm4gKGRpciA+IDApID09IHBhcnQubGV2ZWwgJSAyID8gcGFydC50byA6IHBhcnQuZnJvbTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnQgPSBiaWRpW3BvcyArPSBkaXJdO1xuICAgICAgICBpZiAoIXBhcnQpIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoKGRpciA+IDApID09IHBhcnQubGV2ZWwgJSAyKVxuICAgICAgICAgIHRhcmdldCA9IG1vdmVJbkxpbmUobGluZSwgcGFydC50bywgLTEsIGJ5VW5pdCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0YXJnZXQgPSBtb3ZlSW5MaW5lKGxpbmUsIHBhcnQuZnJvbSwgMSwgYnlVbml0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtb3ZlTG9naWNhbGx5KGxpbmUsIHN0YXJ0LCBkaXIsIGJ5VW5pdCkge1xuICAgIHZhciB0YXJnZXQgPSBzdGFydCArIGRpcjtcbiAgICBpZiAoYnlVbml0KSB3aGlsZSAodGFyZ2V0ID4gMCAmJiBpc0V4dGVuZGluZ0NoYXIobGluZS50ZXh0LmNoYXJBdCh0YXJnZXQpKSkgdGFyZ2V0ICs9IGRpcjtcbiAgICByZXR1cm4gdGFyZ2V0IDwgMCB8fCB0YXJnZXQgPiBsaW5lLnRleHQubGVuZ3RoID8gbnVsbCA6IHRhcmdldDtcbiAgfVxuXG4gIC8vIEJpZGlyZWN0aW9uYWwgb3JkZXJpbmcgYWxnb3JpdGhtXG4gIC8vIFNlZSBodHRwOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjkvdHI5LTEzLmh0bWwgZm9yIHRoZSBhbGdvcml0aG1cbiAgLy8gdGhhdCB0aGlzIChwYXJ0aWFsbHkpIGltcGxlbWVudHMuXG5cbiAgLy8gT25lLWNoYXIgY29kZXMgdXNlZCBmb3IgY2hhcmFjdGVyIHR5cGVzOlxuICAvLyBMIChMKTogICBMZWZ0LXRvLVJpZ2h0XG4gIC8vIFIgKFIpOiAgIFJpZ2h0LXRvLUxlZnRcbiAgLy8gciAoQUwpOiAgUmlnaHQtdG8tTGVmdCBBcmFiaWNcbiAgLy8gMSAoRU4pOiAgRXVyb3BlYW4gTnVtYmVyXG4gIC8vICsgKEVTKTogIEV1cm9wZWFuIE51bWJlciBTZXBhcmF0b3JcbiAgLy8gJSAoRVQpOiAgRXVyb3BlYW4gTnVtYmVyIFRlcm1pbmF0b3JcbiAgLy8gbiAoQU4pOiAgQXJhYmljIE51bWJlclxuICAvLyAsIChDUyk6ICBDb21tb24gTnVtYmVyIFNlcGFyYXRvclxuICAvLyBtIChOU00pOiBOb24tU3BhY2luZyBNYXJrXG4gIC8vIGIgKEJOKTogIEJvdW5kYXJ5IE5ldXRyYWxcbiAgLy8gcyAoQik6ICAgUGFyYWdyYXBoIFNlcGFyYXRvclxuICAvLyB0IChTKTogICBTZWdtZW50IFNlcGFyYXRvclxuICAvLyB3IChXUyk6ICBXaGl0ZXNwYWNlXG4gIC8vIE4gKE9OKTogIE90aGVyIE5ldXRyYWxzXG5cbiAgLy8gUmV0dXJucyBudWxsIGlmIGNoYXJhY3RlcnMgYXJlIG9yZGVyZWQgYXMgdGhleSBhcHBlYXJcbiAgLy8gKGxlZnQtdG8tcmlnaHQpLCBvciBhbiBhcnJheSBvZiBzZWN0aW9ucyAoe2Zyb20sIHRvLCBsZXZlbH1cbiAgLy8gb2JqZWN0cykgaW4gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgb2NjdXIgdmlzdWFsbHkuXG4gIHZhciBiaWRpT3JkZXJpbmcgPSAoZnVuY3Rpb24oKSB7XG4gICAgLy8gQ2hhcmFjdGVyIHR5cGVzIGZvciBjb2RlcG9pbnRzIDAgdG8gMHhmZlxuICAgIHZhciBsb3dUeXBlcyA9IFwiYmJiYmJiYmJidHN0d3NiYmJiYmJiYmJiYmJiYnNzc3R3Tk4lJSVOTk5OTk4sTixOMTExMTExMTExMU5OTk5OTk5MTExMTExMTExMTExMTExMTExMTExMTExMTE5OTk5OTkxMTExMTExMTExMTExMTExMTExMTExMTExMTk5OTmJiYmJiYnNiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYixOJSUlJU5OTk5MTk5OTk4lJTExTkxOTk4xTE5OTk5OTExMTExMTExMTExMTExMTExMTExMTExOTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTE5cIjtcbiAgICAvLyBDaGFyYWN0ZXIgdHlwZXMgZm9yIGNvZGVwb2ludHMgMHg2MDAgdG8gMHg2ZmZcbiAgICB2YXIgYXJhYmljVHlwZXMgPSBcInJycnJycnJycnJycixyTk5tbW1tbW1ycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycm1tbW1tbW1tbW1tbW1tcnJycnJycm5ubm5ubm5ubm4lbm5ycnJtcnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJtbW1tbW1tbW1tbW1tbW1tbW1tTm1tbW1cIjtcbiAgICBmdW5jdGlvbiBjaGFyVHlwZShjb2RlKSB7XG4gICAgICBpZiAoY29kZSA8PSAweGY3KSByZXR1cm4gbG93VHlwZXMuY2hhckF0KGNvZGUpO1xuICAgICAgZWxzZSBpZiAoMHg1OTAgPD0gY29kZSAmJiBjb2RlIDw9IDB4NWY0KSByZXR1cm4gXCJSXCI7XG4gICAgICBlbHNlIGlmICgweDYwMCA8PSBjb2RlICYmIGNvZGUgPD0gMHg2ZWQpIHJldHVybiBhcmFiaWNUeXBlcy5jaGFyQXQoY29kZSAtIDB4NjAwKTtcbiAgICAgIGVsc2UgaWYgKDB4NmVlIDw9IGNvZGUgJiYgY29kZSA8PSAweDhhYykgcmV0dXJuIFwiclwiO1xuICAgICAgZWxzZSBpZiAoMHgyMDAwIDw9IGNvZGUgJiYgY29kZSA8PSAweDIwMGIpIHJldHVybiBcIndcIjtcbiAgICAgIGVsc2UgaWYgKGNvZGUgPT0gMHgyMDBjKSByZXR1cm4gXCJiXCI7XG4gICAgICBlbHNlIHJldHVybiBcIkxcIjtcbiAgICB9XG5cbiAgICB2YXIgYmlkaVJFID0gL1tcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUwNzAwLVxcdTA4YWNdLztcbiAgICB2YXIgaXNOZXV0cmFsID0gL1tzdHdOXS8sIGlzU3Ryb25nID0gL1tMUnJdLywgY291bnRzQXNMZWZ0ID0gL1tMYjFuXS8sIGNvdW50c0FzTnVtID0gL1sxbl0vO1xuICAgIC8vIEJyb3dzZXJzIHNlZW0gdG8gYWx3YXlzIHRyZWF0IHRoZSBib3VuZGFyaWVzIG9mIGJsb2NrIGVsZW1lbnRzIGFzIGJlaW5nIEwuXG4gICAgdmFyIG91dGVyVHlwZSA9IFwiTFwiO1xuXG4gICAgZnVuY3Rpb24gQmlkaVNwYW4obGV2ZWwsIGZyb20sIHRvKSB7XG4gICAgICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gICAgICB0aGlzLmZyb20gPSBmcm9tOyB0aGlzLnRvID0gdG87XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cikge1xuICAgICAgaWYgKCFiaWRpUkUudGVzdChzdHIpKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgbGVuID0gc3RyLmxlbmd0aCwgdHlwZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCB0eXBlOyBpIDwgbGVuOyArK2kpXG4gICAgICAgIHR5cGVzLnB1c2godHlwZSA9IGNoYXJUeXBlKHN0ci5jaGFyQ29kZUF0KGkpKSk7XG5cbiAgICAgIC8vIFcxLiBFeGFtaW5lIGVhY2ggbm9uLXNwYWNpbmcgbWFyayAoTlNNKSBpbiB0aGUgbGV2ZWwgcnVuLCBhbmRcbiAgICAgIC8vIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgTlNNIHRvIHRoZSB0eXBlIG9mIHRoZSBwcmV2aW91c1xuICAgICAgLy8gY2hhcmFjdGVyLiBJZiB0aGUgTlNNIGlzIGF0IHRoZSBzdGFydCBvZiB0aGUgbGV2ZWwgcnVuLCBpdCB3aWxsXG4gICAgICAvLyBnZXQgdGhlIHR5cGUgb2Ygc29yLlxuICAgICAgZm9yICh2YXIgaSA9IDAsIHByZXYgPSBvdXRlclR5cGU7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB2YXIgdHlwZSA9IHR5cGVzW2ldO1xuICAgICAgICBpZiAodHlwZSA9PSBcIm1cIikgdHlwZXNbaV0gPSBwcmV2O1xuICAgICAgICBlbHNlIHByZXYgPSB0eXBlO1xuICAgICAgfVxuXG4gICAgICAvLyBXMi4gU2VhcmNoIGJhY2t3YXJkcyBmcm9tIGVhY2ggaW5zdGFuY2Ugb2YgYSBFdXJvcGVhbiBudW1iZXJcbiAgICAgIC8vIHVudGlsIHRoZSBmaXJzdCBzdHJvbmcgdHlwZSAoUiwgTCwgQUwsIG9yIHNvcikgaXMgZm91bmQuIElmIGFuXG4gICAgICAvLyBBTCBpcyBmb3VuZCwgY2hhbmdlIHRoZSB0eXBlIG9mIHRoZSBFdXJvcGVhbiBudW1iZXIgdG8gQXJhYmljXG4gICAgICAvLyBudW1iZXIuXG4gICAgICAvLyBXMy4gQ2hhbmdlIGFsbCBBTHMgdG8gUi5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBjdXIgPSBvdXRlclR5cGU7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB2YXIgdHlwZSA9IHR5cGVzW2ldO1xuICAgICAgICBpZiAodHlwZSA9PSBcIjFcIiAmJiBjdXIgPT0gXCJyXCIpIHR5cGVzW2ldID0gXCJuXCI7XG4gICAgICAgIGVsc2UgaWYgKGlzU3Ryb25nLnRlc3QodHlwZSkpIHsgY3VyID0gdHlwZTsgaWYgKHR5cGUgPT0gXCJyXCIpIHR5cGVzW2ldID0gXCJSXCI7IH1cbiAgICAgIH1cblxuICAgICAgLy8gVzQuIEEgc2luZ2xlIEV1cm9wZWFuIHNlcGFyYXRvciBiZXR3ZWVuIHR3byBFdXJvcGVhbiBudW1iZXJzXG4gICAgICAvLyBjaGFuZ2VzIHRvIGEgRXVyb3BlYW4gbnVtYmVyLiBBIHNpbmdsZSBjb21tb24gc2VwYXJhdG9yIGJldHdlZW5cbiAgICAgIC8vIHR3byBudW1iZXJzIG9mIHRoZSBzYW1lIHR5cGUgY2hhbmdlcyB0byB0aGF0IHR5cGUuXG4gICAgICBmb3IgKHZhciBpID0gMSwgcHJldiA9IHR5cGVzWzBdOyBpIDwgbGVuIC0gMTsgKytpKSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZXNbaV07XG4gICAgICAgIGlmICh0eXBlID09IFwiK1wiICYmIHByZXYgPT0gXCIxXCIgJiYgdHlwZXNbaSsxXSA9PSBcIjFcIikgdHlwZXNbaV0gPSBcIjFcIjtcbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PSBcIixcIiAmJiBwcmV2ID09IHR5cGVzW2krMV0gJiZcbiAgICAgICAgICAgICAgICAgKHByZXYgPT0gXCIxXCIgfHwgcHJldiA9PSBcIm5cIikpIHR5cGVzW2ldID0gcHJldjtcbiAgICAgICAgcHJldiA9IHR5cGU7XG4gICAgICB9XG5cbiAgICAgIC8vIFc1LiBBIHNlcXVlbmNlIG9mIEV1cm9wZWFuIHRlcm1pbmF0b3JzIGFkamFjZW50IHRvIEV1cm9wZWFuXG4gICAgICAvLyBudW1iZXJzIGNoYW5nZXMgdG8gYWxsIEV1cm9wZWFuIG51bWJlcnMuXG4gICAgICAvLyBXNi4gT3RoZXJ3aXNlLCBzZXBhcmF0b3JzIGFuZCB0ZXJtaW5hdG9ycyBjaGFuZ2UgdG8gT3RoZXJcbiAgICAgIC8vIE5ldXRyYWwuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZXNbaV07XG4gICAgICAgIGlmICh0eXBlID09IFwiLFwiKSB0eXBlc1tpXSA9IFwiTlwiO1xuICAgICAgICBlbHNlIGlmICh0eXBlID09IFwiJVwiKSB7XG4gICAgICAgICAgZm9yICh2YXIgZW5kID0gaSArIDE7IGVuZCA8IGxlbiAmJiB0eXBlc1tlbmRdID09IFwiJVwiOyArK2VuZCkge31cbiAgICAgICAgICB2YXIgcmVwbGFjZSA9IChpICYmIHR5cGVzW2ktMV0gPT0gXCIhXCIpIHx8IChlbmQgPCBsZW4gJiYgdHlwZXNbZW5kXSA9PSBcIjFcIikgPyBcIjFcIiA6IFwiTlwiO1xuICAgICAgICAgIGZvciAodmFyIGogPSBpOyBqIDwgZW5kOyArK2opIHR5cGVzW2pdID0gcmVwbGFjZTtcbiAgICAgICAgICBpID0gZW5kIC0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBXNy4gU2VhcmNoIGJhY2t3YXJkcyBmcm9tIGVhY2ggaW5zdGFuY2Ugb2YgYSBFdXJvcGVhbiBudW1iZXJcbiAgICAgIC8vIHVudGlsIHRoZSBmaXJzdCBzdHJvbmcgdHlwZSAoUiwgTCwgb3Igc29yKSBpcyBmb3VuZC4gSWYgYW4gTCBpc1xuICAgICAgLy8gZm91bmQsIHRoZW4gY2hhbmdlIHRoZSB0eXBlIG9mIHRoZSBFdXJvcGVhbiBudW1iZXIgdG8gTC5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBjdXIgPSBvdXRlclR5cGU7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB2YXIgdHlwZSA9IHR5cGVzW2ldO1xuICAgICAgICBpZiAoY3VyID09IFwiTFwiICYmIHR5cGUgPT0gXCIxXCIpIHR5cGVzW2ldID0gXCJMXCI7XG4gICAgICAgIGVsc2UgaWYgKGlzU3Ryb25nLnRlc3QodHlwZSkpIGN1ciA9IHR5cGU7XG4gICAgICB9XG5cbiAgICAgIC8vIE4xLiBBIHNlcXVlbmNlIG9mIG5ldXRyYWxzIHRha2VzIHRoZSBkaXJlY3Rpb24gb2YgdGhlXG4gICAgICAvLyBzdXJyb3VuZGluZyBzdHJvbmcgdGV4dCBpZiB0aGUgdGV4dCBvbiBib3RoIHNpZGVzIGhhcyB0aGUgc2FtZVxuICAgICAgLy8gZGlyZWN0aW9uLiBFdXJvcGVhbiBhbmQgQXJhYmljIG51bWJlcnMgYWN0IGFzIGlmIHRoZXkgd2VyZSBSIGluXG4gICAgICAvLyB0ZXJtcyBvZiB0aGVpciBpbmZsdWVuY2Ugb24gbmV1dHJhbHMuIFN0YXJ0LW9mLWxldmVsLXJ1biAoc29yKVxuICAgICAgLy8gYW5kIGVuZC1vZi1sZXZlbC1ydW4gKGVvcikgYXJlIHVzZWQgYXQgbGV2ZWwgcnVuIGJvdW5kYXJpZXMuXG4gICAgICAvLyBOMi4gQW55IHJlbWFpbmluZyBuZXV0cmFscyB0YWtlIHRoZSBlbWJlZGRpbmcgZGlyZWN0aW9uLlxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBpZiAoaXNOZXV0cmFsLnRlc3QodHlwZXNbaV0pKSB7XG4gICAgICAgICAgZm9yICh2YXIgZW5kID0gaSArIDE7IGVuZCA8IGxlbiAmJiBpc05ldXRyYWwudGVzdCh0eXBlc1tlbmRdKTsgKytlbmQpIHt9XG4gICAgICAgICAgdmFyIGJlZm9yZSA9IChpID8gdHlwZXNbaS0xXSA6IG91dGVyVHlwZSkgPT0gXCJMXCI7XG4gICAgICAgICAgdmFyIGFmdGVyID0gKGVuZCA8IGxlbiA/IHR5cGVzW2VuZF0gOiBvdXRlclR5cGUpID09IFwiTFwiO1xuICAgICAgICAgIHZhciByZXBsYWNlID0gYmVmb3JlIHx8IGFmdGVyID8gXCJMXCIgOiBcIlJcIjtcbiAgICAgICAgICBmb3IgKHZhciBqID0gaTsgaiA8IGVuZDsgKytqKSB0eXBlc1tqXSA9IHJlcGxhY2U7XG4gICAgICAgICAgaSA9IGVuZCAtIDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSGVyZSB3ZSBkZXBhcnQgZnJvbSB0aGUgZG9jdW1lbnRlZCBhbGdvcml0aG0sIGluIG9yZGVyIHRvIGF2b2lkXG4gICAgICAvLyBidWlsZGluZyB1cCBhbiBhY3R1YWwgbGV2ZWxzIGFycmF5LiBTaW5jZSB0aGVyZSBhcmUgb25seSB0aHJlZVxuICAgICAgLy8gbGV2ZWxzICgwLCAxLCAyKSBpbiBhbiBpbXBsZW1lbnRhdGlvbiB0aGF0IGRvZXNuJ3QgdGFrZVxuICAgICAgLy8gZXhwbGljaXQgZW1iZWRkaW5nIGludG8gYWNjb3VudCwgd2UgY2FuIGJ1aWxkIHVwIHRoZSBvcmRlciBvblxuICAgICAgLy8gdGhlIGZseSwgd2l0aG91dCBmb2xsb3dpbmcgdGhlIGxldmVsLWJhc2VkIGFsZ29yaXRobS5cbiAgICAgIHZhciBvcmRlciA9IFtdLCBtO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgIGlmIChjb3VudHNBc0xlZnQudGVzdCh0eXBlc1tpXSkpIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSBpO1xuICAgICAgICAgIGZvciAoKytpOyBpIDwgbGVuICYmIGNvdW50c0FzTGVmdC50ZXN0KHR5cGVzW2ldKTsgKytpKSB7fVxuICAgICAgICAgIG9yZGVyLnB1c2gobmV3IEJpZGlTcGFuKDAsIHN0YXJ0LCBpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHBvcyA9IGksIGF0ID0gb3JkZXIubGVuZ3RoO1xuICAgICAgICAgIGZvciAoKytpOyBpIDwgbGVuICYmIHR5cGVzW2ldICE9IFwiTFwiOyArK2kpIHt9XG4gICAgICAgICAgZm9yICh2YXIgaiA9IHBvczsgaiA8IGk7KSB7XG4gICAgICAgICAgICBpZiAoY291bnRzQXNOdW0udGVzdCh0eXBlc1tqXSkpIHtcbiAgICAgICAgICAgICAgaWYgKHBvcyA8IGopIG9yZGVyLnNwbGljZShhdCwgMCwgbmV3IEJpZGlTcGFuKDEsIHBvcywgaikpO1xuICAgICAgICAgICAgICB2YXIgbnN0YXJ0ID0gajtcbiAgICAgICAgICAgICAgZm9yICgrK2o7IGogPCBpICYmIGNvdW50c0FzTnVtLnRlc3QodHlwZXNbal0pOyArK2opIHt9XG4gICAgICAgICAgICAgIG9yZGVyLnNwbGljZShhdCwgMCwgbmV3IEJpZGlTcGFuKDIsIG5zdGFydCwgaikpO1xuICAgICAgICAgICAgICBwb3MgPSBqO1xuICAgICAgICAgICAgfSBlbHNlICsrajtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBvcyA8IGkpIG9yZGVyLnNwbGljZShhdCwgMCwgbmV3IEJpZGlTcGFuKDEsIHBvcywgaSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3JkZXJbMF0ubGV2ZWwgPT0gMSAmJiAobSA9IHN0ci5tYXRjaCgvXlxccysvKSkpIHtcbiAgICAgICAgb3JkZXJbMF0uZnJvbSA9IG1bMF0ubGVuZ3RoO1xuICAgICAgICBvcmRlci51bnNoaWZ0KG5ldyBCaWRpU3BhbigwLCAwLCBtWzBdLmxlbmd0aCkpO1xuICAgICAgfVxuICAgICAgaWYgKGxzdChvcmRlcikubGV2ZWwgPT0gMSAmJiAobSA9IHN0ci5tYXRjaCgvXFxzKyQvKSkpIHtcbiAgICAgICAgbHN0KG9yZGVyKS50byAtPSBtWzBdLmxlbmd0aDtcbiAgICAgICAgb3JkZXIucHVzaChuZXcgQmlkaVNwYW4oMCwgbGVuIC0gbVswXS5sZW5ndGgsIGxlbikpO1xuICAgICAgfVxuICAgICAgaWYgKG9yZGVyWzBdLmxldmVsICE9IGxzdChvcmRlcikubGV2ZWwpXG4gICAgICAgIG9yZGVyLnB1c2gobmV3IEJpZGlTcGFuKG9yZGVyWzBdLmxldmVsLCBsZW4sIGxlbikpO1xuXG4gICAgICByZXR1cm4gb3JkZXI7XG4gICAgfTtcbiAgfSkoKTtcblxuICAvLyBUSEUgRU5EXG5cbiAgQ29kZU1pcnJvci52ZXJzaW9uID0gXCI0LjEuMFwiO1xuXG4gIHJldHVybiBDb2RlTWlycm9yO1xufSk7XG4iLCIoZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTW9kZShcImNsaWtlXCIsIGZ1bmN0aW9uKGNvbmZpZywgcGFyc2VyQ29uZmlnKSB7XG4gIHZhciBpbmRlbnRVbml0ID0gY29uZmlnLmluZGVudFVuaXQsXG4gICAgICBzdGF0ZW1lbnRJbmRlbnRVbml0ID0gcGFyc2VyQ29uZmlnLnN0YXRlbWVudEluZGVudFVuaXQgfHwgaW5kZW50VW5pdCxcbiAgICAgIGRvbnRBbGlnbkNhbGxzID0gcGFyc2VyQ29uZmlnLmRvbnRBbGlnbkNhbGxzLFxuICAgICAga2V5d29yZHMgPSBwYXJzZXJDb25maWcua2V5d29yZHMgfHwge30sXG4gICAgICBidWlsdGluID0gcGFyc2VyQ29uZmlnLmJ1aWx0aW4gfHwge30sXG4gICAgICBibG9ja0tleXdvcmRzID0gcGFyc2VyQ29uZmlnLmJsb2NrS2V5d29yZHMgfHwge30sXG4gICAgICBhdG9tcyA9IHBhcnNlckNvbmZpZy5hdG9tcyB8fCB7fSxcbiAgICAgIGhvb2tzID0gcGFyc2VyQ29uZmlnLmhvb2tzIHx8IHt9LFxuICAgICAgbXVsdGlMaW5lU3RyaW5ncyA9IHBhcnNlckNvbmZpZy5tdWx0aUxpbmVTdHJpbmdzO1xuICB2YXIgaXNPcGVyYXRvckNoYXIgPSAvWytcXC0qJiU9PD4hP3xcXC9dLztcblxuICB2YXIgY3VyUHVuYztcblxuICBmdW5jdGlvbiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG4gICAgaWYgKGhvb2tzW2NoXSkge1xuICAgICAgdmFyIHJlc3VsdCA9IGhvb2tzW2NoXShzdHJlYW0sIHN0YXRlKTtcbiAgICAgIGlmIChyZXN1bHQgIT09IGZhbHNlKSByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAoY2ggPT0gJ1wiJyB8fCBjaCA9PSBcIidcIikge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlblN0cmluZyhjaCk7XG4gICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICAgIGlmICgvW1xcW1xcXXt9XFwoXFwpLDtcXDpcXC5dLy50ZXN0KGNoKSkge1xuICAgICAgY3VyUHVuYyA9IGNoO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICgvXFxkLy50ZXN0KGNoKSkge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwuXS8pO1xuICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgfVxuICAgIGlmIChjaCA9PSBcIi9cIikge1xuICAgICAgaWYgKHN0cmVhbS5lYXQoXCIqXCIpKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5Db21tZW50O1xuICAgICAgICByZXR1cm4gdG9rZW5Db21tZW50KHN0cmVhbSwgc3RhdGUpO1xuICAgICAgfVxuICAgICAgaWYgKHN0cmVhbS5lYXQoXCIvXCIpKSB7XG4gICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNPcGVyYXRvckNoYXIudGVzdChjaCkpIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZShpc09wZXJhdG9yQ2hhcik7XG4gICAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICAgIH1cbiAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXCRfXS8pO1xuICAgIHZhciBjdXIgPSBzdHJlYW0uY3VycmVudCgpO1xuICAgIGlmIChrZXl3b3Jkcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSB7XG4gICAgICBpZiAoYmxvY2tLZXl3b3Jkcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSBjdXJQdW5jID0gXCJuZXdzdGF0ZW1lbnRcIjtcbiAgICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgICB9XG4gICAgaWYgKGJ1aWx0aW4ucHJvcGVydHlJc0VudW1lcmFibGUoY3VyKSkge1xuICAgICAgaWYgKGJsb2NrS2V5d29yZHMucHJvcGVydHlJc0VudW1lcmFibGUoY3VyKSkgY3VyUHVuYyA9IFwibmV3c3RhdGVtZW50XCI7XG4gICAgICByZXR1cm4gXCJidWlsdGluXCI7XG4gICAgfVxuICAgIGlmIChhdG9tcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSByZXR1cm4gXCJhdG9tXCI7XG4gICAgcmV0dXJuIFwidmFyaWFibGVcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuU3RyaW5nKHF1b3RlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciBlc2NhcGVkID0gZmFsc2UsIG5leHQsIGVuZCA9IGZhbHNlO1xuICAgICAgd2hpbGUgKChuZXh0ID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgICBpZiAobmV4dCA9PSBxdW90ZSAmJiAhZXNjYXBlZCkge2VuZCA9IHRydWU7IGJyZWFrO31cbiAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkICYmIG5leHQgPT0gXCJcXFxcXCI7XG4gICAgICB9XG4gICAgICBpZiAoZW5kIHx8ICEoZXNjYXBlZCB8fCBtdWx0aUxpbmVTdHJpbmdzKSlcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSBudWxsO1xuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuQ29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIG1heWJlRW5kID0gZmFsc2UsIGNoO1xuICAgIHdoaWxlIChjaCA9IHN0cmVhbS5uZXh0KCkpIHtcbiAgICAgIGlmIChjaCA9PSBcIi9cIiAmJiBtYXliZUVuZCkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbWF5YmVFbmQgPSAoY2ggPT0gXCIqXCIpO1xuICAgIH1cbiAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KGluZGVudGVkLCBjb2x1bW4sIHR5cGUsIGFsaWduLCBwcmV2KSB7XG4gICAgdGhpcy5pbmRlbnRlZCA9IGluZGVudGVkO1xuICAgIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5hbGlnbiA9IGFsaWduO1xuICAgIHRoaXMucHJldiA9IHByZXY7XG4gIH1cbiAgZnVuY3Rpb24gcHVzaENvbnRleHQoc3RhdGUsIGNvbCwgdHlwZSkge1xuICAgIHZhciBpbmRlbnQgPSBzdGF0ZS5pbmRlbnRlZDtcbiAgICBpZiAoc3RhdGUuY29udGV4dCAmJiBzdGF0ZS5jb250ZXh0LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIilcbiAgICAgIGluZGVudCA9IHN0YXRlLmNvbnRleHQuaW5kZW50ZWQ7XG4gICAgcmV0dXJuIHN0YXRlLmNvbnRleHQgPSBuZXcgQ29udGV4dChpbmRlbnQsIGNvbCwgdHlwZSwgbnVsbCwgc3RhdGUuY29udGV4dCk7XG4gIH1cbiAgZnVuY3Rpb24gcG9wQ29udGV4dChzdGF0ZSkge1xuICAgIHZhciB0ID0gc3RhdGUuY29udGV4dC50eXBlO1xuICAgIGlmICh0ID09IFwiKVwiIHx8IHQgPT0gXCJdXCIgfHwgdCA9PSBcIn1cIilcbiAgICAgIHN0YXRlLmluZGVudGVkID0gc3RhdGUuY29udGV4dC5pbmRlbnRlZDtcbiAgICByZXR1cm4gc3RhdGUuY29udGV4dCA9IHN0YXRlLmNvbnRleHQucHJldjtcbiAgfVxuXG4gIC8vIEludGVyZmFjZVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oYmFzZWNvbHVtbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9rZW5pemU6IG51bGwsXG4gICAgICAgIGNvbnRleHQ6IG5ldyBDb250ZXh0KChiYXNlY29sdW1uIHx8IDApIC0gaW5kZW50VW5pdCwgMCwgXCJ0b3BcIiwgZmFsc2UpLFxuICAgICAgICBpbmRlbnRlZDogMCxcbiAgICAgICAgc3RhcnRPZkxpbmU6IHRydWVcbiAgICAgIH07XG4gICAgfSxcblxuICAgIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgY3R4ID0gc3RhdGUuY29udGV4dDtcbiAgICAgIGlmIChzdHJlYW0uc29sKCkpIHtcbiAgICAgICAgaWYgKGN0eC5hbGlnbiA9PSBudWxsKSBjdHguYWxpZ24gPSBmYWxzZTtcbiAgICAgICAgc3RhdGUuaW5kZW50ZWQgPSBzdHJlYW0uaW5kZW50YXRpb24oKTtcbiAgICAgICAgc3RhdGUuc3RhcnRPZkxpbmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSByZXR1cm4gbnVsbDtcbiAgICAgIGN1clB1bmMgPSBudWxsO1xuICAgICAgdmFyIHN0eWxlID0gKHN0YXRlLnRva2VuaXplIHx8IHRva2VuQmFzZSkoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBpZiAoc3R5bGUgPT0gXCJjb21tZW50XCIgfHwgc3R5bGUgPT0gXCJtZXRhXCIpIHJldHVybiBzdHlsZTtcbiAgICAgIGlmIChjdHguYWxpZ24gPT0gbnVsbCkgY3R4LmFsaWduID0gdHJ1ZTtcblxuICAgICAgaWYgKChjdXJQdW5jID09IFwiO1wiIHx8IGN1clB1bmMgPT0gXCI6XCIgfHwgY3VyUHVuYyA9PSBcIixcIikgJiYgY3R4LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIikgcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICBlbHNlIGlmIChjdXJQdW5jID09IFwie1wiKSBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLmNvbHVtbigpLCBcIn1cIik7XG4gICAgICBlbHNlIGlmIChjdXJQdW5jID09IFwiW1wiKSBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLmNvbHVtbigpLCBcIl1cIik7XG4gICAgICBlbHNlIGlmIChjdXJQdW5jID09IFwiKFwiKSBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLmNvbHVtbigpLCBcIilcIik7XG4gICAgICBlbHNlIGlmIChjdXJQdW5jID09IFwifVwiKSB7XG4gICAgICAgIHdoaWxlIChjdHgudHlwZSA9PSBcInN0YXRlbWVudFwiKSBjdHggPSBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgICAgaWYgKGN0eC50eXBlID09IFwifVwiKSBjdHggPSBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgICAgd2hpbGUgKGN0eC50eXBlID09IFwic3RhdGVtZW50XCIpIGN0eCA9IHBvcENvbnRleHQoc3RhdGUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBjdHgudHlwZSkgcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICBlbHNlIGlmICgoKGN0eC50eXBlID09IFwifVwiIHx8IGN0eC50eXBlID09IFwidG9wXCIpICYmIGN1clB1bmMgIT0gJzsnKSB8fCAoY3R4LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIiAmJiBjdXJQdW5jID09IFwibmV3c3RhdGVtZW50XCIpKVxuICAgICAgICBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLmNvbHVtbigpLCBcInN0YXRlbWVudFwiKTtcbiAgICAgIHN0YXRlLnN0YXJ0T2ZMaW5lID0gZmFsc2U7XG4gICAgICByZXR1cm4gc3R5bGU7XG4gICAgfSxcblxuICAgIGluZGVudDogZnVuY3Rpb24oc3RhdGUsIHRleHRBZnRlcikge1xuICAgICAgaWYgKHN0YXRlLnRva2VuaXplICE9IHRva2VuQmFzZSAmJiBzdGF0ZS50b2tlbml6ZSAhPSBudWxsKSByZXR1cm4gQ29kZU1pcnJvci5QYXNzO1xuICAgICAgdmFyIGN0eCA9IHN0YXRlLmNvbnRleHQsIGZpcnN0Q2hhciA9IHRleHRBZnRlciAmJiB0ZXh0QWZ0ZXIuY2hhckF0KDApO1xuICAgICAgaWYgKGN0eC50eXBlID09IFwic3RhdGVtZW50XCIgJiYgZmlyc3RDaGFyID09IFwifVwiKSBjdHggPSBjdHgucHJldjtcbiAgICAgIHZhciBjbG9zaW5nID0gZmlyc3RDaGFyID09IGN0eC50eXBlO1xuICAgICAgaWYgKGN0eC50eXBlID09IFwic3RhdGVtZW50XCIpIHJldHVybiBjdHguaW5kZW50ZWQgKyAoZmlyc3RDaGFyID09IFwie1wiID8gMCA6IHN0YXRlbWVudEluZGVudFVuaXQpO1xuICAgICAgZWxzZSBpZiAoY3R4LmFsaWduICYmICghZG9udEFsaWduQ2FsbHMgfHwgY3R4LnR5cGUgIT0gXCIpXCIpKSByZXR1cm4gY3R4LmNvbHVtbiArIChjbG9zaW5nID8gMCA6IDEpO1xuICAgICAgZWxzZSBpZiAoY3R4LnR5cGUgPT0gXCIpXCIgJiYgIWNsb3NpbmcpIHJldHVybiBjdHguaW5kZW50ZWQgKyBzdGF0ZW1lbnRJbmRlbnRVbml0O1xuICAgICAgZWxzZSByZXR1cm4gY3R4LmluZGVudGVkICsgKGNsb3NpbmcgPyAwIDogaW5kZW50VW5pdCk7XG4gICAgfSxcblxuICAgIGVsZWN0cmljQ2hhcnM6IFwie31cIixcbiAgICBibG9ja0NvbW1lbnRTdGFydDogXCIvKlwiLFxuICAgIGJsb2NrQ29tbWVudEVuZDogXCIqL1wiLFxuICAgIGxpbmVDb21tZW50OiBcIi8vXCIsXG4gICAgZm9sZDogXCJicmFjZVwiXG4gIH07XG59KTtcblxuICBmdW5jdGlvbiB3b3JkcyhzdHIpIHtcbiAgICB2YXIgb2JqID0ge30sIHdvcmRzID0gc3RyLnNwbGl0KFwiIFwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgKytpKSBvYmpbd29yZHNbaV1dID0gdHJ1ZTtcbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIHZhciBjS2V5d29yZHMgPSBcImF1dG8gaWYgYnJlYWsgaW50IGNhc2UgbG9uZyBjaGFyIHJlZ2lzdGVyIGNvbnRpbnVlIHJldHVybiBkZWZhdWx0IHNob3J0IGRvIHNpemVvZiBcIiArXG4gICAgXCJkb3VibGUgc3RhdGljIGVsc2Ugc3RydWN0IGVudHJ5IHN3aXRjaCBleHRlcm4gdHlwZWRlZiBmbG9hdCB1bmlvbiBmb3IgdW5zaWduZWQgXCIgK1xuICAgIFwiZ290byB3aGlsZSBlbnVtIHZvaWQgY29uc3Qgc2lnbmVkIHZvbGF0aWxlXCI7XG5cbiAgZnVuY3Rpb24gY3BwSG9vayhzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKCFzdGF0ZS5zdGFydE9mTGluZSkgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAoOzspIHtcbiAgICAgIGlmIChzdHJlYW0uc2tpcFRvKFwiXFxcXFwiKSkge1xuICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICBpZiAoc3RyZWFtLmVvbCgpKSB7XG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSBjcHBIb29rO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcIm1ldGFcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNwcDExU3RyaW5nSG9vayhzdHJlYW0sIHN0YXRlKSB7XG4gICAgc3RyZWFtLmJhY2tVcCgxKTtcbiAgICAvLyBSYXcgc3RyaW5ncy5cbiAgICBpZiAoc3RyZWFtLm1hdGNoKC8oUnx1OFJ8dVJ8VVJ8TFIpLykpIHtcbiAgICAgIHZhciBtYXRjaCA9IHN0cmVhbS5tYXRjaCgvXCIoLnswLDE2fSlcXCgvKTtcbiAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgc3RhdGUuY3BwMTFSYXdTdHJpbmdEZWxpbSA9IG1hdGNoWzFdO1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlblJhd1N0cmluZztcbiAgICAgIHJldHVybiB0b2tlblJhd1N0cmluZyhzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gICAgLy8gVW5pY29kZSBzdHJpbmdzL2NoYXJzLlxuICAgIGlmIChzdHJlYW0ubWF0Y2goLyh1OHx1fFV8TCkvKSkge1xuICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvW1wiJ10vLCAvKiBlYXQgKi8gZmFsc2UpKSB7XG4gICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBJZ25vcmUgdGhpcyBob29rLlxuICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gQyMtc3R5bGUgc3RyaW5ncyB3aGVyZSBcIlwiIGVzY2FwZXMgYSBxdW90ZS5cbiAgZnVuY3Rpb24gdG9rZW5BdFN0cmluZyhzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIG5leHQ7XG4gICAgd2hpbGUgKChuZXh0ID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgaWYgKG5leHQgPT0gJ1wiJyAmJiAhc3RyZWFtLmVhdCgnXCInKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgfVxuXG4gIC8vIEMrKzExIHJhdyBzdHJpbmcgbGl0ZXJhbCBpcyA8cHJlZml4PlwiPGRlbGltPiggYW55dGhpbmcgKTxkZWxpbT5cIiwgd2hlcmVcbiAgLy8gPGRlbGltPiBjYW4gYmUgYSBzdHJpbmcgdXAgdG8gMTYgY2hhcmFjdGVycyBsb25nLlxuICBmdW5jdGlvbiB0b2tlblJhd1N0cmluZyhzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGNsb3NpbmdTZXF1ZW5jZSA9IG5ldyBSZWdFeHAoXCIuKj9cXFxcKVwiICsgc3RhdGUuY3BwMTFSYXdTdHJpbmdEZWxpbSArICdcIicpO1xuICAgIHZhciBtYXRjaCA9IHN0cmVhbS5tYXRjaChjbG9zaW5nU2VxdWVuY2UpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgfVxuICAgIHJldHVybiBcInN0cmluZ1wiO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVmKG1pbWVzLCBtb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBtaW1lcyA9PSBcInN0cmluZ1wiKSBtaW1lcyA9IFttaW1lc107XG4gICAgdmFyIHdvcmRzID0gW107XG4gICAgZnVuY3Rpb24gYWRkKG9iaikge1xuICAgICAgaWYgKG9iaikgZm9yICh2YXIgcHJvcCBpbiBvYmopIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkpXG4gICAgICAgIHdvcmRzLnB1c2gocHJvcCk7XG4gICAgfVxuICAgIGFkZChtb2RlLmtleXdvcmRzKTtcbiAgICBhZGQobW9kZS5idWlsdGluKTtcbiAgICBhZGQobW9kZS5hdG9tcyk7XG4gICAgaWYgKHdvcmRzLmxlbmd0aCkge1xuICAgICAgbW9kZS5oZWxwZXJUeXBlID0gbWltZXNbMF07XG4gICAgICBDb2RlTWlycm9yLnJlZ2lzdGVySGVscGVyKFwiaGludFdvcmRzXCIsIG1pbWVzWzBdLCB3b3Jkcyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW1lcy5sZW5ndGg7ICsraSlcbiAgICAgIENvZGVNaXJyb3IuZGVmaW5lTUlNRShtaW1lc1tpXSwgbW9kZSk7XG4gIH1cblxuICBkZWYoW1widGV4dC94LWNzcmNcIiwgXCJ0ZXh0L3gtY1wiLCBcInRleHQveC1jaGRyXCJdLCB7XG4gICAgbmFtZTogXCJjbGlrZVwiLFxuICAgIGtleXdvcmRzOiB3b3JkcyhjS2V5d29yZHMpLFxuICAgIGJsb2NrS2V5d29yZHM6IHdvcmRzKFwiY2FzZSBkbyBlbHNlIGZvciBpZiBzd2l0Y2ggd2hpbGUgc3RydWN0XCIpLFxuICAgIGF0b21zOiB3b3JkcyhcIm51bGxcIiksXG4gICAgaG9va3M6IHtcIiNcIjogY3BwSG9va30sXG4gICAgbW9kZVByb3BzOiB7Zm9sZDogW1wiYnJhY2VcIiwgXCJpbmNsdWRlXCJdfVxuICB9KTtcblxuICBkZWYoW1widGV4dC94LWMrK3NyY1wiLCBcInRleHQveC1jKytoZHJcIl0sIHtcbiAgICBuYW1lOiBcImNsaWtlXCIsXG4gICAga2V5d29yZHM6IHdvcmRzKGNLZXl3b3JkcyArIFwiIGFzbSBkeW5hbWljX2Nhc3QgbmFtZXNwYWNlIHJlaW50ZXJwcmV0X2Nhc3QgdHJ5IGJvb2wgZXhwbGljaXQgbmV3IFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJzdGF0aWNfY2FzdCB0eXBlaWQgY2F0Y2ggb3BlcmF0b3IgdGVtcGxhdGUgdHlwZW5hbWUgY2xhc3MgZnJpZW5kIHByaXZhdGUgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcInRoaXMgdXNpbmcgY29uc3RfY2FzdCBpbmxpbmUgcHVibGljIHRocm93IHZpcnR1YWwgZGVsZXRlIG11dGFibGUgcHJvdGVjdGVkIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJ3Y2hhcl90IGFsaWduYXMgYWxpZ25vZiBjb25zdGV4cHIgZGVjbHR5cGUgbnVsbHB0ciBub2V4Y2VwdCB0aHJlYWRfbG9jYWwgZmluYWwgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcInN0YXRpY19hc3NlcnQgb3ZlcnJpZGVcIiksXG4gICAgYmxvY2tLZXl3b3Jkczogd29yZHMoXCJjYXRjaCBjbGFzcyBkbyBlbHNlIGZpbmFsbHkgZm9yIGlmIHN0cnVjdCBzd2l0Y2ggdHJ5IHdoaWxlXCIpLFxuICAgIGF0b21zOiB3b3JkcyhcInRydWUgZmFsc2UgbnVsbFwiKSxcbiAgICBob29rczoge1xuICAgICAgXCIjXCI6IGNwcEhvb2ssXG4gICAgICBcInVcIjogY3BwMTFTdHJpbmdIb29rLFxuICAgICAgXCJVXCI6IGNwcDExU3RyaW5nSG9vayxcbiAgICAgIFwiTFwiOiBjcHAxMVN0cmluZ0hvb2ssXG4gICAgICBcIlJcIjogY3BwMTFTdHJpbmdIb29rXG4gICAgfSxcbiAgICBtb2RlUHJvcHM6IHtmb2xkOiBbXCJicmFjZVwiLCBcImluY2x1ZGVcIl19XG4gIH0pO1xuICBkZWYoXCJ0ZXh0L3gtamF2YVwiLCB7XG4gICAgbmFtZTogXCJjbGlrZVwiLFxuICAgIGtleXdvcmRzOiB3b3JkcyhcImFic3RyYWN0IGFzc2VydCBib29sZWFuIGJyZWFrIGJ5dGUgY2FzZSBjYXRjaCBjaGFyIGNsYXNzIGNvbnN0IGNvbnRpbnVlIGRlZmF1bHQgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcImRvIGRvdWJsZSBlbHNlIGVudW0gZXh0ZW5kcyBmaW5hbCBmaW5hbGx5IGZsb2F0IGZvciBnb3RvIGlmIGltcGxlbWVudHMgaW1wb3J0IFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJpbnN0YW5jZW9mIGludCBpbnRlcmZhY2UgbG9uZyBuYXRpdmUgbmV3IHBhY2thZ2UgcHJpdmF0ZSBwcm90ZWN0ZWQgcHVibGljIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJyZXR1cm4gc2hvcnQgc3RhdGljIHN0cmljdGZwIHN1cGVyIHN3aXRjaCBzeW5jaHJvbml6ZWQgdGhpcyB0aHJvdyB0aHJvd3MgdHJhbnNpZW50IFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJ0cnkgdm9pZCB2b2xhdGlsZSB3aGlsZVwiKSxcbiAgICBibG9ja0tleXdvcmRzOiB3b3JkcyhcImNhdGNoIGNsYXNzIGRvIGVsc2UgZmluYWxseSBmb3IgaWYgc3dpdGNoIHRyeSB3aGlsZVwiKSxcbiAgICBhdG9tczogd29yZHMoXCJ0cnVlIGZhbHNlIG51bGxcIiksXG4gICAgaG9va3M6IHtcbiAgICAgIFwiQFwiOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwkX10vKTtcbiAgICAgICAgcmV0dXJuIFwibWV0YVwiO1xuICAgICAgfVxuICAgIH0sXG4gICAgbW9kZVByb3BzOiB7Zm9sZDogW1wiYnJhY2VcIiwgXCJpbXBvcnRcIl19XG4gIH0pO1xuICBkZWYoXCJ0ZXh0L3gtY3NoYXJwXCIsIHtcbiAgICBuYW1lOiBcImNsaWtlXCIsXG4gICAga2V5d29yZHM6IHdvcmRzKFwiYWJzdHJhY3QgYXMgYmFzZSBicmVhayBjYXNlIGNhdGNoIGNoZWNrZWQgY2xhc3MgY29uc3QgY29udGludWVcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiIGRlZmF1bHQgZGVsZWdhdGUgZG8gZWxzZSBlbnVtIGV2ZW50IGV4cGxpY2l0IGV4dGVybiBmaW5hbGx5IGZpeGVkIGZvclwiICtcbiAgICAgICAgICAgICAgICAgICAgXCIgZm9yZWFjaCBnb3RvIGlmIGltcGxpY2l0IGluIGludGVyZmFjZSBpbnRlcm5hbCBpcyBsb2NrIG5hbWVzcGFjZSBuZXdcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiIG9wZXJhdG9yIG91dCBvdmVycmlkZSBwYXJhbXMgcHJpdmF0ZSBwcm90ZWN0ZWQgcHVibGljIHJlYWRvbmx5IHJlZiByZXR1cm4gc2VhbGVkXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIiBzaXplb2Ygc3RhY2thbGxvYyBzdGF0aWMgc3RydWN0IHN3aXRjaCB0aGlzIHRocm93IHRyeSB0eXBlb2YgdW5jaGVja2VkXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIiB1bnNhZmUgdXNpbmcgdmlydHVhbCB2b2lkIHZvbGF0aWxlIHdoaWxlIGFkZCBhbGlhcyBhc2NlbmRpbmcgZGVzY2VuZGluZyBkeW5hbWljIGZyb20gZ2V0XCIgK1xuICAgICAgICAgICAgICAgICAgICBcIiBnbG9iYWwgZ3JvdXAgaW50byBqb2luIGxldCBvcmRlcmJ5IHBhcnRpYWwgcmVtb3ZlIHNlbGVjdCBzZXQgdmFsdWUgdmFyIHlpZWxkXCIpLFxuICAgIGJsb2NrS2V5d29yZHM6IHdvcmRzKFwiY2F0Y2ggY2xhc3MgZG8gZWxzZSBmaW5hbGx5IGZvciBmb3JlYWNoIGlmIHN0cnVjdCBzd2l0Y2ggdHJ5IHdoaWxlXCIpLFxuICAgIGJ1aWx0aW46IHdvcmRzKFwiQm9vbGVhbiBCeXRlIENoYXIgRGF0ZVRpbWUgRGF0ZVRpbWVPZmZzZXQgRGVjaW1hbCBEb3VibGVcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiIEd1aWQgSW50MTYgSW50MzIgSW50NjQgT2JqZWN0IFNCeXRlIFNpbmdsZSBTdHJpbmcgVGltZVNwYW4gVUludDE2IFVJbnQzMlwiICtcbiAgICAgICAgICAgICAgICAgICAgXCIgVUludDY0IGJvb2wgYnl0ZSBjaGFyIGRlY2ltYWwgZG91YmxlIHNob3J0IGludCBsb25nIG9iamVjdFwiICArXG4gICAgICAgICAgICAgICAgICAgIFwiIHNieXRlIGZsb2F0IHN0cmluZyB1c2hvcnQgdWludCB1bG9uZ1wiKSxcbiAgICBhdG9tczogd29yZHMoXCJ0cnVlIGZhbHNlIG51bGxcIiksXG4gICAgaG9va3M6IHtcbiAgICAgIFwiQFwiOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIGlmIChzdHJlYW0uZWF0KCdcIicpKSB7XG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkF0U3RyaW5nO1xuICAgICAgICAgIHJldHVybiB0b2tlbkF0U3RyaW5nKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcJF9dLyk7XG4gICAgICAgIHJldHVybiBcIm1ldGFcIjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBkZWYoXCJ0ZXh0L3gtc2NhbGFcIiwge1xuICAgIG5hbWU6IFwiY2xpa2VcIixcbiAgICBrZXl3b3Jkczogd29yZHMoXG5cbiAgICAgIC8qIHNjYWxhICovXG4gICAgICBcImFic3RyYWN0IGNhc2UgY2F0Y2ggY2xhc3MgZGVmIGRvIGVsc2UgZXh0ZW5kcyBmYWxzZSBmaW5hbCBmaW5hbGx5IGZvciBmb3JTb21lIGlmIFwiICtcbiAgICAgIFwiaW1wbGljaXQgaW1wb3J0IGxhenkgbWF0Y2ggbmV3IG51bGwgb2JqZWN0IG92ZXJyaWRlIHBhY2thZ2UgcHJpdmF0ZSBwcm90ZWN0ZWQgcmV0dXJuIFwiICtcbiAgICAgIFwic2VhbGVkIHN1cGVyIHRoaXMgdGhyb3cgdHJhaXQgdHJ5IHRyeWUgdHlwZSB2YWwgdmFyIHdoaWxlIHdpdGggeWllbGQgXyA6ID0gPT4gPC0gPDogXCIgK1xuICAgICAgXCI8JSA+OiAjIEAgXCIgK1xuXG4gICAgICAvKiBwYWNrYWdlIHNjYWxhICovXG4gICAgICBcImFzc2VydCBhc3N1bWUgcmVxdWlyZSBwcmludCBwcmludGxuIHByaW50ZiByZWFkTGluZSByZWFkQm9vbGVhbiByZWFkQnl0ZSByZWFkU2hvcnQgXCIgK1xuICAgICAgXCJyZWFkQ2hhciByZWFkSW50IHJlYWRMb25nIHJlYWRGbG9hdCByZWFkRG91YmxlIFwiICtcblxuICAgICAgXCJBbnlWYWwgQXBwIEFwcGxpY2F0aW9uIEFycmF5IEJ1ZmZlcmVkSXRlcmF0b3IgQmlnRGVjaW1hbCBCaWdJbnQgQ2hhciBDb25zb2xlIEVpdGhlciBcIiArXG4gICAgICBcIkVudW1lcmF0aW9uIEVxdWl2IEVycm9yIEV4Y2VwdGlvbiBGcmFjdGlvbmFsIEZ1bmN0aW9uIEluZGV4ZWRTZXEgSW50ZWdyYWwgSXRlcmFibGUgXCIgK1xuICAgICAgXCJJdGVyYXRvciBMaXN0IE1hcCBOdW1lcmljIE5pbCBOb3ROdWxsIE9wdGlvbiBPcmRlcmVkIE9yZGVyaW5nIFBhcnRpYWxGdW5jdGlvbiBQYXJ0aWFsT3JkZXJpbmcgXCIgK1xuICAgICAgXCJQcm9kdWN0IFByb3h5IFJhbmdlIFJlc3BvbmRlciBTZXEgU2VyaWFsaXphYmxlIFNldCBTcGVjaWFsaXphYmxlIFN0cmVhbSBTdHJpbmdCdWlsZGVyIFwiICtcbiAgICAgIFwiU3RyaW5nQ29udGV4dCBTeW1ib2wgVGhyb3dhYmxlIFRyYXZlcnNhYmxlIFRyYXZlcnNhYmxlT25jZSBUdXBsZSBVbml0IFZlY3RvciA6OiAjOjogXCIgK1xuXG4gICAgICAvKiBwYWNrYWdlIGphdmEubGFuZyAqL1xuICAgICAgXCJCb29sZWFuIEJ5dGUgQ2hhcmFjdGVyIENoYXJTZXF1ZW5jZSBDbGFzcyBDbGFzc0xvYWRlciBDbG9uZWFibGUgQ29tcGFyYWJsZSBcIiArXG4gICAgICBcIkNvbXBpbGVyIERvdWJsZSBFeGNlcHRpb24gRmxvYXQgSW50ZWdlciBMb25nIE1hdGggTnVtYmVyIE9iamVjdCBQYWNrYWdlIFBhaXIgUHJvY2VzcyBcIiArXG4gICAgICBcIlJ1bnRpbWUgUnVubmFibGUgU2VjdXJpdHlNYW5hZ2VyIFNob3J0IFN0YWNrVHJhY2VFbGVtZW50IFN0cmljdE1hdGggU3RyaW5nIFwiICtcbiAgICAgIFwiU3RyaW5nQnVmZmVyIFN5c3RlbSBUaHJlYWQgVGhyZWFkR3JvdXAgVGhyZWFkTG9jYWwgVGhyb3dhYmxlIFRyaXBsZSBWb2lkXCJcblxuXG4gICAgKSxcbiAgICBibG9ja0tleXdvcmRzOiB3b3JkcyhcImNhdGNoIGNsYXNzIGRvIGVsc2UgZmluYWxseSBmb3IgZm9yU29tZSBpZiBtYXRjaCBzd2l0Y2ggdHJ5IHdoaWxlXCIpLFxuICAgIGF0b21zOiB3b3JkcyhcInRydWUgZmFsc2UgbnVsbFwiKSxcbiAgICBob29rczoge1xuICAgICAgXCJAXCI6IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXCRfXS8pO1xuICAgICAgICByZXR1cm4gXCJtZXRhXCI7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgZGVmKFtcIngtc2hhZGVyL3gtdmVydGV4XCIsIFwieC1zaGFkZXIveC1mcmFnbWVudFwiXSwge1xuICAgIG5hbWU6IFwiY2xpa2VcIixcbiAgICBrZXl3b3Jkczogd29yZHMoXCJmbG9hdCBpbnQgYm9vbCB2b2lkIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJ2ZWMyIHZlYzMgdmVjNCBpdmVjMiBpdmVjMyBpdmVjNCBidmVjMiBidmVjMyBidmVjNCBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwibWF0MiBtYXQzIG1hdDQgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcInNhbXBsZXIxRCBzYW1wbGVyMkQgc2FtcGxlcjNEIHNhbXBsZXJDdWJlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJzYW1wbGVyMURTaGFkb3cgc2FtcGxlcjJEU2hhZG93XCIgK1xuICAgICAgICAgICAgICAgICAgICBcImNvbnN0IGF0dHJpYnV0ZSB1bmlmb3JtIHZhcnlpbmcgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcImJyZWFrIGNvbnRpbnVlIGRpc2NhcmQgcmV0dXJuIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJmb3Igd2hpbGUgZG8gaWYgZWxzZSBzdHJ1Y3QgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcImluIG91dCBpbm91dFwiKSxcbiAgICBibG9ja0tleXdvcmRzOiB3b3JkcyhcImZvciB3aGlsZSBkbyBpZiBlbHNlIHN0cnVjdFwiKSxcbiAgICBidWlsdGluOiB3b3JkcyhcInJhZGlhbnMgZGVncmVlcyBzaW4gY29zIHRhbiBhc2luIGFjb3MgYXRhbiBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwicG93IGV4cCBsb2cgZXhwMiBzcXJ0IGludmVyc2VzcXJ0IFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJhYnMgc2lnbiBmbG9vciBjZWlsIGZyYWN0IG1vZCBtaW4gbWF4IGNsYW1wIG1peCBzdGVwIHNtb290c3RlcCBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwibGVuZ3RoIGRpc3RhbmNlIGRvdCBjcm9zcyBub3JtYWxpemUgZnRyYW5zZm9ybSBmYWNlZm9yd2FyZCBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwicmVmbGVjdCByZWZyYWN0IG1hdHJpeENvbXBNdWx0IFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJsZXNzVGhhbiBsZXNzVGhhbkVxdWFsIGdyZWF0ZXJUaGFuIGdyZWF0ZXJUaGFuRXF1YWwgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcImVxdWFsIG5vdEVxdWFsIGFueSBhbGwgbm90IFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0dXJlMUQgdGV4dHVyZTFEUHJvaiB0ZXh0dXJlMURMb2QgdGV4dHVyZTFEUHJvakxvZCBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dHVyZTJEIHRleHR1cmUyRFByb2ogdGV4dHVyZTJETG9kIHRleHR1cmUyRFByb2pMb2QgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcInRleHR1cmUzRCB0ZXh0dXJlM0RQcm9qIHRleHR1cmUzRExvZCB0ZXh0dXJlM0RQcm9qTG9kIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0dXJlQ3ViZSB0ZXh0dXJlQ3ViZUxvZCBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwic2hhZG93MUQgc2hhZG93MkQgc2hhZG93MURQcm9qIHNoYWRvdzJEUHJvaiBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwic2hhZG93MURMb2Qgc2hhZG93MkRMb2Qgc2hhZG93MURQcm9qTG9kIHNoYWRvdzJEUHJvakxvZCBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiZEZkeCBkRmR5IGZ3aWR0aCBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwibm9pc2UxIG5vaXNlMiBub2lzZTMgbm9pc2U0XCIpLFxuICAgIGF0b21zOiB3b3JkcyhcInRydWUgZmFsc2UgXCIgK1xuICAgICAgICAgICAgICAgIFwiZ2xfRnJhZ0NvbG9yIGdsX1NlY29uZGFyeUNvbG9yIGdsX05vcm1hbCBnbF9WZXJ0ZXggXCIgK1xuICAgICAgICAgICAgICAgIFwiZ2xfTXVsdGlUZXhDb29yZDAgZ2xfTXVsdGlUZXhDb29yZDEgZ2xfTXVsdGlUZXhDb29yZDIgZ2xfTXVsdGlUZXhDb29yZDMgXCIgK1xuICAgICAgICAgICAgICAgIFwiZ2xfTXVsdGlUZXhDb29yZDQgZ2xfTXVsdGlUZXhDb29yZDUgZ2xfTXVsdGlUZXhDb29yZDYgZ2xfTXVsdGlUZXhDb29yZDcgXCIgK1xuICAgICAgICAgICAgICAgIFwiZ2xfRm9nQ29vcmQgXCIgK1xuICAgICAgICAgICAgICAgIFwiZ2xfUG9zaXRpb24gZ2xfUG9pbnRTaXplIGdsX0NsaXBWZXJ0ZXggXCIgK1xuICAgICAgICAgICAgICAgIFwiZ2xfRnJvbnRDb2xvciBnbF9CYWNrQ29sb3IgZ2xfRnJvbnRTZWNvbmRhcnlDb2xvciBnbF9CYWNrU2Vjb25kYXJ5Q29sb3IgXCIgK1xuICAgICAgICAgICAgICAgIFwiZ2xfVGV4Q29vcmQgZ2xfRm9nRnJhZ0Nvb3JkIFwiICtcbiAgICAgICAgICAgICAgICBcImdsX0ZyYWdDb29yZCBnbF9Gcm9udEZhY2luZyBcIiArXG4gICAgICAgICAgICAgICAgXCJnbF9GcmFnQ29sb3IgZ2xfRnJhZ0RhdGEgZ2xfRnJhZ0RlcHRoIFwiICtcbiAgICAgICAgICAgICAgICBcImdsX01vZGVsVmlld01hdHJpeCBnbF9Qcm9qZWN0aW9uTWF0cml4IGdsX01vZGVsVmlld1Byb2plY3Rpb25NYXRyaXggXCIgK1xuICAgICAgICAgICAgICAgIFwiZ2xfVGV4dHVyZU1hdHJpeCBnbF9Ob3JtYWxNYXRyaXggZ2xfTW9kZWxWaWV3TWF0cml4SW52ZXJzZSBcIiArXG4gICAgICAgICAgICAgICAgXCJnbF9Qcm9qZWN0aW9uTWF0cml4SW52ZXJzZSBnbF9Nb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4SW52ZXJzZSBcIiArXG4gICAgICAgICAgICAgICAgXCJnbF9UZXh1cmVNYXRyaXhUcmFuc3Bvc2UgZ2xfTW9kZWxWaWV3TWF0cml4SW52ZXJzZVRyYW5zcG9zZSBcIiArXG4gICAgICAgICAgICAgICAgXCJnbF9Qcm9qZWN0aW9uTWF0cml4SW52ZXJzZVRyYW5zcG9zZSBcIiArXG4gICAgICAgICAgICAgICAgXCJnbF9Nb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4SW52ZXJzZVRyYW5zcG9zZSBcIiArXG4gICAgICAgICAgICAgICAgXCJnbF9UZXh0dXJlTWF0cml4SW52ZXJzZVRyYW5zcG9zZSBcIiArXG4gICAgICAgICAgICAgICAgXCJnbF9Ob3JtYWxTY2FsZSBnbF9EZXB0aFJhbmdlIGdsX0NsaXBQbGFuZSBcIiArXG4gICAgICAgICAgICAgICAgXCJnbF9Qb2ludCBnbF9Gcm9udE1hdGVyaWFsIGdsX0JhY2tNYXRlcmlhbCBnbF9MaWdodFNvdXJjZSBnbF9MaWdodE1vZGVsIFwiICtcbiAgICAgICAgICAgICAgICBcImdsX0Zyb250TGlnaHRNb2RlbFByb2R1Y3QgZ2xfQmFja0xpZ2h0TW9kZWxQcm9kdWN0IFwiICtcbiAgICAgICAgICAgICAgICBcImdsX1RleHR1cmVDb2xvciBnbF9FeWVQbGFuZVMgZ2xfRXllUGxhbmVUIGdsX0V5ZVBsYW5lUiBnbF9FeWVQbGFuZVEgXCIgK1xuICAgICAgICAgICAgICAgIFwiZ2xfRm9nUGFyYW1ldGVycyBcIiArXG4gICAgICAgICAgICAgICAgXCJnbF9NYXhMaWdodHMgZ2xfTWF4Q2xpcFBsYW5lcyBnbF9NYXhUZXh0dXJlVW5pdHMgZ2xfTWF4VGV4dHVyZUNvb3JkcyBcIiArXG4gICAgICAgICAgICAgICAgXCJnbF9NYXhWZXJ0ZXhBdHRyaWJzIGdsX01heFZlcnRleFVuaWZvcm1Db21wb25lbnRzIGdsX01heFZhcnlpbmdGbG9hdHMgXCIgK1xuICAgICAgICAgICAgICAgIFwiZ2xfTWF4VmVydGV4VGV4dHVyZUltYWdlVW5pdHMgZ2xfTWF4VGV4dHVyZUltYWdlVW5pdHMgXCIgK1xuICAgICAgICAgICAgICAgIFwiZ2xfTWF4RnJhZ21lbnRVbmlmb3JtQ29tcG9uZW50cyBnbF9NYXhDb21iaW5lVGV4dHVyZUltYWdlVW5pdHMgXCIgK1xuICAgICAgICAgICAgICAgIFwiZ2xfTWF4RHJhd0J1ZmZlcnNcIiksXG4gICAgaG9va3M6IHtcIiNcIjogY3BwSG9va30sXG4gICAgbW9kZVByb3BzOiB7Zm9sZDogW1wiYnJhY2VcIiwgXCJpbmNsdWRlXCJdfVxuICB9KTtcblxufSk7XG4iLCIoZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTW9kZShcImNzc1wiLCBmdW5jdGlvbihjb25maWcsIHBhcnNlckNvbmZpZykge1xuICBpZiAoIXBhcnNlckNvbmZpZy5wcm9wZXJ0eUtleXdvcmRzKSBwYXJzZXJDb25maWcgPSBDb2RlTWlycm9yLnJlc29sdmVNb2RlKFwidGV4dC9jc3NcIik7XG5cbiAgdmFyIGluZGVudFVuaXQgPSBjb25maWcuaW5kZW50VW5pdCxcbiAgICAgIHRva2VuSG9va3MgPSBwYXJzZXJDb25maWcudG9rZW5Ib29rcyxcbiAgICAgIG1lZGlhVHlwZXMgPSBwYXJzZXJDb25maWcubWVkaWFUeXBlcyB8fCB7fSxcbiAgICAgIG1lZGlhRmVhdHVyZXMgPSBwYXJzZXJDb25maWcubWVkaWFGZWF0dXJlcyB8fCB7fSxcbiAgICAgIHByb3BlcnR5S2V5d29yZHMgPSBwYXJzZXJDb25maWcucHJvcGVydHlLZXl3b3JkcyB8fCB7fSxcbiAgICAgIG5vblN0YW5kYXJkUHJvcGVydHlLZXl3b3JkcyA9IHBhcnNlckNvbmZpZy5ub25TdGFuZGFyZFByb3BlcnR5S2V5d29yZHMgfHwge30sXG4gICAgICBjb2xvcktleXdvcmRzID0gcGFyc2VyQ29uZmlnLmNvbG9yS2V5d29yZHMgfHwge30sXG4gICAgICB2YWx1ZUtleXdvcmRzID0gcGFyc2VyQ29uZmlnLnZhbHVlS2V5d29yZHMgfHwge30sXG4gICAgICBmb250UHJvcGVydGllcyA9IHBhcnNlckNvbmZpZy5mb250UHJvcGVydGllcyB8fCB7fSxcbiAgICAgIGFsbG93TmVzdGVkID0gcGFyc2VyQ29uZmlnLmFsbG93TmVzdGVkO1xuXG4gIHZhciB0eXBlLCBvdmVycmlkZTtcbiAgZnVuY3Rpb24gcmV0KHN0eWxlLCB0cCkgeyB0eXBlID0gdHA7IHJldHVybiBzdHlsZTsgfVxuXG4gIC8vIFRva2VuaXplcnNcblxuICBmdW5jdGlvbiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG4gICAgaWYgKHRva2VuSG9va3NbY2hdKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdG9rZW5Ib29rc1tjaF0oc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBpZiAocmVzdWx0ICE9PSBmYWxzZSkgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKGNoID09IFwiQFwiKSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXFxcXFwtXS8pO1xuICAgICAgcmV0dXJuIHJldChcImRlZlwiLCBzdHJlYW0uY3VycmVudCgpKTtcbiAgICB9IGVsc2UgaWYgKGNoID09IFwiPVwiIHx8IChjaCA9PSBcIn5cIiB8fCBjaCA9PSBcInxcIikgJiYgc3RyZWFtLmVhdChcIj1cIikpIHtcbiAgICAgIHJldHVybiByZXQobnVsbCwgXCJjb21wYXJlXCIpO1xuICAgIH0gZWxzZSBpZiAoY2ggPT0gXCJcXFwiXCIgfHwgY2ggPT0gXCInXCIpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5TdHJpbmcoY2gpO1xuICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSBpZiAoY2ggPT0gXCIjXCIpIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcXFxcXC1dLyk7XG4gICAgICByZXR1cm4gcmV0KFwiYXRvbVwiLCBcImhhc2hcIik7XG4gICAgfSBlbHNlIGlmIChjaCA9PSBcIiFcIikge1xuICAgICAgc3RyZWFtLm1hdGNoKC9eXFxzKlxcdyovKTtcbiAgICAgIHJldHVybiByZXQoXCJrZXl3b3JkXCIsIFwiaW1wb3J0YW50XCIpO1xuICAgIH0gZWxzZSBpZiAoL1xcZC8udGVzdChjaCkgfHwgY2ggPT0gXCIuXCIgJiYgc3RyZWFtLmVhdCgvXFxkLykpIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcdy4lXS8pO1xuICAgICAgcmV0dXJuIHJldChcIm51bWJlclwiLCBcInVuaXRcIik7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gXCItXCIpIHtcbiAgICAgIGlmICgvW1xcZC5dLy50ZXN0KHN0cmVhbS5wZWVrKCkpKSB7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcdy4lXS8pO1xuICAgICAgICByZXR1cm4gcmV0KFwibnVtYmVyXCIsIFwidW5pdFwiKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKC9eW14tXSstLykpIHtcbiAgICAgICAgcmV0dXJuIHJldChcIm1ldGFcIiwgXCJtZXRhXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoL1ssKz4qXFwvXS8udGVzdChjaCkpIHtcbiAgICAgIHJldHVybiByZXQobnVsbCwgXCJzZWxlY3Qtb3BcIik7XG4gICAgfSBlbHNlIGlmIChjaCA9PSBcIi5cIiAmJiBzdHJlYW0ubWF0Y2goL14tP1tfYS16XVtfYS16MC05LV0qL2kpKSB7XG4gICAgICByZXR1cm4gcmV0KFwicXVhbGlmaWVyXCIsIFwicXVhbGlmaWVyXCIpO1xuICAgIH0gZWxzZSBpZiAoL1s6O3t9XFxbXFxdXFwoXFwpXS8udGVzdChjaCkpIHtcbiAgICAgIHJldHVybiByZXQobnVsbCwgY2gpO1xuICAgIH0gZWxzZSBpZiAoY2ggPT0gXCJ1XCIgJiYgc3RyZWFtLm1hdGNoKFwicmwoXCIpKSB7XG4gICAgICBzdHJlYW0uYmFja1VwKDEpO1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlblBhcmVudGhlc2l6ZWQ7XG4gICAgICByZXR1cm4gcmV0KFwicHJvcGVydHlcIiwgXCJ3b3JkXCIpO1xuICAgIH0gZWxzZSBpZiAoL1tcXHdcXFxcXFwtXS8udGVzdChjaCkpIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcXFxcXC1dLyk7XG4gICAgICByZXR1cm4gcmV0KFwicHJvcGVydHlcIiwgXCJ3b3JkXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmV0KG51bGwsIG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuU3RyaW5nKHF1b3RlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciBlc2NhcGVkID0gZmFsc2UsIGNoO1xuICAgICAgd2hpbGUgKChjaCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGNoID09IHF1b3RlICYmICFlc2NhcGVkKSB7XG4gICAgICAgICAgaWYgKHF1b3RlID09IFwiKVwiKSBzdHJlYW0uYmFja1VwKDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZCAmJiBjaCA9PSBcIlxcXFxcIjtcbiAgICAgIH1cbiAgICAgIGlmIChjaCA9PSBxdW90ZSB8fCAhZXNjYXBlZCAmJiBxdW90ZSAhPSBcIilcIikgc3RhdGUudG9rZW5pemUgPSBudWxsO1xuICAgICAgcmV0dXJuIHJldChcInN0cmluZ1wiLCBcInN0cmluZ1wiKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5QYXJlbnRoZXNpemVkKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBzdHJlYW0ubmV4dCgpOyAvLyBNdXN0IGJlICcoJ1xuICAgIGlmICghc3RyZWFtLm1hdGNoKC9cXHMqW1xcXCJcXCcpXS8sIGZhbHNlKSlcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5TdHJpbmcoXCIpXCIpO1xuICAgIGVsc2VcbiAgICAgIHN0YXRlLnRva2VuaXplID0gbnVsbDtcbiAgICByZXR1cm4gcmV0KG51bGwsIFwiKFwiKTtcbiAgfVxuXG4gIC8vIENvbnRleHQgbWFuYWdlbWVudFxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHlwZSwgaW5kZW50LCBwcmV2KSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmluZGVudCA9IGluZGVudDtcbiAgICB0aGlzLnByZXYgPSBwcmV2O1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgdHlwZSkge1xuICAgIHN0YXRlLmNvbnRleHQgPSBuZXcgQ29udGV4dCh0eXBlLCBzdHJlYW0uaW5kZW50YXRpb24oKSArIGluZGVudFVuaXQsIHN0YXRlLmNvbnRleHQpO1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wQ29udGV4dChzdGF0ZSkge1xuICAgIHN0YXRlLmNvbnRleHQgPSBzdGF0ZS5jb250ZXh0LnByZXY7XG4gICAgcmV0dXJuIHN0YXRlLmNvbnRleHQudHlwZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhc3ModHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZXNbc3RhdGUuY29udGV4dC50eXBlXSh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiBwb3BBbmRQYXNzKHR5cGUsIHN0cmVhbSwgc3RhdGUsIG4pIHtcbiAgICBmb3IgKHZhciBpID0gbiB8fCAxOyBpID4gMDsgaS0tKVxuICAgICAgc3RhdGUuY29udGV4dCA9IHN0YXRlLmNvbnRleHQucHJldjtcbiAgICByZXR1cm4gcGFzcyh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxuXG4gIC8vIFBhcnNlclxuXG4gIGZ1bmN0aW9uIHdvcmRBc1ZhbHVlKHN0cmVhbSkge1xuICAgIHZhciB3b3JkID0gc3RyZWFtLmN1cnJlbnQoKS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICh2YWx1ZUtleXdvcmRzLmhhc093blByb3BlcnR5KHdvcmQpKVxuICAgICAgb3ZlcnJpZGUgPSBcImF0b21cIjtcbiAgICBlbHNlIGlmIChjb2xvcktleXdvcmRzLmhhc093blByb3BlcnR5KHdvcmQpKVxuICAgICAgb3ZlcnJpZGUgPSBcImtleXdvcmRcIjtcbiAgICBlbHNlXG4gICAgICBvdmVycmlkZSA9IFwidmFyaWFibGVcIjtcbiAgfVxuXG4gIHZhciBzdGF0ZXMgPSB7fTtcblxuICBzdGF0ZXMudG9wID0gZnVuY3Rpb24odHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmICh0eXBlID09IFwie1wiKSB7XG4gICAgICByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJibG9ja1wiKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJ9XCIgJiYgc3RhdGUuY29udGV4dC5wcmV2KSB7XG4gICAgICByZXR1cm4gcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09IFwiQG1lZGlhXCIpIHtcbiAgICAgIHJldHVybiBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLCBcIm1lZGlhXCIpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcIkBmb250LWZhY2VcIikge1xuICAgICAgcmV0dXJuIFwiZm9udF9mYWNlX2JlZm9yZVwiO1xuICAgIH0gZWxzZSBpZiAoL15AKC0obW96fG1zfG98d2Via2l0KS0pP2tleWZyYW1lcyQvLnRlc3QodHlwZSkpIHtcbiAgICAgIHJldHVybiBcImtleWZyYW1lc1wiO1xuICAgIH0gZWxzZSBpZiAodHlwZSAmJiB0eXBlLmNoYXJBdCgwKSA9PSBcIkBcIikge1xuICAgICAgcmV0dXJuIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0sIFwiYXRcIik7XG4gICAgfSBlbHNlIGlmICh0eXBlID09IFwiaGFzaFwiKSB7XG4gICAgICBvdmVycmlkZSA9IFwiYnVpbHRpblwiO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcIndvcmRcIikge1xuICAgICAgb3ZlcnJpZGUgPSBcInRhZ1wiO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcInZhcmlhYmxlLWRlZmluaXRpb25cIikge1xuICAgICAgcmV0dXJuIFwibWF5YmVwcm9wXCI7XG4gICAgfSBlbHNlIGlmICh0eXBlID09IFwiaW50ZXJwb2xhdGlvblwiKSB7XG4gICAgICByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJpbnRlcnBvbGF0aW9uXCIpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcIjpcIikge1xuICAgICAgcmV0dXJuIFwicHNldWRvXCI7XG4gICAgfSBlbHNlIGlmIChhbGxvd05lc3RlZCAmJiB0eXBlID09IFwiKFwiKSB7XG4gICAgICByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJwYXJhbXNcIik7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5jb250ZXh0LnR5cGU7XG4gIH07XG5cbiAgc3RhdGVzLmJsb2NrID0gZnVuY3Rpb24odHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmICh0eXBlID09IFwid29yZFwiKSB7XG4gICAgICB2YXIgd29yZCA9IHN0cmVhbS5jdXJyZW50KCkudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChwcm9wZXJ0eUtleXdvcmRzLmhhc093blByb3BlcnR5KHdvcmQpKSB7XG4gICAgICAgIG92ZXJyaWRlID0gXCJwcm9wZXJ0eVwiO1xuICAgICAgICByZXR1cm4gXCJtYXliZXByb3BcIjtcbiAgICAgIH0gZWxzZSBpZiAobm9uU3RhbmRhcmRQcm9wZXJ0eUtleXdvcmRzLmhhc093blByb3BlcnR5KHdvcmQpKSB7XG4gICAgICAgIG92ZXJyaWRlID0gXCJzdHJpbmctMlwiO1xuICAgICAgICByZXR1cm4gXCJtYXliZXByb3BcIjtcbiAgICAgIH0gZWxzZSBpZiAoYWxsb3dOZXN0ZWQpIHtcbiAgICAgICAgb3ZlcnJpZGUgPSBzdHJlYW0ubWF0Y2goL15cXHMqOi8sIGZhbHNlKSA/IFwicHJvcGVydHlcIiA6IFwidGFnXCI7XG4gICAgICAgIHJldHVybiBcImJsb2NrXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdmVycmlkZSArPSBcIiBlcnJvclwiO1xuICAgICAgICByZXR1cm4gXCJtYXliZXByb3BcIjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJtZXRhXCIpIHtcbiAgICAgIHJldHVybiBcImJsb2NrXCI7XG4gICAgfSBlbHNlIGlmICghYWxsb3dOZXN0ZWQgJiYgKHR5cGUgPT0gXCJoYXNoXCIgfHwgdHlwZSA9PSBcInF1YWxpZmllclwiKSkge1xuICAgICAgb3ZlcnJpZGUgPSBcImVycm9yXCI7XG4gICAgICByZXR1cm4gXCJibG9ja1wiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3RhdGVzLnRvcCh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH07XG5cbiAgc3RhdGVzLm1heWJlcHJvcCA9IGZ1bmN0aW9uKHR5cGUsIHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAodHlwZSA9PSBcIjpcIikgcmV0dXJuIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0sIFwicHJvcFwiKTtcbiAgICByZXR1cm4gcGFzcyh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcbiAgfTtcblxuICBzdGF0ZXMucHJvcCA9IGZ1bmN0aW9uKHR5cGUsIHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAodHlwZSA9PSBcIjtcIikgcmV0dXJuIHBvcENvbnRleHQoc3RhdGUpO1xuICAgIGlmICh0eXBlID09IFwie1wiICYmIGFsbG93TmVzdGVkKSByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJwcm9wQmxvY2tcIik7XG4gICAgaWYgKHR5cGUgPT0gXCJ9XCIgfHwgdHlwZSA9PSBcIntcIikgcmV0dXJuIHBvcEFuZFBhc3ModHlwZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKHR5cGUgPT0gXCIoXCIpIHJldHVybiBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLCBcInBhcmVuc1wiKTtcblxuICAgIGlmICh0eXBlID09IFwiaGFzaFwiICYmICEvXiMoWzAtOWEtZkEtZl17M318WzAtOWEtZkEtZl17Nn0pJC8udGVzdChzdHJlYW0uY3VycmVudCgpKSkge1xuICAgICAgb3ZlcnJpZGUgKz0gXCIgZXJyb3JcIjtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJ3b3JkXCIpIHtcbiAgICAgIHdvcmRBc1ZhbHVlKHN0cmVhbSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09IFwiaW50ZXJwb2xhdGlvblwiKSB7XG4gICAgICByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJpbnRlcnBvbGF0aW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gXCJwcm9wXCI7XG4gIH07XG5cbiAgc3RhdGVzLnByb3BCbG9jayA9IGZ1bmN0aW9uKHR5cGUsIF9zdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJ9XCIpIHJldHVybiBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICBpZiAodHlwZSA9PSBcIndvcmRcIikgeyBvdmVycmlkZSA9IFwicHJvcGVydHlcIjsgcmV0dXJuIFwibWF5YmVwcm9wXCI7IH1cbiAgICByZXR1cm4gc3RhdGUuY29udGV4dC50eXBlO1xuICB9O1xuXG4gIHN0YXRlcy5wYXJlbnMgPSBmdW5jdGlvbih0eXBlLCBzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJ7XCIgfHwgdHlwZSA9PSBcIn1cIikgcmV0dXJuIHBvcEFuZFBhc3ModHlwZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKHR5cGUgPT0gXCIpXCIpIHJldHVybiBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICByZXR1cm4gXCJwYXJlbnNcIjtcbiAgfTtcblxuICBzdGF0ZXMucHNldWRvID0gZnVuY3Rpb24odHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmICh0eXBlID09IFwid29yZFwiKSB7XG4gICAgICBvdmVycmlkZSA9IFwidmFyaWFibGUtM1wiO1xuICAgICAgcmV0dXJuIHN0YXRlLmNvbnRleHQudHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIHBhc3ModHlwZSwgc3RyZWFtLCBzdGF0ZSk7XG4gIH07XG5cbiAgc3RhdGVzLm1lZGlhID0gZnVuY3Rpb24odHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmICh0eXBlID09IFwiKFwiKSByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJtZWRpYV9wYXJlbnNcIik7XG4gICAgaWYgKHR5cGUgPT0gXCJ9XCIpIHJldHVybiBwb3BBbmRQYXNzKHR5cGUsIHN0cmVhbSwgc3RhdGUpO1xuICAgIGlmICh0eXBlID09IFwie1wiKSByZXR1cm4gcG9wQ29udGV4dChzdGF0ZSkgJiYgcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgYWxsb3dOZXN0ZWQgPyBcImJsb2NrXCIgOiBcInRvcFwiKTtcblxuICAgIGlmICh0eXBlID09IFwid29yZFwiKSB7XG4gICAgICB2YXIgd29yZCA9IHN0cmVhbS5jdXJyZW50KCkudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICh3b3JkID09IFwib25seVwiIHx8IHdvcmQgPT0gXCJub3RcIiB8fCB3b3JkID09IFwiYW5kXCIpXG4gICAgICAgIG92ZXJyaWRlID0gXCJrZXl3b3JkXCI7XG4gICAgICBlbHNlIGlmIChtZWRpYVR5cGVzLmhhc093blByb3BlcnR5KHdvcmQpKVxuICAgICAgICBvdmVycmlkZSA9IFwiYXR0cmlidXRlXCI7XG4gICAgICBlbHNlIGlmIChtZWRpYUZlYXR1cmVzLmhhc093blByb3BlcnR5KHdvcmQpKVxuICAgICAgICBvdmVycmlkZSA9IFwicHJvcGVydHlcIjtcbiAgICAgIGVsc2VcbiAgICAgICAgb3ZlcnJpZGUgPSBcImVycm9yXCI7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5jb250ZXh0LnR5cGU7XG4gIH07XG5cbiAgc3RhdGVzLm1lZGlhX3BhcmVucyA9IGZ1bmN0aW9uKHR5cGUsIHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAodHlwZSA9PSBcIilcIikgcmV0dXJuIHBvcENvbnRleHQoc3RhdGUpO1xuICAgIGlmICh0eXBlID09IFwie1wiIHx8IHR5cGUgPT0gXCJ9XCIpIHJldHVybiBwb3BBbmRQYXNzKHR5cGUsIHN0cmVhbSwgc3RhdGUsIDIpO1xuICAgIHJldHVybiBzdGF0ZXMubWVkaWEodHlwZSwgc3RyZWFtLCBzdGF0ZSk7XG4gIH07XG5cbiAgc3RhdGVzLmZvbnRfZmFjZV9iZWZvcmUgPSBmdW5jdGlvbih0eXBlLCBzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJ7XCIpXG4gICAgICByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJmb250X2ZhY2VcIik7XG4gICAgcmV0dXJuIHBhc3ModHlwZSwgc3RyZWFtLCBzdGF0ZSk7XG4gIH07XG5cbiAgc3RhdGVzLmZvbnRfZmFjZSA9IGZ1bmN0aW9uKHR5cGUsIHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAodHlwZSA9PSBcIn1cIikgcmV0dXJuIHBvcENvbnRleHQoc3RhdGUpO1xuICAgIGlmICh0eXBlID09IFwid29yZFwiKSB7XG4gICAgICBpZiAoIWZvbnRQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHN0cmVhbS5jdXJyZW50KCkudG9Mb3dlckNhc2UoKSkpXG4gICAgICAgIG92ZXJyaWRlID0gXCJlcnJvclwiO1xuICAgICAgZWxzZVxuICAgICAgICBvdmVycmlkZSA9IFwicHJvcGVydHlcIjtcbiAgICAgIHJldHVybiBcIm1heWJlcHJvcFwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJmb250X2ZhY2VcIjtcbiAgfTtcblxuICBzdGF0ZXMua2V5ZnJhbWVzID0gZnVuY3Rpb24odHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmICh0eXBlID09IFwid29yZFwiKSB7IG92ZXJyaWRlID0gXCJ2YXJpYWJsZVwiOyByZXR1cm4gXCJrZXlmcmFtZXNcIjsgfVxuICAgIGlmICh0eXBlID09IFwie1wiKSByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJ0b3BcIik7XG4gICAgcmV0dXJuIHBhc3ModHlwZSwgc3RyZWFtLCBzdGF0ZSk7XG4gIH07XG5cbiAgc3RhdGVzLmF0ID0gZnVuY3Rpb24odHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmICh0eXBlID09IFwiO1wiKSByZXR1cm4gcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgaWYgKHR5cGUgPT0gXCJ7XCIgfHwgdHlwZSA9PSBcIn1cIikgcmV0dXJuIHBvcEFuZFBhc3ModHlwZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKHR5cGUgPT0gXCJ3b3JkXCIpIG92ZXJyaWRlID0gXCJ0YWdcIjtcbiAgICBlbHNlIGlmICh0eXBlID09IFwiaGFzaFwiKSBvdmVycmlkZSA9IFwiYnVpbHRpblwiO1xuICAgIHJldHVybiBcImF0XCI7XG4gIH07XG5cbiAgc3RhdGVzLmludGVycG9sYXRpb24gPSBmdW5jdGlvbih0eXBlLCBzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJ9XCIpIHJldHVybiBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICBpZiAodHlwZSA9PSBcIntcIiB8fCB0eXBlID09IFwiO1wiKSByZXR1cm4gcG9wQW5kUGFzcyh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICBpZiAodHlwZSAhPSBcInZhcmlhYmxlXCIpIG92ZXJyaWRlID0gXCJlcnJvclwiO1xuICAgIHJldHVybiBcImludGVycG9sYXRpb25cIjtcbiAgfTtcblxuICBzdGF0ZXMucGFyYW1zID0gZnVuY3Rpb24odHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmICh0eXBlID09IFwiKVwiKSByZXR1cm4gcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgaWYgKHR5cGUgPT0gXCJ7XCIgfHwgdHlwZSA9PSBcIn1cIikgcmV0dXJuIHBvcEFuZFBhc3ModHlwZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKHR5cGUgPT0gXCJ3b3JkXCIpIHdvcmRBc1ZhbHVlKHN0cmVhbSk7XG4gICAgcmV0dXJuIFwicGFyYW1zXCI7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydFN0YXRlOiBmdW5jdGlvbihiYXNlKSB7XG4gICAgICByZXR1cm4ge3Rva2VuaXplOiBudWxsLFxuICAgICAgICAgICAgICBzdGF0ZTogXCJ0b3BcIixcbiAgICAgICAgICAgICAgY29udGV4dDogbmV3IENvbnRleHQoXCJ0b3BcIiwgYmFzZSB8fCAwLCBudWxsKX07XG4gICAgfSxcblxuICAgIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBpZiAoIXN0YXRlLnRva2VuaXplICYmIHN0cmVhbS5lYXRTcGFjZSgpKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBzdHlsZSA9IChzdGF0ZS50b2tlbml6ZSB8fCB0b2tlbkJhc2UpKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgaWYgKHN0eWxlICYmIHR5cGVvZiBzdHlsZSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHR5cGUgPSBzdHlsZVsxXTtcbiAgICAgICAgc3R5bGUgPSBzdHlsZVswXTtcbiAgICAgIH1cbiAgICAgIG92ZXJyaWRlID0gc3R5bGU7XG4gICAgICBzdGF0ZS5zdGF0ZSA9IHN0YXRlc1tzdGF0ZS5zdGF0ZV0odHlwZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgICByZXR1cm4gb3ZlcnJpZGU7XG4gICAgfSxcblxuICAgIGluZGVudDogZnVuY3Rpb24oc3RhdGUsIHRleHRBZnRlcikge1xuICAgICAgdmFyIGN4ID0gc3RhdGUuY29udGV4dCwgY2ggPSB0ZXh0QWZ0ZXIgJiYgdGV4dEFmdGVyLmNoYXJBdCgwKTtcbiAgICAgIHZhciBpbmRlbnQgPSBjeC5pbmRlbnQ7XG4gICAgICBpZiAoY3gudHlwZSA9PSBcInByb3BcIiAmJiBjaCA9PSBcIn1cIikgY3ggPSBjeC5wcmV2O1xuICAgICAgaWYgKGN4LnByZXYgJiZcbiAgICAgICAgICAoY2ggPT0gXCJ9XCIgJiYgKGN4LnR5cGUgPT0gXCJibG9ja1wiIHx8IGN4LnR5cGUgPT0gXCJ0b3BcIiB8fCBjeC50eXBlID09IFwiaW50ZXJwb2xhdGlvblwiIHx8IGN4LnR5cGUgPT0gXCJmb250X2ZhY2VcIikgfHxcbiAgICAgICAgICAgY2ggPT0gXCIpXCIgJiYgKGN4LnR5cGUgPT0gXCJwYXJlbnNcIiB8fCBjeC50eXBlID09IFwicGFyYW1zXCIgfHwgY3gudHlwZSA9PSBcIm1lZGlhX3BhcmVuc1wiKSB8fFxuICAgICAgICAgICBjaCA9PSBcIntcIiAmJiAoY3gudHlwZSA9PSBcImF0XCIgfHwgY3gudHlwZSA9PSBcIm1lZGlhXCIpKSkge1xuICAgICAgICBpbmRlbnQgPSBjeC5pbmRlbnQgLSBpbmRlbnRVbml0O1xuICAgICAgICBjeCA9IGN4LnByZXY7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5kZW50O1xuICAgIH0sXG5cbiAgICBlbGVjdHJpY0NoYXJzOiBcIn1cIixcbiAgICBibG9ja0NvbW1lbnRTdGFydDogXCIvKlwiLFxuICAgIGJsb2NrQ29tbWVudEVuZDogXCIqL1wiLFxuICAgIGZvbGQ6IFwiYnJhY2VcIlxuICB9O1xufSk7XG5cbiAgZnVuY3Rpb24ga2V5U2V0KGFycmF5KSB7XG4gICAgdmFyIGtleXMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICBrZXlzW2FycmF5W2ldXSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xuICB9XG5cbiAgdmFyIG1lZGlhVHlwZXNfID0gW1xuICAgIFwiYWxsXCIsIFwiYXVyYWxcIiwgXCJicmFpbGxlXCIsIFwiaGFuZGhlbGRcIiwgXCJwcmludFwiLCBcInByb2plY3Rpb25cIiwgXCJzY3JlZW5cIixcbiAgICBcInR0eVwiLCBcInR2XCIsIFwiZW1ib3NzZWRcIlxuICBdLCBtZWRpYVR5cGVzID0ga2V5U2V0KG1lZGlhVHlwZXNfKTtcblxuICB2YXIgbWVkaWFGZWF0dXJlc18gPSBbXG4gICAgXCJ3aWR0aFwiLCBcIm1pbi13aWR0aFwiLCBcIm1heC13aWR0aFwiLCBcImhlaWdodFwiLCBcIm1pbi1oZWlnaHRcIiwgXCJtYXgtaGVpZ2h0XCIsXG4gICAgXCJkZXZpY2Utd2lkdGhcIiwgXCJtaW4tZGV2aWNlLXdpZHRoXCIsIFwibWF4LWRldmljZS13aWR0aFwiLCBcImRldmljZS1oZWlnaHRcIixcbiAgICBcIm1pbi1kZXZpY2UtaGVpZ2h0XCIsIFwibWF4LWRldmljZS1oZWlnaHRcIiwgXCJhc3BlY3QtcmF0aW9cIixcbiAgICBcIm1pbi1hc3BlY3QtcmF0aW9cIiwgXCJtYXgtYXNwZWN0LXJhdGlvXCIsIFwiZGV2aWNlLWFzcGVjdC1yYXRpb1wiLFxuICAgIFwibWluLWRldmljZS1hc3BlY3QtcmF0aW9cIiwgXCJtYXgtZGV2aWNlLWFzcGVjdC1yYXRpb1wiLCBcImNvbG9yXCIsIFwibWluLWNvbG9yXCIsXG4gICAgXCJtYXgtY29sb3JcIiwgXCJjb2xvci1pbmRleFwiLCBcIm1pbi1jb2xvci1pbmRleFwiLCBcIm1heC1jb2xvci1pbmRleFwiLFxuICAgIFwibW9ub2Nocm9tZVwiLCBcIm1pbi1tb25vY2hyb21lXCIsIFwibWF4LW1vbm9jaHJvbWVcIiwgXCJyZXNvbHV0aW9uXCIsXG4gICAgXCJtaW4tcmVzb2x1dGlvblwiLCBcIm1heC1yZXNvbHV0aW9uXCIsIFwic2NhblwiLCBcImdyaWRcIlxuICBdLCBtZWRpYUZlYXR1cmVzID0ga2V5U2V0KG1lZGlhRmVhdHVyZXNfKTtcblxuICB2YXIgcHJvcGVydHlLZXl3b3Jkc18gPSBbXG4gICAgXCJhbGlnbi1jb250ZW50XCIsIFwiYWxpZ24taXRlbXNcIiwgXCJhbGlnbi1zZWxmXCIsIFwiYWxpZ25tZW50LWFkanVzdFwiLFxuICAgIFwiYWxpZ25tZW50LWJhc2VsaW5lXCIsIFwiYW5jaG9yLXBvaW50XCIsIFwiYW5pbWF0aW9uXCIsIFwiYW5pbWF0aW9uLWRlbGF5XCIsXG4gICAgXCJhbmltYXRpb24tZGlyZWN0aW9uXCIsIFwiYW5pbWF0aW9uLWR1cmF0aW9uXCIsIFwiYW5pbWF0aW9uLWZpbGwtbW9kZVwiLFxuICAgIFwiYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudFwiLCBcImFuaW1hdGlvbi1uYW1lXCIsIFwiYW5pbWF0aW9uLXBsYXktc3RhdGVcIixcbiAgICBcImFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb25cIiwgXCJhcHBlYXJhbmNlXCIsIFwiYXppbXV0aFwiLCBcImJhY2tmYWNlLXZpc2liaWxpdHlcIixcbiAgICBcImJhY2tncm91bmRcIiwgXCJiYWNrZ3JvdW5kLWF0dGFjaG1lbnRcIiwgXCJiYWNrZ3JvdW5kLWNsaXBcIiwgXCJiYWNrZ3JvdW5kLWNvbG9yXCIsXG4gICAgXCJiYWNrZ3JvdW5kLWltYWdlXCIsIFwiYmFja2dyb3VuZC1vcmlnaW5cIiwgXCJiYWNrZ3JvdW5kLXBvc2l0aW9uXCIsXG4gICAgXCJiYWNrZ3JvdW5kLXJlcGVhdFwiLCBcImJhY2tncm91bmQtc2l6ZVwiLCBcImJhc2VsaW5lLXNoaWZ0XCIsIFwiYmluZGluZ1wiLFxuICAgIFwiYmxlZWRcIiwgXCJib29rbWFyay1sYWJlbFwiLCBcImJvb2ttYXJrLWxldmVsXCIsIFwiYm9va21hcmstc3RhdGVcIixcbiAgICBcImJvb2ttYXJrLXRhcmdldFwiLCBcImJvcmRlclwiLCBcImJvcmRlci1ib3R0b21cIiwgXCJib3JkZXItYm90dG9tLWNvbG9yXCIsXG4gICAgXCJib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzXCIsIFwiYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXNcIixcbiAgICBcImJvcmRlci1ib3R0b20tc3R5bGVcIiwgXCJib3JkZXItYm90dG9tLXdpZHRoXCIsIFwiYm9yZGVyLWNvbGxhcHNlXCIsXG4gICAgXCJib3JkZXItY29sb3JcIiwgXCJib3JkZXItaW1hZ2VcIiwgXCJib3JkZXItaW1hZ2Utb3V0c2V0XCIsXG4gICAgXCJib3JkZXItaW1hZ2UtcmVwZWF0XCIsIFwiYm9yZGVyLWltYWdlLXNsaWNlXCIsIFwiYm9yZGVyLWltYWdlLXNvdXJjZVwiLFxuICAgIFwiYm9yZGVyLWltYWdlLXdpZHRoXCIsIFwiYm9yZGVyLWxlZnRcIiwgXCJib3JkZXItbGVmdC1jb2xvclwiLFxuICAgIFwiYm9yZGVyLWxlZnQtc3R5bGVcIiwgXCJib3JkZXItbGVmdC13aWR0aFwiLCBcImJvcmRlci1yYWRpdXNcIiwgXCJib3JkZXItcmlnaHRcIixcbiAgICBcImJvcmRlci1yaWdodC1jb2xvclwiLCBcImJvcmRlci1yaWdodC1zdHlsZVwiLCBcImJvcmRlci1yaWdodC13aWR0aFwiLFxuICAgIFwiYm9yZGVyLXNwYWNpbmdcIiwgXCJib3JkZXItc3R5bGVcIiwgXCJib3JkZXItdG9wXCIsIFwiYm9yZGVyLXRvcC1jb2xvclwiLFxuICAgIFwiYm9yZGVyLXRvcC1sZWZ0LXJhZGl1c1wiLCBcImJvcmRlci10b3AtcmlnaHQtcmFkaXVzXCIsIFwiYm9yZGVyLXRvcC1zdHlsZVwiLFxuICAgIFwiYm9yZGVyLXRvcC13aWR0aFwiLCBcImJvcmRlci13aWR0aFwiLCBcImJvdHRvbVwiLCBcImJveC1kZWNvcmF0aW9uLWJyZWFrXCIsXG4gICAgXCJib3gtc2hhZG93XCIsIFwiYm94LXNpemluZ1wiLCBcImJyZWFrLWFmdGVyXCIsIFwiYnJlYWstYmVmb3JlXCIsIFwiYnJlYWstaW5zaWRlXCIsXG4gICAgXCJjYXB0aW9uLXNpZGVcIiwgXCJjbGVhclwiLCBcImNsaXBcIiwgXCJjb2xvclwiLCBcImNvbG9yLXByb2ZpbGVcIiwgXCJjb2x1bW4tY291bnRcIixcbiAgICBcImNvbHVtbi1maWxsXCIsIFwiY29sdW1uLWdhcFwiLCBcImNvbHVtbi1ydWxlXCIsIFwiY29sdW1uLXJ1bGUtY29sb3JcIixcbiAgICBcImNvbHVtbi1ydWxlLXN0eWxlXCIsIFwiY29sdW1uLXJ1bGUtd2lkdGhcIiwgXCJjb2x1bW4tc3BhblwiLCBcImNvbHVtbi13aWR0aFwiLFxuICAgIFwiY29sdW1uc1wiLCBcImNvbnRlbnRcIiwgXCJjb3VudGVyLWluY3JlbWVudFwiLCBcImNvdW50ZXItcmVzZXRcIiwgXCJjcm9wXCIsIFwiY3VlXCIsXG4gICAgXCJjdWUtYWZ0ZXJcIiwgXCJjdWUtYmVmb3JlXCIsIFwiY3Vyc29yXCIsIFwiZGlyZWN0aW9uXCIsIFwiZGlzcGxheVwiLFxuICAgIFwiZG9taW5hbnQtYmFzZWxpbmVcIiwgXCJkcm9wLWluaXRpYWwtYWZ0ZXItYWRqdXN0XCIsXG4gICAgXCJkcm9wLWluaXRpYWwtYWZ0ZXItYWxpZ25cIiwgXCJkcm9wLWluaXRpYWwtYmVmb3JlLWFkanVzdFwiLFxuICAgIFwiZHJvcC1pbml0aWFsLWJlZm9yZS1hbGlnblwiLCBcImRyb3AtaW5pdGlhbC1zaXplXCIsIFwiZHJvcC1pbml0aWFsLXZhbHVlXCIsXG4gICAgXCJlbGV2YXRpb25cIiwgXCJlbXB0eS1jZWxsc1wiLCBcImZpdFwiLCBcImZpdC1wb3NpdGlvblwiLCBcImZsZXhcIiwgXCJmbGV4LWJhc2lzXCIsXG4gICAgXCJmbGV4LWRpcmVjdGlvblwiLCBcImZsZXgtZmxvd1wiLCBcImZsZXgtZ3Jvd1wiLCBcImZsZXgtc2hyaW5rXCIsIFwiZmxleC13cmFwXCIsXG4gICAgXCJmbG9hdFwiLCBcImZsb2F0LW9mZnNldFwiLCBcImZsb3ctZnJvbVwiLCBcImZsb3ctaW50b1wiLCBcImZvbnRcIiwgXCJmb250LWZlYXR1cmUtc2V0dGluZ3NcIixcbiAgICBcImZvbnQtZmFtaWx5XCIsIFwiZm9udC1rZXJuaW5nXCIsIFwiZm9udC1sYW5ndWFnZS1vdmVycmlkZVwiLCBcImZvbnQtc2l6ZVwiLCBcImZvbnQtc2l6ZS1hZGp1c3RcIixcbiAgICBcImZvbnQtc3RyZXRjaFwiLCBcImZvbnQtc3R5bGVcIiwgXCJmb250LXN5bnRoZXNpc1wiLCBcImZvbnQtdmFyaWFudFwiLFxuICAgIFwiZm9udC12YXJpYW50LWFsdGVybmF0ZXNcIiwgXCJmb250LXZhcmlhbnQtY2Fwc1wiLCBcImZvbnQtdmFyaWFudC1lYXN0LWFzaWFuXCIsXG4gICAgXCJmb250LXZhcmlhbnQtbGlnYXR1cmVzXCIsIFwiZm9udC12YXJpYW50LW51bWVyaWNcIiwgXCJmb250LXZhcmlhbnQtcG9zaXRpb25cIixcbiAgICBcImZvbnQtd2VpZ2h0XCIsIFwiZ3JpZFwiLCBcImdyaWQtYXJlYVwiLCBcImdyaWQtYXV0by1jb2x1bW5zXCIsIFwiZ3JpZC1hdXRvLWZsb3dcIixcbiAgICBcImdyaWQtYXV0by1wb3NpdGlvblwiLCBcImdyaWQtYXV0by1yb3dzXCIsIFwiZ3JpZC1jb2x1bW5cIiwgXCJncmlkLWNvbHVtbi1lbmRcIixcbiAgICBcImdyaWQtY29sdW1uLXN0YXJ0XCIsIFwiZ3JpZC1yb3dcIiwgXCJncmlkLXJvdy1lbmRcIiwgXCJncmlkLXJvdy1zdGFydFwiLFxuICAgIFwiZ3JpZC10ZW1wbGF0ZVwiLCBcImdyaWQtdGVtcGxhdGUtYXJlYXNcIiwgXCJncmlkLXRlbXBsYXRlLWNvbHVtbnNcIixcbiAgICBcImdyaWQtdGVtcGxhdGUtcm93c1wiLCBcImhhbmdpbmctcHVuY3R1YXRpb25cIiwgXCJoZWlnaHRcIiwgXCJoeXBoZW5zXCIsXG4gICAgXCJpY29uXCIsIFwiaW1hZ2Utb3JpZW50YXRpb25cIiwgXCJpbWFnZS1yZW5kZXJpbmdcIiwgXCJpbWFnZS1yZXNvbHV0aW9uXCIsXG4gICAgXCJpbmxpbmUtYm94LWFsaWduXCIsIFwianVzdGlmeS1jb250ZW50XCIsIFwibGVmdFwiLCBcImxldHRlci1zcGFjaW5nXCIsXG4gICAgXCJsaW5lLWJyZWFrXCIsIFwibGluZS1oZWlnaHRcIiwgXCJsaW5lLXN0YWNraW5nXCIsIFwibGluZS1zdGFja2luZy1ydWJ5XCIsXG4gICAgXCJsaW5lLXN0YWNraW5nLXNoaWZ0XCIsIFwibGluZS1zdGFja2luZy1zdHJhdGVneVwiLCBcImxpc3Qtc3R5bGVcIixcbiAgICBcImxpc3Qtc3R5bGUtaW1hZ2VcIiwgXCJsaXN0LXN0eWxlLXBvc2l0aW9uXCIsIFwibGlzdC1zdHlsZS10eXBlXCIsIFwibWFyZ2luXCIsXG4gICAgXCJtYXJnaW4tYm90dG9tXCIsIFwibWFyZ2luLWxlZnRcIiwgXCJtYXJnaW4tcmlnaHRcIiwgXCJtYXJnaW4tdG9wXCIsXG4gICAgXCJtYXJrZXItb2Zmc2V0XCIsIFwibWFya3NcIiwgXCJtYXJxdWVlLWRpcmVjdGlvblwiLCBcIm1hcnF1ZWUtbG9vcFwiLFxuICAgIFwibWFycXVlZS1wbGF5LWNvdW50XCIsIFwibWFycXVlZS1zcGVlZFwiLCBcIm1hcnF1ZWUtc3R5bGVcIiwgXCJtYXgtaGVpZ2h0XCIsXG4gICAgXCJtYXgtd2lkdGhcIiwgXCJtaW4taGVpZ2h0XCIsIFwibWluLXdpZHRoXCIsIFwibW92ZS10b1wiLCBcIm5hdi1kb3duXCIsIFwibmF2LWluZGV4XCIsXG4gICAgXCJuYXYtbGVmdFwiLCBcIm5hdi1yaWdodFwiLCBcIm5hdi11cFwiLCBcIm9wYWNpdHlcIiwgXCJvcmRlclwiLCBcIm9ycGhhbnNcIiwgXCJvdXRsaW5lXCIsXG4gICAgXCJvdXRsaW5lLWNvbG9yXCIsIFwib3V0bGluZS1vZmZzZXRcIiwgXCJvdXRsaW5lLXN0eWxlXCIsIFwib3V0bGluZS13aWR0aFwiLFxuICAgIFwib3ZlcmZsb3dcIiwgXCJvdmVyZmxvdy1zdHlsZVwiLCBcIm92ZXJmbG93LXdyYXBcIiwgXCJvdmVyZmxvdy14XCIsIFwib3ZlcmZsb3cteVwiLFxuICAgIFwicGFkZGluZ1wiLCBcInBhZGRpbmctYm90dG9tXCIsIFwicGFkZGluZy1sZWZ0XCIsIFwicGFkZGluZy1yaWdodFwiLCBcInBhZGRpbmctdG9wXCIsXG4gICAgXCJwYWdlXCIsIFwicGFnZS1icmVhay1hZnRlclwiLCBcInBhZ2UtYnJlYWstYmVmb3JlXCIsIFwicGFnZS1icmVhay1pbnNpZGVcIixcbiAgICBcInBhZ2UtcG9saWN5XCIsIFwicGF1c2VcIiwgXCJwYXVzZS1hZnRlclwiLCBcInBhdXNlLWJlZm9yZVwiLCBcInBlcnNwZWN0aXZlXCIsXG4gICAgXCJwZXJzcGVjdGl2ZS1vcmlnaW5cIiwgXCJwaXRjaFwiLCBcInBpdGNoLXJhbmdlXCIsIFwicGxheS1kdXJpbmdcIiwgXCJwb3NpdGlvblwiLFxuICAgIFwicHJlc2VudGF0aW9uLWxldmVsXCIsIFwicHVuY3R1YXRpb24tdHJpbVwiLCBcInF1b3Rlc1wiLCBcInJlZ2lvbi1icmVhay1hZnRlclwiLFxuICAgIFwicmVnaW9uLWJyZWFrLWJlZm9yZVwiLCBcInJlZ2lvbi1icmVhay1pbnNpZGVcIiwgXCJyZWdpb24tZnJhZ21lbnRcIixcbiAgICBcInJlbmRlcmluZy1pbnRlbnRcIiwgXCJyZXNpemVcIiwgXCJyZXN0XCIsIFwicmVzdC1hZnRlclwiLCBcInJlc3QtYmVmb3JlXCIsIFwicmljaG5lc3NcIixcbiAgICBcInJpZ2h0XCIsIFwicm90YXRpb25cIiwgXCJyb3RhdGlvbi1wb2ludFwiLCBcInJ1YnktYWxpZ25cIiwgXCJydWJ5LW92ZXJoYW5nXCIsXG4gICAgXCJydWJ5LXBvc2l0aW9uXCIsIFwicnVieS1zcGFuXCIsIFwic2hhcGUtaW5zaWRlXCIsIFwic2hhcGUtb3V0c2lkZVwiLCBcInNpemVcIixcbiAgICBcInNwZWFrXCIsIFwic3BlYWstYXNcIiwgXCJzcGVhay1oZWFkZXJcIixcbiAgICBcInNwZWFrLW51bWVyYWxcIiwgXCJzcGVhay1wdW5jdHVhdGlvblwiLCBcInNwZWVjaC1yYXRlXCIsIFwic3RyZXNzXCIsIFwic3RyaW5nLXNldFwiLFxuICAgIFwidGFiLXNpemVcIiwgXCJ0YWJsZS1sYXlvdXRcIiwgXCJ0YXJnZXRcIiwgXCJ0YXJnZXQtbmFtZVwiLCBcInRhcmdldC1uZXdcIixcbiAgICBcInRhcmdldC1wb3NpdGlvblwiLCBcInRleHQtYWxpZ25cIiwgXCJ0ZXh0LWFsaWduLWxhc3RcIiwgXCJ0ZXh0LWRlY29yYXRpb25cIixcbiAgICBcInRleHQtZGVjb3JhdGlvbi1jb2xvclwiLCBcInRleHQtZGVjb3JhdGlvbi1saW5lXCIsIFwidGV4dC1kZWNvcmF0aW9uLXNraXBcIixcbiAgICBcInRleHQtZGVjb3JhdGlvbi1zdHlsZVwiLCBcInRleHQtZW1waGFzaXNcIiwgXCJ0ZXh0LWVtcGhhc2lzLWNvbG9yXCIsXG4gICAgXCJ0ZXh0LWVtcGhhc2lzLXBvc2l0aW9uXCIsIFwidGV4dC1lbXBoYXNpcy1zdHlsZVwiLCBcInRleHQtaGVpZ2h0XCIsXG4gICAgXCJ0ZXh0LWluZGVudFwiLCBcInRleHQtanVzdGlmeVwiLCBcInRleHQtb3V0bGluZVwiLCBcInRleHQtb3ZlcmZsb3dcIiwgXCJ0ZXh0LXNoYWRvd1wiLFxuICAgIFwidGV4dC1zaXplLWFkanVzdFwiLCBcInRleHQtc3BhY2UtY29sbGFwc2VcIiwgXCJ0ZXh0LXRyYW5zZm9ybVwiLCBcInRleHQtdW5kZXJsaW5lLXBvc2l0aW9uXCIsXG4gICAgXCJ0ZXh0LXdyYXBcIiwgXCJ0b3BcIiwgXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2Zvcm0tb3JpZ2luXCIsIFwidHJhbnNmb3JtLXN0eWxlXCIsXG4gICAgXCJ0cmFuc2l0aW9uXCIsIFwidHJhbnNpdGlvbi1kZWxheVwiLCBcInRyYW5zaXRpb24tZHVyYXRpb25cIixcbiAgICBcInRyYW5zaXRpb24tcHJvcGVydHlcIiwgXCJ0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvblwiLCBcInVuaWNvZGUtYmlkaVwiLFxuICAgIFwidmVydGljYWwtYWxpZ25cIiwgXCJ2aXNpYmlsaXR5XCIsIFwidm9pY2UtYmFsYW5jZVwiLCBcInZvaWNlLWR1cmF0aW9uXCIsXG4gICAgXCJ2b2ljZS1mYW1pbHlcIiwgXCJ2b2ljZS1waXRjaFwiLCBcInZvaWNlLXJhbmdlXCIsIFwidm9pY2UtcmF0ZVwiLCBcInZvaWNlLXN0cmVzc1wiLFxuICAgIFwidm9pY2Utdm9sdW1lXCIsIFwidm9sdW1lXCIsIFwid2hpdGUtc3BhY2VcIiwgXCJ3aWRvd3NcIiwgXCJ3aWR0aFwiLCBcIndvcmQtYnJlYWtcIixcbiAgICBcIndvcmQtc3BhY2luZ1wiLCBcIndvcmQtd3JhcFwiLCBcInotaW5kZXhcIixcbiAgICAvLyBTVkctc3BlY2lmaWNcbiAgICBcImNsaXAtcGF0aFwiLCBcImNsaXAtcnVsZVwiLCBcIm1hc2tcIiwgXCJlbmFibGUtYmFja2dyb3VuZFwiLCBcImZpbHRlclwiLCBcImZsb29kLWNvbG9yXCIsXG4gICAgXCJmbG9vZC1vcGFjaXR5XCIsIFwibGlnaHRpbmctY29sb3JcIiwgXCJzdG9wLWNvbG9yXCIsIFwic3RvcC1vcGFjaXR5XCIsIFwicG9pbnRlci1ldmVudHNcIixcbiAgICBcImNvbG9yLWludGVycG9sYXRpb25cIiwgXCJjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnNcIixcbiAgICBcImNvbG9yLXJlbmRlcmluZ1wiLCBcImZpbGxcIiwgXCJmaWxsLW9wYWNpdHlcIiwgXCJmaWxsLXJ1bGVcIiwgXCJpbWFnZS1yZW5kZXJpbmdcIixcbiAgICBcIm1hcmtlclwiLCBcIm1hcmtlci1lbmRcIiwgXCJtYXJrZXItbWlkXCIsIFwibWFya2VyLXN0YXJ0XCIsIFwic2hhcGUtcmVuZGVyaW5nXCIsIFwic3Ryb2tlXCIsXG4gICAgXCJzdHJva2UtZGFzaGFycmF5XCIsIFwic3Ryb2tlLWRhc2hvZmZzZXRcIiwgXCJzdHJva2UtbGluZWNhcFwiLCBcInN0cm9rZS1saW5lam9pblwiLFxuICAgIFwic3Ryb2tlLW1pdGVybGltaXRcIiwgXCJzdHJva2Utb3BhY2l0eVwiLCBcInN0cm9rZS13aWR0aFwiLCBcInRleHQtcmVuZGVyaW5nXCIsXG4gICAgXCJiYXNlbGluZS1zaGlmdFwiLCBcImRvbWluYW50LWJhc2VsaW5lXCIsIFwiZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbFwiLFxuICAgIFwiZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWxcIiwgXCJ0ZXh0LWFuY2hvclwiLCBcIndyaXRpbmctbW9kZVwiXG4gIF0sIHByb3BlcnR5S2V5d29yZHMgPSBrZXlTZXQocHJvcGVydHlLZXl3b3Jkc18pO1xuXG4gIHZhciBub25TdGFuZGFyZFByb3BlcnR5S2V5d29yZHMgPSBbXG4gICAgXCJzY3JvbGxiYXItYXJyb3ctY29sb3JcIiwgXCJzY3JvbGxiYXItYmFzZS1jb2xvclwiLCBcInNjcm9sbGJhci1kYXJrLXNoYWRvdy1jb2xvclwiLFxuICAgIFwic2Nyb2xsYmFyLWZhY2UtY29sb3JcIiwgXCJzY3JvbGxiYXItaGlnaGxpZ2h0LWNvbG9yXCIsIFwic2Nyb2xsYmFyLXNoYWRvdy1jb2xvclwiLFxuICAgIFwic2Nyb2xsYmFyLTNkLWxpZ2h0LWNvbG9yXCIsIFwic2Nyb2xsYmFyLXRyYWNrLWNvbG9yXCIsIFwic2hhcGUtaW5zaWRlXCIsXG4gICAgXCJzZWFyY2hmaWVsZC1jYW5jZWwtYnV0dG9uXCIsIFwic2VhcmNoZmllbGQtZGVjb3JhdGlvblwiLCBcInNlYXJjaGZpZWxkLXJlc3VsdHMtYnV0dG9uXCIsXG4gICAgXCJzZWFyY2hmaWVsZC1yZXN1bHRzLWRlY29yYXRpb25cIiwgXCJ6b29tXCJcbiAgXSwgbm9uU3RhbmRhcmRQcm9wZXJ0eUtleXdvcmRzID0ga2V5U2V0KG5vblN0YW5kYXJkUHJvcGVydHlLZXl3b3Jkcyk7XG5cbiAgdmFyIGNvbG9yS2V5d29yZHNfID0gW1xuICAgIFwiYWxpY2VibHVlXCIsIFwiYW50aXF1ZXdoaXRlXCIsIFwiYXF1YVwiLCBcImFxdWFtYXJpbmVcIiwgXCJhenVyZVwiLCBcImJlaWdlXCIsXG4gICAgXCJiaXNxdWVcIiwgXCJibGFja1wiLCBcImJsYW5jaGVkYWxtb25kXCIsIFwiYmx1ZVwiLCBcImJsdWV2aW9sZXRcIiwgXCJicm93blwiLFxuICAgIFwiYnVybHl3b29kXCIsIFwiY2FkZXRibHVlXCIsIFwiY2hhcnRyZXVzZVwiLCBcImNob2NvbGF0ZVwiLCBcImNvcmFsXCIsIFwiY29ybmZsb3dlcmJsdWVcIixcbiAgICBcImNvcm5zaWxrXCIsIFwiY3JpbXNvblwiLCBcImN5YW5cIiwgXCJkYXJrYmx1ZVwiLCBcImRhcmtjeWFuXCIsIFwiZGFya2dvbGRlbnJvZFwiLFxuICAgIFwiZGFya2dyYXlcIiwgXCJkYXJrZ3JlZW5cIiwgXCJkYXJra2hha2lcIiwgXCJkYXJrbWFnZW50YVwiLCBcImRhcmtvbGl2ZWdyZWVuXCIsXG4gICAgXCJkYXJrb3JhbmdlXCIsIFwiZGFya29yY2hpZFwiLCBcImRhcmtyZWRcIiwgXCJkYXJrc2FsbW9uXCIsIFwiZGFya3NlYWdyZWVuXCIsXG4gICAgXCJkYXJrc2xhdGVibHVlXCIsIFwiZGFya3NsYXRlZ3JheVwiLCBcImRhcmt0dXJxdW9pc2VcIiwgXCJkYXJrdmlvbGV0XCIsXG4gICAgXCJkZWVwcGlua1wiLCBcImRlZXBza3libHVlXCIsIFwiZGltZ3JheVwiLCBcImRvZGdlcmJsdWVcIiwgXCJmaXJlYnJpY2tcIixcbiAgICBcImZsb3JhbHdoaXRlXCIsIFwiZm9yZXN0Z3JlZW5cIiwgXCJmdWNoc2lhXCIsIFwiZ2FpbnNib3JvXCIsIFwiZ2hvc3R3aGl0ZVwiLFxuICAgIFwiZ29sZFwiLCBcImdvbGRlbnJvZFwiLCBcImdyYXlcIiwgXCJncmV5XCIsIFwiZ3JlZW5cIiwgXCJncmVlbnllbGxvd1wiLCBcImhvbmV5ZGV3XCIsXG4gICAgXCJob3RwaW5rXCIsIFwiaW5kaWFucmVkXCIsIFwiaW5kaWdvXCIsIFwiaXZvcnlcIiwgXCJraGFraVwiLCBcImxhdmVuZGVyXCIsXG4gICAgXCJsYXZlbmRlcmJsdXNoXCIsIFwibGF3bmdyZWVuXCIsIFwibGVtb25jaGlmZm9uXCIsIFwibGlnaHRibHVlXCIsIFwibGlnaHRjb3JhbFwiLFxuICAgIFwibGlnaHRjeWFuXCIsIFwibGlnaHRnb2xkZW5yb2R5ZWxsb3dcIiwgXCJsaWdodGdyYXlcIiwgXCJsaWdodGdyZWVuXCIsIFwibGlnaHRwaW5rXCIsXG4gICAgXCJsaWdodHNhbG1vblwiLCBcImxpZ2h0c2VhZ3JlZW5cIiwgXCJsaWdodHNreWJsdWVcIiwgXCJsaWdodHNsYXRlZ3JheVwiLFxuICAgIFwibGlnaHRzdGVlbGJsdWVcIiwgXCJsaWdodHllbGxvd1wiLCBcImxpbWVcIiwgXCJsaW1lZ3JlZW5cIiwgXCJsaW5lblwiLCBcIm1hZ2VudGFcIixcbiAgICBcIm1hcm9vblwiLCBcIm1lZGl1bWFxdWFtYXJpbmVcIiwgXCJtZWRpdW1ibHVlXCIsIFwibWVkaXVtb3JjaGlkXCIsIFwibWVkaXVtcHVycGxlXCIsXG4gICAgXCJtZWRpdW1zZWFncmVlblwiLCBcIm1lZGl1bXNsYXRlYmx1ZVwiLCBcIm1lZGl1bXNwcmluZ2dyZWVuXCIsIFwibWVkaXVtdHVycXVvaXNlXCIsXG4gICAgXCJtZWRpdW12aW9sZXRyZWRcIiwgXCJtaWRuaWdodGJsdWVcIiwgXCJtaW50Y3JlYW1cIiwgXCJtaXN0eXJvc2VcIiwgXCJtb2NjYXNpblwiLFxuICAgIFwibmF2YWpvd2hpdGVcIiwgXCJuYXZ5XCIsIFwib2xkbGFjZVwiLCBcIm9saXZlXCIsIFwib2xpdmVkcmFiXCIsIFwib3JhbmdlXCIsIFwib3JhbmdlcmVkXCIsXG4gICAgXCJvcmNoaWRcIiwgXCJwYWxlZ29sZGVucm9kXCIsIFwicGFsZWdyZWVuXCIsIFwicGFsZXR1cnF1b2lzZVwiLCBcInBhbGV2aW9sZXRyZWRcIixcbiAgICBcInBhcGF5YXdoaXBcIiwgXCJwZWFjaHB1ZmZcIiwgXCJwZXJ1XCIsIFwicGlua1wiLCBcInBsdW1cIiwgXCJwb3dkZXJibHVlXCIsXG4gICAgXCJwdXJwbGVcIiwgXCJyZWRcIiwgXCJyb3N5YnJvd25cIiwgXCJyb3lhbGJsdWVcIiwgXCJzYWRkbGVicm93blwiLCBcInNhbG1vblwiLFxuICAgIFwic2FuZHlicm93blwiLCBcInNlYWdyZWVuXCIsIFwic2Vhc2hlbGxcIiwgXCJzaWVubmFcIiwgXCJzaWx2ZXJcIiwgXCJza3libHVlXCIsXG4gICAgXCJzbGF0ZWJsdWVcIiwgXCJzbGF0ZWdyYXlcIiwgXCJzbm93XCIsIFwic3ByaW5nZ3JlZW5cIiwgXCJzdGVlbGJsdWVcIiwgXCJ0YW5cIixcbiAgICBcInRlYWxcIiwgXCJ0aGlzdGxlXCIsIFwidG9tYXRvXCIsIFwidHVycXVvaXNlXCIsIFwidmlvbGV0XCIsIFwid2hlYXRcIiwgXCJ3aGl0ZVwiLFxuICAgIFwid2hpdGVzbW9rZVwiLCBcInllbGxvd1wiLCBcInllbGxvd2dyZWVuXCJcbiAgXSwgY29sb3JLZXl3b3JkcyA9IGtleVNldChjb2xvcktleXdvcmRzXyk7XG5cbiAgdmFyIHZhbHVlS2V5d29yZHNfID0gW1xuICAgIFwiYWJvdmVcIiwgXCJhYnNvbHV0ZVwiLCBcImFjdGl2ZWJvcmRlclwiLCBcImFjdGl2ZWNhcHRpb25cIiwgXCJhZmFyXCIsXG4gICAgXCJhZnRlci13aGl0ZS1zcGFjZVwiLCBcImFoZWFkXCIsIFwiYWxpYXNcIiwgXCJhbGxcIiwgXCJhbGwtc2Nyb2xsXCIsIFwiYWx0ZXJuYXRlXCIsXG4gICAgXCJhbHdheXNcIiwgXCJhbWhhcmljXCIsIFwiYW1oYXJpYy1hYmVnZWRlXCIsIFwiYW50aWFsaWFzZWRcIiwgXCJhcHB3b3Jrc3BhY2VcIixcbiAgICBcImFyYWJpYy1pbmRpY1wiLCBcImFybWVuaWFuXCIsIFwiYXN0ZXJpc2tzXCIsIFwiYXV0b1wiLCBcImF2b2lkXCIsIFwiYXZvaWQtY29sdW1uXCIsIFwiYXZvaWQtcGFnZVwiLFxuICAgIFwiYXZvaWQtcmVnaW9uXCIsIFwiYmFja2dyb3VuZFwiLCBcImJhY2t3YXJkc1wiLCBcImJhc2VsaW5lXCIsIFwiYmVsb3dcIiwgXCJiaWRpLW92ZXJyaWRlXCIsIFwiYmluYXJ5XCIsXG4gICAgXCJiZW5nYWxpXCIsIFwiYmxpbmtcIiwgXCJibG9ja1wiLCBcImJsb2NrLWF4aXNcIiwgXCJib2xkXCIsIFwiYm9sZGVyXCIsIFwiYm9yZGVyXCIsIFwiYm9yZGVyLWJveFwiLFxuICAgIFwiYm90aFwiLCBcImJvdHRvbVwiLCBcImJyZWFrXCIsIFwiYnJlYWstYWxsXCIsIFwiYnJlYWstd29yZFwiLCBcImJ1dHRvblwiLCBcImJ1dHRvbi1iZXZlbFwiLFxuICAgIFwiYnV0dG9uZmFjZVwiLCBcImJ1dHRvbmhpZ2hsaWdodFwiLCBcImJ1dHRvbnNoYWRvd1wiLCBcImJ1dHRvbnRleHRcIiwgXCJjYW1ib2RpYW5cIixcbiAgICBcImNhcGl0YWxpemVcIiwgXCJjYXBzLWxvY2staW5kaWNhdG9yXCIsIFwiY2FwdGlvblwiLCBcImNhcHRpb250ZXh0XCIsIFwiY2FyZXRcIixcbiAgICBcImNlbGxcIiwgXCJjZW50ZXJcIiwgXCJjaGVja2JveFwiLCBcImNpcmNsZVwiLCBcImNqay1lYXJ0aGx5LWJyYW5jaFwiLFxuICAgIFwiY2prLWhlYXZlbmx5LXN0ZW1cIiwgXCJjamstaWRlb2dyYXBoaWNcIiwgXCJjbGVhclwiLCBcImNsaXBcIiwgXCJjbG9zZS1xdW90ZVwiLFxuICAgIFwiY29sLXJlc2l6ZVwiLCBcImNvbGxhcHNlXCIsIFwiY29sdW1uXCIsIFwiY29tcGFjdFwiLCBcImNvbmRlbnNlZFwiLCBcImNvbnRhaW5cIiwgXCJjb250ZW50XCIsXG4gICAgXCJjb250ZW50LWJveFwiLCBcImNvbnRleHQtbWVudVwiLCBcImNvbnRpbnVvdXNcIiwgXCJjb3B5XCIsIFwiY292ZXJcIiwgXCJjcm9wXCIsXG4gICAgXCJjcm9zc1wiLCBcImNyb3NzaGFpclwiLCBcImN1cnJlbnRjb2xvclwiLCBcImN1cnNpdmVcIiwgXCJkYXNoZWRcIiwgXCJkZWNpbWFsXCIsXG4gICAgXCJkZWNpbWFsLWxlYWRpbmctemVyb1wiLCBcImRlZmF1bHRcIiwgXCJkZWZhdWx0LWJ1dHRvblwiLCBcImRlc3RpbmF0aW9uLWF0b3BcIixcbiAgICBcImRlc3RpbmF0aW9uLWluXCIsIFwiZGVzdGluYXRpb24tb3V0XCIsIFwiZGVzdGluYXRpb24tb3ZlclwiLCBcImRldmFuYWdhcmlcIixcbiAgICBcImRpc2NcIiwgXCJkaXNjYXJkXCIsIFwiZG9jdW1lbnRcIiwgXCJkb3QtZGFzaFwiLCBcImRvdC1kb3QtZGFzaFwiLCBcImRvdHRlZFwiLFxuICAgIFwiZG91YmxlXCIsIFwiZG93blwiLCBcImUtcmVzaXplXCIsIFwiZWFzZVwiLCBcImVhc2UtaW5cIiwgXCJlYXNlLWluLW91dFwiLCBcImVhc2Utb3V0XCIsXG4gICAgXCJlbGVtZW50XCIsIFwiZWxsaXBzZVwiLCBcImVsbGlwc2lzXCIsIFwiZW1iZWRcIiwgXCJlbmRcIiwgXCJldGhpb3BpY1wiLCBcImV0aGlvcGljLWFiZWdlZGVcIixcbiAgICBcImV0aGlvcGljLWFiZWdlZGUtYW0tZXRcIiwgXCJldGhpb3BpYy1hYmVnZWRlLWdlelwiLCBcImV0aGlvcGljLWFiZWdlZGUtdGktZXJcIixcbiAgICBcImV0aGlvcGljLWFiZWdlZGUtdGktZXRcIiwgXCJldGhpb3BpYy1oYWxlaGFtZS1hYS1lclwiLFxuICAgIFwiZXRoaW9waWMtaGFsZWhhbWUtYWEtZXRcIiwgXCJldGhpb3BpYy1oYWxlaGFtZS1hbS1ldFwiLFxuICAgIFwiZXRoaW9waWMtaGFsZWhhbWUtZ2V6XCIsIFwiZXRoaW9waWMtaGFsZWhhbWUtb20tZXRcIixcbiAgICBcImV0aGlvcGljLWhhbGVoYW1lLXNpZC1ldFwiLCBcImV0aGlvcGljLWhhbGVoYW1lLXNvLWV0XCIsXG4gICAgXCJldGhpb3BpYy1oYWxlaGFtZS10aS1lclwiLCBcImV0aGlvcGljLWhhbGVoYW1lLXRpLWV0XCIsXG4gICAgXCJldGhpb3BpYy1oYWxlaGFtZS10aWdcIiwgXCJldy1yZXNpemVcIiwgXCJleHBhbmRlZFwiLCBcImV4dHJhLWNvbmRlbnNlZFwiLFxuICAgIFwiZXh0cmEtZXhwYW5kZWRcIiwgXCJmYW50YXN5XCIsIFwiZmFzdFwiLCBcImZpbGxcIiwgXCJmaXhlZFwiLCBcImZsYXRcIiwgXCJmb290bm90ZXNcIixcbiAgICBcImZvcndhcmRzXCIsIFwiZnJvbVwiLCBcImdlb21ldHJpY1ByZWNpc2lvblwiLCBcImdlb3JnaWFuXCIsIFwiZ3JheXRleHRcIiwgXCJncm9vdmVcIixcbiAgICBcImd1amFyYXRpXCIsIFwiZ3VybXVraGlcIiwgXCJoYW5kXCIsIFwiaGFuZ3VsXCIsIFwiaGFuZ3VsLWNvbnNvbmFudFwiLCBcImhlYnJld1wiLFxuICAgIFwiaGVscFwiLCBcImhpZGRlblwiLCBcImhpZGVcIiwgXCJoaWdoZXJcIiwgXCJoaWdobGlnaHRcIiwgXCJoaWdobGlnaHR0ZXh0XCIsXG4gICAgXCJoaXJhZ2FuYVwiLCBcImhpcmFnYW5hLWlyb2hhXCIsIFwiaG9yaXpvbnRhbFwiLCBcImhzbFwiLCBcImhzbGFcIiwgXCJpY29uXCIsIFwiaWdub3JlXCIsXG4gICAgXCJpbmFjdGl2ZWJvcmRlclwiLCBcImluYWN0aXZlY2FwdGlvblwiLCBcImluYWN0aXZlY2FwdGlvbnRleHRcIiwgXCJpbmZpbml0ZVwiLFxuICAgIFwiaW5mb2JhY2tncm91bmRcIiwgXCJpbmZvdGV4dFwiLCBcImluaGVyaXRcIiwgXCJpbml0aWFsXCIsIFwiaW5saW5lXCIsIFwiaW5saW5lLWF4aXNcIixcbiAgICBcImlubGluZS1ibG9ja1wiLCBcImlubGluZS10YWJsZVwiLCBcImluc2V0XCIsIFwiaW5zaWRlXCIsIFwiaW50cmluc2ljXCIsIFwiaW52ZXJ0XCIsXG4gICAgXCJpdGFsaWNcIiwgXCJqdXN0aWZ5XCIsIFwia2FubmFkYVwiLCBcImthdGFrYW5hXCIsIFwia2F0YWthbmEtaXJvaGFcIiwgXCJrZWVwLWFsbFwiLCBcImtobWVyXCIsXG4gICAgXCJsYW5kc2NhcGVcIiwgXCJsYW9cIiwgXCJsYXJnZVwiLCBcImxhcmdlclwiLCBcImxlZnRcIiwgXCJsZXZlbFwiLCBcImxpZ2h0ZXJcIixcbiAgICBcImxpbmUtdGhyb3VnaFwiLCBcImxpbmVhclwiLCBcImxpbmVzXCIsIFwibGlzdC1pdGVtXCIsIFwibGlzdGJveFwiLCBcImxpc3RpdGVtXCIsXG4gICAgXCJsb2NhbFwiLCBcImxvZ2ljYWxcIiwgXCJsb3VkXCIsIFwibG93ZXJcIiwgXCJsb3dlci1hbHBoYVwiLCBcImxvd2VyLWFybWVuaWFuXCIsXG4gICAgXCJsb3dlci1ncmVla1wiLCBcImxvd2VyLWhleGFkZWNpbWFsXCIsIFwibG93ZXItbGF0aW5cIiwgXCJsb3dlci1ub3J3ZWdpYW5cIixcbiAgICBcImxvd2VyLXJvbWFuXCIsIFwibG93ZXJjYXNlXCIsIFwibHRyXCIsIFwibWFsYXlhbGFtXCIsIFwibWF0Y2hcIixcbiAgICBcIm1lZGlhLWNvbnRyb2xzLWJhY2tncm91bmRcIiwgXCJtZWRpYS1jdXJyZW50LXRpbWUtZGlzcGxheVwiLFxuICAgIFwibWVkaWEtZnVsbHNjcmVlbi1idXR0b25cIiwgXCJtZWRpYS1tdXRlLWJ1dHRvblwiLCBcIm1lZGlhLXBsYXktYnV0dG9uXCIsXG4gICAgXCJtZWRpYS1yZXR1cm4tdG8tcmVhbHRpbWUtYnV0dG9uXCIsIFwibWVkaWEtcmV3aW5kLWJ1dHRvblwiLFxuICAgIFwibWVkaWEtc2Vlay1iYWNrLWJ1dHRvblwiLCBcIm1lZGlhLXNlZWstZm9yd2FyZC1idXR0b25cIiwgXCJtZWRpYS1zbGlkZXJcIixcbiAgICBcIm1lZGlhLXNsaWRlcnRodW1iXCIsIFwibWVkaWEtdGltZS1yZW1haW5pbmctZGlzcGxheVwiLCBcIm1lZGlhLXZvbHVtZS1zbGlkZXJcIixcbiAgICBcIm1lZGlhLXZvbHVtZS1zbGlkZXItY29udGFpbmVyXCIsIFwibWVkaWEtdm9sdW1lLXNsaWRlcnRodW1iXCIsIFwibWVkaXVtXCIsXG4gICAgXCJtZW51XCIsIFwibWVudWxpc3RcIiwgXCJtZW51bGlzdC1idXR0b25cIiwgXCJtZW51bGlzdC10ZXh0XCIsXG4gICAgXCJtZW51bGlzdC10ZXh0ZmllbGRcIiwgXCJtZW51dGV4dFwiLCBcIm1lc3NhZ2UtYm94XCIsIFwibWlkZGxlXCIsIFwibWluLWludHJpbnNpY1wiLFxuICAgIFwibWl4XCIsIFwibW9uZ29saWFuXCIsIFwibW9ub3NwYWNlXCIsIFwibW92ZVwiLCBcIm11bHRpcGxlXCIsIFwibXlhbm1hclwiLCBcIm4tcmVzaXplXCIsXG4gICAgXCJuYXJyb3dlclwiLCBcIm5lLXJlc2l6ZVwiLCBcIm5lc3ctcmVzaXplXCIsIFwibm8tY2xvc2UtcXVvdGVcIiwgXCJuby1kcm9wXCIsXG4gICAgXCJuby1vcGVuLXF1b3RlXCIsIFwibm8tcmVwZWF0XCIsIFwibm9uZVwiLCBcIm5vcm1hbFwiLCBcIm5vdC1hbGxvd2VkXCIsIFwibm93cmFwXCIsXG4gICAgXCJucy1yZXNpemVcIiwgXCJudy1yZXNpemVcIiwgXCJud3NlLXJlc2l6ZVwiLCBcIm9ibGlxdWVcIiwgXCJvY3RhbFwiLCBcIm9wZW4tcXVvdGVcIixcbiAgICBcIm9wdGltaXplTGVnaWJpbGl0eVwiLCBcIm9wdGltaXplU3BlZWRcIiwgXCJvcml5YVwiLCBcIm9yb21vXCIsIFwib3V0c2V0XCIsXG4gICAgXCJvdXRzaWRlXCIsIFwib3V0c2lkZS1zaGFwZVwiLCBcIm92ZXJsYXlcIiwgXCJvdmVybGluZVwiLCBcInBhZGRpbmdcIiwgXCJwYWRkaW5nLWJveFwiLFxuICAgIFwicGFpbnRlZFwiLCBcInBhZ2VcIiwgXCJwYXVzZWRcIiwgXCJwZXJzaWFuXCIsIFwicGx1cy1kYXJrZXJcIiwgXCJwbHVzLWxpZ2h0ZXJcIiwgXCJwb2ludGVyXCIsXG4gICAgXCJwb2x5Z29uXCIsIFwicG9ydHJhaXRcIiwgXCJwcmVcIiwgXCJwcmUtbGluZVwiLCBcInByZS13cmFwXCIsIFwicHJlc2VydmUtM2RcIiwgXCJwcm9ncmVzc1wiLCBcInB1c2gtYnV0dG9uXCIsXG4gICAgXCJyYWRpb1wiLCBcInJlYWQtb25seVwiLCBcInJlYWQtd3JpdGVcIiwgXCJyZWFkLXdyaXRlLXBsYWludGV4dC1vbmx5XCIsIFwicmVjdGFuZ2xlXCIsIFwicmVnaW9uXCIsXG4gICAgXCJyZWxhdGl2ZVwiLCBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgXCJyZXNldFwiLCBcInJldmVyc2VcIiwgXCJyZ2JcIiwgXCJyZ2JhXCIsXG4gICAgXCJyaWRnZVwiLCBcInJpZ2h0XCIsIFwicm91bmRcIiwgXCJyb3ctcmVzaXplXCIsIFwicnRsXCIsIFwicnVuLWluXCIsIFwicnVubmluZ1wiLFxuICAgIFwicy1yZXNpemVcIiwgXCJzYW5zLXNlcmlmXCIsIFwic2Nyb2xsXCIsIFwic2Nyb2xsYmFyXCIsIFwic2UtcmVzaXplXCIsIFwic2VhcmNoZmllbGRcIixcbiAgICBcInNlYXJjaGZpZWxkLWNhbmNlbC1idXR0b25cIiwgXCJzZWFyY2hmaWVsZC1kZWNvcmF0aW9uXCIsXG4gICAgXCJzZWFyY2hmaWVsZC1yZXN1bHRzLWJ1dHRvblwiLCBcInNlYXJjaGZpZWxkLXJlc3VsdHMtZGVjb3JhdGlvblwiLFxuICAgIFwic2VtaS1jb25kZW5zZWRcIiwgXCJzZW1pLWV4cGFuZGVkXCIsIFwic2VwYXJhdGVcIiwgXCJzZXJpZlwiLCBcInNob3dcIiwgXCJzaWRhbWFcIixcbiAgICBcInNpbmdsZVwiLCBcInNraXAtd2hpdGUtc3BhY2VcIiwgXCJzbGlkZVwiLCBcInNsaWRlci1ob3Jpem9udGFsXCIsXG4gICAgXCJzbGlkZXItdmVydGljYWxcIiwgXCJzbGlkZXJ0aHVtYi1ob3Jpem9udGFsXCIsIFwic2xpZGVydGh1bWItdmVydGljYWxcIiwgXCJzbG93XCIsXG4gICAgXCJzbWFsbFwiLCBcInNtYWxsLWNhcHNcIiwgXCJzbWFsbC1jYXB0aW9uXCIsIFwic21hbGxlclwiLCBcInNvbGlkXCIsIFwic29tYWxpXCIsXG4gICAgXCJzb3VyY2UtYXRvcFwiLCBcInNvdXJjZS1pblwiLCBcInNvdXJjZS1vdXRcIiwgXCJzb3VyY2Utb3ZlclwiLCBcInNwYWNlXCIsIFwic3F1YXJlXCIsXG4gICAgXCJzcXVhcmUtYnV0dG9uXCIsIFwic3RhcnRcIiwgXCJzdGF0aWNcIiwgXCJzdGF0dXMtYmFyXCIsIFwic3RyZXRjaFwiLCBcInN0cm9rZVwiLFxuICAgIFwic3ViXCIsIFwic3VicGl4ZWwtYW50aWFsaWFzZWRcIiwgXCJzdXBlclwiLCBcInN3LXJlc2l6ZVwiLCBcInRhYmxlXCIsXG4gICAgXCJ0YWJsZS1jYXB0aW9uXCIsIFwidGFibGUtY2VsbFwiLCBcInRhYmxlLWNvbHVtblwiLCBcInRhYmxlLWNvbHVtbi1ncm91cFwiLFxuICAgIFwidGFibGUtZm9vdGVyLWdyb3VwXCIsIFwidGFibGUtaGVhZGVyLWdyb3VwXCIsIFwidGFibGUtcm93XCIsIFwidGFibGUtcm93LWdyb3VwXCIsXG4gICAgXCJ0ZWx1Z3VcIiwgXCJ0ZXh0XCIsIFwidGV4dC1ib3R0b21cIiwgXCJ0ZXh0LXRvcFwiLCBcInRleHRhcmVhXCIsIFwidGV4dGZpZWxkXCIsIFwidGhhaVwiLFxuICAgIFwidGhpY2tcIiwgXCJ0aGluXCIsIFwidGhyZWVkZGFya3NoYWRvd1wiLCBcInRocmVlZGZhY2VcIiwgXCJ0aHJlZWRoaWdobGlnaHRcIixcbiAgICBcInRocmVlZGxpZ2h0c2hhZG93XCIsIFwidGhyZWVkc2hhZG93XCIsIFwidGliZXRhblwiLCBcInRpZ3JlXCIsIFwidGlncmlueWEtZXJcIixcbiAgICBcInRpZ3JpbnlhLWVyLWFiZWdlZGVcIiwgXCJ0aWdyaW55YS1ldFwiLCBcInRpZ3JpbnlhLWV0LWFiZWdlZGVcIiwgXCJ0b1wiLCBcInRvcFwiLFxuICAgIFwidHJhbnNwYXJlbnRcIiwgXCJ1bHRyYS1jb25kZW5zZWRcIiwgXCJ1bHRyYS1leHBhbmRlZFwiLCBcInVuZGVybGluZVwiLCBcInVwXCIsXG4gICAgXCJ1cHBlci1hbHBoYVwiLCBcInVwcGVyLWFybWVuaWFuXCIsIFwidXBwZXItZ3JlZWtcIiwgXCJ1cHBlci1oZXhhZGVjaW1hbFwiLFxuICAgIFwidXBwZXItbGF0aW5cIiwgXCJ1cHBlci1ub3J3ZWdpYW5cIiwgXCJ1cHBlci1yb21hblwiLCBcInVwcGVyY2FzZVwiLCBcInVyZHVcIiwgXCJ1cmxcIixcbiAgICBcInZlcnRpY2FsXCIsIFwidmVydGljYWwtdGV4dFwiLCBcInZpc2libGVcIiwgXCJ2aXNpYmxlRmlsbFwiLCBcInZpc2libGVQYWludGVkXCIsXG4gICAgXCJ2aXNpYmxlU3Ryb2tlXCIsIFwidmlzdWFsXCIsIFwidy1yZXNpemVcIiwgXCJ3YWl0XCIsIFwid2F2ZVwiLCBcIndpZGVyXCIsXG4gICAgXCJ3aW5kb3dcIiwgXCJ3aW5kb3dmcmFtZVwiLCBcIndpbmRvd3RleHRcIiwgXCJ4LWxhcmdlXCIsIFwieC1zbWFsbFwiLCBcInhvclwiLFxuICAgIFwieHgtbGFyZ2VcIiwgXCJ4eC1zbWFsbFwiXG4gIF0sIHZhbHVlS2V5d29yZHMgPSBrZXlTZXQodmFsdWVLZXl3b3Jkc18pO1xuXG4gIHZhciBmb250UHJvcGVydGllc18gPSBbXG4gICAgXCJmb250LWZhbWlseVwiLCBcInNyY1wiLCBcInVuaWNvZGUtcmFuZ2VcIiwgXCJmb250LXZhcmlhbnRcIiwgXCJmb250LWZlYXR1cmUtc2V0dGluZ3NcIixcbiAgICBcImZvbnQtc3RyZXRjaFwiLCBcImZvbnQtd2VpZ2h0XCIsIFwiZm9udC1zdHlsZVwiXG4gIF0sIGZvbnRQcm9wZXJ0aWVzID0ga2V5U2V0KGZvbnRQcm9wZXJ0aWVzXyk7XG5cbiAgdmFyIGFsbFdvcmRzID0gbWVkaWFUeXBlc18uY29uY2F0KG1lZGlhRmVhdHVyZXNfKS5jb25jYXQocHJvcGVydHlLZXl3b3Jkc18pXG4gICAgLmNvbmNhdChub25TdGFuZGFyZFByb3BlcnR5S2V5d29yZHMpLmNvbmNhdChjb2xvcktleXdvcmRzXykuY29uY2F0KHZhbHVlS2V5d29yZHNfKTtcbiAgQ29kZU1pcnJvci5yZWdpc3RlckhlbHBlcihcImhpbnRXb3Jkc1wiLCBcImNzc1wiLCBhbGxXb3Jkcyk7XG5cbiAgZnVuY3Rpb24gdG9rZW5DQ29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIG1heWJlRW5kID0gZmFsc2UsIGNoO1xuICAgIHdoaWxlICgoY2ggPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICBpZiAobWF5YmVFbmQgJiYgY2ggPT0gXCIvXCIpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG1heWJlRW5kID0gKGNoID09IFwiKlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIFtcImNvbW1lbnRcIiwgXCJjb21tZW50XCJdO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5TR01MQ29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHN0cmVhbS5za2lwVG8oXCItLT5cIikpIHtcbiAgICAgIHN0cmVhbS5tYXRjaChcIi0tPlwiKTtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgIH1cbiAgICByZXR1cm4gW1wiY29tbWVudFwiLCBcImNvbW1lbnRcIl07XG4gIH1cblxuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L2Nzc1wiLCB7XG4gICAgbWVkaWFUeXBlczogbWVkaWFUeXBlcyxcbiAgICBtZWRpYUZlYXR1cmVzOiBtZWRpYUZlYXR1cmVzLFxuICAgIHByb3BlcnR5S2V5d29yZHM6IHByb3BlcnR5S2V5d29yZHMsXG4gICAgbm9uU3RhbmRhcmRQcm9wZXJ0eUtleXdvcmRzOiBub25TdGFuZGFyZFByb3BlcnR5S2V5d29yZHMsXG4gICAgY29sb3JLZXl3b3JkczogY29sb3JLZXl3b3JkcyxcbiAgICB2YWx1ZUtleXdvcmRzOiB2YWx1ZUtleXdvcmRzLFxuICAgIGZvbnRQcm9wZXJ0aWVzOiBmb250UHJvcGVydGllcyxcbiAgICB0b2tlbkhvb2tzOiB7XG4gICAgICBcIjxcIjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgICBpZiAoIXN0cmVhbS5tYXRjaChcIiEtLVwiKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuU0dNTENvbW1lbnQ7XG4gICAgICAgIHJldHVybiB0b2tlblNHTUxDb21tZW50KHN0cmVhbSwgc3RhdGUpO1xuICAgICAgfSxcbiAgICAgIFwiL1wiOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIGlmICghc3RyZWFtLmVhdChcIipcIikpIHJldHVybiBmYWxzZTtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkNDb21tZW50O1xuICAgICAgICByZXR1cm4gdG9rZW5DQ29tbWVudChzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG5hbWU6IFwiY3NzXCJcbiAgfSk7XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94LXNjc3NcIiwge1xuICAgIG1lZGlhVHlwZXM6IG1lZGlhVHlwZXMsXG4gICAgbWVkaWFGZWF0dXJlczogbWVkaWFGZWF0dXJlcyxcbiAgICBwcm9wZXJ0eUtleXdvcmRzOiBwcm9wZXJ0eUtleXdvcmRzLFxuICAgIG5vblN0YW5kYXJkUHJvcGVydHlLZXl3b3Jkczogbm9uU3RhbmRhcmRQcm9wZXJ0eUtleXdvcmRzLFxuICAgIGNvbG9yS2V5d29yZHM6IGNvbG9yS2V5d29yZHMsXG4gICAgdmFsdWVLZXl3b3JkczogdmFsdWVLZXl3b3JkcyxcbiAgICBmb250UHJvcGVydGllczogZm9udFByb3BlcnRpZXMsXG4gICAgYWxsb3dOZXN0ZWQ6IHRydWUsXG4gICAgdG9rZW5Ib29rczoge1xuICAgICAgXCIvXCI6IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgaWYgKHN0cmVhbS5lYXQoXCIvXCIpKSB7XG4gICAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICAgIHJldHVybiBbXCJjb21tZW50XCIsIFwiY29tbWVudFwiXTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0uZWF0KFwiKlwiKSkge1xuICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5DQ29tbWVudDtcbiAgICAgICAgICByZXR1cm4gdG9rZW5DQ29tbWVudChzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gW1wib3BlcmF0b3JcIiwgXCJvcGVyYXRvclwiXTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiOlwiOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXFxzKnsvKSlcbiAgICAgICAgICByZXR1cm4gW251bGwsIFwie1wiXTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIFwiJFwiOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgc3RyZWFtLm1hdGNoKC9eW1xcdy1dKy8pO1xuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eXFxzKjovLCBmYWxzZSkpXG4gICAgICAgICAgcmV0dXJuIFtcInZhcmlhYmxlLTJcIiwgXCJ2YXJpYWJsZS1kZWZpbml0aW9uXCJdO1xuICAgICAgICByZXR1cm4gW1widmFyaWFibGUtMlwiLCBcInZhcmlhYmxlXCJdO1xuICAgICAgfSxcbiAgICAgIFwiI1wiOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgaWYgKCFzdHJlYW0uZWF0KFwie1wiKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gW251bGwsIFwiaW50ZXJwb2xhdGlvblwiXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG5hbWU6IFwiY3NzXCIsXG4gICAgaGVscGVyVHlwZTogXCJzY3NzXCJcbiAgfSk7XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94LWxlc3NcIiwge1xuICAgIG1lZGlhVHlwZXM6IG1lZGlhVHlwZXMsXG4gICAgbWVkaWFGZWF0dXJlczogbWVkaWFGZWF0dXJlcyxcbiAgICBwcm9wZXJ0eUtleXdvcmRzOiBwcm9wZXJ0eUtleXdvcmRzLFxuICAgIG5vblN0YW5kYXJkUHJvcGVydHlLZXl3b3Jkczogbm9uU3RhbmRhcmRQcm9wZXJ0eUtleXdvcmRzLFxuICAgIGNvbG9yS2V5d29yZHM6IGNvbG9yS2V5d29yZHMsXG4gICAgdmFsdWVLZXl3b3JkczogdmFsdWVLZXl3b3JkcyxcbiAgICBmb250UHJvcGVydGllczogZm9udFByb3BlcnRpZXMsXG4gICAgYWxsb3dOZXN0ZWQ6IHRydWUsXG4gICAgdG9rZW5Ib29rczoge1xuICAgICAgXCIvXCI6IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgaWYgKHN0cmVhbS5lYXQoXCIvXCIpKSB7XG4gICAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICAgIHJldHVybiBbXCJjb21tZW50XCIsIFwiY29tbWVudFwiXTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0uZWF0KFwiKlwiKSkge1xuICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5DQ29tbWVudDtcbiAgICAgICAgICByZXR1cm4gdG9rZW5DQ29tbWVudChzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gW1wib3BlcmF0b3JcIiwgXCJvcGVyYXRvclwiXTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiQFwiOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXihjaGFyc2V0fGRvY3VtZW50fGZvbnQtZmFjZXxpbXBvcnR8KC0obW96fG1zfG98d2Via2l0KS0pP2tleWZyYW1lc3xtZWRpYXxuYW1lc3BhY2V8cGFnZXxzdXBwb3J0cylcXGIvLCBmYWxzZSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFxcXFxcLV0vKTtcbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXlxccyo6LywgZmFsc2UpKVxuICAgICAgICAgIHJldHVybiBbXCJ2YXJpYWJsZS0yXCIsIFwidmFyaWFibGUtZGVmaW5pdGlvblwiXTtcbiAgICAgICAgcmV0dXJuIFtcInZhcmlhYmxlLTJcIiwgXCJ2YXJpYWJsZVwiXTtcbiAgICAgIH0sXG4gICAgICBcIiZcIjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbXCJhdG9tXCIsIFwiYXRvbVwiXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG5hbWU6IFwiY3NzXCIsXG4gICAgaGVscGVyVHlwZTogXCJsZXNzXCJcbiAgfSk7XG5cbn0pO1xuIiwiKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSwgcmVxdWlyZShcIi4uL21hcmtkb3duL21hcmtkb3duXCIpLCByZXF1aXJlKFwiLi4vLi4vYWRkb24vbW9kZS9vdmVybGF5XCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIsIFwiLi4vbWFya2Rvd24vbWFya2Rvd25cIiwgXCIuLi8uLi9hZGRvbi9tb2RlL292ZXJsYXlcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwiZ2ZtXCIsIGZ1bmN0aW9uKGNvbmZpZywgbW9kZUNvbmZpZykge1xuICB2YXIgY29kZURlcHRoID0gMDtcbiAgZnVuY3Rpb24gYmxhbmtMaW5lKHN0YXRlKSB7XG4gICAgc3RhdGUuY29kZSA9IGZhbHNlO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBnZm1PdmVybGF5ID0ge1xuICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29kZTogZmFsc2UsXG4gICAgICAgIGNvZGVCbG9jazogZmFsc2UsXG4gICAgICAgIGF0ZVNwYWNlOiBmYWxzZVxuICAgICAgfTtcbiAgICB9LFxuICAgIGNvcHlTdGF0ZTogZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29kZTogcy5jb2RlLFxuICAgICAgICBjb2RlQmxvY2s6IHMuY29kZUJsb2NrLFxuICAgICAgICBhdGVTcGFjZTogcy5hdGVTcGFjZVxuICAgICAgfTtcbiAgICB9LFxuICAgIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAvLyBIYWNrIHRvIHByZXZlbnQgZm9ybWF0dGluZyBvdmVycmlkZSBpbnNpZGUgY29kZSBibG9ja3MgKGJsb2NrIGFuZCBpbmxpbmUpXG4gICAgICBpZiAoc3RhdGUuY29kZUJsb2NrKSB7XG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2goL15gYGAvKSkge1xuICAgICAgICAgIHN0YXRlLmNvZGVCbG9jayA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoc3RyZWFtLnNvbCgpKSB7XG4gICAgICAgIHN0YXRlLmNvZGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHJlYW0uc29sKCkgJiYgc3RyZWFtLm1hdGNoKC9eYGBgLykpIHtcbiAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICBzdGF0ZS5jb2RlQmxvY2sgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIC8vIElmIHRoaXMgYmxvY2sgaXMgY2hhbmdlZCwgaXQgbWF5IG5lZWQgdG8gYmUgdXBkYXRlZCBpbiBNYXJrZG93biBtb2RlXG4gICAgICBpZiAoc3RyZWFtLnBlZWsoKSA9PT0gJ2AnKSB7XG4gICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIHZhciBiZWZvcmUgPSBzdHJlYW0ucG9zO1xuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoJ2AnKTtcbiAgICAgICAgdmFyIGRpZmZlcmVuY2UgPSAxICsgc3RyZWFtLnBvcyAtIGJlZm9yZTtcbiAgICAgICAgaWYgKCFzdGF0ZS5jb2RlKSB7XG4gICAgICAgICAgY29kZURlcHRoID0gZGlmZmVyZW5jZTtcbiAgICAgICAgICBzdGF0ZS5jb2RlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZGlmZmVyZW5jZSA9PT0gY29kZURlcHRoKSB7IC8vIE11c3QgYmUgZXhhY3RcbiAgICAgICAgICAgIHN0YXRlLmNvZGUgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmNvZGUpIHtcbiAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICAvLyBDaGVjayBpZiBzcGFjZS4gSWYgc28sIGxpbmtzIGNhbiBiZSBmb3JtYXR0ZWQgbGF0ZXIgb25cbiAgICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkge1xuICAgICAgICBzdGF0ZS5hdGVTcGFjZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHN0cmVhbS5zb2woKSB8fCBzdGF0ZS5hdGVTcGFjZSkge1xuICAgICAgICBzdGF0ZS5hdGVTcGFjZSA9IGZhbHNlO1xuICAgICAgICBpZihzdHJlYW0ubWF0Y2goL14oPzpbYS16QS1aMC05XFwtX10rXFwvKT8oPzpbYS16QS1aMC05XFwtX10rQCk/KD86W2EtZjAtOV17Nyw0MH1cXGIpLykpIHtcbiAgICAgICAgICAvLyBVc2VyL1Byb2plY3RAU0hBXG4gICAgICAgICAgLy8gVXNlckBTSEFcbiAgICAgICAgICAvLyBTSEFcbiAgICAgICAgICByZXR1cm4gXCJsaW5rXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKC9eKD86W2EtekEtWjAtOVxcLV9dK1xcLyk/KD86W2EtekEtWjAtOVxcLV9dKyk/I1swLTldK1xcYi8pKSB7XG4gICAgICAgICAgLy8gVXNlci9Qcm9qZWN0I051bVxuICAgICAgICAgIC8vIFVzZXIjTnVtXG4gICAgICAgICAgLy8gI051bVxuICAgICAgICAgIHJldHVybiBcImxpbmtcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXigoPzpbYS16XVtcXHctXSs6KD86XFwvezEsM318W2EtejAtOSVdKXx3d3dcXGR7MCwzfVsuXXxbYS16MC05LlxcLV0rWy5dW2Etel17Miw0fVxcLykoPzpbXlxccygpPD5dfFxcKFteXFxzKCk8Pl0qXFwpKSsoPzpcXChbXlxccygpPD5dKlxcKXxbXlxcc2AhKClcXFtcXF17fTs6J1wiLiw8Pj/Cq8K74oCc4oCd4oCY4oCZXSkpL2kpICYmXG4gICAgICAgICBzdHJlYW0uc3RyaW5nLnNsaWNlKHN0cmVhbS5zdGFydCAtIDIsIHN0cmVhbS5zdGFydCkgIT0gXCJdKFwiKSB7XG4gICAgICAgIC8vIFVSTHNcbiAgICAgICAgLy8gVGFrZW4gZnJvbSBodHRwOi8vZGFyaW5nZmlyZWJhbGwubmV0LzIwMTAvMDcvaW1wcm92ZWRfcmVnZXhfZm9yX21hdGNoaW5nX3VybHNcbiAgICAgICAgLy8gQW5kIHRoZW4gKGlzc3VlICMxMTYwKSBzaW1wbGlmaWVkIHRvIG1ha2UgaXQgbm90IGNyYXNoIHRoZSBDaHJvbWUgUmVnZXhwIGVuZ2luZVxuICAgICAgICByZXR1cm4gXCJsaW5rXCI7XG4gICAgICB9XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBibGFua0xpbmU6IGJsYW5rTGluZVxuICB9O1xuXG4gIHZhciBtYXJrZG93bkNvbmZpZyA9IHtcbiAgICB1bmRlcnNjb3Jlc0JyZWFrV29yZHM6IGZhbHNlLFxuICAgIHRhc2tMaXN0czogdHJ1ZSxcbiAgICBmZW5jZWRDb2RlQmxvY2tzOiB0cnVlXG4gIH07XG4gIGZvciAodmFyIGF0dHIgaW4gbW9kZUNvbmZpZykge1xuICAgIG1hcmtkb3duQ29uZmlnW2F0dHJdID0gbW9kZUNvbmZpZ1thdHRyXTtcbiAgfVxuICBtYXJrZG93bkNvbmZpZy5uYW1lID0gXCJtYXJrZG93blwiO1xuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJnZm1CYXNlXCIsIG1hcmtkb3duQ29uZmlnKTtcbiAgcmV0dXJuIENvZGVNaXJyb3Iub3ZlcmxheU1vZGUoQ29kZU1pcnJvci5nZXRNb2RlKGNvbmZpZywgXCJnZm1CYXNlXCIpLCBnZm1PdmVybGF5KTtcbn0sIFwibWFya2Rvd25cIik7XG5cbn0pO1xuIiwiKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSwgcmVxdWlyZShcIi4uL3htbC94bWxcIiksIHJlcXVpcmUoXCIuLi9qYXZhc2NyaXB0L2phdmFzY3JpcHRcIiksIHJlcXVpcmUoXCIuLi9jc3MvY3NzXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIsIFwiLi4veG1sL3htbFwiLCBcIi4uL2phdmFzY3JpcHQvamF2YXNjcmlwdFwiLCBcIi4uL2Nzcy9jc3NcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwiaHRtbG1peGVkXCIsIGZ1bmN0aW9uKGNvbmZpZywgcGFyc2VyQ29uZmlnKSB7XG4gIHZhciBodG1sTW9kZSA9IENvZGVNaXJyb3IuZ2V0TW9kZShjb25maWcsIHtuYW1lOiBcInhtbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbE1vZGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aWxpbmVUYWdJbmRlbnRGYWN0b3I6IHBhcnNlckNvbmZpZy5tdWx0aWxpbmVUYWdJbmRlbnRGYWN0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aWxpbmVUYWdJbmRlbnRQYXN0VGFnOiBwYXJzZXJDb25maWcubXVsdGlsaW5lVGFnSW5kZW50UGFzdFRhZ30pO1xuICB2YXIgY3NzTW9kZSA9IENvZGVNaXJyb3IuZ2V0TW9kZShjb25maWcsIFwiY3NzXCIpO1xuXG4gIHZhciBzY3JpcHRUeXBlcyA9IFtdLCBzY3JpcHRUeXBlc0NvbmYgPSBwYXJzZXJDb25maWcgJiYgcGFyc2VyQ29uZmlnLnNjcmlwdFR5cGVzO1xuICBzY3JpcHRUeXBlcy5wdXNoKHttYXRjaGVzOiAvXig/OnRleHR8YXBwbGljYXRpb24pXFwvKD86eC0pPyg/OmphdmF8ZWNtYSlzY3JpcHQkfF4kL2ksXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IENvZGVNaXJyb3IuZ2V0TW9kZShjb25maWcsIFwiamF2YXNjcmlwdFwiKX0pO1xuICBpZiAoc2NyaXB0VHlwZXNDb25mKSBmb3IgKHZhciBpID0gMDsgaSA8IHNjcmlwdFR5cGVzQ29uZi5sZW5ndGg7ICsraSkge1xuICAgIHZhciBjb25mID0gc2NyaXB0VHlwZXNDb25mW2ldO1xuICAgIHNjcmlwdFR5cGVzLnB1c2goe21hdGNoZXM6IGNvbmYubWF0Y2hlcywgbW9kZTogY29uZi5tb2RlICYmIENvZGVNaXJyb3IuZ2V0TW9kZShjb25maWcsIGNvbmYubW9kZSl9KTtcbiAgfVxuICBzY3JpcHRUeXBlcy5wdXNoKHttYXRjaGVzOiAvLi8sXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IENvZGVNaXJyb3IuZ2V0TW9kZShjb25maWcsIFwidGV4dC9wbGFpblwiKX0pO1xuXG4gIGZ1bmN0aW9uIGh0bWwoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciB0YWdOYW1lID0gc3RhdGUuaHRtbFN0YXRlLnRhZ05hbWU7XG4gICAgdmFyIHN0eWxlID0gaHRtbE1vZGUudG9rZW4oc3RyZWFtLCBzdGF0ZS5odG1sU3RhdGUpO1xuICAgIGlmICh0YWdOYW1lID09IFwic2NyaXB0XCIgJiYgL1xcYnRhZ1xcYi8udGVzdChzdHlsZSkgJiYgc3RyZWFtLmN1cnJlbnQoKSA9PSBcIj5cIikge1xuICAgICAgLy8gU2NyaXB0IGJsb2NrOiBtb2RlIHRvIGNoYW5nZSB0byBkZXBlbmRzIG9uIHR5cGUgYXR0cmlidXRlXG4gICAgICB2YXIgc2NyaXB0VHlwZSA9IHN0cmVhbS5zdHJpbmcuc2xpY2UoTWF0aC5tYXgoMCwgc3RyZWFtLnBvcyAtIDEwMCksIHN0cmVhbS5wb3MpLm1hdGNoKC9cXGJ0eXBlXFxzKj1cXHMqKFwiW15cIl0rXCJ8J1teJ10rJ3xcXFMrKVtePF0qJC9pKTtcbiAgICAgIHNjcmlwdFR5cGUgPSBzY3JpcHRUeXBlID8gc2NyaXB0VHlwZVsxXSA6IFwiXCI7XG4gICAgICBpZiAoc2NyaXB0VHlwZSAmJiAvW1xcXCJcXCddLy50ZXN0KHNjcmlwdFR5cGUuY2hhckF0KDApKSkgc2NyaXB0VHlwZSA9IHNjcmlwdFR5cGUuc2xpY2UoMSwgc2NyaXB0VHlwZS5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2NyaXB0VHlwZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHRwID0gc2NyaXB0VHlwZXNbaV07XG4gICAgICAgIGlmICh0eXBlb2YgdHAubWF0Y2hlcyA9PSBcInN0cmluZ1wiID8gc2NyaXB0VHlwZSA9PSB0cC5tYXRjaGVzIDogdHAubWF0Y2hlcy50ZXN0KHNjcmlwdFR5cGUpKSB7XG4gICAgICAgICAgaWYgKHRwLm1vZGUpIHtcbiAgICAgICAgICAgIHN0YXRlLnRva2VuID0gc2NyaXB0O1xuICAgICAgICAgICAgc3RhdGUubG9jYWxNb2RlID0gdHAubW9kZTtcbiAgICAgICAgICAgIHN0YXRlLmxvY2FsU3RhdGUgPSB0cC5tb2RlLnN0YXJ0U3RhdGUgJiYgdHAubW9kZS5zdGFydFN0YXRlKGh0bWxNb2RlLmluZGVudChzdGF0ZS5odG1sU3RhdGUsIFwiXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRhZ05hbWUgPT0gXCJzdHlsZVwiICYmIC9cXGJ0YWdcXGIvLnRlc3Qoc3R5bGUpICYmIHN0cmVhbS5jdXJyZW50KCkgPT0gXCI+XCIpIHtcbiAgICAgIHN0YXRlLnRva2VuID0gY3NzO1xuICAgICAgc3RhdGUubG9jYWxNb2RlID0gY3NzTW9kZTtcbiAgICAgIHN0YXRlLmxvY2FsU3RhdGUgPSBjc3NNb2RlLnN0YXJ0U3RhdGUoaHRtbE1vZGUuaW5kZW50KHN0YXRlLmh0bWxTdGF0ZSwgXCJcIikpO1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cbiAgZnVuY3Rpb24gbWF5YmVCYWNrdXAoc3RyZWFtLCBwYXQsIHN0eWxlKSB7XG4gICAgdmFyIGN1ciA9IHN0cmVhbS5jdXJyZW50KCk7XG4gICAgdmFyIGNsb3NlID0gY3VyLnNlYXJjaChwYXQpLCBtO1xuICAgIGlmIChjbG9zZSA+IC0xKSBzdHJlYW0uYmFja1VwKGN1ci5sZW5ndGggLSBjbG9zZSk7XG4gICAgZWxzZSBpZiAobSA9IGN1ci5tYXRjaCgvPFxcLz8kLykpIHtcbiAgICAgIHN0cmVhbS5iYWNrVXAoY3VyLmxlbmd0aCk7XG4gICAgICBpZiAoIXN0cmVhbS5tYXRjaChwYXQsIGZhbHNlKSkgc3RyZWFtLm1hdGNoKGN1cik7XG4gICAgfVxuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuICBmdW5jdGlvbiBzY3JpcHQoc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmIChzdHJlYW0ubWF0Y2goL148XFwvXFxzKnNjcmlwdFxccyo+L2ksIGZhbHNlKSkge1xuICAgICAgc3RhdGUudG9rZW4gPSBodG1sO1xuICAgICAgc3RhdGUubG9jYWxTdGF0ZSA9IHN0YXRlLmxvY2FsTW9kZSA9IG51bGw7XG4gICAgICByZXR1cm4gaHRtbChzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIG1heWJlQmFja3VwKHN0cmVhbSwgLzxcXC9cXHMqc2NyaXB0XFxzKj4vLFxuICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5sb2NhbE1vZGUudG9rZW4oc3RyZWFtLCBzdGF0ZS5sb2NhbFN0YXRlKSk7XG4gIH1cbiAgZnVuY3Rpb24gY3NzKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RyZWFtLm1hdGNoKC9ePFxcL1xccypzdHlsZVxccyo+L2ksIGZhbHNlKSkge1xuICAgICAgc3RhdGUudG9rZW4gPSBodG1sO1xuICAgICAgc3RhdGUubG9jYWxTdGF0ZSA9IHN0YXRlLmxvY2FsTW9kZSA9IG51bGw7XG4gICAgICByZXR1cm4gaHRtbChzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIG1heWJlQmFja3VwKHN0cmVhbSwgLzxcXC9cXHMqc3R5bGVcXHMqPi8sXG4gICAgICAgICAgICAgICAgICAgICAgIGNzc01vZGUudG9rZW4oc3RyZWFtLCBzdGF0ZS5sb2NhbFN0YXRlKSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHN0YXRlID0gaHRtbE1vZGUuc3RhcnRTdGF0ZSgpO1xuICAgICAgcmV0dXJuIHt0b2tlbjogaHRtbCwgbG9jYWxNb2RlOiBudWxsLCBsb2NhbFN0YXRlOiBudWxsLCBodG1sU3RhdGU6IHN0YXRlfTtcbiAgICB9LFxuXG4gICAgY29weVN0YXRlOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgaWYgKHN0YXRlLmxvY2FsU3RhdGUpXG4gICAgICAgIHZhciBsb2NhbCA9IENvZGVNaXJyb3IuY29weVN0YXRlKHN0YXRlLmxvY2FsTW9kZSwgc3RhdGUubG9jYWxTdGF0ZSk7XG4gICAgICByZXR1cm4ge3Rva2VuOiBzdGF0ZS50b2tlbiwgbG9jYWxNb2RlOiBzdGF0ZS5sb2NhbE1vZGUsIGxvY2FsU3RhdGU6IGxvY2FsLFxuICAgICAgICAgICAgICBodG1sU3RhdGU6IENvZGVNaXJyb3IuY29weVN0YXRlKGh0bWxNb2RlLCBzdGF0ZS5odG1sU3RhdGUpfTtcbiAgICB9LFxuXG4gICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHJldHVybiBzdGF0ZS50b2tlbihzdHJlYW0sIHN0YXRlKTtcbiAgICB9LFxuXG4gICAgaW5kZW50OiBmdW5jdGlvbihzdGF0ZSwgdGV4dEFmdGVyKSB7XG4gICAgICBpZiAoIXN0YXRlLmxvY2FsTW9kZSB8fCAvXlxccyo8XFwvLy50ZXN0KHRleHRBZnRlcikpXG4gICAgICAgIHJldHVybiBodG1sTW9kZS5pbmRlbnQoc3RhdGUuaHRtbFN0YXRlLCB0ZXh0QWZ0ZXIpO1xuICAgICAgZWxzZSBpZiAoc3RhdGUubG9jYWxNb2RlLmluZGVudClcbiAgICAgICAgcmV0dXJuIHN0YXRlLmxvY2FsTW9kZS5pbmRlbnQoc3RhdGUubG9jYWxTdGF0ZSwgdGV4dEFmdGVyKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIENvZGVNaXJyb3IuUGFzcztcbiAgICB9LFxuXG4gICAgaW5uZXJNb2RlOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgcmV0dXJuIHtzdGF0ZTogc3RhdGUubG9jYWxTdGF0ZSB8fCBzdGF0ZS5odG1sU3RhdGUsIG1vZGU6IHN0YXRlLmxvY2FsTW9kZSB8fCBodG1sTW9kZX07XG4gICAgfVxuICB9O1xufSwgXCJ4bWxcIiwgXCJqYXZhc2NyaXB0XCIsIFwiY3NzXCIpO1xuXG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L2h0bWxcIiwgXCJodG1sbWl4ZWRcIik7XG5cbn0pO1xuIiwiLy8gVE9ETyBhY3R1YWxseSByZWNvZ25pemUgc3ludGF4IG9mIFR5cGVTY3JpcHQgY29uc3RydWN0c1xuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTW9kZShcImphdmFzY3JpcHRcIiwgZnVuY3Rpb24oY29uZmlnLCBwYXJzZXJDb25maWcpIHtcbiAgdmFyIGluZGVudFVuaXQgPSBjb25maWcuaW5kZW50VW5pdDtcbiAgdmFyIHN0YXRlbWVudEluZGVudCA9IHBhcnNlckNvbmZpZy5zdGF0ZW1lbnRJbmRlbnQ7XG4gIHZhciBqc29ubGRNb2RlID0gcGFyc2VyQ29uZmlnLmpzb25sZDtcbiAgdmFyIGpzb25Nb2RlID0gcGFyc2VyQ29uZmlnLmpzb24gfHwganNvbmxkTW9kZTtcbiAgdmFyIGlzVFMgPSBwYXJzZXJDb25maWcudHlwZXNjcmlwdDtcblxuICAvLyBUb2tlbml6ZXJcblxuICB2YXIga2V5d29yZHMgPSBmdW5jdGlvbigpe1xuICAgIGZ1bmN0aW9uIGt3KHR5cGUpIHtyZXR1cm4ge3R5cGU6IHR5cGUsIHN0eWxlOiBcImtleXdvcmRcIn07fVxuICAgIHZhciBBID0ga3coXCJrZXl3b3JkIGFcIiksIEIgPSBrdyhcImtleXdvcmQgYlwiKSwgQyA9IGt3KFwia2V5d29yZCBjXCIpO1xuICAgIHZhciBvcGVyYXRvciA9IGt3KFwib3BlcmF0b3JcIiksIGF0b20gPSB7dHlwZTogXCJhdG9tXCIsIHN0eWxlOiBcImF0b21cIn07XG5cbiAgICB2YXIganNLZXl3b3JkcyA9IHtcbiAgICAgIFwiaWZcIjoga3coXCJpZlwiKSwgXCJ3aGlsZVwiOiBBLCBcIndpdGhcIjogQSwgXCJlbHNlXCI6IEIsIFwiZG9cIjogQiwgXCJ0cnlcIjogQiwgXCJmaW5hbGx5XCI6IEIsXG4gICAgICBcInJldHVyblwiOiBDLCBcImJyZWFrXCI6IEMsIFwiY29udGludWVcIjogQywgXCJuZXdcIjogQywgXCJkZWxldGVcIjogQywgXCJ0aHJvd1wiOiBDLCBcImRlYnVnZ2VyXCI6IEMsXG4gICAgICBcInZhclwiOiBrdyhcInZhclwiKSwgXCJjb25zdFwiOiBrdyhcInZhclwiKSwgXCJsZXRcIjoga3coXCJ2YXJcIiksXG4gICAgICBcImZ1bmN0aW9uXCI6IGt3KFwiZnVuY3Rpb25cIiksIFwiY2F0Y2hcIjoga3coXCJjYXRjaFwiKSxcbiAgICAgIFwiZm9yXCI6IGt3KFwiZm9yXCIpLCBcInN3aXRjaFwiOiBrdyhcInN3aXRjaFwiKSwgXCJjYXNlXCI6IGt3KFwiY2FzZVwiKSwgXCJkZWZhdWx0XCI6IGt3KFwiZGVmYXVsdFwiKSxcbiAgICAgIFwiaW5cIjogb3BlcmF0b3IsIFwidHlwZW9mXCI6IG9wZXJhdG9yLCBcImluc3RhbmNlb2ZcIjogb3BlcmF0b3IsXG4gICAgICBcInRydWVcIjogYXRvbSwgXCJmYWxzZVwiOiBhdG9tLCBcIm51bGxcIjogYXRvbSwgXCJ1bmRlZmluZWRcIjogYXRvbSwgXCJOYU5cIjogYXRvbSwgXCJJbmZpbml0eVwiOiBhdG9tLFxuICAgICAgXCJ0aGlzXCI6IGt3KFwidGhpc1wiKSwgXCJtb2R1bGVcIjoga3coXCJtb2R1bGVcIiksIFwiY2xhc3NcIjoga3coXCJjbGFzc1wiKSwgXCJzdXBlclwiOiBrdyhcImF0b21cIiksXG4gICAgICBcInlpZWxkXCI6IEMsIFwiZXhwb3J0XCI6IGt3KFwiZXhwb3J0XCIpLCBcImltcG9ydFwiOiBrdyhcImltcG9ydFwiKSwgXCJleHRlbmRzXCI6IENcbiAgICB9O1xuXG4gICAgLy8gRXh0ZW5kIHRoZSAnbm9ybWFsJyBrZXl3b3JkcyB3aXRoIHRoZSBUeXBlU2NyaXB0IGxhbmd1YWdlIGV4dGVuc2lvbnNcbiAgICBpZiAoaXNUUykge1xuICAgICAgdmFyIHR5cGUgPSB7dHlwZTogXCJ2YXJpYWJsZVwiLCBzdHlsZTogXCJ2YXJpYWJsZS0zXCJ9O1xuICAgICAgdmFyIHRzS2V5d29yZHMgPSB7XG4gICAgICAgIC8vIG9iamVjdC1saWtlIHRoaW5nc1xuICAgICAgICBcImludGVyZmFjZVwiOiBrdyhcImludGVyZmFjZVwiKSxcbiAgICAgICAgXCJleHRlbmRzXCI6IGt3KFwiZXh0ZW5kc1wiKSxcbiAgICAgICAgXCJjb25zdHJ1Y3RvclwiOiBrdyhcImNvbnN0cnVjdG9yXCIpLFxuXG4gICAgICAgIC8vIHNjb3BlIG1vZGlmaWVyc1xuICAgICAgICBcInB1YmxpY1wiOiBrdyhcInB1YmxpY1wiKSxcbiAgICAgICAgXCJwcml2YXRlXCI6IGt3KFwicHJpdmF0ZVwiKSxcbiAgICAgICAgXCJwcm90ZWN0ZWRcIjoga3coXCJwcm90ZWN0ZWRcIiksXG4gICAgICAgIFwic3RhdGljXCI6IGt3KFwic3RhdGljXCIpLFxuXG4gICAgICAgIC8vIHR5cGVzXG4gICAgICAgIFwic3RyaW5nXCI6IHR5cGUsIFwibnVtYmVyXCI6IHR5cGUsIFwiYm9vbFwiOiB0eXBlLCBcImFueVwiOiB0eXBlXG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBhdHRyIGluIHRzS2V5d29yZHMpIHtcbiAgICAgICAganNLZXl3b3Jkc1thdHRyXSA9IHRzS2V5d29yZHNbYXR0cl07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGpzS2V5d29yZHM7XG4gIH0oKTtcblxuICB2YXIgaXNPcGVyYXRvckNoYXIgPSAvWytcXC0qJiU9PD4hP3x+Xl0vO1xuICB2YXIgaXNKc29ubGRLZXl3b3JkID0gL15AKGNvbnRleHR8aWR8dmFsdWV8bGFuZ3VhZ2V8dHlwZXxjb250YWluZXJ8bGlzdHxzZXR8cmV2ZXJzZXxpbmRleHxiYXNlfHZvY2FifGdyYXBoKVwiLztcblxuICBmdW5jdGlvbiByZWFkUmVnZXhwKHN0cmVhbSkge1xuICAgIHZhciBlc2NhcGVkID0gZmFsc2UsIG5leHQsIGluU2V0ID0gZmFsc2U7XG4gICAgd2hpbGUgKChuZXh0ID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgaWYgKCFlc2NhcGVkKSB7XG4gICAgICAgIGlmIChuZXh0ID09IFwiL1wiICYmICFpblNldCkgcmV0dXJuO1xuICAgICAgICBpZiAobmV4dCA9PSBcIltcIikgaW5TZXQgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmIChpblNldCAmJiBuZXh0ID09IFwiXVwiKSBpblNldCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkICYmIG5leHQgPT0gXCJcXFxcXCI7XG4gICAgfVxuICB9XG5cbiAgLy8gVXNlZCBhcyBzY3JhdGNoIHZhcmlhYmxlcyB0byBjb21tdW5pY2F0ZSBtdWx0aXBsZSB2YWx1ZXMgd2l0aG91dFxuICAvLyBjb25zaW5nIHVwIHRvbnMgb2Ygb2JqZWN0cy5cbiAgdmFyIHR5cGUsIGNvbnRlbnQ7XG4gIGZ1bmN0aW9uIHJldCh0cCwgc3R5bGUsIGNvbnQpIHtcbiAgICB0eXBlID0gdHA7IGNvbnRlbnQgPSBjb250O1xuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuICBmdW5jdGlvbiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG4gICAgaWYgKGNoID09ICdcIicgfHwgY2ggPT0gXCInXCIpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5TdHJpbmcoY2gpO1xuICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSBpZiAoY2ggPT0gXCIuXCIgJiYgc3RyZWFtLm1hdGNoKC9eXFxkKyg/OltlRV1bK1xcLV0/XFxkKyk/LykpIHtcbiAgICAgIHJldHVybiByZXQoXCJudW1iZXJcIiwgXCJudW1iZXJcIik7XG4gICAgfSBlbHNlIGlmIChjaCA9PSBcIi5cIiAmJiBzdHJlYW0ubWF0Y2goXCIuLlwiKSkge1xuICAgICAgcmV0dXJuIHJldChcInNwcmVhZFwiLCBcIm1ldGFcIik7XG4gICAgfSBlbHNlIGlmICgvW1xcW1xcXXt9XFwoXFwpLDtcXDpcXC5dLy50ZXN0KGNoKSkge1xuICAgICAgcmV0dXJuIHJldChjaCk7XG4gICAgfSBlbHNlIGlmIChjaCA9PSBcIj1cIiAmJiBzdHJlYW0uZWF0KFwiPlwiKSkge1xuICAgICAgcmV0dXJuIHJldChcIj0+XCIsIFwib3BlcmF0b3JcIik7XG4gICAgfSBlbHNlIGlmIChjaCA9PSBcIjBcIiAmJiBzdHJlYW0uZWF0KC94L2kpKSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXGRhLWZdL2kpO1xuICAgICAgcmV0dXJuIHJldChcIm51bWJlclwiLCBcIm51bWJlclwiKTtcbiAgICB9IGVsc2UgaWYgKC9cXGQvLnRlc3QoY2gpKSB7XG4gICAgICBzdHJlYW0ubWF0Y2goL15cXGQqKD86XFwuXFxkKik/KD86W2VFXVsrXFwtXT9cXGQrKT8vKTtcbiAgICAgIHJldHVybiByZXQoXCJudW1iZXJcIiwgXCJudW1iZXJcIik7XG4gICAgfSBlbHNlIGlmIChjaCA9PSBcIi9cIikge1xuICAgICAgaWYgKHN0cmVhbS5lYXQoXCIqXCIpKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5Db21tZW50O1xuICAgICAgICByZXR1cm4gdG9rZW5Db21tZW50KHN0cmVhbSwgc3RhdGUpO1xuICAgICAgfSBlbHNlIGlmIChzdHJlYW0uZWF0KFwiL1wiKSkge1xuICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgIHJldHVybiByZXQoXCJjb21tZW50XCIsIFwiY29tbWVudFwiKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGFzdFR5cGUgPT0gXCJvcGVyYXRvclwiIHx8IHN0YXRlLmxhc3RUeXBlID09IFwia2V5d29yZCBjXCIgfHxcbiAgICAgICAgICAgICAgIHN0YXRlLmxhc3RUeXBlID09IFwic29mXCIgfHwgL15bXFxbe31cXCgsOzpdJC8udGVzdChzdGF0ZS5sYXN0VHlwZSkpIHtcbiAgICAgICAgcmVhZFJlZ2V4cChzdHJlYW0pO1xuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1tnaW15XS8pOyAvLyAneScgaXMgXCJzdGlja3lcIiBvcHRpb24gaW4gTW96aWxsYVxuICAgICAgICByZXR1cm4gcmV0KFwicmVnZXhwXCIsIFwic3RyaW5nLTJcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoaXNPcGVyYXRvckNoYXIpO1xuICAgICAgICByZXR1cm4gcmV0KFwib3BlcmF0b3JcIiwgXCJvcGVyYXRvclwiLCBzdHJlYW0uY3VycmVudCgpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNoID09IFwiYFwiKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuUXVhc2k7XG4gICAgICByZXR1cm4gdG9rZW5RdWFzaShzdHJlYW0sIHN0YXRlKTtcbiAgICB9IGVsc2UgaWYgKGNoID09IFwiI1wiKSB7XG4gICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICByZXR1cm4gcmV0KFwiZXJyb3JcIiwgXCJlcnJvclwiKTtcbiAgICB9IGVsc2UgaWYgKGlzT3BlcmF0b3JDaGFyLnRlc3QoY2gpKSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoaXNPcGVyYXRvckNoYXIpO1xuICAgICAgcmV0dXJuIHJldChcIm9wZXJhdG9yXCIsIFwib3BlcmF0b3JcIiwgc3RyZWFtLmN1cnJlbnQoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcJF9dLyk7XG4gICAgICB2YXIgd29yZCA9IHN0cmVhbS5jdXJyZW50KCksIGtub3duID0ga2V5d29yZHMucHJvcGVydHlJc0VudW1lcmFibGUod29yZCkgJiYga2V5d29yZHNbd29yZF07XG4gICAgICByZXR1cm4gKGtub3duICYmIHN0YXRlLmxhc3RUeXBlICE9IFwiLlwiKSA/IHJldChrbm93bi50eXBlLCBrbm93bi5zdHlsZSwgd29yZCkgOlxuICAgICAgICAgICAgICAgICAgICAgcmV0KFwidmFyaWFibGVcIiwgXCJ2YXJpYWJsZVwiLCB3b3JkKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlblN0cmluZyhxdW90ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgZXNjYXBlZCA9IGZhbHNlLCBuZXh0O1xuICAgICAgaWYgKGpzb25sZE1vZGUgJiYgc3RyZWFtLnBlZWsoKSA9PSBcIkBcIiAmJiBzdHJlYW0ubWF0Y2goaXNKc29ubGRLZXl3b3JkKSl7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgICByZXR1cm4gcmV0KFwianNvbmxkLWtleXdvcmRcIiwgXCJtZXRhXCIpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKChuZXh0ID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgICBpZiAobmV4dCA9PSBxdW90ZSAmJiAhZXNjYXBlZCkgYnJlYWs7XG4gICAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZCAmJiBuZXh0ID09IFwiXFxcXFwiO1xuICAgICAgfVxuICAgICAgaWYgKCFlc2NhcGVkKSBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgIHJldHVybiByZXQoXCJzdHJpbmdcIiwgXCJzdHJpbmdcIik7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuQ29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIG1heWJlRW5kID0gZmFsc2UsIGNoO1xuICAgIHdoaWxlIChjaCA9IHN0cmVhbS5uZXh0KCkpIHtcbiAgICAgIGlmIChjaCA9PSBcIi9cIiAmJiBtYXliZUVuZCkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBtYXliZUVuZCA9IChjaCA9PSBcIipcIik7XG4gICAgfVxuICAgIHJldHVybiByZXQoXCJjb21tZW50XCIsIFwiY29tbWVudFwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuUXVhc2koc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBlc2NhcGVkID0gZmFsc2UsIG5leHQ7XG4gICAgd2hpbGUgKChuZXh0ID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgaWYgKCFlc2NhcGVkICYmIChuZXh0ID09IFwiYFwiIHx8IG5leHQgPT0gXCIkXCIgJiYgc3RyZWFtLmVhdChcIntcIikpKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZCAmJiBuZXh0ID09IFwiXFxcXFwiO1xuICAgIH1cbiAgICByZXR1cm4gcmV0KFwicXVhc2lcIiwgXCJzdHJpbmctMlwiLCBzdHJlYW0uY3VycmVudCgpKTtcbiAgfVxuXG4gIHZhciBicmFja2V0cyA9IFwiKFt7fV0pXCI7XG4gIC8vIFRoaXMgaXMgYSBjcnVkZSBsb29rYWhlYWQgdHJpY2sgdG8gdHJ5IGFuZCBub3RpY2UgdGhhdCB3ZSdyZVxuICAvLyBwYXJzaW5nIHRoZSBhcmd1bWVudCBwYXR0ZXJucyBmb3IgYSBmYXQtYXJyb3cgZnVuY3Rpb24gYmVmb3JlIHdlXG4gIC8vIGFjdHVhbGx5IGhpdCB0aGUgYXJyb3cgdG9rZW4uIEl0IG9ubHkgd29ya3MgaWYgdGhlIGFycm93IGlzIG9uXG4gIC8vIHRoZSBzYW1lIGxpbmUgYXMgdGhlIGFyZ3VtZW50cyBhbmQgdGhlcmUncyBubyBzdHJhbmdlIG5vaXNlXG4gIC8vIChjb21tZW50cykgaW4gYmV0d2Vlbi4gRmFsbGJhY2sgaXMgdG8gb25seSBub3RpY2Ugd2hlbiB3ZSBoaXQgdGhlXG4gIC8vIGFycm93LCBhbmQgbm90IGRlY2xhcmUgdGhlIGFyZ3VtZW50cyBhcyBsb2NhbHMgZm9yIHRoZSBhcnJvd1xuICAvLyBib2R5LlxuICBmdW5jdGlvbiBmaW5kRmF0QXJyb3coc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5mYXRBcnJvd0F0KSBzdGF0ZS5mYXRBcnJvd0F0ID0gbnVsbDtcbiAgICB2YXIgYXJyb3cgPSBzdHJlYW0uc3RyaW5nLmluZGV4T2YoXCI9PlwiLCBzdHJlYW0uc3RhcnQpO1xuICAgIGlmIChhcnJvdyA8IDApIHJldHVybjtcblxuICAgIHZhciBkZXB0aCA9IDAsIHNhd1NvbWV0aGluZyA9IGZhbHNlO1xuICAgIGZvciAodmFyIHBvcyA9IGFycm93IC0gMTsgcG9zID49IDA7IC0tcG9zKSB7XG4gICAgICB2YXIgY2ggPSBzdHJlYW0uc3RyaW5nLmNoYXJBdChwb3MpO1xuICAgICAgdmFyIGJyYWNrZXQgPSBicmFja2V0cy5pbmRleE9mKGNoKTtcbiAgICAgIGlmIChicmFja2V0ID49IDAgJiYgYnJhY2tldCA8IDMpIHtcbiAgICAgICAgaWYgKCFkZXB0aCkgeyArK3BvczsgYnJlYWs7IH1cbiAgICAgICAgaWYgKC0tZGVwdGggPT0gMCkgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKGJyYWNrZXQgPj0gMyAmJiBicmFja2V0IDwgNikge1xuICAgICAgICArK2RlcHRoO1xuICAgICAgfSBlbHNlIGlmICgvWyRcXHddLy50ZXN0KGNoKSkge1xuICAgICAgICBzYXdTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChzYXdTb21ldGhpbmcgJiYgIWRlcHRoKSB7XG4gICAgICAgICsrcG9zO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNhd1NvbWV0aGluZyAmJiAhZGVwdGgpIHN0YXRlLmZhdEFycm93QXQgPSBwb3M7XG4gIH1cblxuICAvLyBQYXJzZXJcblxuICB2YXIgYXRvbWljVHlwZXMgPSB7XCJhdG9tXCI6IHRydWUsIFwibnVtYmVyXCI6IHRydWUsIFwidmFyaWFibGVcIjogdHJ1ZSwgXCJzdHJpbmdcIjogdHJ1ZSwgXCJyZWdleHBcIjogdHJ1ZSwgXCJ0aGlzXCI6IHRydWUsIFwianNvbmxkLWtleXdvcmRcIjogdHJ1ZX07XG5cbiAgZnVuY3Rpb24gSlNMZXhpY2FsKGluZGVudGVkLCBjb2x1bW4sIHR5cGUsIGFsaWduLCBwcmV2LCBpbmZvKSB7XG4gICAgdGhpcy5pbmRlbnRlZCA9IGluZGVudGVkO1xuICAgIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5wcmV2ID0gcHJldjtcbiAgICB0aGlzLmluZm8gPSBpbmZvO1xuICAgIGlmIChhbGlnbiAhPSBudWxsKSB0aGlzLmFsaWduID0gYWxpZ247XG4gIH1cblxuICBmdW5jdGlvbiBpblNjb3BlKHN0YXRlLCB2YXJuYW1lKSB7XG4gICAgZm9yICh2YXIgdiA9IHN0YXRlLmxvY2FsVmFyczsgdjsgdiA9IHYubmV4dClcbiAgICAgIGlmICh2Lm5hbWUgPT0gdmFybmFtZSkgcmV0dXJuIHRydWU7XG4gICAgZm9yICh2YXIgY3ggPSBzdGF0ZS5jb250ZXh0OyBjeDsgY3ggPSBjeC5wcmV2KSB7XG4gICAgICBmb3IgKHZhciB2ID0gY3gudmFyczsgdjsgdiA9IHYubmV4dClcbiAgICAgICAgaWYgKHYubmFtZSA9PSB2YXJuYW1lKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUpTKHN0YXRlLCBzdHlsZSwgdHlwZSwgY29udGVudCwgc3RyZWFtKSB7XG4gICAgdmFyIGNjID0gc3RhdGUuY2M7XG4gICAgLy8gQ29tbXVuaWNhdGUgb3VyIGNvbnRleHQgdG8gdGhlIGNvbWJpbmF0b3JzLlxuICAgIC8vIChMZXNzIHdhc3RlZnVsIHRoYW4gY29uc2luZyB1cCBhIGh1bmRyZWQgY2xvc3VyZXMgb24gZXZlcnkgY2FsbC4pXG4gICAgY3guc3RhdGUgPSBzdGF0ZTsgY3guc3RyZWFtID0gc3RyZWFtOyBjeC5tYXJrZWQgPSBudWxsLCBjeC5jYyA9IGNjO1xuXG4gICAgaWYgKCFzdGF0ZS5sZXhpY2FsLmhhc093blByb3BlcnR5KFwiYWxpZ25cIikpXG4gICAgICBzdGF0ZS5sZXhpY2FsLmFsaWduID0gdHJ1ZTtcblxuICAgIHdoaWxlKHRydWUpIHtcbiAgICAgIHZhciBjb21iaW5hdG9yID0gY2MubGVuZ3RoID8gY2MucG9wKCkgOiBqc29uTW9kZSA/IGV4cHJlc3Npb24gOiBzdGF0ZW1lbnQ7XG4gICAgICBpZiAoY29tYmluYXRvcih0eXBlLCBjb250ZW50KSkge1xuICAgICAgICB3aGlsZShjYy5sZW5ndGggJiYgY2NbY2MubGVuZ3RoIC0gMV0ubGV4KVxuICAgICAgICAgIGNjLnBvcCgpKCk7XG4gICAgICAgIGlmIChjeC5tYXJrZWQpIHJldHVybiBjeC5tYXJrZWQ7XG4gICAgICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIiAmJiBpblNjb3BlKHN0YXRlLCBjb250ZW50KSkgcmV0dXJuIFwidmFyaWFibGUtMlwiO1xuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ29tYmluYXRvciB1dGlsc1xuXG4gIHZhciBjeCA9IHtzdGF0ZTogbnVsbCwgY29sdW1uOiBudWxsLCBtYXJrZWQ6IG51bGwsIGNjOiBudWxsfTtcbiAgZnVuY3Rpb24gcGFzcygpIHtcbiAgICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBjeC5jYy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIH1cbiAgZnVuY3Rpb24gY29udCgpIHtcbiAgICBwYXNzLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gcmVnaXN0ZXIodmFybmFtZSkge1xuICAgIGZ1bmN0aW9uIGluTGlzdChsaXN0KSB7XG4gICAgICBmb3IgKHZhciB2ID0gbGlzdDsgdjsgdiA9IHYubmV4dClcbiAgICAgICAgaWYgKHYubmFtZSA9PSB2YXJuYW1lKSByZXR1cm4gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHN0YXRlID0gY3guc3RhdGU7XG4gICAgaWYgKHN0YXRlLmNvbnRleHQpIHtcbiAgICAgIGN4Lm1hcmtlZCA9IFwiZGVmXCI7XG4gICAgICBpZiAoaW5MaXN0KHN0YXRlLmxvY2FsVmFycykpIHJldHVybjtcbiAgICAgIHN0YXRlLmxvY2FsVmFycyA9IHtuYW1lOiB2YXJuYW1lLCBuZXh0OiBzdGF0ZS5sb2NhbFZhcnN9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaW5MaXN0KHN0YXRlLmdsb2JhbFZhcnMpKSByZXR1cm47XG4gICAgICBpZiAocGFyc2VyQ29uZmlnLmdsb2JhbFZhcnMpXG4gICAgICAgIHN0YXRlLmdsb2JhbFZhcnMgPSB7bmFtZTogdmFybmFtZSwgbmV4dDogc3RhdGUuZ2xvYmFsVmFyc307XG4gICAgfVxuICB9XG5cbiAgLy8gQ29tYmluYXRvcnNcblxuICB2YXIgZGVmYXVsdFZhcnMgPSB7bmFtZTogXCJ0aGlzXCIsIG5leHQ6IHtuYW1lOiBcImFyZ3VtZW50c1wifX07XG4gIGZ1bmN0aW9uIHB1c2hjb250ZXh0KCkge1xuICAgIGN4LnN0YXRlLmNvbnRleHQgPSB7cHJldjogY3guc3RhdGUuY29udGV4dCwgdmFyczogY3guc3RhdGUubG9jYWxWYXJzfTtcbiAgICBjeC5zdGF0ZS5sb2NhbFZhcnMgPSBkZWZhdWx0VmFycztcbiAgfVxuICBmdW5jdGlvbiBwb3Bjb250ZXh0KCkge1xuICAgIGN4LnN0YXRlLmxvY2FsVmFycyA9IGN4LnN0YXRlLmNvbnRleHQudmFycztcbiAgICBjeC5zdGF0ZS5jb250ZXh0ID0gY3guc3RhdGUuY29udGV4dC5wcmV2O1xuICB9XG4gIGZ1bmN0aW9uIHB1c2hsZXgodHlwZSwgaW5mbykge1xuICAgIHZhciByZXN1bHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzdGF0ZSA9IGN4LnN0YXRlLCBpbmRlbnQgPSBzdGF0ZS5pbmRlbnRlZDtcbiAgICAgIGlmIChzdGF0ZS5sZXhpY2FsLnR5cGUgPT0gXCJzdGF0XCIpIGluZGVudCA9IHN0YXRlLmxleGljYWwuaW5kZW50ZWQ7XG4gICAgICBzdGF0ZS5sZXhpY2FsID0gbmV3IEpTTGV4aWNhbChpbmRlbnQsIGN4LnN0cmVhbS5jb2x1bW4oKSwgdHlwZSwgbnVsbCwgc3RhdGUubGV4aWNhbCwgaW5mbyk7XG4gICAgfTtcbiAgICByZXN1bHQubGV4ID0gdHJ1ZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGZ1bmN0aW9uIHBvcGxleCgpIHtcbiAgICB2YXIgc3RhdGUgPSBjeC5zdGF0ZTtcbiAgICBpZiAoc3RhdGUubGV4aWNhbC5wcmV2KSB7XG4gICAgICBpZiAoc3RhdGUubGV4aWNhbC50eXBlID09IFwiKVwiKVxuICAgICAgICBzdGF0ZS5pbmRlbnRlZCA9IHN0YXRlLmxleGljYWwuaW5kZW50ZWQ7XG4gICAgICBzdGF0ZS5sZXhpY2FsID0gc3RhdGUubGV4aWNhbC5wcmV2O1xuICAgIH1cbiAgfVxuICBwb3BsZXgubGV4ID0gdHJ1ZTtcblxuICBmdW5jdGlvbiBleHBlY3Qod2FudGVkKSB7XG4gICAgZnVuY3Rpb24gZXhwKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09IHdhbnRlZCkgcmV0dXJuIGNvbnQoKTtcbiAgICAgIGVsc2UgaWYgKHdhbnRlZCA9PSBcIjtcIikgcmV0dXJuIHBhc3MoKTtcbiAgICAgIGVsc2UgcmV0dXJuIGNvbnQoZXhwKTtcbiAgICB9O1xuICAgIHJldHVybiBleHA7XG4gIH1cblxuICBmdW5jdGlvbiBzdGF0ZW1lbnQodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZSA9PSBcInZhclwiKSByZXR1cm4gY29udChwdXNobGV4KFwidmFyZGVmXCIsIHZhbHVlLmxlbmd0aCksIHZhcmRlZiwgZXhwZWN0KFwiO1wiKSwgcG9wbGV4KTtcbiAgICBpZiAodHlwZSA9PSBcImtleXdvcmQgYVwiKSByZXR1cm4gY29udChwdXNobGV4KFwiZm9ybVwiKSwgZXhwcmVzc2lvbiwgc3RhdGVtZW50LCBwb3BsZXgpO1xuICAgIGlmICh0eXBlID09IFwia2V5d29yZCBiXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJmb3JtXCIpLCBzdGF0ZW1lbnQsIHBvcGxleCk7XG4gICAgaWYgKHR5cGUgPT0gXCJ7XCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJ9XCIpLCBibG9jaywgcG9wbGV4KTtcbiAgICBpZiAodHlwZSA9PSBcIjtcIikgcmV0dXJuIGNvbnQoKTtcbiAgICBpZiAodHlwZSA9PSBcImlmXCIpIHtcbiAgICAgIGlmIChjeC5zdGF0ZS5sZXhpY2FsLmluZm8gPT0gXCJlbHNlXCIgJiYgY3guc3RhdGUuY2NbY3guc3RhdGUuY2MubGVuZ3RoIC0gMV0gPT0gcG9wbGV4KVxuICAgICAgICBjeC5zdGF0ZS5jYy5wb3AoKSgpO1xuICAgICAgcmV0dXJuIGNvbnQocHVzaGxleChcImZvcm1cIiksIGV4cHJlc3Npb24sIHN0YXRlbWVudCwgcG9wbGV4LCBtYXliZWVsc2UpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBjb250KGZ1bmN0aW9uZGVmKTtcbiAgICBpZiAodHlwZSA9PSBcImZvclwiKSByZXR1cm4gY29udChwdXNobGV4KFwiZm9ybVwiKSwgZm9yc3BlYywgc3RhdGVtZW50LCBwb3BsZXgpO1xuICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIikgcmV0dXJuIGNvbnQocHVzaGxleChcInN0YXRcIiksIG1heWJlbGFiZWwpO1xuICAgIGlmICh0eXBlID09IFwic3dpdGNoXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJmb3JtXCIpLCBleHByZXNzaW9uLCBwdXNobGV4KFwifVwiLCBcInN3aXRjaFwiKSwgZXhwZWN0KFwie1wiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2ssIHBvcGxleCwgcG9wbGV4KTtcbiAgICBpZiAodHlwZSA9PSBcImNhc2VcIikgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbiwgZXhwZWN0KFwiOlwiKSk7XG4gICAgaWYgKHR5cGUgPT0gXCJkZWZhdWx0XCIpIHJldHVybiBjb250KGV4cGVjdChcIjpcIikpO1xuICAgIGlmICh0eXBlID09IFwiY2F0Y2hcIikgcmV0dXJuIGNvbnQocHVzaGxleChcImZvcm1cIiksIHB1c2hjb250ZXh0LCBleHBlY3QoXCIoXCIpLCBmdW5hcmcsIGV4cGVjdChcIilcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50LCBwb3BsZXgsIHBvcGNvbnRleHQpO1xuICAgIGlmICh0eXBlID09IFwibW9kdWxlXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJmb3JtXCIpLCBwdXNoY29udGV4dCwgYWZ0ZXJNb2R1bGUsIHBvcGNvbnRleHQsIHBvcGxleCk7XG4gICAgaWYgKHR5cGUgPT0gXCJjbGFzc1wiKSByZXR1cm4gY29udChwdXNobGV4KFwiZm9ybVwiKSwgY2xhc3NOYW1lLCBvYmpsaXQsIHBvcGxleCk7XG4gICAgaWYgKHR5cGUgPT0gXCJleHBvcnRcIikgcmV0dXJuIGNvbnQocHVzaGxleChcImZvcm1cIiksIGFmdGVyRXhwb3J0LCBwb3BsZXgpO1xuICAgIGlmICh0eXBlID09IFwiaW1wb3J0XCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJmb3JtXCIpLCBhZnRlckltcG9ydCwgcG9wbGV4KTtcbiAgICByZXR1cm4gcGFzcyhwdXNobGV4KFwic3RhdFwiKSwgZXhwcmVzc2lvbiwgZXhwZWN0KFwiO1wiKSwgcG9wbGV4KTtcbiAgfVxuICBmdW5jdGlvbiBleHByZXNzaW9uKHR5cGUpIHtcbiAgICByZXR1cm4gZXhwcmVzc2lvbklubmVyKHR5cGUsIGZhbHNlKTtcbiAgfVxuICBmdW5jdGlvbiBleHByZXNzaW9uTm9Db21tYSh0eXBlKSB7XG4gICAgcmV0dXJuIGV4cHJlc3Npb25Jbm5lcih0eXBlLCB0cnVlKTtcbiAgfVxuICBmdW5jdGlvbiBleHByZXNzaW9uSW5uZXIodHlwZSwgbm9Db21tYSkge1xuICAgIGlmIChjeC5zdGF0ZS5mYXRBcnJvd0F0ID09IGN4LnN0cmVhbS5zdGFydCkge1xuICAgICAgdmFyIGJvZHkgPSBub0NvbW1hID8gYXJyb3dCb2R5Tm9Db21tYSA6IGFycm93Qm9keTtcbiAgICAgIGlmICh0eXBlID09IFwiKFwiKSByZXR1cm4gY29udChwdXNoY29udGV4dCwgcHVzaGxleChcIilcIiksIGNvbW1hc2VwKHBhdHRlcm4sIFwiKVwiKSwgcG9wbGV4LCBleHBlY3QoXCI9PlwiKSwgYm9keSwgcG9wY29udGV4dCk7XG4gICAgICBlbHNlIGlmICh0eXBlID09IFwidmFyaWFibGVcIikgcmV0dXJuIHBhc3MocHVzaGNvbnRleHQsIHBhdHRlcm4sIGV4cGVjdChcIj0+XCIpLCBib2R5LCBwb3Bjb250ZXh0KTtcbiAgICB9XG5cbiAgICB2YXIgbWF5YmVvcCA9IG5vQ29tbWEgPyBtYXliZW9wZXJhdG9yTm9Db21tYSA6IG1heWJlb3BlcmF0b3JDb21tYTtcbiAgICBpZiAoYXRvbWljVHlwZXMuaGFzT3duUHJvcGVydHkodHlwZSkpIHJldHVybiBjb250KG1heWJlb3ApO1xuICAgIGlmICh0eXBlID09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGNvbnQoZnVuY3Rpb25kZWYsIG1heWJlb3ApO1xuICAgIGlmICh0eXBlID09IFwia2V5d29yZCBjXCIpIHJldHVybiBjb250KG5vQ29tbWEgPyBtYXliZWV4cHJlc3Npb25Ob0NvbW1hIDogbWF5YmVleHByZXNzaW9uKTtcbiAgICBpZiAodHlwZSA9PSBcIihcIikgcmV0dXJuIGNvbnQocHVzaGxleChcIilcIiksIG1heWJlZXhwcmVzc2lvbiwgY29tcHJlaGVuc2lvbiwgZXhwZWN0KFwiKVwiKSwgcG9wbGV4LCBtYXliZW9wKTtcbiAgICBpZiAodHlwZSA9PSBcIm9wZXJhdG9yXCIgfHwgdHlwZSA9PSBcInNwcmVhZFwiKSByZXR1cm4gY29udChub0NvbW1hID8gZXhwcmVzc2lvbk5vQ29tbWEgOiBleHByZXNzaW9uKTtcbiAgICBpZiAodHlwZSA9PSBcIltcIikgcmV0dXJuIGNvbnQocHVzaGxleChcIl1cIiksIGFycmF5TGl0ZXJhbCwgcG9wbGV4LCBtYXliZW9wKTtcbiAgICBpZiAodHlwZSA9PSBcIntcIikgcmV0dXJuIGNvbnRDb21tYXNlcChvYmpwcm9wLCBcIn1cIiwgbnVsbCwgbWF5YmVvcCk7XG4gICAgaWYgKHR5cGUgPT0gXCJxdWFzaVwiKSB7IHJldHVybiBwYXNzKHF1YXNpLCBtYXliZW9wKTsgfVxuICAgIHJldHVybiBjb250KCk7XG4gIH1cbiAgZnVuY3Rpb24gbWF5YmVleHByZXNzaW9uKHR5cGUpIHtcbiAgICBpZiAodHlwZS5tYXRjaCgvWztcXH1cXClcXF0sXS8pKSByZXR1cm4gcGFzcygpO1xuICAgIHJldHVybiBwYXNzKGV4cHJlc3Npb24pO1xuICB9XG4gIGZ1bmN0aW9uIG1heWJlZXhwcmVzc2lvbk5vQ29tbWEodHlwZSkge1xuICAgIGlmICh0eXBlLm1hdGNoKC9bO1xcfVxcKVxcXSxdLykpIHJldHVybiBwYXNzKCk7XG4gICAgcmV0dXJuIHBhc3MoZXhwcmVzc2lvbk5vQ29tbWEpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF5YmVvcGVyYXRvckNvbW1hKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCIsXCIpIHJldHVybiBjb250KGV4cHJlc3Npb24pO1xuICAgIHJldHVybiBtYXliZW9wZXJhdG9yTm9Db21tYSh0eXBlLCB2YWx1ZSwgZmFsc2UpO1xuICB9XG4gIGZ1bmN0aW9uIG1heWJlb3BlcmF0b3JOb0NvbW1hKHR5cGUsIHZhbHVlLCBub0NvbW1hKSB7XG4gICAgdmFyIG1lID0gbm9Db21tYSA9PSBmYWxzZSA/IG1heWJlb3BlcmF0b3JDb21tYSA6IG1heWJlb3BlcmF0b3JOb0NvbW1hO1xuICAgIHZhciBleHByID0gbm9Db21tYSA9PSBmYWxzZSA/IGV4cHJlc3Npb24gOiBleHByZXNzaW9uTm9Db21tYTtcbiAgICBpZiAodmFsdWUgPT0gXCI9PlwiKSByZXR1cm4gY29udChwdXNoY29udGV4dCwgbm9Db21tYSA/IGFycm93Qm9keU5vQ29tbWEgOiBhcnJvd0JvZHksIHBvcGNvbnRleHQpO1xuICAgIGlmICh0eXBlID09IFwib3BlcmF0b3JcIikge1xuICAgICAgaWYgKC9cXCtcXCt8LS0vLnRlc3QodmFsdWUpKSByZXR1cm4gY29udChtZSk7XG4gICAgICBpZiAodmFsdWUgPT0gXCI/XCIpIHJldHVybiBjb250KGV4cHJlc3Npb24sIGV4cGVjdChcIjpcIiksIGV4cHIpO1xuICAgICAgcmV0dXJuIGNvbnQoZXhwcik7XG4gICAgfVxuICAgIGlmICh0eXBlID09IFwicXVhc2lcIikgeyByZXR1cm4gcGFzcyhxdWFzaSwgbWUpOyB9XG4gICAgaWYgKHR5cGUgPT0gXCI7XCIpIHJldHVybjtcbiAgICBpZiAodHlwZSA9PSBcIihcIikgcmV0dXJuIGNvbnRDb21tYXNlcChleHByZXNzaW9uTm9Db21tYSwgXCIpXCIsIFwiY2FsbFwiLCBtZSk7XG4gICAgaWYgKHR5cGUgPT0gXCIuXCIpIHJldHVybiBjb250KHByb3BlcnR5LCBtZSk7XG4gICAgaWYgKHR5cGUgPT0gXCJbXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJdXCIpLCBtYXliZWV4cHJlc3Npb24sIGV4cGVjdChcIl1cIiksIHBvcGxleCwgbWUpO1xuICB9XG4gIGZ1bmN0aW9uIHF1YXNpKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGUgIT0gXCJxdWFzaVwiKSByZXR1cm4gcGFzcygpO1xuICAgIGlmICh2YWx1ZS5zbGljZSh2YWx1ZS5sZW5ndGggLSAyKSAhPSBcIiR7XCIpIHJldHVybiBjb250KHF1YXNpKTtcbiAgICByZXR1cm4gY29udChleHByZXNzaW9uLCBjb250aW51ZVF1YXNpKTtcbiAgfVxuICBmdW5jdGlvbiBjb250aW51ZVF1YXNpKHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PSBcIn1cIikge1xuICAgICAgY3gubWFya2VkID0gXCJzdHJpbmctMlwiO1xuICAgICAgY3guc3RhdGUudG9rZW5pemUgPSB0b2tlblF1YXNpO1xuICAgICAgcmV0dXJuIGNvbnQocXVhc2kpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBhcnJvd0JvZHkodHlwZSkge1xuICAgIGZpbmRGYXRBcnJvdyhjeC5zdHJlYW0sIGN4LnN0YXRlKTtcbiAgICBpZiAodHlwZSA9PSBcIntcIikgcmV0dXJuIHBhc3Moc3RhdGVtZW50KTtcbiAgICByZXR1cm4gcGFzcyhleHByZXNzaW9uKTtcbiAgfVxuICBmdW5jdGlvbiBhcnJvd0JvZHlOb0NvbW1hKHR5cGUpIHtcbiAgICBmaW5kRmF0QXJyb3coY3guc3RyZWFtLCBjeC5zdGF0ZSk7XG4gICAgaWYgKHR5cGUgPT0gXCJ7XCIpIHJldHVybiBwYXNzKHN0YXRlbWVudCk7XG4gICAgcmV0dXJuIHBhc3MoZXhwcmVzc2lvbk5vQ29tbWEpO1xuICB9XG4gIGZ1bmN0aW9uIG1heWJlbGFiZWwodHlwZSkge1xuICAgIGlmICh0eXBlID09IFwiOlwiKSByZXR1cm4gY29udChwb3BsZXgsIHN0YXRlbWVudCk7XG4gICAgcmV0dXJuIHBhc3MobWF5YmVvcGVyYXRvckNvbW1hLCBleHBlY3QoXCI7XCIpLCBwb3BsZXgpO1xuICB9XG4gIGZ1bmN0aW9uIHByb3BlcnR5KHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIpIHtjeC5tYXJrZWQgPSBcInByb3BlcnR5XCI7IHJldHVybiBjb250KCk7fVxuICB9XG4gIGZ1bmN0aW9uIG9ianByb3AodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIpIHtcbiAgICAgIGN4Lm1hcmtlZCA9IFwicHJvcGVydHlcIjtcbiAgICAgIGlmICh2YWx1ZSA9PSBcImdldFwiIHx8IHZhbHVlID09IFwic2V0XCIpIHJldHVybiBjb250KGdldHRlclNldHRlcik7XG4gICAgfSBlbHNlIGlmICh0eXBlID09IFwibnVtYmVyXCIgfHwgdHlwZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICBjeC5tYXJrZWQgPSBqc29ubGRNb2RlID8gXCJwcm9wZXJ0eVwiIDogKHR5cGUgKyBcIiBwcm9wZXJ0eVwiKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJbXCIpIHtcbiAgICAgIHJldHVybiBjb250KGV4cHJlc3Npb24sIGV4cGVjdChcIl1cIiksIGFmdGVycHJvcCk7XG4gICAgfVxuICAgIGlmIChhdG9taWNUeXBlcy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgcmV0dXJuIGNvbnQoYWZ0ZXJwcm9wKTtcbiAgfVxuICBmdW5jdGlvbiBnZXR0ZXJTZXR0ZXIodHlwZSkge1xuICAgIGlmICh0eXBlICE9IFwidmFyaWFibGVcIikgcmV0dXJuIHBhc3MoYWZ0ZXJwcm9wKTtcbiAgICBjeC5tYXJrZWQgPSBcInByb3BlcnR5XCI7XG4gICAgcmV0dXJuIGNvbnQoZnVuY3Rpb25kZWYpO1xuICB9XG4gIGZ1bmN0aW9uIGFmdGVycHJvcCh0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCI6XCIpIHJldHVybiBjb250KGV4cHJlc3Npb25Ob0NvbW1hKTtcbiAgICBpZiAodHlwZSA9PSBcIihcIikgcmV0dXJuIHBhc3MoZnVuY3Rpb25kZWYpO1xuICB9XG4gIGZ1bmN0aW9uIGNvbW1hc2VwKHdoYXQsIGVuZCkge1xuICAgIGZ1bmN0aW9uIHByb2NlZWQodHlwZSkge1xuICAgICAgaWYgKHR5cGUgPT0gXCIsXCIpIHtcbiAgICAgICAgdmFyIGxleCA9IGN4LnN0YXRlLmxleGljYWw7XG4gICAgICAgIGlmIChsZXguaW5mbyA9PSBcImNhbGxcIikgbGV4LnBvcyA9IChsZXgucG9zIHx8IDApICsgMTtcbiAgICAgICAgcmV0dXJuIGNvbnQod2hhdCwgcHJvY2VlZCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PSBlbmQpIHJldHVybiBjb250KCk7XG4gICAgICByZXR1cm4gY29udChleHBlY3QoZW5kKSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PSBlbmQpIHJldHVybiBjb250KCk7XG4gICAgICByZXR1cm4gcGFzcyh3aGF0LCBwcm9jZWVkKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGNvbnRDb21tYXNlcCh3aGF0LCBlbmQsIGluZm8pIHtcbiAgICBmb3IgKHZhciBpID0gMzsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcbiAgICAgIGN4LmNjLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICByZXR1cm4gY29udChwdXNobGV4KGVuZCwgaW5mbyksIGNvbW1hc2VwKHdoYXQsIGVuZCksIHBvcGxleCk7XG4gIH1cbiAgZnVuY3Rpb24gYmxvY2sodHlwZSkge1xuICAgIGlmICh0eXBlID09IFwifVwiKSByZXR1cm4gY29udCgpO1xuICAgIHJldHVybiBwYXNzKHN0YXRlbWVudCwgYmxvY2spO1xuICB9XG4gIGZ1bmN0aW9uIG1heWJldHlwZSh0eXBlKSB7XG4gICAgaWYgKGlzVFMgJiYgdHlwZSA9PSBcIjpcIikgcmV0dXJuIGNvbnQodHlwZWRlZik7XG4gIH1cbiAgZnVuY3Rpb24gdHlwZWRlZih0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKXtjeC5tYXJrZWQgPSBcInZhcmlhYmxlLTNcIjsgcmV0dXJuIGNvbnQoKTt9XG4gIH1cbiAgZnVuY3Rpb24gdmFyZGVmKCkge1xuICAgIHJldHVybiBwYXNzKHBhdHRlcm4sIG1heWJldHlwZSwgbWF5YmVBc3NpZ24sIHZhcmRlZkNvbnQpO1xuICB9XG4gIGZ1bmN0aW9uIHBhdHRlcm4odHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIpIHsgcmVnaXN0ZXIodmFsdWUpOyByZXR1cm4gY29udCgpOyB9XG4gICAgaWYgKHR5cGUgPT0gXCJbXCIpIHJldHVybiBjb250Q29tbWFzZXAocGF0dGVybiwgXCJdXCIpO1xuICAgIGlmICh0eXBlID09IFwie1wiKSByZXR1cm4gY29udENvbW1hc2VwKHByb3BwYXR0ZXJuLCBcIn1cIik7XG4gIH1cbiAgZnVuY3Rpb24gcHJvcHBhdHRlcm4odHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIgJiYgIWN4LnN0cmVhbS5tYXRjaCgvXlxccyo6LywgZmFsc2UpKSB7XG4gICAgICByZWdpc3Rlcih2YWx1ZSk7XG4gICAgICByZXR1cm4gY29udChtYXliZUFzc2lnbik7XG4gICAgfVxuICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIikgY3gubWFya2VkID0gXCJwcm9wZXJ0eVwiO1xuICAgIHJldHVybiBjb250KGV4cGVjdChcIjpcIiksIHBhdHRlcm4sIG1heWJlQXNzaWduKTtcbiAgfVxuICBmdW5jdGlvbiBtYXliZUFzc2lnbihfdHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gXCI9XCIpIHJldHVybiBjb250KGV4cHJlc3Npb25Ob0NvbW1hKTtcbiAgfVxuICBmdW5jdGlvbiB2YXJkZWZDb250KHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PSBcIixcIikgcmV0dXJuIGNvbnQodmFyZGVmKTtcbiAgfVxuICBmdW5jdGlvbiBtYXliZWVsc2UodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZSA9PSBcImtleXdvcmQgYlwiICYmIHZhbHVlID09IFwiZWxzZVwiKSByZXR1cm4gY29udChwdXNobGV4KFwiZm9ybVwiLCBcImVsc2VcIiksIHN0YXRlbWVudCwgcG9wbGV4KTtcbiAgfVxuICBmdW5jdGlvbiBmb3JzcGVjKHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PSBcIihcIikgcmV0dXJuIGNvbnQocHVzaGxleChcIilcIiksIGZvcnNwZWMxLCBleHBlY3QoXCIpXCIpLCBwb3BsZXgpO1xuICB9XG4gIGZ1bmN0aW9uIGZvcnNwZWMxKHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PSBcInZhclwiKSByZXR1cm4gY29udCh2YXJkZWYsIGV4cGVjdChcIjtcIiksIGZvcnNwZWMyKTtcbiAgICBpZiAodHlwZSA9PSBcIjtcIikgcmV0dXJuIGNvbnQoZm9yc3BlYzIpO1xuICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIikgcmV0dXJuIGNvbnQoZm9ybWF5YmVpbm9mKTtcbiAgICByZXR1cm4gcGFzcyhleHByZXNzaW9uLCBleHBlY3QoXCI7XCIpLCBmb3JzcGVjMik7XG4gIH1cbiAgZnVuY3Rpb24gZm9ybWF5YmVpbm9mKF90eXBlLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBcImluXCIgfHwgdmFsdWUgPT0gXCJvZlwiKSB7IGN4Lm1hcmtlZCA9IFwia2V5d29yZFwiOyByZXR1cm4gY29udChleHByZXNzaW9uKTsgfVxuICAgIHJldHVybiBjb250KG1heWJlb3BlcmF0b3JDb21tYSwgZm9yc3BlYzIpO1xuICB9XG4gIGZ1bmN0aW9uIGZvcnNwZWMyKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCI7XCIpIHJldHVybiBjb250KGZvcnNwZWMzKTtcbiAgICBpZiAodmFsdWUgPT0gXCJpblwiIHx8IHZhbHVlID09IFwib2ZcIikgeyBjeC5tYXJrZWQgPSBcImtleXdvcmRcIjsgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbik7IH1cbiAgICByZXR1cm4gcGFzcyhleHByZXNzaW9uLCBleHBlY3QoXCI7XCIpLCBmb3JzcGVjMyk7XG4gIH1cbiAgZnVuY3Rpb24gZm9yc3BlYzModHlwZSkge1xuICAgIGlmICh0eXBlICE9IFwiKVwiKSBjb250KGV4cHJlc3Npb24pO1xuICB9XG4gIGZ1bmN0aW9uIGZ1bmN0aW9uZGVmKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IFwiKlwiKSB7Y3gubWFya2VkID0gXCJrZXl3b3JkXCI7IHJldHVybiBjb250KGZ1bmN0aW9uZGVmKTt9XG4gICAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKSB7cmVnaXN0ZXIodmFsdWUpOyByZXR1cm4gY29udChmdW5jdGlvbmRlZik7fVxuICAgIGlmICh0eXBlID09IFwiKFwiKSByZXR1cm4gY29udChwdXNoY29udGV4dCwgcHVzaGxleChcIilcIiksIGNvbW1hc2VwKGZ1bmFyZywgXCIpXCIpLCBwb3BsZXgsIHN0YXRlbWVudCwgcG9wY29udGV4dCk7XG4gIH1cbiAgZnVuY3Rpb24gZnVuYXJnKHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PSBcInNwcmVhZFwiKSByZXR1cm4gY29udChmdW5hcmcpO1xuICAgIHJldHVybiBwYXNzKHBhdHRlcm4sIG1heWJldHlwZSk7XG4gIH1cbiAgZnVuY3Rpb24gY2xhc3NOYW1lKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKSB7cmVnaXN0ZXIodmFsdWUpOyByZXR1cm4gY29udChjbGFzc05hbWVBZnRlcik7fVxuICB9XG4gIGZ1bmN0aW9uIGNsYXNzTmFtZUFmdGVyKF90eXBlLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBcImV4dGVuZHNcIikgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbik7XG4gIH1cbiAgZnVuY3Rpb24gb2JqbGl0KHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PSBcIntcIikgcmV0dXJuIGNvbnRDb21tYXNlcChvYmpwcm9wLCBcIn1cIik7XG4gIH1cbiAgZnVuY3Rpb24gYWZ0ZXJNb2R1bGUodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZSA9PSBcInN0cmluZ1wiKSByZXR1cm4gY29udChzdGF0ZW1lbnQpO1xuICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIikgeyByZWdpc3Rlcih2YWx1ZSk7IHJldHVybiBjb250KG1heWJlRnJvbSk7IH1cbiAgfVxuICBmdW5jdGlvbiBhZnRlckV4cG9ydChfdHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gXCIqXCIpIHsgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7IHJldHVybiBjb250KG1heWJlRnJvbSwgZXhwZWN0KFwiO1wiKSk7IH1cbiAgICBpZiAodmFsdWUgPT0gXCJkZWZhdWx0XCIpIHsgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7IHJldHVybiBjb250KGV4cHJlc3Npb24sIGV4cGVjdChcIjtcIikpOyB9XG4gICAgcmV0dXJuIHBhc3Moc3RhdGVtZW50KTtcbiAgfVxuICBmdW5jdGlvbiBhZnRlckltcG9ydCh0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJzdHJpbmdcIikgcmV0dXJuIGNvbnQoKTtcbiAgICByZXR1cm4gcGFzcyhpbXBvcnRTcGVjLCBtYXliZUZyb20pO1xuICB9XG4gIGZ1bmN0aW9uIGltcG9ydFNwZWModHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZSA9PSBcIntcIikgcmV0dXJuIGNvbnRDb21tYXNlcChpbXBvcnRTcGVjLCBcIn1cIik7XG4gICAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKSByZWdpc3Rlcih2YWx1ZSk7XG4gICAgcmV0dXJuIGNvbnQoKTtcbiAgfVxuICBmdW5jdGlvbiBtYXliZUZyb20oX3R5cGUsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IFwiZnJvbVwiKSB7IGN4Lm1hcmtlZCA9IFwia2V5d29yZFwiOyByZXR1cm4gY29udChleHByZXNzaW9uKTsgfVxuICB9XG4gIGZ1bmN0aW9uIGFycmF5TGl0ZXJhbCh0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJdXCIpIHJldHVybiBjb250KCk7XG4gICAgcmV0dXJuIHBhc3MoZXhwcmVzc2lvbk5vQ29tbWEsIG1heWJlQXJyYXlDb21wcmVoZW5zaW9uKTtcbiAgfVxuICBmdW5jdGlvbiBtYXliZUFycmF5Q29tcHJlaGVuc2lvbih0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJmb3JcIikgcmV0dXJuIHBhc3MoY29tcHJlaGVuc2lvbiwgZXhwZWN0KFwiXVwiKSk7XG4gICAgaWYgKHR5cGUgPT0gXCIsXCIpIHJldHVybiBjb250KGNvbW1hc2VwKGV4cHJlc3Npb25Ob0NvbW1hLCBcIl1cIikpO1xuICAgIHJldHVybiBwYXNzKGNvbW1hc2VwKGV4cHJlc3Npb25Ob0NvbW1hLCBcIl1cIikpO1xuICB9XG4gIGZ1bmN0aW9uIGNvbXByZWhlbnNpb24odHlwZSkge1xuICAgIGlmICh0eXBlID09IFwiZm9yXCIpIHJldHVybiBjb250KGZvcnNwZWMsIGNvbXByZWhlbnNpb24pO1xuICAgIGlmICh0eXBlID09IFwiaWZcIikgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbiwgY29tcHJlaGVuc2lvbik7XG4gIH1cblxuICAvLyBJbnRlcmZhY2VcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKGJhc2Vjb2x1bW4pIHtcbiAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgdG9rZW5pemU6IHRva2VuQmFzZSxcbiAgICAgICAgbGFzdFR5cGU6IFwic29mXCIsXG4gICAgICAgIGNjOiBbXSxcbiAgICAgICAgbGV4aWNhbDogbmV3IEpTTGV4aWNhbCgoYmFzZWNvbHVtbiB8fCAwKSAtIGluZGVudFVuaXQsIDAsIFwiYmxvY2tcIiwgZmFsc2UpLFxuICAgICAgICBsb2NhbFZhcnM6IHBhcnNlckNvbmZpZy5sb2NhbFZhcnMsXG4gICAgICAgIGNvbnRleHQ6IHBhcnNlckNvbmZpZy5sb2NhbFZhcnMgJiYge3ZhcnM6IHBhcnNlckNvbmZpZy5sb2NhbFZhcnN9LFxuICAgICAgICBpbmRlbnRlZDogMFxuICAgICAgfTtcbiAgICAgIGlmIChwYXJzZXJDb25maWcuZ2xvYmFsVmFycyAmJiB0eXBlb2YgcGFyc2VyQ29uZmlnLmdsb2JhbFZhcnMgPT0gXCJvYmplY3RcIilcbiAgICAgICAgc3RhdGUuZ2xvYmFsVmFycyA9IHBhcnNlckNvbmZpZy5nbG9iYWxWYXJzO1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG5cbiAgICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKHN0cmVhbS5zb2woKSkge1xuICAgICAgICBpZiAoIXN0YXRlLmxleGljYWwuaGFzT3duUHJvcGVydHkoXCJhbGlnblwiKSlcbiAgICAgICAgICBzdGF0ZS5sZXhpY2FsLmFsaWduID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmluZGVudGVkID0gc3RyZWFtLmluZGVudGF0aW9uKCk7XG4gICAgICAgIGZpbmRGYXRBcnJvdyhzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS50b2tlbml6ZSAhPSB0b2tlbkNvbW1lbnQgJiYgc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xuICAgICAgdmFyIHN0eWxlID0gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBpZiAodHlwZSA9PSBcImNvbW1lbnRcIikgcmV0dXJuIHN0eWxlO1xuICAgICAgc3RhdGUubGFzdFR5cGUgPSB0eXBlID09IFwib3BlcmF0b3JcIiAmJiAoY29udGVudCA9PSBcIisrXCIgfHwgY29udGVudCA9PSBcIi0tXCIpID8gXCJpbmNkZWNcIiA6IHR5cGU7XG4gICAgICByZXR1cm4gcGFyc2VKUyhzdGF0ZSwgc3R5bGUsIHR5cGUsIGNvbnRlbnQsIHN0cmVhbSk7XG4gICAgfSxcblxuICAgIGluZGVudDogZnVuY3Rpb24oc3RhdGUsIHRleHRBZnRlcikge1xuICAgICAgaWYgKHN0YXRlLnRva2VuaXplID09IHRva2VuQ29tbWVudCkgcmV0dXJuIENvZGVNaXJyb3IuUGFzcztcbiAgICAgIGlmIChzdGF0ZS50b2tlbml6ZSAhPSB0b2tlbkJhc2UpIHJldHVybiAwO1xuICAgICAgdmFyIGZpcnN0Q2hhciA9IHRleHRBZnRlciAmJiB0ZXh0QWZ0ZXIuY2hhckF0KDApLCBsZXhpY2FsID0gc3RhdGUubGV4aWNhbDtcbiAgICAgIC8vIEtsdWRnZSB0byBwcmV2ZW50ICdtYXliZWxzZScgZnJvbSBibG9ja2luZyBsZXhpY2FsIHNjb3BlIHBvcHNcbiAgICAgIGlmICghL15cXHMqZWxzZVxcYi8udGVzdCh0ZXh0QWZ0ZXIpKSBmb3IgKHZhciBpID0gc3RhdGUuY2MubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGMgPSBzdGF0ZS5jY1tpXTtcbiAgICAgICAgaWYgKGMgPT0gcG9wbGV4KSBsZXhpY2FsID0gbGV4aWNhbC5wcmV2O1xuICAgICAgICBlbHNlIGlmIChjICE9IG1heWJlZWxzZSkgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAobGV4aWNhbC50eXBlID09IFwic3RhdFwiICYmIGZpcnN0Q2hhciA9PSBcIn1cIikgbGV4aWNhbCA9IGxleGljYWwucHJldjtcbiAgICAgIGlmIChzdGF0ZW1lbnRJbmRlbnQgJiYgbGV4aWNhbC50eXBlID09IFwiKVwiICYmIGxleGljYWwucHJldi50eXBlID09IFwic3RhdFwiKVxuICAgICAgICBsZXhpY2FsID0gbGV4aWNhbC5wcmV2O1xuICAgICAgdmFyIHR5cGUgPSBsZXhpY2FsLnR5cGUsIGNsb3NpbmcgPSBmaXJzdENoYXIgPT0gdHlwZTtcblxuICAgICAgaWYgKHR5cGUgPT0gXCJ2YXJkZWZcIikgcmV0dXJuIGxleGljYWwuaW5kZW50ZWQgKyAoc3RhdGUubGFzdFR5cGUgPT0gXCJvcGVyYXRvclwiIHx8IHN0YXRlLmxhc3RUeXBlID09IFwiLFwiID8gbGV4aWNhbC5pbmZvICsgMSA6IDApO1xuICAgICAgZWxzZSBpZiAodHlwZSA9PSBcImZvcm1cIiAmJiBmaXJzdENoYXIgPT0gXCJ7XCIpIHJldHVybiBsZXhpY2FsLmluZGVudGVkO1xuICAgICAgZWxzZSBpZiAodHlwZSA9PSBcImZvcm1cIikgcmV0dXJuIGxleGljYWwuaW5kZW50ZWQgKyBpbmRlbnRVbml0O1xuICAgICAgZWxzZSBpZiAodHlwZSA9PSBcInN0YXRcIilcbiAgICAgICAgcmV0dXJuIGxleGljYWwuaW5kZW50ZWQgKyAoc3RhdGUubGFzdFR5cGUgPT0gXCJvcGVyYXRvclwiIHx8IHN0YXRlLmxhc3RUeXBlID09IFwiLFwiID8gc3RhdGVtZW50SW5kZW50IHx8IGluZGVudFVuaXQgOiAwKTtcbiAgICAgIGVsc2UgaWYgKGxleGljYWwuaW5mbyA9PSBcInN3aXRjaFwiICYmICFjbG9zaW5nICYmIHBhcnNlckNvbmZpZy5kb3VibGVJbmRlbnRTd2l0Y2ggIT0gZmFsc2UpXG4gICAgICAgIHJldHVybiBsZXhpY2FsLmluZGVudGVkICsgKC9eKD86Y2FzZXxkZWZhdWx0KVxcYi8udGVzdCh0ZXh0QWZ0ZXIpID8gaW5kZW50VW5pdCA6IDIgKiBpbmRlbnRVbml0KTtcbiAgICAgIGVsc2UgaWYgKGxleGljYWwuYWxpZ24pIHJldHVybiBsZXhpY2FsLmNvbHVtbiArIChjbG9zaW5nID8gMCA6IDEpO1xuICAgICAgZWxzZSByZXR1cm4gbGV4aWNhbC5pbmRlbnRlZCArIChjbG9zaW5nID8gMCA6IGluZGVudFVuaXQpO1xuICAgIH0sXG5cbiAgICBlbGVjdHJpY0NoYXJzOiBcIjp7fVwiLFxuICAgIGJsb2NrQ29tbWVudFN0YXJ0OiBqc29uTW9kZSA/IG51bGwgOiBcIi8qXCIsXG4gICAgYmxvY2tDb21tZW50RW5kOiBqc29uTW9kZSA/IG51bGwgOiBcIiovXCIsXG4gICAgbGluZUNvbW1lbnQ6IGpzb25Nb2RlID8gbnVsbCA6IFwiLy9cIixcbiAgICBmb2xkOiBcImJyYWNlXCIsXG5cbiAgICBoZWxwZXJUeXBlOiBqc29uTW9kZSA/IFwianNvblwiIDogXCJqYXZhc2NyaXB0XCIsXG4gICAganNvbmxkTW9kZToganNvbmxkTW9kZSxcbiAgICBqc29uTW9kZToganNvbk1vZGVcbiAgfTtcbn0pO1xuXG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L2phdmFzY3JpcHRcIiwgXCJqYXZhc2NyaXB0XCIpO1xuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC9lY21hc2NyaXB0XCIsIFwiamF2YXNjcmlwdFwiKTtcbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIiwgXCJqYXZhc2NyaXB0XCIpO1xuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdFwiLCBcImphdmFzY3JpcHRcIik7XG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJhcHBsaWNhdGlvbi9qc29uXCIsIHtuYW1lOiBcImphdmFzY3JpcHRcIiwganNvbjogdHJ1ZX0pO1xuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwiYXBwbGljYXRpb24veC1qc29uXCIsIHtuYW1lOiBcImphdmFzY3JpcHRcIiwganNvbjogdHJ1ZX0pO1xuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwiYXBwbGljYXRpb24vbGQranNvblwiLCB7bmFtZTogXCJqYXZhc2NyaXB0XCIsIGpzb25sZDogdHJ1ZX0pO1xuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC90eXBlc2NyaXB0XCIsIHsgbmFtZTogXCJqYXZhc2NyaXB0XCIsIHR5cGVzY3JpcHQ6IHRydWUgfSk7XG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJhcHBsaWNhdGlvbi90eXBlc2NyaXB0XCIsIHsgbmFtZTogXCJqYXZhc2NyaXB0XCIsIHR5cGVzY3JpcHQ6IHRydWUgfSk7XG5cbn0pO1xuIiwiKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiLCByZXF1aXJlKFwiLi4veG1sL3htbFwiKSkpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIiwgXCIuLi94bWwveG1sXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTW9kZShcIm1hcmtkb3duXCIsIGZ1bmN0aW9uKGNtQ2ZnLCBtb2RlQ2ZnKSB7XG5cbiAgdmFyIGh0bWxGb3VuZCA9IENvZGVNaXJyb3IubW9kZXMuaGFzT3duUHJvcGVydHkoXCJ4bWxcIik7XG4gIHZhciBodG1sTW9kZSA9IENvZGVNaXJyb3IuZ2V0TW9kZShjbUNmZywgaHRtbEZvdW5kID8ge25hbWU6IFwieG1sXCIsIGh0bWxNb2RlOiB0cnVlfSA6IFwidGV4dC9wbGFpblwiKTtcbiAgdmFyIGFsaWFzZXMgPSB7XG4gICAgaHRtbDogXCJodG1sbWl4ZWRcIixcbiAgICBqczogXCJqYXZhc2NyaXB0XCIsXG4gICAganNvbjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgYzogXCJ0ZXh0L3gtY3NyY1wiLFxuICAgIFwiYysrXCI6IFwidGV4dC94LWMrK3NyY1wiLFxuICAgIGphdmE6IFwidGV4dC94LWphdmFcIixcbiAgICBjc2hhcnA6IFwidGV4dC94LWNzaGFycFwiLFxuICAgIFwiYyNcIjogXCJ0ZXh0L3gtY3NoYXJwXCIsXG4gICAgc2NhbGE6IFwidGV4dC94LXNjYWxhXCJcbiAgfTtcblxuICB2YXIgZ2V0TW9kZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGksIG1vZGVzID0ge30sIG1pbWVzID0ge30sIG1pbWU7XG5cbiAgICB2YXIgbGlzdCA9IFtdO1xuICAgIGZvciAodmFyIG0gaW4gQ29kZU1pcnJvci5tb2RlcylcbiAgICAgIGlmIChDb2RlTWlycm9yLm1vZGVzLnByb3BlcnR5SXNFbnVtZXJhYmxlKG0pKSBsaXN0LnB1c2gobSk7XG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIG1vZGVzW2xpc3RbaV1dID0gbGlzdFtpXTtcbiAgICB9XG4gICAgdmFyIG1pbWVzTGlzdCA9IFtdO1xuICAgIGZvciAodmFyIG0gaW4gQ29kZU1pcnJvci5taW1lTW9kZXMpXG4gICAgICBpZiAoQ29kZU1pcnJvci5taW1lTW9kZXMucHJvcGVydHlJc0VudW1lcmFibGUobSkpXG4gICAgICAgIG1pbWVzTGlzdC5wdXNoKHttaW1lOiBtLCBtb2RlOiBDb2RlTWlycm9yLm1pbWVNb2Rlc1ttXX0pO1xuICAgIGZvciAoaSA9IDA7IGkgPCBtaW1lc0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIG1pbWUgPSBtaW1lc0xpc3RbaV0ubWltZTtcbiAgICAgIG1pbWVzW21pbWVdID0gbWltZXNMaXN0W2ldLm1pbWU7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgYSBpbiBhbGlhc2VzKSB7XG4gICAgICBpZiAoYWxpYXNlc1thXSBpbiBtb2RlcyB8fCBhbGlhc2VzW2FdIGluIG1pbWVzKVxuICAgICAgICBtb2Rlc1thXSA9IGFsaWFzZXNbYV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChsYW5nKSB7XG4gICAgICByZXR1cm4gbW9kZXNbbGFuZ10gPyBDb2RlTWlycm9yLmdldE1vZGUoY21DZmcsIG1vZGVzW2xhbmddKSA6IG51bGw7XG4gICAgfTtcbiAgfSgpKTtcblxuICAvLyBTaG91bGQgY2hhcmFjdGVycyB0aGF0IGFmZmVjdCBoaWdobGlnaHRpbmcgYmUgaGlnaGxpZ2h0ZWQgc2VwYXJhdGU/XG4gIC8vIERvZXMgbm90IGluY2x1ZGUgY2hhcmFjdGVycyB0aGF0IHdpbGwgYmUgb3V0cHV0IChzdWNoIGFzIGAxLmAgYW5kIGAtYCBmb3IgbGlzdHMpXG4gIGlmIChtb2RlQ2ZnLmhpZ2hsaWdodEZvcm1hdHRpbmcgPT09IHVuZGVmaW5lZClcbiAgICBtb2RlQ2ZnLmhpZ2hsaWdodEZvcm1hdHRpbmcgPSBmYWxzZTtcblxuICAvLyBNYXhpbXVtIG51bWJlciBvZiBuZXN0ZWQgYmxvY2txdW90ZXMuIFNldCB0byAwIGZvciBpbmZpbml0ZSBuZXN0aW5nLlxuICAvLyBFeGNlc3MgYD5gIHdpbGwgZW1pdCBgZXJyb3JgIHRva2VuLlxuICBpZiAobW9kZUNmZy5tYXhCbG9ja3F1b3RlRGVwdGggPT09IHVuZGVmaW5lZClcbiAgICBtb2RlQ2ZnLm1heEJsb2NrcXVvdGVEZXB0aCA9IDA7XG5cbiAgLy8gU2hvdWxkIHVuZGVyc2NvcmVzIGluIHdvcmRzIG9wZW4vY2xvc2UgZW0vc3Ryb25nP1xuICBpZiAobW9kZUNmZy51bmRlcnNjb3Jlc0JyZWFrV29yZHMgPT09IHVuZGVmaW5lZClcbiAgICBtb2RlQ2ZnLnVuZGVyc2NvcmVzQnJlYWtXb3JkcyA9IHRydWU7XG5cbiAgLy8gVHVybiBvbiBmZW5jZWQgY29kZSBibG9ja3M/IChcImBgYFwiIHRvIHN0YXJ0L2VuZClcbiAgaWYgKG1vZGVDZmcuZmVuY2VkQ29kZUJsb2NrcyA9PT0gdW5kZWZpbmVkKSBtb2RlQ2ZnLmZlbmNlZENvZGVCbG9ja3MgPSBmYWxzZTtcblxuICAvLyBUdXJuIG9uIHRhc2sgbGlzdHM/IChcIi0gWyBdIFwiIGFuZCBcIi0gW3hdIFwiKVxuICBpZiAobW9kZUNmZy50YXNrTGlzdHMgPT09IHVuZGVmaW5lZCkgbW9kZUNmZy50YXNrTGlzdHMgPSBmYWxzZTtcblxuICB2YXIgY29kZURlcHRoID0gMDtcblxuICB2YXIgaGVhZGVyICAgPSAnaGVhZGVyJ1xuICAsICAgY29kZSAgICAgPSAnY29tbWVudCdcbiAgLCAgIHF1b3RlICAgID0gJ3F1b3RlJ1xuICAsICAgbGlzdDEgICAgPSAndmFyaWFibGUtMidcbiAgLCAgIGxpc3QyICAgID0gJ3ZhcmlhYmxlLTMnXG4gICwgICBsaXN0MyAgICA9ICdrZXl3b3JkJ1xuICAsICAgaHIgICAgICAgPSAnaHInXG4gICwgICBpbWFnZSAgICA9ICd0YWcnXG4gICwgICBmb3JtYXR0aW5nID0gJ2Zvcm1hdHRpbmcnXG4gICwgICBsaW5raW5saW5lID0gJ2xpbmsnXG4gICwgICBsaW5rZW1haWwgPSAnbGluaydcbiAgLCAgIGxpbmt0ZXh0ID0gJ2xpbmsnXG4gICwgICBsaW5raHJlZiA9ICdzdHJpbmcnXG4gICwgICBlbSAgICAgICA9ICdlbSdcbiAgLCAgIHN0cm9uZyAgID0gJ3N0cm9uZyc7XG5cbiAgdmFyIGhyUkUgPSAvXihbKlxcLT1fXSkoPzpcXHMqXFwxKXsyLH1cXHMqJC9cbiAgLCAgIHVsUkUgPSAvXlsqXFwtK11cXHMrL1xuICAsICAgb2xSRSA9IC9eWzAtOV0rXFwuXFxzKy9cbiAgLCAgIHRhc2tMaXN0UkUgPSAvXlxcWyh4fCApXFxdKD89XFxzKS8gLy8gTXVzdCBmb2xsb3cgdWxSRSBvciBvbFJFXG4gICwgICBhdHhIZWFkZXJSRSA9IC9eIysvXG4gICwgICBzZXRleHRIZWFkZXJSRSA9IC9eKD86XFw9ezEsfXwtezEsfSkkL1xuICAsICAgdGV4dFJFID0gL15bXiMhXFxbXFxdKl9cXFxcPD5gIFwiJyhdKy87XG5cbiAgZnVuY3Rpb24gc3dpdGNoSW5saW5lKHN0cmVhbSwgc3RhdGUsIGYpIHtcbiAgICBzdGF0ZS5mID0gc3RhdGUuaW5saW5lID0gZjtcbiAgICByZXR1cm4gZihzdHJlYW0sIHN0YXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN3aXRjaEJsb2NrKHN0cmVhbSwgc3RhdGUsIGYpIHtcbiAgICBzdGF0ZS5mID0gc3RhdGUuYmxvY2sgPSBmO1xuICAgIHJldHVybiBmKHN0cmVhbSwgc3RhdGUpO1xuICB9XG5cblxuICAvLyBCbG9ja3NcblxuICBmdW5jdGlvbiBibGFua0xpbmUoc3RhdGUpIHtcbiAgICAvLyBSZXNldCBsaW5rVGl0bGUgc3RhdGVcbiAgICBzdGF0ZS5saW5rVGl0bGUgPSBmYWxzZTtcbiAgICAvLyBSZXNldCBFTSBzdGF0ZVxuICAgIHN0YXRlLmVtID0gZmFsc2U7XG4gICAgLy8gUmVzZXQgU1RST05HIHN0YXRlXG4gICAgc3RhdGUuc3Ryb25nID0gZmFsc2U7XG4gICAgLy8gUmVzZXQgc3RhdGUucXVvdGVcbiAgICBzdGF0ZS5xdW90ZSA9IDA7XG4gICAgaWYgKCFodG1sRm91bmQgJiYgc3RhdGUuZiA9PSBodG1sQmxvY2spIHtcbiAgICAgIHN0YXRlLmYgPSBpbmxpbmVOb3JtYWw7XG4gICAgICBzdGF0ZS5ibG9jayA9IGJsb2NrTm9ybWFsO1xuICAgIH1cbiAgICAvLyBSZXNldCBzdGF0ZS50cmFpbGluZ1NwYWNlXG4gICAgc3RhdGUudHJhaWxpbmdTcGFjZSA9IDA7XG4gICAgc3RhdGUudHJhaWxpbmdTcGFjZU5ld0xpbmUgPSBmYWxzZTtcbiAgICAvLyBNYXJrIHRoaXMgbGluZSBhcyBibGFua1xuICAgIHN0YXRlLnRoaXNMaW5lSGFzQ29udGVudCA9IGZhbHNlO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gYmxvY2tOb3JtYWwoc3RyZWFtLCBzdGF0ZSkge1xuXG4gICAgdmFyIHNvbCA9IHN0cmVhbS5zb2woKTtcblxuICAgIHZhciBwcmV2TGluZUlzTGlzdCA9IChzdGF0ZS5saXN0ICE9PSBmYWxzZSk7XG4gICAgaWYgKHN0YXRlLmxpc3QgIT09IGZhbHNlICYmIHN0YXRlLmluZGVudGF0aW9uRGlmZiA+PSAwKSB7IC8vIENvbnRpbnVlZCBsaXN0XG4gICAgICBpZiAoc3RhdGUuaW5kZW50YXRpb25EaWZmIDwgNCkgeyAvLyBPbmx5IGFkanVzdCBpbmRlbnRhdGlvbiBpZiAqbm90KiBhIGNvZGUgYmxvY2tcbiAgICAgICAgc3RhdGUuaW5kZW50YXRpb24gLT0gc3RhdGUuaW5kZW50YXRpb25EaWZmO1xuICAgICAgfVxuICAgICAgc3RhdGUubGlzdCA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5saXN0ICE9PSBmYWxzZSAmJiBzdGF0ZS5pbmRlbnRhdGlvbiA+IDApIHtcbiAgICAgIHN0YXRlLmxpc3QgPSBudWxsO1xuICAgICAgc3RhdGUubGlzdERlcHRoID0gTWF0aC5mbG9vcihzdGF0ZS5pbmRlbnRhdGlvbiAvIDQpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUubGlzdCAhPT0gZmFsc2UpIHsgLy8gTm8gbG9uZ2VyIGEgbGlzdFxuICAgICAgc3RhdGUubGlzdCA9IGZhbHNlO1xuICAgICAgc3RhdGUubGlzdERlcHRoID0gMDtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2ggPSBudWxsO1xuICAgIGlmIChzdGF0ZS5pbmRlbnRhdGlvbkRpZmYgPj0gNCkge1xuICAgICAgc3RhdGUuaW5kZW50YXRpb24gLT0gNDtcbiAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgIHJldHVybiBjb2RlO1xuICAgIH0gZWxzZSBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAobWF0Y2ggPSBzdHJlYW0ubWF0Y2goYXR4SGVhZGVyUkUpKSB7XG4gICAgICBzdGF0ZS5oZWFkZXIgPSBtYXRjaFswXS5sZW5ndGggPD0gNiA/IG1hdGNoWzBdLmxlbmd0aCA6IDY7XG4gICAgICBpZiAobW9kZUNmZy5oaWdobGlnaHRGb3JtYXR0aW5nKSBzdGF0ZS5mb3JtYXR0aW5nID0gXCJoZWFkZXJcIjtcbiAgICAgIHN0YXRlLmYgPSBzdGF0ZS5pbmxpbmU7XG4gICAgICByZXR1cm4gZ2V0VHlwZShzdGF0ZSk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5wcmV2TGluZUhhc0NvbnRlbnQgJiYgKG1hdGNoID0gc3RyZWFtLm1hdGNoKHNldGV4dEhlYWRlclJFKSkpIHtcbiAgICAgIHN0YXRlLmhlYWRlciA9IG1hdGNoWzBdLmNoYXJBdCgwKSA9PSAnPScgPyAxIDogMjtcbiAgICAgIGlmIChtb2RlQ2ZnLmhpZ2hsaWdodEZvcm1hdHRpbmcpIHN0YXRlLmZvcm1hdHRpbmcgPSBcImhlYWRlclwiO1xuICAgICAgc3RhdGUuZiA9IHN0YXRlLmlubGluZTtcbiAgICAgIHJldHVybiBnZXRUeXBlKHN0YXRlKTtcbiAgICB9IGVsc2UgaWYgKHN0cmVhbS5lYXQoJz4nKSkge1xuICAgICAgc3RhdGUuaW5kZW50YXRpb24rKztcbiAgICAgIHN0YXRlLnF1b3RlID0gc29sID8gMSA6IHN0YXRlLnF1b3RlICsgMTtcbiAgICAgIGlmIChtb2RlQ2ZnLmhpZ2hsaWdodEZvcm1hdHRpbmcpIHN0YXRlLmZvcm1hdHRpbmcgPSBcInF1b3RlXCI7XG4gICAgICBzdHJlYW0uZWF0U3BhY2UoKTtcbiAgICAgIHJldHVybiBnZXRUeXBlKHN0YXRlKTtcbiAgICB9IGVsc2UgaWYgKHN0cmVhbS5wZWVrKCkgPT09ICdbJykge1xuICAgICAgcmV0dXJuIHN3aXRjaElubGluZShzdHJlYW0sIHN0YXRlLCBmb290bm90ZUxpbmspO1xuICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKGhyUkUsIHRydWUpKSB7XG4gICAgICByZXR1cm4gaHI7XG4gICAgfSBlbHNlIGlmICgoIXN0YXRlLnByZXZMaW5lSGFzQ29udGVudCB8fCBwcmV2TGluZUlzTGlzdCkgJiYgKHN0cmVhbS5tYXRjaCh1bFJFLCBmYWxzZSkgfHwgc3RyZWFtLm1hdGNoKG9sUkUsIGZhbHNlKSkpIHtcbiAgICAgIHZhciBsaXN0VHlwZSA9IG51bGw7XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKHVsUkUsIHRydWUpKSB7XG4gICAgICAgIGxpc3RUeXBlID0gJ3VsJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmVhbS5tYXRjaChvbFJFLCB0cnVlKTtcbiAgICAgICAgbGlzdFR5cGUgPSAnb2wnO1xuICAgICAgfVxuICAgICAgc3RhdGUuaW5kZW50YXRpb24gKz0gNDtcbiAgICAgIHN0YXRlLmxpc3QgPSB0cnVlO1xuICAgICAgc3RhdGUubGlzdERlcHRoKys7XG4gICAgICBpZiAobW9kZUNmZy50YXNrTGlzdHMgJiYgc3RyZWFtLm1hdGNoKHRhc2tMaXN0UkUsIGZhbHNlKSkge1xuICAgICAgICBzdGF0ZS50YXNrTGlzdCA9IHRydWU7XG4gICAgICB9XG4gICAgICBzdGF0ZS5mID0gc3RhdGUuaW5saW5lO1xuICAgICAgaWYgKG1vZGVDZmcuaGlnaGxpZ2h0Rm9ybWF0dGluZykgc3RhdGUuZm9ybWF0dGluZyA9IFtcImxpc3RcIiwgXCJsaXN0LVwiICsgbGlzdFR5cGVdO1xuICAgICAgcmV0dXJuIGdldFR5cGUoc3RhdGUpO1xuICAgIH0gZWxzZSBpZiAobW9kZUNmZy5mZW5jZWRDb2RlQmxvY2tzICYmIHN0cmVhbS5tYXRjaCgvXmBgYChbXFx3KyNdKikvLCB0cnVlKSkge1xuICAgICAgLy8gdHJ5IHN3aXRjaGluZyBtb2RlXG4gICAgICBzdGF0ZS5sb2NhbE1vZGUgPSBnZXRNb2RlKFJlZ0V4cC4kMSk7XG4gICAgICBpZiAoc3RhdGUubG9jYWxNb2RlKSBzdGF0ZS5sb2NhbFN0YXRlID0gc3RhdGUubG9jYWxNb2RlLnN0YXJ0U3RhdGUoKTtcbiAgICAgIHN3aXRjaEJsb2NrKHN0cmVhbSwgc3RhdGUsIGxvY2FsKTtcbiAgICAgIGlmIChtb2RlQ2ZnLmhpZ2hsaWdodEZvcm1hdHRpbmcpIHN0YXRlLmZvcm1hdHRpbmcgPSBcImNvZGUtYmxvY2tcIjtcbiAgICAgIHN0YXRlLmNvZGUgPSB0cnVlO1xuICAgICAgcmV0dXJuIGdldFR5cGUoc3RhdGUpO1xuICAgIH1cblxuICAgIHJldHVybiBzd2l0Y2hJbmxpbmUoc3RyZWFtLCBzdGF0ZSwgc3RhdGUuaW5saW5lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGh0bWxCbG9jayhzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIHN0eWxlID0gaHRtbE1vZGUudG9rZW4oc3RyZWFtLCBzdGF0ZS5odG1sU3RhdGUpO1xuICAgIGlmICgoaHRtbEZvdW5kICYmICFzdGF0ZS5odG1sU3RhdGUudGFnTmFtZSAmJiAhc3RhdGUuaHRtbFN0YXRlLmNvbnRleHQpIHx8XG4gICAgICAgIChzdGF0ZS5tZF9pbnNpZGUgJiYgc3RyZWFtLmN1cnJlbnQoKS5pbmRleE9mKFwiPlwiKSA+IC0xKSkge1xuICAgICAgc3RhdGUuZiA9IGlubGluZU5vcm1hbDtcbiAgICAgIHN0YXRlLmJsb2NrID0gYmxvY2tOb3JtYWw7XG4gICAgICBzdGF0ZS5odG1sU3RhdGUgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cblxuICBmdW5jdGlvbiBsb2NhbChzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHN0cmVhbS5zb2woKSAmJiBzdHJlYW0ubWF0Y2goL15gYGAvLCB0cnVlKSkge1xuICAgICAgc3RhdGUubG9jYWxNb2RlID0gc3RhdGUubG9jYWxTdGF0ZSA9IG51bGw7XG4gICAgICBzdGF0ZS5mID0gaW5saW5lTm9ybWFsO1xuICAgICAgc3RhdGUuYmxvY2sgPSBibG9ja05vcm1hbDtcbiAgICAgIGlmIChtb2RlQ2ZnLmhpZ2hsaWdodEZvcm1hdHRpbmcpIHN0YXRlLmZvcm1hdHRpbmcgPSBcImNvZGUtYmxvY2tcIjtcbiAgICAgIHN0YXRlLmNvZGUgPSB0cnVlO1xuICAgICAgdmFyIHJldHVyblR5cGUgPSBnZXRUeXBlKHN0YXRlKTtcbiAgICAgIHN0YXRlLmNvZGUgPSBmYWxzZTtcbiAgICAgIHJldHVybiByZXR1cm5UeXBlO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUubG9jYWxNb2RlKSB7XG4gICAgICByZXR1cm4gc3RhdGUubG9jYWxNb2RlLnRva2VuKHN0cmVhbSwgc3RhdGUubG9jYWxTdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbiAgfVxuXG4gIC8vIElubGluZVxuICBmdW5jdGlvbiBnZXRUeXBlKHN0YXRlKSB7XG4gICAgdmFyIHN0eWxlcyA9IFtdO1xuXG4gICAgaWYgKHN0YXRlLmZvcm1hdHRpbmcpIHtcbiAgICAgIHN0eWxlcy5wdXNoKGZvcm1hdHRpbmcpO1xuXG4gICAgICBpZiAodHlwZW9mIHN0YXRlLmZvcm1hdHRpbmcgPT09IFwic3RyaW5nXCIpIHN0YXRlLmZvcm1hdHRpbmcgPSBbc3RhdGUuZm9ybWF0dGluZ107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUuZm9ybWF0dGluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzdHlsZXMucHVzaChmb3JtYXR0aW5nICsgXCItXCIgKyBzdGF0ZS5mb3JtYXR0aW5nW2ldKTtcblxuICAgICAgICBpZiAoc3RhdGUuZm9ybWF0dGluZ1tpXSA9PT0gXCJoZWFkZXJcIikge1xuICAgICAgICAgIHN0eWxlcy5wdXNoKGZvcm1hdHRpbmcgKyBcIi1cIiArIHN0YXRlLmZvcm1hdHRpbmdbaV0gKyBcIi1cIiArIHN0YXRlLmhlYWRlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgYGZvcm1hdHRpbmctcXVvdGVgIGFuZCBgZm9ybWF0dGluZy1xdW90ZS0jYCBmb3IgYmxvY2txdW90ZXNcbiAgICAgICAgLy8gQWRkIGBlcnJvcmAgaW5zdGVhZCBpZiB0aGUgbWF4aW11bSBibG9ja3F1b3RlIG5lc3RpbmcgZGVwdGggaXMgcGFzc2VkXG4gICAgICAgIGlmIChzdGF0ZS5mb3JtYXR0aW5nW2ldID09PSBcInF1b3RlXCIpIHtcbiAgICAgICAgICBpZiAoIW1vZGVDZmcubWF4QmxvY2txdW90ZURlcHRoIHx8IG1vZGVDZmcubWF4QmxvY2txdW90ZURlcHRoID49IHN0YXRlLnF1b3RlKSB7XG4gICAgICAgICAgICBzdHlsZXMucHVzaChmb3JtYXR0aW5nICsgXCItXCIgKyBzdGF0ZS5mb3JtYXR0aW5nW2ldICsgXCItXCIgKyBzdGF0ZS5xdW90ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlcy5wdXNoKFwiZXJyb3JcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnRhc2tPcGVuKSB7XG4gICAgICBzdHlsZXMucHVzaChcIm1ldGFcIik7XG4gICAgICByZXR1cm4gc3R5bGVzLmxlbmd0aCA/IHN0eWxlcy5qb2luKCcgJykgOiBudWxsO1xuICAgIH1cbiAgICBpZiAoc3RhdGUudGFza0Nsb3NlZCkge1xuICAgICAgc3R5bGVzLnB1c2goXCJwcm9wZXJ0eVwiKTtcbiAgICAgIHJldHVybiBzdHlsZXMubGVuZ3RoID8gc3R5bGVzLmpvaW4oJyAnKSA6IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmxpbmtIcmVmKSB7XG4gICAgICBzdHlsZXMucHVzaChsaW5raHJlZik7XG4gICAgICByZXR1cm4gc3R5bGVzLmxlbmd0aCA/IHN0eWxlcy5qb2luKCcgJykgOiBudWxsO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5zdHJvbmcpIHsgc3R5bGVzLnB1c2goc3Ryb25nKTsgfVxuICAgIGlmIChzdGF0ZS5lbSkgeyBzdHlsZXMucHVzaChlbSk7IH1cblxuICAgIGlmIChzdGF0ZS5saW5rVGV4dCkgeyBzdHlsZXMucHVzaChsaW5rdGV4dCk7IH1cblxuICAgIGlmIChzdGF0ZS5jb2RlKSB7IHN0eWxlcy5wdXNoKGNvZGUpOyB9XG5cbiAgICBpZiAoc3RhdGUuaGVhZGVyKSB7IHN0eWxlcy5wdXNoKGhlYWRlcik7IHN0eWxlcy5wdXNoKGhlYWRlciArIFwiLVwiICsgc3RhdGUuaGVhZGVyKTsgfVxuXG4gICAgaWYgKHN0YXRlLnF1b3RlKSB7XG4gICAgICBzdHlsZXMucHVzaChxdW90ZSk7XG5cbiAgICAgIC8vIEFkZCBgcXVvdGUtI2Agd2hlcmUgdGhlIG1heGltdW0gZm9yIGAjYCBpcyBtb2RlQ2ZnLm1heEJsb2NrcXVvdGVEZXB0aFxuICAgICAgaWYgKCFtb2RlQ2ZnLm1heEJsb2NrcXVvdGVEZXB0aCB8fCBtb2RlQ2ZnLm1heEJsb2NrcXVvdGVEZXB0aCA+PSBzdGF0ZS5xdW90ZSkge1xuICAgICAgICBzdHlsZXMucHVzaChxdW90ZSArIFwiLVwiICsgc3RhdGUucXVvdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGVzLnB1c2gocXVvdGUgKyBcIi1cIiArIG1vZGVDZmcubWF4QmxvY2txdW90ZURlcHRoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RhdGUubGlzdCAhPT0gZmFsc2UpIHtcbiAgICAgIHZhciBsaXN0TW9kID0gKHN0YXRlLmxpc3REZXB0aCAtIDEpICUgMztcbiAgICAgIGlmICghbGlzdE1vZCkge1xuICAgICAgICBzdHlsZXMucHVzaChsaXN0MSk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RNb2QgPT09IDEpIHtcbiAgICAgICAgc3R5bGVzLnB1c2gobGlzdDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGVzLnB1c2gobGlzdDMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdGF0ZS50cmFpbGluZ1NwYWNlTmV3TGluZSkge1xuICAgICAgc3R5bGVzLnB1c2goXCJ0cmFpbGluZy1zcGFjZS1uZXctbGluZVwiKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLnRyYWlsaW5nU3BhY2UpIHtcbiAgICAgIHN0eWxlcy5wdXNoKFwidHJhaWxpbmctc3BhY2UtXCIgKyAoc3RhdGUudHJhaWxpbmdTcGFjZSAlIDIgPyBcImFcIiA6IFwiYlwiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlcy5sZW5ndGggPyBzdHlsZXMuam9pbignICcpIDogbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVRleHQoc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmIChzdHJlYW0ubWF0Y2godGV4dFJFLCB0cnVlKSkge1xuICAgICAgcmV0dXJuIGdldFR5cGUoc3RhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5saW5lTm9ybWFsKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgc3R5bGUgPSBzdGF0ZS50ZXh0KHN0cmVhbSwgc3RhdGUpO1xuICAgIGlmICh0eXBlb2Ygc3R5bGUgIT09ICd1bmRlZmluZWQnKVxuICAgICAgcmV0dXJuIHN0eWxlO1xuXG4gICAgaWYgKHN0YXRlLmxpc3QpIHsgLy8gTGlzdCBtYXJrZXIgKCosICssIC0sIDEuLCBldGMpXG4gICAgICBzdGF0ZS5saXN0ID0gbnVsbDtcbiAgICAgIHJldHVybiBnZXRUeXBlKHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUudGFza0xpc3QpIHtcbiAgICAgIHZhciB0YXNrT3BlbiA9IHN0cmVhbS5tYXRjaCh0YXNrTGlzdFJFLCB0cnVlKVsxXSAhPT0gXCJ4XCI7XG4gICAgICBpZiAodGFza09wZW4pIHN0YXRlLnRhc2tPcGVuID0gdHJ1ZTtcbiAgICAgIGVsc2Ugc3RhdGUudGFza0Nsb3NlZCA9IHRydWU7XG4gICAgICBpZiAobW9kZUNmZy5oaWdobGlnaHRGb3JtYXR0aW5nKSBzdGF0ZS5mb3JtYXR0aW5nID0gXCJ0YXNrXCI7XG4gICAgICBzdGF0ZS50YXNrTGlzdCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGdldFR5cGUoc3RhdGUpO1xuICAgIH1cblxuICAgIHN0YXRlLnRhc2tPcGVuID0gZmFsc2U7XG4gICAgc3RhdGUudGFza0Nsb3NlZCA9IGZhbHNlO1xuXG4gICAgaWYgKHN0YXRlLmhlYWRlciAmJiBzdHJlYW0ubWF0Y2goL14jKyQvLCB0cnVlKSkge1xuICAgICAgaWYgKG1vZGVDZmcuaGlnaGxpZ2h0Rm9ybWF0dGluZykgc3RhdGUuZm9ybWF0dGluZyA9IFwiaGVhZGVyXCI7XG4gICAgICByZXR1cm4gZ2V0VHlwZShzdGF0ZSk7XG4gICAgfVxuXG4gICAgLy8gR2V0IHNvbCgpIHZhbHVlIG5vdywgYmVmb3JlIGNoYXJhY3RlciBpcyBjb25zdW1lZFxuICAgIHZhciBzb2wgPSBzdHJlYW0uc29sKCk7XG5cbiAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuXG4gICAgaWYgKHN0YXRlLmVzY2FwZSkge1xuICAgICAgc3RhdGUuZXNjYXBlID0gZmFsc2U7XG4gICAgICByZXR1cm4gZ2V0VHlwZShzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKGNoID09PSAnXFxcXCcpIHtcbiAgICAgIGlmIChtb2RlQ2ZnLmhpZ2hsaWdodEZvcm1hdHRpbmcpIHN0YXRlLmZvcm1hdHRpbmcgPSBcImVzY2FwZVwiO1xuICAgICAgc3RhdGUuZXNjYXBlID0gdHJ1ZTtcbiAgICAgIHJldHVybiBnZXRUeXBlKHN0YXRlKTtcbiAgICB9XG5cbiAgICAvLyBNYXRjaGVzIGxpbmsgdGl0bGVzIHByZXNlbnQgb24gbmV4dCBsaW5lXG4gICAgaWYgKHN0YXRlLmxpbmtUaXRsZSkge1xuICAgICAgc3RhdGUubGlua1RpdGxlID0gZmFsc2U7XG4gICAgICB2YXIgbWF0Y2hDaCA9IGNoO1xuICAgICAgaWYgKGNoID09PSAnKCcpIHtcbiAgICAgICAgbWF0Y2hDaCA9ICcpJztcbiAgICAgIH1cbiAgICAgIG1hdGNoQ2ggPSAobWF0Y2hDaCsnJykucmVwbGFjZSgvKFsuPyorXiRbXFxdXFxcXCgpe318LV0pL2csIFwiXFxcXCQxXCIpO1xuICAgICAgdmFyIHJlZ2V4ID0gJ15cXFxccyooPzpbXicgKyBtYXRjaENoICsgJ1xcXFxcXFxcXSt8XFxcXFxcXFxcXFxcXFxcXHxcXFxcXFxcXC4pJyArIG1hdGNoQ2g7XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKG5ldyBSZWdFeHAocmVnZXgpLCB0cnVlKSkge1xuICAgICAgICByZXR1cm4gbGlua2hyZWY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhpcyBibG9jayBpcyBjaGFuZ2VkLCBpdCBtYXkgbmVlZCB0byBiZSB1cGRhdGVkIGluIEdGTSBtb2RlXG4gICAgaWYgKGNoID09PSAnYCcpIHtcbiAgICAgIHZhciBwcmV2aW91c0Zvcm1hdHRpbmcgPSBzdGF0ZS5mb3JtYXR0aW5nO1xuICAgICAgaWYgKG1vZGVDZmcuaGlnaGxpZ2h0Rm9ybWF0dGluZykgc3RhdGUuZm9ybWF0dGluZyA9IFwiY29kZVwiO1xuICAgICAgdmFyIHQgPSBnZXRUeXBlKHN0YXRlKTtcbiAgICAgIHZhciBiZWZvcmUgPSBzdHJlYW0ucG9zO1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKCdgJyk7XG4gICAgICB2YXIgZGlmZmVyZW5jZSA9IDEgKyBzdHJlYW0ucG9zIC0gYmVmb3JlO1xuICAgICAgaWYgKCFzdGF0ZS5jb2RlKSB7XG4gICAgICAgIGNvZGVEZXB0aCA9IGRpZmZlcmVuY2U7XG4gICAgICAgIHN0YXRlLmNvZGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZ2V0VHlwZShzdGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZGlmZmVyZW5jZSA9PT0gY29kZURlcHRoKSB7IC8vIE11c3QgYmUgZXhhY3RcbiAgICAgICAgICBzdGF0ZS5jb2RlID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZm9ybWF0dGluZyA9IHByZXZpb3VzRm9ybWF0dGluZztcbiAgICAgICAgcmV0dXJuIGdldFR5cGUoc3RhdGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3RhdGUuY29kZSkge1xuICAgICAgcmV0dXJuIGdldFR5cGUoc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChjaCA9PT0gJyEnICYmIHN0cmVhbS5tYXRjaCgvXFxbW15cXF1dKlxcXSA/KD86XFwofFxcWykvLCBmYWxzZSkpIHtcbiAgICAgIHN0cmVhbS5tYXRjaCgvXFxbW15cXF1dKlxcXS8pO1xuICAgICAgc3RhdGUuaW5saW5lID0gc3RhdGUuZiA9IGxpbmtIcmVmO1xuICAgICAgcmV0dXJuIGltYWdlO1xuICAgIH1cblxuICAgIGlmIChjaCA9PT0gJ1snICYmIHN0cmVhbS5tYXRjaCgvLipcXF0oXFwofCA/XFxbKS8sIGZhbHNlKSkge1xuICAgICAgc3RhdGUubGlua1RleHQgPSB0cnVlO1xuICAgICAgaWYgKG1vZGVDZmcuaGlnaGxpZ2h0Rm9ybWF0dGluZykgc3RhdGUuZm9ybWF0dGluZyA9IFwibGlua1wiO1xuICAgICAgcmV0dXJuIGdldFR5cGUoc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChjaCA9PT0gJ10nICYmIHN0YXRlLmxpbmtUZXh0KSB7XG4gICAgICBpZiAobW9kZUNmZy5oaWdobGlnaHRGb3JtYXR0aW5nKSBzdGF0ZS5mb3JtYXR0aW5nID0gXCJsaW5rXCI7XG4gICAgICB2YXIgdHlwZSA9IGdldFR5cGUoc3RhdGUpO1xuICAgICAgc3RhdGUubGlua1RleHQgPSBmYWxzZTtcbiAgICAgIHN0YXRlLmlubGluZSA9IHN0YXRlLmYgPSBsaW5rSHJlZjtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cblxuICAgIGlmIChjaCA9PT0gJzwnICYmIHN0cmVhbS5tYXRjaCgvXihodHRwcz98ZnRwcz8pOlxcL1xcLyg/OlteXFxcXD5dfFxcXFwuKSs+LywgZmFsc2UpKSB7XG4gICAgICBzdGF0ZS5mID0gc3RhdGUuaW5saW5lID0gbGlua0lubGluZTtcbiAgICAgIGlmIChtb2RlQ2ZnLmhpZ2hsaWdodEZvcm1hdHRpbmcpIHN0YXRlLmZvcm1hdHRpbmcgPSBcImxpbmtcIjtcbiAgICAgIHZhciB0eXBlID0gZ2V0VHlwZShzdGF0ZSk7XG4gICAgICBpZiAodHlwZSl7XG4gICAgICAgIHR5cGUgKz0gXCIgXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlID0gXCJcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlICsgbGlua2lubGluZTtcbiAgICB9XG5cbiAgICBpZiAoY2ggPT09ICc8JyAmJiBzdHJlYW0ubWF0Y2goL15bXj4gXFxcXF0rQCg/OlteXFxcXD5dfFxcXFwuKSs+LywgZmFsc2UpKSB7XG4gICAgICBzdGF0ZS5mID0gc3RhdGUuaW5saW5lID0gbGlua0lubGluZTtcbiAgICAgIGlmIChtb2RlQ2ZnLmhpZ2hsaWdodEZvcm1hdHRpbmcpIHN0YXRlLmZvcm1hdHRpbmcgPSBcImxpbmtcIjtcbiAgICAgIHZhciB0eXBlID0gZ2V0VHlwZShzdGF0ZSk7XG4gICAgICBpZiAodHlwZSl7XG4gICAgICAgIHR5cGUgKz0gXCIgXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlID0gXCJcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlICsgbGlua2VtYWlsO1xuICAgIH1cblxuICAgIGlmIChjaCA9PT0gJzwnICYmIHN0cmVhbS5tYXRjaCgvXlxcdy8sIGZhbHNlKSkge1xuICAgICAgaWYgKHN0cmVhbS5zdHJpbmcuaW5kZXhPZihcIj5cIikgIT0gLTEpIHtcbiAgICAgICAgdmFyIGF0dHMgPSBzdHJlYW0uc3RyaW5nLnN1YnN0cmluZygxLHN0cmVhbS5zdHJpbmcuaW5kZXhPZihcIj5cIikpO1xuICAgICAgICBpZiAoL21hcmtkb3duXFxzKj1cXHMqKCd8XCIpezAsMX0xKCd8XCIpezAsMX0vLnRlc3QoYXR0cykpIHtcbiAgICAgICAgICBzdGF0ZS5tZF9pbnNpZGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdHJlYW0uYmFja1VwKDEpO1xuICAgICAgc3RhdGUuaHRtbFN0YXRlID0gQ29kZU1pcnJvci5zdGFydFN0YXRlKGh0bWxNb2RlKTtcbiAgICAgIHJldHVybiBzd2l0Y2hCbG9jayhzdHJlYW0sIHN0YXRlLCBodG1sQmxvY2spO1xuICAgIH1cblxuICAgIGlmIChjaCA9PT0gJzwnICYmIHN0cmVhbS5tYXRjaCgvXlxcL1xcdyo/Pi8pKSB7XG4gICAgICBzdGF0ZS5tZF9pbnNpZGUgPSBmYWxzZTtcbiAgICAgIHJldHVybiBcInRhZ1wiO1xuICAgIH1cblxuICAgIHZhciBpZ25vcmVVbmRlcnNjb3JlID0gZmFsc2U7XG4gICAgaWYgKCFtb2RlQ2ZnLnVuZGVyc2NvcmVzQnJlYWtXb3Jkcykge1xuICAgICAgaWYgKGNoID09PSAnXycgJiYgc3RyZWFtLnBlZWsoKSAhPT0gJ18nICYmIHN0cmVhbS5tYXRjaCgvKFxcdykvLCBmYWxzZSkpIHtcbiAgICAgICAgdmFyIHByZXZQb3MgPSBzdHJlYW0ucG9zIC0gMjtcbiAgICAgICAgaWYgKHByZXZQb3MgPj0gMCkge1xuICAgICAgICAgIHZhciBwcmV2Q2ggPSBzdHJlYW0uc3RyaW5nLmNoYXJBdChwcmV2UG9zKTtcbiAgICAgICAgICBpZiAocHJldkNoICE9PSAnXycgJiYgcHJldkNoLm1hdGNoKC8oXFx3KS8sIGZhbHNlKSkge1xuICAgICAgICAgICAgaWdub3JlVW5kZXJzY29yZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjaCA9PT0gJyonIHx8IChjaCA9PT0gJ18nICYmICFpZ25vcmVVbmRlcnNjb3JlKSkge1xuICAgICAgaWYgKHNvbCAmJiBzdHJlYW0ucGVlaygpID09PSAnICcpIHtcbiAgICAgICAgLy8gRG8gbm90aGluZywgc3Vycm91bmRlZCBieSBuZXdsaW5lIGFuZCBzcGFjZVxuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5zdHJvbmcgPT09IGNoICYmIHN0cmVhbS5lYXQoY2gpKSB7IC8vIFJlbW92ZSBTVFJPTkdcbiAgICAgICAgaWYgKG1vZGVDZmcuaGlnaGxpZ2h0Rm9ybWF0dGluZykgc3RhdGUuZm9ybWF0dGluZyA9IFwic3Ryb25nXCI7XG4gICAgICAgIHZhciB0ID0gZ2V0VHlwZShzdGF0ZSk7XG4gICAgICAgIHN0YXRlLnN0cm9uZyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdDtcbiAgICAgIH0gZWxzZSBpZiAoIXN0YXRlLnN0cm9uZyAmJiBzdHJlYW0uZWF0KGNoKSkgeyAvLyBBZGQgU1RST05HXG4gICAgICAgIHN0YXRlLnN0cm9uZyA9IGNoO1xuICAgICAgICBpZiAobW9kZUNmZy5oaWdobGlnaHRGb3JtYXR0aW5nKSBzdGF0ZS5mb3JtYXR0aW5nID0gXCJzdHJvbmdcIjtcbiAgICAgICAgcmV0dXJuIGdldFR5cGUoc3RhdGUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5lbSA9PT0gY2gpIHsgLy8gUmVtb3ZlIEVNXG4gICAgICAgIGlmIChtb2RlQ2ZnLmhpZ2hsaWdodEZvcm1hdHRpbmcpIHN0YXRlLmZvcm1hdHRpbmcgPSBcImVtXCI7XG4gICAgICAgIHZhciB0ID0gZ2V0VHlwZShzdGF0ZSk7XG4gICAgICAgIHN0YXRlLmVtID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0O1xuICAgICAgfSBlbHNlIGlmICghc3RhdGUuZW0pIHsgLy8gQWRkIEVNXG4gICAgICAgIHN0YXRlLmVtID0gY2g7XG4gICAgICAgIGlmIChtb2RlQ2ZnLmhpZ2hsaWdodEZvcm1hdHRpbmcpIHN0YXRlLmZvcm1hdHRpbmcgPSBcImVtXCI7XG4gICAgICAgIHJldHVybiBnZXRUeXBlKHN0YXRlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNoID09PSAnICcpIHtcbiAgICAgIGlmIChzdHJlYW0uZWF0KCcqJykgfHwgc3RyZWFtLmVhdCgnXycpKSB7IC8vIFByb2JhYmx5IHN1cnJvdW5kZWQgYnkgc3BhY2VzXG4gICAgICAgIGlmIChzdHJlYW0ucGVlaygpID09PSAnICcpIHsgLy8gU3Vycm91bmRlZCBieSBzcGFjZXMsIGlnbm9yZVxuICAgICAgICAgIHJldHVybiBnZXRUeXBlKHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gTm90IHN1cnJvdW5kZWQgYnkgc3BhY2VzLCBiYWNrIHVwIHBvaW50ZXJcbiAgICAgICAgICBzdHJlYW0uYmFja1VwKDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNoID09PSAnICcpIHtcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goLyArJC8sIGZhbHNlKSkge1xuICAgICAgICBzdGF0ZS50cmFpbGluZ1NwYWNlKys7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLnRyYWlsaW5nU3BhY2UpIHtcbiAgICAgICAgc3RhdGUudHJhaWxpbmdTcGFjZU5ld0xpbmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBnZXRUeXBlKHN0YXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpbmtJbmxpbmUoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG5cbiAgICBpZiAoY2ggPT09IFwiPlwiKSB7XG4gICAgICBzdGF0ZS5mID0gc3RhdGUuaW5saW5lID0gaW5saW5lTm9ybWFsO1xuICAgICAgaWYgKG1vZGVDZmcuaGlnaGxpZ2h0Rm9ybWF0dGluZykgc3RhdGUuZm9ybWF0dGluZyA9IFwibGlua1wiO1xuICAgICAgdmFyIHR5cGUgPSBnZXRUeXBlKHN0YXRlKTtcbiAgICAgIGlmICh0eXBlKXtcbiAgICAgICAgdHlwZSArPSBcIiBcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGUgPSBcIlwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGUgKyBsaW5raW5saW5lO1xuICAgIH1cblxuICAgIHN0cmVhbS5tYXRjaCgvXltePl0rLywgdHJ1ZSk7XG5cbiAgICByZXR1cm4gbGlua2lubGluZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpbmtIcmVmKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAvLyBDaGVjayBpZiBzcGFjZSwgYW5kIHJldHVybiBOVUxMIGlmIHNvICh0byBhdm9pZCBtYXJraW5nIHRoZSBzcGFjZSlcbiAgICBpZihzdHJlYW0uZWF0U3BhY2UoKSl7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGNoID0gc3RyZWFtLm5leHQoKTtcbiAgICBpZiAoY2ggPT09ICcoJyB8fCBjaCA9PT0gJ1snKSB7XG4gICAgICBzdGF0ZS5mID0gc3RhdGUuaW5saW5lID0gZ2V0TGlua0hyZWZJbnNpZGUoY2ggPT09IFwiKFwiID8gXCIpXCIgOiBcIl1cIik7XG4gICAgICBpZiAobW9kZUNmZy5oaWdobGlnaHRGb3JtYXR0aW5nKSBzdGF0ZS5mb3JtYXR0aW5nID0gXCJsaW5rLXN0cmluZ1wiO1xuICAgICAgc3RhdGUubGlua0hyZWYgPSB0cnVlO1xuICAgICAgcmV0dXJuIGdldFR5cGUoc3RhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gJ2Vycm9yJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldExpbmtIcmVmSW5zaWRlKGVuZENoYXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIGNoID0gc3RyZWFtLm5leHQoKTtcblxuICAgICAgaWYgKGNoID09PSBlbmRDaGFyKSB7XG4gICAgICAgIHN0YXRlLmYgPSBzdGF0ZS5pbmxpbmUgPSBpbmxpbmVOb3JtYWw7XG4gICAgICAgIGlmIChtb2RlQ2ZnLmhpZ2hsaWdodEZvcm1hdHRpbmcpIHN0YXRlLmZvcm1hdHRpbmcgPSBcImxpbmstc3RyaW5nXCI7XG4gICAgICAgIHZhciByZXR1cm5TdGF0ZSA9IGdldFR5cGUoc3RhdGUpO1xuICAgICAgICBzdGF0ZS5saW5rSHJlZiA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gcmV0dXJuU3RhdGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goaW5saW5lUkUoZW5kQ2hhciksIHRydWUpKSB7XG4gICAgICAgIHN0cmVhbS5iYWNrVXAoMSk7XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLmxpbmtIcmVmID0gdHJ1ZTtcbiAgICAgIHJldHVybiBnZXRUeXBlKHN0YXRlKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZm9vdG5vdGVMaW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RyZWFtLm1hdGNoKC9eW15cXF1dKlxcXTovLCBmYWxzZSkpIHtcbiAgICAgIHN0YXRlLmYgPSBmb290bm90ZUxpbmtJbnNpZGU7XG4gICAgICBzdHJlYW0ubmV4dCgpOyAvLyBDb25zdW1lIFtcbiAgICAgIGlmIChtb2RlQ2ZnLmhpZ2hsaWdodEZvcm1hdHRpbmcpIHN0YXRlLmZvcm1hdHRpbmcgPSBcImxpbmtcIjtcbiAgICAgIHN0YXRlLmxpbmtUZXh0ID0gdHJ1ZTtcbiAgICAgIHJldHVybiBnZXRUeXBlKHN0YXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN3aXRjaElubGluZShzdHJlYW0sIHN0YXRlLCBpbmxpbmVOb3JtYWwpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9vdG5vdGVMaW5rSW5zaWRlKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RyZWFtLm1hdGNoKC9eXFxdOi8sIHRydWUpKSB7XG4gICAgICBzdGF0ZS5mID0gc3RhdGUuaW5saW5lID0gZm9vdG5vdGVVcmw7XG4gICAgICBpZiAobW9kZUNmZy5oaWdobGlnaHRGb3JtYXR0aW5nKSBzdGF0ZS5mb3JtYXR0aW5nID0gXCJsaW5rXCI7XG4gICAgICB2YXIgcmV0dXJuVHlwZSA9IGdldFR5cGUoc3RhdGUpO1xuICAgICAgc3RhdGUubGlua1RleHQgPSBmYWxzZTtcbiAgICAgIHJldHVybiByZXR1cm5UeXBlO1xuICAgIH1cblxuICAgIHN0cmVhbS5tYXRjaCgvXlteXFxdXSsvLCB0cnVlKTtcblxuICAgIHJldHVybiBsaW5rdGV4dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvb3Rub3RlVXJsKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAvLyBDaGVjayBpZiBzcGFjZSwgYW5kIHJldHVybiBOVUxMIGlmIHNvICh0byBhdm9pZCBtYXJraW5nIHRoZSBzcGFjZSlcbiAgICBpZihzdHJlYW0uZWF0U3BhY2UoKSl7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gTWF0Y2ggVVJMXG4gICAgc3RyZWFtLm1hdGNoKC9eW15cXHNdKy8sIHRydWUpO1xuICAgIC8vIENoZWNrIGZvciBsaW5rIHRpdGxlXG4gICAgaWYgKHN0cmVhbS5wZWVrKCkgPT09IHVuZGVmaW5lZCkgeyAvLyBFbmQgb2YgbGluZSwgc2V0IGZsYWcgdG8gY2hlY2sgbmV4dCBsaW5lXG4gICAgICBzdGF0ZS5saW5rVGl0bGUgPSB0cnVlO1xuICAgIH0gZWxzZSB7IC8vIE1vcmUgY29udGVudCBvbiBsaW5lLCBjaGVjayBpZiBsaW5rIHRpdGxlXG4gICAgICBzdHJlYW0ubWF0Y2goL14oPzpcXHMrKD86XCIoPzpbXlwiXFxcXF18XFxcXFxcXFx8XFxcXC4pK1wifCcoPzpbXidcXFxcXXxcXFxcXFxcXHxcXFxcLikrJ3xcXCgoPzpbXilcXFxcXXxcXFxcXFxcXHxcXFxcLikrXFwpKSk/LywgdHJ1ZSk7XG4gICAgfVxuICAgIHN0YXRlLmYgPSBzdGF0ZS5pbmxpbmUgPSBpbmxpbmVOb3JtYWw7XG4gICAgcmV0dXJuIGxpbmtocmVmO1xuICB9XG5cbiAgdmFyIHNhdmVkSW5saW5lUkUgPSBbXTtcbiAgZnVuY3Rpb24gaW5saW5lUkUoZW5kQ2hhcikge1xuICAgIGlmICghc2F2ZWRJbmxpbmVSRVtlbmRDaGFyXSkge1xuICAgICAgLy8gRXNjYXBlIGVuZENoYXIgZm9yIFJlZ0V4cCAodGFrZW4gZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80OTQxMjIvNTI2NzQxKVxuICAgICAgZW5kQ2hhciA9IChlbmRDaGFyKycnKS5yZXBsYWNlKC8oWy4/KiteJFtcXF1cXFxcKCl7fXwtXSkvZywgXCJcXFxcJDFcIik7XG4gICAgICAvLyBNYXRjaCBhbnkgbm9uLWVuZENoYXIsIGVzY2FwZWQgY2hhcmFjdGVyLCBhcyB3ZWxsIGFzIHRoZSBjbG9zaW5nXG4gICAgICAvLyBlbmRDaGFyLlxuICAgICAgc2F2ZWRJbmxpbmVSRVtlbmRDaGFyXSA9IG5ldyBSZWdFeHAoJ14oPzpbXlxcXFxcXFxcXXxcXFxcXFxcXC4pKj8oJyArIGVuZENoYXIgKyAnKScpO1xuICAgIH1cbiAgICByZXR1cm4gc2F2ZWRJbmxpbmVSRVtlbmRDaGFyXTtcbiAgfVxuXG4gIHZhciBtb2RlID0ge1xuICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZjogYmxvY2tOb3JtYWwsXG5cbiAgICAgICAgcHJldkxpbmVIYXNDb250ZW50OiBmYWxzZSxcbiAgICAgICAgdGhpc0xpbmVIYXNDb250ZW50OiBmYWxzZSxcblxuICAgICAgICBibG9jazogYmxvY2tOb3JtYWwsXG4gICAgICAgIGh0bWxTdGF0ZTogbnVsbCxcbiAgICAgICAgaW5kZW50YXRpb246IDAsXG5cbiAgICAgICAgaW5saW5lOiBpbmxpbmVOb3JtYWwsXG4gICAgICAgIHRleHQ6IGhhbmRsZVRleHQsXG5cbiAgICAgICAgZXNjYXBlOiBmYWxzZSxcbiAgICAgICAgZm9ybWF0dGluZzogZmFsc2UsXG4gICAgICAgIGxpbmtUZXh0OiBmYWxzZSxcbiAgICAgICAgbGlua0hyZWY6IGZhbHNlLFxuICAgICAgICBsaW5rVGl0bGU6IGZhbHNlLFxuICAgICAgICBlbTogZmFsc2UsXG4gICAgICAgIHN0cm9uZzogZmFsc2UsXG4gICAgICAgIGhlYWRlcjogMCxcbiAgICAgICAgdGFza0xpc3Q6IGZhbHNlLFxuICAgICAgICBsaXN0OiBmYWxzZSxcbiAgICAgICAgbGlzdERlcHRoOiAwLFxuICAgICAgICBxdW90ZTogMCxcbiAgICAgICAgdHJhaWxpbmdTcGFjZTogMCxcbiAgICAgICAgdHJhaWxpbmdTcGFjZU5ld0xpbmU6IGZhbHNlXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICBjb3B5U3RhdGU6IGZ1bmN0aW9uKHMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGY6IHMuZixcblxuICAgICAgICBwcmV2TGluZUhhc0NvbnRlbnQ6IHMucHJldkxpbmVIYXNDb250ZW50LFxuICAgICAgICB0aGlzTGluZUhhc0NvbnRlbnQ6IHMudGhpc0xpbmVIYXNDb250ZW50LFxuXG4gICAgICAgIGJsb2NrOiBzLmJsb2NrLFxuICAgICAgICBodG1sU3RhdGU6IHMuaHRtbFN0YXRlICYmIENvZGVNaXJyb3IuY29weVN0YXRlKGh0bWxNb2RlLCBzLmh0bWxTdGF0ZSksXG4gICAgICAgIGluZGVudGF0aW9uOiBzLmluZGVudGF0aW9uLFxuXG4gICAgICAgIGxvY2FsTW9kZTogcy5sb2NhbE1vZGUsXG4gICAgICAgIGxvY2FsU3RhdGU6IHMubG9jYWxNb2RlID8gQ29kZU1pcnJvci5jb3B5U3RhdGUocy5sb2NhbE1vZGUsIHMubG9jYWxTdGF0ZSkgOiBudWxsLFxuXG4gICAgICAgIGlubGluZTogcy5pbmxpbmUsXG4gICAgICAgIHRleHQ6IHMudGV4dCxcbiAgICAgICAgZXNjYXBlOiBmYWxzZSxcbiAgICAgICAgZm9ybWF0dGluZzogZmFsc2UsXG4gICAgICAgIGxpbmtUaXRsZTogcy5saW5rVGl0bGUsXG4gICAgICAgIGVtOiBzLmVtLFxuICAgICAgICBzdHJvbmc6IHMuc3Ryb25nLFxuICAgICAgICBoZWFkZXI6IHMuaGVhZGVyLFxuICAgICAgICB0YXNrTGlzdDogcy50YXNrTGlzdCxcbiAgICAgICAgbGlzdDogcy5saXN0LFxuICAgICAgICBsaXN0RGVwdGg6IHMubGlzdERlcHRoLFxuICAgICAgICBxdW90ZTogcy5xdW90ZSxcbiAgICAgICAgdHJhaWxpbmdTcGFjZTogcy50cmFpbGluZ1NwYWNlLFxuICAgICAgICB0cmFpbGluZ1NwYWNlTmV3TGluZTogcy50cmFpbGluZ1NwYWNlTmV3TGluZSxcbiAgICAgICAgbWRfaW5zaWRlOiBzLm1kX2luc2lkZVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcblxuICAgICAgLy8gUmVzZXQgc3RhdGUuZm9ybWF0dGluZ1xuICAgICAgc3RhdGUuZm9ybWF0dGluZyA9IGZhbHNlO1xuXG4gICAgICBpZiAoc3RyZWFtLnNvbCgpKSB7XG4gICAgICAgIHZhciBmb3JjZUJsYW5rTGluZSA9IHN0cmVhbS5tYXRjaCgvXlxccyokLywgdHJ1ZSkgfHwgc3RhdGUuaGVhZGVyO1xuXG4gICAgICAgIC8vIFJlc2V0IHN0YXRlLmhlYWRlclxuICAgICAgICBzdGF0ZS5oZWFkZXIgPSAwO1xuXG4gICAgICAgIGlmIChmb3JjZUJsYW5rTGluZSkge1xuICAgICAgICAgIHN0YXRlLnByZXZMaW5lSGFzQ29udGVudCA9IGZhbHNlO1xuICAgICAgICAgIGJsYW5rTGluZShzdGF0ZSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG9rZW4oc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUucHJldkxpbmVIYXNDb250ZW50ID0gc3RhdGUudGhpc0xpbmVIYXNDb250ZW50O1xuICAgICAgICAgIHN0YXRlLnRoaXNMaW5lSGFzQ29udGVudCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXNldCBzdGF0ZS5lc2NhcGVcbiAgICAgICAgc3RhdGUuZXNjYXBlID0gZmFsc2U7XG5cbiAgICAgICAgLy8gUmVzZXQgc3RhdGUudGFza0xpc3RcbiAgICAgICAgc3RhdGUudGFza0xpc3QgPSBmYWxzZTtcblxuICAgICAgICAvLyBSZXNldCBzdGF0ZS5jb2RlXG4gICAgICAgIHN0YXRlLmNvZGUgPSBmYWxzZTtcblxuICAgICAgICAvLyBSZXNldCBzdGF0ZS50cmFpbGluZ1NwYWNlXG4gICAgICAgIHN0YXRlLnRyYWlsaW5nU3BhY2UgPSAwO1xuICAgICAgICBzdGF0ZS50cmFpbGluZ1NwYWNlTmV3TGluZSA9IGZhbHNlO1xuXG4gICAgICAgIHN0YXRlLmYgPSBzdGF0ZS5ibG9jaztcbiAgICAgICAgdmFyIGluZGVudGF0aW9uID0gc3RyZWFtLm1hdGNoKC9eXFxzKi8sIHRydWUpWzBdLnJlcGxhY2UoL1xcdC9nLCAnICAgICcpLmxlbmd0aDtcbiAgICAgICAgdmFyIGRpZmZlcmVuY2UgPSBNYXRoLmZsb29yKChpbmRlbnRhdGlvbiAtIHN0YXRlLmluZGVudGF0aW9uKSAvIDQpICogNDtcbiAgICAgICAgaWYgKGRpZmZlcmVuY2UgPiA0KSBkaWZmZXJlbmNlID0gNDtcbiAgICAgICAgdmFyIGFkanVzdGVkSW5kZW50YXRpb24gPSBzdGF0ZS5pbmRlbnRhdGlvbiArIGRpZmZlcmVuY2U7XG4gICAgICAgIHN0YXRlLmluZGVudGF0aW9uRGlmZiA9IGFkanVzdGVkSW5kZW50YXRpb24gLSBzdGF0ZS5pbmRlbnRhdGlvbjtcbiAgICAgICAgc3RhdGUuaW5kZW50YXRpb24gPSBhZGp1c3RlZEluZGVudGF0aW9uO1xuICAgICAgICBpZiAoaW5kZW50YXRpb24gPiAwKSByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBzdGF0ZS5mKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgaWYgKHN0cmVhbS5zdGFydCA9PSBzdHJlYW0ucG9zKSByZXR1cm4gdGhpcy50b2tlbihzdHJlYW0sIHN0YXRlKTtcbiAgICAgIGVsc2UgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgaW5uZXJNb2RlOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgaWYgKHN0YXRlLmJsb2NrID09IGh0bWxCbG9jaykgcmV0dXJuIHtzdGF0ZTogc3RhdGUuaHRtbFN0YXRlLCBtb2RlOiBodG1sTW9kZX07XG4gICAgICBpZiAoc3RhdGUubG9jYWxTdGF0ZSkgcmV0dXJuIHtzdGF0ZTogc3RhdGUubG9jYWxTdGF0ZSwgbW9kZTogc3RhdGUubG9jYWxNb2RlfTtcbiAgICAgIHJldHVybiB7c3RhdGU6IHN0YXRlLCBtb2RlOiBtb2RlfTtcbiAgICB9LFxuXG4gICAgYmxhbmtMaW5lOiBibGFua0xpbmUsXG5cbiAgICBnZXRUeXBlOiBnZXRUeXBlLFxuXG4gICAgZm9sZDogXCJtYXJrZG93blwiXG4gIH07XG4gIHJldHVybiBtb2RlO1xufSwgXCJ4bWxcIik7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQveC1tYXJrZG93blwiLCBcIm1hcmtkb3duXCIpO1xuXG59KTtcbiIsIihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwieG1sXCIsIGZ1bmN0aW9uKGNvbmZpZywgcGFyc2VyQ29uZmlnKSB7XG4gIHZhciBpbmRlbnRVbml0ID0gY29uZmlnLmluZGVudFVuaXQ7XG4gIHZhciBtdWx0aWxpbmVUYWdJbmRlbnRGYWN0b3IgPSBwYXJzZXJDb25maWcubXVsdGlsaW5lVGFnSW5kZW50RmFjdG9yIHx8IDE7XG4gIHZhciBtdWx0aWxpbmVUYWdJbmRlbnRQYXN0VGFnID0gcGFyc2VyQ29uZmlnLm11bHRpbGluZVRhZ0luZGVudFBhc3RUYWc7XG4gIGlmIChtdWx0aWxpbmVUYWdJbmRlbnRQYXN0VGFnID09IG51bGwpIG11bHRpbGluZVRhZ0luZGVudFBhc3RUYWcgPSB0cnVlO1xuXG4gIHZhciBLbHVkZ2VzID0gcGFyc2VyQ29uZmlnLmh0bWxNb2RlID8ge1xuICAgIGF1dG9TZWxmQ2xvc2VyczogeydhcmVhJzogdHJ1ZSwgJ2Jhc2UnOiB0cnVlLCAnYnInOiB0cnVlLCAnY29sJzogdHJ1ZSwgJ2NvbW1hbmQnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICdlbWJlZCc6IHRydWUsICdmcmFtZSc6IHRydWUsICdocic6IHRydWUsICdpbWcnOiB0cnVlLCAnaW5wdXQnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICdrZXlnZW4nOiB0cnVlLCAnbGluayc6IHRydWUsICdtZXRhJzogdHJ1ZSwgJ3BhcmFtJzogdHJ1ZSwgJ3NvdXJjZSc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgJ3RyYWNrJzogdHJ1ZSwgJ3dicic6IHRydWV9LFxuICAgIGltcGxpY2l0bHlDbG9zZWQ6IHsnZGQnOiB0cnVlLCAnbGknOiB0cnVlLCAnb3B0Z3JvdXAnOiB0cnVlLCAnb3B0aW9uJzogdHJ1ZSwgJ3AnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAncnAnOiB0cnVlLCAncnQnOiB0cnVlLCAndGJvZHknOiB0cnVlLCAndGQnOiB0cnVlLCAndGZvb3QnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAndGgnOiB0cnVlLCAndHInOiB0cnVlfSxcbiAgICBjb250ZXh0R3JhYmJlcnM6IHtcbiAgICAgICdkZCc6IHsnZGQnOiB0cnVlLCAnZHQnOiB0cnVlfSxcbiAgICAgICdkdCc6IHsnZGQnOiB0cnVlLCAnZHQnOiB0cnVlfSxcbiAgICAgICdsaSc6IHsnbGknOiB0cnVlfSxcbiAgICAgICdvcHRpb24nOiB7J29wdGlvbic6IHRydWUsICdvcHRncm91cCc6IHRydWV9LFxuICAgICAgJ29wdGdyb3VwJzogeydvcHRncm91cCc6IHRydWV9LFxuICAgICAgJ3AnOiB7J2FkZHJlc3MnOiB0cnVlLCAnYXJ0aWNsZSc6IHRydWUsICdhc2lkZSc6IHRydWUsICdibG9ja3F1b3RlJzogdHJ1ZSwgJ2Rpcic6IHRydWUsXG4gICAgICAgICAgICAnZGl2JzogdHJ1ZSwgJ2RsJzogdHJ1ZSwgJ2ZpZWxkc2V0JzogdHJ1ZSwgJ2Zvb3Rlcic6IHRydWUsICdmb3JtJzogdHJ1ZSxcbiAgICAgICAgICAgICdoMSc6IHRydWUsICdoMic6IHRydWUsICdoMyc6IHRydWUsICdoNCc6IHRydWUsICdoNSc6IHRydWUsICdoNic6IHRydWUsXG4gICAgICAgICAgICAnaGVhZGVyJzogdHJ1ZSwgJ2hncm91cCc6IHRydWUsICdocic6IHRydWUsICdtZW51JzogdHJ1ZSwgJ25hdic6IHRydWUsICdvbCc6IHRydWUsXG4gICAgICAgICAgICAncCc6IHRydWUsICdwcmUnOiB0cnVlLCAnc2VjdGlvbic6IHRydWUsICd0YWJsZSc6IHRydWUsICd1bCc6IHRydWV9LFxuICAgICAgJ3JwJzogeydycCc6IHRydWUsICdydCc6IHRydWV9LFxuICAgICAgJ3J0JzogeydycCc6IHRydWUsICdydCc6IHRydWV9LFxuICAgICAgJ3Rib2R5Jzogeyd0Ym9keSc6IHRydWUsICd0Zm9vdCc6IHRydWV9LFxuICAgICAgJ3RkJzogeyd0ZCc6IHRydWUsICd0aCc6IHRydWV9LFxuICAgICAgJ3Rmb290Jzogeyd0Ym9keSc6IHRydWV9LFxuICAgICAgJ3RoJzogeyd0ZCc6IHRydWUsICd0aCc6IHRydWV9LFxuICAgICAgJ3RoZWFkJzogeyd0Ym9keSc6IHRydWUsICd0Zm9vdCc6IHRydWV9LFxuICAgICAgJ3RyJzogeyd0cic6IHRydWV9XG4gICAgfSxcbiAgICBkb05vdEluZGVudDoge1wicHJlXCI6IHRydWV9LFxuICAgIGFsbG93VW5xdW90ZWQ6IHRydWUsXG4gICAgYWxsb3dNaXNzaW5nOiB0cnVlLFxuICAgIGNhc2VGb2xkOiB0cnVlXG4gIH0gOiB7XG4gICAgYXV0b1NlbGZDbG9zZXJzOiB7fSxcbiAgICBpbXBsaWNpdGx5Q2xvc2VkOiB7fSxcbiAgICBjb250ZXh0R3JhYmJlcnM6IHt9LFxuICAgIGRvTm90SW5kZW50OiB7fSxcbiAgICBhbGxvd1VucXVvdGVkOiBmYWxzZSxcbiAgICBhbGxvd01pc3Npbmc6IGZhbHNlLFxuICAgIGNhc2VGb2xkOiBmYWxzZVxuICB9O1xuICB2YXIgYWxpZ25DREFUQSA9IHBhcnNlckNvbmZpZy5hbGlnbkNEQVRBO1xuXG4gIC8vIFJldHVybiB2YXJpYWJsZXMgZm9yIHRva2VuaXplcnNcbiAgdmFyIHR5cGUsIHNldFN0eWxlO1xuXG4gIGZ1bmN0aW9uIGluVGV4dChzdHJlYW0sIHN0YXRlKSB7XG4gICAgZnVuY3Rpb24gY2hhaW4ocGFyc2VyKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHBhcnNlcjtcbiAgICAgIHJldHVybiBwYXJzZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgdmFyIGNoID0gc3RyZWFtLm5leHQoKTtcbiAgICBpZiAoY2ggPT0gXCI8XCIpIHtcbiAgICAgIGlmIChzdHJlYW0uZWF0KFwiIVwiKSkge1xuICAgICAgICBpZiAoc3RyZWFtLmVhdChcIltcIikpIHtcbiAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKFwiQ0RBVEFbXCIpKSByZXR1cm4gY2hhaW4oaW5CbG9jayhcImF0b21cIiwgXCJdXT5cIikpO1xuICAgICAgICAgIGVsc2UgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKFwiLS1cIikpIHtcbiAgICAgICAgICByZXR1cm4gY2hhaW4oaW5CbG9jayhcImNvbW1lbnRcIiwgXCItLT5cIikpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaChcIkRPQ1RZUEVcIiwgdHJ1ZSwgdHJ1ZSkpIHtcbiAgICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXC5fXFwtXS8pO1xuICAgICAgICAgIHJldHVybiBjaGFpbihkb2N0eXBlKDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzdHJlYW0uZWF0KFwiP1wiKSkge1xuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXC5fXFwtXS8pO1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IGluQmxvY2soXCJtZXRhXCIsIFwiPz5cIik7XG4gICAgICAgIHJldHVybiBcIm1ldGFcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGUgPSBzdHJlYW0uZWF0KFwiL1wiKSA/IFwiY2xvc2VUYWdcIiA6IFwib3BlblRhZ1wiO1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IGluVGFnO1xuICAgICAgICByZXR1cm4gXCJ0YWcgYnJhY2tldFwiO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2ggPT0gXCImXCIpIHtcbiAgICAgIHZhciBvaztcbiAgICAgIGlmIChzdHJlYW0uZWF0KFwiI1wiKSkge1xuICAgICAgICBpZiAoc3RyZWFtLmVhdChcInhcIikpIHtcbiAgICAgICAgICBvayA9IHN0cmVhbS5lYXRXaGlsZSgvW2EtZkEtRlxcZF0vKSAmJiBzdHJlYW0uZWF0KFwiO1wiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvayA9IHN0cmVhbS5lYXRXaGlsZSgvW1xcZF0vKSAmJiBzdHJlYW0uZWF0KFwiO1wiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2sgPSBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXC5cXC06XS8pICYmIHN0cmVhbS5lYXQoXCI7XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9rID8gXCJhdG9tXCIgOiBcImVycm9yXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW14mPF0vKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluVGFnKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuICAgIGlmIChjaCA9PSBcIj5cIiB8fCAoY2ggPT0gXCIvXCIgJiYgc3RyZWFtLmVhdChcIj5cIikpKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IGluVGV4dDtcbiAgICAgIHR5cGUgPSBjaCA9PSBcIj5cIiA/IFwiZW5kVGFnXCIgOiBcInNlbGZjbG9zZVRhZ1wiO1xuICAgICAgcmV0dXJuIFwidGFnIGJyYWNrZXRcIjtcbiAgICB9IGVsc2UgaWYgKGNoID09IFwiPVwiKSB7XG4gICAgICB0eXBlID0gXCJlcXVhbHNcIjtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAoY2ggPT0gXCI8XCIpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gaW5UZXh0O1xuICAgICAgc3RhdGUuc3RhdGUgPSBiYXNlU3RhdGU7XG4gICAgICBzdGF0ZS50YWdOYW1lID0gc3RhdGUudGFnU3RhcnQgPSBudWxsO1xuICAgICAgdmFyIG5leHQgPSBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgIHJldHVybiBuZXh0ID8gbmV4dCArIFwiIGVycm9yXCIgOiBcImVycm9yXCI7XG4gICAgfSBlbHNlIGlmICgvW1xcJ1xcXCJdLy50ZXN0KGNoKSkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSBpbkF0dHJpYnV0ZShjaCk7XG4gICAgICBzdGF0ZS5zdHJpbmdTdGFydENvbCA9IHN0cmVhbS5jb2x1bW4oKTtcbiAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyZWFtLm1hdGNoKC9eW15cXHNcXHUwMGEwPTw+XFxcIlxcJ10qW15cXHNcXHUwMGEwPTw+XFxcIlxcJ1xcL10vKTtcbiAgICAgIHJldHVybiBcIndvcmRcIjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbkF0dHJpYnV0ZShxdW90ZSkge1xuICAgIHZhciBjbG9zdXJlID0gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgd2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcbiAgICAgICAgaWYgKHN0cmVhbS5uZXh0KCkgPT0gcXVvdGUpIHtcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IGluVGFnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICB9O1xuICAgIGNsb3N1cmUuaXNJbkF0dHJpYnV0ZSA9IHRydWU7XG4gICAgcmV0dXJuIGNsb3N1cmU7XG4gIH1cblxuICBmdW5jdGlvbiBpbkJsb2NrKHN0eWxlLCB0ZXJtaW5hdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2godGVybWluYXRvcikpIHtcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IGluVGV4dDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZG9jdHlwZShkZXB0aCkge1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgY2g7XG4gICAgICB3aGlsZSAoKGNoID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgICBpZiAoY2ggPT0gXCI8XCIpIHtcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IGRvY3R5cGUoZGVwdGggKyAxKTtcbiAgICAgICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCI+XCIpIHtcbiAgICAgICAgICBpZiAoZGVwdGggPT0gMSkge1xuICAgICAgICAgICAgc3RhdGUudG9rZW5pemUgPSBpblRleHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUudG9rZW5pemUgPSBkb2N0eXBlKGRlcHRoIC0gMSk7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJtZXRhXCI7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQoc3RhdGUsIHRhZ05hbWUsIHN0YXJ0T2ZMaW5lKSB7XG4gICAgdGhpcy5wcmV2ID0gc3RhdGUuY29udGV4dDtcbiAgICB0aGlzLnRhZ05hbWUgPSB0YWdOYW1lO1xuICAgIHRoaXMuaW5kZW50ID0gc3RhdGUuaW5kZW50ZWQ7XG4gICAgdGhpcy5zdGFydE9mTGluZSA9IHN0YXJ0T2ZMaW5lO1xuICAgIGlmIChLbHVkZ2VzLmRvTm90SW5kZW50Lmhhc093blByb3BlcnR5KHRhZ05hbWUpIHx8IChzdGF0ZS5jb250ZXh0ICYmIHN0YXRlLmNvbnRleHQubm9JbmRlbnQpKVxuICAgICAgdGhpcy5ub0luZGVudCA9IHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gcG9wQ29udGV4dChzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5jb250ZXh0KSBzdGF0ZS5jb250ZXh0ID0gc3RhdGUuY29udGV4dC5wcmV2O1xuICB9XG4gIGZ1bmN0aW9uIG1heWJlUG9wQ29udGV4dChzdGF0ZSwgbmV4dFRhZ05hbWUpIHtcbiAgICB2YXIgcGFyZW50VGFnTmFtZTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKCFzdGF0ZS5jb250ZXh0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHBhcmVudFRhZ05hbWUgPSBzdGF0ZS5jb250ZXh0LnRhZ05hbWU7XG4gICAgICBpZiAoIUtsdWRnZXMuY29udGV4dEdyYWJiZXJzLmhhc093blByb3BlcnR5KHBhcmVudFRhZ05hbWUpIHx8XG4gICAgICAgICAgIUtsdWRnZXMuY29udGV4dEdyYWJiZXJzW3BhcmVudFRhZ05hbWVdLmhhc093blByb3BlcnR5KG5leHRUYWdOYW1lKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBiYXNlU3RhdGUodHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmICh0eXBlID09IFwib3BlblRhZ1wiKSB7XG4gICAgICBzdGF0ZS50YWdTdGFydCA9IHN0cmVhbS5jb2x1bW4oKTtcbiAgICAgIHJldHVybiB0YWdOYW1lU3RhdGU7XG4gICAgfSBlbHNlIGlmICh0eXBlID09IFwiY2xvc2VUYWdcIikge1xuICAgICAgcmV0dXJuIGNsb3NlVGFnTmFtZVN0YXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYmFzZVN0YXRlO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0YWdOYW1lU3RhdGUodHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmICh0eXBlID09IFwid29yZFwiKSB7XG4gICAgICBzdGF0ZS50YWdOYW1lID0gc3RyZWFtLmN1cnJlbnQoKTtcbiAgICAgIHNldFN0eWxlID0gXCJ0YWdcIjtcbiAgICAgIHJldHVybiBhdHRyU3RhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFN0eWxlID0gXCJlcnJvclwiO1xuICAgICAgcmV0dXJuIHRhZ05hbWVTdGF0ZTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY2xvc2VUYWdOYW1lU3RhdGUodHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmICh0eXBlID09IFwid29yZFwiKSB7XG4gICAgICB2YXIgdGFnTmFtZSA9IHN0cmVhbS5jdXJyZW50KCk7XG4gICAgICBpZiAoc3RhdGUuY29udGV4dCAmJiBzdGF0ZS5jb250ZXh0LnRhZ05hbWUgIT0gdGFnTmFtZSAmJlxuICAgICAgICAgIEtsdWRnZXMuaW1wbGljaXRseUNsb3NlZC5oYXNPd25Qcm9wZXJ0eShzdGF0ZS5jb250ZXh0LnRhZ05hbWUpKVxuICAgICAgICBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgIGlmIChzdGF0ZS5jb250ZXh0ICYmIHN0YXRlLmNvbnRleHQudGFnTmFtZSA9PSB0YWdOYW1lKSB7XG4gICAgICAgIHNldFN0eWxlID0gXCJ0YWdcIjtcbiAgICAgICAgcmV0dXJuIGNsb3NlU3RhdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRTdHlsZSA9IFwidGFnIGVycm9yXCI7XG4gICAgICAgIHJldHVybiBjbG9zZVN0YXRlRXJyO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXRTdHlsZSA9IFwiZXJyb3JcIjtcbiAgICAgIHJldHVybiBjbG9zZVN0YXRlRXJyO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlU3RhdGUodHlwZSwgX3N0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAodHlwZSAhPSBcImVuZFRhZ1wiKSB7XG4gICAgICBzZXRTdHlsZSA9IFwiZXJyb3JcIjtcbiAgICAgIHJldHVybiBjbG9zZVN0YXRlO1xuICAgIH1cbiAgICBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICByZXR1cm4gYmFzZVN0YXRlO1xuICB9XG4gIGZ1bmN0aW9uIGNsb3NlU3RhdGVFcnIodHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgIHNldFN0eWxlID0gXCJlcnJvclwiO1xuICAgIHJldHVybiBjbG9zZVN0YXRlKHR5cGUsIHN0cmVhbSwgc3RhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXR0clN0YXRlKHR5cGUsIF9zdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJ3b3JkXCIpIHtcbiAgICAgIHNldFN0eWxlID0gXCJhdHRyaWJ1dGVcIjtcbiAgICAgIHJldHVybiBhdHRyRXFTdGF0ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJlbmRUYWdcIiB8fCB0eXBlID09IFwic2VsZmNsb3NlVGFnXCIpIHtcbiAgICAgIHZhciB0YWdOYW1lID0gc3RhdGUudGFnTmFtZSwgdGFnU3RhcnQgPSBzdGF0ZS50YWdTdGFydDtcbiAgICAgIHN0YXRlLnRhZ05hbWUgPSBzdGF0ZS50YWdTdGFydCA9IG51bGw7XG4gICAgICBpZiAodHlwZSA9PSBcInNlbGZjbG9zZVRhZ1wiIHx8XG4gICAgICAgICAgS2x1ZGdlcy5hdXRvU2VsZkNsb3NlcnMuaGFzT3duUHJvcGVydHkodGFnTmFtZSkpIHtcbiAgICAgICAgbWF5YmVQb3BDb250ZXh0KHN0YXRlLCB0YWdOYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1heWJlUG9wQ29udGV4dChzdGF0ZSwgdGFnTmFtZSk7XG4gICAgICAgIHN0YXRlLmNvbnRleHQgPSBuZXcgQ29udGV4dChzdGF0ZSwgdGFnTmFtZSwgdGFnU3RhcnQgPT0gc3RhdGUuaW5kZW50ZWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VTdGF0ZTtcbiAgICB9XG4gICAgc2V0U3R5bGUgPSBcImVycm9yXCI7XG4gICAgcmV0dXJuIGF0dHJTdGF0ZTtcbiAgfVxuICBmdW5jdGlvbiBhdHRyRXFTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJlcXVhbHNcIikgcmV0dXJuIGF0dHJWYWx1ZVN0YXRlO1xuICAgIGlmICghS2x1ZGdlcy5hbGxvd01pc3NpbmcpIHNldFN0eWxlID0gXCJlcnJvclwiO1xuICAgIHJldHVybiBhdHRyU3RhdGUodHlwZSwgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gYXR0clZhbHVlU3RhdGUodHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmICh0eXBlID09IFwic3RyaW5nXCIpIHJldHVybiBhdHRyQ29udGludWVkU3RhdGU7XG4gICAgaWYgKHR5cGUgPT0gXCJ3b3JkXCIgJiYgS2x1ZGdlcy5hbGxvd1VucXVvdGVkKSB7c2V0U3R5bGUgPSBcInN0cmluZ1wiOyByZXR1cm4gYXR0clN0YXRlO31cbiAgICBzZXRTdHlsZSA9IFwiZXJyb3JcIjtcbiAgICByZXR1cm4gYXR0clN0YXRlKHR5cGUsIHN0cmVhbSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIGF0dHJDb250aW51ZWRTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJzdHJpbmdcIikgcmV0dXJuIGF0dHJDb250aW51ZWRTdGF0ZTtcbiAgICByZXR1cm4gYXR0clN0YXRlKHR5cGUsIHN0cmVhbSwgc3RhdGUpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7dG9rZW5pemU6IGluVGV4dCxcbiAgICAgICAgICAgICAgc3RhdGU6IGJhc2VTdGF0ZSxcbiAgICAgICAgICAgICAgaW5kZW50ZWQ6IDAsXG4gICAgICAgICAgICAgIHRhZ05hbWU6IG51bGwsIHRhZ1N0YXJ0OiBudWxsLFxuICAgICAgICAgICAgICBjb250ZXh0OiBudWxsfTtcbiAgICB9LFxuXG4gICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmICghc3RhdGUudGFnTmFtZSAmJiBzdHJlYW0uc29sKCkpXG4gICAgICAgIHN0YXRlLmluZGVudGVkID0gc3RyZWFtLmluZGVudGF0aW9uKCk7XG5cbiAgICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkgcmV0dXJuIG51bGw7XG4gICAgICB0eXBlID0gbnVsbDtcbiAgICAgIHZhciBzdHlsZSA9IHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgaWYgKChzdHlsZSB8fCB0eXBlKSAmJiBzdHlsZSAhPSBcImNvbW1lbnRcIikge1xuICAgICAgICBzZXRTdHlsZSA9IG51bGw7XG4gICAgICAgIHN0YXRlLnN0YXRlID0gc3RhdGUuc3RhdGUodHlwZSB8fCBzdHlsZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIGlmIChzZXRTdHlsZSlcbiAgICAgICAgICBzdHlsZSA9IHNldFN0eWxlID09IFwiZXJyb3JcIiA/IHN0eWxlICsgXCIgZXJyb3JcIiA6IHNldFN0eWxlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH0sXG5cbiAgICBpbmRlbnQ6IGZ1bmN0aW9uKHN0YXRlLCB0ZXh0QWZ0ZXIsIGZ1bGxMaW5lKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHN0YXRlLmNvbnRleHQ7XG4gICAgICAvLyBJbmRlbnQgbXVsdGktbGluZSBzdHJpbmdzIChlLmcuIGNzcykuXG4gICAgICBpZiAoc3RhdGUudG9rZW5pemUuaXNJbkF0dHJpYnV0ZSkge1xuICAgICAgICBpZiAoc3RhdGUudGFnU3RhcnQgPT0gc3RhdGUuaW5kZW50ZWQpXG4gICAgICAgICAgcmV0dXJuIHN0YXRlLnN0cmluZ1N0YXJ0Q29sICsgMTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJldHVybiBzdGF0ZS5pbmRlbnRlZCArIGluZGVudFVuaXQ7XG4gICAgICB9XG4gICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Lm5vSW5kZW50KSByZXR1cm4gQ29kZU1pcnJvci5QYXNzO1xuICAgICAgaWYgKHN0YXRlLnRva2VuaXplICE9IGluVGFnICYmIHN0YXRlLnRva2VuaXplICE9IGluVGV4dClcbiAgICAgICAgcmV0dXJuIGZ1bGxMaW5lID8gZnVsbExpbmUubWF0Y2goL14oXFxzKikvKVswXS5sZW5ndGggOiAwO1xuICAgICAgLy8gSW5kZW50IHRoZSBzdGFydHMgb2YgYXR0cmlidXRlIG5hbWVzLlxuICAgICAgaWYgKHN0YXRlLnRhZ05hbWUpIHtcbiAgICAgICAgaWYgKG11bHRpbGluZVRhZ0luZGVudFBhc3RUYWcpXG4gICAgICAgICAgcmV0dXJuIHN0YXRlLnRhZ1N0YXJ0ICsgc3RhdGUudGFnTmFtZS5sZW5ndGggKyAyO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmV0dXJuIHN0YXRlLnRhZ1N0YXJ0ICsgaW5kZW50VW5pdCAqIG11bHRpbGluZVRhZ0luZGVudEZhY3RvcjtcbiAgICAgIH1cbiAgICAgIGlmIChhbGlnbkNEQVRBICYmIC88IVxcW0NEQVRBXFxbLy50ZXN0KHRleHRBZnRlcikpIHJldHVybiAwO1xuICAgICAgdmFyIHRhZ0FmdGVyID0gdGV4dEFmdGVyICYmIC9ePChcXC8pPyhbXFx3XzpcXC4tXSopLy5leGVjKHRleHRBZnRlcik7XG4gICAgICBpZiAodGFnQWZ0ZXIgJiYgdGFnQWZ0ZXJbMV0pIHsgLy8gQ2xvc2luZyB0YWcgc3BvdHRlZFxuICAgICAgICB3aGlsZSAoY29udGV4dCkge1xuICAgICAgICAgIGlmIChjb250ZXh0LnRhZ05hbWUgPT0gdGFnQWZ0ZXJbMl0pIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnByZXY7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2UgaWYgKEtsdWRnZXMuaW1wbGljaXRseUNsb3NlZC5oYXNPd25Qcm9wZXJ0eShjb250ZXh0LnRhZ05hbWUpKSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gY29udGV4dC5wcmV2O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGFnQWZ0ZXIpIHsgLy8gT3BlbmluZyB0YWcgc3BvdHRlZFxuICAgICAgICB3aGlsZSAoY29udGV4dCkge1xuICAgICAgICAgIHZhciBncmFiYmVycyA9IEtsdWRnZXMuY29udGV4dEdyYWJiZXJzW2NvbnRleHQudGFnTmFtZV07XG4gICAgICAgICAgaWYgKGdyYWJiZXJzICYmIGdyYWJiZXJzLmhhc093blByb3BlcnR5KHRhZ0FmdGVyWzJdKSlcbiAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnByZXY7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChjb250ZXh0ICYmICFjb250ZXh0LnN0YXJ0T2ZMaW5lKVxuICAgICAgICBjb250ZXh0ID0gY29udGV4dC5wcmV2O1xuICAgICAgaWYgKGNvbnRleHQpIHJldHVybiBjb250ZXh0LmluZGVudCArIGluZGVudFVuaXQ7XG4gICAgICBlbHNlIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICBlbGVjdHJpY0lucHV0OiAvPFxcL1tcXHNcXHc6XSs+JC8sXG4gICAgYmxvY2tDb21tZW50U3RhcnQ6IFwiPCEtLVwiLFxuICAgIGJsb2NrQ29tbWVudEVuZDogXCItLT5cIixcblxuICAgIGNvbmZpZ3VyYXRpb246IHBhcnNlckNvbmZpZy5odG1sTW9kZSA/IFwiaHRtbFwiIDogXCJ4bWxcIixcbiAgICBoZWxwZXJUeXBlOiBwYXJzZXJDb25maWcuaHRtbE1vZGUgPyBcImh0bWxcIiA6IFwieG1sXCJcbiAgfTtcbn0pO1xuXG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3htbFwiLCBcInhtbFwiKTtcbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcImFwcGxpY2F0aW9uL3htbFwiLCBcInhtbFwiKTtcbmlmICghQ29kZU1pcnJvci5taW1lTW9kZXMuaGFzT3duUHJvcGVydHkoXCJ0ZXh0L2h0bWxcIikpXG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQvaHRtbFwiLCB7bmFtZTogXCJ4bWxcIiwgaHRtbE1vZGU6IHRydWV9KTtcblxufSk7XG4iLCJ2YXIgaGJzQmFzZSAgICAgICAgICAgICAgID0gcmVxdWlyZSgnaGFuZGxlYmFycy9kaXN0L2Nqcy9oYW5kbGViYXJzL2Jhc2UnKTtcbnZhciBVdGlscyAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgSGFuZGxlYmFyc0Vudmlyb25tZW50ID0gaGJzQmFzZS5IYW5kbGViYXJzRW52aXJvbm1lbnQ7XG5cbi8qKlxuICogRXh0ZW5kIEhhbmRsZWJhcnMgYmFzZSBvYmplY3Qgd2l0aCBjdXN0b20gZnVuY3Rpb25hbGl0eS5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgYmFzZSA9IG1vZHVsZS5leHBvcnRzID0gVXRpbHMuY3JlYXRlKGhic0Jhc2UpO1xuXG4vKipcbiAqIFdyYXAgb2xkLXN0eWxlIEhhbmRsZWJhcnMgaGVscGVycyB3aXRoIHRoZSB1cGRhdGVkIG9iamVjdCBzeW50YXggcmV0dXJuLlxuICpcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBoZWxwZXJcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG52YXIgd3JhcE9sZEhlbHBlciA9IGZ1bmN0aW9uIChoZWxwZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gaGVscGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAvLyBOZWVkIGEgc3BlY2lhbCBoYW5kbGVyIGZvciB0aGUgYHdpdGhgIGhlbHBlciB3aGljaCB3b24ndCBhbHdheXMgZXhlY3V0ZS5cbiAgICByZXR1cm4gcmVzdWx0ID09IG51bGwgPyByZXN1bHQgOiByZXN1bHQudmFsdWU7XG4gIH07XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVyIERPTUJhcnMgaGVscGVycyBvbiB0aGUgcGFzc2VkIGluIERPTUJhcnMgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGluc3RhbmNlXG4gKi9cbnZhciByZWdpc3RlckRlZmF1bHRIZWxwZXJzID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gIC8qKlxuICAgKiBUaGUgaGFuZGxlYmFycyBgZWFjaGAgaGVscGVyIGlzIGluY29tcGF0aWJhYmxlIHdpdGggRE9NQmFycywgc2luY2UgaXRcbiAgICogYXNzdW1lcyBzdHJpbmcgY29uY2F0aW5hdGlvbiAoYXMgb3Bwb3NlZCB0byBkb2N1bWVudCBmcmFnbWVudHMpLlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGNvbnRleHRcbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge05vZGV9XG4gICAqL1xuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignZWFjaCcsIGZ1bmN0aW9uIChjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgdmFyIGZuICAgICAgID0gb3B0aW9ucy5mbjtcbiAgICB2YXIgaW52ZXJzZSAgPSBvcHRpb25zLmludmVyc2U7XG4gICAgdmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIHZhciBpICAgICAgICA9IDA7XG4gICAgdmFyIGRhdGE7XG5cbiAgICBpZiAodHlwZW9mIGNvbnRleHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnRleHQgPSBjb250ZXh0LmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuZGF0YSkge1xuICAgICAgZGF0YSA9IFV0aWxzLmNyZWF0ZShvcHRpb25zLmRhdGEpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29udGV4dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBsZW4gPSBjb250ZXh0Lmxlbmd0aDtcblxuICAgICAgaWYgKGxlbiA9PT0gK2xlbikge1xuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgZGF0YS5pbmRleCA9IGk7XG4gICAgICAgICAgZGF0YS5maXJzdCA9IChpID09PSAwKTtcbiAgICAgICAgICBkYXRhLmxhc3QgID0gKGkgPT09IGxlbiAtIDEpO1xuXG4gICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZm4oY29udGV4dFtpXSwgeyBkYXRhOiBkYXRhIH0pLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbnRleHQsIGtleSkpIHtcbiAgICAgICAgICAgIGkgKz0gMTtcblxuICAgICAgICAgICAgZGF0YS5rZXkgICA9IGtleTtcbiAgICAgICAgICAgIGRhdGEuaW5kZXggPSBpO1xuICAgICAgICAgICAgZGF0YS5maXJzdCA9IChpID09PSAwKTtcblxuICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZm4oY29udGV4dFtrZXldLCB7IGRhdGE6IGRhdGEgfSkudmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpID09PSAwKSB7XG4gICAgICByZXR1cm4gaW52ZXJzZSh0aGlzKS52YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnJhZ21lbnQ7XG4gIH0pO1xuXG4gIC8vIFJlZ2lzdGVyIHVwZGF0ZWQgSGFuZGxlYmFycyBoZWxwZXJzLlxuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcih7XG4gICAgJ2lmJzogICAgICAgICAgICAgICAgIHdyYXBPbGRIZWxwZXIoaW5zdGFuY2UuaGVscGVycy5pZiksXG4gICAgJ3dpdGgnOiAgICAgICAgICAgICAgIHdyYXBPbGRIZWxwZXIoaW5zdGFuY2UuaGVscGVycy53aXRoKSxcbiAgICAnYmxvY2tIZWxwZXJNaXNzaW5nJzogd3JhcE9sZEhlbHBlcihpbnN0YW5jZS5oZWxwZXJzLmJsb2NrSGVscGVyTWlzc2luZylcbiAgfSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIGN1c3RvbSBET01CYXJzIGVudmlyb25tZW50IHRvIG1hdGNoIEhhbmRsZWJhcnNFbnZpcm9ubWVudC5cbiAqL1xudmFyIERPTUJhcnNFbnZpcm9ubWVudCA9IGJhc2UuRE9NQmFyc0Vudmlyb25tZW50ID0gZnVuY3Rpb24gKCkge1xuICBIYW5kbGViYXJzRW52aXJvbm1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgcmVnaXN0ZXJEZWZhdWx0SGVscGVycyh0aGlzKTtcbn07XG5cbi8qKlxuICogRXh0ZW5kIHRoZSBIYW5kbGViYXJzRW52aXJvbm1lbnQgcHJvdG90eXBlLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBlbnZQcm90b3R5cGUgPSBET01CYXJzRW52aXJvbm1lbnQucHJvdG90eXBlID0gVXRpbHMuY3JlYXRlKFxuICBIYW5kbGViYXJzRW52aXJvbm1lbnQucHJvdG90eXBlXG4pO1xuXG4vKipcbiAqIEFsaWFzIHNvbWUgdXNlZnVsIGZ1bmN0aW9uYWxpdHkgdGhhdCBpcyBleHBlY3RlZCB0byBiZSBleHBvc2VkIG9uIHRoZSByb290XG4gKiBvYmplY3QuXG4gKi9cbmVudlByb3RvdHlwZS5jcmVhdGVGcmFtZSAgICAgICA9IGhic0Jhc2UuY3JlYXRlRnJhbWU7XG5lbnZQcm90b3R5cGUuUkVWSVNJT05fQ0hBTkdFUyAgPSBoYnNCYXNlLlJFVklTSU9OX0NIQU5HRVM7XG5lbnZQcm90b3R5cGUuQ09NUElMRVJfUkVWSVNJT04gPSBoYnNCYXNlLkNPTVBJTEVSX1JFVklTSU9OO1xuXG4vKipcbiAqIFRoZSBiYXNpYyBnZXR0ZXIgZnVuY3Rpb24uIE92ZXJyaWRlIHRoaXMgd2l0aCBzb21ldGhpbmcgZWxzZSBiYXNlZCBvbiB5b3VyXG4gKiBwcm9qZWN0LiBGb3IgZXhhbXBsZSwgQmFja2JvbmUuanMgbW9kZWxzLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gb2JqZWN0XG4gKiBAcGFyYW0gIHtTdHJpbmd9IHByb3BlcnR5XG4gKiBAcmV0dXJuIHsqfVxuICovXG5lbnZQcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgcmV0dXJuIG9iamVjdFtwcm9wZXJ0eV07XG59O1xuXG4vKipcbiAqIE5vb3AgZnVuY3Rpb25zIGZvciBzdWJzY3JpYmUgYW5kIHVuc3Vic2NyaWJlLiBPdmVycmlkZSB3aXRoIGN1c3RvbVxuICogZnVuY3Rpb25hbGl0eS5cbiAqL1xuZW52UHJvdG90eXBlLnN1YnNjcmliZSA9IGVudlByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHt9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdoYW5kbGViYXJzL2Rpc3QvY2pzL2hhbmRsZWJhcnMvZXhjZXB0aW9uJykuZGVmYXVsdDtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qKlxuICogUmV0dXJuIHRoZSBjdXJyZW50IHRpbWVzdGFtcCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xudmFyIGN1cnJlbnRUaW1lID0gZ2xvYmFsLkRhdGUubm93IHx8IChmdW5jdGlvbiAoKSB7XG4gIHZhciBDb25zdHVjdG9yID0gZ2xvYmFsLkRhdGU7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IENvbnN0dWN0b3IoKS5nZXRUaW1lKCk7XG4gIH07XG59KSgpO1xuXG4vKipcbiAqIEtlZXAgbG9jYWwgcmVmZXJlbmNlcyB0byB0aGUgdGltZW91dCBmdW5jdGlvbnMuIFRoaXMgc3RvcHMgdXRpbGl0aWVzIGxpa2VcbiAqIFNpbm9uLmpzIGZyb20gYnJlYWtpbmcgdGhlIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqL1xudmFyIHNldFRpbWVyICAgPSBnbG9iYWwuc2V0VGltZW91dDtcbnZhciBjbGVhclRpbWVyID0gZ2xvYmFsLmNsZWFyVGltZW91dDtcblxuLyoqXG4gKiBGYWxsYmFjayBhbmltYXRpb24gZnJhbWUgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbnZhciBmYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHByZXYgPSBjdXJyZW50VGltZSgpO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICB2YXIgY3VyciA9IGN1cnJlbnRUaW1lKCk7XG4gICAgdmFyIG1zICAgPSBNYXRoLm1heCgwLCAxNiAtIChjdXJyIC0gcHJldikpO1xuICAgIHZhciByZXEgID0gc2V0VGltZXIoZm4sIG1zKTtcblxuICAgIHByZXYgPSBjdXJyO1xuXG4gICAgcmV0dXJuIHJlcTtcbiAgfTtcbn07XG5cbi8qKlxuICogRXhwb3NlIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgLlxuICpcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICBnbG9iYWwud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gIGdsb2JhbC5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgZ2xvYmFsLm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gIGdsb2JhbC5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gIGZhbGxiYWNrKCk7XG5cbi8qKlxuICogQ2FuY2VsIHRoZSBhbmltYXRpb24gZnJhbWUuXG4gKlxuICogQHR5cGUge0Z1bmN0aW9ufVxuICovXG52YXIgY2FuY2VsID0gZ2xvYmFsLmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XG4gIGdsb2JhbC53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSB8fFxuICBnbG9iYWwubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHxcbiAgZ2xvYmFsLm1zQ2FuY2VsQW5pbWF0aW9uRnJhbWUgfHxcbiAgZ2xvYmFsLm9DYW5jZWxBbmltYXRpb25GcmFtZSB8fFxuICBjbGVhclRpbWVyO1xuXG4vKipcbiAqIENhbmNlbCBhbiBhbmltYXRpb24gZnJhbWUuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGlkXG4gKi9cbmV4cG9ydHMuY2FuY2VsID0gZnVuY3Rpb24gKGlkKSB7XG4gIGNhbmNlbC5jYWxsKGdsb2JhbCwgaWQpO1xufTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCJ2YXIgaGJzVk0gPSByZXF1aXJlKCdoYW5kbGViYXJzL2Rpc3QvY2pzL2hhbmRsZWJhcnMvcnVudGltZScpO1xudmFyIFV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIHJhZiAgID0gcmVxdWlyZSgnLi9yYWYnKTtcblxuLyoqXG4gKiBLZWVwIGEgbWFwIG9mIGF0dHJpYnV0ZXMgdGhhdCBuZWVkIHRvIHVwZGF0ZSB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0aWVzLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBhdHRyUHJvcHMgPSB7XG4gIElOUFVUOiB7XG4gICAgdmFsdWU6ICAgJ3ZhbHVlJyxcbiAgICBjaGVja2VkOiAnY2hlY2tlZCdcbiAgfSxcbiAgT1BUSU9OOiB7XG4gICAgc2VsZWN0ZWQ6ICdzZWxlY3RlZCdcbiAgfVxufTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYSBzdWJzY3JpcHRpb25zIG9iamVjdCwgY2FsbGluZyBhIGZ1bmN0aW9uIHdpdGggdGhlIG9iamVjdFxuICogcHJvcGVydHkgZGV0YWlscyBhbmQgYSB1bmlxdWUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtBcnJheX0gICAgc3Vic2NyaXB0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKi9cbnZhciBpdGVyYXRlU3Vic2NyaXB0aW9ucyA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb25zLCBmbiwgY29udGV4dCkge1xuICBmb3IgKHZhciBpZCBpbiBzdWJzY3JpcHRpb25zKSB7XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gc3Vic2NyaXB0aW9uc1tpZF0pIHtcbiAgICAgIGZuLmNhbGwoY29udGV4dCwgc3Vic2NyaXB0aW9uc1tpZF1bcHJvcGVydHldLCBwcm9wZXJ0eSwgaWQpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgc3Vic2NpcHRpb24gaW5zdGFuY2UuIFRoaXMgZnVuY3Rpb25hbGl0eSBpcyB0aWdodGx5IGNvdXBsZWQgdG9cbiAqIERPTUJhcnMgcHJvZ3JhbSBleGVjdXRpb24uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZVxuICogQHBhcmFtIHtPYmplY3R9ICAgY29udGFpbmVyXG4gKiBAcGFyYW0ge09iamVjdH0gICBlbnZcbiAqL1xudmFyIFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChmbiwgdXBkYXRlLCBjb250YWluZXIsIGVudikge1xuICAvLyBBbGlhcyBwYXNzZWQgaW4gdmFyaWFibGVzIGZvciBsYXRlciBhY2Nlc3MuXG4gIHRoaXMuX2ZuICAgICAgICA9IGZuO1xuICB0aGlzLl91cGRhdGUgICAgPSB1cGRhdGU7XG4gIHRoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgdGhpcy5fZW52ICAgICAgID0gZW52O1xuXG4gIC8vIEFzc2lnbiBldmVyeSBzdWJzY3JpcHRpb24gaW5zdGFuY2UgYSB1bmlxdWUgaWQuIFRoaXMgaGVscHMgd2l0aCBsaW5raW5nXG4gIC8vIGJldHdlZW4gcGFyZW50IGFuZCBjaGlsZCBzdWJzY3JpcHRpb24gaW5zdGFuY2VzLlxuICB0aGlzLmNpZCAgICAgICAgICAgICA9ICdjJyArIFV0aWxzLnVuaXF1ZUlkKCk7XG4gIHRoaXMuY2hpbGRyZW4gICAgICAgID0ge307XG4gIHRoaXMuc3Vic2NyaXB0aW9ucyAgID0ge307XG4gIHRoaXMudW5zdWJzY3JpcHRpb25zID0gW107XG5cbiAgLy8gQ3JlYXRlIHN0YXRpY2FsbHkgYm91bmQgZnVuY3Rpb24gaW5zdGFuY2VzIGZvciBwdWJsaWMgY29uc3VtcHRpb24uXG4gIHRoaXMuYm91bmRVcGRhdGUgICAgICAgICA9IFV0aWxzLmJpbmQodGhpcy51cGRhdGUsIHRoaXMpO1xuICB0aGlzLmJvdW5kVW5zdWJzY3JpcHRpb24gPSBVdGlscy5iaW5kKHRoaXMudW5zdWJzY3JpcHRpb24sIHRoaXMpO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgdGhlIGludGVybmFsIHN1c2JjcmliZSBmdW5jdGlvbmFsaXR5IGZvciB0aGUgY29udGFpbmVyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKi9cblN1YnNjcmlwdGlvbi5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKG9iamVjdCwgcHJvcGVydHksIGlkKSB7XG4gICh0aGlzLnN1YnNjcmlwdGlvbnNbaWRdIHx8ICh0aGlzLnN1YnNjcmlwdGlvbnNbaWRdID0ge30pKVtwcm9wZXJ0eV0gPSBvYmplY3Q7XG59O1xuXG4vKipcbiAqIFBhc3MgYSBjdXN0b20gdW5zdWJzY3JpcHRpb24gZnVuY3Rpb24gdGhhdCB3aWxsIGV4ZWN1dGUgd2hlbiB3ZSB1bnN1YnNjcmliZS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5TdWJzY3JpcHRpb24ucHJvdG90eXBlLnVuc3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKGZuKSB7XG4gIFV0aWxzLmlzRnVuY3Rpb24oZm4pICYmIHRoaXMudW5zdWJzY3JpcHRpb25zLnB1c2goZm4pO1xufTtcblxuLyoqXG4gKiBVbnN1YnNjcmliZSBmcm9tIGEgc3ViY3JpcHRpb25zIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc3Vic2NyaXB0aW9uc1xuICovXG5TdWJzY3JpcHRpb24ucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb25zKSB7XG4gIGl0ZXJhdGVTdWJzY3JpcHRpb25zKHN1YnNjcmlwdGlvbnMsIGZ1bmN0aW9uIChvYmplY3QsIHByb3BlcnR5LCBpZCkge1xuICAgIGRlbGV0ZSBzdWJzY3JpcHRpb25zW2lkXVtwcm9wZXJ0eV07XG4gICAgdGhpcy5fZW52LnVuc3Vic2NyaWJlKG9iamVjdCwgcHJvcGVydHksIHRoaXMuYm91bmRVcGRhdGUpO1xuICB9LCB0aGlzKTtcbn07XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFuIGFycmF5IG9mIHVuc3Vic2NyaXB0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB1bnN1YnNjcmlwdGlvbnNcbiAqL1xuU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5fdW5zdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAodW5zdWJzY3JpcHRpb25zKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdW5zdWJzY3JpcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgdW5zdWJzY3JpcHRpb25zW2ldKCk7XG4gIH1cbn07XG5cbi8qKlxuICogVW5zdWJzY3JpYmUgZXZlcnl0aGluZyBmcm9tIHRoZSBjdXJyZW50IGluc3RhbmNlLlxuICovXG5TdWJzY3JpcHRpb24ucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fdW5zdWJzY3JpYmVkKSB7IHJldHVybjsgfVxuXG4gIHRoaXMuX3Vuc3Vic2NyaWJlKHRoaXMuc3Vic2NyaXB0aW9ucyk7XG4gIHRoaXMuX3Vuc3Vic2NyaXB0aW9uKHRoaXMudW5zdWJzY3JpcHRpb25zKTtcblxuICAvLyBEZWxldGUgYW55IHJlZmVyZW5jZSB0byB0aGlzIHN1YnNjcmlwdGlvbiBmcm9tIHRoZSBwYXJlbnQuXG4gIGlmICh0aGlzLnBhcmVudCkge1xuICAgIGRlbGV0ZSB0aGlzLnBhcmVudC5jaGlsZHJlblt0aGlzLmNpZF07XG4gICAgZGVsZXRlIHRoaXMucGFyZW50O1xuICB9XG5cbiAgLy8gQ2FuY2VsIGFueSBjdXJyZW50bHkgZXhlY3V0aW5nIGZ1bmN0aW9ucy4gV2UgYWxzbyBuZWVkIHRvIHNldCBhblxuICAvLyB1bnN1YnNjcmliZWQgZmxhZyBpbiBjYXNlIHRoZSBmdW5jdGlvbiBpcyBzdGlsbCBhdmFpbGFibGUgc29tZXdoZXJlIGFuZFxuICAvLyBjYWxsZWQgYWZ0ZXIgdW5zdWJzY3JpcHRpb24gaGFzIG9jY3VyZWQuXG4gIFZNLmV4ZWMuY2FuY2VsKHRoaXMuX2V4ZWNJZCk7XG4gIHRoaXMuX3Vuc3Vic2NyaWJlZCA9IHRydWU7XG4gIHRoaXMuX3Vuc3Vic2NyaWJlQ2hpbGRyZW4oKTtcblxuICAvLyBSZW1vdmUgdW53YW50ZWQgbGluZ2VyaW5nIHJlZmVyZW5jZXMuXG4gIGRlbGV0ZSB0aGlzLmNoaWxkcmVuO1xuICBkZWxldGUgdGhpcy5zdWJzY3JpcHRpb25zO1xuICBkZWxldGUgdGhpcy51bnN1YnNjcmlwdGlvbnM7XG4gIGRlbGV0ZSB0aGlzLl9mbjtcbiAgZGVsZXRlIHRoaXMuX2VudjtcbiAgZGVsZXRlIHRoaXMuX3VwZGF0ZTtcbiAgZGVsZXRlIHRoaXMuX2NvbnRhaW5lcjtcbiAgZGVsZXRlIHRoaXMuYm91bmRVcGRhdGU7XG4gIGRlbGV0ZSB0aGlzLmJvdW5kVW5zdWJzY3JpcHRpb247XG59O1xuXG4vKipcbiAqIFVuc3Vic2NyaWJlIHRoZSBjdXJyZW50IGluc3RhbmNlIGNoaWxkcmVuLlxuICovXG5TdWJzY3JpcHRpb24ucHJvdG90eXBlLl91bnN1YnNjcmliZUNoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBjaGlsZCBpbiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgdGhpcy5jaGlsZHJlbltjaGlsZF0udW5zdWJzY3JpYmUoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBFeGVjdXRlIHRoZSBzdWJzY3JpcHRpb24gZnVuY3Rpb24uXG4gKlxuICogQHJldHVybiB7Kn1cbiAqL1xuU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcGFyZW50ID0gdGhpcy5fY29udGFpbmVyLnN1YnNjcmlwdGlvbjtcblxuICAvLyBJZiB3ZSBoYXZlIGFuIGV4aXN0aW5nIHN1YnNjcmlwdGlvbiwgbGluayB0aGUgc3Vic2NyaXB0aW9ucyB0b2dldGhlci5cbiAgaWYgKHBhcmVudCAmJiAhcGFyZW50Ll91bnN1YnNjcmliZWQpIHtcbiAgICB0aGlzLnBhcmVudCA9IHRoaXMuX2NvbnRhaW5lci5zdWJzY3JpcHRpb247XG4gICAgdGhpcy5wYXJlbnQuY2hpbGRyZW5bdGhpcy5jaWRdID0gdGhpcztcbiAgfVxuXG4gIC8vIEFsaWFzIHRoZSBjdXJyZW50IHN1YnNjcmlwdGlvbnMgb2JqZWN0IGZvciBkaWZmaW5nIGFmdGVyIGV4ZWN1dGlvbi5cbiAgdGhpcy5fc3Vic2NyaXB0aW9ucyA9IHRoaXMuc3Vic2NyaXB0aW9ucztcbiAgdGhpcy5fdW5zdWJzY3JpcHRpb24odGhpcy51bnN1YnNjcmlwdGlvbnMpO1xuXG4gIC8vIFJlc2V0IHRoZSBzdWJzY3JpcHRpb25zIGFuZCB1bnN1YnNjcmlwdGlvbnMgb2JqZWN0cyBiZWZvcmUgZXhlY3V0aW9uLlxuICB0aGlzLnN1YnNjcmlwdGlvbnMgICA9IHt9O1xuICB0aGlzLnVuc3Vic2NyaXB0aW9ucyA9IFtdO1xuXG4gIHRoaXMuX2NvbnRhaW5lci5zdWJzY3JpcHRpb24gPSB0aGlzO1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgdGhpcy5fY29udGFpbmVyLnN1YnNjcmlwdGlvbiA9IHRoaXMucGFyZW50O1xuXG4gIC8vIFRoZSBjdXJyZW50IHN1YnNjcmlwdGlvbnMgb2JqZWN0IG5lZWRzIHRvIGJlIGNvbXBhcmVkIGFnYWluc3QgdGhlIHByZXZpb3VzXG4gIC8vIHN1YnNjcmlwdGlvbnMgYW5kIGFueSBkaWZmZW5jZXMgZml4ZWQuXG4gIHZhciBjdXJyZW50ICA9IHRoaXMuc3Vic2NyaXB0aW9ucztcbiAgdmFyIHByZXZpb3VzID0gdGhpcy5fc3Vic2NyaXB0aW9ucztcblxuICAvLyBJdGVyYXRlIG92ZXIgdGhlIG5ldyBzdWJzY3JpcHRpb25zIG9iamVjdC4gQ2hlY2sgZXZlcnkga2V5IGluIHRoZSBvYmplY3RcbiAgLy8gYWdhaW5zdCB0aGUgcHJldmlvdXMgc3Vic2NyaXB0aW9ucy4gSWYgaXQgZXhpc3RzIGluIHRoZSBwcmV2aW91cyBvYmplY3QsXG4gIC8vIGl0IG1lYW5zIHdlIGFyZSBhbHJlYWR5IHN1YnNjcmliZWQuIE90aGVyd2lzZSB3ZSBuZWVkIHRvIHN1YnNjcmliZSB0b1xuICAvLyB0aGUgbmV3IHByb3BlcnR5LlxuICBpdGVyYXRlU3Vic2NyaXB0aW9ucyhjdXJyZW50LCBmdW5jdGlvbiAob2JqZWN0LCBwcm9wZXJ0eSwgaWQpIHtcbiAgICBpZiAocHJldmlvdXNbaWRdICYmIHByZXZpb3VzW2lkXVtwcm9wZXJ0eV0pIHtcbiAgICAgIHJldHVybiBkZWxldGUgcHJldmlvdXNbaWRdW3Byb3BlcnR5XTtcbiAgICB9XG5cbiAgICB0aGlzLl9lbnYuc3Vic2NyaWJlKG9iamVjdCwgcHJvcGVydHksIHRoaXMuYm91bmRVcGRhdGUpO1xuICB9LCB0aGlzKTtcblxuICAvLyBJdGVyYXRlIG92ZXIgYWxsIHJlbWFpbmluZyBwcmV2aW91cyBzdWJzY3JpcHRpb25zIGFuZCB1bnN1YnNjcmliZSB0aGVtLlxuICBkZWxldGUgdGhpcy5fc3Vic2NyaXB0aW9ucztcbiAgdGhpcy5fdW5zdWJzY3JpYmUocHJldmlvdXMpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgc3VzYmNyaXB0aW9uIGluc3RhbmNlIHdpdGggY2hhbmdlcy5cbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5TdWJzY3JpcHRpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX3RyaWdnZXJlZCB8fCB0aGlzLl91bnN1YnNjcmliZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0aGlzLl91bnN1YnNjcmliZUNoaWxkcmVuKCk7XG5cbiAgdGhpcy5fZXhlY0lkID0gVk0uZXhlYyhVdGlscy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICBkZWxldGUgdGhpcy5fdHJpZ2dlcmVkO1xuICAgIHRoaXMuX3VwZGF0ZSh0aGlzLmV4ZWN1dGUoKSk7XG4gIH0sIHRoaXMpKTtcblxuICByZXR1cm4gdGhpcy5fdHJpZ2dlcmVkID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogRXh0ZW5kIHRoZSBIYW5kbGViYXJzIHJ1bnRpbWUgZW52aXJvbm1lbnQgd2l0aCBET00gc3BlY2lmaWMgaGVscGVycy5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgVk0gPSBtb2R1bGUuZXhwb3J0cyA9IFV0aWxzLmNyZWF0ZShoYnNWTSk7XG5cbi8qKlxuICogQmluZCBhIGZ1bmN0aW9uIHRvIHRoZSBhbmltYXRpb24gZnJhbWUuXG4gKlxuICogQHBhcmFtICB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblZNLmV4ZWMgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIHJhZihmbik7XG59O1xuXG4vKipcbiAqIENhbmNlbCBhbiBleGVjdXRpb24uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGlkXG4gKi9cblZNLmV4ZWMuY2FuY2VsID0gZnVuY3Rpb24gKGlkKSB7XG4gIHJldHVybiByYWYuY2FuY2VsKGlkKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuIGVsZW1lbnQgZnJvbSBhIHRhZyBuYW1lLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gdGFnTmFtZVxuICogQHBhcmFtICB7T2JqZWN0fSBlbnZcbiAqIEByZXR1cm4ge05vZGV9XG4gKi9cblZNLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAodGFnTmFtZSkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbn07XG5cbi8qKlxuICogQ29weSBhbGwgdGhlIGRhdGEgZnJvbSBvbmUgZWxlbWVudCB0byBhbm90aGVyIGFuZCByZXBsYWNlIGluIHBsYWNlLlxuICpcbiAqIEBwYXJhbSAge05vZGV9ICAgbm9kZVxuICogQHBhcmFtICB7U3RyaW5nfSB0YWdOYW1lXG4gKiBAcGFyYW0gIHtPYmplY3R9IGVudlxuICogQHJldHVybiB7Tm9kZX1cbiAqL1xuVk0uc2V0VGFnTmFtZSA9IGZ1bmN0aW9uIChub2RlLCB0YWdOYW1lKSB7XG4gIHZhciBuZXdOb2RlID0gVk0uY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcblxuICAvLyBNb3ZlIGFsbCBjaGlsZCBlbGVtZW50cyB0byB0aGUgbmV3IG5vZGUuXG4gIHdoaWxlIChub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICBuZXdOb2RlLmFwcGVuZENoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XG4gIH1cblxuICAvLyBDb3B5IGFsbCB0aGUgYXR0cmlidXRlcyB0byB0aGUgbmV3IG5vZGUuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGF0dHJpYnV0ZSA9IG5vZGUuYXR0cmlidXRlc1tpXTtcbiAgICBWTS5zZXRBdHRyaWJ1dGUobmV3Tm9kZSwgYXR0cmlidXRlLm5hbWUsIGF0dHJpYnV0ZS52YWx1ZSk7XG4gIH1cblxuICAvLyBSZXBsYWNlIHRoZSBub2RlIHBvc2l0aW9uIGluIHRoZSBwbGFjZS5cbiAgbm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChuZXdOb2RlLCBub2RlKTtcblxuICByZXR1cm4gbmV3Tm9kZTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGF0dHJpYnV0ZSBmcm9tIGFuIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtOb2RlfSAgIGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtPYmplY3R9IGVudlxuICovXG5WTS5yZW1vdmVBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoZWwsIG5hbWUpIHtcbiAgaWYgKCFlbC5oYXNBdHRyaWJ1dGUobmFtZSkpIHsgcmV0dXJuOyB9XG5cbiAgZWwucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuXG4gIC8vIFVuc2V0IHRoZSBET00gcHJvcGVydHkgd2hlbiB0aGUgYXR0cmlidXRlIGlzIHJlbW92ZWQuXG4gIGlmIChhdHRyUHJvcHNbZWwudGFnTmFtZV0gJiYgYXR0clByb3BzW2VsLnRhZ05hbWVdW25hbWVdKSB7XG4gICAgZWxbYXR0clByb3BzW2VsLnRhZ05hbWVdW25hbWVdXSA9IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0IGFuIGF0dHJpYnV0ZSB2YWx1ZSBvbiBhbiBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gICBlbFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Kn0gICAgICB2YWx1ZVxuICogQHBhcmFtIHtPYmplY3R9IGVudlxuICovXG5WTS5zZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gVk0ucmVtb3ZlQXR0cmlidXRlKGVsLCBuYW1lKTtcbiAgfVxuXG4gIC8vIFNldCB0aGUgYXR0cmlidXRlIHZhbHVlIHRvIHRoZSBuYW1lIHdoZW4gdGhlIHZhbHVlIGlzIGB0cnVlYC5cbiAgZWwuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlID09PSB0cnVlID8gbmFtZSA6IHZhbHVlKTtcblxuICAvLyBVcGRhdGUgdGhlIERPTSBwcm9wZXJ0eSB3aGVuIHRoZSBhdHRyaWJ1dGUgY2hhbmdlcy5cbiAgaWYgKGF0dHJQcm9wc1tlbC50YWdOYW1lXSAmJiBhdHRyUHJvcHNbZWwudGFnTmFtZV1bbmFtZV0pIHtcbiAgICBlbFthdHRyUHJvcHNbZWwudGFnTmFtZV1bbmFtZV1dID0gdmFsdWU7XG4gIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgY29tbWVudCBub2RlIGJhc2VkIG9uIHRleHQgY29udGVudHMuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBjb250ZW50c1xuICogQHBhcmFtICB7T2JqZWN0fSBlbnZcbiAqIEByZXR1cm4ge05vZGV9XG4gKi9cblZNLmNyZWF0ZUNvbW1lbnQgPSBmdW5jdGlvbiAoY29tbWVudCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudChjb21tZW50KTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgYW4gZXhlY3V0YWJsZSB0ZW1wbGF0ZSBmcm9tIGEgdGVtcGxhdGUgc3BlYy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9ICAgdGVtcGxhdGVTcGVjXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuVk0udGVtcGxhdGUgPSBmdW5jdGlvbiAodGVtcGxhdGVTcGVjLCBlbnYpIHtcbiAgLyoqXG4gICAqIFN1YnNjcmliZXIgdG8gZnVuY3Rpb24gaW4gdGhlIERPTUJhcnMgZXhlY3V0aW9uIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm5cbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGNyZWF0ZVxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gdXBkYXRlXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHZhciBzdWJzY3JpYmUgPSBmdW5jdGlvbiAoZm4sIGNyZWF0ZSwgdXBkYXRlKSB7XG4gICAgdmFyIHN1YnNjcmliZXIgPSBuZXcgU3Vic2NyaXB0aW9uKGZuLCB1cGRhdGUsIGNvbnRhaW5lciwgZW52KTtcblxuICAgIC8vIEltbWVkaWF0ZWx5IGFsaWFzIHRoZSBzdGFydGluZyB2YWx1ZS5cbiAgICBzdWJzY3JpYmVyLnZhbHVlID0gc3Vic2NyaWJlci5leGVjdXRlKCk7XG4gICAgVXRpbHMuaXNGdW5jdGlvbihjcmVhdGUpICYmIChzdWJzY3JpYmVyLnZhbHVlID0gY3JlYXRlKHN1YnNjcmliZXIudmFsdWUpKTtcblxuICAgIHJldHVybiBzdWJzY3JpYmVyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXcmFwIGEgZnVuY3Rpb24gd2l0aCBhIHNhbml0aXplZCBwdWJsaWMgc3Vic2NyaWJlciBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmblxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICovXG4gIHZhciB3cmFwUHJvZ3JhbSA9IGZ1bmN0aW9uIChmbikge1xuICAgIHZhciB3cmFwcGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN1YnNjcmliZXIgPSBuZXcgU3Vic2NyaXB0aW9uKGZuLCBudWxsLCBjb250YWluZXIsIGVudik7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiAgICAgICBzdWJzY3JpYmVyLmV4ZWN1dGUuYXBwbHkoc3Vic2NyaWJlciwgYXJndW1lbnRzKSxcbiAgICAgICAgdW5zdWJzY3JpYmU6IFV0aWxzLmJpbmQoc3Vic2NyaWJlci51bnN1YnNjcmliZSwgc3Vic2NyaWJlcilcbiAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIEV4dGVuZCB0aGUgd3JhcHBlciBmdW5jdGlvbiB3aXRoIHByb3BlcnRpZXMgb2YgdGhlIHBhc3NlZCBpbiBmdW5jdGlvbi5cbiAgICBVdGlscy5leHRlbmQod3JhcHBlciwgZm4pO1xuXG4gICAgcmV0dXJuIHdyYXBwZXI7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoZSBjb250YWluZXIgb2JqZWN0IGhvbGRzIGFsbCB0aGUgZnVuY3Rpb25zIHVzZWQgYnkgdGhlIHRlbXBsYXRlIHNwZWMuXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB2YXIgY29udGFpbmVyID0ge1xuICAgIGludm9rZVBhcnRpYWw6ICAgIFZNLmludm9rZVBhcnRpYWwsXG4gICAgcHJvZ3JhbXM6ICAgICAgICAgW10sXG4gICAgbm9vcDogICAgICAgICAgICAgVk0ubm9vcCxcbiAgICBwYXJ0aWFsOiAgICAgICAgICBVdGlscy5wYXJ0aWFsLFxuICAgIHdyYXBQcm9ncmFtOiAgICAgIHdyYXBQcm9ncmFtLFxuICAgIGVzY2FwZUV4cHJlc3Npb246IFV0aWxzLmVzY2FwZUV4cHJlc3Npb24sXG4gICAgcHJvZ3JhbVdpdGhEZXB0aDogVk0ucHJvZ3JhbVdpdGhEZXB0aFxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgYW5kIHN1YnNjcmliZSBhIHNpbmdsZSBET00gbm9kZSB1c2luZyBhIGN1c3RvbSBjcmVhdGlvbiBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGZuXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjcmVhdGVcbiAgICogQHJldHVybiB7Tm9kZX1cbiAgICovXG4gIHZhciBzdWJzY3JpYmVOb2RlID0gZnVuY3Rpb24gKGZuLCBjcmVhdGUpIHtcbiAgICByZXR1cm4gc3Vic2NyaWJlKGZuLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBVdGlscy50cmFja05vZGUoY3JlYXRlKHZhbHVlKSk7XG4gICAgfSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB0aGlzLnZhbHVlLnJlcGxhY2UoY3JlYXRlKHZhbHVlKSk7XG4gICAgfSkudmFsdWUuZnJhZ21lbnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBlbGVtZW50IGFuZCBzdWJzY3JpYmUgdG8gYW55IGNoYW5nZXMuIFRoaXMgbWV0aG9kIHJlcXVpcmVzIGFcbiAgICogY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGFueSBlbGVtZW50IGNoYW5nZXMgc2luY2UgeW91IGNhbid0IGNoYW5nZSBhIHRhZ1xuICAgKiBuYW1lIGluIHBsYWNlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm5cbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqL1xuICBjb250YWluZXIuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChmbiwgY2IpIHtcbiAgICByZXR1cm4gc3Vic2NyaWJlKGZuLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBWTS5jcmVhdGVFbGVtZW50KHZhbHVlLCBlbnYpO1xuICAgIH0sIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgY2IodGhpcy52YWx1ZSA9IFZNLnNldFRhZ05hbWUodGhpcy52YWx1ZSwgdmFsdWUsIGVudikpO1xuICAgIH0pLnZhbHVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBcHBlbmQgYW4gZWxlbWVudCB0byB0aGUgZW5kIG9mIGFub3RoZXIgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBwYXJlbnRcbiAgICogQHBhcmFtIHtOb2RlfSBjaGlsZFxuICAgKi9cbiAgY29udGFpbmVyLmFwcGVuZENoaWxkID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQpIHtcbiAgICBjaGlsZCAmJiBwYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgYW4gZWxlbWVudHMgYXR0cmlidXRlLiBXZSBhY2NlcHQgdGhlIGN1cnJlbnQgZWxlbWVudCBhIGZ1bmN0aW9uXG4gICAqIGJlY2F1c2Ugd2hlbiBhIHRhZyBuYW1lIGNoYW5nZXMgd2Ugd2lsbCBsb3NlIHJlZmVyZW5jZSB0byB0aGUgYWN0aXZlbHlcbiAgICogcmVuZGVyZWQgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VycmVudEVsXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG5hbWVGblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB2YWx1ZUZuXG4gICAqL1xuICBjb250YWluZXIuc2V0QXR0cmlidXRlID0gZnVuY3Rpb24gKGN1cnJlbnRFbCwgbmFtZUZuLCB2YWx1ZUZuKSB7XG4gICAgdmFyIGF0dHJOYW1lID0gc3Vic2NyaWJlKG5hbWVGbiwgbnVsbCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBWTS5yZW1vdmVBdHRyaWJ1dGUoY3VycmVudEVsKCksIHRoaXMudmFsdWUpO1xuICAgICAgVk0uc2V0QXR0cmlidXRlKGN1cnJlbnRFbCgpLCB0aGlzLnZhbHVlID0gdmFsdWUsIGF0dHJWYWx1ZS52YWx1ZSk7XG4gICAgfSk7XG5cbiAgICB2YXIgYXR0clZhbHVlID0gc3Vic2NyaWJlKHZhbHVlRm4sIG51bGwsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgVk0uc2V0QXR0cmlidXRlKGN1cnJlbnRFbCgpLCBhdHRyTmFtZS52YWx1ZSwgdGhpcy52YWx1ZSA9IHZhbHVlKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBWTS5zZXRBdHRyaWJ1dGUoY3VycmVudEVsKCksIGF0dHJOYW1lLnZhbHVlLCBhdHRyVmFsdWUudmFsdWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBET00gZWxlbWVudCBhbmQgc3Vic2NyaWJlIHRvIGFueSBjaGFuZ2VzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm5cbiAgICogQHJldHVybiB7Tm9kZX1cbiAgICovXG4gIGNvbnRhaW5lci5jcmVhdGVET00gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gc3Vic2NyaWJlTm9kZShmbiwgVXRpbHMuZG9taWZ5RXhwcmVzc2lvbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHRleHQgbm9kZSBhbmQgc3Vic2NyaWJlIHRvIGFueSBjaGFuZ2VzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm5cbiAgICogQHJldHVybiB7VGV4dH1cbiAgICovXG4gIGNvbnRhaW5lci5jcmVhdGVUZXh0ID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIHN1YnNjcmliZU5vZGUoZm4sIFV0aWxzLnRleHRpZnlFeHByZXNzaW9uKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgY29tbWVudCBub2RlIGFuZCBzdWJzY3JpYmUgdG8gYW55IGNoYW5nZXMuXG4gICAqXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmblxuICAgKiBAcmV0dXJuIHtDb21tZW50fVxuICAgKi9cbiAgY29udGFpbmVyLmNyZWF0ZUNvbW1lbnQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gc3Vic2NyaWJlKGZuLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBWTS5jcmVhdGVDb21tZW50KHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHRoaXMudmFsdWUudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgICB9KS52YWx1ZTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuZCByZXR1cm4gYSBwcm9ncmFtIHNpbmdsZXRvbiBiYXNlZCBvbiBpbmRleC5cbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyfSAgIGlcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGZuXG4gICAqIEBwYXJhbSAge09iamVjdH0gICBkYXRhXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKi9cbiAgY29udGFpbmVyLnByb2dyYW0gPSBmdW5jdGlvbiAoaSwgZm4sIGRhdGEpIHtcbiAgICB2YXIgcHJvZ3JhbVdyYXBwZXIgPSBjb250YWluZXIucHJvZ3JhbXNbaV07XG5cbiAgICBpZiAoZGF0YSkge1xuICAgICAgcmV0dXJuIFZNLnByb2dyYW0oaSwgZm4sIGRhdGEpO1xuICAgIH1cblxuICAgIGlmICghcHJvZ3JhbVdyYXBwZXIpIHtcbiAgICAgIHJldHVybiBjb250YWluZXIucHJvZ3JhbXNbaV0gPSBWTS5wcm9ncmFtKGksIGZuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvZ3JhbVdyYXBwZXI7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1lcmdlIHR3byBvYmplY3RzIGludG8gYSBzaW5nbGUgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHBhcmFtXG4gICAqIEBwYXJhbSAge09iamVjdH0gY29tbW9uXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGNvbnRhaW5lci5tZXJnZSA9IGZ1bmN0aW9uIChwYXJhbSwgY29tbW9uKSB7XG4gICAgdmFyIHJldCA9IHBhcmFtIHx8IGNvbW1vbjtcblxuICAgIGlmIChwYXJhbSAmJiBjb21tb24gJiYgKHBhcmFtICE9PSBjb21tb24pKSB7XG4gICAgICByZXQgPSB7fTtcbiAgICAgIFV0aWxzLmV4dGVuZChyZXQsIGNvbW1vbik7XG4gICAgICBVdGlscy5leHRlbmQocmV0LCBwYXJhbSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGEgcHJvcGVydHkgZnJvbSBhbiBvYmplY3QuIFBhc3NlcyBpbiB0aGUgb2JqZWN0IGlkIChkZXB0aCkgdG8gbWFrZSBpdFxuICAgKiBtdWNoIGZhc3RlciB0byBkbyBjb21wYXJpc29ucyBiZXR3ZWVuIG5ldyBhbmQgb2xkIHN1YnNjcmlwdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSAge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtICB7U3RyaW5nfSBpZFxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgY29udGFpbmVyLmdldCA9IGZ1bmN0aW9uIChvYmplY3QsIHByb3BlcnR5LCBpZCkge1xuICAgIGNvbnRhaW5lci5zdWJzY3JpcHRpb24uc3Vic2NyaWJlKG9iamVjdCwgcHJvcGVydHksIGlkKTtcbiAgICByZXR1cm4gZW52LmdldChvYmplY3QsIHByb3BlcnR5KTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjb21waWxlZCBKYXZhU2NyaXB0IGZ1bmN0aW9uIGZvciBleGVjdXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gY29udGV4dFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7Tm9kZX1cbiAgICovXG4gIHJldHVybiB3cmFwUHJvZ3JhbShmdW5jdGlvbiAoY29udGV4dCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIG5hbWVzcGFjZSA9IG9wdGlvbnMucGFydGlhbCA/IG9wdGlvbnMgOiBlbnY7XG4gICAgdmFyIGhlbHBlcnM7XG4gICAgdmFyIHBhcnRpYWxzO1xuXG4gICAgaWYgKCFvcHRpb25zLnBhcnRpYWwpIHtcbiAgICAgIGhlbHBlcnMgID0gb3B0aW9ucy5oZWxwZXJzO1xuICAgICAgcGFydGlhbHMgPSBvcHRpb25zLnBhcnRpYWxzO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSB0ZW1wbGF0ZVNwZWMuY2FsbChcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIG5hbWVzcGFjZSxcbiAgICAgIGNvbnRleHQsXG4gICAgICBoZWxwZXJzLFxuICAgICAgcGFydGlhbHMsXG4gICAgICBvcHRpb25zLmRhdGFcbiAgICApO1xuXG4gICAgaWYgKCFvcHRpb25zLnBhcnRpYWwpIHtcbiAgICAgIGVudi5WTS5jaGVja1JldmlzaW9uKGNvbnRhaW5lci5jb21waWxlckluZm8pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnaGFuZGxlYmFycy9kaXN0L2Nqcy9oYW5kbGViYXJzL3NhZmUtc3RyaW5nJykuZGVmYXVsdDtcbiIsInZhciBUcmFja05vZGUgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHRoaXMuZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgLy8gSW5zdGFudGx5IGFwcGVuZCBhIGJlZm9yZSBhbmQgYWZ0ZXIgdHJhY2tpbmcgbm9kZS5cbiAgdGhpcy5iZWZvcmUgPSB0aGlzLmZyYWdtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKSk7XG4gIHRoaXMuYWZ0ZXIgID0gdGhpcy5mcmFnbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJykpO1xuXG4gIC8vIEFwcGVuZCB0aGUgcGFzc2VkIGluIG5vZGUgdG8gdGhlIGN1cnJlbnQgZnJhZ21lbnQuXG4gIG5vZGUgJiYgdGhpcy5hcHBlbmRDaGlsZChub2RlKTtcbn07XG5cbi8qKlxuICogQXBwZW5kIGEgbm9kZSB0byB0aGUgY3VycmVudCB0cmFja2luZyBmcmFnbWVudC5cbiAqXG4gKiBAcGFyYW0gIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJuIHt0aGlzfVxuICovXG5UcmFja05vZGUucHJvdG90eXBlLmFwcGVuZENoaWxkID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdGhpcy5hZnRlci5wYXJlbnROb2RlICYmIHRoaXMuYWZ0ZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgdGhpcy5hZnRlcik7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFByZXBlbmQgYSBub2RlIHRvIHRoZSBjdXJyZW50IHRyYWNraW5nIGZyYWdtZW50LlxuICpcbiAqIEBwYXJhbSAge05vZGV9IG5vZGVcbiAqIEByZXR1cm4ge3RoaXN9XG4gKi9cblRyYWNrTm9kZS5wcm90b3R5cGUucHJlcGVuZENoaWxkID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdGhpcy5iZWZvcmUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgdGhpcy5iZWZvcmUubmV4dFNpYmxpbmcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGVsZW1lbnRzIGJldHdlZW4gdGhlIHR3byB0cmFja2luZyBub2Rlcy5cbiAqXG4gKiBAcGFyYW0gIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJuIHt0aGlzfVxuICovXG5UcmFja05vZGUucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24gKCkge1xuICB3aGlsZSAodGhpcy5iZWZvcmUubmV4dFNpYmxpbmcgJiYgdGhpcy5iZWZvcmUubmV4dFNpYmxpbmcgIT09IHRoaXMuYWZ0ZXIpIHtcbiAgICB0aGlzLmJlZm9yZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuYmVmb3JlLm5leHRTaWJsaW5nKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIHRoZSBlbGVtZW50cyBmcm9tIHRoZSBET00uXG4gKlxuICogQHBhcmFtICB7Tm9kZX0gbm9kZVxuICogQHJldHVybiB7dGhpc31cbiAqL1xuVHJhY2tOb2RlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gIHdoaWxlICh0aGlzLmJlZm9yZS5uZXh0U2libGluZyAmJiB0aGlzLmJlZm9yZS5uZXh0U2libGluZyAhPT0gdGhpcy5hZnRlcikge1xuICAgIHRoaXMuZnJhZ21lbnQuYXBwZW5kQ2hpbGQodGhpcy5iZWZvcmUubmV4dFNpYmxpbmcpO1xuICB9XG5cbiAgLy8gUHVsbCB0aGUgdHdvIHJlZmVyZW5jZSBub2RlcyBvdXQgb2YgdGhlIERPTSBhbmQgaW50byB0aGUgZnJhZ21lbnQuXG4gIHRoaXMuZnJhZ21lbnQuYXBwZW5kQ2hpbGQodGhpcy5hZnRlcik7XG4gIHRoaXMuZnJhZ21lbnQuaW5zZXJ0QmVmb3JlKHRoaXMuYmVmb3JlLCB0aGlzLmZyYWdtZW50LmZpcnN0Q2hpbGQpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXBsYWNlIHRoZSBjb250ZW50cyBvZiB0aGUgdHJhY2tpbmcgbm9kZSB3aXRoIG5ldyBjb250ZW50cy5cbiAqXG4gKiBAcGFyYW0gIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJuIHt0aGlzfVxuICovXG5UcmFja05vZGUucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiAobm9kZSkge1xuICByZXR1cm4gdGhpcy5lbXB0eSgpLmFwcGVuZENoaWxkKG5vZGUpO1xufTtcbiIsInZhciBoYnNVdGlscyAgID0gcmVxdWlyZSgnaGFuZGxlYmFycy9kaXN0L2Nqcy9oYW5kbGViYXJzL3V0aWxzJyk7XG52YXIgdW5pcXVlSWQgICA9IDA7XG52YXIgVHJhY2tOb2RlICA9IHJlcXVpcmUoJy4vdHJhY2stbm9kZScpO1xudmFyIFNhZmVTdHJpbmcgPSByZXF1aXJlKCcuL3NhZmUtc3RyaW5nJyk7XG52YXIgX19zbGljZSAgICA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuLyoqXG4gKiBTaW1wbGUgd2F5IHRvIHN1YmNsYXNzIGFuIG9iamVjdCwgd2l0aCBzdXBwb3J0IGZvciBvbGRlciBicm93c2Vycy5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbnZhciBjcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IChmdW5jdGlvbiAoKSB7XG4gIHZhciBGID0gZnVuY3Rpb24gKCkge307XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChvKSB7XG4gICAgRi5wcm90b3R5cGUgPSBvO1xuICAgIHZhciBvYmogPSBuZXcgRigpO1xuICAgIEYucHJvdG90eXBlID0gbnVsbDtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xufSkoKTtcblxuLyoqXG4gKiBFeHRlbmQgSGFuZGxlYmFycyB1dGlsaXRpZXMgd2l0aCBET00gZnVuY3Rpb25hbGl0eS5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgVXRpbHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZShoYnNVdGlscyk7XG5cbi8qKlxuICogUmV0dXJuIGEgdW5pcXVlIGlkLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuVXRpbHMudW5pcXVlSWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB1bmlxdWVJZCsrO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgYW4gdW5saW1pdGVkIG51bWJlciBvZiBhcmd1bWVudHMgYXMgdGhlIGxhc3RcbiAqIGFyZ3VtZW50LlxuICpcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblV0aWxzLnZhcmlhZGljID0gZnVuY3Rpb24gKGZuKSB7XG4gIHZhciBjb3VudCA9IE1hdGgubWF4KGZuLmxlbmd0aCAtIDEsIDApO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBfX3NsaWNlLmNhbGwoYXJndW1lbnRzLCAwLCBjb3VudCk7XG5cbiAgICAvLyBFbmZvcmNlIHRoZSBhcnJheSBsZW5ndGgsIGluIGNhc2Ugd2UgZGlkbid0IGhhdmUgZW5vdWdoIGFyZ3VtZW50cy5cbiAgICBhcmdzLmxlbmd0aCA9IGNvdW50O1xuICAgIGFyZ3MucHVzaChfX3NsaWNlLmNhbGwoYXJndW1lbnRzLCBjb3VudCkpO1xuXG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9O1xufTtcblxuLyoqXG4gKiBTaW1wbGUgcGFydGlhbCBhcHBsaWNhdGlvbiBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSAgeyp9ICAgICAgICAuLi5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5VdGlscy5wYXJ0aWFsID0gVXRpbHMudmFyaWFkaWMoZnVuY3Rpb24gKGZuLCBhcmdzKSB7XG4gIHJldHVybiBVdGlscy52YXJpYWRpYyhmdW5jdGlvbiAoY2FsbGVkKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3MuY29uY2F0KGNhbGxlZCkpO1xuICB9KTtcbn0pO1xuXG4vKipcbiAqIEJpbmQgYSBmdW5jdGlvbiB0byBhIGNlcnRhaW4gY29udGV4dC5cbiAqXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSAge09iamVjdH0gICBjb250ZXh0XG4gKiBAcGFyYW0gIHsqfSAgICAgICAgLi4uXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuVXRpbHMuYmluZCA9IFV0aWxzLnZhcmlhZGljKGZ1bmN0aW9uIChmbiwgY29udGV4dCwgYXJncykge1xuICByZXR1cm4gVXRpbHMudmFyaWFkaWMoZnVuY3Rpb24gKGNhbGxlZCkge1xuICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmdzLmNvbmNhdChjYWxsZWQpKTtcbiAgfSk7XG59KTtcblxuLyoqXG4gKiBFeHBvc2UgdGhlIGNyZWF0ZSBmdW5jdGlvbi5cbiAqXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKi9cblV0aWxzLmNyZWF0ZSA9IGNyZWF0ZTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGFuIG9iamVjdCBpcyBhY3R1YWxseSBhIERPTSBub2RlLlxuICpcbiAqIEBwYXJhbSAgeyp9ICAgICAgIGVsZW1lbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblV0aWxzLmlzTm9kZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50IGluc3RhbmNlb2YgTm9kZTtcbn07XG5cbi8qKlxuICogVHJhY2sgYSBub2RlIGluc3RhbmNlIGFueXdoZXJlIGl0IGdvZXMgaW4gdGhlIERPTS5cbiAqXG4gKiBAcGFyYW0gIHtOb2RlfSAgICAgIG5vZGVcbiAqIEByZXR1cm4ge1RyYWNrTm9kZX1cbiAqL1xuVXRpbHMudHJhY2tOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgcmV0dXJuIG5ldyBUcmFja05vZGUobm9kZSk7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhIHN0cmluZyBpbnRvIGFyYml0cmFyeSBET00gbm9kZXMuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge05vZGV9XG4gKi9cblV0aWxzLmRvbWlmeUV4cHJlc3Npb24gPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIC8vIElmIHdlIHBhc3NlZCBpbiBhIHNhZmUgc3RyaW5nLCBnZXQgdGhlIGFjdHVhbCB2YWx1ZS5cbiAgaWYgKHN0cmluZyBpbnN0YW5jZW9mIFNhZmVTdHJpbmcpIHtcbiAgICBzdHJpbmcgPSBzdHJpbmcuc3RyaW5nO1xuICB9XG5cbiAgLy8gTm8gbmVlZCB0byBjb2VyY2UgYSBub2RlLlxuICBpZiAoVXRpbHMuaXNOb2RlKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG5cbiAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkaXYuaW5uZXJIVE1MID0gc3RyaW5nO1xuXG4gIGlmIChkaXYuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZGl2LnJlbW92ZUNoaWxkKGRpdi5jaGlsZE5vZGVzWzBdKTtcbiAgfVxuXG4gIHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICB3aGlsZSAoZGl2LmZpcnN0Q2hpbGQpIHtcbiAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChkaXYuZmlyc3RDaGlsZCk7XG4gIH1cblxuICByZXR1cm4gZnJhZ21lbnQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhIHN0cmluZyBpbnRvIGEgRE9NIHRleHQgbm9kZSBmb3IgYXBwZW5kaW5nIHRvIHRoZSB0ZW1wbGF0ZS5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7VGV4dH1cbiAqL1xuVXRpbHMudGV4dGlmeUV4cHJlc3Npb24gPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIGlmIChzdHJpbmcgaW5zdGFuY2VvZiBTYWZlU3RyaW5nKSB7XG4gICAgcmV0dXJuIFV0aWxzLmRvbWlmeUV4cHJlc3Npb24oc3RyaW5nLnN0cmluZyk7XG4gIH1cblxuICAvLyBDYXRjaCB3aGVuIHRoZSBzdHJpbmcgaXMgYWN0dWFsbHkgYSBET00gbm9kZSBhbmQgdHVybiBpdCBpbnRvIGEgc3RyaW5nLlxuICBpZiAoVXRpbHMuaXNOb2RlKHN0cmluZykpIHtcbiAgICAvLyBBbHJlYWR5IGEgdGV4dCBub2RlLCBqdXN0IHJldHVybiBpdCBpbW1lZGlhdGVseS5cbiAgICBpZiAoc3RyaW5nLm5vZGVUeXBlID09PSAzKSB7XG4gICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc3RyaW5nLm91dGVySFRNTCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzdHJpbmcub3V0ZXJIVE1MKTtcbiAgICB9XG5cbiAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGl2LmFwcGVuZENoaWxkKHN0cmluZy5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShkaXYuaW5uZXJIVE1MKTtcbiAgfVxuXG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzdHJpbmcgPT0gbnVsbCA/ICcnIDogc3RyaW5nKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBVdGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIEV4Y2VwdGlvbiA9IHJlcXVpcmUoXCIuL2V4Y2VwdGlvblwiKVtcImRlZmF1bHRcIl07XG5cbnZhciBWRVJTSU9OID0gXCIxLjMuMFwiO1xuZXhwb3J0cy5WRVJTSU9OID0gVkVSU0lPTjt2YXIgQ09NUElMRVJfUkVWSVNJT04gPSA0O1xuZXhwb3J0cy5DT01QSUxFUl9SRVZJU0lPTiA9IENPTVBJTEVSX1JFVklTSU9OO1xudmFyIFJFVklTSU9OX0NIQU5HRVMgPSB7XG4gIDE6ICc8PSAxLjAucmMuMicsIC8vIDEuMC5yYy4yIGlzIGFjdHVhbGx5IHJldjIgYnV0IGRvZXNuJ3QgcmVwb3J0IGl0XG4gIDI6ICc9PSAxLjAuMC1yYy4zJyxcbiAgMzogJz09IDEuMC4wLXJjLjQnLFxuICA0OiAnPj0gMS4wLjAnXG59O1xuZXhwb3J0cy5SRVZJU0lPTl9DSEFOR0VTID0gUkVWSVNJT05fQ0hBTkdFUztcbnZhciBpc0FycmF5ID0gVXRpbHMuaXNBcnJheSxcbiAgICBpc0Z1bmN0aW9uID0gVXRpbHMuaXNGdW5jdGlvbixcbiAgICB0b1N0cmluZyA9IFV0aWxzLnRvU3RyaW5nLFxuICAgIG9iamVjdFR5cGUgPSAnW29iamVjdCBPYmplY3RdJztcblxuZnVuY3Rpb24gSGFuZGxlYmFyc0Vudmlyb25tZW50KGhlbHBlcnMsIHBhcnRpYWxzKSB7XG4gIHRoaXMuaGVscGVycyA9IGhlbHBlcnMgfHwge307XG4gIHRoaXMucGFydGlhbHMgPSBwYXJ0aWFscyB8fCB7fTtcblxuICByZWdpc3RlckRlZmF1bHRIZWxwZXJzKHRoaXMpO1xufVxuXG5leHBvcnRzLkhhbmRsZWJhcnNFbnZpcm9ubWVudCA9IEhhbmRsZWJhcnNFbnZpcm9ubWVudDtIYW5kbGViYXJzRW52aXJvbm1lbnQucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogSGFuZGxlYmFyc0Vudmlyb25tZW50LFxuXG4gIGxvZ2dlcjogbG9nZ2VyLFxuICBsb2c6IGxvZyxcblxuICByZWdpc3RlckhlbHBlcjogZnVuY3Rpb24obmFtZSwgZm4sIGludmVyc2UpIHtcbiAgICBpZiAodG9TdHJpbmcuY2FsbChuYW1lKSA9PT0gb2JqZWN0VHlwZSkge1xuICAgICAgaWYgKGludmVyc2UgfHwgZm4pIHsgdGhyb3cgbmV3IEV4Y2VwdGlvbignQXJnIG5vdCBzdXBwb3J0ZWQgd2l0aCBtdWx0aXBsZSBoZWxwZXJzJyk7IH1cbiAgICAgIFV0aWxzLmV4dGVuZCh0aGlzLmhlbHBlcnMsIG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaW52ZXJzZSkgeyBmbi5ub3QgPSBpbnZlcnNlOyB9XG4gICAgICB0aGlzLmhlbHBlcnNbbmFtZV0gPSBmbjtcbiAgICB9XG4gIH0sXG5cbiAgcmVnaXN0ZXJQYXJ0aWFsOiBmdW5jdGlvbihuYW1lLCBzdHIpIHtcbiAgICBpZiAodG9TdHJpbmcuY2FsbChuYW1lKSA9PT0gb2JqZWN0VHlwZSkge1xuICAgICAgVXRpbHMuZXh0ZW5kKHRoaXMucGFydGlhbHMsICBuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYXJ0aWFsc1tuYW1lXSA9IHN0cjtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdEhlbHBlcnMoaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2hlbHBlck1pc3NpbmcnLCBmdW5jdGlvbihhcmcpIHtcbiAgICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKFwiTWlzc2luZyBoZWxwZXI6ICdcIiArIGFyZyArIFwiJ1wiKTtcbiAgICB9XG4gIH0pO1xuXG4gIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCdibG9ja0hlbHBlck1pc3NpbmcnLCBmdW5jdGlvbihjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgdmFyIGludmVyc2UgPSBvcHRpb25zLmludmVyc2UgfHwgZnVuY3Rpb24oKSB7fSwgZm4gPSBvcHRpb25zLmZuO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oY29udGV4dCkpIHsgY29udGV4dCA9IGNvbnRleHQuY2FsbCh0aGlzKTsgfVxuXG4gICAgaWYoY29udGV4dCA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGZuKHRoaXMpO1xuICAgIH0gZWxzZSBpZihjb250ZXh0ID09PSBmYWxzZSB8fCBjb250ZXh0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBpbnZlcnNlKHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShjb250ZXh0KSkge1xuICAgICAgaWYoY29udGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS5oZWxwZXJzLmVhY2goY29udGV4dCwgb3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaW52ZXJzZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZuKGNvbnRleHQpO1xuICAgIH1cbiAgfSk7XG5cbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2VhY2gnLCBmdW5jdGlvbihjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgdmFyIGZuID0gb3B0aW9ucy5mbiwgaW52ZXJzZSA9IG9wdGlvbnMuaW52ZXJzZTtcbiAgICB2YXIgaSA9IDAsIHJldCA9IFwiXCIsIGRhdGE7XG5cbiAgICBpZiAoaXNGdW5jdGlvbihjb250ZXh0KSkgeyBjb250ZXh0ID0gY29udGV4dC5jYWxsKHRoaXMpOyB9XG5cbiAgICBpZiAob3B0aW9ucy5kYXRhKSB7XG4gICAgICBkYXRhID0gY3JlYXRlRnJhbWUob3B0aW9ucy5kYXRhKTtcbiAgICB9XG5cbiAgICBpZihjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0ID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKGlzQXJyYXkoY29udGV4dCkpIHtcbiAgICAgICAgZm9yKHZhciBqID0gY29udGV4dC5sZW5ndGg7IGk8ajsgaSsrKSB7XG4gICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIGRhdGEuaW5kZXggPSBpO1xuICAgICAgICAgICAgZGF0YS5maXJzdCA9IChpID09PSAwKTtcbiAgICAgICAgICAgIGRhdGEubGFzdCAgPSAoaSA9PT0gKGNvbnRleHQubGVuZ3RoLTEpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0ID0gcmV0ICsgZm4oY29udGV4dFtpXSwgeyBkYXRhOiBkYXRhIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IodmFyIGtleSBpbiBjb250ZXh0KSB7XG4gICAgICAgICAgaWYoY29udGV4dC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBpZihkYXRhKSB7IFxuICAgICAgICAgICAgICBkYXRhLmtleSA9IGtleTsgXG4gICAgICAgICAgICAgIGRhdGEuaW5kZXggPSBpO1xuICAgICAgICAgICAgICBkYXRhLmZpcnN0ID0gKGkgPT09IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0ID0gcmV0ICsgZm4oY29udGV4dFtrZXldLCB7ZGF0YTogZGF0YX0pO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmKGkgPT09IDApe1xuICAgICAgcmV0ID0gaW52ZXJzZSh0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9KTtcblxuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignaWYnLCBmdW5jdGlvbihjb25kaXRpb25hbCwgb3B0aW9ucykge1xuICAgIGlmIChpc0Z1bmN0aW9uKGNvbmRpdGlvbmFsKSkgeyBjb25kaXRpb25hbCA9IGNvbmRpdGlvbmFsLmNhbGwodGhpcyk7IH1cblxuICAgIC8vIERlZmF1bHQgYmVoYXZpb3IgaXMgdG8gcmVuZGVyIHRoZSBwb3NpdGl2ZSBwYXRoIGlmIHRoZSB2YWx1ZSBpcyB0cnV0aHkgYW5kIG5vdCBlbXB0eS5cbiAgICAvLyBUaGUgYGluY2x1ZGVaZXJvYCBvcHRpb24gbWF5IGJlIHNldCB0byB0cmVhdCB0aGUgY29uZHRpb25hbCBhcyBwdXJlbHkgbm90IGVtcHR5IGJhc2VkIG9uIHRoZVxuICAgIC8vIGJlaGF2aW9yIG9mIGlzRW1wdHkuIEVmZmVjdGl2ZWx5IHRoaXMgZGV0ZXJtaW5lcyBpZiAwIGlzIGhhbmRsZWQgYnkgdGhlIHBvc2l0aXZlIHBhdGggb3IgbmVnYXRpdmUuXG4gICAgaWYgKCghb3B0aW9ucy5oYXNoLmluY2x1ZGVaZXJvICYmICFjb25kaXRpb25hbCkgfHwgVXRpbHMuaXNFbXB0eShjb25kaXRpb25hbCkpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmludmVyc2UodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmZuKHRoaXMpO1xuICAgIH1cbiAgfSk7XG5cbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ3VubGVzcycsIGZ1bmN0aW9uKGNvbmRpdGlvbmFsLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLmhlbHBlcnNbJ2lmJ10uY2FsbCh0aGlzLCBjb25kaXRpb25hbCwge2ZuOiBvcHRpb25zLmludmVyc2UsIGludmVyc2U6IG9wdGlvbnMuZm4sIGhhc2g6IG9wdGlvbnMuaGFzaH0pO1xuICB9KTtcblxuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignd2l0aCcsIGZ1bmN0aW9uKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBpZiAoaXNGdW5jdGlvbihjb250ZXh0KSkgeyBjb250ZXh0ID0gY29udGV4dC5jYWxsKHRoaXMpOyB9XG5cbiAgICBpZiAoIVV0aWxzLmlzRW1wdHkoY29udGV4dCkpIHJldHVybiBvcHRpb25zLmZuKGNvbnRleHQpO1xuICB9KTtcblxuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignbG9nJywgZnVuY3Rpb24oY29udGV4dCwgb3B0aW9ucykge1xuICAgIHZhciBsZXZlbCA9IG9wdGlvbnMuZGF0YSAmJiBvcHRpb25zLmRhdGEubGV2ZWwgIT0gbnVsbCA/IHBhcnNlSW50KG9wdGlvbnMuZGF0YS5sZXZlbCwgMTApIDogMTtcbiAgICBpbnN0YW5jZS5sb2cobGV2ZWwsIGNvbnRleHQpO1xuICB9KTtcbn1cblxudmFyIGxvZ2dlciA9IHtcbiAgbWV0aG9kTWFwOiB7IDA6ICdkZWJ1ZycsIDE6ICdpbmZvJywgMjogJ3dhcm4nLCAzOiAnZXJyb3InIH0sXG5cbiAgLy8gU3RhdGUgZW51bVxuICBERUJVRzogMCxcbiAgSU5GTzogMSxcbiAgV0FSTjogMixcbiAgRVJST1I6IDMsXG4gIGxldmVsOiAzLFxuXG4gIC8vIGNhbiBiZSBvdmVycmlkZGVuIGluIHRoZSBob3N0IGVudmlyb25tZW50XG4gIGxvZzogZnVuY3Rpb24obGV2ZWwsIG9iaikge1xuICAgIGlmIChsb2dnZXIubGV2ZWwgPD0gbGV2ZWwpIHtcbiAgICAgIHZhciBtZXRob2QgPSBsb2dnZXIubWV0aG9kTWFwW2xldmVsXTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZVttZXRob2RdKSB7XG4gICAgICAgIGNvbnNvbGVbbWV0aG9kXS5jYWxsKGNvbnNvbGUsIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuZXhwb3J0cy5sb2dnZXIgPSBsb2dnZXI7XG5mdW5jdGlvbiBsb2cobGV2ZWwsIG9iaikgeyBsb2dnZXIubG9nKGxldmVsLCBvYmopOyB9XG5cbmV4cG9ydHMubG9nID0gbG9nO3ZhciBjcmVhdGVGcmFtZSA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICB2YXIgb2JqID0ge307XG4gIFV0aWxzLmV4dGVuZChvYmosIG9iamVjdCk7XG4gIHJldHVybiBvYmo7XG59O1xuZXhwb3J0cy5jcmVhdGVGcmFtZSA9IGNyZWF0ZUZyYW1lOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgZXJyb3JQcm9wcyA9IFsnZGVzY3JpcHRpb24nLCAnZmlsZU5hbWUnLCAnbGluZU51bWJlcicsICdtZXNzYWdlJywgJ25hbWUnLCAnbnVtYmVyJywgJ3N0YWNrJ107XG5cbmZ1bmN0aW9uIEV4Y2VwdGlvbihtZXNzYWdlLCBub2RlKSB7XG4gIHZhciBsaW5lO1xuICBpZiAobm9kZSAmJiBub2RlLmZpcnN0TGluZSkge1xuICAgIGxpbmUgPSBub2RlLmZpcnN0TGluZTtcblxuICAgIG1lc3NhZ2UgKz0gJyAtICcgKyBsaW5lICsgJzonICsgbm9kZS5maXJzdENvbHVtbjtcbiAgfVxuXG4gIHZhciB0bXAgPSBFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcblxuICAvLyBVbmZvcnR1bmF0ZWx5IGVycm9ycyBhcmUgbm90IGVudW1lcmFibGUgaW4gQ2hyb21lIChhdCBsZWFzdCksIHNvIGBmb3IgcHJvcCBpbiB0bXBgIGRvZXNuJ3Qgd29yay5cbiAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgZXJyb3JQcm9wcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgdGhpc1tlcnJvclByb3BzW2lkeF1dID0gdG1wW2Vycm9yUHJvcHNbaWR4XV07XG4gIH1cblxuICBpZiAobGluZSkge1xuICAgIHRoaXMubGluZU51bWJlciA9IGxpbmU7XG4gICAgdGhpcy5jb2x1bW4gPSBub2RlLmZpcnN0Q29sdW1uO1xuICB9XG59XG5cbkV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBFeGNlcHRpb247IiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgVXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbnZhciBFeGNlcHRpb24gPSByZXF1aXJlKFwiLi9leGNlcHRpb25cIilbXCJkZWZhdWx0XCJdO1xudmFyIENPTVBJTEVSX1JFVklTSU9OID0gcmVxdWlyZShcIi4vYmFzZVwiKS5DT01QSUxFUl9SRVZJU0lPTjtcbnZhciBSRVZJU0lPTl9DSEFOR0VTID0gcmVxdWlyZShcIi4vYmFzZVwiKS5SRVZJU0lPTl9DSEFOR0VTO1xuXG5mdW5jdGlvbiBjaGVja1JldmlzaW9uKGNvbXBpbGVySW5mbykge1xuICB2YXIgY29tcGlsZXJSZXZpc2lvbiA9IGNvbXBpbGVySW5mbyAmJiBjb21waWxlckluZm9bMF0gfHwgMSxcbiAgICAgIGN1cnJlbnRSZXZpc2lvbiA9IENPTVBJTEVSX1JFVklTSU9OO1xuXG4gIGlmIChjb21waWxlclJldmlzaW9uICE9PSBjdXJyZW50UmV2aXNpb24pIHtcbiAgICBpZiAoY29tcGlsZXJSZXZpc2lvbiA8IGN1cnJlbnRSZXZpc2lvbikge1xuICAgICAgdmFyIHJ1bnRpbWVWZXJzaW9ucyA9IFJFVklTSU9OX0NIQU5HRVNbY3VycmVudFJldmlzaW9uXSxcbiAgICAgICAgICBjb21waWxlclZlcnNpb25zID0gUkVWSVNJT05fQ0hBTkdFU1tjb21waWxlclJldmlzaW9uXTtcbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oXCJUZW1wbGF0ZSB3YXMgcHJlY29tcGlsZWQgd2l0aCBhbiBvbGRlciB2ZXJzaW9uIG9mIEhhbmRsZWJhcnMgdGhhbiB0aGUgY3VycmVudCBydW50aW1lLiBcIitcbiAgICAgICAgICAgIFwiUGxlYXNlIHVwZGF0ZSB5b3VyIHByZWNvbXBpbGVyIHRvIGEgbmV3ZXIgdmVyc2lvbiAoXCIrcnVudGltZVZlcnNpb25zK1wiKSBvciBkb3duZ3JhZGUgeW91ciBydW50aW1lIHRvIGFuIG9sZGVyIHZlcnNpb24gKFwiK2NvbXBpbGVyVmVyc2lvbnMrXCIpLlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXNlIHRoZSBlbWJlZGRlZCB2ZXJzaW9uIGluZm8gc2luY2UgdGhlIHJ1bnRpbWUgZG9lc24ndCBrbm93IGFib3V0IHRoaXMgcmV2aXNpb24geWV0XG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKFwiVGVtcGxhdGUgd2FzIHByZWNvbXBpbGVkIHdpdGggYSBuZXdlciB2ZXJzaW9uIG9mIEhhbmRsZWJhcnMgdGhhbiB0aGUgY3VycmVudCBydW50aW1lLiBcIitcbiAgICAgICAgICAgIFwiUGxlYXNlIHVwZGF0ZSB5b3VyIHJ1bnRpbWUgdG8gYSBuZXdlciB2ZXJzaW9uIChcIitjb21waWxlckluZm9bMV0rXCIpLlwiKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5jaGVja1JldmlzaW9uID0gY2hlY2tSZXZpc2lvbjsvLyBUT0RPOiBSZW1vdmUgdGhpcyBsaW5lIGFuZCBicmVhayB1cCBjb21waWxlUGFydGlhbFxuXG5mdW5jdGlvbiB0ZW1wbGF0ZSh0ZW1wbGF0ZVNwZWMsIGVudikge1xuICBpZiAoIWVudikge1xuICAgIHRocm93IG5ldyBFeGNlcHRpb24oXCJObyBlbnZpcm9ubWVudCBwYXNzZWQgdG8gdGVtcGxhdGVcIik7XG4gIH1cblxuICAvLyBOb3RlOiBVc2luZyBlbnYuVk0gcmVmZXJlbmNlcyByYXRoZXIgdGhhbiBsb2NhbCB2YXIgcmVmZXJlbmNlcyB0aHJvdWdob3V0IHRoaXMgc2VjdGlvbiB0byBhbGxvd1xuICAvLyBmb3IgZXh0ZXJuYWwgdXNlcnMgdG8gb3ZlcnJpZGUgdGhlc2UgYXMgcHN1ZWRvLXN1cHBvcnRlZCBBUElzLlxuICB2YXIgaW52b2tlUGFydGlhbFdyYXBwZXIgPSBmdW5jdGlvbihwYXJ0aWFsLCBuYW1lLCBjb250ZXh0LCBoZWxwZXJzLCBwYXJ0aWFscywgZGF0YSkge1xuICAgIHZhciByZXN1bHQgPSBlbnYuVk0uaW52b2tlUGFydGlhbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChyZXN1bHQgIT0gbnVsbCkgeyByZXR1cm4gcmVzdWx0OyB9XG5cbiAgICBpZiAoZW52LmNvbXBpbGUpIHtcbiAgICAgIHZhciBvcHRpb25zID0geyBoZWxwZXJzOiBoZWxwZXJzLCBwYXJ0aWFsczogcGFydGlhbHMsIGRhdGE6IGRhdGEgfTtcbiAgICAgIHBhcnRpYWxzW25hbWVdID0gZW52LmNvbXBpbGUocGFydGlhbCwgeyBkYXRhOiBkYXRhICE9PSB1bmRlZmluZWQgfSwgZW52KTtcbiAgICAgIHJldHVybiBwYXJ0aWFsc1tuYW1lXShjb250ZXh0LCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbihcIlRoZSBwYXJ0aWFsIFwiICsgbmFtZSArIFwiIGNvdWxkIG5vdCBiZSBjb21waWxlZCB3aGVuIHJ1bm5pbmcgaW4gcnVudGltZS1vbmx5IG1vZGVcIik7XG4gICAgfVxuICB9O1xuXG4gIC8vIEp1c3QgYWRkIHdhdGVyXG4gIHZhciBjb250YWluZXIgPSB7XG4gICAgZXNjYXBlRXhwcmVzc2lvbjogVXRpbHMuZXNjYXBlRXhwcmVzc2lvbixcbiAgICBpbnZva2VQYXJ0aWFsOiBpbnZva2VQYXJ0aWFsV3JhcHBlcixcbiAgICBwcm9ncmFtczogW10sXG4gICAgcHJvZ3JhbTogZnVuY3Rpb24oaSwgZm4sIGRhdGEpIHtcbiAgICAgIHZhciBwcm9ncmFtV3JhcHBlciA9IHRoaXMucHJvZ3JhbXNbaV07XG4gICAgICBpZihkYXRhKSB7XG4gICAgICAgIHByb2dyYW1XcmFwcGVyID0gcHJvZ3JhbShpLCBmbiwgZGF0YSk7XG4gICAgICB9IGVsc2UgaWYgKCFwcm9ncmFtV3JhcHBlcikge1xuICAgICAgICBwcm9ncmFtV3JhcHBlciA9IHRoaXMucHJvZ3JhbXNbaV0gPSBwcm9ncmFtKGksIGZuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm9ncmFtV3JhcHBlcjtcbiAgICB9LFxuICAgIG1lcmdlOiBmdW5jdGlvbihwYXJhbSwgY29tbW9uKSB7XG4gICAgICB2YXIgcmV0ID0gcGFyYW0gfHwgY29tbW9uO1xuXG4gICAgICBpZiAocGFyYW0gJiYgY29tbW9uICYmIChwYXJhbSAhPT0gY29tbW9uKSkge1xuICAgICAgICByZXQgPSB7fTtcbiAgICAgICAgVXRpbHMuZXh0ZW5kKHJldCwgY29tbW9uKTtcbiAgICAgICAgVXRpbHMuZXh0ZW5kKHJldCwgcGFyYW0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuICAgIHByb2dyYW1XaXRoRGVwdGg6IGVudi5WTS5wcm9ncmFtV2l0aERlcHRoLFxuICAgIG5vb3A6IGVudi5WTS5ub29wLFxuICAgIGNvbXBpbGVySW5mbzogbnVsbFxuICB9O1xuXG4gIHJldHVybiBmdW5jdGlvbihjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIG5hbWVzcGFjZSA9IG9wdGlvbnMucGFydGlhbCA/IG9wdGlvbnMgOiBlbnYsXG4gICAgICAgIGhlbHBlcnMsXG4gICAgICAgIHBhcnRpYWxzO1xuXG4gICAgaWYgKCFvcHRpb25zLnBhcnRpYWwpIHtcbiAgICAgIGhlbHBlcnMgPSBvcHRpb25zLmhlbHBlcnM7XG4gICAgICBwYXJ0aWFscyA9IG9wdGlvbnMucGFydGlhbHM7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSB0ZW1wbGF0ZVNwZWMuY2FsbChcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgbmFtZXNwYWNlLCBjb250ZXh0LFxuICAgICAgICAgIGhlbHBlcnMsXG4gICAgICAgICAgcGFydGlhbHMsXG4gICAgICAgICAgb3B0aW9ucy5kYXRhKTtcblxuICAgIGlmICghb3B0aW9ucy5wYXJ0aWFsKSB7XG4gICAgICBlbnYuVk0uY2hlY2tSZXZpc2lvbihjb250YWluZXIuY29tcGlsZXJJbmZvKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG5leHBvcnRzLnRlbXBsYXRlID0gdGVtcGxhdGU7ZnVuY3Rpb24gcHJvZ3JhbVdpdGhEZXB0aChpLCBmbiwgZGF0YSAvKiwgJGRlcHRoICovKSB7XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAzKTtcblxuICB2YXIgcHJvZyA9IGZ1bmN0aW9uKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBbY29udGV4dCwgb3B0aW9ucy5kYXRhIHx8IGRhdGFdLmNvbmNhdChhcmdzKSk7XG4gIH07XG4gIHByb2cucHJvZ3JhbSA9IGk7XG4gIHByb2cuZGVwdGggPSBhcmdzLmxlbmd0aDtcbiAgcmV0dXJuIHByb2c7XG59XG5cbmV4cG9ydHMucHJvZ3JhbVdpdGhEZXB0aCA9IHByb2dyYW1XaXRoRGVwdGg7ZnVuY3Rpb24gcHJvZ3JhbShpLCBmbiwgZGF0YSkge1xuICB2YXIgcHJvZyA9IGZ1bmN0aW9uKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHJldHVybiBmbihjb250ZXh0LCBvcHRpb25zLmRhdGEgfHwgZGF0YSk7XG4gIH07XG4gIHByb2cucHJvZ3JhbSA9IGk7XG4gIHByb2cuZGVwdGggPSAwO1xuICByZXR1cm4gcHJvZztcbn1cblxuZXhwb3J0cy5wcm9ncmFtID0gcHJvZ3JhbTtmdW5jdGlvbiBpbnZva2VQYXJ0aWFsKHBhcnRpYWwsIG5hbWUsIGNvbnRleHQsIGhlbHBlcnMsIHBhcnRpYWxzLCBkYXRhKSB7XG4gIHZhciBvcHRpb25zID0geyBwYXJ0aWFsOiB0cnVlLCBoZWxwZXJzOiBoZWxwZXJzLCBwYXJ0aWFsczogcGFydGlhbHMsIGRhdGE6IGRhdGEgfTtcblxuICBpZihwYXJ0aWFsID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKFwiVGhlIHBhcnRpYWwgXCIgKyBuYW1lICsgXCIgY291bGQgbm90IGJlIGZvdW5kXCIpO1xuICB9IGVsc2UgaWYocGFydGlhbCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuIHBhcnRpYWwoY29udGV4dCwgb3B0aW9ucyk7XG4gIH1cbn1cblxuZXhwb3J0cy5pbnZva2VQYXJ0aWFsID0gaW52b2tlUGFydGlhbDtmdW5jdGlvbiBub29wKCkgeyByZXR1cm4gXCJcIjsgfVxuXG5leHBvcnRzLm5vb3AgPSBub29wOyIsIlwidXNlIHN0cmljdFwiO1xuLy8gQnVpbGQgb3V0IG91ciBiYXNpYyBTYWZlU3RyaW5nIHR5cGVcbmZ1bmN0aW9uIFNhZmVTdHJpbmcoc3RyaW5nKSB7XG4gIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xufVxuXG5TYWZlU3RyaW5nLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gXCJcIiArIHRoaXMuc3RyaW5nO1xufTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBTYWZlU3RyaW5nOyIsIlwidXNlIHN0cmljdFwiO1xuLypqc2hpbnQgLVcwMDQgKi9cbnZhciBTYWZlU3RyaW5nID0gcmVxdWlyZShcIi4vc2FmZS1zdHJpbmdcIilbXCJkZWZhdWx0XCJdO1xuXG52YXIgZXNjYXBlID0ge1xuICBcIiZcIjogXCImYW1wO1wiLFxuICBcIjxcIjogXCImbHQ7XCIsXG4gIFwiPlwiOiBcIiZndDtcIixcbiAgJ1wiJzogXCImcXVvdDtcIixcbiAgXCInXCI6IFwiJiN4Mjc7XCIsXG4gIFwiYFwiOiBcIiYjeDYwO1wiXG59O1xuXG52YXIgYmFkQ2hhcnMgPSAvWyY8PlwiJ2BdL2c7XG52YXIgcG9zc2libGUgPSAvWyY8PlwiJ2BdLztcblxuZnVuY3Rpb24gZXNjYXBlQ2hhcihjaHIpIHtcbiAgcmV0dXJuIGVzY2FwZVtjaHJdIHx8IFwiJmFtcDtcIjtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kKG9iaiwgdmFsdWUpIHtcbiAgZm9yKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpIHtcbiAgICAgIG9ialtrZXldID0gdmFsdWVba2V5XTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5leHRlbmQgPSBleHRlbmQ7dmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbmV4cG9ydHMudG9TdHJpbmcgPSB0b1N0cmluZztcbi8vIFNvdXJjZWQgZnJvbSBsb2Rhc2hcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iZXN0aWVqcy9sb2Rhc2gvYmxvYi9tYXN0ZXIvTElDRU5TRS50eHRcbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn07XG4vLyBmYWxsYmFjayBmb3Igb2xkZXIgdmVyc2lvbnMgb2YgQ2hyb21lIGFuZCBTYWZhcmlcbmlmIChpc0Z1bmN0aW9uKC94LykpIHtcbiAgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgfTtcbn1cbnZhciBpc0Z1bmN0aW9uO1xuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpID8gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XScgOiBmYWxzZTtcbn07XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBlc2NhcGVFeHByZXNzaW9uKHN0cmluZykge1xuICAvLyBkb24ndCBlc2NhcGUgU2FmZVN0cmluZ3MsIHNpbmNlIHRoZXkncmUgYWxyZWFkeSBzYWZlXG4gIGlmIChzdHJpbmcgaW5zdGFuY2VvZiBTYWZlU3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy50b1N0cmluZygpO1xuICB9IGVsc2UgaWYgKCFzdHJpbmcgJiYgc3RyaW5nICE9PSAwKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cblxuICAvLyBGb3JjZSBhIHN0cmluZyBjb252ZXJzaW9uIGFzIHRoaXMgd2lsbCBiZSBkb25lIGJ5IHRoZSBhcHBlbmQgcmVnYXJkbGVzcyBhbmRcbiAgLy8gdGhlIHJlZ2V4IHRlc3Qgd2lsbCBkbyB0aGlzIHRyYW5zcGFyZW50bHkgYmVoaW5kIHRoZSBzY2VuZXMsIGNhdXNpbmcgaXNzdWVzIGlmXG4gIC8vIGFuIG9iamVjdCdzIHRvIHN0cmluZyBoYXMgZXNjYXBlZCBjaGFyYWN0ZXJzIGluIGl0LlxuICBzdHJpbmcgPSBcIlwiICsgc3RyaW5nO1xuXG4gIGlmKCFwb3NzaWJsZS50ZXN0KHN0cmluZykpIHsgcmV0dXJuIHN0cmluZzsgfVxuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoYmFkQ2hhcnMsIGVzY2FwZUNoYXIpO1xufVxuXG5leHBvcnRzLmVzY2FwZUV4cHJlc3Npb24gPSBlc2NhcGVFeHByZXNzaW9uO2Z1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSAmJiB2YWx1ZSAhPT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnRzLmlzRW1wdHkgPSBpc0VtcHR5OyIsInZhciBiYXNlICAgICAgID0gcmVxdWlyZSgnLi9saWIvYmFzZScpO1xudmFyIFNhZmVTdHJpbmcgPSByZXF1aXJlKCcuL2xpYi9zYWZlLXN0cmluZycpO1xudmFyIEV4Y2VwdGlvbiAgPSByZXF1aXJlKCcuL2xpYi9leGNlcHRpb24nKTtcbnZhciBVdGlscyAgICAgID0gcmVxdWlyZSgnLi9saWIvdXRpbHMnKTtcbnZhciBydW50aW1lICAgID0gcmVxdWlyZSgnLi9saWIvcnVudGltZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiBjcmVhdGUgKCkge1xuICB2YXIgZGIgPSBuZXcgYmFzZS5ET01CYXJzRW52aXJvbm1lbnQoKTtcblxuICBVdGlscy5leHRlbmQoZGIsIGJhc2UpO1xuICBkYi5WTSAgICAgICAgID0gcnVudGltZTtcbiAgZGIuVXRpbHMgICAgICA9IFV0aWxzO1xuICBkYi5jcmVhdGUgICAgID0gY3JlYXRlO1xuICBkYi5FeGNlcHRpb24gID0gRXhjZXB0aW9uO1xuICBkYi5TYWZlU3RyaW5nID0gU2FmZVN0cmluZztcblxuICBkYi50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChzcGVjKSB7XG4gICAgcmV0dXJuIHJ1bnRpbWUudGVtcGxhdGUoc3BlYywgZGIpO1xuICB9O1xuXG4gIHJldHVybiBkYjtcbn0pKCk7XG4iLCJcbi8qKlxuICogRXhwb3NlIGBwYXJzZWAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZTtcblxuLyoqXG4gKiBXcmFwIG1hcCBmcm9tIGpxdWVyeS5cbiAqL1xuXG52YXIgbWFwID0ge1xuICBsZWdlbmQ6IFsxLCAnPGZpZWxkc2V0PicsICc8L2ZpZWxkc2V0PiddLFxuICB0cjogWzIsICc8dGFibGU+PHRib2R5PicsICc8L3Rib2R5PjwvdGFibGU+J10sXG4gIGNvbDogWzIsICc8dGFibGU+PHRib2R5PjwvdGJvZHk+PGNvbGdyb3VwPicsICc8L2NvbGdyb3VwPjwvdGFibGU+J10sXG4gIF9kZWZhdWx0OiBbMCwgJycsICcnXVxufTtcblxubWFwLnRkID1cbm1hcC50aCA9IFszLCAnPHRhYmxlPjx0Ym9keT48dHI+JywgJzwvdHI+PC90Ym9keT48L3RhYmxlPiddO1xuXG5tYXAub3B0aW9uID1cbm1hcC5vcHRncm91cCA9IFsxLCAnPHNlbGVjdCBtdWx0aXBsZT1cIm11bHRpcGxlXCI+JywgJzwvc2VsZWN0PiddO1xuXG5tYXAudGhlYWQgPVxubWFwLnRib2R5ID1cbm1hcC5jb2xncm91cCA9XG5tYXAuY2FwdGlvbiA9XG5tYXAudGZvb3QgPSBbMSwgJzx0YWJsZT4nLCAnPC90YWJsZT4nXTtcblxubWFwLnRleHQgPVxubWFwLmNpcmNsZSA9XG5tYXAuZWxsaXBzZSA9XG5tYXAubGluZSA9XG5tYXAucGF0aCA9XG5tYXAucG9seWdvbiA9XG5tYXAucG9seWxpbmUgPVxubWFwLnJlY3QgPSBbMSwgJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZlcnNpb249XCIxLjFcIj4nLCc8L3N2Zz4nXTtcblxuLyoqXG4gKiBQYXJzZSBgaHRtbGAgYW5kIHJldHVybiB0aGUgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGh0bWxcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2UoaHRtbCkge1xuICBpZiAoJ3N0cmluZycgIT0gdHlwZW9mIGh0bWwpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1N0cmluZyBleHBlY3RlZCcpO1xuICBcbiAgLy8gdGFnIG5hbWVcbiAgdmFyIG0gPSAvPChbXFx3Ol0rKS8uZXhlYyhodG1sKTtcbiAgaWYgKCFtKSByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoaHRtbCk7XG5cbiAgaHRtbCA9IGh0bWwucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpOyAvLyBSZW1vdmUgbGVhZGluZy90cmFpbGluZyB3aGl0ZXNwYWNlXG5cbiAgdmFyIHRhZyA9IG1bMV07XG5cbiAgLy8gYm9keSBzdXBwb3J0XG4gIGlmICh0YWcgPT0gJ2JvZHknKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaHRtbCcpO1xuICAgIGVsLmlubmVySFRNTCA9IGh0bWw7XG4gICAgcmV0dXJuIGVsLnJlbW92ZUNoaWxkKGVsLmxhc3RDaGlsZCk7XG4gIH1cblxuICAvLyB3cmFwIG1hcFxuICB2YXIgd3JhcCA9IG1hcFt0YWddIHx8IG1hcC5fZGVmYXVsdDtcbiAgdmFyIGRlcHRoID0gd3JhcFswXTtcbiAgdmFyIHByZWZpeCA9IHdyYXBbMV07XG4gIHZhciBzdWZmaXggPSB3cmFwWzJdO1xuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZWwuaW5uZXJIVE1MID0gcHJlZml4ICsgaHRtbCArIHN1ZmZpeDtcbiAgd2hpbGUgKGRlcHRoLS0pIGVsID0gZWwubGFzdENoaWxkO1xuXG4gIC8vIG9uZSBlbGVtZW50XG4gIGlmIChlbC5maXJzdENoaWxkID09IGVsLmxhc3RDaGlsZCkge1xuICAgIHJldHVybiBlbC5yZW1vdmVDaGlsZChlbC5maXJzdENoaWxkKTtcbiAgfVxuXG4gIC8vIHNldmVyYWwgZWxlbWVudHNcbiAgdmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICB3aGlsZSAoZWwuZmlyc3RDaGlsZCkge1xuICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGVsLnJlbW92ZUNoaWxkKGVsLmZpcnN0Q2hpbGQpKTtcbiAgfVxuXG4gIHJldHVybiBmcmFnbWVudDtcbn1cbiIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcblwiV2Vha01hcFwiIGluIHRoaXMgfHwgKGZ1bmN0aW9uIChtb2R1bGUpIHtcInVzZSBzdHJpY3RcIjtcblxuICAvLyEoQykgV2ViUmVmbGVjdGlvbiAtIE1pdCBTdHlsZSBMaWNlbnNlXG4gIC8vIHNpemUgYW5kIHBlcmZvcm1hbmNlcyBvcmllbnRlZCBwb2x5ZmlsbCBmb3IgRVM2XG4gIC8vIFdlYWtNYXAsIE1hcCwgYW5kIFNldFxuICAvLyBjb21wYXRpYmxlIHdpdGggbm9kZS5qcywgUmhpbm8sIGFueSBicm93c2VyXG4gIC8vIGRvZXMgbm90IGltcGxlbWVudCBkZWZhdWx0IHZhdWxlIGR1cmluZyB3bS5nZXQoKVxuICAvLyBzaW5jZSBFUy5uZXh0IHdvbid0IHByb2JhYmx5IGRvIHRoYXRcbiAgLy8gdXNlIHdtLmhhcyhvKSA/IHdtLmdldChvKSA6IGQzZmF1bHQ7IGluc3RlYWRcblxuICAvLyBXZWFrTWFwKHZvaWQpOldlYWtNYXBcbiAgZnVuY3Rpb24gV2Vha01hcCgpIHtcblxuICAgIC8vIHByaXZhdGUgcmVmZXJlbmNlcyBob2xkZXJzXG4gICAgdmFyXG4gICAgICBrZXlzID0gW10sXG4gICAgICB2YWx1ZXMgPSBbXVxuICAgIDtcblxuICAgIC8vIHJldHVybnMgZnJlc2hseSBuZXcgY3JlYXRlZFxuICAgIC8vIGluc3RhbmNlb2YgV2Vha01hcCBpbiBhbnkgY2FzZVxuICAgIHJldHVybiBjcmVhdGUoV2Vha01hcFByb3RvdHlwZSwge1xuICAgICAgLy8gV2Vha01hcCNkZWxldGUoa2V5OnZvaWQqKTpib29sZWFuXG4gICAgICBcImRlbGV0ZVwiOiB7dmFsdWU6IGJpbmQuY2FsbChzaGFyZWREZWwsIE5VTEwsIFRSVUUsIGtleXMsIHZhbHVlcyl9LFxuICAgICAgLy86d2FzIFdlYWtNYXAjZ2V0KGtleTp2b2lkKlssIGQzZmF1bHQ6dm9pZCpdKTp2b2lkKlxuICAgICAgLy8gV2Vha01hcCNnZXQoa2V5OnZvaWQqKTp2b2lkKlxuICAgICAgZ2V0OiAgICAgIHt2YWx1ZTogYmluZC5jYWxsKHNoYXJlZEdldCwgTlVMTCwgVFJVRSwga2V5cywgdmFsdWVzKX0sXG4gICAgICAvLyBXZWFrTWFwI2hhcyhrZXk6dm9pZCopOmJvb2xlYW5cbiAgICAgIGhhczogICAgICB7dmFsdWU6IGJpbmQuY2FsbChzaGFyZWRIYXMsIE5VTEwsIFRSVUUsIGtleXMsIHZhbHVlcyl9LFxuICAgICAgLy8gV2Vha01hcCNzZXQoa2V5OnZvaWQqLCB2YWx1ZTp2b2lkKik6dm9pZFxuICAgICAgc2V0OiAgICAgIHt2YWx1ZTogYmluZC5jYWxsKHNoYXJlZFNldCwgTlVMTCwgVFJVRSwga2V5cywgdmFsdWVzKX1cbiAgICB9KTtcblxuICB9XG5cbiAgLy8gTWFwKHZvaWQpOk1hcFxuICBmdW5jdGlvbiBNYXAoKSB7XG5cbiAgICAvLyBwcml2YXRlIHJlZmVyZW5jZXMgaG9sZGVyc1xuICAgIHZhclxuICAgICAga2V5cyA9IFtdLFxuICAgICAgdmFsdWVzID0gW11cbiAgICA7XG5cbiAgICAvLyByZXR1cm5zIGZyZXNobHkgbmV3IGNyZWF0ZWRcbiAgICAvLyBpbnN0YW5jZW9mIFdlYWtNYXAgaW4gYW55IGNhc2VcbiAgICByZXR1cm4gY3JlYXRlKE1hcFByb3RvdHlwZSwge1xuICAgICAgLy8gTWFwI2RlbGV0ZShrZXk6dm9pZCopOmJvb2xlYW5cbiAgICAgIFwiZGVsZXRlXCI6IHt2YWx1ZTogYmluZC5jYWxsKHNoYXJlZERlbCwgTlVMTCwgRkFMU0UsIGtleXMsIHZhbHVlcyl9LFxuICAgICAgLy86d2FzIE1hcCNnZXQoa2V5OnZvaWQqWywgZDNmYXVsdDp2b2lkKl0pOnZvaWQqXG4gICAgICAvLyBNYXAjZ2V0KGtleTp2b2lkKik6dm9pZCpcbiAgICAgIGdldDogICAgICB7dmFsdWU6IGJpbmQuY2FsbChzaGFyZWRHZXQsIE5VTEwsIEZBTFNFLCBrZXlzLCB2YWx1ZXMpfSxcbiAgICAgIC8vIE1hcCNoYXMoa2V5OnZvaWQqKTpib29sZWFuXG4gICAgICBoYXM6ICAgICAge3ZhbHVlOiBiaW5kLmNhbGwoc2hhcmVkSGFzLCBOVUxMLCBGQUxTRSwga2V5cywgdmFsdWVzKX0sXG4gICAgICAvLyBNYXAjc2V0KGtleTp2b2lkKiwgdmFsdWU6dm9pZCopOnZvaWRcbiAgICAgIHNldDogICAgICB7dmFsdWU6IGJpbmQuY2FsbChzaGFyZWRTZXQsIE5VTEwsIEZBTFNFLCBrZXlzLCB2YWx1ZXMpfVxuICAgICAgLyosXG4gICAgICAvLyBNYXAjc2l6ZSh2b2lkKTpudW1iZXIgPT09IE1vemlsbGEgb25seSBzbyBmYXJcbiAgICAgIHNpemU6ICAgICB7dmFsdWU6IGJpbmQuY2FsbChzaGFyZWRTaXplLCBOVUxMLCBrZXlzKX0sXG4gICAgICAvLyBNYXAja2V5cyh2b2lkKTpBcnJheSA9PT0gbm90IGluIHNwZWNzXG4gICAgICBrZXlzOiAgICAge3ZhbHVlOiBib3VuZFNsaWNlKGtleXMpfSxcbiAgICAgIC8vIE1hcCN2YWx1ZXModm9pZCk6QXJyYXkgPT09IG5vdCBpbiBzcGVjc1xuICAgICAgdmFsdWVzOiAgIHt2YWx1ZTogYm91bmRTbGljZSh2YWx1ZXMpfSxcbiAgICAgIC8vIE1hcCNpdGVyYXRlKGNhbGxiYWNrOkZ1bmN0aW9uLCBjb250ZXh0OnZvaWQqKTp2b2lkID09PiBjYWxsYmFjay5jYWxsKGNvbnRleHQsIGtleSwgdmFsdWUsIGluZGV4KSA9PT0gbm90IGluIHNwZWNzXG4gICAgICBpdGVyYXRlOiAge3ZhbHVlOiBiaW5kLmNhbGwoc2hhcmVkSXRlcmF0ZSwgTlVMTCwgRkFMU0UsIGtleXMsIHZhbHVlcyl9XG4gICAgICAvLyovXG4gICAgfSk7XG5cbiAgfVxuXG4gIC8vIFNldCh2b2lkKTpTZXRcbiAgLyoqXG4gICAqIHRvIGJlIHJlYWxseSBob25lc3QsIEkgd291bGQgcmF0aGVyIHBvbGx1dGUgQXJyYXkucHJvdG90eXBlXG4gICAqIGluIG9yZGVyIHRvIGhhdmUgU2V0IGxpa2UgYmVoYXZpb3JcbiAgICogT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQXJyYXkucHJvdG90eXBlLCB7XG4gICAqICAgYWRkOiB7dmFsdWU6IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgKiAgICAgcmV0dXJuIC0xIDwgdGhpcy5pbmRleE9mKHZhbHVlKSAmJiAhIXRoaXMucHVzaCh2YWx1ZSk7XG4gICAqICAgfX1cbiAgICogICBoYXM6IHt2YWx1ZTogZnVuY3Rpb24gaGFzKHZhbHVlKSB7XG4gICAqICAgICByZXR1cm4gLTEgPCB0aGlzLmluZGV4T2YodmFsdWUpO1xuICAgKiAgIH19XG4gICAqICAgZGVsZXRlOiB7dmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZSh2YWx1ZSkge1xuICAgKiAgICAgdmFyIGkgPSB0aGlzLmluZGV4T2YodmFsdWUpO1xuICAgKiAgICAgcmV0dXJuIC0xIDwgaSAmJiAhIXRoaXMuc3BsaWNlKGksIDEpO1xuICAgKiAgIH19XG4gICAqIH0pO1xuICAgKiAuLi4gYW55d2F5IC4uLlxuICAgKi9cbiAgZnVuY3Rpb24gU2V0KCkge1xuICAgIHZhclxuICAgICAga2V5cyA9IFtdLCAgLy8gcGxhY2Vob2xkZXIgdXNlZCBzaW1wbHkgdG8gcmVjeWNsZSBmdW5jdGlvbnNcbiAgICAgIHZhbHVlcyA9IFtdLC8vIHJlYWwgc3RvcmFnZVxuICAgICAgaGFzID0gYmluZC5jYWxsKHNoYXJlZEhhcywgTlVMTCwgRkFMU0UsIHZhbHVlcywga2V5cylcbiAgICA7XG4gICAgcmV0dXJuIGNyZWF0ZShTZXRQcm90b3R5cGUsIHtcbiAgICAgIC8vIFNldCNkZWxldGUodmFsdWU6dm9pZCopOmJvb2xlYW5cbiAgICAgIFwiZGVsZXRlXCI6IHt2YWx1ZTogYmluZC5jYWxsKHNoYXJlZERlbCwgTlVMTCwgRkFMU0UsIHZhbHVlcywga2V5cyl9LFxuICAgICAgLy8gU2V0I2hhcyh2YWx1ZTp2b2lkKik6Ym9vbGVhblxuICAgICAgaGFzOiAgICAgIHt2YWx1ZTogaGFzfSxcbiAgICAgIC8vIFNldCNhZGQodmFsdWU6dm9pZCopOmJvb2xlYW5cbiAgICAgIGFkZDogICAgICB7dmFsdWU6IGJpbmQuY2FsbChTZXRfYWRkLCBOVUxMLCBGQUxTRSwgaGFzLCB2YWx1ZXMpfVxuICAgICAgLyosXG4gICAgICAvLyBNYXAjc2l6ZSh2b2lkKTpudW1iZXIgPT09IE1vemlsbGEgb25seVxuICAgICAgc2l6ZTogICAgIHt2YWx1ZTogYmluZC5jYWxsKHNoYXJlZFNpemUsIE5VTEwsIHZhbHVlcyl9LFxuICAgICAgLy8gU2V0I3ZhbHVlcyh2b2lkKTpBcnJheSA9PT0gbm90IGluIHNwZWNzXG4gICAgICB2YWx1ZXM6ICAge3ZhbHVlOiBib3VuZFNsaWNlKHZhbHVlcyl9LFxuICAgICAgLy8gU2V0I2l0ZXJhdGUoY2FsbGJhY2s6RnVuY3Rpb24sIGNvbnRleHQ6dm9pZCopOnZvaWQgPT0+IGNhbGxiYWNrLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4KSA9PT0gbm90IGluIHNwZWNzXG4gICAgICBpdGVyYXRlOiAge3ZhbHVlOiBiaW5kLmNhbGwoU2V0X2l0ZXJhdGUsIE5VTEwsIEZBTFNFLCBOVUxMLCB2YWx1ZXMpfVxuICAgICAgLy8qL1xuICAgIH0pO1xuICB9XG5cbiAgLy8gY29tbW9uIHNoYXJlZCBtZXRob2QgcmVjeWNsZWQgZm9yIGFsbCBzaGltcyB0aHJvdWdoIGJpbmRcbiAgZnVuY3Rpb24gc2hhcmVkRGVsKG9iamVjdE9ubHksIGtleXMsIHZhbHVlcywga2V5KSB7XG4gICAgaWYgKHNoYXJlZEhhcyhvYmplY3RPbmx5LCBrZXlzLCB2YWx1ZXMsIGtleSkpIHtcbiAgICAgIGtleXMuc3BsaWNlKGksIDEpO1xuICAgICAgdmFsdWVzLnNwbGljZShpLCAxKTtcbiAgICB9XG4gICAgLy8gQXVyb3JhIGhlcmUgZG9lcyBpdCB3aGlsZSBDYW5hcnkgZG9lc24ndFxuICAgIHJldHVybiAtMSA8IGk7XG4gIH1cblxuICBmdW5jdGlvbiBzaGFyZWRHZXQob2JqZWN0T25seSwga2V5cywgdmFsdWVzLCBrZXkvKiwgZDNmYXVsdCovKSB7XG4gICAgcmV0dXJuIHNoYXJlZEhhcyhvYmplY3RPbmx5LCBrZXlzLCB2YWx1ZXMsIGtleSkgPyB2YWx1ZXNbaV0gOiB1bmRlZmluZWQ7IC8vZDNmYXVsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNoYXJlZEhhcyhvYmplY3RPbmx5LCBrZXlzLCB2YWx1ZXMsIGtleSkge1xuICAgIGlmIChvYmplY3RPbmx5ICYmIGtleSAhPT0gT2JqZWN0KGtleSkpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibm90IGEgbm9uLW51bGwgb2JqZWN0XCIpXG4gICAgO1xuICAgIGkgPSBiZXR0ZXJJbmRleE9mLmNhbGwoa2V5cywga2V5KTtcbiAgICByZXR1cm4gLTEgPCBpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hhcmVkU2V0KG9iamVjdE9ubHksIGtleXMsIHZhbHVlcywga2V5LCB2YWx1ZSkge1xuICAgIC8qIHJldHVybiAqL3NoYXJlZEhhcyhvYmplY3RPbmx5LCBrZXlzLCB2YWx1ZXMsIGtleSkgP1xuICAgICAgdmFsdWVzW2ldID0gdmFsdWVcbiAgICAgIDpcbiAgICAgIHZhbHVlc1trZXlzLnB1c2goa2V5KSAtIDFdID0gdmFsdWVcbiAgICA7XG4gIH1cblxuICAvKiBrZXlzLCB2YWx1ZXMsIGFuZCBpdGVyYXRlIHJlbGF0ZWQgbWV0aG9kc1xuICBmdW5jdGlvbiBib3VuZFNsaWNlKHZhbHVlcykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gc2xpY2UuY2FsbCh2YWx1ZXMpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzaGFyZWRTaXplKGtleXMpIHtcbiAgICByZXR1cm4ga2V5cy5sZW5ndGg7XG4gIH1cblxuICBmdW5jdGlvbiBzaGFyZWRJdGVyYXRlKG9iamVjdE9ubHksIGtleXMsIHZhbHVlcywgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICBmb3IgKHZhclxuICAgICAgayA9IHNsaWNlLmNhbGwoa2V5cyksIHYgPSBzbGljZS5jYWxsKHZhbHVlcyksXG4gICAgICBpID0gMCwgbGVuZ3RoID0gay5sZW5ndGg7XG4gICAgICBpIDwgbGVuZ3RoOyBjYWxsYmFjay5jYWxsKGNvbnRleHQsIGtbaV0sIHZbaV0sIGkrKylcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gU2V0X2l0ZXJhdGUob2JqZWN0T25seSwga2V5cywgdmFsdWVzLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgIGZvciAodmFyXG4gICAgICB2ID0gc2xpY2UuY2FsbCh2YWx1ZXMpLFxuICAgICAgaSA9IDAsIGxlbmd0aCA9IHYubGVuZ3RoO1xuICAgICAgaSA8IGxlbmd0aDsgY2FsbGJhY2suY2FsbChjb250ZXh0LCB2W2ldLCBpKyspXG4gICAgKTtcbiAgfVxuICAvLyovXG5cbiAgLy8gU2V0I2FkZCByZWN5Y2xlZCB0aHJvdWdoIGJpbmQgcGVyIGVhY2ggaW5zdGFuY2VvZiBTZXRcbiAgZnVuY3Rpb24gU2V0X2FkZChvYmplY3RPbmx5LCBoYXMsIHZhbHVlcywgdmFsdWUpIHtcbiAgICAvKnJldHVybiAqLyghaGFzKHZhbHVlKSAmJiAhIXZhbHVlcy5wdXNoKHZhbHVlKSk7XG4gIH1cblxuICAvLyBhIG1vcmUgcmVsaWFibGUgaW5kZXhPZlxuICBmdW5jdGlvbiBiZXR0ZXJJbmRleE9mKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9IHZhbHVlIHx8IHZhbHVlID09PSAwKSB7XG4gICAgICBmb3IgKGkgPSB0aGlzLmxlbmd0aDsgaS0tICYmICFpcyh0aGlzW2ldLCB2YWx1ZSk7KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaSA9IGluZGV4T2YuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBpO1xuICB9XG5cbiAgLy8gbmVlZCBmb3IgYW4gZW1wdHkgY29uc3RydWN0b3IgLi4uXG4gIGZ1bmN0aW9uIENvbnN0cnVjdG9yKCl7fSAgLy8gR0MnZWQgaWYgISFPYmplY3QuY3JlYXRlXG4gIC8vIC4uLiBzbyB0aGF0IG5ldyBXZWFrTWFwSW5zdGFuY2UgYW5kIG5ldyBXZWFrTWFwXG4gIC8vIHByb2R1Y2VzIGJvdGggYW4gaW5zdGFuY2VvZiBXZWFrTWFwXG5cbiAgdmFyXG4gICAgLy8gc2hvcnRjdXRzIGFuZCAuLi5cbiAgICBOVUxMID0gbnVsbCwgVFJVRSA9IHRydWUsIEZBTFNFID0gZmFsc2UsXG4gICAgbm90SW5Ob2RlID0gbW9kdWxlID09IFwidW5kZWZpbmVkXCIsXG4gICAgd2luZG93ID0gbm90SW5Ob2RlID8gdGhpcyA6IGdsb2JhbCxcbiAgICBtb2R1bGUgPSBub3RJbk5vZGUgPyB7fSA6IGV4cG9ydHMsXG4gICAgT2JqZWN0ID0gd2luZG93Lk9iamVjdCxcbiAgICBXZWFrTWFwUHJvdG90eXBlID0gV2Vha01hcC5wcm90b3R5cGUsXG4gICAgTWFwUHJvdG90eXBlID0gTWFwLnByb3RvdHlwZSxcbiAgICBTZXRQcm90b3R5cGUgPSBTZXQucHJvdG90eXBlLFxuICAgIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LFxuICAgIHNsaWNlID0gW10uc2xpY2UsXG5cbiAgICAvLyBPYmplY3QuaXMoYSwgYikgc2hpbVxuICAgIGlzID0gT2JqZWN0LmlzIHx8IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYSA9PT0gYiA/XG4gICAgICAgIGEgIT09IDAgfHwgMSAvIGEgPT0gMSAvIGIgOlxuICAgICAgICBhICE9IGEgJiYgYiAhPSBiXG4gICAgICA7XG4gICAgfSxcblxuICAgIC8vIHBhcnRpYWwgcG9seWZpbGwgZm9yIHRoaXMgYWltIG9ubHlcbiAgICBiaW5kID0gV2Vha01hcC5iaW5kIHx8IGZ1bmN0aW9uIGJpbmQoY29udGV4dCwgb2JqZWN0T25seSwga2V5cywgdmFsdWVzKSB7XG4gICAgICAvLyBwYXJ0aWFsIGZhc3QgYWQtaG9jIEZ1bmN0aW9uI2JpbmQgcG9seWZpbGwgaWYgbm90IGF2YWlsYWJsZVxuICAgICAgdmFyIGNhbGxiYWNrID0gdGhpcztcbiAgICAgIHJldHVybiBmdW5jdGlvbiBib3VuZChrZXksIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKGNvbnRleHQsIG9iamVjdE9ubHksIGtleXMsIHZhbHVlcywga2V5LCB2YWx1ZSk7XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICBjcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShwcm90bywgZGVzY3JpcHRvcikge1xuICAgICAgLy8gcGFydGlhbCBhZC1ob2MgT2JqZWN0LmNyZWF0ZSBzaGltIGlmIG5vdCBhdmFpbGFibGVcbiAgICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgdmFyIG9iamVjdCA9IG5ldyBDb25zdHJ1Y3Rvciwga2V5O1xuICAgICAgZm9yIChrZXkgaW4gZGVzY3JpcHRvcikge1xuICAgICAgICBvYmplY3Rba2V5XSA9IGRlc2NyaXB0b3Jba2V5XS52YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcblxuICAgIGluZGV4T2YgPSBbXS5pbmRleE9mIHx8IGZ1bmN0aW9uIGluZGV4T2YodmFsdWUpIHtcbiAgICAgIC8vIHBhcnRpYWwgZmFzdCBBcnJheSNpbmRleE9mIHBvbHlmaWxsIGlmIG5vdCBhdmFpbGFibGVcbiAgICAgIGZvciAoaSA9IHRoaXMubGVuZ3RoOyBpLS0gJiYgdGhpc1tpXSAhPT0gdmFsdWU7KTtcbiAgICAgIHJldHVybiBpO1xuICAgIH0sXG5cbiAgICB1bmRlZmluZWQsXG4gICAgaSAvLyByZWN5Y2xlIEFMTCB0aGUgdmFyaWFibGVzICFcbiAgO1xuXG4gIC8vIH5pbmRleE9mLmNhbGwoW05hTl0sIE5hTikgYXMgZnV0dXJlIHBvc3NpYmxlIGZlYXR1cmUgZGV0ZWN0aW9uXG5cbiAgLy8gdXNlZCB0byBmb2xsb3cgRkYgYmVoYXZpb3Igd2hlcmUgV2Vha01hcC5wcm90b3R5cGUgaXMgYSBXZWFrTWFwIGl0c2VsZlxuICBXZWFrTWFwLnByb3RvdHlwZSA9IFdlYWtNYXBQcm90b3R5cGUgPSBXZWFrTWFwKCk7XG4gIE1hcC5wcm90b3R5cGUgPSBNYXBQcm90b3R5cGUgPSBNYXAoKTtcbiAgU2V0LnByb3RvdHlwZSA9IFNldFByb3RvdHlwZSA9IFNldCgpO1xuXG4gIC8vIGFzc2lnbiBpdCB0byB0aGUgZ2xvYmFsIGNvbnRleHRcbiAgLy8gaWYgYWxyZWFkeSB0aGVyZSwgZS5nLiBpbiBub2RlLCBleHBvcnQgbmF0aXZlXG4gIHdpbmRvdy5XZWFrTWFwID0gbW9kdWxlLldlYWtNYXAgPSB3aW5kb3cuV2Vha01hcCB8fCBXZWFrTWFwO1xuICB3aW5kb3cuTWFwID0gbW9kdWxlLk1hcCA9IHdpbmRvdy5NYXAgfHwgTWFwO1xuICB3aW5kb3cuU2V0ID0gbW9kdWxlLlNldCA9IHdpbmRvdy5TZXQgfHwgU2V0O1xuXG4gIC8qIHByb2JhYmx5IG5vdCBuZWVkZWQsIGFkZCBhIHNsYXNoIHRvIGVuc3VyZSBub24gY29uZmlndXJhYmxlIGFuZCBub24gd3JpdGFibGVcbiAgaWYgKGRlZmluZVByb3BlcnR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkod2luZG93LCBcIldlYWtNYXBcIiwge3ZhbHVlOiBXZWFrTWFwfSk7XG4gICAgZGVmaW5lUHJvcGVydHkod2luZG93LCBcIk1hcFwiLCB7dmFsdWU6IE1hcH0pO1xuICAgIGRlZmluZVByb3BlcnR5KHdpbmRvdywgXCJTZXRcIiwge3ZhbHVlOiBTZXR9KTtcbiAgfVxuICAvLyovXG5cbiAgLy8gdGhhdCdzIHByZXR0eSBtdWNoIGl0XG5cbn0uY2FsbChcbiAgdGhpcyxcbiAgdHlwZW9mIGV4cG9ydHNcbikpO1xufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCIvKiEgS2FtaW5vIHYwLjAuMSB8IGh0dHA6Ly9naXRodWIuY29tL0N5cmlsLXNmL2thbWluby5qcyB8IENvcHlyaWdodCAyMDEyLCBLaXQgQ2FtYnJpZGdlIHwgaHR0cDovL2tpdC5taXQtbGljZW5zZS5vcmcgKi9cbihmdW5jdGlvbih3aW5kb3cpIHtcbiAgLy8gQ29udmVuaWVuY2UgYWxpYXNlcy5cbiAgdmFyIGdldENsYXNzID0ge30udG9TdHJpbmcsIGlzUHJvcGVydHksIGZvckVhY2gsIHVuZGVmO1xuXG4gIEthbWlubyA9IHt9O1xuICBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBLYW1pbm87XG4gICAgfVxuICAgIGV4cG9ydHMuS2FtaW5vID0gS2FtaW5vO1xuICB9IGVsc2Uge1xuICAgIHdpbmRvd1snS2FtaW5vJ10gPSBLYW1pbm87XG4gIH1cblxuICBLYW1pbm8uVkVSU0lPTiA9ICcwLjEuMCc7XG5cbiAgS2FtaW5vRXhjZXB0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5uYW1lID0gXCJLYW1pbm9FeGNlcHRpb25cIjtcbiAgICB0aGlzLm51bWJlciA9IDI1O1xuICAgIHRoaXMubWVzc2FnZSA9IFwiVW5jYXVnaHQgRXJyb3I6IERBVEFfQ0xPTkVfRVJSOiBLYW1pbm8gRXhjZXB0aW9uIDI1XCI7XG4gIH07XG5cbiAgLy8gVGVzdCB0aGUgYERhdGUjZ2V0VVRDKmAgbWV0aG9kcy4gQmFzZWQgb24gd29yayBieSBAWWFmZmxlLlxuICB2YXIgaXNFeHRlbmRlZCA9IG5ldyBEYXRlKC0zNTA5ODI3MzM0NTczMjkyKTtcbiAgdHJ5IHtcbiAgICAvLyBUaGUgYGdldFVUQ0Z1bGxZZWFyYCwgYE1vbnRoYCwgYW5kIGBEYXRlYCBtZXRob2RzIHJldHVybiBub25zZW5zaWNhbFxuICAgIC8vIHJlc3VsdHMgZm9yIGNlcnRhaW4gZGF0ZXMgaW4gT3BlcmEgPj0gMTAuNTMuXG4gICAgaXNFeHRlbmRlZCA9IGlzRXh0ZW5kZWQuZ2V0VVRDRnVsbFllYXIoKSA9PSAtMTA5MjUyICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTW9udGgoKSA9PT0gMCAmJiBpc0V4dGVuZGVkLmdldFVUQ0RhdGUoKSA9PSAxICYmXG4gICAgICAvLyBTYWZhcmkgPCAyLjAuMiBzdG9yZXMgdGhlIGludGVybmFsIG1pbGxpc2Vjb25kIHRpbWUgdmFsdWUgY29ycmVjdGx5LFxuICAgICAgLy8gYnV0IGNsaXBzIHRoZSB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGRhdGUgbWV0aG9kcyB0byB0aGUgcmFuZ2Ugb2ZcbiAgICAgIC8vIHNpZ25lZCAzMi1iaXQgaW50ZWdlcnMgKFstMiAqKiAzMSwgMiAqKiAzMSAtIDFdKS5cbiAgICAgIGlzRXh0ZW5kZWQuZ2V0VVRDSG91cnMoKSA9PSAxMCAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbnV0ZXMoKSA9PSAzNyAmJiBpc0V4dGVuZGVkLmdldFVUQ1NlY29uZHMoKSA9PSA2ICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTWlsbGlzZWNvbmRzKCkgPT0gNzA4O1xuICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG5cbiAgLy8gSUUgPD0gNyBkb2Vzbid0IHN1cHBvcnQgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIHVzaW5nIHNxdWFyZVxuICAvLyBicmFja2V0IG5vdGF0aW9uLiBJRSA4IG9ubHkgc3VwcG9ydHMgdGhpcyBmb3IgcHJpbWl0aXZlcy5cbiAgdmFyIGNoYXJJbmRleEJ1Z2d5ID0gXCJBXCJbMF0gIT0gXCJBXCI7XG5cbiAgLy8gRGVmaW5lIGFkZGl0aW9uYWwgdXRpbGl0eSBtZXRob2RzIGlmIHRoZSBgRGF0ZWAgbWV0aG9kcyBhcmUgYnVnZ3kuXG4gIGlmICghaXNFeHRlbmRlZCkge1xuICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gICAgLy8gQSBtYXBwaW5nIGJldHdlZW4gdGhlIG1vbnRocyBvZiB0aGUgeWVhciBhbmQgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW5cbiAgICAvLyBKYW51YXJ5IDFzdCBhbmQgdGhlIGZpcnN0IG9mIHRoZSByZXNwZWN0aXZlIG1vbnRoLlxuICAgIHZhciBNb250aHMgPSBbMCwgMzEsIDU5LCA5MCwgMTIwLCAxNTEsIDE4MSwgMjEyLCAyNDMsIDI3MywgMzA0LCAzMzRdO1xuICAgIC8vIEludGVybmFsOiBDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuIHRoZSBVbml4IGVwb2NoIGFuZCB0aGVcbiAgICAvLyBmaXJzdCBkYXkgb2YgdGhlIGdpdmVuIG1vbnRoLlxuICAgIHZhciBnZXREYXkgPSBmdW5jdGlvbiAoeWVhciwgbW9udGgpIHtcbiAgICAgIHJldHVybiBNb250aHNbbW9udGhdICsgMzY1ICogKHllYXIgLSAxOTcwKSArIGZsb29yKCh5ZWFyIC0gMTk2OSArIChtb250aCA9ICsobW9udGggPiAxKSkpIC8gNCkgLSBmbG9vcigoeWVhciAtIDE5MDEgKyBtb250aCkgLyAxMDApICsgZmxvb3IoKHllYXIgLSAxNjAxICsgbW9udGgpIC8gNDAwKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgaWYgYSBwcm9wZXJ0eSBpcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiB0aGUgZ2l2ZW5cbiAgLy8gb2JqZWN0LiBEZWxlZ2F0ZXMgdG8gdGhlIG5hdGl2ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBtZXRob2QuXG4gIGlmICghKGlzUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eSkpIHtcbiAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICB2YXIgbWVtYmVycyA9IHt9LCBjb25zdHJ1Y3RvcjtcbiAgICAgIGlmICgobWVtYmVycy5fX3Byb3RvX18gPSBudWxsLCBtZW1iZXJzLl9fcHJvdG9fXyA9IHtcbiAgICAgICAgLy8gVGhlICpwcm90byogcHJvcGVydHkgY2Fubm90IGJlIHNldCBtdWx0aXBsZSB0aW1lcyBpbiByZWNlbnRcbiAgICAgICAgLy8gdmVyc2lvbnMgb2YgRmlyZWZveCBhbmQgU2VhTW9ua2V5LlxuICAgICAgICBcInRvU3RyaW5nXCI6IDFcbiAgICAgIH0sIG1lbWJlcnMpLnRvU3RyaW5nICE9IGdldENsYXNzKSB7XG4gICAgICAgIC8vIFNhZmFyaSA8PSAyLjAuMyBkb2Vzbid0IGltcGxlbWVudCBgT2JqZWN0I2hhc093blByb3BlcnR5YCwgYnV0XG4gICAgICAgIC8vIHN1cHBvcnRzIHRoZSBtdXRhYmxlICpwcm90byogcHJvcGVydHkuXG4gICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAvLyBDYXB0dXJlIGFuZCBicmVhayB0aGUgb2JqZWN0J3MgcHJvdG90eXBlIGNoYWluIChzZWUgc2VjdGlvbiA4LjYuMlxuICAgICAgICAgIC8vIG9mIHRoZSBFUyA1LjEgc3BlYykuIFRoZSBwYXJlbnRoZXNpemVkIGV4cHJlc3Npb24gcHJldmVudHMgYW5cbiAgICAgICAgICAvLyB1bnNhZmUgdHJhbnNmb3JtYXRpb24gYnkgdGhlIENsb3N1cmUgQ29tcGlsZXIuXG4gICAgICAgICAgdmFyIG9yaWdpbmFsID0gdGhpcy5fX3Byb3RvX18sIHJlc3VsdCA9IHByb3BlcnR5IGluICh0aGlzLl9fcHJvdG9fXyA9IG51bGwsIHRoaXMpO1xuICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHByb3RvdHlwZSBjaGFpbi5cbiAgICAgICAgICB0aGlzLl9fcHJvdG9fXyA9IG9yaWdpbmFsO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDYXB0dXJlIGEgcmVmZXJlbmNlIHRvIHRoZSB0b3AtbGV2ZWwgYE9iamVjdGAgY29uc3RydWN0b3IuXG4gICAgICAgIGNvbnN0cnVjdG9yID0gbWVtYmVycy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgLy8gVXNlIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IHRvIHNpbXVsYXRlIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGluXG4gICAgICAgIC8vIG90aGVyIGVudmlyb25tZW50cy5cbiAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgIHZhciBwYXJlbnQgPSAodGhpcy5jb25zdHJ1Y3RvciB8fCBjb25zdHJ1Y3RvcikucHJvdG90eXBlO1xuICAgICAgICAgIHJldHVybiBwcm9wZXJ0eSBpbiB0aGlzICYmICEocHJvcGVydHkgaW4gcGFyZW50ICYmIHRoaXNbcHJvcGVydHldID09PSBwYXJlbnRbcHJvcGVydHldKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIG1lbWJlcnMgPSBudWxsO1xuICAgICAgcmV0dXJuIGlzUHJvcGVydHkuY2FsbCh0aGlzLCBwcm9wZXJ0eSk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIEludGVybmFsOiBOb3JtYWxpemVzIHRoZSBgZm9yLi4uaW5gIGl0ZXJhdGlvbiBhbGdvcml0aG0gYWNyb3NzXG4gIC8vIGVudmlyb25tZW50cy4gRWFjaCBlbnVtZXJhdGVkIGtleSBpcyB5aWVsZGVkIHRvIGEgYGNhbGxiYWNrYCBmdW5jdGlvbi5cbiAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNpemUgPSAwLCBQcm9wZXJ0aWVzLCBtZW1iZXJzLCBwcm9wZXJ0eSwgZm9yRWFjaDtcblxuICAgIC8vIFRlc3RzIGZvciBidWdzIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50J3MgYGZvci4uLmluYCBhbGdvcml0aG0uIFRoZVxuICAgIC8vIGB2YWx1ZU9mYCBwcm9wZXJ0eSBpbmhlcml0cyB0aGUgbm9uLWVudW1lcmFibGUgZmxhZyBmcm9tXG4gICAgLy8gYE9iamVjdC5wcm90b3R5cGVgIGluIG9sZGVyIHZlcnNpb25zIG9mIElFLCBOZXRzY2FwZSwgYW5kIE1vemlsbGEuXG4gICAgKFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnZhbHVlT2YgPSAwO1xuICAgIH0pLnByb3RvdHlwZS52YWx1ZU9mID0gMDtcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYFByb3BlcnRpZXNgIGNsYXNzLlxuICAgIG1lbWJlcnMgPSBuZXcgUHJvcGVydGllcygpO1xuICAgIGZvciAocHJvcGVydHkgaW4gbWVtYmVycykge1xuICAgICAgLy8gSWdub3JlIGFsbCBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cbiAgICAgIGlmIChpc1Byb3BlcnR5LmNhbGwobWVtYmVycywgcHJvcGVydHkpKSB7XG4gICAgICAgIHNpemUrKztcbiAgICAgIH1cbiAgICB9XG4gICAgUHJvcGVydGllcyA9IG1lbWJlcnMgPSBudWxsO1xuXG4gICAgLy8gTm9ybWFsaXplIHRoZSBpdGVyYXRpb24gYWxnb3JpdGhtLlxuICAgIGlmICghc2l6ZSkge1xuICAgICAgLy8gQSBsaXN0IG9mIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgaW5oZXJpdGVkIGZyb20gYE9iamVjdC5wcm90b3R5cGVgLlxuICAgICAgbWVtYmVycyA9IFtcInZhbHVlT2ZcIiwgXCJ0b1N0cmluZ1wiLCBcInRvTG9jYWxlU3RyaW5nXCIsIFwicHJvcGVydHlJc0VudW1lcmFibGVcIiwgXCJpc1Byb3RvdHlwZU9mXCIsIFwiaGFzT3duUHJvcGVydHlcIiwgXCJjb25zdHJ1Y3RvclwiXTtcbiAgICAgIC8vIElFIDw9IDgsIE1vemlsbGEgMS4wLCBhbmQgTmV0c2NhcGUgNi4yIGlnbm9yZSBzaGFkb3dlZCBub24tZW51bWVyYWJsZVxuICAgICAgLy8gcHJvcGVydGllcy5cbiAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBcIltvYmplY3QgRnVuY3Rpb25dXCIsIHByb3BlcnR5LCBsZW5ndGg7XG4gICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgLy8gR2Vja28gPD0gMS4wIGVudW1lcmF0ZXMgdGhlIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyB1bmRlclxuICAgICAgICAgIC8vIGNlcnRhaW4gY29uZGl0aW9uczsgSUUgZG9lcyBub3QuXG4gICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFudWFsbHkgaW52b2tlIHRoZSBjYWxsYmFjayBmb3IgZWFjaCBub24tZW51bWVyYWJsZSBwcm9wZXJ0eS5cbiAgICAgICAgZm9yIChsZW5ndGggPSBtZW1iZXJzLmxlbmd0aDsgcHJvcGVydHkgPSBtZW1iZXJzWy0tbGVuZ3RoXTsgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmIGNhbGxiYWNrKHByb3BlcnR5KSk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoc2l6ZSA9PSAyKSB7XG4gICAgICAvLyBTYWZhcmkgPD0gMi4wLjQgZW51bWVyYXRlcyBzaGFkb3dlZCBwcm9wZXJ0aWVzIHR3aWNlLlxuICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIHNldCBvZiBpdGVyYXRlZCBwcm9wZXJ0aWVzLlxuICAgICAgICB2YXIgbWVtYmVycyA9IHt9LCBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IFwiW29iamVjdCBGdW5jdGlvbl1cIiwgcHJvcGVydHk7XG4gICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgLy8gU3RvcmUgZWFjaCBwcm9wZXJ0eSBuYW1lIHRvIHByZXZlbnQgZG91YmxlIGVudW1lcmF0aW9uLiBUaGVcbiAgICAgICAgICAvLyBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgaXMgbm90IGVudW1lcmF0ZWQgZHVlIHRvIGNyb3NzLVxuICAgICAgICAgIC8vIGVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cbiAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmICFpc1Byb3BlcnR5LmNhbGwobWVtYmVycywgcHJvcGVydHkpICYmIChtZW1iZXJzW3Byb3BlcnR5XSA9IDEpICYmIGlzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm8gYnVncyBkZXRlY3RlZDsgdXNlIHRoZSBzdGFuZGFyZCBgZm9yLi4uaW5gIGFsZ29yaXRobS5cbiAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBcIltvYmplY3QgRnVuY3Rpb25dXCIsIHByb3BlcnR5LCBpc0NvbnN0cnVjdG9yO1xuICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmICEoaXNDb25zdHJ1Y3RvciA9IHByb3BlcnR5ID09PSBcImNvbnN0cnVjdG9yXCIpKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IGR1ZSB0b1xuICAgICAgICAvLyBjcm9zcy1lbnZpcm9ubWVudCBpbmNvbnNpc3RlbmNpZXMuXG4gICAgICAgIGlmIChpc0NvbnN0cnVjdG9yIHx8IGlzUHJvcGVydHkuY2FsbChvYmplY3QsIChwcm9wZXJ0eSA9IFwiY29uc3RydWN0b3JcIikpKSB7XG4gICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZm9yRWFjaChvYmplY3QsIGNhbGxiYWNrKTtcbiAgfTtcblxuICAvLyBQdWJsaWM6IFNlcmlhbGl6ZXMgYSBKYXZhU2NyaXB0IGB2YWx1ZWAgYXMgYSBzdHJpbmcuIFRoZSBvcHRpb25hbFxuICAvLyBgZmlsdGVyYCBhcmd1bWVudCBtYXkgc3BlY2lmeSBlaXRoZXIgYSBmdW5jdGlvbiB0aGF0IGFsdGVycyBob3cgb2JqZWN0IGFuZFxuICAvLyBhcnJheSBtZW1iZXJzIGFyZSBzZXJpYWxpemVkLCBvciBhbiBhcnJheSBvZiBzdHJpbmdzIGFuZCBudW1iZXJzIHRoYXRcbiAgLy8gaW5kaWNhdGVzIHdoaWNoIHByb3BlcnRpZXMgc2hvdWxkIGJlIHNlcmlhbGl6ZWQuIFRoZSBvcHRpb25hbCBgd2lkdGhgXG4gIC8vIGFyZ3VtZW50IG1heSBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgbnVtYmVyIHRoYXQgc3BlY2lmaWVzIHRoZSBpbmRlbnRhdGlvblxuICAvLyBsZXZlbCBvZiB0aGUgb3V0cHV0LlxuXG4gIC8vIEludGVybmFsOiBBIG1hcCBvZiBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuXG4gIHZhciBFc2NhcGVzID0ge1xuICAgIFwiXFxcXFwiOiBcIlxcXFxcXFxcXCIsXG4gICAgJ1wiJzogJ1xcXFxcIicsXG4gICAgXCJcXGJcIjogXCJcXFxcYlwiLFxuICAgIFwiXFxmXCI6IFwiXFxcXGZcIixcbiAgICBcIlxcblwiOiBcIlxcXFxuXCIsXG4gICAgXCJcXHJcIjogXCJcXFxcclwiLFxuICAgIFwiXFx0XCI6IFwiXFxcXHRcIlxuICB9O1xuXG4gIC8vIEludGVybmFsOiBDb252ZXJ0cyBgdmFsdWVgIGludG8gYSB6ZXJvLXBhZGRlZCBzdHJpbmcgc3VjaCB0aGF0IGl0c1xuICAvLyBsZW5ndGggaXMgYXQgbGVhc3QgZXF1YWwgdG8gYHdpZHRoYC4gVGhlIGB3aWR0aGAgbXVzdCBiZSA8PSA2LlxuICB2YXIgdG9QYWRkZWRTdHJpbmcgPSBmdW5jdGlvbiAod2lkdGgsIHZhbHVlKSB7XG4gICAgLy8gVGhlIGB8fCAwYCBleHByZXNzaW9uIGlzIG5lY2Vzc2FyeSB0byB3b3JrIGFyb3VuZCBhIGJ1ZyBpblxuICAgIC8vIE9wZXJhIDw9IDcuNTR1MiB3aGVyZSBgMCA9PSAtMGAsIGJ1dCBgU3RyaW5nKC0wKSAhPT0gXCIwXCJgLlxuICAgIHJldHVybiAoXCIwMDAwMDBcIiArICh2YWx1ZSB8fCAwKSkuc2xpY2UoLXdpZHRoKTtcbiAgfTtcblxuICAvLyBJbnRlcm5hbDogRG91YmxlLXF1b3RlcyBhIHN0cmluZyBgdmFsdWVgLCByZXBsYWNpbmcgYWxsIEFTQ0lJIGNvbnRyb2xcbiAgLy8gY2hhcmFjdGVycyAoY2hhcmFjdGVycyB3aXRoIGNvZGUgdW5pdCB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAzMSkgd2l0aFxuICAvLyB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICAvLyBgUXVvdGUodmFsdWUpYCBvcGVyYXRpb24gZGVmaW5lZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxuICB2YXIgcXVvdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gJ1wiJywgaW5kZXggPSAwLCBzeW1ib2w7XG4gICAgZm9yICg7IHN5bWJvbCA9IHZhbHVlLmNoYXJBdChpbmRleCk7IGluZGV4KyspIHtcbiAgICAgIC8vIEVzY2FwZSB0aGUgcmV2ZXJzZSBzb2xpZHVzLCBkb3VibGUgcXVvdGUsIGJhY2tzcGFjZSwgZm9ybSBmZWVkLCBsaW5lXG4gICAgICAvLyBmZWVkLCBjYXJyaWFnZSByZXR1cm4sIGFuZCB0YWIgY2hhcmFjdGVycy5cbiAgICAgIHJlc3VsdCArPSAnXFxcXFwiXFxiXFxmXFxuXFxyXFx0Jy5pbmRleE9mKHN5bWJvbCkgPiAtMSA/IEVzY2FwZXNbc3ltYm9sXSA6XG4gICAgICAgIC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgYSBjb250cm9sIGNoYXJhY3RlciwgYXBwZW5kIGl0cyBVbmljb2RlIGVzY2FwZVxuICAgICAgICAvLyBzZXF1ZW5jZTsgb3RoZXJ3aXNlLCBhcHBlbmQgdGhlIGNoYXJhY3RlciBhcy1pcy5cbiAgICAgICAgKEVzY2FwZXNbc3ltYm9sXSA9IHN5bWJvbCA8IFwiIFwiID8gXCJcXFxcdTAwXCIgKyB0b1BhZGRlZFN0cmluZygyLCBzeW1ib2wuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpIDogc3ltYm9sKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdCArICdcIic7XG4gIH07XG5cbiAgLy8gSW50ZXJuYWw6IGRldGVjdHMgaWYgYW4gb2JqZWN0IGlzIGEgRE9NIGVsZW1lbnQuXG4gIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzg0Mjg2L2phdmFzY3JpcHQtaXNkb20taG93LWRvLXlvdS1jaGVjay1pZi1hLWphdmFzY3JpcHQtb2JqZWN0LWlzLWEtZG9tLW9iamVjdFxuICB2YXIgaXNFbGVtZW50ID0gZnVuY3Rpb24obykge1xuICAgIHJldHVybiAoXG4gICAgICB0eXBlb2YgSFRNTEVsZW1lbnQgPT09IFwib2JqZWN0XCIgPyBvIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgOiAvL0RPTTJcbiAgICAgIG8gJiYgdHlwZW9mIG8gPT09IFwib2JqZWN0XCIgJiYgby5ub2RlVHlwZSA9PT0gMSAmJiB0eXBlb2Ygby5ub2RlTmFtZT09PVwic3RyaW5nXCJcbiAgICApO1xuICB9O1xuXG4gIC8vIEludGVybmFsOiBSZWN1cnNpdmVseSBzZXJpYWxpemVzIGFuIG9iamVjdC4gSW1wbGVtZW50cyB0aGVcbiAgLy8gYFN0cihrZXksIGhvbGRlcilgLCBgSk8odmFsdWUpYCwgYW5kIGBKQSh2YWx1ZSlgIG9wZXJhdGlvbnMuXG4gIHZhciBzZXJpYWxpemUgPSBmdW5jdGlvbiAocHJvcGVydHksIG9iamVjdCwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjaykge1xuICAgIHZhciB2YWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV0sIG9yaWdpbmFsQ2xhc3NOYW1lLCBjbGFzc05hbWUsIHllYXIsIG1vbnRoLCBkYXRlLCB0aW1lLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCByZXN1bHRzLCBlbGVtZW50LCBpbmRleCwgbGVuZ3RoLCBwcmVmaXgsIGFueSwgcmVzdWx0LFxuICAgICAgICByZWdFeHBTb3VyY2UsIHJlZ0V4cE1vZGlmaWVycyA9IFwiXCI7XG4gICAgaWYoIHZhbHVlIGluc3RhbmNlb2YgRXJyb3IgfHwgdmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEthbWlub0V4Y2VwdGlvbigpO1xuICAgIH1cbiAgICBpZiggaXNFbGVtZW50KCB2YWx1ZSApICkge1xuICAgICAgdGhyb3cgbmV3IEthbWlub0V4Y2VwdGlvbigpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcbiAgICAgIG9yaWdpbmFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSk7XG4gICAgICBpZiAob3JpZ2luYWxDbGFzc05hbWUgPT0gXCJbb2JqZWN0IERhdGVdXCIgJiYgIWlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpIHtcbiAgICAgICAgaWYgKHZhbHVlID4gLTEgLyAwICYmIHZhbHVlIDwgMSAvIDApIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvVVRDU3RyaW5nKCkucmVwbGFjZShcIkdNVFwiLCBcIlVUQ1wiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlLnRvSlNPTiA9PSBcImZ1bmN0aW9uXCIgJiYgKChvcmlnaW5hbENsYXNzTmFtZSAhPSBcIltvYmplY3QgTnVtYmVyXVwiICYmIG9yaWdpbmFsQ2xhc3NOYW1lICE9IFwiW29iamVjdCBTdHJpbmddXCIgJiYgb3JpZ2luYWxDbGFzc05hbWUgIT0gXCJbb2JqZWN0IEFycmF5XVwiKSB8fCBpc1Byb3BlcnR5LmNhbGwodmFsdWUsIFwidG9KU09OXCIpKSkge1xuICAgICAgICAvLyBQcm90b3R5cGUgPD0gMS42LjEgYWRkcyBub24tc3RhbmRhcmQgYHRvSlNPTmAgbWV0aG9kcyB0byB0aGVcbiAgICAgICAgLy8gYE51bWJlcmAsIGBTdHJpbmdgLCBgRGF0ZWAsIGFuZCBgQXJyYXlgIHByb3RvdHlwZXMuIEpTT04gM1xuICAgICAgICAvLyBpZ25vcmVzIGFsbCBgdG9KU09OYCBtZXRob2RzIG9uIHRoZXNlIG9iamVjdHMgdW5sZXNzIHRoZXkgYXJlXG4gICAgICAgIC8vIGRlZmluZWQgZGlyZWN0bHkgb24gYW4gaW5zdGFuY2UuXG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKHByb3BlcnR5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAvLyBJZiBhIHJlcGxhY2VtZW50IGZ1bmN0aW9uIHdhcyBwcm92aWRlZCwgY2FsbCBpdCB0byBvYnRhaW4gdGhlIHZhbHVlXG4gICAgICAvLyBmb3Igc2VyaWFsaXphdGlvbi5cbiAgICAgIHZhbHVlID0gY2FsbGJhY2suY2FsbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSk7XG4gICAgaWYgKGNsYXNzTmFtZSA9PSBcIltvYmplY3QgQm9vbGVhbl1cIikge1xuICAgICAgLy8gQm9vbGVhbnMgYXJlIHJlcHJlc2VudGVkIGxpdGVyYWxseS5cbiAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gXCJbb2JqZWN0IE51bWJlcl1cIikge1xuICAgICAgLy8gS2FtaW5vIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIGBJbmZpbml0eWAgYW5kIGBOYU5gIGFyZSBzZXJpYWxpemVkIGFzXG4gICAgICAvLyBgXCJudWxsXCJgLlxuICAgICAgaWYoIHZhbHVlID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgKSB7XG4gICAgICAgIHJldHVybiBcIkluZmluaXR5XCI7XG4gICAgICB9IGVsc2UgaWYoIHZhbHVlID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgKSB7XG4gICAgICAgIHJldHVybiBcIk5JbmZpbml0eVwiO1xuICAgICAgfSBlbHNlIGlmKCBpc05hTiggdmFsdWUgKSApIHtcbiAgICAgICAgcmV0dXJuIFwiTmFOXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IFwiW29iamVjdCBSZWdFeHBdXCIpIHtcbiAgICAgIC8vIFN0cmluZ3MgYXJlIGRvdWJsZS1xdW90ZWQgYW5kIGVzY2FwZWQuXG4gICAgICByZWdFeHBTb3VyY2UgPSB2YWx1ZS5zb3VyY2U7XG4gICAgICByZWdFeHBNb2RpZmllcnMgKz0gdmFsdWUuaWdub3JlQ2FzZSA/IFwiaVwiIDogXCJcIjtcbiAgICAgIHJlZ0V4cE1vZGlmaWVycyArPSB2YWx1ZS5nbG9iYWwgPyBcImdcIiA6IFwiXCI7XG4gICAgICByZWdFeHBNb2RpZmllcnMgKz0gdmFsdWUubXVsdGlsaW5lID8gXCJtXCIgOiBcIlwiO1xuXG4gICAgICByZWdFeHBTb3VyY2UgPSBxdW90ZShjaGFySW5kZXhCdWdneSA/IHJlZ0V4cFNvdXJjZS5zcGxpdChcIlwiKSA6IHJlZ0V4cFNvdXJjZSk7XG4gICAgICByZWdFeHBNb2RpZmllcnMgPSBxdW90ZShjaGFySW5kZXhCdWdneSA/IHJlZ0V4cE1vZGlmaWVycy5zcGxpdChcIlwiKSA6IHJlZ0V4cE1vZGlmaWVycyk7XG5cbiAgICAgIC8vIEFkZHMgdGhlIFJlZ0V4cCBwcmVmaXguXG4gICAgICB2YWx1ZSA9ICdeJyArIHJlZ0V4cFNvdXJjZSArIHJlZ0V4cE1vZGlmaWVycztcblxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IFwiW29iamVjdCBTdHJpbmddXCIpIHtcbiAgICAgIC8vIFN0cmluZ3MgYXJlIGRvdWJsZS1xdW90ZWQgYW5kIGVzY2FwZWQuXG4gICAgICB2YWx1ZSA9IHF1b3RlKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuc3BsaXQoXCJcIikgOiB2YWx1ZSk7XG5cbiAgICAgIGlmKCBvcmlnaW5hbENsYXNzTmFtZSA9PSBcIltvYmplY3QgRGF0ZV1cIikge1xuICAgICAgICAvLyBBZGRzIHRoZSBEYXRlIHByZWZpeC5cbiAgICAgICAgdmFsdWUgPSAnJScgKyB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIikge1xuICAgICAgLy8gQ2hlY2sgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGlzIGlzIGEgbGluZWFyIHNlYXJjaDsgcGVyZm9ybWFuY2VcbiAgICAgIC8vIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZiB1bmlxdWUgbmVzdGVkIG9iamVjdHMuXG4gICAgICBmb3IgKGxlbmd0aCA9IHN0YWNrLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG4gICAgICAgIGlmIChzdGFja1tsZW5ndGhdID09PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBcIiZcIiArIGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQWRkIHRoZSBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgICAgc3RhY2sucHVzaCh2YWx1ZSk7XG4gICAgICByZXN1bHRzID0gW107XG4gICAgICAvLyBTYXZlIHRoZSBjdXJyZW50IGluZGVudGF0aW9uIGxldmVsIGFuZCBpbmRlbnQgb25lIGFkZGl0aW9uYWwgbGV2ZWwuXG4gICAgICBwcmVmaXggPSBpbmRlbnRhdGlvbjtcbiAgICAgIGluZGVudGF0aW9uICs9IHdoaXRlc3BhY2U7XG4gICAgICBpZiAoY2xhc3NOYW1lID09IFwiW29iamVjdCBBcnJheV1cIikge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgYXJyYXkgZWxlbWVudHMuXG4gICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBhbnkgfHwgKGFueSA9IHRydWUpLCBpbmRleCsrKSB7XG4gICAgICAgICAgZWxlbWVudCA9IHNlcmlhbGl6ZShpbmRleCwgdmFsdWUsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spO1xuICAgICAgICAgIHJlc3VsdHMucHVzaChlbGVtZW50ID09PSB1bmRlZiA/IFwibnVsbFwiIDogZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gYW55ID8gKHdoaXRlc3BhY2UgPyBcIltcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwiXVwiIDogKFwiW1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwiXVwiKSkgOiBcIltdXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb2JqZWN0IG1lbWJlcnMuIE1lbWJlcnMgYXJlIHNlbGVjdGVkIGZyb21cbiAgICAgICAgLy8gZWl0aGVyIGEgdXNlci1zcGVjaWZpZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcywgb3IgdGhlIG9iamVjdFxuICAgICAgICAvLyBpdHNlbGYuXG4gICAgICAgIGZvckVhY2gocHJvcGVydGllcyB8fCB2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSBzZXJpYWxpemUocHJvcGVydHksIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcbiAgICAgICAgICBpZiAoZWxlbWVudCAhPT0gdW5kZWYpIHtcbiAgICAgICAgICAgIC8vIEFjY29yZGluZyB0byBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zOiBcIklmIGBnYXBgIHt3aGl0ZXNwYWNlfVxuICAgICAgICAgICAgLy8gaXMgbm90IHRoZSBlbXB0eSBzdHJpbmcsIGxldCBgbWVtYmVyYCB7cXVvdGUocHJvcGVydHkpICsgXCI6XCJ9XG4gICAgICAgICAgICAvLyBiZSB0aGUgY29uY2F0ZW5hdGlvbiBvZiBgbWVtYmVyYCBhbmQgdGhlIGBzcGFjZWAgY2hhcmFjdGVyLlwiXG4gICAgICAgICAgICAvLyBUaGUgXCJgc3BhY2VgIGNoYXJhY3RlclwiIHJlZmVycyB0byB0aGUgbGl0ZXJhbCBzcGFjZVxuICAgICAgICAgICAgLy8gY2hhcmFjdGVyLCBub3QgdGhlIGBzcGFjZWAge3dpZHRofSBhcmd1bWVudCBwcm92aWRlZCB0b1xuICAgICAgICAgICAgLy8gYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChxdW90ZShjaGFySW5kZXhCdWdneSA/IHByb3BlcnR5LnNwbGl0KFwiXCIpIDogcHJvcGVydHkpICsgXCI6XCIgKyAod2hpdGVzcGFjZSA/IFwiIFwiIDogXCJcIikgKyBlbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYW55IHx8IChhbnkgPSB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3VsdCA9IGFueSA/ICh3aGl0ZXNwYWNlID8gXCJ7XFxuXCIgKyBpbmRlbnRhdGlvbiArIHJlc3VsdHMuam9pbihcIixcXG5cIiArIGluZGVudGF0aW9uKSArIFwiXFxuXCIgKyBwcmVmaXggKyBcIn1cIiA6IChcIntcIiArIHJlc3VsdHMuam9pbihcIixcIikgKyBcIn1cIikpIDogXCJ7fVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH07XG5cbiAgLy8gUHVibGljOiBgS2FtaW5vLnN0cmluZ2lmeWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxuICBLYW1pbm8uc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHNvdXJjZSwgZmlsdGVyLCB3aWR0aCkge1xuICAgIHZhciB3aGl0ZXNwYWNlLCBjYWxsYmFjaywgcHJvcGVydGllcztcbiAgICBpZiAodHlwZW9mIGZpbHRlciA9PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIGZpbHRlciA9PSBcIm9iamVjdFwiICYmIGZpbHRlcikge1xuICAgICAgaWYgKGdldENsYXNzLmNhbGwoZmlsdGVyKSA9PSBcIltvYmplY3QgRnVuY3Rpb25dXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBmaWx0ZXI7XG4gICAgICB9IGVsc2UgaWYgKGdldENsYXNzLmNhbGwoZmlsdGVyKSA9PSBcIltvYmplY3QgQXJyYXldXCIpIHtcbiAgICAgICAgLy8gQ29udmVydCB0aGUgcHJvcGVydHkgbmFtZXMgYXJyYXkgaW50byBhIG1ha2VzaGlmdCBzZXQuXG4gICAgICAgIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW5ndGggPSBmaWx0ZXIubGVuZ3RoLCB2YWx1ZTsgaW5kZXggPCBsZW5ndGg7IHZhbHVlID0gZmlsdGVyW2luZGV4KytdLCAoKGdldENsYXNzLmNhbGwodmFsdWUpID09IFwiW29iamVjdCBTdHJpbmddXCIgfHwgZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkgPT0gXCJbb2JqZWN0IE51bWJlcl1cIikgJiYgKHByb3BlcnRpZXNbdmFsdWVdID0gMSkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHdpZHRoKSB7XG4gICAgICBpZiAoZ2V0Q2xhc3MuY2FsbCh3aWR0aCkgPT0gXCJbb2JqZWN0IE51bWJlcl1cIikge1xuICAgICAgICAvLyBDb252ZXJ0IHRoZSBgd2lkdGhgIHRvIGFuIGludGVnZXIgYW5kIGNyZWF0ZSBhIHN0cmluZyBjb250YWluaW5nXG4gICAgICAgIC8vIGB3aWR0aGAgbnVtYmVyIG9mIHNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAgIGlmICgod2lkdGggLT0gd2lkdGggJSAxKSA+IDApIHtcbiAgICAgICAgICBmb3IgKHdoaXRlc3BhY2UgPSBcIlwiLCB3aWR0aCA+IDEwICYmICh3aWR0aCA9IDEwKTsgd2hpdGVzcGFjZS5sZW5ndGggPCB3aWR0aDsgd2hpdGVzcGFjZSArPSBcIiBcIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZ2V0Q2xhc3MuY2FsbCh3aWR0aCkgPT0gXCJbb2JqZWN0IFN0cmluZ11cIikge1xuICAgICAgICB3aGl0ZXNwYWNlID0gd2lkdGgubGVuZ3RoIDw9IDEwID8gd2lkdGggOiB3aWR0aC5zbGljZSgwLCAxMCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIE9wZXJhIDw9IDcuNTR1MiBkaXNjYXJkcyB0aGUgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCBlbXB0eSBzdHJpbmcga2V5c1xuICAgIC8vIChgXCJcImApIG9ubHkgaWYgdGhleSBhcmUgdXNlZCBkaXJlY3RseSB3aXRoaW4gYW4gb2JqZWN0IG1lbWJlciBsaXN0XG4gICAgLy8gKGUuZy4sIGAhKFwiXCIgaW4geyBcIlwiOiAxfSlgKS5cbiAgICByZXR1cm4gc2VyaWFsaXplKFwiXCIsICh2YWx1ZSA9IHt9LCB2YWx1ZVtcIlwiXSA9IHNvdXJjZSwgdmFsdWUpLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgXCJcIiwgW10pO1xuICB9O1xuXG4gIC8vIFB1YmxpYzogUGFyc2VzIGEgc291cmNlIHN0cmluZy5cbiAgdmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbiAgLy8gSW50ZXJuYWw6IEEgbWFwIG9mIGVzY2FwZWQgY29udHJvbCBjaGFyYWN0ZXJzIGFuZCB0aGVpciB1bmVzY2FwZWRcbiAgLy8gZXF1aXZhbGVudHMuXG4gIHZhciBVbmVzY2FwZXMgPSB7XG4gICAgXCJcXFxcXCI6IFwiXFxcXFwiLFxuICAgICdcIic6ICdcIicsXG4gICAgXCIvXCI6IFwiL1wiLFxuICAgIFwiYlwiOiBcIlxcYlwiLFxuICAgIFwidFwiOiBcIlxcdFwiLFxuICAgIFwiblwiOiBcIlxcblwiLFxuICAgIFwiZlwiOiBcIlxcZlwiLFxuICAgIFwiclwiOiBcIlxcclwiXG4gIH07XG5cbiAgLy8gSW50ZXJuYWw6IFN0b3JlcyB0aGUgcGFyc2VyIHN0YXRlLlxuICB2YXIgSW5kZXgsIFNvdXJjZSwgc3RhY2s7XG5cbiAgLy8gSW50ZXJuYWw6IFJlc2V0cyB0aGUgcGFyc2VyIHN0YXRlIGFuZCB0aHJvd3MgYSBgU3ludGF4RXJyb3JgLlxuICB2YXIgYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XG4gICAgdGhyb3cgU3ludGF4RXJyb3IoKTtcbiAgfTtcblxuICB2YXIgcGFyc2VTdHJpbmcgPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICBwcmVmaXggPSBwcmVmaXggfHwgXCJcIjtcbiAgICB2YXIgc291cmNlID0gU291cmNlLCBsZW5ndGggPSBzb3VyY2UubGVuZ3RoLCB2YWx1ZSwgc3ltYm9sLCBiZWdpbiwgcG9zaXRpb247XG4gICAgLy8gQWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kIHBhcnNlIGEgS2FtaW5vIHN0cmluZyBhdCB0aGVcbiAgICAvLyBjdXJyZW50IHBvc2l0aW9uLiBTdHJpbmcgdG9rZW5zIGFyZSBwcmVmaXhlZCB3aXRoIHRoZSBzZW50aW5lbFxuICAgIC8vIGBAYCBjaGFyYWN0ZXIgdG8gZGlzdGluZ3Vpc2ggdGhlbSBmcm9tIHB1bmN0dWF0b3JzLlxuICAgIGZvciAodmFsdWUgPSBwcmVmaXgsIEluZGV4Kys7IEluZGV4IDwgbGVuZ3RoOykge1xuICAgICAgc3ltYm9sID0gc291cmNlW0luZGV4XTtcbiAgICAgIGlmIChzeW1ib2wgPCBcIiBcIikge1xuICAgICAgICAvLyBVbmVzY2FwZWQgQVNDSUkgY29udHJvbCBjaGFyYWN0ZXJzIGFyZSBub3QgcGVybWl0dGVkLlxuICAgICAgICBhYm9ydCgpO1xuICAgICAgfSBlbHNlIGlmIChzeW1ib2wgPT0gXCJcXFxcXCIpIHtcbiAgICAgICAgLy8gUGFyc2UgZXNjYXBlZCBLYW1pbm8gY29udHJvbCBjaGFyYWN0ZXJzLCBgXCJgLCBgXFxgLCBgL2AsIGFuZFxuICAgICAgICAvLyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZXMuXG4gICAgICAgIHN5bWJvbCA9IHNvdXJjZVsrK0luZGV4XTtcbiAgICAgICAgaWYgKCdcXFxcXCIvYnRuZnInLmluZGV4T2Yoc3ltYm9sKSA+IC0xKSB7XG4gICAgICAgICAgLy8gUmV2aXZlIGVzY2FwZWQgY29udHJvbCBjaGFyYWN0ZXJzLlxuICAgICAgICAgIHZhbHVlICs9IFVuZXNjYXBlc1tzeW1ib2xdO1xuICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgIH0gZWxzZSBpZiAoc3ltYm9sID09IFwidVwiKSB7XG4gICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgYmVnaW4gPSArK0luZGV4O1xuICAgICAgICAgIC8vIFZhbGlkYXRlIHRoZSBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICBmb3IgKHBvc2l0aW9uID0gSW5kZXggKyA0OyBJbmRleCA8IHBvc2l0aW9uOyBJbmRleCsrKSB7XG4gICAgICAgICAgICBzeW1ib2wgPSBzb3VyY2VbSW5kZXhdO1xuICAgICAgICAgICAgLy8gQSB2YWxpZCBzZXF1ZW5jZSBjb21wcmlzZXMgZm91ciBoZXhkaWdpdHMgdGhhdCBmb3JtIGFcbiAgICAgICAgICAgIC8vIHNpbmdsZSBoZXhhZGVjaW1hbCB2YWx1ZS5cbiAgICAgICAgICAgIGlmICghKHN5bWJvbCA+PSBcIjBcIiAmJiBzeW1ib2wgPD0gXCI5XCIgfHwgc3ltYm9sID49IFwiYVwiICYmIHN5bWJvbCA8PSBcImZcIiB8fCBzeW1ib2wgPj0gXCJBXCIgJiYgc3ltYm9sIDw9IFwiRlwiKSkge1xuICAgICAgICAgICAgICAvLyBJbnZhbGlkIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXZpdmUgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAgICAgIHZhbHVlICs9IGZyb21DaGFyQ29kZShcIjB4XCIgKyBzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSW52YWxpZCBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHN5bWJvbCA9PSAnXCInKSB7XG4gICAgICAgICAgLy8gQW4gdW5lc2NhcGVkIGRvdWJsZS1xdW90ZSBjaGFyYWN0ZXIgbWFya3MgdGhlIGVuZCBvZiB0aGVcbiAgICAgICAgICAvLyBzdHJpbmcuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXBwZW5kIHRoZSBvcmlnaW5hbCBjaGFyYWN0ZXIgYXMtaXMuXG4gICAgICAgIHZhbHVlICs9IHN5bWJvbDtcbiAgICAgICAgSW5kZXgrKztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNvdXJjZVtJbmRleF0gPT0gJ1wiJykge1xuICAgICAgSW5kZXgrKztcbiAgICAgIC8vIFJldHVybiB0aGUgcmV2aXZlZCBzdHJpbmcuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8vIFVudGVybWluYXRlZCBzdHJpbmcuXG4gICAgYWJvcnQoKTtcbiAgfTtcblxuICAvLyBJbnRlcm5hbDogUmV0dXJucyB0aGUgbmV4dCB0b2tlbiwgb3IgYFwiJFwiYCBpZiB0aGUgcGFyc2VyIGhhcyByZWFjaGVkXG4gIC8vIHRoZSBlbmQgb2YgdGhlIHNvdXJjZSBzdHJpbmcuIEEgdG9rZW4gbWF5IGJlIGEgc3RyaW5nLCBudW1iZXIsIGBudWxsYFxuICAvLyBsaXRlcmFsLCBgTmFOYCBsaXRlcmFsIG9yIEJvb2xlYW4gbGl0ZXJhbC5cbiAgdmFyIGxleCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc291cmNlID0gU291cmNlLCBsZW5ndGggPSBzb3VyY2UubGVuZ3RoLCBzeW1ib2wsIHZhbHVlLCBiZWdpbiwgcG9zaXRpb24sIHNpZ24sXG4gICAgICAgIGRhdGVTdHJpbmcsIHJlZ0V4cFNvdXJjZSwgcmVnRXhwTW9kaWZpZXJzO1xuICAgIHdoaWxlIChJbmRleCA8IGxlbmd0aCkge1xuICAgICAgc3ltYm9sID0gc291cmNlW0luZGV4XTtcbiAgICAgIGlmIChcIlxcdFxcclxcbiBcIi5pbmRleE9mKHN5bWJvbCkgPiAtMSkge1xuICAgICAgICAvLyBTa2lwIHdoaXRlc3BhY2UgdG9rZW5zLCBpbmNsdWRpbmcgdGFicywgY2FycmlhZ2UgcmV0dXJucywgbGluZVxuICAgICAgICAvLyBmZWVkcywgYW5kIHNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAgIEluZGV4Kys7XG4gICAgICB9IGVsc2UgaWYgKFwie31bXTosXCIuaW5kZXhPZihzeW1ib2wpID4gLTEpIHtcbiAgICAgICAgLy8gUGFyc2UgYSBwdW5jdHVhdG9yIHRva2VuIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAgICBJbmRleCsrO1xuICAgICAgICByZXR1cm4gc3ltYm9sO1xuICAgICAgfSBlbHNlIGlmIChzeW1ib2wgPT0gJ1wiJykge1xuICAgICAgICAvLyBQYXJzZSBzdHJpbmdzLlxuICAgICAgICByZXR1cm4gcGFyc2VTdHJpbmcoXCJAXCIpO1xuICAgICAgfSBlbHNlIGlmIChzeW1ib2wgPT0gJyUnKSB7XG4gICAgICAgIC8vIFBhcnNlIGRhdGVzLlxuICAgICAgICBJbmRleCsrO1xuICAgICAgICBzeW1ib2wgPSBzb3VyY2VbSW5kZXhdO1xuICAgICAgICBpZihzeW1ib2wgPT0gJ1wiJykge1xuICAgICAgICAgIGRhdGVTdHJpbmcgPSBwYXJzZVN0cmluZygpO1xuICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSggZGF0ZVN0cmluZyApO1xuICAgICAgICB9XG4gICAgICAgIGFib3J0KCk7XG4gICAgICB9IGVsc2UgaWYgKHN5bWJvbCA9PSAnXicpIHtcbiAgICAgICAgLy8gUGFyc2UgcmVndWxhciBleHByZXNzaW9ucy5cbiAgICAgICAgSW5kZXgrKztcbiAgICAgICAgc3ltYm9sID0gc291cmNlW0luZGV4XTtcbiAgICAgICAgaWYoc3ltYm9sID09ICdcIicpIHtcbiAgICAgICAgICByZWdFeHBTb3VyY2UgPSBwYXJzZVN0cmluZygpO1xuXG4gICAgICAgICAgc3ltYm9sID0gc291cmNlW0luZGV4XTtcbiAgICAgICAgICBpZihzeW1ib2wgPT0gJ1wiJykge1xuICAgICAgICAgICAgcmVnRXhwTW9kaWZpZXJzID0gcGFyc2VTdHJpbmcoKTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoIHJlZ0V4cFNvdXJjZSwgcmVnRXhwTW9kaWZpZXJzICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFib3J0KCk7XG4gICAgICB9IGVsc2UgaWYgKHN5bWJvbCA9PSAnJicpIHtcbiAgICAgICAgLy8gUGFyc2Ugb2JqZWN0IHJlZmVyZW5jZXMuXG4gICAgICAgIEluZGV4Kys7XG4gICAgICAgIHN5bWJvbCA9IHNvdXJjZVtJbmRleF07XG4gICAgICAgIGlmIChzeW1ib2wgPj0gXCIwXCIgJiYgc3ltYm9sIDw9IFwiOVwiKSB7XG4gICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICByZXR1cm4gc3RhY2tbc3ltYm9sXTtcbiAgICAgICAgfVxuICAgICAgICBhYm9ydCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUGFyc2UgbnVtYmVycyBhbmQgbGl0ZXJhbHMuXG4gICAgICAgIGJlZ2luID0gSW5kZXg7XG4gICAgICAgIC8vIEFkdmFuY2UgdGhlIHNjYW5uZXIncyBwb3NpdGlvbiBwYXN0IHRoZSBzaWduLCBpZiBvbmUgaXNcbiAgICAgICAgLy8gc3BlY2lmaWVkLlxuICAgICAgICBpZiAoc3ltYm9sID09IFwiLVwiKSB7XG4gICAgICAgICAgc2lnbiA9IHRydWU7XG4gICAgICAgICAgc3ltYm9sID0gc291cmNlWysrSW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhcnNlIGFuIGludGVnZXIgb3IgZmxvYXRpbmctcG9pbnQgdmFsdWUuXG4gICAgICAgIGlmIChzeW1ib2wgPj0gXCIwXCIgJiYgc3ltYm9sIDw9IFwiOVwiKSB7XG4gICAgICAgICAgLy8gTGVhZGluZyB6ZXJvZXMgYXJlIGludGVycHJldGVkIGFzIG9jdGFsIGxpdGVyYWxzLlxuICAgICAgICAgIGlmIChzeW1ib2wgPT0gXCIwXCIgJiYgKHN5bWJvbCA9IHNvdXJjZVtJbmRleCArIDFdLCBzeW1ib2wgPj0gXCIwXCIgJiYgc3ltYm9sIDw9IFwiOVwiKSkge1xuICAgICAgICAgICAgLy8gSWxsZWdhbCBvY3RhbCBsaXRlcmFsLlxuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2lnbiA9IGZhbHNlO1xuICAgICAgICAgIC8vIFBhcnNlIHRoZSBpbnRlZ2VyIGNvbXBvbmVudC5cbiAgICAgICAgICBmb3IgKDsgSW5kZXggPCBsZW5ndGggJiYgKHN5bWJvbCA9IHNvdXJjZVtJbmRleF0sIHN5bWJvbCA+PSBcIjBcIiAmJiBzeW1ib2wgPD0gXCI5XCIpOyBJbmRleCsrKTtcbiAgICAgICAgICAvLyBGbG9hdHMgY2Fubm90IGNvbnRhaW4gYSBsZWFkaW5nIGRlY2ltYWwgcG9pbnQ7IGhvd2V2ZXIsIHRoaXNcbiAgICAgICAgICAvLyBjYXNlIGlzIGFscmVhZHkgYWNjb3VudGVkIGZvciBieSB0aGUgcGFyc2VyLlxuICAgICAgICAgIGlmIChzb3VyY2VbSW5kZXhdID09IFwiLlwiKSB7XG4gICAgICAgICAgICBwb3NpdGlvbiA9ICsrSW5kZXg7XG4gICAgICAgICAgICAvLyBQYXJzZSB0aGUgZGVjaW1hbCBjb21wb25lbnQuXG4gICAgICAgICAgICBmb3IgKDsgcG9zaXRpb24gPCBsZW5ndGggJiYgKHN5bWJvbCA9IHNvdXJjZVtwb3NpdGlvbl0sIHN5bWJvbCA+PSBcIjBcIiAmJiBzeW1ib2wgPD0gXCI5XCIpOyBwb3NpdGlvbisrKTtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBJbmRleCkge1xuICAgICAgICAgICAgICAvLyBJbGxlZ2FsIHRyYWlsaW5nIGRlY2ltYWwuXG4gICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBJbmRleCA9IHBvc2l0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBQYXJzZSBleHBvbmVudHMuXG4gICAgICAgICAgc3ltYm9sID0gc291cmNlW0luZGV4XTtcbiAgICAgICAgICBpZiAoc3ltYm9sID09IFwiZVwiIHx8IHN5bWJvbCA9PSBcIkVcIikge1xuICAgICAgICAgICAgLy8gU2tpcCBwYXN0IHRoZSBzaWduIGZvbGxvd2luZyB0aGUgZXhwb25lbnQsIGlmIG9uZSBpc1xuICAgICAgICAgICAgLy8gc3BlY2lmaWVkLlxuICAgICAgICAgICAgc3ltYm9sID0gc291cmNlWysrSW5kZXhdO1xuICAgICAgICAgICAgaWYgKHN5bWJvbCA9PSBcIitcIiB8fCBzeW1ib2wgPT0gXCItXCIpIHtcbiAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBleHBvbmVudGlhbCBjb21wb25lbnQuXG4gICAgICAgICAgICBmb3IgKHBvc2l0aW9uID0gSW5kZXg7IHBvc2l0aW9uIDwgbGVuZ3RoICYmIChzeW1ib2wgPSBzb3VyY2VbcG9zaXRpb25dLCBzeW1ib2wgPj0gXCIwXCIgJiYgc3ltYm9sIDw9IFwiOVwiKTsgcG9zaXRpb24rKyk7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPT0gSW5kZXgpIHtcbiAgICAgICAgICAgICAgLy8gSWxsZWdhbCBlbXB0eSBleHBvbmVudC5cbiAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEluZGV4ID0gcG9zaXRpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIENvZXJjZSB0aGUgcGFyc2VkIHZhbHVlIHRvIGEgSmF2YVNjcmlwdCBudW1iZXIuXG4gICAgICAgICAgcmV0dXJuICtzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBIG5lZ2F0aXZlIHNpZ24gbWF5IG9ubHkgcHJlY2VkZSBudW1iZXJzLlxuICAgICAgICBpZiAoc2lnbikge1xuICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYHRydWVgLCBgZmFsc2VgLCBgSW5maW5pdHlgLCBgLUluZmluaXR5YCwgYE5hTmAgYW5kIGBudWxsYCBsaXRlcmFscy5cbiAgICAgICAgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA0KSA9PSBcInRydWVcIikge1xuICAgICAgICAgIEluZGV4ICs9IDQ7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDUpID09IFwiZmFsc2VcIikge1xuICAgICAgICAgIEluZGV4ICs9IDU7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA4KSA9PSBcIkluZmluaXR5XCIpIHtcbiAgICAgICAgICBJbmRleCArPSA4O1xuICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgOSkgPT0gXCJOSW5maW5pdHlcIikge1xuICAgICAgICAgIEluZGV4ICs9IDk7XG4gICAgICAgICAgcmV0dXJuIC1JbmZpbml0eTtcbiAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgMykgPT0gXCJOYU5cIikge1xuICAgICAgICAgIEluZGV4ICs9IDM7XG4gICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNCkgPT0gXCJudWxsXCIpIHtcbiAgICAgICAgICBJbmRleCArPSA0O1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVucmVjb2duaXplZCB0b2tlbi5cbiAgICAgICAgYWJvcnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmV0dXJuIHRoZSBzZW50aW5lbCBgJGAgY2hhcmFjdGVyIGlmIHRoZSBwYXJzZXIgaGFzIHJlYWNoZWQgdGhlIGVuZFxuICAgIC8vIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLlxuICAgIHJldHVybiBcIiRcIjtcbiAgfTtcblxuICAvLyBJbnRlcm5hbDogUGFyc2VzIGEgS2FtaW5vIGB2YWx1ZWAgdG9rZW4uXG4gIHZhciBnZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0cywgYW55LCBrZXk7XG4gICAgaWYgKHZhbHVlID09IFwiJFwiKSB7XG4gICAgICAvLyBVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dC5cbiAgICAgIGFib3J0KCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKHZhbHVlWzBdID09IFwiQFwiKSB7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgc2VudGluZWwgYEBgIGNoYXJhY3Rlci5cbiAgICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKDEpO1xuICAgICAgfVxuICAgICAgLy8gUGFyc2Ugb2JqZWN0IGFuZCBhcnJheSBsaXRlcmFscy5cbiAgICAgIGlmICh2YWx1ZSA9PSBcIltcIikge1xuICAgICAgICAvLyBQYXJzZXMgYSBLYW1pbm8gYXJyYXksIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IGFycmF5LlxuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIHN0YWNrW3N0YWNrLmxlbmd0aF0gPSByZXN1bHRzO1xuICAgICAgICBmb3IgKDs7IGFueSB8fCAoYW55ID0gdHJ1ZSkpIHtcbiAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgIC8vIEEgY2xvc2luZyBzcXVhcmUgYnJhY2tldCBtYXJrcyB0aGUgZW5kIG9mIHRoZSBhcnJheSBsaXRlcmFsLlxuICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIl1cIikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIElmIHRoZSBhcnJheSBsaXRlcmFsIGNvbnRhaW5zIGVsZW1lbnRzLCB0aGUgY3VycmVudCB0b2tlblxuICAgICAgICAgIC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRpbmcgdGhlIHByZXZpb3VzIGVsZW1lbnQgZnJvbSB0aGVcbiAgICAgICAgICAvLyBuZXh0LlxuICAgICAgICAgIGlmIChhbnkpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBhcnJheSBsaXRlcmFsLlxuICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBhcnJheSBlbGVtZW50LlxuICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBFbGlzaW9ucyBhbmQgbGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQuXG4gICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHRzLnB1c2goZ2V0KHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiICYmIGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuc3BsaXQoXCJcIikgOiB2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PSBcIntcIikge1xuICAgICAgICAvLyBQYXJzZXMgYSBLYW1pbm8gb2JqZWN0LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBvYmplY3QuXG4gICAgICAgIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgc3RhY2tbc3RhY2subGVuZ3RoXSA9IHJlc3VsdHM7XG4gICAgICAgIGZvciAoOzsgYW55IHx8IChhbnkgPSB0cnVlKSkge1xuICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgLy8gQSBjbG9zaW5nIGN1cmx5IGJyYWNlIG1hcmtzIHRoZSBlbmQgb2YgdGhlIG9iamVjdCBsaXRlcmFsLlxuICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIn1cIikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIElmIHRoZSBvYmplY3QgbGl0ZXJhbCBjb250YWlucyBtZW1iZXJzLCB0aGUgY3VycmVudCB0b2tlblxuICAgICAgICAgIC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRvci5cbiAgICAgICAgICBpZiAoYW55KSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0cmFpbGluZyBgLGAgaW4gb2JqZWN0IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gQSBgLGAgbXVzdCBzZXBhcmF0ZSBlYWNoIG9iamVjdCBtZW1iZXIuXG4gICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIExlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLCBvYmplY3QgcHJvcGVydHkgbmFtZXMgbXVzdCBiZVxuICAgICAgICAgIC8vIGRvdWJsZS1xdW90ZWQgc3RyaW5ncywgYW5kIGEgYDpgIG11c3Qgc2VwYXJhdGUgZWFjaCBwcm9wZXJ0eVxuICAgICAgICAgIC8vIG5hbWUgYW5kIHZhbHVlLlxuICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIiB8fCB0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIiB8fCB2YWx1ZVswXSAhPSBcIkBcIiB8fCBsZXgoKSAhPSBcIjpcIikge1xuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGxleCgpO1xuICAgICAgICAgIHJlc3VsdHNbdmFsdWUuc2xpY2UoMSldID0gZ2V0KHR5cGVvZiByZXN1bHQgPT0gXCJzdHJpbmdcIiAmJiBjaGFySW5kZXhCdWdneSA/IHJlc3VsdC5zcGxpdChcIlwiKSA6IHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICB9XG4gICAgICAvLyBVbmV4cGVjdGVkIHRva2VuIGVuY291bnRlcmVkLlxuICAgICAgYWJvcnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIC8vIEludGVybmFsOiBVcGRhdGVzIGEgdHJhdmVyc2VkIG9iamVjdCBtZW1iZXIuXG4gIHZhciB1cGRhdGUgPSBmdW5jdGlvbihzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjaykge1xuICAgIHZhciBlbGVtZW50ID0gd2Fsayhzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjayk7XG4gICAgaWYgKGVsZW1lbnQgPT09IHVuZGVmKSB7XG4gICAgICBkZWxldGUgc291cmNlW3Byb3BlcnR5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgc291cmNlW3Byb3BlcnR5XSA9IGVsZW1lbnQ7XG4gICAgfVxuICB9O1xuXG4gIC8vIEludGVybmFsOiBSZWN1cnNpdmVseSB0cmF2ZXJzZXMgYSBwYXJzZWQgS2FtaW5vIG9iamVjdCwgaW52b2tpbmcgdGhlXG4gIC8vIGBjYWxsYmFja2AgZnVuY3Rpb24gZm9yIGVhY2ggdmFsdWUuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gIC8vIGBXYWxrKGhvbGRlciwgbmFtZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXG4gIHZhciB3YWxrID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgdmFyIHZhbHVlID0gc291cmNlW3Byb3BlcnR5XSwgbGVuZ3RoO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xuICAgICAgaWYgKGdldENsYXNzLmNhbGwodmFsdWUpID09IFwiW29iamVjdCBBcnJheV1cIikge1xuICAgICAgICBmb3IgKGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG4gICAgICAgICAgdXBkYXRlKHZhbHVlLCBsZW5ndGgsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYGZvckVhY2hgIGNhbid0IGJlIHVzZWQgdG8gdHJhdmVyc2UgYW4gYXJyYXkgaW4gT3BlcmEgPD0gOC41NCxcbiAgICAgICAgLy8gYXMgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgcmV0dXJucyBgZmFsc2VgIGZvciBhcnJheSBpbmRpY2VzXG4gICAgICAgIC8vIChlLmcuLCBgIVsxLCAyLCAzXS5oYXNPd25Qcm9wZXJ0eShcIjBcIilgKS5cbiAgICAgICAgZm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgdXBkYXRlKHZhbHVlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc291cmNlLCBwcm9wZXJ0eSwgdmFsdWUpO1xuICB9O1xuXG4gIC8vIFB1YmxpYzogYEthbWluby5wYXJzZWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4yLlxuICBLYW1pbm8ucGFyc2UgPSBmdW5jdGlvbiAoc291cmNlLCBjYWxsYmFjaykge1xuICAgIHZhciByZXN1bHQsIHZhbHVlO1xuICAgIEluZGV4ID0gMDtcbiAgICBTb3VyY2UgPSBcIlwiICsgc291cmNlO1xuICAgIHN0YWNrID0gW107XG4gICAgaWYgKGNoYXJJbmRleEJ1Z2d5KSB7XG4gICAgICBTb3VyY2UgPSBzb3VyY2Uuc3BsaXQoXCJcIik7XG4gICAgfVxuICAgIHJlc3VsdCA9IGdldChsZXgoKSk7XG4gICAgLy8gSWYgYSBLYW1pbm8gc3RyaW5nIGNvbnRhaW5zIG11bHRpcGxlIHRva2VucywgaXQgaXMgaW52YWxpZC5cbiAgICBpZiAobGV4KCkgIT0gXCIkXCIpIHtcbiAgICAgIGFib3J0KCk7XG4gICAgfVxuICAgIC8vIFJlc2V0IHRoZSBwYXJzZXIgc3RhdGUuXG4gICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgIHJldHVybiBjYWxsYmFjayAmJiBnZXRDbGFzcy5jYWxsKGNhbGxiYWNrKSA9PSBcIltvYmplY3QgRnVuY3Rpb25dXCIgPyB3YWxrKCh2YWx1ZSA9IHt9LCB2YWx1ZVtcIlwiXSA9IHJlc3VsdCwgdmFsdWUpLCBcIlwiLCBjYWxsYmFjaykgOiByZXN1bHQ7XG4gIH07XG5cbiAgS2FtaW5vLmNsb25lID0gZnVuY3Rpb24oc291cmNlKSB7XG4gICAgcmV0dXJuIEthbWluby5wYXJzZSggS2FtaW5vLnN0cmluZ2lmeShzb3VyY2UpICk7XG4gIH07XG59KSh0aGlzKTtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qKlxuICogbWFya2VkIC0gYSBtYXJrZG93biBwYXJzZXJcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDEzLCBDaHJpc3RvcGhlciBKZWZmcmV5LiAoTUlUIExpY2Vuc2VkKVxuICogaHR0cHM6Ly9naXRodWIuY29tL2NoamovbWFya2VkXG4gKi9cblxuOyhmdW5jdGlvbigpIHtcblxuLyoqXG4gKiBCbG9jay1MZXZlbCBHcmFtbWFyXG4gKi9cblxudmFyIGJsb2NrID0ge1xuICBuZXdsaW5lOiAvXlxcbisvLFxuICBjb2RlOiAvXiggezR9W15cXG5dK1xcbiopKy8sXG4gIGZlbmNlczogbm9vcCxcbiAgaHI6IC9eKCAqWy0qX10pezMsfSAqKD86XFxuK3wkKS8sXG4gIGhlYWRpbmc6IC9eICooI3sxLDZ9KSAqKFteXFxuXSs/KSAqIyogKig/Olxcbit8JCkvLFxuICBucHRhYmxlOiBub29wLFxuICBsaGVhZGluZzogL14oW15cXG5dKylcXG4gKig9fC0pezIsfSAqKD86XFxuK3wkKS8sXG4gIGJsb2NrcXVvdGU6IC9eKCAqPlteXFxuXSsoXFxuW15cXG5dKykqXFxuKikrLyxcbiAgbGlzdDogL14oICopKGJ1bGwpIFtcXHNcXFNdKz8oPzpocnxcXG57Mix9KD8hICkoPyFcXDFidWxsIClcXG4qfFxccyokKS8sXG4gIGh0bWw6IC9eICooPzpjb21tZW50fGNsb3NlZHxjbG9zaW5nKSAqKD86XFxuezIsfXxcXHMqJCkvLFxuICBkZWY6IC9eICpcXFsoW15cXF1dKylcXF06ICo8PyhbXlxccz5dKyk+Pyg/OiArW1wiKF0oW15cXG5dKylbXCIpXSk/ICooPzpcXG4rfCQpLyxcbiAgdGFibGU6IG5vb3AsXG4gIHBhcmFncmFwaDogL14oKD86W15cXG5dK1xcbj8oPyFocnxoZWFkaW5nfGxoZWFkaW5nfGJsb2NrcXVvdGV8dGFnfGRlZikpKylcXG4qLyxcbiAgdGV4dDogL15bXlxcbl0rL1xufTtcblxuYmxvY2suYnVsbGV0ID0gLyg/OlsqKy1dfFxcZCtcXC4pLztcbmJsb2NrLml0ZW0gPSAvXiggKikoYnVsbCkgW15cXG5dKig/Olxcbig/IVxcMWJ1bGwgKVteXFxuXSopKi87XG5ibG9jay5pdGVtID0gcmVwbGFjZShibG9jay5pdGVtLCAnZ20nKVxuICAoL2J1bGwvZywgYmxvY2suYnVsbGV0KVxuICAoKTtcblxuYmxvY2subGlzdCA9IHJlcGxhY2UoYmxvY2subGlzdClcbiAgKC9idWxsL2csIGJsb2NrLmJ1bGxldClcbiAgKCdocicsIC9cXG4rKD89KD86ICpbLSpfXSl7Myx9ICooPzpcXG4rfCQpKS8pXG4gICgpO1xuXG5ibG9jay5fdGFnID0gJyg/ISg/OidcbiAgKyAnYXxlbXxzdHJvbmd8c21hbGx8c3xjaXRlfHF8ZGZufGFiYnJ8ZGF0YXx0aW1lfGNvZGUnXG4gICsgJ3x2YXJ8c2FtcHxrYmR8c3VifHN1cHxpfGJ8dXxtYXJrfHJ1Ynl8cnR8cnB8YmRpfGJkbydcbiAgKyAnfHNwYW58YnJ8d2JyfGluc3xkZWx8aW1nKVxcXFxiKVxcXFx3Kyg/ITovfEApXFxcXGInO1xuXG5ibG9jay5odG1sID0gcmVwbGFjZShibG9jay5odG1sKVxuICAoJ2NvbW1lbnQnLCAvPCEtLVtcXHNcXFNdKj8tLT4vKVxuICAoJ2Nsb3NlZCcsIC88KHRhZylbXFxzXFxTXSs/PFxcL1xcMT4vKVxuICAoJ2Nsb3NpbmcnLCAvPHRhZyg/OlwiW15cIl0qXCJ8J1teJ10qJ3xbXidcIj5dKSo/Pi8pXG4gICgvdGFnL2csIGJsb2NrLl90YWcpXG4gICgpO1xuXG5ibG9jay5wYXJhZ3JhcGggPSByZXBsYWNlKGJsb2NrLnBhcmFncmFwaClcbiAgKCdocicsIGJsb2NrLmhyKVxuICAoJ2hlYWRpbmcnLCBibG9jay5oZWFkaW5nKVxuICAoJ2xoZWFkaW5nJywgYmxvY2subGhlYWRpbmcpXG4gICgnYmxvY2txdW90ZScsIGJsb2NrLmJsb2NrcXVvdGUpXG4gICgndGFnJywgJzwnICsgYmxvY2suX3RhZylcbiAgKCdkZWYnLCBibG9jay5kZWYpXG4gICgpO1xuXG4vKipcbiAqIE5vcm1hbCBCbG9jayBHcmFtbWFyXG4gKi9cblxuYmxvY2subm9ybWFsID0gbWVyZ2Uoe30sIGJsb2NrKTtcblxuLyoqXG4gKiBHRk0gQmxvY2sgR3JhbW1hclxuICovXG5cbmJsb2NrLmdmbSA9IG1lcmdlKHt9LCBibG9jay5ub3JtYWwsIHtcbiAgZmVuY2VzOiAvXiAqKGB7Myx9fH57Myx9KSAqKFxcUyspPyAqXFxuKFtcXHNcXFNdKz8pXFxzKlxcMSAqKD86XFxuK3wkKS8sXG4gIHBhcmFncmFwaDogL14vXG59KTtcblxuYmxvY2suZ2ZtLnBhcmFncmFwaCA9IHJlcGxhY2UoYmxvY2sucGFyYWdyYXBoKVxuICAoJyg/IScsICcoPyEnXG4gICAgKyBibG9jay5nZm0uZmVuY2VzLnNvdXJjZS5yZXBsYWNlKCdcXFxcMScsICdcXFxcMicpICsgJ3wnXG4gICAgKyBibG9jay5saXN0LnNvdXJjZS5yZXBsYWNlKCdcXFxcMScsICdcXFxcMycpICsgJ3wnKVxuICAoKTtcblxuLyoqXG4gKiBHRk0gKyBUYWJsZXMgQmxvY2sgR3JhbW1hclxuICovXG5cbmJsb2NrLnRhYmxlcyA9IG1lcmdlKHt9LCBibG9jay5nZm0sIHtcbiAgbnB0YWJsZTogL14gKihcXFMuKlxcfC4qKVxcbiAqKFstOl0rICpcXHxbLXwgOl0qKVxcbigoPzouKlxcfC4qKD86XFxufCQpKSopXFxuKi8sXG4gIHRhYmxlOiAvXiAqXFx8KC4rKVxcbiAqXFx8KCAqWy06XStbLXwgOl0qKVxcbigoPzogKlxcfC4qKD86XFxufCQpKSopXFxuKi9cbn0pO1xuXG4vKipcbiAqIEJsb2NrIExleGVyXG4gKi9cblxuZnVuY3Rpb24gTGV4ZXIob3B0aW9ucykge1xuICB0aGlzLnRva2VucyA9IFtdO1xuICB0aGlzLnRva2Vucy5saW5rcyA9IHt9O1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IG1hcmtlZC5kZWZhdWx0cztcbiAgdGhpcy5ydWxlcyA9IGJsb2NrLm5vcm1hbDtcblxuICBpZiAodGhpcy5vcHRpb25zLmdmbSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudGFibGVzKSB7XG4gICAgICB0aGlzLnJ1bGVzID0gYmxvY2sudGFibGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJ1bGVzID0gYmxvY2suZ2ZtO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEV4cG9zZSBCbG9jayBSdWxlc1xuICovXG5cbkxleGVyLnJ1bGVzID0gYmxvY2s7XG5cbi8qKlxuICogU3RhdGljIExleCBNZXRob2RcbiAqL1xuXG5MZXhlci5sZXggPSBmdW5jdGlvbihzcmMsIG9wdGlvbnMpIHtcbiAgdmFyIGxleGVyID0gbmV3IExleGVyKG9wdGlvbnMpO1xuICByZXR1cm4gbGV4ZXIubGV4KHNyYyk7XG59O1xuXG4vKipcbiAqIFByZXByb2Nlc3NpbmdcbiAqL1xuXG5MZXhlci5wcm90b3R5cGUubGV4ID0gZnVuY3Rpb24oc3JjKSB7XG4gIHNyYyA9IHNyY1xuICAgIC5yZXBsYWNlKC9cXHJcXG58XFxyL2csICdcXG4nKVxuICAgIC5yZXBsYWNlKC9cXHQvZywgJyAgICAnKVxuICAgIC5yZXBsYWNlKC9cXHUwMGEwL2csICcgJylcbiAgICAucmVwbGFjZSgvXFx1MjQyNC9nLCAnXFxuJyk7XG5cbiAgcmV0dXJuIHRoaXMudG9rZW4oc3JjLCB0cnVlKTtcbn07XG5cbi8qKlxuICogTGV4aW5nXG4gKi9cblxuTGV4ZXIucHJvdG90eXBlLnRva2VuID0gZnVuY3Rpb24oc3JjLCB0b3ApIHtcbiAgdmFyIHNyYyA9IHNyYy5yZXBsYWNlKC9eICskL2dtLCAnJylcbiAgICAsIG5leHRcbiAgICAsIGxvb3NlXG4gICAgLCBjYXBcbiAgICAsIGJ1bGxcbiAgICAsIGJcbiAgICAsIGl0ZW1cbiAgICAsIHNwYWNlXG4gICAgLCBpXG4gICAgLCBsO1xuXG4gIHdoaWxlIChzcmMpIHtcbiAgICAvLyBuZXdsaW5lXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMubmV3bGluZS5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBpZiAoY2FwWzBdLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogJ3NwYWNlJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb2RlXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuY29kZS5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBjYXAgPSBjYXBbMF0ucmVwbGFjZSgvXiB7NH0vZ20sICcnKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnY29kZScsXG4gICAgICAgIHRleHQ6ICF0aGlzLm9wdGlvbnMucGVkYW50aWNcbiAgICAgICAgICA/IGNhcC5yZXBsYWNlKC9cXG4rJC8sICcnKVxuICAgICAgICAgIDogY2FwXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGZlbmNlcyAoZ2ZtKVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmZlbmNlcy5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICBsYW5nOiBjYXBbMl0sXG4gICAgICAgIHRleHQ6IGNhcFszXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBoZWFkaW5nXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuaGVhZGluZy5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2hlYWRpbmcnLFxuICAgICAgICBkZXB0aDogY2FwWzFdLmxlbmd0aCxcbiAgICAgICAgdGV4dDogY2FwWzJdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHRhYmxlIG5vIGxlYWRpbmcgcGlwZSAoZ2ZtKVxuICAgIGlmICh0b3AgJiYgKGNhcCA9IHRoaXMucnVsZXMubnB0YWJsZS5leGVjKHNyYykpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuXG4gICAgICBpdGVtID0ge1xuICAgICAgICB0eXBlOiAndGFibGUnLFxuICAgICAgICBoZWFkZXI6IGNhcFsxXS5yZXBsYWNlKC9eICp8ICpcXHwgKiQvZywgJycpLnNwbGl0KC8gKlxcfCAqLyksXG4gICAgICAgIGFsaWduOiBjYXBbMl0ucmVwbGFjZSgvXiAqfFxcfCAqJC9nLCAnJykuc3BsaXQoLyAqXFx8ICovKSxcbiAgICAgICAgY2VsbHM6IGNhcFszXS5yZXBsYWNlKC9cXG4kLywgJycpLnNwbGl0KCdcXG4nKVxuICAgICAgfTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGl0ZW0uYWxpZ24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKC9eICotKzogKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIGlmICgvXiAqOi0rOiAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnY2VudGVyJztcbiAgICAgICAgfSBlbHNlIGlmICgvXiAqOi0rICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdsZWZ0JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbS5jZWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtLmNlbGxzW2ldID0gaXRlbS5jZWxsc1tpXS5zcGxpdCgvICpcXHwgKi8pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRva2Vucy5wdXNoKGl0ZW0pO1xuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBsaGVhZGluZ1xuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmxoZWFkaW5nLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnaGVhZGluZycsXG4gICAgICAgIGRlcHRoOiBjYXBbMl0gPT09ICc9JyA/IDEgOiAyLFxuICAgICAgICB0ZXh0OiBjYXBbMV1cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gaHJcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5oci5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2hyJ1xuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBibG9ja3F1b3RlXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuYmxvY2txdW90ZS5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG5cbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnYmxvY2txdW90ZV9zdGFydCdcbiAgICAgIH0pO1xuXG4gICAgICBjYXAgPSBjYXBbMF0ucmVwbGFjZSgvXiAqPiA/L2dtLCAnJyk7XG5cbiAgICAgIC8vIFBhc3MgYHRvcGAgdG8ga2VlcCB0aGUgY3VycmVudFxuICAgICAgLy8gXCJ0b3BsZXZlbFwiIHN0YXRlLiBUaGlzIGlzIGV4YWN0bHlcbiAgICAgIC8vIGhvdyBtYXJrZG93bi5wbCB3b3Jrcy5cbiAgICAgIHRoaXMudG9rZW4oY2FwLCB0b3ApO1xuXG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2Jsb2NrcXVvdGVfZW5kJ1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGxpc3RcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5saXN0LmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIGJ1bGwgPSBjYXBbMl07XG5cbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnbGlzdF9zdGFydCcsXG4gICAgICAgIG9yZGVyZWQ6IGJ1bGwubGVuZ3RoID4gMVxuICAgICAgfSk7XG5cbiAgICAgIC8vIEdldCBlYWNoIHRvcC1sZXZlbCBpdGVtLlxuICAgICAgY2FwID0gY2FwWzBdLm1hdGNoKHRoaXMucnVsZXMuaXRlbSk7XG5cbiAgICAgIG5leHQgPSBmYWxzZTtcbiAgICAgIGwgPSBjYXAubGVuZ3RoO1xuICAgICAgaSA9IDA7XG5cbiAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBjYXBbaV07XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBsaXN0IGl0ZW0ncyBidWxsZXRcbiAgICAgICAgLy8gc28gaXQgaXMgc2VlbiBhcyB0aGUgbmV4dCB0b2tlbi5cbiAgICAgICAgc3BhY2UgPSBpdGVtLmxlbmd0aDtcbiAgICAgICAgaXRlbSA9IGl0ZW0ucmVwbGFjZSgvXiAqKFsqKy1dfFxcZCtcXC4pICsvLCAnJyk7XG5cbiAgICAgICAgLy8gT3V0ZGVudCB3aGF0ZXZlciB0aGVcbiAgICAgICAgLy8gbGlzdCBpdGVtIGNvbnRhaW5zLiBIYWNreS5cbiAgICAgICAgaWYgKH5pdGVtLmluZGV4T2YoJ1xcbiAnKSkge1xuICAgICAgICAgIHNwYWNlIC09IGl0ZW0ubGVuZ3RoO1xuICAgICAgICAgIGl0ZW0gPSAhdGhpcy5vcHRpb25zLnBlZGFudGljXG4gICAgICAgICAgICA/IGl0ZW0ucmVwbGFjZShuZXcgUmVnRXhwKCdeIHsxLCcgKyBzcGFjZSArICd9JywgJ2dtJyksICcnKVxuICAgICAgICAgICAgOiBpdGVtLnJlcGxhY2UoL14gezEsNH0vZ20sICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVybWluZSB3aGV0aGVyIHRoZSBuZXh0IGxpc3QgaXRlbSBiZWxvbmdzIGhlcmUuXG4gICAgICAgIC8vIEJhY2twZWRhbCBpZiBpdCBkb2VzIG5vdCBiZWxvbmcgaW4gdGhpcyBsaXN0LlxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNtYXJ0TGlzdHMgJiYgaSAhPT0gbCAtIDEpIHtcbiAgICAgICAgICBiID0gYmxvY2suYnVsbGV0LmV4ZWMoY2FwW2kgKyAxXSlbMF07XG4gICAgICAgICAgaWYgKGJ1bGwgIT09IGIgJiYgIShidWxsLmxlbmd0aCA+IDEgJiYgYi5sZW5ndGggPiAxKSkge1xuICAgICAgICAgICAgc3JjID0gY2FwLnNsaWNlKGkgKyAxKS5qb2luKCdcXG4nKSArIHNyYztcbiAgICAgICAgICAgIGkgPSBsIC0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgd2hldGhlciBpdGVtIGlzIGxvb3NlIG9yIG5vdC5cbiAgICAgICAgLy8gVXNlOiAvKF58XFxuKSg/ISApW15cXG5dK1xcblxcbig/IVxccyokKS9cbiAgICAgICAgLy8gZm9yIGRpc2NvdW50IGJlaGF2aW9yLlxuICAgICAgICBsb29zZSA9IG5leHQgfHwgL1xcblxcbig/IVxccyokKS8udGVzdChpdGVtKTtcbiAgICAgICAgaWYgKGkgIT09IGwgLSAxKSB7XG4gICAgICAgICAgbmV4dCA9IGl0ZW0uY2hhckF0KGl0ZW0ubGVuZ3RoIC0gMSkgPT09ICdcXG4nO1xuICAgICAgICAgIGlmICghbG9vc2UpIGxvb3NlID0gbmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICAgIHR5cGU6IGxvb3NlXG4gICAgICAgICAgICA/ICdsb29zZV9pdGVtX3N0YXJ0J1xuICAgICAgICAgICAgOiAnbGlzdF9pdGVtX3N0YXJ0J1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBSZWN1cnNlLlxuICAgICAgICB0aGlzLnRva2VuKGl0ZW0sIGZhbHNlKTtcblxuICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAnbGlzdF9pdGVtX2VuZCdcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnbGlzdF9lbmQnXG4gICAgICB9KTtcblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gaHRtbFxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmh0bWwuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6IHRoaXMub3B0aW9ucy5zYW5pdGl6ZVxuICAgICAgICAgID8gJ3BhcmFncmFwaCdcbiAgICAgICAgICA6ICdodG1sJyxcbiAgICAgICAgcHJlOiBjYXBbMV0gPT09ICdwcmUnIHx8IGNhcFsxXSA9PT0gJ3NjcmlwdCcgfHwgY2FwWzFdID09PSAnc3R5bGUnLFxuICAgICAgICB0ZXh0OiBjYXBbMF1cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZGVmXG4gICAgaWYgKHRvcCAmJiAoY2FwID0gdGhpcy5ydWxlcy5kZWYuZXhlYyhzcmMpKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLmxpbmtzW2NhcFsxXS50b0xvd2VyQ2FzZSgpXSA9IHtcbiAgICAgICAgaHJlZjogY2FwWzJdLFxuICAgICAgICB0aXRsZTogY2FwWzNdXG4gICAgICB9O1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdGFibGUgKGdmbSlcbiAgICBpZiAodG9wICYmIChjYXAgPSB0aGlzLnJ1bGVzLnRhYmxlLmV4ZWMoc3JjKSkpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG5cbiAgICAgIGl0ZW0gPSB7XG4gICAgICAgIHR5cGU6ICd0YWJsZScsXG4gICAgICAgIGhlYWRlcjogY2FwWzFdLnJlcGxhY2UoL14gKnwgKlxcfCAqJC9nLCAnJykuc3BsaXQoLyAqXFx8ICovKSxcbiAgICAgICAgYWxpZ246IGNhcFsyXS5yZXBsYWNlKC9eICp8XFx8ICokL2csICcnKS5zcGxpdCgvICpcXHwgKi8pLFxuICAgICAgICBjZWxsczogY2FwWzNdLnJlcGxhY2UoLyg/OiAqXFx8ICopP1xcbiQvLCAnJykuc3BsaXQoJ1xcbicpXG4gICAgICB9O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbS5hbGlnbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoL14gKi0rOiAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAncmlnaHQnO1xuICAgICAgICB9IGVsc2UgaWYgKC9eICo6LSs6ICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdjZW50ZXInO1xuICAgICAgICB9IGVsc2UgaWYgKC9eICo6LSsgKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ2xlZnQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtLmNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZW0uY2VsbHNbaV0gPSBpdGVtLmNlbGxzW2ldXG4gICAgICAgICAgLnJlcGxhY2UoL14gKlxcfCAqfCAqXFx8ICokL2csICcnKVxuICAgICAgICAgIC5zcGxpdCgvICpcXHwgKi8pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRva2Vucy5wdXNoKGl0ZW0pO1xuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB0b3AtbGV2ZWwgcGFyYWdyYXBoXG4gICAgaWYgKHRvcCAmJiAoY2FwID0gdGhpcy5ydWxlcy5wYXJhZ3JhcGguZXhlYyhzcmMpKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAncGFyYWdyYXBoJyxcbiAgICAgICAgdGV4dDogY2FwWzFdLmNoYXJBdChjYXBbMV0ubGVuZ3RoIC0gMSkgPT09ICdcXG4nXG4gICAgICAgICAgPyBjYXBbMV0uc2xpY2UoMCwgLTEpXG4gICAgICAgICAgOiBjYXBbMV1cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdGV4dFxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLnRleHQuZXhlYyhzcmMpKSB7XG4gICAgICAvLyBUb3AtbGV2ZWwgc2hvdWxkIG5ldmVyIHJlYWNoIGhlcmUuXG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgdGV4dDogY2FwWzBdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChzcmMpIHtcbiAgICAgIHRocm93IG5ld1xuICAgICAgICBFcnJvcignSW5maW5pdGUgbG9vcCBvbiBieXRlOiAnICsgc3JjLmNoYXJDb2RlQXQoMCkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzLnRva2Vucztcbn07XG5cbi8qKlxuICogSW5saW5lLUxldmVsIEdyYW1tYXJcbiAqL1xuXG52YXIgaW5saW5lID0ge1xuICBlc2NhcGU6IC9eXFxcXChbXFxcXGAqe31cXFtcXF0oKSMrXFwtLiFfPl0pLyxcbiAgYXV0b2xpbms6IC9ePChbXiA+XSsoQHw6XFwvKVteID5dKyk+LyxcbiAgdXJsOiBub29wLFxuICB0YWc6IC9ePCEtLVtcXHNcXFNdKj8tLT58XjxcXC8/XFx3Kyg/OlwiW15cIl0qXCJ8J1teJ10qJ3xbXidcIj5dKSo/Pi8sXG4gIGxpbms6IC9eIT9cXFsoaW5zaWRlKVxcXVxcKGhyZWZcXCkvLFxuICByZWZsaW5rOiAvXiE/XFxbKGluc2lkZSlcXF1cXHMqXFxbKFteXFxdXSopXFxdLyxcbiAgbm9saW5rOiAvXiE/XFxbKCg/OlxcW1teXFxdXSpcXF18W15cXFtcXF1dKSopXFxdLyxcbiAgc3Ryb25nOiAvXl9fKFtcXHNcXFNdKz8pX18oPyFfKXxeXFwqXFwqKFtcXHNcXFNdKz8pXFwqXFwqKD8hXFwqKS8sXG4gIGVtOiAvXlxcYl8oKD86X198W1xcc1xcU10pKz8pX1xcYnxeXFwqKCg/OlxcKlxcKnxbXFxzXFxTXSkrPylcXCooPyFcXCopLyxcbiAgY29kZTogL14oYCspXFxzKihbXFxzXFxTXSo/W15gXSlcXHMqXFwxKD8hYCkvLFxuICBicjogL14gezIsfVxcbig/IVxccyokKS8sXG4gIGRlbDogbm9vcCxcbiAgdGV4dDogL15bXFxzXFxTXSs/KD89W1xcXFw8IVxcW18qYF18IHsyLH1cXG58JCkvXG59O1xuXG5pbmxpbmUuX2luc2lkZSA9IC8oPzpcXFtbXlxcXV0qXFxdfFteXFxbXFxdXXxcXF0oPz1bXlxcW10qXFxdKSkqLztcbmlubGluZS5faHJlZiA9IC9cXHMqPD8oW1xcc1xcU10qPyk+Pyg/OlxccytbJ1wiXShbXFxzXFxTXSo/KVsnXCJdKT9cXHMqLztcblxuaW5saW5lLmxpbmsgPSByZXBsYWNlKGlubGluZS5saW5rKVxuICAoJ2luc2lkZScsIGlubGluZS5faW5zaWRlKVxuICAoJ2hyZWYnLCBpbmxpbmUuX2hyZWYpXG4gICgpO1xuXG5pbmxpbmUucmVmbGluayA9IHJlcGxhY2UoaW5saW5lLnJlZmxpbmspXG4gICgnaW5zaWRlJywgaW5saW5lLl9pbnNpZGUpXG4gICgpO1xuXG4vKipcbiAqIE5vcm1hbCBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5ub3JtYWwgPSBtZXJnZSh7fSwgaW5saW5lKTtcblxuLyoqXG4gKiBQZWRhbnRpYyBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5wZWRhbnRpYyA9IG1lcmdlKHt9LCBpbmxpbmUubm9ybWFsLCB7XG4gIHN0cm9uZzogL15fXyg/PVxcUykoW1xcc1xcU10qP1xcUylfXyg/IV8pfF5cXCpcXCooPz1cXFMpKFtcXHNcXFNdKj9cXFMpXFwqXFwqKD8hXFwqKS8sXG4gIGVtOiAvXl8oPz1cXFMpKFtcXHNcXFNdKj9cXFMpXyg/IV8pfF5cXCooPz1cXFMpKFtcXHNcXFNdKj9cXFMpXFwqKD8hXFwqKS9cbn0pO1xuXG4vKipcbiAqIEdGTSBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5nZm0gPSBtZXJnZSh7fSwgaW5saW5lLm5vcm1hbCwge1xuICBlc2NhcGU6IHJlcGxhY2UoaW5saW5lLmVzY2FwZSkoJ10pJywgJ358XSknKSgpLFxuICB1cmw6IC9eKGh0dHBzPzpcXC9cXC9bXlxcczxdK1tePC4sOjtcIicpXFxdXFxzXSkvLFxuICBkZWw6IC9efn4oPz1cXFMpKFtcXHNcXFNdKj9cXFMpfn4vLFxuICB0ZXh0OiByZXBsYWNlKGlubGluZS50ZXh0KVxuICAgICgnXXwnLCAnfl18JylcbiAgICAoJ3wnLCAnfGh0dHBzPzovL3wnKVxuICAgICgpXG59KTtcblxuLyoqXG4gKiBHRk0gKyBMaW5lIEJyZWFrcyBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5icmVha3MgPSBtZXJnZSh7fSwgaW5saW5lLmdmbSwge1xuICBicjogcmVwbGFjZShpbmxpbmUuYnIpKCd7Mix9JywgJyonKSgpLFxuICB0ZXh0OiByZXBsYWNlKGlubGluZS5nZm0udGV4dCkoJ3syLH0nLCAnKicpKClcbn0pO1xuXG4vKipcbiAqIElubGluZSBMZXhlciAmIENvbXBpbGVyXG4gKi9cblxuZnVuY3Rpb24gSW5saW5lTGV4ZXIobGlua3MsIG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBtYXJrZWQuZGVmYXVsdHM7XG4gIHRoaXMubGlua3MgPSBsaW5rcztcbiAgdGhpcy5ydWxlcyA9IGlubGluZS5ub3JtYWw7XG4gIHRoaXMucmVuZGVyZXIgPSB0aGlzLm9wdGlvbnMucmVuZGVyZXIgfHwgbmV3IFJlbmRlcmVyO1xuXG4gIGlmICghdGhpcy5saW5rcykge1xuICAgIHRocm93IG5ld1xuICAgICAgRXJyb3IoJ1Rva2VucyBhcnJheSByZXF1aXJlcyBhIGBsaW5rc2AgcHJvcGVydHkuJyk7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLmdmbSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYnJlYWtzKSB7XG4gICAgICB0aGlzLnJ1bGVzID0gaW5saW5lLmJyZWFrcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ydWxlcyA9IGlubGluZS5nZm07XG4gICAgfVxuICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgIHRoaXMucnVsZXMgPSBpbmxpbmUucGVkYW50aWM7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHBvc2UgSW5saW5lIFJ1bGVzXG4gKi9cblxuSW5saW5lTGV4ZXIucnVsZXMgPSBpbmxpbmU7XG5cbi8qKlxuICogU3RhdGljIExleGluZy9Db21waWxpbmcgTWV0aG9kXG4gKi9cblxuSW5saW5lTGV4ZXIub3V0cHV0ID0gZnVuY3Rpb24oc3JjLCBsaW5rcywgb3B0aW9ucykge1xuICB2YXIgaW5saW5lID0gbmV3IElubGluZUxleGVyKGxpbmtzLCBvcHRpb25zKTtcbiAgcmV0dXJuIGlubGluZS5vdXRwdXQoc3JjKTtcbn07XG5cbi8qKlxuICogTGV4aW5nL0NvbXBpbGluZ1xuICovXG5cbklubGluZUxleGVyLnByb3RvdHlwZS5vdXRwdXQgPSBmdW5jdGlvbihzcmMpIHtcbiAgdmFyIG91dCA9ICcnXG4gICAgLCBsaW5rXG4gICAgLCB0ZXh0XG4gICAgLCBocmVmXG4gICAgLCBjYXA7XG5cbiAgd2hpbGUgKHNyYykge1xuICAgIC8vIGVzY2FwZVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmVzY2FwZS5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gY2FwWzFdO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gYXV0b2xpbmtcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5hdXRvbGluay5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBpZiAoY2FwWzJdID09PSAnQCcpIHtcbiAgICAgICAgdGV4dCA9IGNhcFsxXS5jaGFyQXQoNikgPT09ICc6J1xuICAgICAgICAgID8gdGhpcy5tYW5nbGUoY2FwWzFdLnN1YnN0cmluZyg3KSlcbiAgICAgICAgICA6IHRoaXMubWFuZ2xlKGNhcFsxXSk7XG4gICAgICAgIGhyZWYgPSB0aGlzLm1hbmdsZSgnbWFpbHRvOicpICsgdGV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQgPSBlc2NhcGUoY2FwWzFdKTtcbiAgICAgICAgaHJlZiA9IHRleHQ7XG4gICAgICB9XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5saW5rKGhyZWYsIG51bGwsIHRleHQpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdXJsIChnZm0pXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMudXJsLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRleHQgPSBlc2NhcGUoY2FwWzFdKTtcbiAgICAgIGhyZWYgPSB0ZXh0O1xuICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIubGluayhocmVmLCBudWxsLCB0ZXh0KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHRhZ1xuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLnRhZy5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5vcHRpb25zLnNhbml0aXplXG4gICAgICAgID8gZXNjYXBlKGNhcFswXSlcbiAgICAgICAgOiBjYXBbMF07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBsaW5rXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMubGluay5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5vdXRwdXRMaW5rKGNhcCwge1xuICAgICAgICBocmVmOiBjYXBbMl0sXG4gICAgICAgIHRpdGxlOiBjYXBbM11cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gcmVmbGluaywgbm9saW5rXG4gICAgaWYgKChjYXAgPSB0aGlzLnJ1bGVzLnJlZmxpbmsuZXhlYyhzcmMpKVxuICAgICAgICB8fCAoY2FwID0gdGhpcy5ydWxlcy5ub2xpbmsuZXhlYyhzcmMpKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIGxpbmsgPSAoY2FwWzJdIHx8IGNhcFsxXSkucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuICAgICAgbGluayA9IHRoaXMubGlua3NbbGluay50b0xvd2VyQ2FzZSgpXTtcbiAgICAgIGlmICghbGluayB8fCAhbGluay5ocmVmKSB7XG4gICAgICAgIG91dCArPSBjYXBbMF0uY2hhckF0KDApO1xuICAgICAgICBzcmMgPSBjYXBbMF0uc3Vic3RyaW5nKDEpICsgc3JjO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIG91dCArPSB0aGlzLm91dHB1dExpbmsoY2FwLCBsaW5rKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHN0cm9uZ1xuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLnN0cm9uZy5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5zdHJvbmcodGhpcy5vdXRwdXQoY2FwWzJdIHx8IGNhcFsxXSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZW1cbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5lbS5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5lbSh0aGlzLm91dHB1dChjYXBbMl0gfHwgY2FwWzFdKSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBjb2RlXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuY29kZS5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5jb2Rlc3Bhbihlc2NhcGUoY2FwWzJdLCB0cnVlKSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBiclxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmJyLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmJyKCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBkZWwgKGdmbSlcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5kZWwuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuZGVsKHRoaXMub3V0cHV0KGNhcFsxXSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdGV4dFxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLnRleHQuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IGVzY2FwZSh0aGlzLnNtYXJ0eXBhbnRzKGNhcFswXSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHNyYykge1xuICAgICAgdGhyb3cgbmV3XG4gICAgICAgIEVycm9yKCdJbmZpbml0ZSBsb29wIG9uIGJ5dGU6ICcgKyBzcmMuY2hhckNvZGVBdCgwKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29tcGlsZSBMaW5rXG4gKi9cblxuSW5saW5lTGV4ZXIucHJvdG90eXBlLm91dHB1dExpbmsgPSBmdW5jdGlvbihjYXAsIGxpbmspIHtcbiAgdmFyIGhyZWYgPSBlc2NhcGUobGluay5ocmVmKVxuICAgICwgdGl0bGUgPSBsaW5rLnRpdGxlID8gZXNjYXBlKGxpbmsudGl0bGUpIDogbnVsbDtcblxuICByZXR1cm4gY2FwWzBdLmNoYXJBdCgwKSAhPT0gJyEnXG4gICAgPyB0aGlzLnJlbmRlcmVyLmxpbmsoaHJlZiwgdGl0bGUsIHRoaXMub3V0cHV0KGNhcFsxXSkpXG4gICAgOiB0aGlzLnJlbmRlcmVyLmltYWdlKGhyZWYsIHRpdGxlLCBlc2NhcGUoY2FwWzFdKSk7XG59O1xuXG4vKipcbiAqIFNtYXJ0eXBhbnRzIFRyYW5zZm9ybWF0aW9uc1xuICovXG5cbklubGluZUxleGVyLnByb3RvdHlwZS5zbWFydHlwYW50cyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgaWYgKCF0aGlzLm9wdGlvbnMuc21hcnR5cGFudHMpIHJldHVybiB0ZXh0O1xuICByZXR1cm4gdGV4dFxuICAgIC8vIGVtLWRhc2hlc1xuICAgIC5yZXBsYWNlKC8tLS9nLCAnXFx1MjAxNCcpXG4gICAgLy8gb3BlbmluZyBzaW5nbGVzXG4gICAgLnJlcGxhY2UoLyhefFstXFx1MjAxNC8oXFxbe1wiXFxzXSknL2csICckMVxcdTIwMTgnKVxuICAgIC8vIGNsb3Npbmcgc2luZ2xlcyAmIGFwb3N0cm9waGVzXG4gICAgLnJlcGxhY2UoLycvZywgJ1xcdTIwMTknKVxuICAgIC8vIG9wZW5pbmcgZG91Ymxlc1xuICAgIC5yZXBsYWNlKC8oXnxbLVxcdTIwMTQvKFxcW3tcXHUyMDE4XFxzXSlcIi9nLCAnJDFcXHUyMDFjJylcbiAgICAvLyBjbG9zaW5nIGRvdWJsZXNcbiAgICAucmVwbGFjZSgvXCIvZywgJ1xcdTIwMWQnKVxuICAgIC8vIGVsbGlwc2VzXG4gICAgLnJlcGxhY2UoL1xcLnszfS9nLCAnXFx1MjAyNicpO1xufTtcblxuLyoqXG4gKiBNYW5nbGUgTGlua3NcbiAqL1xuXG5JbmxpbmVMZXhlci5wcm90b3R5cGUubWFuZ2xlID0gZnVuY3Rpb24odGV4dCkge1xuICB2YXIgb3V0ID0gJydcbiAgICAsIGwgPSB0ZXh0Lmxlbmd0aFxuICAgICwgaSA9IDBcbiAgICAsIGNoO1xuXG4gIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgY2ggPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKE1hdGgucmFuZG9tKCkgPiAwLjUpIHtcbiAgICAgIGNoID0gJ3gnICsgY2gudG9TdHJpbmcoMTYpO1xuICAgIH1cbiAgICBvdXQgKz0gJyYjJyArIGNoICsgJzsnO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmVuZGVyZXJcbiAqL1xuXG5mdW5jdGlvbiBSZW5kZXJlcigpIHt9XG5cblJlbmRlcmVyLnByb3RvdHlwZS5jb2RlID0gZnVuY3Rpb24oY29kZSwgbGFuZywgZXNjYXBlZCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAob3B0aW9ucy5oaWdobGlnaHQpIHtcbiAgICB2YXIgb3V0ID0gb3B0aW9ucy5oaWdobGlnaHQoY29kZSwgbGFuZyk7XG4gICAgaWYgKG91dCAhPSBudWxsICYmIG91dCAhPT0gY29kZSkge1xuICAgICAgZXNjYXBlZCA9IHRydWU7XG4gICAgICBjb2RlID0gb3V0O1xuICAgIH1cbiAgfVxuXG4gIGlmICghbGFuZykge1xuICAgIHJldHVybiAnPHByZT48Y29kZT4nXG4gICAgICArIChlc2NhcGVkID8gY29kZSA6IGVzY2FwZShjb2RlLCB0cnVlKSlcbiAgICAgICsgJ1xcbjwvY29kZT48L3ByZT4nO1xuICB9XG5cbiAgcmV0dXJuICc8cHJlPjxjb2RlIGNsYXNzPVwiJ1xuICAgICsgb3B0aW9ucy5sYW5nUHJlZml4XG4gICAgKyBsYW5nXG4gICAgKyAnXCI+J1xuICAgICsgKGVzY2FwZWQgPyBjb2RlIDogZXNjYXBlKGNvZGUpKVxuICAgICsgJ1xcbjwvY29kZT48L3ByZT5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmJsb2NrcXVvdGUgPSBmdW5jdGlvbihxdW90ZSkge1xuICByZXR1cm4gJzxibG9ja3F1b3RlPlxcbicgKyBxdW90ZSArICc8L2Jsb2NrcXVvdGU+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5odG1sID0gZnVuY3Rpb24oaHRtbCkge1xuICByZXR1cm4gaHRtbDtcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5oZWFkaW5nID0gZnVuY3Rpb24odGV4dCwgbGV2ZWwsIHJhdywgb3B0aW9ucykge1xuICByZXR1cm4gJzxoJ1xuICAgICsgbGV2ZWxcbiAgICArICcgaWQ9XCInXG4gICAgKyBvcHRpb25zLmhlYWRlclByZWZpeFxuICAgICsgcmF3LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvW15cXHddKy9nLCAnLScpXG4gICAgKyAnXCI+J1xuICAgICsgdGV4dFxuICAgICsgJzwvaCdcbiAgICArIGxldmVsXG4gICAgKyAnPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuaHIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICc8aHI+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5saXN0ID0gZnVuY3Rpb24oYm9keSwgb3JkZXJlZCkge1xuICB2YXIgdHlwZSA9IG9yZGVyZWQgPyAnb2wnIDogJ3VsJztcbiAgcmV0dXJuICc8JyArIHR5cGUgKyAnPlxcbicgKyBib2R5ICsgJzwvJyArIHR5cGUgKyAnPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUubGlzdGl0ZW0gPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHJldHVybiAnPGxpPicgKyB0ZXh0ICsgJzwvbGk+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5wYXJhZ3JhcGggPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHJldHVybiAnPHA+JyArIHRleHQgKyAnPC9wPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUudGFibGUgPSBmdW5jdGlvbihoZWFkZXIsIGJvZHkpIHtcbiAgcmV0dXJuICc8dGFibGU+XFxuJ1xuICAgICsgJzx0aGVhZD5cXG4nXG4gICAgKyBoZWFkZXJcbiAgICArICc8L3RoZWFkPlxcbidcbiAgICArICc8dGJvZHk+XFxuJ1xuICAgICsgYm9keVxuICAgICsgJzwvdGJvZHk+XFxuJ1xuICAgICsgJzwvdGFibGU+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS50YWJsZXJvdyA9IGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgcmV0dXJuICc8dHI+XFxuJyArIGNvbnRlbnQgKyAnPC90cj5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLnRhYmxlY2VsbCA9IGZ1bmN0aW9uKGNvbnRlbnQsIGZsYWdzKSB7XG4gIHZhciB0eXBlID0gZmxhZ3MuaGVhZGVyID8gJ3RoJyA6ICd0ZCc7XG4gIHZhciB0YWcgPSBmbGFncy5hbGlnblxuICAgID8gJzwnICsgdHlwZSArICcgc3R5bGU9XCJ0ZXh0LWFsaWduOicgKyBmbGFncy5hbGlnbiArICdcIj4nXG4gICAgOiAnPCcgKyB0eXBlICsgJz4nO1xuICByZXR1cm4gdGFnICsgY29udGVudCArICc8LycgKyB0eXBlICsgJz5cXG4nO1xufTtcblxuLy8gc3BhbiBsZXZlbCByZW5kZXJlclxuUmVuZGVyZXIucHJvdG90eXBlLnN0cm9uZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuICc8c3Ryb25nPicgKyB0ZXh0ICsgJzwvc3Ryb25nPic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuZW0gPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHJldHVybiAnPGVtPicgKyB0ZXh0ICsgJzwvZW0+Jztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5jb2Rlc3BhbiA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuICc8Y29kZT4nICsgdGV4dCArICc8L2NvZGU+Jztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5iciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJzxicj4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuICc8ZGVsPicgKyB0ZXh0ICsgJzwvZGVsPic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUubGluayA9IGZ1bmN0aW9uKGhyZWYsIHRpdGxlLCB0ZXh0KSB7XG4gIHZhciBvdXQgPSAnPGEgaHJlZj1cIicgKyBocmVmICsgJ1wiJztcbiAgaWYgKHRpdGxlKSB7XG4gICAgb3V0ICs9ICcgdGl0bGU9XCInICsgdGl0bGUgKyAnXCInO1xuICB9XG4gIG91dCArPSAnPicgKyB0ZXh0ICsgJzwvYT4nO1xuICByZXR1cm4gb3V0O1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmltYWdlID0gZnVuY3Rpb24oaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgdmFyIG91dCA9ICc8aW1nIHNyYz1cIicgKyBocmVmICsgJ1wiIGFsdD1cIicgKyB0ZXh0ICsgJ1wiJztcbiAgaWYgKHRpdGxlKSB7XG4gICAgb3V0ICs9ICcgdGl0bGU9XCInICsgdGl0bGUgKyAnXCInO1xuICB9XG4gIG91dCArPSAnPic7XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBhcnNpbmcgJiBDb21waWxpbmdcbiAqL1xuXG5mdW5jdGlvbiBQYXJzZXIob3B0aW9ucykge1xuICB0aGlzLnRva2VucyA9IFtdO1xuICB0aGlzLnRva2VuID0gbnVsbDtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBtYXJrZWQuZGVmYXVsdHM7XG4gIHRoaXMub3B0aW9ucy5yZW5kZXJlciA9IHRoaXMub3B0aW9ucy5yZW5kZXJlciB8fCBuZXcgUmVuZGVyZXI7XG4gIHRoaXMucmVuZGVyZXIgPSB0aGlzLm9wdGlvbnMucmVuZGVyZXI7XG59XG5cbi8qKlxuICogU3RhdGljIFBhcnNlIE1ldGhvZFxuICovXG5cblBhcnNlci5wYXJzZSA9IGZ1bmN0aW9uKHNyYywgb3B0aW9ucywgcmVuZGVyZXIpIHtcbiAgdmFyIHBhcnNlciA9IG5ldyBQYXJzZXIob3B0aW9ucywgcmVuZGVyZXIpO1xuICByZXR1cm4gcGFyc2VyLnBhcnNlKHNyYyk7XG59O1xuXG4vKipcbiAqIFBhcnNlIExvb3BcbiAqL1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oc3JjKSB7XG4gIHRoaXMuaW5saW5lID0gbmV3IElubGluZUxleGVyKHNyYy5saW5rcywgdGhpcy5vcHRpb25zLCB0aGlzLnJlbmRlcmVyKTtcbiAgdGhpcy50b2tlbnMgPSBzcmMucmV2ZXJzZSgpO1xuXG4gIHZhciBvdXQgPSAnJztcbiAgd2hpbGUgKHRoaXMubmV4dCgpKSB7XG4gICAgb3V0ICs9IHRoaXMudG9rKCk7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBOZXh0IFRva2VuXG4gKi9cblxuUGFyc2VyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnRva2VuID0gdGhpcy50b2tlbnMucG9wKCk7XG59O1xuXG4vKipcbiAqIFByZXZpZXcgTmV4dCBUb2tlblxuICovXG5cblBhcnNlci5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50b2tlbnNbdGhpcy50b2tlbnMubGVuZ3RoIC0gMV0gfHwgMDtcbn07XG5cbi8qKlxuICogUGFyc2UgVGV4dCBUb2tlbnNcbiAqL1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlVGV4dCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYm9keSA9IHRoaXMudG9rZW4udGV4dDtcblxuICB3aGlsZSAodGhpcy5wZWVrKCkudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgYm9keSArPSAnXFxuJyArIHRoaXMubmV4dCgpLnRleHQ7XG4gIH1cblxuICByZXR1cm4gdGhpcy5pbmxpbmUub3V0cHV0KGJvZHkpO1xufTtcblxuLyoqXG4gKiBQYXJzZSBDdXJyZW50IFRva2VuXG4gKi9cblxuUGFyc2VyLnByb3RvdHlwZS50b2sgPSBmdW5jdGlvbigpIHtcbiAgc3dpdGNoICh0aGlzLnRva2VuLnR5cGUpIHtcbiAgICBjYXNlICdzcGFjZSc6IHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgY2FzZSAnaHInOiB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5ocigpO1xuICAgIH1cbiAgICBjYXNlICdoZWFkaW5nJzoge1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuaGVhZGluZyhcbiAgICAgICAgdGhpcy5pbmxpbmUub3V0cHV0KHRoaXMudG9rZW4udGV4dCksXG4gICAgICAgIHRoaXMudG9rZW4uZGVwdGgsXG4gICAgICAgIHRoaXMudG9rZW4udGV4dCxcbiAgICAgICAgdGhpcy5vcHRpb25zXG4gICAgICApO1xuICAgIH1cbiAgICBjYXNlICdjb2RlJzoge1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuY29kZSh0aGlzLnRva2VuLnRleHQsXG4gICAgICAgIHRoaXMudG9rZW4ubGFuZyxcbiAgICAgICAgdGhpcy50b2tlbi5lc2NhcGVkLFxuICAgICAgICB0aGlzLm9wdGlvbnMpO1xuICAgIH1cbiAgICBjYXNlICd0YWJsZSc6IHtcbiAgICAgIHZhciBoZWFkZXIgPSAnJ1xuICAgICAgICAsIGJvZHkgPSAnJ1xuICAgICAgICAsIGlcbiAgICAgICAgLCByb3dcbiAgICAgICAgLCBjZWxsXG4gICAgICAgICwgZmxhZ3NcbiAgICAgICAgLCBqO1xuXG4gICAgICAvLyBoZWFkZXJcbiAgICAgIGNlbGwgPSAnJztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnRva2VuLmhlYWRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBmbGFncyA9IHsgaGVhZGVyOiB0cnVlLCBhbGlnbjogdGhpcy50b2tlbi5hbGlnbltpXSB9O1xuICAgICAgICBjZWxsICs9IHRoaXMucmVuZGVyZXIudGFibGVjZWxsKFxuICAgICAgICAgIHRoaXMuaW5saW5lLm91dHB1dCh0aGlzLnRva2VuLmhlYWRlcltpXSksXG4gICAgICAgICAgeyBoZWFkZXI6IHRydWUsIGFsaWduOiB0aGlzLnRva2VuLmFsaWduW2ldIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGhlYWRlciArPSB0aGlzLnJlbmRlcmVyLnRhYmxlcm93KGNlbGwpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy50b2tlbi5jZWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICByb3cgPSB0aGlzLnRva2VuLmNlbGxzW2ldO1xuXG4gICAgICAgIGNlbGwgPSAnJztcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHJvdy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNlbGwgKz0gdGhpcy5yZW5kZXJlci50YWJsZWNlbGwoXG4gICAgICAgICAgICB0aGlzLmlubGluZS5vdXRwdXQocm93W2pdKSxcbiAgICAgICAgICAgIHsgaGVhZGVyOiBmYWxzZSwgYWxpZ246IHRoaXMudG9rZW4uYWxpZ25bal0gfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBib2R5ICs9IHRoaXMucmVuZGVyZXIudGFibGVyb3coY2VsbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci50YWJsZShoZWFkZXIsIGJvZHkpO1xuICAgIH1cbiAgICBjYXNlICdibG9ja3F1b3RlX3N0YXJ0Jzoge1xuICAgICAgdmFyIGJvZHkgPSAnJztcblxuICAgICAgd2hpbGUgKHRoaXMubmV4dCgpLnR5cGUgIT09ICdibG9ja3F1b3RlX2VuZCcpIHtcbiAgICAgICAgYm9keSArPSB0aGlzLnRvaygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5ibG9ja3F1b3RlKGJvZHkpO1xuICAgIH1cbiAgICBjYXNlICdsaXN0X3N0YXJ0Jzoge1xuICAgICAgdmFyIGJvZHkgPSAnJ1xuICAgICAgICAsIG9yZGVyZWQgPSB0aGlzLnRva2VuLm9yZGVyZWQ7XG5cbiAgICAgIHdoaWxlICh0aGlzLm5leHQoKS50eXBlICE9PSAnbGlzdF9lbmQnKSB7XG4gICAgICAgIGJvZHkgKz0gdGhpcy50b2soKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIubGlzdChib2R5LCBvcmRlcmVkKTtcbiAgICB9XG4gICAgY2FzZSAnbGlzdF9pdGVtX3N0YXJ0Jzoge1xuICAgICAgdmFyIGJvZHkgPSAnJztcblxuICAgICAgd2hpbGUgKHRoaXMubmV4dCgpLnR5cGUgIT09ICdsaXN0X2l0ZW1fZW5kJykge1xuICAgICAgICBib2R5ICs9IHRoaXMudG9rZW4udHlwZSA9PT0gJ3RleHQnXG4gICAgICAgICAgPyB0aGlzLnBhcnNlVGV4dCgpXG4gICAgICAgICAgOiB0aGlzLnRvaygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5saXN0aXRlbShib2R5KTtcbiAgICB9XG4gICAgY2FzZSAnbG9vc2VfaXRlbV9zdGFydCc6IHtcbiAgICAgIHZhciBib2R5ID0gJyc7XG5cbiAgICAgIHdoaWxlICh0aGlzLm5leHQoKS50eXBlICE9PSAnbGlzdF9pdGVtX2VuZCcpIHtcbiAgICAgICAgYm9keSArPSB0aGlzLnRvaygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5saXN0aXRlbShib2R5KTtcbiAgICB9XG4gICAgY2FzZSAnaHRtbCc6IHtcbiAgICAgIHZhciBodG1sID0gIXRoaXMudG9rZW4ucHJlICYmICF0aGlzLm9wdGlvbnMucGVkYW50aWNcbiAgICAgICAgPyB0aGlzLmlubGluZS5vdXRwdXQodGhpcy50b2tlbi50ZXh0KVxuICAgICAgICA6IHRoaXMudG9rZW4udGV4dDtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmh0bWwoaHRtbCk7XG4gICAgfVxuICAgIGNhc2UgJ3BhcmFncmFwaCc6IHtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLnBhcmFncmFwaCh0aGlzLmlubGluZS5vdXRwdXQodGhpcy50b2tlbi50ZXh0KSk7XG4gICAgfVxuICAgIGNhc2UgJ3RleHQnOiB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5wYXJhZ3JhcGgodGhpcy5wYXJzZVRleHQoKSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEhlbHBlcnNcbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGUoaHRtbCwgZW5jb2RlKSB7XG4gIHJldHVybiBodG1sXG4gICAgLnJlcGxhY2UoIWVuY29kZSA/IC8mKD8hIz9cXHcrOykvZyA6IC8mL2csICcmYW1wOycpXG4gICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpXG4gICAgLnJlcGxhY2UoLycvZywgJyYjMzk7Jyk7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2UocmVnZXgsIG9wdCkge1xuICByZWdleCA9IHJlZ2V4LnNvdXJjZTtcbiAgb3B0ID0gb3B0IHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb24gc2VsZihuYW1lLCB2YWwpIHtcbiAgICBpZiAoIW5hbWUpIHJldHVybiBuZXcgUmVnRXhwKHJlZ2V4LCBvcHQpO1xuICAgIHZhbCA9IHZhbC5zb3VyY2UgfHwgdmFsO1xuICAgIHZhbCA9IHZhbC5yZXBsYWNlKC8oXnxbXlxcW10pXFxeL2csICckMScpO1xuICAgIHJlZ2V4ID0gcmVnZXgucmVwbGFjZShuYW1lLCB2YWwpO1xuICAgIHJldHVybiBzZWxmO1xuICB9O1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cbm5vb3AuZXhlYyA9IG5vb3A7XG5cbmZ1bmN0aW9uIG1lcmdlKG9iaikge1xuICB2YXIgaSA9IDFcbiAgICAsIHRhcmdldFxuICAgICwga2V5O1xuXG4gIGZvciAoOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGFyZ2V0ID0gYXJndW1lbnRzW2ldO1xuICAgIGZvciAoa2V5IGluIHRhcmdldCkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIGtleSkpIHtcbiAgICAgICAgb2JqW2tleV0gPSB0YXJnZXRba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5cbi8qKlxuICogTWFya2VkXG4gKi9cblxuZnVuY3Rpb24gbWFya2VkKHNyYywgb3B0LCBjYWxsYmFjaykge1xuICBpZiAoY2FsbGJhY2sgfHwgdHlwZW9mIG9wdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0O1xuICAgICAgb3B0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBvcHQgPSBtZXJnZSh7fSwgbWFya2VkLmRlZmF1bHRzLCBvcHQgfHwge30pO1xuXG4gICAgdmFyIGhpZ2hsaWdodCA9IG9wdC5oaWdobGlnaHRcbiAgICAgICwgdG9rZW5zXG4gICAgICAsIHBlbmRpbmdcbiAgICAgICwgaSA9IDA7XG5cbiAgICB0cnkge1xuICAgICAgdG9rZW5zID0gTGV4ZXIubGV4KHNyYywgb3B0KVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlKTtcbiAgICB9XG5cbiAgICBwZW5kaW5nID0gdG9rZW5zLmxlbmd0aDtcblxuICAgIHZhciBkb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3V0LCBlcnI7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIG91dCA9IFBhcnNlci5wYXJzZSh0b2tlbnMsIG9wdCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVyciA9IGU7XG4gICAgICB9XG5cbiAgICAgIG9wdC5oaWdobGlnaHQgPSBoaWdobGlnaHQ7XG5cbiAgICAgIHJldHVybiBlcnJcbiAgICAgICAgPyBjYWxsYmFjayhlcnIpXG4gICAgICAgIDogY2FsbGJhY2sobnVsbCwgb3V0KTtcbiAgICB9O1xuXG4gICAgaWYgKCFoaWdobGlnaHQgfHwgaGlnaGxpZ2h0Lmxlbmd0aCA8IDMpIHtcbiAgICAgIHJldHVybiBkb25lKCk7XG4gICAgfVxuXG4gICAgZGVsZXRlIG9wdC5oaWdobGlnaHQ7XG5cbiAgICBpZiAoIXBlbmRpbmcpIHJldHVybiBkb25lKCk7XG5cbiAgICBmb3IgKDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgKGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgICAgIGlmICh0b2tlbi50eXBlICE9PSAnY29kZScpIHtcbiAgICAgICAgICByZXR1cm4gLS1wZW5kaW5nIHx8IGRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGlnaGxpZ2h0KHRva2VuLnRleHQsIHRva2VuLmxhbmcsIGZ1bmN0aW9uKGVyciwgY29kZSkge1xuICAgICAgICAgIGlmIChjb2RlID09IG51bGwgfHwgY29kZSA9PT0gdG9rZW4udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIC0tcGVuZGluZyB8fCBkb25lKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRva2VuLnRleHQgPSBjb2RlO1xuICAgICAgICAgIHRva2VuLmVzY2FwZWQgPSB0cnVlO1xuICAgICAgICAgIC0tcGVuZGluZyB8fCBkb25lKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSkodG9rZW5zW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cbiAgdHJ5IHtcbiAgICBpZiAob3B0KSBvcHQgPSBtZXJnZSh7fSwgbWFya2VkLmRlZmF1bHRzLCBvcHQpO1xuICAgIHJldHVybiBQYXJzZXIucGFyc2UoTGV4ZXIubGV4KHNyYywgb3B0KSwgb3B0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGUubWVzc2FnZSArPSAnXFxuUGxlYXNlIHJlcG9ydCB0aGlzIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGpqL21hcmtlZC4nO1xuICAgIGlmICgob3B0IHx8IG1hcmtlZC5kZWZhdWx0cykuc2lsZW50KSB7XG4gICAgICByZXR1cm4gJzxwPkFuIGVycm9yIG9jY3VyZWQ6PC9wPjxwcmU+J1xuICAgICAgICArIGVzY2FwZShlLm1lc3NhZ2UgKyAnJywgdHJ1ZSlcbiAgICAgICAgKyAnPC9wcmU+JztcbiAgICB9XG4gICAgdGhyb3cgZTtcbiAgfVxufVxuXG4vKipcbiAqIE9wdGlvbnNcbiAqL1xuXG5tYXJrZWQub3B0aW9ucyA9XG5tYXJrZWQuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdCkge1xuICBtZXJnZShtYXJrZWQuZGVmYXVsdHMsIG9wdCk7XG4gIHJldHVybiBtYXJrZWQ7XG59O1xuXG5tYXJrZWQuZGVmYXVsdHMgPSB7XG4gIGdmbTogdHJ1ZSxcbiAgdGFibGVzOiB0cnVlLFxuICBicmVha3M6IGZhbHNlLFxuICBwZWRhbnRpYzogZmFsc2UsXG4gIHNhbml0aXplOiBmYWxzZSxcbiAgc21hcnRMaXN0czogZmFsc2UsXG4gIHNpbGVudDogZmFsc2UsXG4gIGhpZ2hsaWdodDogbnVsbCxcbiAgbGFuZ1ByZWZpeDogJ2xhbmctJyxcbiAgc21hcnR5cGFudHM6IGZhbHNlLFxuICBoZWFkZXJQcmVmaXg6ICcnLFxuICByZW5kZXJlcjogbmV3IFJlbmRlcmVyXG59O1xuXG4vKipcbiAqIEV4cG9zZVxuICovXG5cbm1hcmtlZC5QYXJzZXIgPSBQYXJzZXI7XG5tYXJrZWQucGFyc2VyID0gUGFyc2VyLnBhcnNlO1xuXG5tYXJrZWQuUmVuZGVyZXIgPSBSZW5kZXJlcjtcblxubWFya2VkLkxleGVyID0gTGV4ZXI7XG5tYXJrZWQubGV4ZXIgPSBMZXhlci5sZXg7XG5cbm1hcmtlZC5JbmxpbmVMZXhlciA9IElubGluZUxleGVyO1xubWFya2VkLmlubGluZUxleGVyID0gSW5saW5lTGV4ZXIub3V0cHV0O1xuXG5tYXJrZWQucGFyc2UgPSBtYXJrZWQ7XG5cbmlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBtYXJrZWQ7XG59IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBtYXJrZWQ7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy5tYXJrZWQgPSBtYXJrZWQ7XG59XG5cbn0pLmNhbGwoZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzIHx8ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbCk7XG59KCkpO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsIi8qKlxuICogT2JqZWN0I3RvU3RyaW5nKCkgcmVmIGZvciBzdHJpbmdpZnkoKS5cbiAqL1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIE9iamVjdCNoYXNPd25Qcm9wZXJ0eSByZWZcbiAqL1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEFycmF5I2luZGV4T2Ygc2hpbS5cbiAqL1xuXG52YXIgaW5kZXhPZiA9IHR5cGVvZiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJ1xuICA/IGZ1bmN0aW9uKGFyciwgZWwpIHsgcmV0dXJuIGFyci5pbmRleE9mKGVsKTsgfVxuICA6IGZ1bmN0aW9uKGFyciwgZWwpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhcnJbaV0gPT09IGVsKSByZXR1cm4gaTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuXG4vKipcbiAqIEFycmF5LmlzQXJyYXkgc2hpbS5cbiAqL1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24oYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbi8qKlxuICogT2JqZWN0LmtleXMgc2hpbS5cbiAqL1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uKG9iaikge1xuICB2YXIgcmV0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHJldC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIEFycmF5I2ZvckVhY2ggc2hpbS5cbiAqL1xuXG52YXIgZm9yRWFjaCA9IHR5cGVvZiBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCA9PT0gJ2Z1bmN0aW9uJ1xuICA/IGZ1bmN0aW9uKGFyciwgZm4pIHsgcmV0dXJuIGFyci5mb3JFYWNoKGZuKTsgfVxuICA6IGZ1bmN0aW9uKGFyciwgZm4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBmbihhcnJbaV0pO1xuICAgIH07XG5cbi8qKlxuICogQXJyYXkjcmVkdWNlIHNoaW0uXG4gKi9cblxudmFyIHJlZHVjZSA9IGZ1bmN0aW9uKGFyciwgZm4sIGluaXRpYWwpIHtcbiAgaWYgKHR5cGVvZiBhcnIucmVkdWNlID09PSAnZnVuY3Rpb24nKSByZXR1cm4gYXJyLnJlZHVjZShmbiwgaW5pdGlhbCk7XG4gIHZhciByZXMgPSBpbml0aWFsO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcmVzID0gZm4ocmVzLCBhcnJbaV0pO1xuICByZXR1cm4gcmVzO1xufTtcblxuLyoqXG4gKiBDYWNoZSBub24taW50ZWdlciB0ZXN0IHJlZ2V4cC5cbiAqL1xuXG52YXIgaXNpbnQgPSAvXlswLTldKyQvO1xuXG5mdW5jdGlvbiBwcm9tb3RlKHBhcmVudCwga2V5KSB7XG4gIGlmIChwYXJlbnRba2V5XS5sZW5ndGggPT0gMCkgcmV0dXJuIHBhcmVudFtrZXldID0ge31cbiAgdmFyIHQgPSB7fTtcbiAgZm9yICh2YXIgaSBpbiBwYXJlbnRba2V5XSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmVudFtrZXldLCBpKSkge1xuICAgICAgdFtpXSA9IHBhcmVudFtrZXldW2ldO1xuICAgIH1cbiAgfVxuICBwYXJlbnRba2V5XSA9IHQ7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBwYXJzZShwYXJ0cywgcGFyZW50LCBrZXksIHZhbCkge1xuICB2YXIgcGFydCA9IHBhcnRzLnNoaWZ0KCk7XG4gIFxuICAvLyBpbGxlZ2FsXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdC5wcm90b3R5cGUsIGtleSkpIHJldHVybjtcbiAgXG4gIC8vIGVuZFxuICBpZiAoIXBhcnQpIHtcbiAgICBpZiAoaXNBcnJheShwYXJlbnRba2V5XSkpIHtcbiAgICAgIHBhcmVudFtrZXldLnB1c2godmFsKTtcbiAgICB9IGVsc2UgaWYgKCdvYmplY3QnID09IHR5cGVvZiBwYXJlbnRba2V5XSkge1xuICAgICAgcGFyZW50W2tleV0gPSB2YWw7XG4gICAgfSBlbHNlIGlmICgndW5kZWZpbmVkJyA9PSB0eXBlb2YgcGFyZW50W2tleV0pIHtcbiAgICAgIHBhcmVudFtrZXldID0gdmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnRba2V5XSA9IFtwYXJlbnRba2V5XSwgdmFsXTtcbiAgICB9XG4gICAgLy8gYXJyYXlcbiAgfSBlbHNlIHtcbiAgICB2YXIgb2JqID0gcGFyZW50W2tleV0gPSBwYXJlbnRba2V5XSB8fCBbXTtcbiAgICBpZiAoJ10nID09IHBhcnQpIHtcbiAgICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgICAgaWYgKCcnICE9IHZhbCkgb2JqLnB1c2godmFsKTtcbiAgICAgIH0gZWxzZSBpZiAoJ29iamVjdCcgPT0gdHlwZW9mIG9iaikge1xuICAgICAgICBvYmpbb2JqZWN0S2V5cyhvYmopLmxlbmd0aF0gPSB2YWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmogPSBwYXJlbnRba2V5XSA9IFtwYXJlbnRba2V5XSwgdmFsXTtcbiAgICAgIH1cbiAgICAgIC8vIHByb3BcbiAgICB9IGVsc2UgaWYgKH5pbmRleE9mKHBhcnQsICddJykpIHtcbiAgICAgIHBhcnQgPSBwYXJ0LnN1YnN0cigwLCBwYXJ0Lmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKCFpc2ludC50ZXN0KHBhcnQpICYmIGlzQXJyYXkob2JqKSkgb2JqID0gcHJvbW90ZShwYXJlbnQsIGtleSk7XG4gICAgICBwYXJzZShwYXJ0cywgb2JqLCBwYXJ0LCB2YWwpO1xuICAgICAgLy8ga2V5XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghaXNpbnQudGVzdChwYXJ0KSAmJiBpc0FycmF5KG9iaikpIG9iaiA9IHByb21vdGUocGFyZW50LCBrZXkpO1xuICAgICAgcGFyc2UocGFydHMsIG9iaiwgcGFydCwgdmFsKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSBwYXJlbnQga2V5L3ZhbCBwYWlyLlxuICovXG5cbmZ1bmN0aW9uIG1lcmdlKHBhcmVudCwga2V5LCB2YWwpe1xuICBpZiAofmluZGV4T2Yoa2V5LCAnXScpKSB7XG4gICAgdmFyIHBhcnRzID0ga2V5LnNwbGl0KCdbJylcbiAgICAgICwgbGVuID0gcGFydHMubGVuZ3RoXG4gICAgICAsIGxhc3QgPSBsZW4gLSAxO1xuICAgIHBhcnNlKHBhcnRzLCBwYXJlbnQsICdiYXNlJywgdmFsKTtcbiAgICAvLyBvcHRpbWl6ZVxuICB9IGVsc2Uge1xuICAgIGlmICghaXNpbnQudGVzdChrZXkpICYmIGlzQXJyYXkocGFyZW50LmJhc2UpKSB7XG4gICAgICB2YXIgdCA9IHt9O1xuICAgICAgZm9yICh2YXIgayBpbiBwYXJlbnQuYmFzZSkgdFtrXSA9IHBhcmVudC5iYXNlW2tdO1xuICAgICAgcGFyZW50LmJhc2UgPSB0O1xuICAgIH1cbiAgICBzZXQocGFyZW50LmJhc2UsIGtleSwgdmFsKTtcbiAgfVxuXG4gIHJldHVybiBwYXJlbnQ7XG59XG5cbi8qKlxuICogQ29tcGFjdCBzcGFyc2UgYXJyYXlzLlxuICovXG5cbmZ1bmN0aW9uIGNvbXBhY3Qob2JqKSB7XG4gIGlmICgnb2JqZWN0JyAhPSB0eXBlb2Ygb2JqKSByZXR1cm4gb2JqO1xuXG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICB2YXIgcmV0ID0gW107XG5cbiAgICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkge1xuICAgICAgICByZXQucHVzaChvYmpbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgb2JqW2tleV0gPSBjb21wYWN0KG9ialtrZXldKTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIG9iai5cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZU9iamVjdChvYmope1xuICB2YXIgcmV0ID0geyBiYXNlOiB7fSB9O1xuXG4gIGZvckVhY2gob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihuYW1lKXtcbiAgICBtZXJnZShyZXQsIG5hbWUsIG9ialtuYW1lXSk7XG4gIH0pO1xuXG4gIHJldHVybiBjb21wYWN0KHJldC5iYXNlKTtcbn1cblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gc3RyLlxuICovXG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nKHN0cil7XG4gIHZhciByZXQgPSByZWR1Y2UoU3RyaW5nKHN0cikuc3BsaXQoJyYnKSwgZnVuY3Rpb24ocmV0LCBwYWlyKXtcbiAgICB2YXIgZXFsID0gaW5kZXhPZihwYWlyLCAnPScpXG4gICAgICAsIGJyYWNlID0gbGFzdEJyYWNlSW5LZXkocGFpcilcbiAgICAgICwga2V5ID0gcGFpci5zdWJzdHIoMCwgYnJhY2UgfHwgZXFsKVxuICAgICAgLCB2YWwgPSBwYWlyLnN1YnN0cihicmFjZSB8fCBlcWwsIHBhaXIubGVuZ3RoKVxuICAgICAgLCB2YWwgPSB2YWwuc3Vic3RyKGluZGV4T2YodmFsLCAnPScpICsgMSwgdmFsLmxlbmd0aCk7XG5cbiAgICAvLyA/Zm9vXG4gICAgaWYgKCcnID09IGtleSkga2V5ID0gcGFpciwgdmFsID0gJyc7XG4gICAgaWYgKCcnID09IGtleSkgcmV0dXJuIHJldDtcblxuICAgIHJldHVybiBtZXJnZShyZXQsIGRlY29kZShrZXkpLCBkZWNvZGUodmFsKSk7XG4gIH0sIHsgYmFzZToge30gfSkuYmFzZTtcblxuICByZXR1cm4gY29tcGFjdChyZXQpO1xufVxuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBxdWVyeSBgc3RyYCBvciBgb2JqYCwgcmV0dXJuaW5nIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIHwge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbihzdHIpe1xuICBpZiAobnVsbCA9PSBzdHIgfHwgJycgPT0gc3RyKSByZXR1cm4ge307XG4gIHJldHVybiAnb2JqZWN0JyA9PSB0eXBlb2Ygc3RyXG4gICAgPyBwYXJzZU9iamVjdChzdHIpXG4gICAgOiBwYXJzZVN0cmluZyhzdHIpO1xufTtcblxuLyoqXG4gKiBUdXJuIHRoZSBnaXZlbiBgb2JqYCBpbnRvIGEgcXVlcnkgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG52YXIgc3RyaW5naWZ5ID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBmdW5jdGlvbihvYmosIHByZWZpeCkge1xuICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeUFycmF5KG9iaiwgcHJlZml4KTtcbiAgfSBlbHNlIGlmICgnW29iamVjdCBPYmplY3RdJyA9PSB0b1N0cmluZy5jYWxsKG9iaikpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5T2JqZWN0KG9iaiwgcHJlZml4KTtcbiAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PSB0eXBlb2Ygb2JqKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeVN0cmluZyhvYmosIHByZWZpeCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHByZWZpeCArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcob2JqKSk7XG4gIH1cbn07XG5cbi8qKlxuICogU3RyaW5naWZ5IHRoZSBnaXZlbiBgc3RyYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzdHJpbmdpZnlTdHJpbmcoc3RyLCBwcmVmaXgpIHtcbiAgaWYgKCFwcmVmaXgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmluZ2lmeSBleHBlY3RzIGFuIG9iamVjdCcpO1xuICByZXR1cm4gcHJlZml4ICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cik7XG59XG5cbi8qKlxuICogU3RyaW5naWZ5IHRoZSBnaXZlbiBgYXJyYC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXhcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUFycmF5KGFyciwgcHJlZml4KSB7XG4gIHZhciByZXQgPSBbXTtcbiAgaWYgKCFwcmVmaXgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmluZ2lmeSBleHBlY3RzIGFuIG9iamVjdCcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIHJldC5wdXNoKHN0cmluZ2lmeShhcnJbaV0sIHByZWZpeCArICdbJyArIGkgKyAnXScpKTtcbiAgfVxuICByZXR1cm4gcmV0LmpvaW4oJyYnKTtcbn1cblxuLyoqXG4gKiBTdHJpbmdpZnkgdGhlIGdpdmVuIGBvYmpgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXhcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHN0cmluZ2lmeU9iamVjdChvYmosIHByZWZpeCkge1xuICB2YXIgcmV0ID0gW11cbiAgICAsIGtleXMgPSBvYmplY3RLZXlzKG9iailcbiAgICAsIGtleTtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgaWYgKCcnID09IGtleSkgY29udGludWU7XG4gICAgaWYgKG51bGwgPT0gb2JqW2tleV0pIHtcbiAgICAgIHJldC5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0LnB1c2goc3RyaW5naWZ5KG9ialtrZXldLCBwcmVmaXhcbiAgICAgICAgPyBwcmVmaXggKyAnWycgKyBlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICddJ1xuICAgICAgICA6IGVuY29kZVVSSUNvbXBvbmVudChrZXkpKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldC5qb2luKCcmJyk7XG59XG5cbi8qKlxuICogU2V0IGBvYmpgJ3MgYGtleWAgdG8gYHZhbGAgcmVzcGVjdGluZ1xuICogdGhlIHdlaXJkIGFuZCB3b25kZXJmdWwgc3ludGF4IG9mIGEgcXMsXG4gKiB3aGVyZSBcImZvbz1iYXImZm9vPWJhelwiIGJlY29tZXMgYW4gYXJyYXkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2V0KG9iaiwga2V5LCB2YWwpIHtcbiAgdmFyIHYgPSBvYmpba2V5XTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqZWN0LnByb3RvdHlwZSwga2V5KSkgcmV0dXJuO1xuICBpZiAodW5kZWZpbmVkID09PSB2KSB7XG4gICAgb2JqW2tleV0gPSB2YWw7XG4gIH0gZWxzZSBpZiAoaXNBcnJheSh2KSkge1xuICAgIHYucHVzaCh2YWwpO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gW3YsIHZhbF07XG4gIH1cbn1cblxuLyoqXG4gKiBMb2NhdGUgbGFzdCBicmFjZSBpbiBgc3RyYCB3aXRoaW4gdGhlIGtleS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsYXN0QnJhY2VJbktleShzdHIpIHtcbiAgdmFyIGxlbiA9IHN0ci5sZW5ndGhcbiAgICAsIGJyYWNlXG4gICAgLCBjO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgYyA9IHN0cltpXTtcbiAgICBpZiAoJ10nID09IGMpIGJyYWNlID0gZmFsc2U7XG4gICAgaWYgKCdbJyA9PSBjKSBicmFjZSA9IHRydWU7XG4gICAgaWYgKCc9JyA9PSBjICYmICFicmFjZSkgcmV0dXJuIGk7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWNvZGUgYHN0cmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZGVjb2RlKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyLnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuOyhmdW5jdGlvbih3aW4pe1xuXHR2YXIgc3RvcmUgPSB7fSxcblx0XHRkb2MgPSB3aW4uZG9jdW1lbnQsXG5cdFx0bG9jYWxTdG9yYWdlTmFtZSA9ICdsb2NhbFN0b3JhZ2UnLFxuXHRcdHN0b3JhZ2VcblxuXHRzdG9yZS5kaXNhYmxlZCA9IGZhbHNlXG5cdHN0b3JlLnNldCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHt9XG5cdHN0b3JlLmdldCA9IGZ1bmN0aW9uKGtleSkge31cblx0c3RvcmUucmVtb3ZlID0gZnVuY3Rpb24oa2V5KSB7fVxuXHRzdG9yZS5jbGVhciA9IGZ1bmN0aW9uKCkge31cblx0c3RvcmUudHJhbnNhY3QgPSBmdW5jdGlvbihrZXksIGRlZmF1bHRWYWwsIHRyYW5zYWN0aW9uRm4pIHtcblx0XHR2YXIgdmFsID0gc3RvcmUuZ2V0KGtleSlcblx0XHRpZiAodHJhbnNhY3Rpb25GbiA9PSBudWxsKSB7XG5cdFx0XHR0cmFuc2FjdGlvbkZuID0gZGVmYXVsdFZhbFxuXHRcdFx0ZGVmYXVsdFZhbCA9IG51bGxcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiB2YWwgPT0gJ3VuZGVmaW5lZCcpIHsgdmFsID0gZGVmYXVsdFZhbCB8fCB7fSB9XG5cdFx0dHJhbnNhY3Rpb25Gbih2YWwpXG5cdFx0c3RvcmUuc2V0KGtleSwgdmFsKVxuXHR9XG5cdHN0b3JlLmdldEFsbCA9IGZ1bmN0aW9uKCkge31cblx0c3RvcmUuZm9yRWFjaCA9IGZ1bmN0aW9uKCkge31cblxuXHRzdG9yZS5zZXJpYWxpemUgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSlcblx0fVxuXHRzdG9yZS5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgeyByZXR1cm4gdW5kZWZpbmVkIH1cblx0XHR0cnkgeyByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSkgfVxuXHRcdGNhdGNoKGUpIHsgcmV0dXJuIHZhbHVlIHx8IHVuZGVmaW5lZCB9XG5cdH1cblxuXHQvLyBGdW5jdGlvbnMgdG8gZW5jYXBzdWxhdGUgcXVlc3Rpb25hYmxlIEZpcmVGb3ggMy42LjEzIGJlaGF2aW9yXG5cdC8vIHdoZW4gYWJvdXQuY29uZmlnOjpkb20uc3RvcmFnZS5lbmFibGVkID09PSBmYWxzZVxuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21hcmN1c3dlc3Rpbi9zdG9yZS5qcy9pc3N1ZXMjaXNzdWUvMTNcblx0ZnVuY3Rpb24gaXNMb2NhbFN0b3JhZ2VOYW1lU3VwcG9ydGVkKCkge1xuXHRcdHRyeSB7IHJldHVybiAobG9jYWxTdG9yYWdlTmFtZSBpbiB3aW4gJiYgd2luW2xvY2FsU3RvcmFnZU5hbWVdKSB9XG5cdFx0Y2F0Y2goZXJyKSB7IHJldHVybiBmYWxzZSB9XG5cdH1cblxuXHRpZiAoaXNMb2NhbFN0b3JhZ2VOYW1lU3VwcG9ydGVkKCkpIHtcblx0XHRzdG9yYWdlID0gd2luW2xvY2FsU3RvcmFnZU5hbWVdXG5cdFx0c3RvcmUuc2V0ID0gZnVuY3Rpb24oa2V5LCB2YWwpIHtcblx0XHRcdGlmICh2YWwgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gc3RvcmUucmVtb3ZlKGtleSkgfVxuXHRcdFx0c3RvcmFnZS5zZXRJdGVtKGtleSwgc3RvcmUuc2VyaWFsaXplKHZhbCkpXG5cdFx0XHRyZXR1cm4gdmFsXG5cdFx0fVxuXHRcdHN0b3JlLmdldCA9IGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gc3RvcmUuZGVzZXJpYWxpemUoc3RvcmFnZS5nZXRJdGVtKGtleSkpIH1cblx0XHRzdG9yZS5yZW1vdmUgPSBmdW5jdGlvbihrZXkpIHsgc3RvcmFnZS5yZW1vdmVJdGVtKGtleSkgfVxuXHRcdHN0b3JlLmNsZWFyID0gZnVuY3Rpb24oKSB7IHN0b3JhZ2UuY2xlYXIoKSB9XG5cdFx0c3RvcmUuZ2V0QWxsID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcmV0ID0ge31cblx0XHRcdHN0b3JlLmZvckVhY2goZnVuY3Rpb24oa2V5LCB2YWwpIHtcblx0XHRcdFx0cmV0W2tleV0gPSB2YWxcblx0XHRcdH0pXG5cdFx0XHRyZXR1cm4gcmV0XG5cdFx0fVxuXHRcdHN0b3JlLmZvckVhY2ggPSBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRcdFx0Zm9yICh2YXIgaT0wOyBpPHN0b3JhZ2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIGtleSA9IHN0b3JhZ2Uua2V5KGkpXG5cdFx0XHRcdGNhbGxiYWNrKGtleSwgc3RvcmUuZ2V0KGtleSkpXG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKGRvYy5kb2N1bWVudEVsZW1lbnQuYWRkQmVoYXZpb3IpIHtcblx0XHR2YXIgc3RvcmFnZU93bmVyLFxuXHRcdFx0c3RvcmFnZUNvbnRhaW5lclxuXHRcdC8vIFNpbmNlICN1c2VyRGF0YSBzdG9yYWdlIGFwcGxpZXMgb25seSB0byBzcGVjaWZpYyBwYXRocywgd2UgbmVlZCB0b1xuXHRcdC8vIHNvbWVob3cgbGluayBvdXIgZGF0YSB0byBhIHNwZWNpZmljIHBhdGguICBXZSBjaG9vc2UgL2Zhdmljb24uaWNvXG5cdFx0Ly8gYXMgYSBwcmV0dHkgc2FmZSBvcHRpb24sIHNpbmNlIGFsbCBicm93c2VycyBhbHJlYWR5IG1ha2UgYSByZXF1ZXN0IHRvXG5cdFx0Ly8gdGhpcyBVUkwgYW55d2F5IGFuZCBiZWluZyBhIDQwNCB3aWxsIG5vdCBodXJ0IHVzIGhlcmUuICBXZSB3cmFwIGFuXG5cdFx0Ly8gaWZyYW1lIHBvaW50aW5nIHRvIHRoZSBmYXZpY29uIGluIGFuIEFjdGl2ZVhPYmplY3QoaHRtbGZpbGUpIG9iamVjdFxuXHRcdC8vIChzZWU6IGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9hYTc1MjU3NCh2PVZTLjg1KS5hc3B4KVxuXHRcdC8vIHNpbmNlIHRoZSBpZnJhbWUgYWNjZXNzIHJ1bGVzIGFwcGVhciB0byBhbGxvdyBkaXJlY3QgYWNjZXNzIGFuZFxuXHRcdC8vIG1hbmlwdWxhdGlvbiBvZiB0aGUgZG9jdW1lbnQgZWxlbWVudCwgZXZlbiBmb3IgYSA0MDQgcGFnZS4gIFRoaXNcblx0XHQvLyBkb2N1bWVudCBjYW4gYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IGRvY3VtZW50ICh3aGljaCB3b3VsZFxuXHRcdC8vIGhhdmUgYmVlbiBsaW1pdGVkIHRvIHRoZSBjdXJyZW50IHBhdGgpIHRvIHBlcmZvcm0gI3VzZXJEYXRhIHN0b3JhZ2UuXG5cdFx0dHJ5IHtcblx0XHRcdHN0b3JhZ2VDb250YWluZXIgPSBuZXcgQWN0aXZlWE9iamVjdCgnaHRtbGZpbGUnKVxuXHRcdFx0c3RvcmFnZUNvbnRhaW5lci5vcGVuKClcblx0XHRcdHN0b3JhZ2VDb250YWluZXIud3JpdGUoJzxzJyArICdjcmlwdD5kb2N1bWVudC53PXdpbmRvdzwvcycgKyAnY3JpcHQ+PGlmcmFtZSBzcmM9XCIvZmF2aWNvbi5pY29cIj48L2lmcmFtZT4nKVxuXHRcdFx0c3RvcmFnZUNvbnRhaW5lci5jbG9zZSgpXG5cdFx0XHRzdG9yYWdlT3duZXIgPSBzdG9yYWdlQ29udGFpbmVyLncuZnJhbWVzWzBdLmRvY3VtZW50XG5cdFx0XHRzdG9yYWdlID0gc3RvcmFnZU93bmVyLmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG5cdFx0fSBjYXRjaChlKSB7XG5cdFx0XHQvLyBzb21laG93IEFjdGl2ZVhPYmplY3QgaW5zdGFudGlhdGlvbiBmYWlsZWQgKHBlcmhhcHMgc29tZSBzcGVjaWFsXG5cdFx0XHQvLyBzZWN1cml0eSBzZXR0aW5ncyBvciBvdGhlcndzZSksIGZhbGwgYmFjayB0byBwZXItcGF0aCBzdG9yYWdlXG5cdFx0XHRzdG9yYWdlID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG5cdFx0XHRzdG9yYWdlT3duZXIgPSBkb2MuYm9keVxuXHRcdH1cblx0XHRmdW5jdGlvbiB3aXRoSUVTdG9yYWdlKHN0b3JlRnVuY3Rpb24pIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApXG5cdFx0XHRcdGFyZ3MudW5zaGlmdChzdG9yYWdlKVxuXHRcdFx0XHQvLyBTZWUgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTMxMDgxKHY9VlMuODUpLmFzcHhcblx0XHRcdFx0Ly8gYW5kIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzMTQyNCh2PVZTLjg1KS5hc3B4XG5cdFx0XHRcdHN0b3JhZ2VPd25lci5hcHBlbmRDaGlsZChzdG9yYWdlKVxuXHRcdFx0XHRzdG9yYWdlLmFkZEJlaGF2aW9yKCcjZGVmYXVsdCN1c2VyRGF0YScpXG5cdFx0XHRcdHN0b3JhZ2UubG9hZChsb2NhbFN0b3JhZ2VOYW1lKVxuXHRcdFx0XHR2YXIgcmVzdWx0ID0gc3RvcmVGdW5jdGlvbi5hcHBseShzdG9yZSwgYXJncylcblx0XHRcdFx0c3RvcmFnZU93bmVyLnJlbW92ZUNoaWxkKHN0b3JhZ2UpXG5cdFx0XHRcdHJldHVybiByZXN1bHRcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJbiBJRTcsIGtleXMgbWF5IG5vdCBjb250YWluIHNwZWNpYWwgY2hhcnMuIFNlZSBhbGwgb2YgaHR0cHM6Ly9naXRodWIuY29tL21hcmN1c3dlc3Rpbi9zdG9yZS5qcy9pc3N1ZXMvNDBcblx0XHR2YXIgZm9yYmlkZGVuQ2hhcnNSZWdleCA9IG5ldyBSZWdFeHAoXCJbIVxcXCIjJCUmJygpKissL1xcXFxcXFxcOjs8PT4/QFtcXFxcXV5ge3x9fl1cIiwgXCJnXCIpXG5cdFx0ZnVuY3Rpb24gaWVLZXlGaXgoa2V5KSB7XG5cdFx0XHRyZXR1cm4ga2V5LnJlcGxhY2UoZm9yYmlkZGVuQ2hhcnNSZWdleCwgJ19fXycpXG5cdFx0fVxuXHRcdHN0b3JlLnNldCA9IHdpdGhJRVN0b3JhZ2UoZnVuY3Rpb24oc3RvcmFnZSwga2V5LCB2YWwpIHtcblx0XHRcdGtleSA9IGllS2V5Rml4KGtleSlcblx0XHRcdGlmICh2YWwgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gc3RvcmUucmVtb3ZlKGtleSkgfVxuXHRcdFx0c3RvcmFnZS5zZXRBdHRyaWJ1dGUoa2V5LCBzdG9yZS5zZXJpYWxpemUodmFsKSlcblx0XHRcdHN0b3JhZ2Uuc2F2ZShsb2NhbFN0b3JhZ2VOYW1lKVxuXHRcdFx0cmV0dXJuIHZhbFxuXHRcdH0pXG5cdFx0c3RvcmUuZ2V0ID0gd2l0aElFU3RvcmFnZShmdW5jdGlvbihzdG9yYWdlLCBrZXkpIHtcblx0XHRcdGtleSA9IGllS2V5Rml4KGtleSlcblx0XHRcdHJldHVybiBzdG9yZS5kZXNlcmlhbGl6ZShzdG9yYWdlLmdldEF0dHJpYnV0ZShrZXkpKVxuXHRcdH0pXG5cdFx0c3RvcmUucmVtb3ZlID0gd2l0aElFU3RvcmFnZShmdW5jdGlvbihzdG9yYWdlLCBrZXkpIHtcblx0XHRcdGtleSA9IGllS2V5Rml4KGtleSlcblx0XHRcdHN0b3JhZ2UucmVtb3ZlQXR0cmlidXRlKGtleSlcblx0XHRcdHN0b3JhZ2Uuc2F2ZShsb2NhbFN0b3JhZ2VOYW1lKVxuXHRcdH0pXG5cdFx0c3RvcmUuY2xlYXIgPSB3aXRoSUVTdG9yYWdlKGZ1bmN0aW9uKHN0b3JhZ2UpIHtcblx0XHRcdHZhciBhdHRyaWJ1dGVzID0gc3RvcmFnZS5YTUxEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXR0cmlidXRlc1xuXHRcdFx0c3RvcmFnZS5sb2FkKGxvY2FsU3RvcmFnZU5hbWUpXG5cdFx0XHRmb3IgKHZhciBpPTAsIGF0dHI7IGF0dHI9YXR0cmlidXRlc1tpXTsgaSsrKSB7XG5cdFx0XHRcdHN0b3JhZ2UucmVtb3ZlQXR0cmlidXRlKGF0dHIubmFtZSlcblx0XHRcdH1cblx0XHRcdHN0b3JhZ2Uuc2F2ZShsb2NhbFN0b3JhZ2VOYW1lKVxuXHRcdH0pXG5cdFx0c3RvcmUuZ2V0QWxsID0gZnVuY3Rpb24oc3RvcmFnZSkge1xuXHRcdFx0dmFyIHJldCA9IHt9XG5cdFx0XHRzdG9yZS5mb3JFYWNoKGZ1bmN0aW9uKGtleSwgdmFsKSB7XG5cdFx0XHRcdHJldFtrZXldID0gdmFsXG5cdFx0XHR9KVxuXHRcdFx0cmV0dXJuIHJldFxuXHRcdH1cblx0XHRzdG9yZS5mb3JFYWNoID0gd2l0aElFU3RvcmFnZShmdW5jdGlvbihzdG9yYWdlLCBjYWxsYmFjaykge1xuXHRcdFx0dmFyIGF0dHJpYnV0ZXMgPSBzdG9yYWdlLlhNTERvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hdHRyaWJ1dGVzXG5cdFx0XHRmb3IgKHZhciBpPTAsIGF0dHI7IGF0dHI9YXR0cmlidXRlc1tpXTsgKytpKSB7XG5cdFx0XHRcdGNhbGxiYWNrKGF0dHIubmFtZSwgc3RvcmUuZGVzZXJpYWxpemUoc3RvcmFnZS5nZXRBdHRyaWJ1dGUoYXR0ci5uYW1lKSkpXG5cdFx0XHR9XG5cdFx0fSlcblx0fVxuXG5cdHRyeSB7XG5cdFx0dmFyIHRlc3RLZXkgPSAnX19zdG9yZWpzX18nXG5cdFx0c3RvcmUuc2V0KHRlc3RLZXksIHRlc3RLZXkpXG5cdFx0aWYgKHN0b3JlLmdldCh0ZXN0S2V5KSAhPSB0ZXN0S2V5KSB7IHN0b3JlLmRpc2FibGVkID0gdHJ1ZSB9XG5cdFx0c3RvcmUucmVtb3ZlKHRlc3RLZXkpXG5cdH0gY2F0Y2goZSkge1xuXHRcdHN0b3JlLmRpc2FibGVkID0gdHJ1ZVxuXHR9XG5cdHN0b3JlLmVuYWJsZWQgPSAhc3RvcmUuZGlzYWJsZWRcblx0XG5cdGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7IG1vZHVsZS5leHBvcnRzID0gc3RvcmUgfVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHsgZGVmaW5lKHN0b3JlKSB9XG5cdGVsc2UgeyB3aW4uc3RvcmUgPSBzdG9yZSB9XG5cdFxufSkodGhpcy53aW5kb3cgfHwgZ2xvYmFsKTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCIvLyAgICAgVW5kZXJzY29yZS5qcyAxLjYuMFxuLy8gICAgIGh0dHA6Ly91bmRlcnNjb3JlanMub3JnXG4vLyAgICAgKGMpIDIwMDktMjAxNCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuLy8gICAgIFVuZGVyc2NvcmUgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbihmdW5jdGlvbigpIHtcblxuICAvLyBCYXNlbGluZSBzZXR1cFxuICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEVzdGFibGlzaCB0aGUgcm9vdCBvYmplY3QsIGB3aW5kb3dgIGluIHRoZSBicm93c2VyLCBvciBgZXhwb3J0c2Agb24gdGhlIHNlcnZlci5cbiAgdmFyIHJvb3QgPSB0aGlzO1xuXG4gIC8vIFNhdmUgdGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBgX2AgdmFyaWFibGUuXG4gIHZhciBwcmV2aW91c1VuZGVyc2NvcmUgPSByb290Ll87XG5cbiAgLy8gRXN0YWJsaXNoIHRoZSBvYmplY3QgdGhhdCBnZXRzIHJldHVybmVkIHRvIGJyZWFrIG91dCBvZiBhIGxvb3AgaXRlcmF0aW9uLlxuICB2YXIgYnJlYWtlciA9IHt9O1xuXG4gIC8vIFNhdmUgYnl0ZXMgaW4gdGhlIG1pbmlmaWVkIChidXQgbm90IGd6aXBwZWQpIHZlcnNpb246XG4gIHZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLCBPYmpQcm90byA9IE9iamVjdC5wcm90b3R5cGUsIEZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuICAvLyBDcmVhdGUgcXVpY2sgcmVmZXJlbmNlIHZhcmlhYmxlcyBmb3Igc3BlZWQgYWNjZXNzIHRvIGNvcmUgcHJvdG90eXBlcy5cbiAgdmFyXG4gICAgcHVzaCAgICAgICAgICAgICA9IEFycmF5UHJvdG8ucHVzaCxcbiAgICBzbGljZSAgICAgICAgICAgID0gQXJyYXlQcm90by5zbGljZSxcbiAgICBjb25jYXQgICAgICAgICAgID0gQXJyYXlQcm90by5jb25jYXQsXG4gICAgdG9TdHJpbmcgICAgICAgICA9IE9ialByb3RvLnRvU3RyaW5nLFxuICAgIGhhc093blByb3BlcnR5ICAgPSBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAvLyBBbGwgKipFQ01BU2NyaXB0IDUqKiBuYXRpdmUgZnVuY3Rpb24gaW1wbGVtZW50YXRpb25zIHRoYXQgd2UgaG9wZSB0byB1c2VcbiAgLy8gYXJlIGRlY2xhcmVkIGhlcmUuXG4gIHZhclxuICAgIG5hdGl2ZUlzQXJyYXkgICAgICA9IEFycmF5LmlzQXJyYXksXG4gICAgbmF0aXZlS2V5cyAgICAgICAgID0gT2JqZWN0LmtleXMsXG4gICAgbmF0aXZlQmluZCAgICAgICAgID0gRnVuY1Byb3RvLmJpbmQ7XG5cbiAgLy8gQ3JlYXRlIGEgc2FmZSByZWZlcmVuY2UgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciB1c2UgYmVsb3cuXG4gIHZhciBfID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIF8pIHJldHVybiBvYmo7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIF8pKSByZXR1cm4gbmV3IF8ob2JqKTtcbiAgICB0aGlzLl93cmFwcGVkID0gb2JqO1xuICB9O1xuXG4gIC8vIEV4cG9ydCB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yICoqTm9kZS5qcyoqLCB3aXRoXG4gIC8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGZvciB0aGUgb2xkIGByZXF1aXJlKClgIEFQSS4gSWYgd2UncmUgaW5cbiAgLy8gdGhlIGJyb3dzZXIsIGFkZCBgX2AgYXMgYSBnbG9iYWwgb2JqZWN0IHZpYSBhIHN0cmluZyBpZGVudGlmaWVyLFxuICAvLyBmb3IgQ2xvc3VyZSBDb21waWxlciBcImFkdmFuY2VkXCIgbW9kZS5cbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gXztcbiAgICB9XG4gICAgZXhwb3J0cy5fID0gXztcbiAgfSBlbHNlIHtcbiAgICByb290Ll8gPSBfO1xuICB9XG5cbiAgLy8gQ3VycmVudCB2ZXJzaW9uLlxuICBfLlZFUlNJT04gPSAnMS42LjAnO1xuXG4gIC8vIENvbGxlY3Rpb24gRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gVGhlIGNvcm5lcnN0b25lLCBhbiBgZWFjaGAgaW1wbGVtZW50YXRpb24sIGFrYSBgZm9yRWFjaGAuXG4gIC8vIEhhbmRsZXMgcmF3IG9iamVjdHMgaW4gYWRkaXRpb24gdG8gYXJyYXktbGlrZXMuIFRyZWF0cyBhbGxcbiAgLy8gc3BhcnNlIGFycmF5LWxpa2VzIGFzIGlmIHRoZXkgd2VyZSBkZW5zZS5cbiAgXy5lYWNoID0gXy5mb3JFYWNoID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIG9iajtcbiAgICBpZiAob2JqLmxlbmd0aCA9PT0gK29iai5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopID09PSBicmVha2VyKSByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpba2V5c1tpXV0sIGtleXNbaV0sIG9iaikgPT09IGJyZWFrZXIpIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdG9yIHRvIGVhY2ggZWxlbWVudC5cbiAgXy5tYXAgPSBfLmNvbGxlY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHRzO1xuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgcmVzdWx0cy5wdXNoKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgdmFyIHJlZHVjZUVycm9yID0gJ1JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnO1xuXG4gIC8vICoqUmVkdWNlKiogYnVpbGRzIHVwIGEgc2luZ2xlIHJlc3VsdCBmcm9tIGEgbGlzdCBvZiB2YWx1ZXMsIGFrYSBgaW5qZWN0YCxcbiAgLy8gb3IgYGZvbGRsYC5cbiAgXy5yZWR1Y2UgPSBfLmZvbGRsID0gXy5pbmplY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBtZW1vLCBjb250ZXh0KSB7XG4gICAgdmFyIGluaXRpYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgICBpZiAob2JqID09IG51bGwpIG9iaiA9IFtdO1xuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKCFpbml0aWFsKSB7XG4gICAgICAgIG1lbW8gPSB2YWx1ZTtcbiAgICAgICAgaW5pdGlhbCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZW1vID0gaXRlcmF0b3IuY2FsbChjb250ZXh0LCBtZW1vLCB2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghaW5pdGlhbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihyZWR1Y2VFcnJvcik7XG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG5cbiAgLy8gVGhlIHJpZ2h0LWFzc29jaWF0aXZlIHZlcnNpb24gb2YgcmVkdWNlLCBhbHNvIGtub3duIGFzIGBmb2xkcmAuXG4gIF8ucmVkdWNlUmlnaHQgPSBfLmZvbGRyID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgbWVtbywgY29udGV4dCkge1xuICAgIHZhciBpbml0aWFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XG4gICAgaWYgKG9iaiA9PSBudWxsKSBvYmogPSBbXTtcbiAgICB2YXIgbGVuZ3RoID0gb2JqLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoICE9PSArbGVuZ3RoKSB7XG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgfVxuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaW5kZXggPSBrZXlzID8ga2V5c1stLWxlbmd0aF0gOiAtLWxlbmd0aDtcbiAgICAgIGlmICghaW5pdGlhbCkge1xuICAgICAgICBtZW1vID0gb2JqW2luZGV4XTtcbiAgICAgICAgaW5pdGlhbCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZW1vID0gaXRlcmF0b3IuY2FsbChjb250ZXh0LCBtZW1vLCBvYmpbaW5kZXhdLCBpbmRleCwgbGlzdCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFpbml0aWFsKSB0aHJvdyBuZXcgVHlwZUVycm9yKHJlZHVjZUVycm9yKTtcbiAgICByZXR1cm4gbWVtbztcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIGZpcnN0IHZhbHVlIHdoaWNoIHBhc3NlcyBhIHRydXRoIHRlc3QuIEFsaWFzZWQgYXMgYGRldGVjdGAuXG4gIF8uZmluZCA9IF8uZGV0ZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIF8uc29tZShvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkpIHtcbiAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBwYXNzIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgc2VsZWN0YC5cbiAgXy5maWx0ZXIgPSBfLnNlbGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHRzO1xuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkpIHJlc3VsdHMucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgZm9yIHdoaWNoIGEgdHJ1dGggdGVzdCBmYWlscy5cbiAgXy5yZWplY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHJldHVybiBfLmZpbHRlcihvYmosIF8ubmVnYXRlKHByZWRpY2F0ZSksIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIERldGVybWluZSB3aGV0aGVyIGFsbCBvZiB0aGUgZWxlbWVudHMgbWF0Y2ggYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBhbGxgLlxuICBfLmV2ZXJ5ID0gXy5hbGwgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSB8fCAocHJlZGljYXRlID0gXy5pZGVudGl0eSk7XG4gICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gcmVzdWx0O1xuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKCEocmVzdWx0ID0gcmVzdWx0ICYmIHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkpKSByZXR1cm4gYnJlYWtlcjtcbiAgICB9KTtcbiAgICByZXR1cm4gISFyZXN1bHQ7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIGF0IGxlYXN0IG9uZSBlbGVtZW50IGluIHRoZSBvYmplY3QgbWF0Y2hlcyBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYGFueWAuXG4gIF8uc29tZSA9IF8uYW55ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IF8uaWRlbnRpdHkpO1xuICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICBpZiAocmVzdWx0IHx8IChyZXN1bHQgPSBwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpKSkgcmV0dXJuIGJyZWFrZXI7XG4gICAgfSk7XG4gICAgcmV0dXJuICEhcmVzdWx0O1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiB0aGUgYXJyYXkgb3Igb2JqZWN0IGNvbnRhaW5zIGEgZ2l2ZW4gdmFsdWUgKHVzaW5nIGA9PT1gKS5cbiAgLy8gQWxpYXNlZCBhcyBgaW5jbHVkZWAuXG4gIF8uY29udGFpbnMgPSBfLmluY2x1ZGUgPSBmdW5jdGlvbihvYmosIHRhcmdldCkge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkgcmV0dXJuIF8uaW5kZXhPZihvYmosIHRhcmdldCkgPj0gMDtcbiAgICByZXR1cm4gXy5zb21lKG9iaiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdGFyZ2V0O1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIEludm9rZSBhIG1ldGhvZCAod2l0aCBhcmd1bWVudHMpIG9uIGV2ZXJ5IGl0ZW0gaW4gYSBjb2xsZWN0aW9uLlxuICBfLmludm9rZSA9IGZ1bmN0aW9uKG9iaiwgbWV0aG9kKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIGlzRnVuYyA9IF8uaXNGdW5jdGlvbihtZXRob2QpO1xuICAgIHJldHVybiBfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gKGlzRnVuYyA/IG1ldGhvZCA6IHZhbHVlW21ldGhvZF0pLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBtYXBgOiBmZXRjaGluZyBhIHByb3BlcnR5LlxuICBfLnBsdWNrID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBfLnByb3BlcnR5KGtleSkpO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbHRlcmA6IHNlbGVjdGluZyBvbmx5IG9iamVjdHNcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy53aGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBfLm1hdGNoZXMoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaW5kYDogZ2V0dGluZyB0aGUgZmlyc3Qgb2JqZWN0XG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8uZmluZFdoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLmZpbmQob2JqLCBfLm1hdGNoZXMoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1heGltdW0gZWxlbWVudCBvciAoZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWF4ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSAtSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IC1JbmZpbml0eSxcbiAgICAgICAgdmFsdWUsIGNvbXB1dGVkO1xuICAgIGlmICghaXRlcmF0b3IgJiYgXy5pc0FycmF5KG9iaikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBvYmpbaV07XG4gICAgICAgIGlmICh2YWx1ZSA+IHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdG9yID8gaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpIDogdmFsdWU7XG4gICAgICAgIGlmIChjb21wdXRlZCA+IGxhc3RDb21wdXRlZCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGxhc3RDb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1pbmltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWluID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSBJbmZpbml0eSwgbGFzdENvbXB1dGVkID0gSW5maW5pdHksXG4gICAgICAgIHZhbHVlLCBjb21wdXRlZDtcbiAgICBpZiAoIWl0ZXJhdG9yICYmIF8uaXNBcnJheShvYmopKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gb2JqW2ldO1xuICAgICAgICBpZiAodmFsdWUgPCByZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRvciA/IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSA6IHZhbHVlO1xuICAgICAgICBpZiAoY29tcHV0ZWQgPCBsYXN0Q29tcHV0ZWQpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gU2h1ZmZsZSBhbiBhcnJheSwgdXNpbmcgdGhlIG1vZGVybiB2ZXJzaW9uIG9mIHRoZVxuICAvLyBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVy4oCTWWF0ZXNfc2h1ZmZsZSkuXG4gIF8uc2h1ZmZsZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciByYW5kO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHNodWZmbGVkID0gW107XG4gICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJhbmQgPSBfLnJhbmRvbShpbmRleCsrKTtcbiAgICAgIHNodWZmbGVkW2luZGV4IC0gMV0gPSBzaHVmZmxlZFtyYW5kXTtcbiAgICAgIHNodWZmbGVkW3JhbmRdID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNodWZmbGVkO1xuICB9O1xuXG4gIC8vIFNhbXBsZSAqKm4qKiByYW5kb20gdmFsdWVzIGZyb20gYSBjb2xsZWN0aW9uLlxuICAvLyBJZiAqKm4qKiBpcyBub3Qgc3BlY2lmaWVkLCByZXR1cm5zIGEgc2luZ2xlIHJhbmRvbSBlbGVtZW50LlxuICAvLyBUaGUgaW50ZXJuYWwgYGd1YXJkYCBhcmd1bWVudCBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBtYXBgLlxuICBfLnNhbXBsZSA9IGZ1bmN0aW9uKG9iaiwgbiwgZ3VhcmQpIHtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSB7XG4gICAgICBpZiAob2JqLmxlbmd0aCAhPT0gK29iai5sZW5ndGgpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgICByZXR1cm4gb2JqW18ucmFuZG9tKG9iai5sZW5ndGggLSAxKV07XG4gICAgfVxuICAgIHJldHVybiBfLnNodWZmbGUob2JqKS5zbGljZSgwLCBNYXRoLm1heCgwLCBuKSk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgbG9va3VwIGl0ZXJhdG9ycy5cbiAgdmFyIGxvb2t1cEl0ZXJhdG9yID0gZnVuY3Rpb24odmFsdWUsIGNvbnRleHQpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIF8uaWRlbnRpdHk7XG4gICAgaWYgKCFfLmlzRnVuY3Rpb24odmFsdWUpKSByZXR1cm4gXy5wcm9wZXJ0eSh2YWx1ZSk7XG4gICAgaWYgKCFjb250ZXh0KSByZXR1cm4gdmFsdWU7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHZhbHVlLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBTb3J0IHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24gcHJvZHVjZWQgYnkgYW4gaXRlcmF0b3IuXG4gIF8uc29ydEJ5ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGl0ZXJhdG9yID0gbG9va3VwSXRlcmF0b3IoaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgIHJldHVybiBfLnBsdWNrKF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgY3JpdGVyaWE6IGl0ZXJhdG9yKHZhbHVlLCBpbmRleCwgbGlzdClcbiAgICAgIH07XG4gICAgfSkuc29ydChmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgdmFyIGEgPSBsZWZ0LmNyaXRlcmlhO1xuICAgICAgdmFyIGIgPSByaWdodC5jcml0ZXJpYTtcbiAgICAgIGlmIChhICE9PSBiKSB7XG4gICAgICAgIGlmIChhID4gYiB8fCBhID09PSB2b2lkIDApIHJldHVybiAxO1xuICAgICAgICBpZiAoYSA8IGIgfHwgYiA9PT0gdm9pZCAwKSByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGVmdC5pbmRleCAtIHJpZ2h0LmluZGV4O1xuICAgIH0pLCAndmFsdWUnKTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiB1c2VkIGZvciBhZ2dyZWdhdGUgXCJncm91cCBieVwiIG9wZXJhdGlvbnMuXG4gIHZhciBncm91cCA9IGZ1bmN0aW9uKGJlaGF2aW9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGl0ZXJhdG9yID0gbG9va3VwSXRlcmF0b3IoaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHZhciBrZXkgPSBpdGVyYXRvcih2YWx1ZSwgaW5kZXgsIG9iaik7XG4gICAgICAgIGJlaGF2aW9yKHJlc3VsdCwgdmFsdWUsIGtleSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBHcm91cHMgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbi4gUGFzcyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlXG4gIC8vIHRvIGdyb3VwIGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgY3JpdGVyaW9uLlxuICBfLmdyb3VwQnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICBfLmhhcyhyZXN1bHQsIGtleSkgPyByZXN1bHRba2V5XS5wdXNoKHZhbHVlKSA6IHJlc3VsdFtrZXldID0gW3ZhbHVlXTtcbiAgfSk7XG5cbiAgLy8gSW5kZXhlcyB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uLCBzaW1pbGFyIHRvIGBncm91cEJ5YCwgYnV0IGZvclxuICAvLyB3aGVuIHlvdSBrbm93IHRoYXQgeW91ciBpbmRleCB2YWx1ZXMgd2lsbCBiZSB1bmlxdWUuXG4gIF8uaW5kZXhCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gIH0pO1xuXG4gIC8vIENvdW50cyBpbnN0YW5jZXMgb2YgYW4gb2JqZWN0IHRoYXQgZ3JvdXAgYnkgYSBjZXJ0YWluIGNyaXRlcmlvbi4gUGFzc1xuICAvLyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlIHRvIGNvdW50IGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgLy8gY3JpdGVyaW9uLlxuICBfLmNvdW50QnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICBfLmhhcyhyZXN1bHQsIGtleSkgPyByZXN1bHRba2V5XSsrIDogcmVzdWx0W2tleV0gPSAxO1xuICB9KTtcblxuICAvLyBVc2UgYSBjb21wYXJhdG9yIGZ1bmN0aW9uIHRvIGZpZ3VyZSBvdXQgdGhlIHNtYWxsZXN0IGluZGV4IGF0IHdoaWNoXG4gIC8vIGFuIG9iamVjdCBzaG91bGQgYmUgaW5zZXJ0ZWQgc28gYXMgdG8gbWFpbnRhaW4gb3JkZXIuIFVzZXMgYmluYXJ5IHNlYXJjaC5cbiAgXy5zb3J0ZWRJbmRleCA9IGZ1bmN0aW9uKGFycmF5LCBvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0b3IgPSBsb29rdXBJdGVyYXRvcihpdGVyYXRvciwgY29udGV4dCk7XG4gICAgdmFyIHZhbHVlID0gaXRlcmF0b3Iob2JqKTtcbiAgICB2YXIgbG93ID0gMCwgaGlnaCA9IGFycmF5Lmxlbmd0aDtcbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgdmFyIG1pZCA9IChsb3cgKyBoaWdoKSA+Pj4gMTtcbiAgICAgIGl0ZXJhdG9yKGFycmF5W21pZF0pIDwgdmFsdWUgPyBsb3cgPSBtaWQgKyAxIDogaGlnaCA9IG1pZDtcbiAgICB9XG4gICAgcmV0dXJuIGxvdztcbiAgfTtcblxuICAvLyBTYWZlbHkgY3JlYXRlIGEgcmVhbCwgbGl2ZSBhcnJheSBmcm9tIGFueXRoaW5nIGl0ZXJhYmxlLlxuICBfLnRvQXJyYXkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIFtdO1xuICAgIGlmIChfLmlzQXJyYXkob2JqKSkgcmV0dXJuIHNsaWNlLmNhbGwob2JqKTtcbiAgICBpZiAob2JqLmxlbmd0aCA9PT0gK29iai5sZW5ndGgpIHJldHVybiBfLm1hcChvYmosIF8uaWRlbnRpdHkpO1xuICAgIHJldHVybiBfLnZhbHVlcyhvYmopO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIGFuIG9iamVjdC5cbiAgXy5zaXplID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gMDtcbiAgICByZXR1cm4gKG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoKSA/IG9iai5sZW5ndGggOiBfLmtleXMob2JqKS5sZW5ndGg7XG4gIH07XG5cbiAgLy8gQXJyYXkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgZmlyc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBBbGlhc2VkIGFzIGBoZWFkYCBhbmQgYHRha2VgLiBUaGUgKipndWFyZCoqIGNoZWNrXG4gIC8vIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5maXJzdCA9IF8uaGVhZCA9IF8udGFrZSA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmICgobiA9PSBudWxsKSB8fCBndWFyZCkgcmV0dXJuIGFycmF5WzBdO1xuICAgIGlmIChuIDwgMCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCAwLCBuKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBsYXN0IGVudHJ5IG9mIHRoZSBhcnJheS4gRXNwZWNpYWxseSB1c2VmdWwgb25cbiAgLy8gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gYWxsIHRoZSB2YWx1ZXMgaW5cbiAgLy8gdGhlIGFycmF5LCBleGNsdWRpbmcgdGhlIGxhc3QgTi4gVGhlICoqZ3VhcmQqKiBjaGVjayBhbGxvd3MgaXQgdG8gd29yayB3aXRoXG4gIC8vIGBfLm1hcGAuXG4gIF8uaW5pdGlhbCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCAwLCBNYXRoLm1heCgwLCBhcnJheS5sZW5ndGggLSAobiA9PSBudWxsIHx8IGd1YXJkID8gMSA6IG4pKSk7XG4gIH07XG5cbiAgLy8gR2V0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYW4gYXJyYXkuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gdGhlIGxhc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBUaGUgKipndWFyZCoqIGNoZWNrIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5sYXN0ID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgaWYgKChuID09IG51bGwpIHx8IGd1YXJkKSByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIE1hdGgubWF4KGFycmF5Lmxlbmd0aCAtIG4sIDApKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBmaXJzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYHRhaWxgIGFuZCBgZHJvcGAuXG4gIC8vIEVzcGVjaWFsbHkgdXNlZnVsIG9uIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nIGFuICoqbioqIHdpbGwgcmV0dXJuXG4gIC8vIHRoZSByZXN0IE4gdmFsdWVzIGluIHRoZSBhcnJheS4gVGhlICoqZ3VhcmQqKlxuICAvLyBjaGVjayBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBfLm1hcGAuXG4gIF8ucmVzdCA9IF8udGFpbCA9IF8uZHJvcCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCAobiA9PSBudWxsKSB8fCBndWFyZCA/IDEgOiBuKTtcbiAgfTtcblxuICAvLyBUcmltIG91dCBhbGwgZmFsc3kgdmFsdWVzIGZyb20gYW4gYXJyYXkuXG4gIF8uY29tcGFjdCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBfLmlkZW50aXR5KTtcbiAgfTtcblxuICAvLyBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvZiBhIHJlY3Vyc2l2ZSBgZmxhdHRlbmAgZnVuY3Rpb24uXG4gIHZhciBmbGF0dGVuID0gZnVuY3Rpb24oaW5wdXQsIHNoYWxsb3csIHN0cmljdCwgb3V0cHV0KSB7XG4gICAgaWYgKHNoYWxsb3cgJiYgXy5ldmVyeShpbnB1dCwgXy5pc0FycmF5KSkge1xuICAgICAgcmV0dXJuIGNvbmNhdC5hcHBseShvdXRwdXQsIGlucHV0KTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGlucHV0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBpbnB1dFtpXTtcbiAgICAgIGlmICghXy5pc0FycmF5KHZhbHVlKSAmJiAhXy5pc0FyZ3VtZW50cyh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKCFzdHJpY3QpIG91dHB1dC5wdXNoKHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc2hhbGxvdykge1xuICAgICAgICBwdXNoLmFwcGx5KG91dHB1dCwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmxhdHRlbih2YWx1ZSwgc2hhbGxvdywgc3RyaWN0LCBvdXRwdXQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xuXG4gIC8vIEZsYXR0ZW4gb3V0IGFuIGFycmF5LCBlaXRoZXIgcmVjdXJzaXZlbHkgKGJ5IGRlZmF1bHQpLCBvciBqdXN0IG9uZSBsZXZlbC5cbiAgXy5mbGF0dGVuID0gZnVuY3Rpb24oYXJyYXksIHNoYWxsb3cpIHtcbiAgICByZXR1cm4gZmxhdHRlbihhcnJheSwgc2hhbGxvdywgZmFsc2UsIFtdKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSB2ZXJzaW9uIG9mIHRoZSBhcnJheSB0aGF0IGRvZXMgbm90IGNvbnRhaW4gdGhlIHNwZWNpZmllZCB2YWx1ZShzKS5cbiAgXy53aXRob3V0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gXy5kaWZmZXJlbmNlKGFycmF5LCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICB9O1xuXG4gIC8vIFNwbGl0IGFuIGFycmF5IGludG8gdHdvIGFycmF5czogb25lIHdob3NlIGVsZW1lbnRzIGFsbCBzYXRpc2Z5IHRoZSBnaXZlblxuICAvLyBwcmVkaWNhdGUsIGFuZCBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIGRvIG5vdCBzYXRpc2Z5IHRoZSBwcmVkaWNhdGUuXG4gIF8ucGFydGl0aW9uID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBsb29rdXBJdGVyYXRvcihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBwYXNzID0gW10sIGZhaWwgPSBbXTtcbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmopIHtcbiAgICAgIChwcmVkaWNhdGUodmFsdWUsIGtleSwgb2JqKSA/IHBhc3MgOiBmYWlsKS5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gW3Bhc3MsIGZhaWxdO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIHRoZSBhcnJheS4gSWYgdGhlIGFycmF5IGhhcyBhbHJlYWR5XG4gIC8vIGJlZW4gc29ydGVkLCB5b3UgaGF2ZSB0aGUgb3B0aW9uIG9mIHVzaW5nIGEgZmFzdGVyIGFsZ29yaXRobS5cbiAgLy8gQWxpYXNlZCBhcyBgdW5pcXVlYC5cbiAgXy51bmlxID0gXy51bmlxdWUgPSBmdW5jdGlvbihhcnJheSwgaXNTb3J0ZWQsIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiBbXTtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKGlzU29ydGVkKSkge1xuICAgICAgY29udGV4dCA9IGl0ZXJhdG9yO1xuICAgICAgaXRlcmF0b3IgPSBpc1NvcnRlZDtcbiAgICAgIGlzU29ydGVkID0gZmFsc2U7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgc2VlbiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaV07XG4gICAgICBpZiAoaXRlcmF0b3IpIHZhbHVlID0gaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaSwgYXJyYXkpO1xuICAgICAgaWYgKGlzU29ydGVkID8gKCFpIHx8IHNlZW4gIT09IHZhbHVlKSA6ICFfLmNvbnRhaW5zKHNlZW4sIHZhbHVlKSkge1xuICAgICAgICBpZiAoaXNTb3J0ZWQpIHNlZW4gPSB2YWx1ZTtcbiAgICAgICAgZWxzZSBzZWVuLnB1c2godmFsdWUpO1xuICAgICAgICByZXN1bHQucHVzaChhcnJheVtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSB1bmlvbjogZWFjaCBkaXN0aW5jdCBlbGVtZW50IGZyb20gYWxsIG9mXG4gIC8vIHRoZSBwYXNzZWQtaW4gYXJyYXlzLlxuICBfLnVuaW9uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8udW5pcShmbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSwgW10pKTtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgZXZlcnkgaXRlbSBzaGFyZWQgYmV0d2VlbiBhbGwgdGhlXG4gIC8vIHBhc3NlZC1pbiBhcnJheXMuXG4gIF8uaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIFtdO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IGFycmF5W2ldO1xuICAgICAgaWYgKF8uY29udGFpbnMocmVzdWx0LCBpdGVtKSkgY29udGludWU7XG4gICAgICBmb3IgKHZhciBqID0gMTsgaiA8IGFyZ3NMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoIV8uY29udGFpbnMoYXJndW1lbnRzW2pdLCBpdGVtKSkgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoaiA9PT0gYXJnc0xlbmd0aCkgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gVGFrZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIG9uZSBhcnJheSBhbmQgYSBudW1iZXIgb2Ygb3RoZXIgYXJyYXlzLlxuICAvLyBPbmx5IHRoZSBlbGVtZW50cyBwcmVzZW50IGluIGp1c3QgdGhlIGZpcnN0IGFycmF5IHdpbGwgcmVtYWluLlxuICBfLmRpZmZlcmVuY2UgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciByZXN0ID0gZmxhdHRlbihzbGljZS5jYWxsKGFyZ3VtZW50cywgMSksIHRydWUsIHRydWUsIFtdKTtcbiAgICByZXR1cm4gXy5maWx0ZXIoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKXsgcmV0dXJuICFfLmNvbnRhaW5zKHJlc3QsIHZhbHVlKTsgfSk7XG4gIH07XG5cbiAgLy8gWmlwIHRvZ2V0aGVyIG11bHRpcGxlIGxpc3RzIGludG8gYSBzaW5nbGUgYXJyYXkgLS0gZWxlbWVudHMgdGhhdCBzaGFyZVxuICAvLyBhbiBpbmRleCBnbyB0b2dldGhlci5cbiAgXy56aXAgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGVuZ3RoID0gXy5tYXgoXy5wbHVjayhhcmd1bWVudHMsICdsZW5ndGgnKS5jb25jYXQoMCkpO1xuICAgIHZhciByZXN1bHRzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0c1tpXSA9IF8ucGx1Y2soYXJndW1lbnRzLCAnJyArIGkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBDb252ZXJ0cyBsaXN0cyBpbnRvIG9iamVjdHMuIFBhc3MgZWl0aGVyIGEgc2luZ2xlIGFycmF5IG9mIGBba2V5LCB2YWx1ZV1gXG4gIC8vIHBhaXJzLCBvciB0d28gcGFyYWxsZWwgYXJyYXlzIG9mIHRoZSBzYW1lIGxlbmd0aCAtLSBvbmUgb2Yga2V5cywgYW5kIG9uZSBvZlxuICAvLyB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gIF8ub2JqZWN0ID0gZnVuY3Rpb24obGlzdCwgdmFsdWVzKSB7XG4gICAgaWYgKGxpc3QgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbGlzdC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICByZXN1bHRbbGlzdFtpXV0gPSB2YWx1ZXNbaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbbGlzdFtpXVswXV0gPSBsaXN0W2ldWzFdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYW4gaXRlbSBpbiBhbiBhcnJheSxcbiAgLy8gb3IgLTEgaWYgdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS5cbiAgLy8gSWYgdGhlIGFycmF5IGlzIGxhcmdlIGFuZCBhbHJlYWR5IGluIHNvcnQgb3JkZXIsIHBhc3MgYHRydWVgXG4gIC8vIGZvciAqKmlzU29ydGVkKiogdG8gdXNlIGJpbmFyeSBzZWFyY2guXG4gIF8uaW5kZXhPZiA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBpc1NvcnRlZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gLTE7XG4gICAgdmFyIGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgaWYgKGlzU29ydGVkKSB7XG4gICAgICBpZiAodHlwZW9mIGlzU29ydGVkID09ICdudW1iZXInKSB7XG4gICAgICAgIGkgPSAoaXNTb3J0ZWQgPCAwID8gTWF0aC5tYXgoMCwgbGVuZ3RoICsgaXNTb3J0ZWQpIDogaXNTb3J0ZWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaSA9IF8uc29ydGVkSW5kZXgoYXJyYXksIGl0ZW0pO1xuICAgICAgICByZXR1cm4gYXJyYXlbaV0gPT09IGl0ZW0gPyBpIDogLTE7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIGlmIChhcnJheVtpXSA9PT0gaXRlbSkgcmV0dXJuIGk7XG4gICAgcmV0dXJuIC0xO1xuICB9O1xuXG4gIF8ubGFzdEluZGV4T2YgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgZnJvbSkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gLTE7XG4gICAgdmFyIGkgPSBmcm9tID09IG51bGwgPyBhcnJheS5sZW5ndGggOiBmcm9tO1xuICAgIHdoaWxlIChpLS0pIGlmIChhcnJheVtpXSA9PT0gaXRlbSkgcmV0dXJuIGk7XG4gICAgcmV0dXJuIC0xO1xuICB9O1xuXG4gIC8vIEdlbmVyYXRlIGFuIGludGVnZXIgQXJyYXkgY29udGFpbmluZyBhbiBhcml0aG1ldGljIHByb2dyZXNzaW9uLiBBIHBvcnQgb2ZcbiAgLy8gdGhlIG5hdGl2ZSBQeXRob24gYHJhbmdlKClgIGZ1bmN0aW9uLiBTZWVcbiAgLy8gW3RoZSBQeXRob24gZG9jdW1lbnRhdGlvbl0oaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L2Z1bmN0aW9ucy5odG1sI3JhbmdlKS5cbiAgXy5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSkge1xuICAgICAgc3RvcCA9IHN0YXJ0IHx8IDA7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIHN0ZXAgPSBhcmd1bWVudHNbMl0gfHwgMTtcblxuICAgIHZhciBsZW5ndGggPSBNYXRoLm1heChNYXRoLmNlaWwoKHN0b3AgLSBzdGFydCkgLyBzdGVwKSwgMCk7XG4gICAgdmFyIGlkeCA9IDA7XG4gICAgdmFyIHJhbmdlID0gbmV3IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZShpZHggPCBsZW5ndGgpIHtcbiAgICAgIHJhbmdlW2lkeCsrXSA9IHN0YXJ0O1xuICAgICAgc3RhcnQgKz0gc3RlcDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH07XG5cbiAgLy8gRnVuY3Rpb24gKGFoZW0pIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBSZXVzYWJsZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgcHJvdG90eXBlIHNldHRpbmcuXG4gIHZhciBjdG9yID0gZnVuY3Rpb24oKXt9O1xuXG4gIC8vIENyZWF0ZSBhIGZ1bmN0aW9uIGJvdW5kIHRvIGEgZ2l2ZW4gb2JqZWN0IChhc3NpZ25pbmcgYHRoaXNgLCBhbmQgYXJndW1lbnRzLFxuICAvLyBvcHRpb25hbGx5KS4gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYEZ1bmN0aW9uLmJpbmRgIGlmXG4gIC8vIGF2YWlsYWJsZS5cbiAgXy5iaW5kID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCkge1xuICAgIHZhciBhcmdzLCBib3VuZDtcbiAgICBpZiAobmF0aXZlQmluZCAmJiBmdW5jLmJpbmQgPT09IG5hdGl2ZUJpbmQpIHJldHVybiBuYXRpdmVCaW5kLmFwcGx5KGZ1bmMsIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgaWYgKCFfLmlzRnVuY3Rpb24oZnVuYykpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JpbmQgbXVzdCBiZSBjYWxsZWQgb24gYSBmdW5jdGlvbicpO1xuICAgIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgcmV0dXJuIGJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgYm91bmQpKSByZXR1cm4gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgIGN0b3IucHJvdG90eXBlID0gZnVuYy5wcm90b3R5cGU7XG4gICAgICB2YXIgc2VsZiA9IG5ldyBjdG9yO1xuICAgICAgY3Rvci5wcm90b3R5cGUgPSBudWxsO1xuICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkoc2VsZiwgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUGFydGlhbGx5IGFwcGx5IGEgZnVuY3Rpb24gYnkgY3JlYXRpbmcgYSB2ZXJzaW9uIHRoYXQgaGFzIGhhZCBzb21lIG9mIGl0c1xuICAvLyBhcmd1bWVudHMgcHJlLWZpbGxlZCwgd2l0aG91dCBjaGFuZ2luZyBpdHMgZHluYW1pYyBgdGhpc2AgY29udGV4dC4gXyBhY3RzXG4gIC8vIGFzIGEgcGxhY2Vob2xkZXIsIGFsbG93aW5nIGFueSBjb21iaW5hdGlvbiBvZiBhcmd1bWVudHMgdG8gYmUgcHJlLWZpbGxlZC5cbiAgXy5wYXJ0aWFsID0gZnVuY3Rpb24oZnVuYykge1xuICAgIHZhciBib3VuZEFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvc2l0aW9uID0gMDtcbiAgICAgIHZhciBhcmdzID0gYm91bmRBcmdzLnNsaWNlKCk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gYXJncy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYXJnc1tpXSA9PT0gXykgYXJnc1tpXSA9IGFyZ3VtZW50c1twb3NpdGlvbisrXTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChwb3NpdGlvbiA8IGFyZ3VtZW50cy5sZW5ndGgpIGFyZ3MucHVzaChhcmd1bWVudHNbcG9zaXRpb24rK10pO1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBCaW5kIGEgbnVtYmVyIG9mIGFuIG9iamVjdCdzIG1ldGhvZHMgdG8gdGhhdCBvYmplY3QuIFJlbWFpbmluZyBhcmd1bWVudHNcbiAgLy8gYXJlIHRoZSBtZXRob2QgbmFtZXMgdG8gYmUgYm91bmQuIFVzZWZ1bCBmb3IgZW5zdXJpbmcgdGhhdCBhbGwgY2FsbGJhY2tzXG4gIC8vIGRlZmluZWQgb24gYW4gb2JqZWN0IGJlbG9uZyB0byBpdC5cbiAgXy5iaW5kQWxsID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGZ1bmNzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGlmIChmdW5jcy5sZW5ndGggPT09IDApIHRocm93IG5ldyBFcnJvcignYmluZEFsbCBtdXN0IGJlIHBhc3NlZCBmdW5jdGlvbiBuYW1lcycpO1xuICAgIF8uZWFjaChmdW5jcywgZnVuY3Rpb24oZikgeyBvYmpbZl0gPSBfLmJpbmQob2JqW2ZdLCBvYmopOyB9KTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIE1lbW9pemUgYW4gZXhwZW5zaXZlIGZ1bmN0aW9uIGJ5IHN0b3JpbmcgaXRzIHJlc3VsdHMuXG4gIF8ubWVtb2l6ZSA9IGZ1bmN0aW9uKGZ1bmMsIGhhc2hlcikge1xuICAgIHZhciBtZW1vID0ge307XG4gICAgaGFzaGVyIHx8IChoYXNoZXIgPSBfLmlkZW50aXR5KTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIga2V5ID0gaGFzaGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gXy5oYXMobWVtbywga2V5KSA/IG1lbW9ba2V5XSA6IChtZW1vW2tleV0gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gRGVsYXlzIGEgZnVuY3Rpb24gZm9yIHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCBhbmQgdGhlbiBjYWxsc1xuICAvLyBpdCB3aXRoIHRoZSBhcmd1bWVudHMgc3VwcGxpZWQuXG4gIF8uZGVsYXkgPSBmdW5jdGlvbihmdW5jLCB3YWl0KSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKXsgcmV0dXJuIGZ1bmMuYXBwbHkobnVsbCwgYXJncyk7IH0sIHdhaXQpO1xuICB9O1xuXG4gIC8vIERlZmVycyBhIGZ1bmN0aW9uLCBzY2hlZHVsaW5nIGl0IHRvIHJ1biBhZnRlciB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhc1xuICAvLyBjbGVhcmVkLlxuICBfLmRlZmVyID0gZnVuY3Rpb24oZnVuYykge1xuICAgIHJldHVybiBfLmRlbGF5LmFwcGx5KF8sIFtmdW5jLCAxXS5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCB3aGVuIGludm9rZWQsIHdpbGwgb25seSBiZSB0cmlnZ2VyZWQgYXQgbW9zdCBvbmNlXG4gIC8vIGR1cmluZyBhIGdpdmVuIHdpbmRvdyBvZiB0aW1lLiBOb3JtYWxseSwgdGhlIHRocm90dGxlZCBmdW5jdGlvbiB3aWxsIHJ1blxuICAvLyBhcyBtdWNoIGFzIGl0IGNhbiwgd2l0aG91dCBldmVyIGdvaW5nIG1vcmUgdGhhbiBvbmNlIHBlciBgd2FpdGAgZHVyYXRpb247XG4gIC8vIGJ1dCBpZiB5b3UnZCBsaWtlIHRvIGRpc2FibGUgdGhlIGV4ZWN1dGlvbiBvbiB0aGUgbGVhZGluZyBlZGdlLCBwYXNzXG4gIC8vIGB7bGVhZGluZzogZmFsc2V9YC4gVG8gZGlzYWJsZSBleGVjdXRpb24gb24gdGhlIHRyYWlsaW5nIGVkZ2UsIGRpdHRvLlxuICBfLnRocm90dGxlID0gZnVuY3Rpb24oZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgIHZhciBjb250ZXh0LCBhcmdzLCByZXN1bHQ7XG4gICAgdmFyIHRpbWVvdXQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91cyA9IDA7XG4gICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBfLm5vdygpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5vdyA9IF8ubm93KCk7XG4gICAgICBpZiAoIXByZXZpb3VzICYmIG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UpIHByZXZpb3VzID0gbm93O1xuICAgICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAobm93IC0gcHJldmlvdXMpO1xuICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgaWYgKHJlbWFpbmluZyA8PSAwIHx8IHJlbWFpbmluZyA+IHdhaXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLCB3aWxsIG5vdFxuICAvLyBiZSB0cmlnZ2VyZWQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBpdCBzdG9wcyBiZWluZyBjYWxsZWQgZm9yXG4gIC8vIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxuICAvLyBsZWFkaW5nIGVkZ2UsIGluc3RlYWQgb2YgdGhlIHRyYWlsaW5nLlxuICBfLmRlYm91bmNlID0gZnVuY3Rpb24oZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gICAgdmFyIHRpbWVvdXQsIGFyZ3MsIGNvbnRleHQsIHRpbWVzdGFtcCwgcmVzdWx0O1xuXG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGFzdCA9IF8ubm93KCkgLSB0aW1lc3RhbXA7XG5cbiAgICAgIGlmIChsYXN0IDwgd2FpdCAmJiBsYXN0ID4gMCkge1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCAtIGxhc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIGlmICghaW1tZWRpYXRlKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdGltZXN0YW1wID0gXy5ub3coKTtcbiAgICAgIHZhciBjYWxsTm93ID0gaW1tZWRpYXRlICYmICF0aW1lb3V0O1xuICAgICAgaWYgKCF0aW1lb3V0KSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICAgIH1cbiAgICAgIGlmIChjYWxsTm93KSB7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYXQgbW9zdCBvbmUgdGltZSwgbm8gbWF0dGVyIGhvd1xuICAvLyBvZnRlbiB5b3UgY2FsbCBpdC4gVXNlZnVsIGZvciBsYXp5IGluaXRpYWxpemF0aW9uLlxuICBfLm9uY2UgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgdmFyIHJhbiA9IGZhbHNlLCBtZW1vO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChyYW4pIHJldHVybiBtZW1vO1xuICAgICAgcmFuID0gdHJ1ZTtcbiAgICAgIG1lbW8gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBmdW5jID0gbnVsbDtcbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3QgZnVuY3Rpb24gcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBzZWNvbmQsXG4gIC8vIGFsbG93aW5nIHlvdSB0byBhZGp1c3QgYXJndW1lbnRzLCBydW4gY29kZSBiZWZvcmUgYW5kIGFmdGVyLCBhbmRcbiAgLy8gY29uZGl0aW9uYWxseSBleGVjdXRlIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cbiAgXy53cmFwID0gZnVuY3Rpb24oZnVuYywgd3JhcHBlcikge1xuICAgIHJldHVybiBfLnBhcnRpYWwod3JhcHBlciwgZnVuYyk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIG5lZ2F0ZWQgdmVyc2lvbiBvZiB0aGUgcGFzc2VkLWluIHByZWRpY2F0ZS5cbiAgXy5uZWdhdGUgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIGEgbGlzdCBvZiBmdW5jdGlvbnMsIGVhY2hcbiAgLy8gY29uc3VtaW5nIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgZm9sbG93cy5cbiAgXy5jb21wb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZ1bmNzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgZm9yICh2YXIgaSA9IGZ1bmNzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGFyZ3MgPSBbZnVuY3NbaV0uYXBwbHkodGhpcywgYXJncyldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgYWZ0ZXIgYmVpbmcgY2FsbGVkIE4gdGltZXMuXG4gIF8uYWZ0ZXIgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzIDwgMSkge1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLy8gT2JqZWN0IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUmV0cmlldmUgdGhlIG5hbWVzIG9mIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBPYmplY3Qua2V5c2BcbiAgXy5rZXlzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBbXTtcbiAgICBpZiAobmF0aXZlS2V5cykgcmV0dXJuIG5hdGl2ZUtleXMob2JqKTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGlmIChfLmhhcyhvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICAgIHJldHVybiBrZXlzO1xuICB9O1xuXG4gIC8vIFJldHJpZXZlIHRoZSB2YWx1ZXMgb2YgYW4gb2JqZWN0J3MgcHJvcGVydGllcy5cbiAgXy52YWx1ZXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgdmFsdWVzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWVzW2ldID0gb2JqW2tleXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9O1xuXG4gIC8vIENvbnZlcnQgYW4gb2JqZWN0IGludG8gYSBsaXN0IG9mIGBba2V5LCB2YWx1ZV1gIHBhaXJzLlxuICBfLnBhaXJzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHBhaXJzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcGFpcnNbaV0gPSBba2V5c1tpXSwgb2JqW2tleXNbaV1dXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhaXJzO1xuICB9O1xuXG4gIC8vIEludmVydCB0aGUga2V5cyBhbmQgdmFsdWVzIG9mIGFuIG9iamVjdC4gVGhlIHZhbHVlcyBtdXN0IGJlIHNlcmlhbGl6YWJsZS5cbiAgXy5pbnZlcnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0W29ialtrZXlzW2ldXV0gPSBrZXlzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHNvcnRlZCBsaXN0IG9mIHRoZSBmdW5jdGlvbiBuYW1lcyBhdmFpbGFibGUgb24gdGhlIG9iamVjdC5cbiAgLy8gQWxpYXNlZCBhcyBgbWV0aG9kc2BcbiAgXy5mdW5jdGlvbnMgPSBfLm1ldGhvZHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9ialtrZXldKSkgbmFtZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXMuc29ydCgpO1xuICB9O1xuXG4gIC8vIEV4dGVuZCBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgcHJvcGVydGllcyBpbiBwYXNzZWQtaW4gb2JqZWN0KHMpLlxuICBfLmV4dGVuZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICAgIF8uZWFjaChzbGljZS5jYWxsKGFyZ3VtZW50cywgMSksIGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgb2JqW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IG9ubHkgY29udGFpbmluZyB0aGUgd2hpdGVsaXN0ZWQgcHJvcGVydGllcy5cbiAgXy5waWNrID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKGl0ZXJhdG9yKSkge1xuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGtleSwgb2JqKSkgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleXMgPSBjb25jYXQuYXBwbHkoW10sIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmopIHJlc3VsdFtrZXldID0gb2JqW2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCB3aXRob3V0IHRoZSBibGFja2xpc3RlZCBwcm9wZXJ0aWVzLlxuICBfLm9taXQgPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIGtleXM7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihpdGVyYXRvcikpIHtcbiAgICAgIGl0ZXJhdG9yID0gXy5uZWdhdGUoaXRlcmF0b3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzID0gXy5tYXAoY29uY2F0LmFwcGx5KFtdLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpLCBTdHJpbmcpO1xuICAgICAgaXRlcmF0b3IgPSBmdW5jdGlvbih2YWx1ZSwga2V5KSB7IHJldHVybiAhXy5jb250YWlucyhrZXlzLCBrZXkpOyB9O1xuICAgIH1cbiAgICByZXR1cm4gXy5waWNrKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIEZpbGwgaW4gYSBnaXZlbiBvYmplY3Qgd2l0aCBkZWZhdWx0IHByb3BlcnRpZXMuXG4gIF8uZGVmYXVsdHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIG9iajtcbiAgICBfLmVhY2goc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChvYmpbcHJvcF0gPT09IHZvaWQgMCkgb2JqW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgKHNoYWxsb3ctY2xvbmVkKSBkdXBsaWNhdGUgb2YgYW4gb2JqZWN0LlxuICBfLmNsb25lID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7XG4gICAgcmV0dXJuIF8uaXNBcnJheShvYmopID8gb2JqLnNsaWNlKCkgOiBfLmV4dGVuZCh7fSwgb2JqKTtcbiAgfTtcblxuICAvLyBJbnZva2VzIGludGVyY2VwdG9yIHdpdGggdGhlIG9iaiwgYW5kIHRoZW4gcmV0dXJucyBvYmouXG4gIC8vIFRoZSBwcmltYXJ5IHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gXCJ0YXAgaW50b1wiIGEgbWV0aG9kIGNoYWluLCBpblxuICAvLyBvcmRlciB0byBwZXJmb3JtIG9wZXJhdGlvbnMgb24gaW50ZXJtZWRpYXRlIHJlc3VsdHMgd2l0aGluIHRoZSBjaGFpbi5cbiAgXy50YXAgPSBmdW5jdGlvbihvYmosIGludGVyY2VwdG9yKSB7XG4gICAgaW50ZXJjZXB0b3Iob2JqKTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIEludGVybmFsIHJlY3Vyc2l2ZSBjb21wYXJpc29uIGZ1bmN0aW9uIGZvciBgaXNFcXVhbGAuXG4gIHZhciBlcSA9IGZ1bmN0aW9uKGEsIGIsIGFTdGFjaywgYlN0YWNrKSB7XG4gICAgLy8gSWRlbnRpY2FsIG9iamVjdHMgYXJlIGVxdWFsLiBgMCA9PT0gLTBgLCBidXQgdGhleSBhcmVuJ3QgaWRlbnRpY2FsLlxuICAgIC8vIFNlZSB0aGUgW0hhcm1vbnkgYGVnYWxgIHByb3Bvc2FsXShodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmVnYWwpLlxuICAgIGlmIChhID09PSBiKSByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PSAxIC8gYjtcbiAgICAvLyBBIHN0cmljdCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGBudWxsID09IHVuZGVmaW5lZGAuXG4gICAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBhID09PSBiO1xuICAgIC8vIFVud3JhcCBhbnkgd3JhcHBlZCBvYmplY3RzLlxuICAgIGlmIChhIGluc3RhbmNlb2YgXykgYSA9IGEuX3dyYXBwZWQ7XG4gICAgaWYgKGIgaW5zdGFuY2VvZiBfKSBiID0gYi5fd3JhcHBlZDtcbiAgICAvLyBDb21wYXJlIGBbW0NsYXNzXV1gIG5hbWVzLlxuICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKGEpO1xuICAgIGlmIChjbGFzc05hbWUgIT0gdG9TdHJpbmcuY2FsbChiKSkgcmV0dXJuIGZhbHNlO1xuICAgIHN3aXRjaCAoY2xhc3NOYW1lKSB7XG4gICAgICAvLyBTdHJpbmdzLCBudW1iZXJzLCBkYXRlcywgYW5kIGJvb2xlYW5zIGFyZSBjb21wYXJlZCBieSB2YWx1ZS5cbiAgICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nXSc6XG4gICAgICAgIC8vIFByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IHdyYXBwZXJzIGFyZSBlcXVpdmFsZW50OyB0aHVzLCBgXCI1XCJgIGlzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gYG5ldyBTdHJpbmcoXCI1XCIpYC5cbiAgICAgICAgcmV0dXJuIGEgPT0gU3RyaW5nKGIpO1xuICAgICAgY2FzZSAnW29iamVjdCBOdW1iZXJdJzpcbiAgICAgICAgLy8gYE5hTmBzIGFyZSBlcXVpdmFsZW50LCBidXQgbm9uLXJlZmxleGl2ZS4gQW4gYGVnYWxgIGNvbXBhcmlzb24gaXMgcGVyZm9ybWVkIGZvclxuICAgICAgICAvLyBvdGhlciBudW1lcmljIHZhbHVlcy5cbiAgICAgICAgcmV0dXJuIGEgIT0gK2EgPyBiICE9ICtiIDogKGEgPT0gMCA/IDEgLyBhID09IDEgLyBiIDogYSA9PSArYik7XG4gICAgICBjYXNlICdbb2JqZWN0IERhdGVdJzpcbiAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxuICAgICAgICAvLyBDb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWVyaWMgcHJpbWl0aXZlIHZhbHVlcy4gRGF0ZXMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyXG4gICAgICAgIC8vIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9ucy4gTm90ZSB0aGF0IGludmFsaWQgZGF0ZXMgd2l0aCBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnNcbiAgICAgICAgLy8gb2YgYE5hTmAgYXJlIG5vdCBlcXVpdmFsZW50LlxuICAgICAgICByZXR1cm4gK2EgPT0gK2I7XG4gICAgICAvLyBSZWdFeHBzIGFyZSBjb21wYXJlZCBieSB0aGVpciBzb3VyY2UgcGF0dGVybnMgYW5kIGZsYWdzLlxuICAgICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzpcbiAgICAgICAgcmV0dXJuIGEuc291cmNlID09IGIuc291cmNlICYmXG4gICAgICAgICAgICAgICBhLmdsb2JhbCA9PSBiLmdsb2JhbCAmJlxuICAgICAgICAgICAgICAgYS5tdWx0aWxpbmUgPT0gYi5tdWx0aWxpbmUgJiZcbiAgICAgICAgICAgICAgIGEuaWdub3JlQ2FzZSA9PSBiLmlnbm9yZUNhc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYSAhPSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuICAgIC8vIEFzc3VtZSBlcXVhbGl0eSBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWNcbiAgICAvLyBzdHJ1Y3R1cmVzIGlzIGFkYXB0ZWQgZnJvbSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLCBhYnN0cmFjdCBvcGVyYXRpb24gYEpPYC5cbiAgICB2YXIgbGVuZ3RoID0gYVN0YWNrLmxlbmd0aDtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIC8vIExpbmVhciBzZWFyY2guIFBlcmZvcm1hbmNlIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZlxuICAgICAgLy8gdW5pcXVlIG5lc3RlZCBzdHJ1Y3R1cmVzLlxuICAgICAgaWYgKGFTdGFja1tsZW5ndGhdID09IGEpIHJldHVybiBiU3RhY2tbbGVuZ3RoXSA9PSBiO1xuICAgIH1cbiAgICAvLyBPYmplY3RzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWl2YWxlbnQsIGJ1dCBgT2JqZWN0YHNcbiAgICAvLyBmcm9tIGRpZmZlcmVudCBmcmFtZXMgYXJlLlxuICAgIHZhciBhQ3RvciwgYUhhc0N0b3IsIGJDdG9yLCBiSGFzQ3RvcjtcblxuICAgIHRyeSB7XG4gICAgICBhQ3RvciA9IGEuY29uc3RydWN0b3I7XG4gICAgICBhSGFzQ3RvciA9ICdjb25zdHJ1Y3RvcicgaW4gYTtcbiAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgdHJ5IHtcbiAgICAgIGJDdG9yID0gYi5jb25zdHJ1Y3RvcjtcbiAgICAgIGJIYXNDdG9yID0gJ2NvbnN0cnVjdG9yJyBpbiBiO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICBpZiAoYUN0b3IgIT09IGJDdG9yICYmIGFIYXNDdG9yICYmIGJIYXNDdG9yICYmXG4gICAgICAhKF8uaXNGdW5jdGlvbihhQ3RvcikgJiYgKGFDdG9yIGluc3RhbmNlb2YgYUN0b3IpICYmXG4gICAgICAgIF8uaXNGdW5jdGlvbihiQ3RvcikgJiYgKGJDdG9yIGluc3RhbmNlb2YgYkN0b3IpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBBZGQgdGhlIGZpcnN0IG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgYVN0YWNrLnB1c2goYSk7XG4gICAgYlN0YWNrLnB1c2goYik7XG4gICAgdmFyIHNpemUgPSAwLCByZXN1bHQgPSB0cnVlO1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgIGlmIChjbGFzc05hbWUgPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgLy8gQ29tcGFyZSBhcnJheSBsZW5ndGhzIHRvIGRldGVybWluZSBpZiBhIGRlZXAgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkuXG4gICAgICBzaXplID0gYS5sZW5ndGg7XG4gICAgICByZXN1bHQgPSBzaXplID09IGIubGVuZ3RoO1xuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAvLyBEZWVwIGNvbXBhcmUgdGhlIGNvbnRlbnRzLCBpZ25vcmluZyBub24tbnVtZXJpYyBwcm9wZXJ0aWVzLlxuICAgICAgICB3aGlsZSAoc2l6ZS0tKSB7XG4gICAgICAgICAgaWYgKCEocmVzdWx0ID0gZXEoYVtzaXplXSwgYltzaXplXSwgYVN0YWNrLCBiU3RhY2spKSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHMuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gYSkge1xuICAgICAgICBpZiAoXy5oYXMoYSwga2V5KSkge1xuICAgICAgICAgIC8vIENvdW50IHRoZSBleHBlY3RlZCBudW1iZXIgb2YgcHJvcGVydGllcy5cbiAgICAgICAgICBzaXplKys7XG4gICAgICAgICAgLy8gRGVlcCBjb21wYXJlIGVhY2ggbWVtYmVyLlxuICAgICAgICAgIGlmICghKHJlc3VsdCA9IF8uaGFzKGIsIGtleSkgJiYgZXEoYVtrZXldLCBiW2tleV0sIGFTdGFjaywgYlN0YWNrKSkpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBFbnN1cmUgdGhhdCBib3RoIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllcy5cbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgZm9yIChrZXkgaW4gYikge1xuICAgICAgICAgIGlmIChfLmhhcyhiLCBrZXkpICYmICEoc2l6ZS0tKSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gIXNpemU7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFJlbW92ZSB0aGUgZmlyc3Qgb2JqZWN0IGZyb20gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIGFTdGFjay5wb3AoKTtcbiAgICBiU3RhY2sucG9wKCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBQZXJmb3JtIGEgZGVlcCBjb21wYXJpc29uIHRvIGNoZWNrIGlmIHR3byBvYmplY3RzIGFyZSBlcXVhbC5cbiAgXy5pc0VxdWFsID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBlcShhLCBiLCBbXSwgW10pO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gYXJyYXksIHN0cmluZywgb3Igb2JqZWN0IGVtcHR5P1xuICAvLyBBbiBcImVtcHR5XCIgb2JqZWN0IGhhcyBubyBlbnVtZXJhYmxlIG93bi1wcm9wZXJ0aWVzLlxuICBfLmlzRW1wdHkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB0cnVlO1xuICAgIGlmIChfLmlzQXJyYXkob2JqKSB8fCBfLmlzU3RyaW5nKG9iaikgfHwgXy5pc0FyZ3VtZW50cyhvYmopKSByZXR1cm4gb2JqLmxlbmd0aCA9PT0gMDtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAoXy5oYXMob2JqLCBrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIERPTSBlbGVtZW50P1xuICBfLmlzRWxlbWVudCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiAhIShvYmogJiYgb2JqLm5vZGVUeXBlID09PSAxKTtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGFuIGFycmF5P1xuICAvLyBEZWxlZ2F0ZXMgdG8gRUNNQTUncyBuYXRpdmUgQXJyYXkuaXNBcnJheVxuICBfLmlzQXJyYXkgPSBuYXRpdmVJc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIGFuIG9iamVjdD9cbiAgXy5pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IE9iamVjdChvYmopO1xuICB9O1xuXG4gIC8vIEFkZCBzb21lIGlzVHlwZSBtZXRob2RzOiBpc0FyZ3VtZW50cywgaXNGdW5jdGlvbiwgaXNTdHJpbmcsIGlzTnVtYmVyLCBpc0RhdGUsIGlzUmVnRXhwLlxuICBfLmVhY2goWydBcmd1bWVudHMnLCAnRnVuY3Rpb24nLCAnU3RyaW5nJywgJ051bWJlcicsICdEYXRlJywgJ1JlZ0V4cCddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgX1snaXMnICsgbmFtZV0gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgJyArIG5hbWUgKyAnXSc7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gRGVmaW5lIGEgZmFsbGJhY2sgdmVyc2lvbiBvZiB0aGUgbWV0aG9kIGluIGJyb3dzZXJzIChhaGVtLCBJRSksIHdoZXJlXG4gIC8vIHRoZXJlIGlzbid0IGFueSBpbnNwZWN0YWJsZSBcIkFyZ3VtZW50c1wiIHR5cGUuXG4gIGlmICghXy5pc0FyZ3VtZW50cyhhcmd1bWVudHMpKSB7XG4gICAgXy5pc0FyZ3VtZW50cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuICEhKG9iaiAmJiBfLmhhcyhvYmosICdjYWxsZWUnKSk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIE9wdGltaXplIGBpc0Z1bmN0aW9uYCBpZiBhcHByb3ByaWF0ZS5cbiAgaWYgKHR5cGVvZiAoLy4vKSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIF8uaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbic7XG4gICAgfTtcbiAgfVxuXG4gIC8vIElzIGEgZ2l2ZW4gb2JqZWN0IGEgZmluaXRlIG51bWJlcj9cbiAgXy5pc0Zpbml0ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBpc0Zpbml0ZShvYmopICYmICFpc05hTihwYXJzZUZsb2F0KG9iaikpO1xuICB9O1xuXG4gIC8vIElzIHRoZSBnaXZlbiB2YWx1ZSBgTmFOYD8gKE5hTiBpcyB0aGUgb25seSBudW1iZXIgd2hpY2ggZG9lcyBub3QgZXF1YWwgaXRzZWxmKS5cbiAgXy5pc05hTiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBfLmlzTnVtYmVyKG9iaikgJiYgb2JqICE9ICtvYmo7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIGJvb2xlYW4/XG4gIF8uaXNCb29sZWFuID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdHJ1ZSB8fCBvYmogPT09IGZhbHNlIHx8IHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBCb29sZWFuXSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBlcXVhbCB0byBudWxsP1xuICBfLmlzTnVsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IG51bGw7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSB1bmRlZmluZWQ/XG4gIF8uaXNVbmRlZmluZWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB2b2lkIDA7XG4gIH07XG5cbiAgLy8gU2hvcnRjdXQgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBwcm9wZXJ0eSBkaXJlY3RseVxuICAvLyBvbiBpdHNlbGYgKGluIG90aGVyIHdvcmRzLCBub3Qgb24gYSBwcm90b3R5cGUpLlxuICBfLmhhcyA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xuICB9O1xuXG4gIC8vIFV0aWxpdHkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUnVuIFVuZGVyc2NvcmUuanMgaW4gKm5vQ29uZmxpY3QqIG1vZGUsIHJldHVybmluZyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0c1xuICAvLyBwcmV2aW91cyBvd25lci4gUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJvb3QuXyA9IHByZXZpb3VzVW5kZXJzY29yZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBLZWVwIHRoZSBpZGVudGl0eSBmdW5jdGlvbiBhcm91bmQgZm9yIGRlZmF1bHQgaXRlcmF0b3JzLlxuICBfLmlkZW50aXR5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgXy5jb25zdGFudCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gIH07XG5cbiAgXy5ub29wID0gZnVuY3Rpb24oKXt9O1xuXG4gIF8ucHJvcGVydHkgPSBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgcHJlZGljYXRlIGZvciBjaGVja2luZyB3aGV0aGVyIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBzZXQgb2YgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8ubWF0Y2hlcyA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gXy5pc0VtcHR5KGF0dHJzKTtcbiAgICAgIGlmIChvYmogPT09IGF0dHJzKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBhdHRycykgaWYgKGF0dHJzW2tleV0gIT09IG9ialtrZXldKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUnVuIGEgZnVuY3Rpb24gKipuKiogdGltZXMuXG4gIF8udGltZXMgPSBmdW5jdGlvbihuLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIHZhciBhY2N1bSA9IEFycmF5KE1hdGgubWF4KDAsIG4pKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykgYWNjdW1baV0gPSBpdGVyYXRvci5jYWxsKGNvbnRleHQsIGkpO1xuICAgIHJldHVybiBhY2N1bTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIG1pbiBhbmQgbWF4IChpbmNsdXNpdmUpLlxuICBfLnJhbmRvbSA9IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgaWYgKG1heCA9PSBudWxsKSB7XG4gICAgICBtYXggPSBtaW47XG4gICAgICBtaW4gPSAwO1xuICAgIH1cbiAgICByZXR1cm4gbWluICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKTtcbiAgfTtcblxuICAvLyBBIChwb3NzaWJseSBmYXN0ZXIpIHdheSB0byBnZXQgdGhlIGN1cnJlbnQgdGltZXN0YW1wIGFzIGFuIGludGVnZXIuXG4gIF8ubm93ID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTsgfTtcblxuICAvLyBMaXN0IG9mIEhUTUwgZW50aXRpZXMgZm9yIGVzY2FwaW5nLlxuICB2YXIgZW50aXR5TWFwID0ge1xuICAgIGVzY2FwZToge1xuICAgICAgJyYnOiAnJmFtcDsnLFxuICAgICAgJzwnOiAnJmx0OycsXG4gICAgICAnPic6ICcmZ3Q7JyxcbiAgICAgICdcIic6ICcmcXVvdDsnLFxuICAgICAgXCInXCI6ICcmI3gyNzsnXG4gICAgfVxuICB9O1xuICBlbnRpdHlNYXAudW5lc2NhcGUgPSBfLmludmVydChlbnRpdHlNYXAuZXNjYXBlKTtcblxuICAvLyBSZWdleGVzIGNvbnRhaW5pbmcgdGhlIGtleXMgYW5kIHZhbHVlcyBsaXN0ZWQgaW1tZWRpYXRlbHkgYWJvdmUuXG4gIHZhciBlbnRpdHlSZWdleGVzID0ge1xuICAgIGVzY2FwZTogICBuZXcgUmVnRXhwKCdbJyArIF8ua2V5cyhlbnRpdHlNYXAuZXNjYXBlKS5qb2luKCcnKSArICddJywgJ2cnKSxcbiAgICB1bmVzY2FwZTogbmV3IFJlZ0V4cCgnKCcgKyBfLmtleXMoZW50aXR5TWFwLnVuZXNjYXBlKS5qb2luKCd8JykgKyAnKScsICdnJylcbiAgfTtcblxuICAvLyBGdW5jdGlvbnMgZm9yIGVzY2FwaW5nIGFuZCB1bmVzY2FwaW5nIHN0cmluZ3MgdG8vZnJvbSBIVE1MIGludGVycG9sYXRpb24uXG4gIF8uZWFjaChbJ2VzY2FwZScsICd1bmVzY2FwZSddLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgICBfW21ldGhvZF0gPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIGlmIChzdHJpbmcgPT0gbnVsbCkgcmV0dXJuICcnO1xuICAgICAgcmV0dXJuICgnJyArIHN0cmluZykucmVwbGFjZShlbnRpdHlSZWdleGVzW21ldGhvZF0sIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICAgIHJldHVybiBlbnRpdHlNYXBbbWV0aG9kXVttYXRjaF07XG4gICAgICB9KTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBJZiB0aGUgdmFsdWUgb2YgdGhlIG5hbWVkIGBwcm9wZXJ0eWAgaXMgYSBmdW5jdGlvbiB0aGVuIGludm9rZSBpdCB3aXRoIHRoZVxuICAvLyBgb2JqZWN0YCBhcyBjb250ZXh0OyBvdGhlcndpc2UsIHJldHVybiBpdC5cbiAgXy5yZXN1bHQgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIHZhciB2YWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgcmV0dXJuIF8uaXNGdW5jdGlvbih2YWx1ZSkgPyBvYmplY3RbcHJvcGVydHldKCkgOiB2YWx1ZTtcbiAgfTtcblxuICAvLyBBZGQgeW91ciBvd24gY3VzdG9tIGZ1bmN0aW9ucyB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubWl4aW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICBfLmVhY2goXy5mdW5jdGlvbnMob2JqKSwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBfW25hbWVdID0gb2JqW25hbWVdO1xuICAgICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbdGhpcy5fd3JhcHBlZF07XG4gICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5jYWxsKHRoaXMsIGZ1bmMuYXBwbHkoXywgYXJncykpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBpbnRlZ2VyIGlkICh1bmlxdWUgd2l0aGluIHRoZSBlbnRpcmUgY2xpZW50IHNlc3Npb24pLlxuICAvLyBVc2VmdWwgZm9yIHRlbXBvcmFyeSBET00gaWRzLlxuICB2YXIgaWRDb3VudGVyID0gMDtcbiAgXy51bmlxdWVJZCA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIHZhciBpZCA9ICsraWRDb3VudGVyICsgJyc7XG4gICAgcmV0dXJuIHByZWZpeCA/IHByZWZpeCArIGlkIDogaWQ7XG4gIH07XG5cbiAgLy8gQnkgZGVmYXVsdCwgVW5kZXJzY29yZSB1c2VzIEVSQi1zdHlsZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLCBjaGFuZ2UgdGhlXG4gIC8vIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAgXy50ZW1wbGF0ZVNldHRpbmdzID0ge1xuICAgIGV2YWx1YXRlICAgIDogLzwlKFtcXHNcXFNdKz8pJT4vZyxcbiAgICBpbnRlcnBvbGF0ZSA6IC88JT0oW1xcc1xcU10rPyklPi9nLFxuICAgIGVzY2FwZSAgICAgIDogLzwlLShbXFxzXFxTXSs/KSU+L2dcbiAgfTtcblxuICAvLyBXaGVuIGN1c3RvbWl6aW5nIGB0ZW1wbGF0ZVNldHRpbmdzYCwgaWYgeW91IGRvbid0IHdhbnQgdG8gZGVmaW5lIGFuXG4gIC8vIGludGVycG9sYXRpb24sIGV2YWx1YXRpb24gb3IgZXNjYXBpbmcgcmVnZXgsIHdlIG5lZWQgb25lIHRoYXQgaXNcbiAgLy8gZ3VhcmFudGVlZCBub3QgdG8gbWF0Y2guXG4gIHZhciBub01hdGNoID0gLyguKV4vO1xuXG4gIC8vIENlcnRhaW4gY2hhcmFjdGVycyBuZWVkIHRvIGJlIGVzY2FwZWQgc28gdGhhdCB0aGV5IGNhbiBiZSBwdXQgaW50byBhXG4gIC8vIHN0cmluZyBsaXRlcmFsLlxuICB2YXIgZXNjYXBlcyA9IHtcbiAgICBcIidcIjogICAgICBcIidcIixcbiAgICAnXFxcXCc6ICAgICAnXFxcXCcsXG4gICAgJ1xccic6ICAgICAncicsXG4gICAgJ1xcbic6ICAgICAnbicsXG4gICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAgICdcXHUyMDI5JzogJ3UyMDI5J1xuICB9O1xuXG4gIHZhciBlc2NhcGVyID0gL1xcXFx8J3xcXHJ8XFxufFxcdTIwMjh8XFx1MjAyOS9nO1xuXG4gIHZhciBlc2NhcGVDaGFyID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gJ1xcXFwnICsgZXNjYXBlc1ttYXRjaF07XG4gIH07XG5cbiAgLy8gSmF2YVNjcmlwdCBtaWNyby10ZW1wbGF0aW5nLCBzaW1pbGFyIHRvIEpvaG4gUmVzaWcncyBpbXBsZW1lbnRhdGlvbi5cbiAgLy8gVW5kZXJzY29yZSB0ZW1wbGF0aW5nIGhhbmRsZXMgYXJiaXRyYXJ5IGRlbGltaXRlcnMsIHByZXNlcnZlcyB3aGl0ZXNwYWNlLFxuICAvLyBhbmQgY29ycmVjdGx5IGVzY2FwZXMgcXVvdGVzIHdpdGhpbiBpbnRlcnBvbGF0ZWQgY29kZS5cbiAgXy50ZW1wbGF0ZSA9IGZ1bmN0aW9uKHRleHQsIGRhdGEsIHNldHRpbmdzKSB7XG4gICAgc2V0dGluZ3MgPSBfLmRlZmF1bHRzKHt9LCBzZXR0aW5ncywgXy50ZW1wbGF0ZVNldHRpbmdzKTtcblxuICAgIC8vIENvbWJpbmUgZGVsaW1pdGVycyBpbnRvIG9uZSByZWd1bGFyIGV4cHJlc3Npb24gdmlhIGFsdGVybmF0aW9uLlxuICAgIHZhciBtYXRjaGVyID0gbmV3IFJlZ0V4cChbXG4gICAgICAoc2V0dGluZ3MuZXNjYXBlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAgIChzZXR0aW5ncy5pbnRlcnBvbGF0ZSB8fCBub01hdGNoKS5zb3VyY2UsXG4gICAgICAoc2V0dGluZ3MuZXZhbHVhdGUgfHwgbm9NYXRjaCkuc291cmNlXG4gICAgXS5qb2luKCd8JykgKyAnfCQnLCAnZycpO1xuXG4gICAgLy8gQ29tcGlsZSB0aGUgdGVtcGxhdGUgc291cmNlLCBlc2NhcGluZyBzdHJpbmcgbGl0ZXJhbHMgYXBwcm9wcmlhdGVseS5cbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBzb3VyY2UgPSBcIl9fcCs9J1wiO1xuICAgIHRleHQucmVwbGFjZShtYXRjaGVyLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlLCBpbnRlcnBvbGF0ZSwgZXZhbHVhdGUsIG9mZnNldCkge1xuICAgICAgc291cmNlICs9IHRleHQuc2xpY2UoaW5kZXgsIG9mZnNldCkucmVwbGFjZShlc2NhcGVyLCBlc2NhcGVDaGFyKTtcbiAgICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgICBpZiAoZXNjYXBlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIicrXFxuKChfX3Q9KFwiICsgZXNjYXBlICsgXCIpKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcXG4nXCI7XG4gICAgICB9IGVsc2UgaWYgKGludGVycG9sYXRlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIicrXFxuKChfX3Q9KFwiICsgaW50ZXJwb2xhdGUgKyBcIikpPT1udWxsPycnOl9fdCkrXFxuJ1wiO1xuICAgICAgfSBlbHNlIGlmIChldmFsdWF0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGUgKyBcIlxcbl9fcCs9J1wiO1xuICAgICAgfVxuXG4gICAgICAvLyBBZG9iZSBWTXMgbmVlZCB0aGUgbWF0Y2ggcmV0dXJuZWQgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBvZmZlc3QuXG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG4gICAgc291cmNlICs9IFwiJztcXG5cIjtcblxuICAgIC8vIElmIGEgdmFyaWFibGUgaXMgbm90IHNwZWNpZmllZCwgcGxhY2UgZGF0YSB2YWx1ZXMgaW4gbG9jYWwgc2NvcGUuXG4gICAgaWYgKCFzZXR0aW5ncy52YXJpYWJsZSkgc291cmNlID0gJ3dpdGgob2JqfHx7fSl7XFxuJyArIHNvdXJjZSArICd9XFxuJztcblxuICAgIHNvdXJjZSA9IFwidmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLFwiICtcbiAgICAgIFwicHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcXG5cIiArXG4gICAgICBzb3VyY2UgKyBcInJldHVybiBfX3A7XFxuXCI7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIHJlbmRlciA9IG5ldyBGdW5jdGlvbihzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJywgJ18nLCBzb3VyY2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGUuc291cmNlID0gc291cmNlO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YSkgcmV0dXJuIHJlbmRlcihkYXRhLCBfKTtcbiAgICB2YXIgdGVtcGxhdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gcmVuZGVyLmNhbGwodGhpcywgZGF0YSwgXyk7XG4gICAgfTtcblxuICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIHNvdXJjZSBhcyBhIGNvbnZlbmllbmNlIGZvciBwcmVjb21waWxhdGlvbi5cbiAgICB2YXIgYXJndW1lbnQgPSBzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJztcbiAgICB0ZW1wbGF0ZS5zb3VyY2UgPSAnZnVuY3Rpb24oJyArIGFyZ3VtZW50ICsgJyl7XFxuJyArIHNvdXJjZSArICd9JztcblxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfTtcblxuICAvLyBBZGQgYSBcImNoYWluXCIgZnVuY3Rpb24sIHdoaWNoIHdpbGwgZGVsZWdhdGUgdG8gdGhlIHdyYXBwZXIuXG4gIF8uY2hhaW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gXyhvYmopLmNoYWluKCk7XG4gIH07XG5cbiAgLy8gT09QXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuICAvLyBJZiBVbmRlcnNjb3JlIGlzIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLCBpdCByZXR1cm5zIGEgd3JhcHBlZCBvYmplY3QgdGhhdFxuICAvLyBjYW4gYmUgdXNlZCBPTy1zdHlsZS4gVGhpcyB3cmFwcGVyIGhvbGRzIGFsdGVyZWQgdmVyc2lvbnMgb2YgYWxsIHRoZVxuICAvLyB1bmRlcnNjb3JlIGZ1bmN0aW9ucy4gV3JhcHBlZCBvYmplY3RzIG1heSBiZSBjaGFpbmVkLlxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjb250aW51ZSBjaGFpbmluZyBpbnRlcm1lZGlhdGUgcmVzdWx0cy5cbiAgdmFyIHJlc3VsdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0aGlzLl9jaGFpbiA/IF8ob2JqKS5jaGFpbigpIDogb2JqO1xuICB9O1xuXG4gIC8vIEFkZCBhbGwgb2YgdGhlIFVuZGVyc2NvcmUgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgXy5taXhpbihfKTtcblxuICAvLyBBZGQgYWxsIG11dGF0b3IgQXJyYXkgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxuICBfLmVhY2goWydwb3AnLCAncHVzaCcsICdyZXZlcnNlJywgJ3NoaWZ0JywgJ3NvcnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb2JqID0gdGhpcy5fd3JhcHBlZDtcbiAgICAgIG1ldGhvZC5hcHBseShvYmosIGFyZ3VtZW50cyk7XG4gICAgICBpZiAoKG5hbWUgPT0gJ3NoaWZ0JyB8fCBuYW1lID09ICdzcGxpY2UnKSAmJiBvYmoubGVuZ3RoID09PSAwKSBkZWxldGUgb2JqWzBdO1xuICAgICAgcmV0dXJuIHJlc3VsdC5jYWxsKHRoaXMsIG9iaik7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gQWRkIGFsbCBhY2Nlc3NvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIF8uZWFjaChbJ2NvbmNhdCcsICdqb2luJywgJ3NsaWNlJ10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgbWV0aG9kID0gQXJyYXlQcm90b1tuYW1lXTtcbiAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJlc3VsdC5jYWxsKHRoaXMsIG1ldGhvZC5hcHBseSh0aGlzLl93cmFwcGVkLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KTtcblxuICBfLmV4dGVuZChfLnByb3RvdHlwZSwge1xuXG4gICAgLy8gU3RhcnQgY2hhaW5pbmcgYSB3cmFwcGVkIFVuZGVyc2NvcmUgb2JqZWN0LlxuICAgIGNoYWluOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2NoYWluID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBFeHRyYWN0cyB0aGUgcmVzdWx0IGZyb20gYSB3cmFwcGVkIGFuZCBjaGFpbmVkIG9iamVjdC5cbiAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd3JhcHBlZDtcbiAgICB9XG5cbiAgfSk7XG5cbiAgLy8gQU1EIHJlZ2lzdHJhdGlvbiBoYXBwZW5zIGF0IHRoZSBlbmQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBBTUQgbG9hZGVyc1xuICAvLyB0aGF0IG1heSBub3QgZW5mb3JjZSBuZXh0LXR1cm4gc2VtYW50aWNzIG9uIG1vZHVsZXMuIEV2ZW4gdGhvdWdoIGdlbmVyYWxcbiAgLy8gcHJhY3RpY2UgZm9yIEFNRCByZWdpc3RyYXRpb24gaXMgdG8gYmUgYW5vbnltb3VzLCB1bmRlcnNjb3JlIHJlZ2lzdGVyc1xuICAvLyBhcyBhIG5hbWVkIG1vZHVsZSBiZWNhdXNlLCBsaWtlIGpRdWVyeSwgaXQgaXMgYSBiYXNlIGxpYnJhcnkgdGhhdCBpc1xuICAvLyBwb3B1bGFyIGVub3VnaCB0byBiZSBidW5kbGVkIGluIGEgdGhpcmQgcGFydHkgbGliLCBidXQgbm90IGJlIHBhcnQgb2ZcbiAgLy8gYW4gQU1EIGxvYWQgcmVxdWVzdC4gVGhvc2UgY2FzZXMgY291bGQgZ2VuZXJhdGUgYW4gZXJyb3Igd2hlbiBhblxuICAvLyBhbm9ueW1vdXMgZGVmaW5lKCkgaXMgY2FsbGVkIG91dHNpZGUgb2YgYSBsb2FkZXIgcmVxdWVzdC5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZSgndW5kZXJzY29yZScsIFtdLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG59KS5jYWxsKHRoaXMpO1xuIiwicmVxdWlyZSgnLi9vdmVyZmxvdy1zY3JvbGwnKTtcbiIsInZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG5cbi8qKlxuICogU2Nyb2xsIGFuIGVsZW1lbnQgdmVydGljYWxseSBiYXNlZCBvbiBhIHdoZWVsIGV2ZW50IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gIGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYmxvY2tcbiAqL1xudmFyIHNjcm9sbFZlcnRpY2FsID0gZnVuY3Rpb24gKGUsIGVsLCBibG9jaykge1xuICBpZiAoIWJsb2NrKSB7XG4gICAgLy8gSGFzbid0IHNjcm9sbGVkIHVwIG9yIGRvd24uXG4gICAgaWYgKGUuZGVsdGFZID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQXR0ZW1wdGluZyB0byBzY3JvbGwgdXAuXG4gICAgaWYgKGUuZGVsdGFZIDwgMCAmJiBlbC5zY3JvbGxUb3AgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBBdHRlbXB0aW5nIHRvIHNjcm9sbCBkb3duLlxuICAgIGlmIChlLmRlbHRhWSA+IDAgJiYgZWwuc2Nyb2xsVG9wID09PSBlbC5zY3JvbGxIZWlnaHQgLSBlbC5jbGllbnRIZWlnaHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIGVsLnNjcm9sbFRvcCArPSBlLmRlbHRhWTtcbn07XG5cbi8qKlxuICogU2Nyb2xsIGFuIGVsZW1lbnQgaG9yaXpvbnRhbGx5IGJhc2VkIG9uIGEgd2hlZWwgZXZlbnQgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSAgZVxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtCb29sZWFufSBibG9ja1xuICovXG52YXIgc2Nyb2xsSG9yaXpvbnRhbCA9IGZ1bmN0aW9uIChlLCBlbCwgYmxvY2spIHtcbiAgaWYgKCFibG9jaykge1xuICAgIC8vIEhhc24ndCBzY3JvbGxlZCBsZWZ0IG9yIHJpZ2h0LlxuICAgIGlmIChlLmRlbHRhWCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEF0dGVtcHRpbmcgdG8gc2Nyb2xsIGxlZnQuXG4gICAgaWYgKGUuZGVsdGFYIDwgMCAmJiBlbC5zY3JvbGxMZWZ0ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQXR0ZW1wdGluZyB0byBzY3JvbGwgcmlnaHQuXG4gICAgaWYgKGUuZGVsdGFYID4gMCAmJiBlbC5zY3JvbGxMZWZ0ID09PSBlbC5zY3JvbGxXaWR0aCAtIGVsLmNsaWVudFdpZHRoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICBlbC5zY3JvbGxMZWZ0ICs9IGUuZGVsdGFYO1xufTtcblxuLyoqXG4gKiBCaW5kIHRvIHRoZSBlbnRpcmUgZG9jdW1lbnQgYW5kIGp1c3QgbGlzdGVuIGZvciBhIGRhdGEgYXR0cmlidXRlLlxuICovXG5CYWNrYm9uZS4kKGRvY3VtZW50KVxuICAub24oJ3doZWVsJywgJ1tkYXRhLW92ZXJmbG93LXNjcm9sbF0nLCBmdW5jdGlvbiAoZSwgZWwpIHtcbiAgICB2YXIgYmxvY2sgPSAhIWVsLmdldEF0dHJpYnV0ZSgnZGF0YS1vdmVyZmxvdy1zY3JvbGwnKTtcblxuICAgIHNjcm9sbFZlcnRpY2FsKGUsIGVsLCBibG9jayk7XG4gICAgc2Nyb2xsSG9yaXpvbnRhbChlLCBlbCwgYmxvY2spO1xuICB9KTtcbiIsIi8vIFNoaW0gQmFja2JvbmUgd2l0aCB0aGUgZnVuY3Rpb25hbGl0eSBmcm9tIEJhY2tib25lLm5hdGl2ZVxudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbkJhY2tib25lLiQgICA9IHJlcXVpcmUoJ2JhY2tib25lLm5hdGl2ZScpO1xuXG4vLyBFUzYgRmVhdHVyZSBTaGltLlxucmVxdWlyZSgnZXM2LWNvbGxlY3Rpb25zJyk7XG5cbi8vIFJlcXVpcmUgYWxsIENvZGVNaXJyb3IgZnVuY3Rpb25hbGl0eS5cbnJlcXVpcmUoJ2NvZGVtaXJyb3IvYWRkb24vbW9kZS9vdmVybGF5Jyk7XG5yZXF1aXJlKCdjb2RlbWlycm9yL2FkZG9uL2NvbW1lbnQvY29tbWVudCcpO1xucmVxdWlyZSgnY29kZW1pcnJvci9tb2RlL2dmbS9nZm0nKTtcbnJlcXVpcmUoJ2NvZGVtaXJyb3IvbW9kZS9tYXJrZG93bi9tYXJrZG93bicpO1xucmVxdWlyZSgnY29kZW1pcnJvci9tb2RlL2Nzcy9jc3MnKTtcbnJlcXVpcmUoJ2NvZGVtaXJyb3IvbW9kZS94bWwveG1sJyk7XG5yZXF1aXJlKCdjb2RlbWlycm9yL21vZGUvY2xpa2UvY2xpa2UnKTtcbnJlcXVpcmUoJ2NvZGVtaXJyb3IvbW9kZS9odG1sbWl4ZWQvaHRtbG1peGVkJyk7XG5yZXF1aXJlKCdjb2RlbWlycm9yL21vZGUvamF2YXNjcmlwdC9qYXZhc2NyaXB0Jyk7XG5cbi8vIEJvb3RzdHJhcCBjb3JlIGZ1bmN0aW9uYWxpdHkuXG5yZXF1aXJlKCcuL2RvbScpO1xucmVxdWlyZSgnLi9wbHVnaW5zJyk7XG4iLCJ2YXIgXyAgICAgICAgICA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBtaWRkbGV3YXJlID0gcmVxdWlyZSgnLi4vLi4vc3RhdGUvbWlkZGxld2FyZScpO1xuXG52YXIgQUpBWF9USU1FT1VUID0gMjAwMDA7XG5cbi8qKlxuICogU2VuZCBhbiBhamF4IHJlcXVlc3QgYW5kIHJldHVybiB0aGUgeGhyIHJlcXVlc3QgYmFjayB0byB0aGUgZmluYWwgbGlzdGVuZXIuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSAgIG9wdGlvbnNcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBuZXh0XG4gKi9cbm1pZGRsZXdhcmUucmVnaXN0ZXIoJ2FqYXgnLCBmdW5jdGlvbiAob3B0aW9ucywgbmV4dCkge1xuICB2YXIgdXJsICAgICA9IG9wdGlvbnMudXJsO1xuICB2YXIgbWV0aG9kICA9IG9wdGlvbnMubWV0aG9kIHx8ICdHRVQnO1xuICB2YXIgeGhyICAgICA9IG9wdGlvbnMueGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gIHZhciBhc3luYyAgID0gb3B0aW9ucy5hc3luYyAhPT0gZmFsc2U7XG4gIHZhciB0aW1lb3V0ID0gK29wdGlvbnMudGltZW91dCB8fCBBSkFYX1RJTUVPVVQ7XG4gIHZhciBhamF4VGltZW91dDtcblxuICAvKipcbiAgICogV3JhcHMgY2FsbGJhY2sgZnVuY3Rpb25zIHRvIHJlbW92ZSB4aHIgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGZuXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKi9cbiAgdmFyIGNvbXBsZXRlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoYWpheFRpbWVvdXQpO1xuXG4gICAgICAvLyBSZW1vdmUgcmVmZXJlbmNlcyB0byB1bnVzZWQgZnVuY3Rpb25zLlxuICAgICAgeGhyLm9ubG9hZCA9IHhoci5vbmVycm9yID0geGhyLm9uYWJvcnQgPSBudWxsO1xuXG4gICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIHhoci5vcGVuKG1ldGhvZCwgdXJsLCBhc3luYyk7XG5cbiAgLy8gU2V0cyBhbGwgcmVxdWVzdCBoZWFkZXJzIGJlZm9yZSB3ZSBtYWtlIHRoZSByZXF1ZXN0LlxuICBfLmVhY2gob3B0aW9ucy5oZWFkZXJzLCBmdW5jdGlvbiAodmFsdWUsIGhlYWRlcikge1xuICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlciwgdmFsdWUpO1xuICB9KTtcblxuICAvLyBFbmFibGUgaG9va2luZyBpbnRvIHRoZSBhamF4IHJlcXVlc3QgYmVmb3JlIHdlIHNlbmQgaXQuXG4gIGlmIChvcHRpb25zLmJlZm9yZVNlbmQpIHtcbiAgICBvcHRpb25zLmJlZm9yZVNlbmQoeGhyKTtcbiAgfVxuXG4gIC8vIFN1Y2Nlc3NmdWwgY2FsbGJhY2suXG4gIHhoci5vbmxvYWQgPSBjb21wbGV0ZShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5leHQobnVsbCwgeGhyKTtcbiAgfSk7XG5cbiAgLy8gRmFpbHVyZSBjYWxsYmFjay5cbiAgeGhyLm9uZXJyb3IgPSB4aHIub25hYm9ydCA9IGNvbXBsZXRlKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV4dChuZXcgRXJyb3IoeGhyLnN0YXR1c1RleHQgfHwgJ0FqYXggcmVxdWVzdCBhYm9ydGVkJyksIHhocik7XG4gIH0pO1xuXG4gIC8vIFNldCBhIHJlcXVlc3QgdGltZW91dC4gTW9kZXJuIGJyb3dzZXJzIGNhbiBzZXQgYSBgdGltZW91dGAgcHJvcGVydHlcbiAgLy8gd2hpY2ggd29ya3MgdGhlIHNhbWUsIGJ1dCB3ZSdsbCB1c2UgYSB0aW1lb3V0IGZvciBjb25zaXN0ZW5jeS5cbiAgaWYgKGFzeW5jKSB7XG4gICAgYWpheFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChjb21wbGV0ZShmdW5jdGlvbiAoKSB7XG4gICAgICB4aHIuYWJvcnQoKTtcblxuICAgICAgLy8gQ2FsbHMgdGhlIGBuZXh0YCBmdW5jdGlvbiB3aXRoIHRoZSB0aW1lb3V0IGRldGFpbHMuXG4gICAgICByZXR1cm4gbmV4dChcbiAgICAgICAgbmV3IEVycm9yKCdBamF4IHRpbWVvdXQgb2YgJyArIHRpbWVvdXQgKyAnbXMgZXhjZWVkZWQnKSwgeGhyXG4gICAgICApO1xuICAgIH0pLCB0aW1lb3V0KTtcbiAgfVxuXG4gIHhoci5zZW5kKG9wdGlvbnMuZGF0YSk7XG59KTtcbiIsIi8qIGdsb2JhbCBBcHAgKi9cbnZhciBfICAgICAgICAgICA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBhc3luYyAgICAgICA9IHJlcXVpcmUoJ2FzeW5jJyk7XG52YXIgbG9hZFNjcmlwdCAgPSByZXF1aXJlKCcuLi8uLi9saWIvYnJvd3Nlci9sb2FkLXNjcmlwdCcpO1xudmFyIHN0YXRlICAgICAgID0gcmVxdWlyZSgnLi4vLi4vc3RhdGUvc3RhdGUnKTtcbnZhciBjb25maWcgICAgICA9IHJlcXVpcmUoJy4uLy4uL3N0YXRlL2NvbmZpZycpO1xudmFyIG1lc3NhZ2VzICAgID0gcmVxdWlyZSgnLi4vLi4vc3RhdGUvbWVzc2FnZXMnKTtcbnZhciBtaWRkbGV3YXJlICA9IHJlcXVpcmUoJy4uLy4uL3N0YXRlL21pZGRsZXdhcmUnKTtcbnZhciBQb3N0TWVzc2FnZSA9IHJlcXVpcmUoJy4uLy4uL2xpYi9wb3N0LW1lc3NhZ2UnKTtcblxuLyoqXG4gKiBBbGlhcyBhbnkgb3B0aW9uYWwgZ2xvYmFsIHZhcmlhYmxlcyBwYXNzZWQgaW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9ICAgb3B0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gbmV4dFxuICovXG5taWRkbGV3YXJlLnJlZ2lzdGVyKCdhcHBsaWNhdGlvbjpzdGFydCcsIGZ1bmN0aW9uIChvcHRpb25zLCBuZXh0KSB7XG4gIF8uZWFjaChvcHRpb25zLmFsaWFzIHx8IHt9LCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgIHdpbmRvd1trZXldID0gdmFsdWU7XG4gIH0pO1xuXG4gIHJldHVybiBuZXh0KCk7XG59KTtcblxuLyoqXG4gKiBFeGVjdXRlIGFyYml0cmFyeSBwYXNzZWQgaW4gc2NyaXB0cy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gICBvcHRpb25zXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0XG4gKi9cbm1pZGRsZXdhcmUucmVnaXN0ZXIoJ2FwcGxpY2F0aW9uOnN0YXJ0JywgZnVuY3Rpb24gKG9wdGlvbnMsIG5leHQpIHtcbiAgdHJ5IHtcbiAgICAvKiBqc2hpbnQgZXZpbDogdHJ1ZSAqL1xuICAgIHdpbmRvdy5ldmFsKG9wdGlvbnMuZXhlYyB8fCAnJyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbmV4dChlKTtcbiAgfVxuXG4gIHJldHVybiBuZXh0KCk7XG59KTtcblxuLyoqXG4gKiBMb2FkIGFsbCBpbmplY3RlZCBzY3JpcHQgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gICBvcHRpb25zXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0XG4gKi9cbm1pZGRsZXdhcmUucmVnaXN0ZXIoJ2FwcGxpY2F0aW9uOnN0YXJ0JywgZnVuY3Rpb24gKG9wdGlvbnMsIG5leHQpIHtcbiAgcmV0dXJuIGFzeW5jLmVhY2gob3B0aW9ucy5pbmplY3QgfHwgW10sIGxvYWRTY3JpcHQsIG5leHQpO1xufSk7XG5cbi8qKlxuICogVXBkYXRlIHRoZSBjb25maWcgb2JqZWN0IHdpdGggdGhlIG9wdGlvbmFsIHBhc3NlZCBpbiBjb25maWcuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9ICAgb3B0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gbmV4dFxuICovXG5taWRkbGV3YXJlLnJlZ2lzdGVyKCdhcHBsaWNhdGlvbjpzdGFydCcsIGZ1bmN0aW9uIChvcHRpb25zLCBuZXh0KSB7XG4gIG1pZGRsZXdhcmUudHJpZ2dlcihcbiAgICAnYXBwbGljYXRpb246Y29uZmlnJyxcbiAgICBfLmV4dGVuZCh7fSwgb3B0aW9ucy5jb25maWcpLFxuICAgIGZ1bmN0aW9uIChlcnIsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIG5leHQoZXJyKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IGNlcnRhaW4gcHJvcGVydGllcyBiZWZvcmUgb3RoZXJzIHRvIGF2b2lkIG9yZGVyaW5nIGlzc3Vlcy5cbiAgICAgIGNvbmZpZy5zZXQoJ2VtYmVkZGVkJywgICAgICAgISFvcHRpb25zLmVtYmVkZGVkKTtcbiAgICAgIGNvbmZpZy5zZXQoJ2F1dGhlbnRpY2F0aW9uJywgb3B0aW9ucy5hdXRoZW50aWNhdGlvbiAhPT0gZmFsc2UpO1xuICAgICAgY29uZmlnLnNldChfLm9taXQob3B0aW9ucywgWydlbWJlZGRlZCcsICdhdXRoZW50aWNhdGlvbiddKSk7XG5cbiAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgfVxuICApO1xufSk7XG5cbi8qKlxuICogVGhlIGZpcnN0IG1pZGRsZXdhcmUgZm9yIGFwcGxpY2F0aW9uIHN0YXJ0IGhhcyB0byBiZSB0aGUgcGFyZW50IGZyYW1lIHNldCB1cC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gICBvcHRpb25zXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0XG4gKi9cbm1pZGRsZXdhcmUucmVnaXN0ZXIoJ2FwcGxpY2F0aW9uOnN0YXJ0JywgZnVuY3Rpb24gKG9wdGlvbnMsIG5leHQpIHtcbiAgLy8gU2tpcCBtaWRkbGV3YXJlIGV4ZWN1dGlvbiBpZiB3ZSBhcmUgdGhlIHBhcmVudCBmcmFtZS5cbiAgaWYgKHdpbmRvdyA9PT0gd2luZG93LnBhcmVudCkgeyByZXR1cm4gbmV4dCgpOyB9XG5cbiAgdmFyIHBvc3RNZXNzYWdlID0gQXBwLnBvc3RNZXNzYWdlID0gbmV3IFBvc3RNZXNzYWdlKHdpbmRvdy5wYXJlbnQpO1xuXG4gIC8qKlxuICAgKiBMaXN0ZW4gZm9yIGNoYW5nZXMgaW4gdGhlIGRvY3VtZW50IGhlaWdodCBhbmQgcmVzaXplIHRoZSBwYXJlbnQgZnJhbWUuXG4gICAqL1xuICBzdGF0ZS5vbignY2hhbmdlOmRvY3VtZW50SGVpZ2h0JywgZnVuY3Rpb24gKF8sIGhlaWdodCkge1xuICAgIHBvc3RNZXNzYWdlLnRyaWdnZXIoJ2hlaWdodCcsIGhlaWdodCk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBMaXN0ZW4gZm9yIGFueSBjaGFuZ2VzIHRvIHRoZSBjb25maWd1cmF0aW9uIHVybCBhbmQgdXBkYXRlIHRoZSBiYXNlXG4gICAqIGVsZW1lbnQuIFRoaXMgaXMgcmVxdWlyZWQgZm9yIGNvcnJlY3RseSBvcGVuaW5nIGxpbmtzIGluIHRoZSBwYXJlbnQgZnJhbWUuXG4gICAqL1xuICBwb3N0TWVzc2FnZS5saXN0ZW5Ubyhjb25maWcsICdjaGFuZ2U6dXJsJywgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGVhZEVsID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICAgIHZhciBiYXNlRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYmFzZScpWzBdO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChfLCB1cmwpIHtcbiAgICAgIGlmIChiYXNlRWwpIHsgYmFzZUVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYmFzZUVsKTsgfVxuXG4gICAgICBiYXNlRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdiYXNlJyk7XG4gICAgICBiYXNlRWwuc2V0QXR0cmlidXRlKCdocmVmJywgICB1cmwpO1xuICAgICAgYmFzZUVsLnNldEF0dHJpYnV0ZSgndGFyZ2V0JywgJ19wYXJlbnQnKTtcbiAgICAgIGhlYWRFbC5hcHBlbmRDaGlsZChiYXNlRWwpO1xuICAgIH07XG4gIH0pKCkpO1xuXG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gdGhlIHBhcmVudCBmcmFtZSB0byBiZSByZWFkeSBhbmQgcGFzcyBpdHMgY29uZmlnIG9wdGlvbnMuXG4gICAqL1xuICBwb3N0TWVzc2FnZS5vbigncmVhZHknLCBmdW5jdGlvbiAocGFyZW50T3B0aW9ucykge1xuICAgIF8uZXh0ZW5kKG9wdGlvbnMsIHBhcmVudE9wdGlvbnMpO1xuICAgIHJldHVybiBuZXh0KCk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSdW4gYXJiaXRyYXJ5IGNvZGUgaW5zaWRlIHRoZSBmcmFtZSBieSBwYXNzZWQgYW4gZXZpbCBzdHJpbmcgaW4uXG4gICAqL1xuICBwb3N0TWVzc2FnZS5vbignZXhlYycsIGZ1bmN0aW9uIChldmlsKSB7XG4gICAgLyoganNoaW50IGV2aWw6IHRydWUgKi9cbiAgICBwb3N0TWVzc2FnZS50cmlnZ2VyKCdleGVjJywgd2luZG93LmV2YWwoZXZpbCkpO1xuICB9KTtcblxuICAvKipcbiAgICogTGlzdGVuIHRvIGFueSBjb25maWd1cmF0aW9uIGNoYW5nZXMuXG4gICAqL1xuICBwb3N0TWVzc2FnZS5vbignY29uZmlnJywgZnVuY3Rpb24gKCkge1xuICAgIGNvbmZpZy5zZXQuYXBwbHkoY29uZmlnLCBhcmd1bWVudHMpO1xuICB9KTtcblxuICAvKipcbiAgICogVHJpZ2dlciBjcm9zcy1mcmFtZSBtZXNzYWdlcyBlYXNpbHkuXG4gICAqL1xuICBwb3N0TWVzc2FnZS5vbignbWVzc2FnZScsIGZ1bmN0aW9uICgpIHtcbiAgICBtZXNzYWdlcy50cmlnZ2VyLmFwcGx5KG1lc3NhZ2VzLCBhcmd1bWVudHMpO1xuICB9KTtcblxuICAvKipcbiAgICogVHJpZ2dlciBjaGFuZ2VzIG9uIHRoZSBjb25maWcgb2JqZWN0IHRvIHRoZSBwYXJlbnQgZnJhbWUuIFRoaXMgaXNcbiAgICogaW5jcmVkaWJseSB1c2VmdWwgZm9yIGhlbHBpbmcgdGhlIHBhcmVudCBmcmFtZSB3aXRoIGludGVncmF0aW9uLlxuICAgKi9cbiAgcG9zdE1lc3NhZ2UubGlzdGVuVG8oY29uZmlnLCAnYWxsJywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAobmFtZS5zdWJzdHIoMCwgNykgIT09ICdjaGFuZ2U6JykgeyByZXR1cm47IH1cblxuICAgIHZhciBvcHRpb24gPSBuYW1lLnN1YnN0cig3KTtcbiAgICBwb3N0TWVzc2FnZS50cmlnZ2VyKCdjb25maWcnLCBvcHRpb24sIGNvbmZpZy5nZXQob3B0aW9uKSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIGEgcmVhZHkgZXZlbnQgdG8gdGhlIHBhcmVudCBmcmFtZS4gVGhpcyBhbGxvd3MgdGhlIGZyYW1lIHRvIG5vd1xuICAgKiBzZW5kIGFsbCBpdHMgY29uZmlnIG9wdGlvbnMgd2l0aG91dCByaXNrIG9mIGxvc2luZyBkYXRhLlxuICAgKi9cbiAgcG9zdE1lc3NhZ2UudHJpZ2dlcigncmVhZHknKTtcbn0pO1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGJyb3dzZXIgc3VwcG9ydHMgY29yZSBKYXZhU2NyaXB0IEVTNSBBUElzIG5lZWRlZCBmb3IgdGhlXG4gKiBub3RlYm9vayB0byBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gICBhcHBcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHRcbiAqL1xubWlkZGxld2FyZS5yZWdpc3RlcignYXBwbGljYXRpb246c3RhcnQnLCBmdW5jdGlvbiAoYXBwLCBuZXh0KSB7XG4gIGlmIChcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyAmJlxuICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yXG4gICkge1xuICAgIHJldHVybiBuZXh0KCk7XG4gIH1cblxuICBtaWRkbGV3YXJlLnRyaWdnZXIoJ3VpOm1vZGFsJywge1xuICAgIHRpdGxlOiAnVW5zdXBwb3J0ZWQgQnJvd3NlcicsXG4gICAgY29udGVudDogJzxwPllvdXIgYnJvd3NlciBpcyBvdXQgb2YgZGF0ZS4gUGxlYXNlIGNvbnNpZGVyIHVwZ3JhZGluZyB0byAnICtcbiAgICAgICdnZXQgdGhlIGZ1bGwgZXhwZXJpZW5jZSBvZiB0aGlzIGFwcGxpY2F0aW9uLiA8YSB0YXJnZXQ9XCJfYmxhbmtcIiAnICtcbiAgICAgICdocmVmPVwiaHR0cDovL2Jyb3dzZWhhcHB5LmNvbS9cIj5Zb3UgY2FuIGZpbmQgYSBsaXN0IG9mIHVwLXRvLWRhdGUgJyArXG4gICAgICAnYnJvd3NlcnMgaGVyZS48L2E+PC9wPjxkaXYgY2xhc3M9XCJ0ZXh0LWNlbnRlclwiPicgK1xuICAgICAgJzxidXR0b24gY2xhc3M9XCJidG4gYnRuLXByaW1hcnlcIiBkYXRhLWRpc21pc3M+Q2xvc2U8L2J1dHRvbj48L2Rpdj4nXG4gIH0sIG5leHQpO1xufSk7XG4iLCIoZnVuY3Rpb24gKEJ1ZmZlcil7XG52YXIgXyAgICAgICAgICA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBtaWRkbGV3YXJlID0gcmVxdWlyZSgnLi4vLi4vLi4vc3RhdGUvbWlkZGxld2FyZScpO1xuXG4vKipcbiAqIEF1dGhlbnRpY2F0ZSB1c2luZyBiYXNpYyBhdXRoLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSAgIG9wdGlvbnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAqL1xubWlkZGxld2FyZS5yZWdpc3RlcignYXV0aGVudGljYXRlJywgZnVuY3Rpb24gKG9wdGlvbnMsIG5leHQsIGRvbmUpIHtcbiAgaWYgKG9wdGlvbnMudHlwZSAhPT0gJ0Jhc2ljIEF1dGhlbnRpY2F0aW9uJykge1xuICAgIHJldHVybiBuZXh0KCk7XG4gIH1cblxuICBpZiAoIV8uaXNTdHJpbmcob3B0aW9ucy51c2VybmFtZSkgfHwgIV8uaXNTdHJpbmcob3B0aW9ucy5wYXNzd29yZCkpIHtcbiAgICByZXR1cm4gbmV4dChuZXcgVHlwZUVycm9yKCdVc2VybmFtZSBhbmQgcGFzc3dvcmQgbXVzdCBiZSBkZWZpbmVkJykpO1xuICB9XG5cbiAgcmV0dXJuIGRvbmUobnVsbCwgXy5waWNrKG9wdGlvbnMsICd1c2VybmFtZScsICdwYXNzd29yZCcpKTtcbn0pO1xuXG4vKipcbiAqIFRyaWdnZXIgYW4gYWpheCByZXF1ZXN0IHVzaW5nIGJhc2ljIGF1dGggY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSAgIGRhdGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHRcbiAqL1xubWlkZGxld2FyZS5yZWdpc3RlcignYWpheDpiYXNpY0F1dGgnLCBmdW5jdGlvbiAoZGF0YSwgbmV4dCkge1xuICAvLyBDaGVjayB3ZSBoYXZlIGEgYmFzaWMgYXV0aCBvYmplY3QgYmVmb3JlIG1peGluZyBpbiBvdXIgY3JlZGVudGlhbHMuXG4gIGlmIChfLmlzT2JqZWN0KGRhdGEuYmFzaWNBdXRoKSkge1xuICAgIGRhdGEuaGVhZGVycyA9IF8uZXh0ZW5kKHtcbiAgICAgICdBdXRob3JpemF0aW9uJzogJ0Jhc2ljICcgKyBuZXcgQnVmZmVyKFxuICAgICAgICBkYXRhLmJhc2ljQXV0aC51c2VybmFtZSArICc6JyArIGRhdGEuYmFzaWNBdXRoLnBhc3N3b3JkXG4gICAgICApLnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgIH0sIGRhdGEuaGVhZGVycyk7XG4gIH1cblxuICByZXR1cm4gbWlkZGxld2FyZS50cmlnZ2VyKCdhamF4JywgZGF0YSwgbmV4dCk7XG59KTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKSIsInJlcXVpcmUoJy4vYmFzaWMnKTtcbnJlcXVpcmUoJy4vb2F1dGgxJyk7XG5yZXF1aXJlKCcuL29hdXRoMicpO1xuIiwidmFyIF8gICAgICAgICAgPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgICA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgbWlkZGxld2FyZSA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL3N0YXRlL21pZGRsZXdhcmUnKTtcblxuLyoqXG4gKiBLZWVwIHRyYWNrIG9mIG9wZW4gcG9wdXAgd2luZG93cyBzbyB3ZSBvbmx5IGhhdmUgb25lIG9wZW4gYXQgYSB0aW1lLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBvcGVuUG9wdXAsIG9wZW5Nb2RhbCwgY2xvc2VJbnRlcnZhbDtcblxuLyoqXG4gKiBDbG9zZXMgcHJldmlvdXNseSBvcGVuZWQgd2luZG93cyBhbmQgbW9kYWxzLlxuICovXG52YXIgY2xvc2VBbGwgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChvcGVuUG9wdXApIHsgb3BlblBvcHVwLmNsb3NlKCk7IH1cbiAgaWYgKG9wZW5Nb2RhbCkgeyBvcGVuTW9kYWwuY2xvc2UoKTsgfVxuXG4gIG9wZW5Qb3B1cCA9IG51bGw7XG4gIG9wZW5Nb2RhbCA9IG51bGw7XG5cbiAgd2luZG93LmNsZWFySW50ZXJ2YWwoY2xvc2VJbnRlcnZhbCk7XG59O1xuXG4vKipcbiAqIFBvcCBvcGVuIGFuIGF1dGhlbnRpY2F0aW9uIHdpbmRvdy4gSXQgYWRkcyBzb21lIGFkZGl0aW9uYWwgc2FmZSBndWFyZHMgc3VjaFxuICogYXMgY2F0Y2hpbmcgYmxvY2tlZCBwb3B1cCB3aW5kb3dzLCBsaXN0ZW5pbmcgZm9yIHdpbmRvdyBjbG9zZXMsIHNpbXBsaWZpZWRcbiAqIHdpbmRvdyBwb3NpdGlvbmluZywgZXRjLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gRXhlY3V0ZSBgY2xvc2VgIHdoZW4gdGhlIHdpbmRvdyBpcyBzYWZlIHRvIGNsZWFyZWQuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucywgY2IpIHtcbiAgdmFyIHdpZHRoICAgICA9IE1hdGgubWluKDcyMCwgd2luZG93LnNjcmVlbi5hdmFpbFdpZHRoKTtcbiAgdmFyIGhlaWdodCAgICA9IE1hdGgubWluKDQ4MCwgd2luZG93LnNjcmVlbi5hdmFpbEhlaWdodCk7XG4gIHZhciB0b3AgICAgICAgPSBNYXRoLm1pbigxMDAsICh3aW5kb3cuc2NyZWVuLmF2YWlsSGVpZ2h0IC0gaGVpZ2h0KSAvIDIpO1xuICB2YXIgbGVmdCAgICAgID0gKHdpbmRvdy5zY3JlZW4uYXZhaWxXaWR0aCAtIHdpZHRoKSAvIDI7XG4gIHZhciBjb21wbGV0ZWQgPSBmYWxzZTtcblxuICAvKipcbiAgICogQ2xvc2UgYWxsIHRoZSBvcGVuIG1vZGFscyBhbmQgcG9wdXBzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtFcnJvcn0gICAgZXJyXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKi9cbiAgdmFyIGRvbmUgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgY2xvc2VBbGwoKTtcbiAgICByZXR1cm4gY2IoZXJyKTtcbiAgfTtcblxuICAvLyBDbG9zZSBwcmV2aW91c2x5IG9wZW4gcG9wdXAgd2luZG93cyBhbmQgbW9kYWxzLlxuICBjbG9zZUFsbCgpO1xuXG4gIHZhciBtb2RhbE9wdGlvbnMgPSBfLmV4dGVuZCh7XG4gICAgdGl0bGU6ICdSZXF1ZXN0IEFQSSBQZXJtaXNzaW9uJyxcbiAgICBjb250ZW50OiBbXG4gICAgICAnPHA+JyxcbiAgICAgICdQbGVhc2UgZ3JhbnQgYWNjZXNzIHRvIHRoaXMgYXBwbGljYXRpb24gdG8gbWFrZSBhbiBBUEkgcmVxdWVzdC4nLFxuICAgICAgJzwvcD4nLFxuICAgICAgJzxwPicsXG4gICAgICAnQ2xpY2sgdGhlIFwiQXV0aGVudGljYXRlXCIgYnV0dG9uIHRvIGFwcHJvdmUgdGhlIHVzZSBvZiB5b3VyIGNyZWRlbnRpYWxzLicsXG4gICAgICAnWW91IGNhbiByZXZva2UgdGhlc2UgcGVybWlzc2lvbnMgYXQgYW55IHRpbWUuJyxcbiAgICAgICc8L3A+JyxcbiAgICBdLmpvaW4oJ1xcbicpLFxuICAgIGJ0blRleHQ6ICdBdXRoZW50aWNhdGUnLFxuICAgIHNob3c6IGZ1bmN0aW9uIChtb2RhbCkge1xuICAgICAgb3Blbk1vZGFsID0gbW9kYWw7XG5cbiAgICAgIC8vIE9wZW4gYSBwb3B1cCB3aW5kb3cgd2hlbiB0aGUgYXV0aGVudGljYXRpb24gYnV0dG9uIGlzIHByZXNzZWQuXG4gICAgICBCYWNrYm9uZS4kKG1vZGFsLmVsKS5vbignY2xpY2snLCAnW2RhdGEtYXV0aGVudGljYXRlXScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb3BlblBvcHVwID0gd2luZG93Lm9wZW4oXG4gICAgICAgICAgdXJsLCAnJywgW1xuICAgICAgICAgICAgJ3RvcD0nICsgdG9wLFxuICAgICAgICAgICAgJ2xlZnQ9JyArIGxlZnQsXG4gICAgICAgICAgICAnd2lkdGg9JyArIHdpZHRoLFxuICAgICAgICAgICAgJ2hlaWdodD0nICsgaGVpZ2h0LFxuICAgICAgICAgICAgJ3Njcm9sbGJhcnM9MSdcbiAgICAgICAgICBdLmpvaW4oJywnKVxuICAgICAgICApO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb3BlblBvcHVwICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIG9wZW5Qb3B1cCA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIGRvbmUobmV3IEVycm9yKCdQb3B1cCB3aW5kb3cgYmxvY2tlZCcpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhdGNoIHdpbmRvdyBjbG9zZXMgYmVmb3JlIGF1dGhlbnRpY2F0aW9uIGlzIGNvbXBsZXRlLlxuICAgICAgICBjbG9zZUludGVydmFsID0gd2luZG93LnNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAob3BlblBvcHVwLmNsb3NlZCkge1xuICAgICAgICAgICAgb3BlblBvcHVwID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBkb25lKG5ldyBFcnJvcignUG9wdXAgd2luZG93IGNsb3NlZCcpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDQwMCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIG9wdGlvbnMubW9kYWwpO1xuXG5cbiAgbW9kYWxPcHRpb25zLmNvbnRlbnQgKz0gW1xuICAgICc8ZGl2IGNsYXNzPVwidGV4dC1jZW50ZXJcIj4nLFxuICAgICc8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1wcmltYXJ5XCIgZGF0YS1hdXRoZW50aWNhdGU+JyxcbiAgICBtb2RhbE9wdGlvbnMuYnRuVGV4dCxcbiAgICAnPC9idXR0b24+JyxcbiAgICAnPC9kaXY+J1xuICBdLmpvaW4oJ1xcbicpO1xuXG4gIG1pZGRsZXdhcmUudHJpZ2dlcigndWk6bW9kYWwnLCBtb2RhbE9wdGlvbnMsIGZ1bmN0aW9uICgpIHtcbiAgICBvcGVuTW9kYWwgPSBudWxsO1xuICAgIHJldHVybiAhY29tcGxldGVkICYmIGRvbmUobmV3IEVycm9yKCdNb2RhbCBjbG9zZWQgd2l0aG91dCBhdXRoZW50aWNhdGluZycpKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgLy8gU2V0IGNvbXBsZXRlZCB0byB0cnVlIHNvIHdlIHdvbid0IGNhdXNlIGFuIGVycm9yIGNhbGxiYWNrLlxuICAgICAgY29tcGxldGVkID0gdHJ1ZTtcblxuICAgICAgLy8gUmVtb3ZlIGFueSByZWZlcmVuY2VzIHRvIG9wZW4gbW9kYWxzIGFuZCB3aW5kb3dzLlxuICAgICAgcmV0dXJuIGNsb3NlQWxsKCk7XG4gICAgfVxuICB9O1xufTtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qIGdsb2JhbCBBcHAgKi9cbnZhciBfICAgICAgICAgICA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBxcyAgICAgICAgICA9IHJlcXVpcmUoJ3FzJyk7XG52YXIgdXJsICAgICAgICAgPSByZXF1aXJlKCd1cmwnKTtcbnZhciBjcnlwdG8gICAgICA9IHJlcXVpcmUoJ2NyeXB0bycpO1xudmFyIGF1dGhXaW5kb3cgID0gcmVxdWlyZSgnLi9saWIvYXV0aC13aW5kb3cnKTtcbnZhciBtaWRkbGV3YXJlICA9IHJlcXVpcmUoJy4uLy4uLy4uL3N0YXRlL21pZGRsZXdhcmUnKTtcblxuLyoqXG4gKiBTZXQgdGhlIGRlZmF1bHQgcmVkaXJlY3Rpb24gdXJsLlxuICpcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKi9cbnZhciBSRURJUkVDVF9VUkkgPSB1cmwucmVzb2x2ZShcbiAgZ2xvYmFsLmxvY2F0aW9uLmhyZWYsIHtcInVybFwiOlwiaHR0cHM6Ly9tdWxlc29mdC5naXRodWIuaW8vYXBpLW5vdGVib29rL1wiLFwidGl0bGVcIjpcIkFQSSBOb3RlYm9va1wiLFwib2F1dGhDYWxsYmFja1wiOlwiL2F1dGhlbnRpY2F0ZS9vYXV0aC5odG1sXCJ9Lm9hdXRoQ2FsbGJhY2tcbik7XG5cbi8qKlxuICogU2ltcGxlIGNvbnN0YW50IGZvciB0aGUgdXJsIGVuY29kZWQgY29udGVudCB0eXBlLlxuICpcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKi9cbnZhciBVUkxfRU5DT0RFRCA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuXG4vKipcbiAqIERlZmF1bHQgcG9ydHMgb2YgZGlmZmVyZW50IHByb3RvY29scy5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgZGVmYXVsdFBvcnRzID0ge1xuICAnaHR0cDonOiAgJzgwJyxcbiAgJ2h0dHBzOic6ICc0NDMnXG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgY3VycmVudCB0aW1lc3RhbXAgaW4gc2Vjb25kcyBzaW5jZSBKYW51YXJ5IDEsIDE5NzAgMDA6MDA6MDAgR01ULlxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xudmFyIGdldFRpbWVzdGFtcCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xufTtcblxuLyoqXG4gKiBFbmNvZGUgYSBzdHJpbmcgYWNjb3JkaW5nIHRvIFJGQzM5ODYuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xudmFyIGVuY29kZURhdGEgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIGlmIChzdHIgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyKVxuICAgIC5yZXBsYWNlKC9cXCcvZywgJyUyNycpXG4gICAgLnJlcGxhY2UoL1xcKC9nLCAnJTI4JylcbiAgICAucmVwbGFjZSgvXFwpL2csICclMjknKVxuICAgIC5yZXBsYWNlKC9cXCovZywgJyUyQScpXG4gICAgLnJlcGxhY2UoL1xcIS9nLCAnJTIxJyk7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgdXJsIGZvciBpbmNsdWRpbmcgd2l0aCB0aGUgaGFzaGVkIHNpZ25hdHVyZS5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHVyaVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG52YXIgbm9ybWFsaXplVXJsID0gZnVuY3Rpb24gKHVyaSkge1xuICB2YXIgcG9ydCA9ICcnO1xuXG4gIGlmICh1cmkucG9ydCAmJiBkZWZhdWx0UG9ydHNbdXJpLnByb3RvY29sXSAhPT0gdXJpLnBvcnQpIHtcbiAgICBwb3J0ID0gJzonICsgdXJpLnBvcnQ7XG4gIH1cblxuICByZXR1cm4gdXJpLnByb3RvY29sICsgJy8vJyArIHVyaS5ob3N0bmFtZSArIHBvcnQgKyB1cmkucGF0aG5hbWU7XG59O1xuXG4vKipcbiAqIFNvcnQgcXVlcnkgc3RyaW5nIHBhcmFtZXRlcnMgKHJlcHJlc2VudGVkIGFzIGFuIGFycmF5IG9mIGFycmF5cykgYnkgbmFtZSBhbmRcbiAqIHRoZW4gdmFsdWUuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9IGFyZ1BhaXJzXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xudmFyIHNvcnRSZXF1ZXN0UGFyYW1zID0gZnVuY3Rpb24gKGFyZ1BhaXJzKSB7XG4gIHJldHVybiBhcmdQYWlycy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgaWYgKGFbMF0gPT09IGJbMF0pIHtcbiAgICAgIHJldHVybiBhWzFdIDwgYlsxXSA/IC0xIDogMTtcbiAgICB9XG5cbiAgICByZXR1cm4gYVswXSA8IGJbMF0gPyAtMSA6IDE7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gb2JqZWN0IG9mIGtleSwgdmFsdWUgcGFpcnMgdG8gYW4gYXJyYXkgb2YgYXJyYXlzLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xudmFyIHBhcmFtc1RvQXJyYXkgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBfLnBhaXJzKG9iaik7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhbiBhcnJheSBvZiBwYXJhbWV0ZXJzIChpbiBuZXN0ZWQgYXJyYXkgZm9ybSkgdG8gYSBxdWVyeSBzdHJpbmcuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9ICBhcnJheVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG52YXIgYXJyYXlUb1BhcmFtcyA9IGZ1bmN0aW9uIChhcnJheSkge1xuICByZXR1cm4gXy5tYXAoYXJyYXksIGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgcmV0dXJuIGVuY29kZURhdGEoYXJnc1swXSkgKyAnPScgKyBlbmNvZGVEYXRhKGFyZ3NbMV0pO1xuICB9KS5qb2luKCcmJyk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSB0aGUgYmFzZSBzaWduYXR1cmUgc3RyaW5nIGZvciBoYXNoaW5nLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gZGF0YVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG52YXIgY3JlYXRlU2lnbmF0dXJlQmFzZSA9IGZ1bmN0aW9uIChwYXJhbXMsIGRhdGEpIHtcbiAgcmV0dXJuIFtcbiAgICBkYXRhLm1ldGhvZC50b1VwcGVyQ2FzZSgpLFxuICAgIGVuY29kZURhdGEobm9ybWFsaXplVXJsKGRhdGEudXJsKSksXG4gICAgZW5jb2RlRGF0YShhcnJheVRvUGFyYW1zKHBhcmFtcykpXG4gIF0uam9pbignJicpO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHNpZ25hdHVyZSBzdHJpbmcgY29tYmluaW5nIHRoZSBiYXNlIHNpZ25hdHVyZSB3aXRoIGNvbnN1bWVyXG4gKiBzZWNyZXRzLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gYmFzZVxuICogQHBhcmFtICB7T2JqZWN0fSBkYXRhXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbnZhciBjcmVhdGVTaWduYXR1cmUgPSBmdW5jdGlvbiAoYmFzZSwgb3B0aW9ucykge1xuICB2YXIga2V5ID0gW1xuICAgIGVuY29kZURhdGEob3B0aW9ucy5jb25zdW1lclNlY3JldCksIGVuY29kZURhdGEob3B0aW9ucy5vYXV0aFRva2VuU2VjcmV0KVxuICBdLmpvaW4oJyYnKTtcblxuICB2YXIgaGFzaCA9IGtleTtcblxuICBpZiAob3B0aW9ucy5zaWduYXR1cmVNZXRob2QgPT09ICdITUFDLVNIQTEnKSB7XG4gICAgaGFzaCA9IGNyeXB0by5jcmVhdGVIbWFjKCdzaGExJywga2V5KS51cGRhdGUoYmFzZSkuZGlnZXN0KCdiYXNlNjQnKTtcbiAgfVxuXG4gIHJldHVybiBoYXNoO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHNpZ25hdHVyZSBmcm9tIHRoZSBBSkFYIGRhdGEuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9ICBwYXJhbXNcbiAqIEBwYXJhbSAge09iamVjdH0gZGF0YVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG52YXIgZ2V0U2lnbmF0dXJlID0gZnVuY3Rpb24gKHBhcmFtcywgZGF0YSkge1xuICB2YXIgc2lnbmF0dXJlQmFzZSA9IGNyZWF0ZVNpZ25hdHVyZUJhc2UocGFyYW1zLCBkYXRhKTtcbiAgcmV0dXJuIGNyZWF0ZVNpZ25hdHVyZShzaWduYXR1cmVCYXNlLCBkYXRhLm9hdXRoMSk7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgcmFuZG9tIG5vbmNlIHN0cmluZy5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbnZhciBnZXROb25jZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNoYXJzID0gW1xuICAgICdhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJywgJ2gnLCAnaScsICdqJywgJ2snLCAnbCcsICdtJywgJ24nLCAnbycsXG4gICAgJ3AnLCAncScsICdyJywgJ3MnLCAndCcsICd1JywgJ3YnLCAndycsICd4JywgJ3knLCAneicsICdBJywgJ0InLCAnQycsICdEJyxcbiAgICAnRScsICdGJywgJ0cnLCAnSCcsICdJJywgJ0onLCAnSycsICdMJywgJ00nLCAnTicsICdPJywgJ1AnLCAnUScsICdSJywgJ1MnLFxuICAgICdUJywgJ1UnLCAnVicsICdXJywgJ1gnLCAnWScsICdaJywgJzAnLCAnMScsICcyJywgJzMnLCAnNCcsICc1JywgJzYnLCAnNycsXG4gICAgJzgnLCAnOSdcbiAgXTtcblxuICB2YXIgbm9uY2UgPSAnJztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICBub25jZSArPSBfLnNhbXBsZShjaGFycyk7XG4gIH1cblxuICByZXR1cm4gbm9uY2U7XG59O1xuXG4vKipcbiAqIFByZXBhcmUgb3JkZXJlZCBPQXV0aCBwYXJhbWV0ZXJzIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBkYXRhLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gZGF0YVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbnZhciBwcmVwYXJlUGFyYW1ldGVycyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHZhciBwYXJhbXMgPSBwYXJhbXNUb0FycmF5KF8uZXh0ZW5kKHtcbiAgICAnb2F1dGhfdGltZXN0YW1wJzogICAgICAgIGdldFRpbWVzdGFtcCgpLFxuICAgICdvYXV0aF9ub25jZSc6ICAgICAgICAgICAgZ2V0Tm9uY2UoKSxcbiAgICAnb2F1dGhfdmVyc2lvbic6ICAgICAgICAgICcxLjAnLFxuICAgICdvYXV0aF9zaWduYXR1cmVfbWV0aG9kJzogZGF0YS5vYXV0aDEuc2lnbmF0dXJlTWV0aG9kLFxuICAgICdvYXV0aF9jb25zdW1lcl9rZXknOiAgICAgZGF0YS5vYXV0aDEuY29uc3VtZXJLZXlcbiAgfSwgZGF0YS51cmwucXVlcnkpKTtcblxuICAvLyBBdHRhY2ggdGhlIHRva2VuIHF1ZXJ5IHBhcmFtZXRlciBpZiB3ZSBoYXZlIG9uZS5cbiAgaWYgKGRhdGEub2F1dGgxLm9hdXRoVG9rZW4pIHtcbiAgICBwYXJhbXMucHVzaChbJ29hdXRoX3Rva2VuJywgZGF0YS5vYXV0aDEub2F1dGhUb2tlbl0pO1xuICB9XG5cbiAgaWYgKGRhdGEub2F1dGgxLm9hdXRoQ2FsbGJhY2spIHtcbiAgICBwYXJhbXMucHVzaChbJ29hdXRoX2NhbGxiYWNrJywgZGF0YS5vYXV0aDEub2F1dGhDYWxsYmFja10pO1xuICB9XG5cbiAgdmFyIGNvbnRlbnRUeXBlID0gXy5maW5kKF8ucGFpcnMoZGF0YS5oZWFkZXJzKSwgZnVuY3Rpb24gKGhlYWRlcikge1xuICAgIHJldHVybiBoZWFkZXJbMF0udG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtdHlwZSc7XG4gIH0pO1xuXG4gIGlmICghY29udGVudFR5cGUpIHtcbiAgICBjb250ZW50VHlwZSA9IGRhdGEuaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSBVUkxfRU5DT0RFRDtcbiAgfSBlbHNlIHtcbiAgICBjb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlWzFdO1xuICB9XG5cbiAgaWYgKGNvbnRlbnRUeXBlID09PSBVUkxfRU5DT0RFRCkge1xuICAgIGlmIChfLmlzU3RyaW5nKGRhdGEuZGF0YSkpIHtcbiAgICAgIGRhdGEuZGF0YSA9IHFzLnBhcnNlKGRhdGEuZGF0YSk7XG4gICAgfVxuXG4gICAgaWYgKF8uaXNPYmplY3QoZGF0YS5kYXRhKSkge1xuICAgICAgdmFyIGJvZHkgPSBwYXJhbXNUb0FycmF5KGRhdGEuZGF0YSk7XG4gICAgICBkYXRhLmRhdGEgPSBhcnJheVRvUGFyYW1zKGJvZHkpO1xuICAgICAgcGFyYW1zLnB1c2guYXBwbHkocGFyYW1zLCBib2R5KTtcbiAgICB9XG4gIH1cblxuICB2YXIgc29ydGVkUGFyYW1zID0gc29ydFJlcXVlc3RQYXJhbXMocGFyYW1zKTtcblxuICBzb3J0ZWRQYXJhbXMucHVzaChcbiAgICBbJ29hdXRoX3NpZ25hdHVyZScsIGVuY29kZURhdGEoZ2V0U2lnbmF0dXJlKHNvcnRlZFBhcmFtcywgZGF0YSkpXVxuICApO1xuXG4gIHJldHVybiBzb3J0ZWRQYXJhbXM7XG59O1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIHBhcmFtZXRlcnMgbmFtZSBpcyBhIHZhbGlkIE9BdXRoIHBhcmFtZXRlci5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICBwYXJhbVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzUGFyYW1Bbk9BdXRoUGFyYW1ldGVyID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gIHJldHVybiAoL15vYXV0aF8vKS50ZXN0KHBhcmFtKTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgdGhlIEF1dGhvcml6YXRpb24gaGVhZGVyIGZyb20gYW4gb3JkZXIgcGFyYW1ldGVyIGFycmF5LlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gZGF0YVxuICogQHBhcmFtICB7QXJyYXl9ICBwYXJhbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xudmFyIGJ1aWxkQXV0aG9yaXphdGlvbkhlYWRlcnMgPSBmdW5jdGlvbiAoZGF0YSwgcGFyYW1zKSB7XG4gIHJldHVybiAnT0F1dGggcmVhbG09XCInICsgbm9ybWFsaXplVXJsKGRhdGEudXJsKSArICdcIiwnICtcbiAgICBfLmNoYWluKHBhcmFtcykuZmlsdGVyKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgcmV0dXJuIGlzUGFyYW1Bbk9BdXRoUGFyYW1ldGVyKHBhcmFtWzBdKTtcbiAgICB9KS5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICByZXR1cm4gcGFyYW1bMF0gKyAnPVwiJyArIHBhcmFtWzFdICsgJ1wiJztcbiAgICB9KS52YWx1ZSgpLmpvaW4oJywnKTtcbn07XG5cbi8qKlxuICogU2VuZCBhIHJlcXVlc3QgdG8gZ2V0IHRoZSBpbml0aWFsIE9BdXRoIHJlcXVlc3QgdG9rZW5zLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSAgIHVybFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICovXG52YXIgZ2V0UmVxdWVzdFRva2VuID0gZnVuY3Rpb24gKG9wdGlvbnMsIGRvbmUpIHtcbiAgcmV0dXJuIEFwcC5taWRkbGV3YXJlLnRyaWdnZXIoJ2FqYXg6b2F1dGgxJywge1xuICAgIHVybDogICAgb3B0aW9ucy5yZXF1ZXN0VG9rZW5VcmksXG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgb2F1dGgxOiBfLmV4dGVuZCh7XG4gICAgICBvYXV0aENhbGxiYWNrOiBvcHRpb25zLnJlZGlyZWN0VXJpXG4gICAgfSwgb3B0aW9ucyksXG4gICAgaGVhZGVyczoge1xuICAgICAgJ0NvbnRlbnQtVHlwZSc6IFVSTF9FTkNPREVEXG4gICAgfVxuICB9LCBmdW5jdGlvbiAoZXJyLCB4aHIpIHtcbiAgICBpZiAoZXJyKSB7IHJldHVybiBkb25lKGVycik7IH1cblxuICAgIGlmICh4aHIuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgIHJldHVybiBkb25lKG5ldyBFcnJvcih4aHIucmVzcG9uc2VUZXh0IHx8ICdJbnZhbGlkIFJlcXVlc3QnKSk7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRlbnQgPSBxcy5wYXJzZSh4aHIucmVzcG9uc2VUZXh0KTtcblxuICAgIHJldHVybiBkb25lKG51bGwsIHtcbiAgICAgIG9hdXRoVG9rZW46ICAgICAgIGNvbnRlbnQub2F1dGhfdG9rZW4sXG4gICAgICBvYXV0aFRva2VuU2VjcmV0OiBjb250ZW50Lm9hdXRoX3Rva2VuX3NlY3JldFxuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBmaW5hbCBhY2Nlc3MgdG9rZW4gYnkgcGFzc2luZyBpbiB0aGUgcmVxdWVzdCBvcHRpb25zIGFuZCB0aGUgdG9rZW5cbiAqIHZlcmlmaWVyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSAgIG9wdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSAgIHZlcmlmaWVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gKi9cbnZhciBnZXRBY2Nlc3NUb2tlbiA9IGZ1bmN0aW9uIChvcHRpb25zLCB2ZXJpZmllciwgZG9uZSkge1xuICByZXR1cm4gQXBwLm1pZGRsZXdhcmUudHJpZ2dlcignYWpheDpvYXV0aDEnLCB7XG4gICAgdXJsOiAgICBvcHRpb25zLnRva2VuQ3JlZGVudGlhbHNVcmksXG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgb2F1dGgxOiBvcHRpb25zLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgICdDb250ZW50LVR5cGUnOiBVUkxfRU5DT0RFRFxuICAgIH0sXG4gICAgZGF0YTogcXMuc3RyaW5naWZ5KHtcbiAgICAgICdvYXV0aF92ZXJpZmllcic6IHZlcmlmaWVyXG4gICAgfSlcbiAgfSwgZnVuY3Rpb24gKGVyciwgeGhyKSB7XG4gICAgaWYgKGVycikgeyByZXR1cm4gZG9uZShlcnIpOyB9XG5cbiAgICB2YXIgcmVzcG9uc2UgPSBxcy5wYXJzZSh4aHIucmVzcG9uc2VUZXh0KTtcblxuICAgIHZhciBkYXRhID0ge1xuICAgICAgcmVzcG9uc2U6ICAgICAgICAgcmVzcG9uc2UsXG4gICAgICBvYXV0aFRva2VuOiAgICAgICByZXNwb25zZS5vYXV0aF90b2tlbixcbiAgICAgIG9hdXRoVG9rZW5TZWNyZXQ6IHJlc3BvbnNlLm9hdXRoX3Rva2VuX3NlY3JldFxuICAgIH07XG5cbiAgICAvLyBEZWxldGUgZGF0YSB0aGF0IGhhcyBiZWVuIHB1bGxlZCBvZmYgdGhlIHJlc3BvbnNlIG9iamVjdCB0byBhdm9pZFxuICAgIC8vIGR1cGxpY2F0aW9uLlxuICAgIGRlbGV0ZSByZXNwb25zZS5vYXV0aF90b2tlbjtcbiAgICBkZWxldGUgcmVzcG9uc2Uub2F1dGhfdG9rZW5fc2VjcmV0O1xuXG4gICAgaWYgKCFfLmtleXMoZGF0YS5yZXNwb25zZSkubGVuZ3RoKSB7XG4gICAgICBkZWxldGUgZGF0YS5yZXNwb25zZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZG9uZShudWxsLCBkYXRhKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFRyaWdnZXIgdGhlIGZ1bGwgT0F1dGgxIGF1dGhlbnRpY2F0aW9uIGZsb3cuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9ICAgb3B0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICovXG52YXIgb2F1dGgxRmxvdyA9IGZ1bmN0aW9uIChvcHRpb25zLCBkb25lKSB7XG4gIGlmICghXy5pc1N0cmluZyhvcHRpb25zLmNvbnN1bWVyS2V5KSkge1xuICAgIHJldHVybiBkb25lKG5ldyBUeXBlRXJyb3IoJ1wiY29uc3VtZXJLZXlcIiBleHBlY3RlZCcpKTtcbiAgfVxuXG4gIGlmICghXy5pc1N0cmluZyhvcHRpb25zLmNvbnN1bWVyU2VjcmV0KSkge1xuICAgIHJldHVybiBkb25lKG5ldyBUeXBlRXJyb3IoJ1wiY29uc3VtZXJTZWNyZXRcIiBleHBlY3RlZCcpKTtcbiAgfVxuXG4gIGlmICghXy5pc1N0cmluZyhvcHRpb25zLnJlcXVlc3RUb2tlblVyaSkpIHtcbiAgICByZXR1cm4gZG9uZShuZXcgVHlwZUVycm9yKCdcInJlcXVlc3RUb2tlblVyaVwiIGV4cGVjdGVkJykpO1xuICB9XG5cbiAgaWYgKCFfLmlzU3RyaW5nKG9wdGlvbnMuYXV0aG9yaXphdGlvblVyaSkpIHtcbiAgICByZXR1cm4gZG9uZShuZXcgVHlwZUVycm9yKCdcImF1dGhvcml6YXRpb25VcmlcIiBleHBlY3RlZCcpKTtcbiAgfVxuXG4gIGlmICghXy5pc1N0cmluZyhvcHRpb25zLnRva2VuQ3JlZGVudGlhbHNVcmkpKSB7XG4gICAgcmV0dXJuIGRvbmUobmV3IFR5cGVFcnJvcignXCJ0b2tlbkNyZWRlbnRpYWxzVXJpXCIgZXhwZWN0ZWQnKSk7XG4gIH1cblxuICByZXR1cm4gZ2V0UmVxdWVzdFRva2VuKG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICBpZiAoZXJyKSB7IHJldHVybiBkb25lKGVycik7IH1cblxuICAgIHZhciBwb3B1cCA9IGF1dGhXaW5kb3cob3B0aW9ucy5hdXRob3JpemF0aW9uVXJpICsgJz8nICsgcXMuc3RyaW5naWZ5KHtcbiAgICAgICdvYXV0aF90b2tlbic6IGRhdGEub2F1dGhUb2tlblxuICAgIH0pLCBvcHRpb25zLCBkb25lKTtcblxuICAgIGdsb2JhbC5hdXRoZW50aWNhdGVPQXV0aCA9IGZ1bmN0aW9uIChocmVmKSB7XG4gICAgICBwb3B1cC5jbG9zZSgpO1xuICAgICAgZGVsZXRlIGdsb2JhbC5hdXRoZW50aWNhdGVPQXV0aDtcblxuICAgICAgaWYgKGhyZWYuc3Vic3RyKDAsIG9wdGlvbnMucmVkaXJlY3RVcmkubGVuZ3RoKSAhPT0gb3B0aW9ucy5yZWRpcmVjdFVyaSkge1xuICAgICAgICByZXR1cm4gZG9uZShuZXcgRXJyb3IoJ0ludmFsaWQgcmVkaXJlY3QgdXJpJykpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzcG9uc2UgPSB1cmwucGFyc2UoaHJlZiwgdHJ1ZSkucXVlcnk7XG5cbiAgICAgIGlmIChyZXNwb25zZS5vYXV0aF90b2tlbiAhPT0gZGF0YS5vYXV0aFRva2VuKSB7XG4gICAgICAgIHJldHVybiBkb25lKG5ldyBFcnJvcignSW52YWxpZCBPQXV0aCB0b2tlbiByZXNwb25zZScpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldEFjY2Vzc1Rva2VuKF8uZXh0ZW5kKHtcbiAgICAgICAgb2F1dGhUb2tlbjogcmVzcG9uc2Uub2F1dGhfdG9rZW5cbiAgICAgIH0sIG9wdGlvbnMpLCByZXNwb25zZS5vYXV0aF92ZXJpZmllciwgZG9uZSk7XG4gICAgfTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFRyaWdnZXIgYXV0aGVudGljYXRpb24gdmlhIE9BdXRoMS4wKEEpIGluIHRoZSBicm93c2VyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSAgIG9wdGlvbnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAqL1xubWlkZGxld2FyZS5yZWdpc3RlcignYXV0aGVudGljYXRlJywgZnVuY3Rpb24gKG9wdGlvbnMsIG5leHQsIGRvbmUpIHtcbiAgaWYgKG9wdGlvbnMudHlwZSA9PT0gJ09BdXRoIDEuMCcpIHtcbiAgICByZXR1cm4gb2F1dGgxRmxvdyhfLmV4dGVuZCh7XG4gICAgICByZWRpcmVjdFVyaTogUkVESVJFQ1RfVVJJXG4gICAgfSwgb3B0aW9ucyksIGRvbmUpO1xuICB9XG5cbiAgcmV0dXJuIG5leHQoKTtcbn0pO1xuXG4vKipcbiAqIEFsbG93IGEgbmV3IGFqYXggZmxvdyBmb3IgT0F1dGgxLWJhc2VkIFVSTHMuIEFjY2VwdHMgYW4gYG9hdXRoMWAgcHJvcGVydHlcbiAqIG9uIHRoZSBkYXRhIG9iamVjdCBpbiB0aGUgZm9ybWF0IHRoYXQgaXMgcmV0dXJuZWQgZnJvbSB0aGUgbWlkZGxld2FyZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gICBkYXRhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0XG4gKi9cbm1pZGRsZXdhcmUucmVnaXN0ZXIoJ2FqYXg6b2F1dGgxJywgZnVuY3Rpb24gKGRhdGEsIG5leHQpIHtcbiAgLy8gQ2hlY2sgd2UgaGF2ZSBhbiBvYXV0aDEgb2JqZWN0IGZvciBhdHRlbXB0aW5nIHRvIG1peGluIGtleXMuXG4gIGlmIChfLmlzT2JqZWN0KGRhdGEub2F1dGgxKSkge1xuICAgIGlmICghZGF0YS5vYXV0aDEuc2lnbmF0dXJlTWV0aG9kKSB7XG4gICAgICBkYXRhLm9hdXRoMS5zaWduYXR1cmVNZXRob2QgPSAnSE1BQy1TSEExJztcbiAgICB9XG5cbiAgICAvLyBQYXJzZSB0aGUgdXJsIGZvciBhdWdtZW50aW5nIHRoZSBxdWVyeSBzdHJpbmcgcGFyYW1ldGVycy4gTmVlZGVkIGluXG4gICAgLy8gbXVsdGlwbGUgcGxhY2VzIHRocm91Z2hvdXQgdGhlIGZsb3csIHNvIHdlIGNhbiBtaW5pbWl6ZSB0aGUgbnVtYmVyIG9mXG4gICAgLy8gcGFyc2VzIGJ5IGRvaW5nIGl0IG9uY2UgYXQgdGhlIHN0YXJ0LlxuICAgIGRhdGEudXJsID0gdXJsLnBhcnNlKGRhdGEudXJsLCB0cnVlKTtcblxuICAgIC8vIERlbGV0ZSBwYXJhbWV0ZXJzIHNwZWNpZmljIHRvIHJlLWFkZGluZyB0aGUgcXVlcnkgc3RyaW5nLCBzaW5jZSB3ZSBuZWVkXG4gICAgLy8gdG8gcmVnZW5lcmF0ZSB0aGUgcXVlcnkgc3RyaW5nIHdpdGhvdXQgT0F1dGggcGFyYW1zLlxuICAgIGRlbGV0ZSBkYXRhLnVybC5ocmVmO1xuICAgIGRlbGV0ZSBkYXRhLnVybC5wYXRoO1xuICAgIGRlbGV0ZSBkYXRhLnVybC5zZWFyY2g7XG5cbiAgICB2YXIgb3JkZXJlZFBhcmFtcyA9IHByZXBhcmVQYXJhbWV0ZXJzKGRhdGEpO1xuICAgIHZhciBhdXRob3JpemF0aW9uID0gYnVpbGRBdXRob3JpemF0aW9uSGVhZGVycyhkYXRhLCBvcmRlcmVkUGFyYW1zKTtcblxuICAgIGRhdGEuaGVhZGVycy5BdXRob3JpemF0aW9uID0gYXV0aG9yaXphdGlvbjtcblxuICAgIGRhdGEudXJsLnF1ZXJ5ID0gYXJyYXlUb1BhcmFtcyhcbiAgICAgIF8uZmlsdGVyKHBhcmFtc1RvQXJyYXkoZGF0YS51cmwucXVlcnkpLCBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgcmV0dXJuICFpc1BhcmFtQW5PQXV0aFBhcmFtZXRlcihwYXJhbVswXSk7XG4gICAgICB9KVxuICAgICk7XG5cbiAgICAvLyBSZWF0dGFjaCB0aGUgcXVlcnkgc3RyaW5nIGlmIHdlIGhhdmUgb25lIGF2YWlsYWJsZS5cbiAgICBpZiAoZGF0YS51cmwucXVlcnkpIHtcbiAgICAgIGRhdGEudXJsLnNlYXJjaCA9ICc/JyArIGRhdGEudXJsLnF1ZXJ5O1xuICAgICAgZGF0YS51cmwucGF0aCAgID0gZGF0YS51cmwucGF0aG5hbWUgKyBkYXRhLnVybC5zZWFyY2g7XG4gICAgfVxuXG4gICAgZGF0YS51cmwgPSB1cmwuZm9ybWF0KGRhdGEudXJsKTtcbiAgfVxuXG4gIHJldHVybiBtaWRkbGV3YXJlLnRyaWdnZXIoJ2FqYXgnLCBkYXRhLCBuZXh0KTtcbn0pO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qIGdsb2JhbCBBcHAgKi9cbnZhciBfICAgICAgICAgICA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBxcyAgICAgICAgICA9IHJlcXVpcmUoJ3FzJyk7XG52YXIgdXJsICAgICAgICAgPSByZXF1aXJlKCd1cmwnKTtcbnZhciBhdXRoV2luZG93ICA9IHJlcXVpcmUoJy4vbGliL2F1dGgtd2luZG93Jyk7XG52YXIgbWlkZGxld2FyZSAgPSByZXF1aXJlKCcuLi8uLi8uLi9zdGF0ZS9taWRkbGV3YXJlJyk7XG5cbi8qKlxuICogU2V0IHRoZSBkZWZhdWx0IHJlZGlyZWN0aW9uIHVybC5cbiAqXG4gKiBAdHlwZSB7U3RyaW5nfVxuICovXG52YXIgUkVESVJFQ1RfVVJJID0gdXJsLnJlc29sdmUoXG4gIGdsb2JhbC5sb2NhdGlvbi5ocmVmLCB7XCJ1cmxcIjpcImh0dHBzOi8vbXVsZXNvZnQuZ2l0aHViLmlvL2FwaS1ub3RlYm9vay9cIixcInRpdGxlXCI6XCJBUEkgTm90ZWJvb2tcIixcIm9hdXRoQ2FsbGJhY2tcIjpcIi9hdXRoZW50aWNhdGUvb2F1dGguaHRtbFwifS5vYXV0aENhbGxiYWNrXG4pO1xuXG4vKipcbiAqIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHN1cHBvcnRlZCBncmFudCB0eXBlcyBpbiBwcmVmZXJyZWQgb3JkZXIuXG4gKlxuICogQHR5cGUge0FycmF5fVxuICovXG52YXIgU1VQUE9SVEVEX0dSQU5UUyA9IFsndG9rZW4nLCAnY29kZSddO1xuXG4vKipcbiAqIEZvcm1hdCBlcnJvciByZXNwb25zZSB0eXBlcyB0byByZWd1bGFyIHN0cmluZ3MgZm9yIGRpc3BsYXlpbmcgdGhlIGNsaWVudHMuXG4gKiBSZWZlcmVuY2U6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY3NDkjc2VjdGlvbi00LjEuMi4xXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIEVSUk9SX1JFU1BPTlNFUyA9IHtcbiAgJ2ludmFsaWRfcmVxdWVzdCc6IFtcbiAgICAnVGhlIHJlcXVlc3QgaXMgbWlzc2luZyBhIHJlcXVpcmVkIHBhcmFtZXRlciwgaW5jbHVkZXMgYW4nLFxuICAgICdpbnZhbGlkIHBhcmFtZXRlciB2YWx1ZSwgaW5jbHVkZXMgYSBwYXJhbWV0ZXIgbW9yZSB0aGFuJyxcbiAgICAnb25jZSwgb3IgaXMgb3RoZXJ3aXNlIG1hbGZvcm1lZC4nXG4gIF0uam9pbignICcpLFxuICAnaW52YWxpZF9jbGllbnQnOiBbXG4gICAgJ0NsaWVudCBhdXRoZW50aWNhdGlvbiBmYWlsZWQgKGUuZy4sIHVua25vd24gY2xpZW50LCBubycsXG4gICAgJ2NsaWVudCBhdXRoZW50aWNhdGlvbiBpbmNsdWRlZCwgb3IgdW5zdXBwb3J0ZWQnLFxuICAgICdhdXRoZW50aWNhdGlvbiBtZXRob2QpLidcbiAgXS5qb2luKCcgJyksXG4gICdpbnZhbGlkX2dyYW50JzogW1xuICAgICdUaGUgcHJvdmlkZWQgYXV0aG9yaXphdGlvbiBncmFudCAoZS5nLiwgYXV0aG9yaXphdGlvbicsXG4gICAgJ2NvZGUsIHJlc291cmNlIG93bmVyIGNyZWRlbnRpYWxzKSBvciByZWZyZXNoIHRva2VuIGlzJyxcbiAgICAnaW52YWxpZCwgZXhwaXJlZCwgcmV2b2tlZCwgZG9lcyBub3QgbWF0Y2ggdGhlIHJlZGlyZWN0aW9uJyxcbiAgICAnVVJJIHVzZWQgaW4gdGhlIGF1dGhvcml6YXRpb24gcmVxdWVzdCwgb3Igd2FzIGlzc3VlZCB0bycsXG4gICAgJ2Fub3RoZXIgY2xpZW50LidcbiAgXS5qb2luKCcgJyksXG4gICd1bmF1dGhvcml6ZWRfY2xpZW50JzogW1xuICAgICdUaGUgY2xpZW50IGlzIG5vdCBhdXRob3JpemVkIHRvIHJlcXVlc3QgYW4gYXV0aG9yaXphdGlvbicsXG4gICAgJ2NvZGUgdXNpbmcgdGhpcyBtZXRob2QuJ1xuICBdLmpvaW4oJyAnKSxcbiAgJ3Vuc3VwcG9ydGVkX2dyYW50X3R5cGUnOiBbXG4gICAgJ1RoZSBhdXRob3JpemF0aW9uIGdyYW50IHR5cGUgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUnLFxuICAgICdhdXRob3JpemF0aW9uIHNlcnZlci4nXG4gIF0uam9pbignICcpLFxuICAnYWNjZXNzX2RlbmllZCc6IFtcbiAgICAnVGhlIHJlc291cmNlIG93bmVyIG9yIGF1dGhvcml6YXRpb24gc2VydmVyIGRlbmllZCB0aGUgcmVxdWVzdC4nXG4gIF0uam9pbignICcpLFxuICAndW5zdXBwb3J0ZWRfcmVzcG9uc2VfdHlwZSc6IFtcbiAgICAnVGhlIGF1dGhvcml6YXRpb24gc2VydmVyIGRvZXMgbm90IHN1cHBvcnQgb2J0YWluaW5nJyxcbiAgICAnYW4gYXV0aG9yaXphdGlvbiBjb2RlIHVzaW5nIHRoaXMgbWV0aG9kLidcbiAgXS5qb2luKCcgJyksXG4gICdpbnZhbGlkX3Njb3BlJzogW1xuICAgICdUaGUgcmVxdWVzdGVkIHNjb3BlIGlzIGludmFsaWQsIHVua25vd24sIG9yIG1hbGZvcm1lZC4nXG4gIF0uam9pbignICcpLFxuICAnc2VydmVyX2Vycm9yJzogW1xuICAgICdUaGUgYXV0aG9yaXphdGlvbiBzZXJ2ZXIgZW5jb3VudGVyZWQgYW4gdW5leHBlY3RlZCcsXG4gICAgJ2NvbmRpdGlvbiB0aGF0IHByZXZlbnRlZCBpdCBmcm9tIGZ1bGZpbGxpbmcgdGhlIHJlcXVlc3QuJyxcbiAgICAnKFRoaXMgZXJyb3IgY29kZSBpcyBuZWVkZWQgYmVjYXVzZSBhIDUwMCBJbnRlcm5hbCBTZXJ2ZXInLFxuICAgICdFcnJvciBIVFRQIHN0YXR1cyBjb2RlIGNhbm5vdCBiZSByZXR1cm5lZCB0byB0aGUgY2xpZW50JyxcbiAgICAndmlhIGFuIEhUVFAgcmVkaXJlY3QuKSdcbiAgXS5qb2luKCcgJyksXG4gICd0ZW1wb3JhcmlseV91bmF2YWlsYWJsZSc6IFtcbiAgICAnVGhlIGF1dGhvcml6YXRpb24gc2VydmVyIGlzIGN1cnJlbnRseSB1bmFibGUgdG8gaGFuZGxlJyxcbiAgICAndGhlIHJlcXVlc3QgZHVlIHRvIGEgdGVtcG9yYXJ5IG92ZXJsb2FkaW5nIG9yIG1haW50ZW5hbmNlJyxcbiAgICAnb2YgdGhlIHNlcnZlci4nXG4gIF0uam9pbignICcpXG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgZm9ybWF0dGVkIGVycm9yIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IGRhdGFcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xudmFyIGVycm9yZWRSZXNwb25zZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHJldHVybiBFUlJPUl9SRVNQT05TRVNbZGF0YS5lcnJvcl0gfHwgZGF0YS5lcnJvciB8fCBkYXRhLmVycm9yX21lc3NhZ2U7XG59O1xuXG4vKipcbiAqIEZpeCBwYXNzZWQgaW4gb3B0aW9ucyBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG52YXIgc2FuaXRpemVPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgLy8gRXh0ZW5kIGFuIGRlZmF1bHQgb3B0aW9ucyBvYmplY3QuXG4gIHZhciBvcHRzID0gXy5leHRlbmQoe1xuICAgIHJlZGlyZWN0VXJpOiBSRURJUkVDVF9VUklcbiAgfSwgb3B0aW9ucyk7XG5cbiAgLy8gRml4IHVwIHJlZmVyZW5jZSB0byB0aGUgYHNjb3Blc2AgYXJyYXkuXG4gIG9wdHMuc2NvcGUgPSBvcHRzLnNjb3BlIHx8IG9wdHMuc2NvcGVzO1xuXG4gIGlmIChfLmlzQXJyYXkob3B0cy5zY29wZSkpIHtcbiAgICBvcHRzLnNjb3BlID0gb3B0cy5zY29wZS5qb2luKCcgJyk7XG4gIH1cblxuICAvLyBSZW1vdmUgdW51c2VkIGBzY29wZXNgIHByb3BlcnR5LlxuICBkZWxldGUgb3B0cy5zY29wZXM7XG5cbiAgcmV0dXJuIG9wdHM7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlIGFuIE9BdXRoMiByZXNwb25zZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9ICAgcmVzcG9uc2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAqL1xudmFyIGF1dGhSZXNwb25zZSA9IGZ1bmN0aW9uIChvcHRpb25zLCByZXNwb25zZSwgZG9uZSkge1xuICBpZiAoZXJyb3JlZFJlc3BvbnNlKHJlc3BvbnNlKSkge1xuICAgIHJldHVybiBkb25lKG5ldyBFcnJvcihlcnJvcmVkUmVzcG9uc2UocmVzcG9uc2UpKSk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHtcbiAgICBzY29wZTogcmVzcG9uc2Uuc2NvcGUgfHwgb3B0aW9ucy5zY29wZSxcbiAgICByZXNwb25zZTogXy5vbWl0KHJlc3BvbnNlLCBbXG4gICAgICAnYWNjZXNzX3Rva2VuJywgJ3JlZnJlc2hfdG9rZW4nLCAndG9rZW5fdHlwZScsICdleHBpcmVzX2luJywgJ3Njb3BlJyxcbiAgICAgICdzdGF0ZScsICdlcnJvcicsICdlcnJvcl9kZXNjcmlwdGlvbicsICdlcnJvcl91cmknXG4gICAgXSksXG4gICAgYWNjZXNzVG9rZW46IHJlc3BvbnNlLmFjY2Vzc190b2tlblxuICB9O1xuXG4gIC8vIE9taXQgdGhlIHJlc3BvbnNlIG9iamVjdCBhbHRvZ2V0aGVyIGlmIG5vIHJlc3BvbnNlIGlzIGF2YWlsYWJsZS5cbiAgaWYgKCFfLmtleXMoZGF0YS5yZXNwb25zZSkubGVuZ3RoKSB7XG4gICAgZGVsZXRlIGRhdGEucmVzcG9uc2U7XG4gIH1cblxuICBpZiAocmVzcG9uc2UudG9rZW5fdHlwZSkge1xuICAgIGRhdGEudG9rZW5UeXBlID0gcmVzcG9uc2UudG9rZW5fdHlwZTtcbiAgfVxuXG4gIGlmICgrcmVzcG9uc2UuZXhwaXJlc19pbikge1xuICAgIGRhdGEuZXhwaXJlcyA9IERhdGUubm93KCkgKyAocmVzcG9uc2UuZXhwaXJlc19pbiAqIDEwMDApO1xuICB9XG5cbiAgaWYgKHJlc3BvbnNlLnJlZnJlc2hfdG9rZW4pIHtcbiAgICBkYXRhLnJlZnJlc2hUb2tlbiA9IHJlc3BvbnNlLnJlZnJlc2hfdG9rZW47XG4gIH1cblxuICByZXR1cm4gZG9uZShudWxsLCBkYXRhKTtcbn07XG5cbi8qKlxuICogVHJpZ2dlciB0aGUgY2xpZW50LXNpZGUgaW1wbGljaXQgT0F1dGgyIGZsb3cuXG4gKiBSZWZlcmVuY2U6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY3NDkjc2VjdGlvbi00LjJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gICBvcHRpb25zXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gKi9cbnZhciBvYXV0aDJUb2tlbkZsb3cgPSBmdW5jdGlvbiAob3B0aW9ucywgZG9uZSkge1xuICBpZiAoIV8uaXNTdHJpbmcob3B0aW9ucy5jbGllbnRJZCkpIHtcbiAgICByZXR1cm4gZG9uZShuZXcgVHlwZUVycm9yKCdcImNsaWVudElkXCIgZXhwZWN0ZWQnKSk7XG4gIH1cblxuICBpZiAoIV8uaXNTdHJpbmcob3B0aW9ucy5hdXRob3JpemF0aW9uVXJpKSkge1xuICAgIHJldHVybiBkb25lKG5ldyBUeXBlRXJyb3IoJ1wiYXV0aG9yaXphdGlvblVyaVwiIGV4cGVjdGVkJykpO1xuICB9XG5cbiAgdmFyIHN0YXRlID0gKCcnICsgTWF0aC5yYW5kb20oKSkuc3Vic3RyKDIpO1xuICB2YXIgcG9wdXAgPSBhdXRoV2luZG93KG9wdGlvbnMuYXV0aG9yaXphdGlvblVyaSArICc/JyArIHFzLnN0cmluZ2lmeSh7XG4gICAgJ3N0YXRlJzogICAgICAgICBzdGF0ZSxcbiAgICAnc2NvcGUnOiAgICAgICAgIG9wdGlvbnMuc2NvcGUsXG4gICAgJ2NsaWVudF9pZCc6ICAgICBvcHRpb25zLmNsaWVudElkLFxuICAgICdyZWRpcmVjdF91cmknOiAgb3B0aW9ucy5yZWRpcmVjdFVyaSxcbiAgICAncmVzcG9uc2VfdHlwZSc6ICd0b2tlbidcbiAgfSksIG9wdGlvbnMsIGRvbmUpO1xuXG4gIGdsb2JhbC5hdXRoZW50aWNhdGVPQXV0aCA9IGZ1bmN0aW9uIChocmVmKSB7XG4gICAgcG9wdXAuY2xvc2UoKTtcbiAgICBkZWxldGUgZ2xvYmFsLmF1dGhlbnRpY2F0ZU9BdXRoO1xuXG4gICAgdmFyIHVyaSAgICAgID0gdXJsLnBhcnNlKGhyZWYsIHRydWUpO1xuICAgIHZhciByZXNwb25zZSA9IF8uZXh0ZW5kKHFzLnBhcnNlKCh1cmkuaGFzaCB8fCAnJykuc3Vic3RyKDEpKSwgdXJpLnF1ZXJ5KTtcblxuICAgIGlmIChocmVmLnN1YnN0cigwLCBvcHRpb25zLnJlZGlyZWN0VXJpLmxlbmd0aCkgIT09IG9wdGlvbnMucmVkaXJlY3RVcmkpIHtcbiAgICAgIHJldHVybiBkb25lKG5ldyBFcnJvcignSW52YWxpZCByZWRpcmVjdCB1cmknKSk7XG4gICAgfVxuXG4gICAgaWYgKHJlc3BvbnNlLnN0YXRlICE9PSBzdGF0ZSkge1xuICAgICAgcmV0dXJuIGRvbmUobmV3IEVycm9yKCdTdGF0ZSBtaXNtYXRjaCcpKTtcbiAgICB9XG5cbiAgICAvLyBQYXNzIHRoZSByZXNwb25zZSBvZmYgZm9yIHZhbGlkYXRpb24uIEF0IGxlYXN0IEluc3RhZ3JhbSBoYXMgYSBidWcgd2hlcmVcbiAgICAvLyB0aGUgc3RhdGUgaXMgYmVpbmcgcGFzc2VkIGJhY2sgYXMgcGFydCBvZiB0aGUgcXVlcnkgc3RyaW5nIGluc3RlYWQgb2YgdGhlXG4gICAgLy8gaGFzaCwgc28gd2UgbWVyZ2UgYm90aCBvcHRpb25zIHRvZ2V0aGVyLlxuICAgIHJldHVybiBhdXRoUmVzcG9uc2Uob3B0aW9ucywgcmVzcG9uc2UsIGRvbmUpO1xuICB9O1xufTtcblxuLyoqXG4gKiBUcmlnZ2VyIHRoZSBmdWxsIHNlcnZlci1zaWRlIE9BdXRoMiBmbG93LlxuICogUmVmZXJlbmNlOiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NzQ5I3NlY3Rpb24tNC4xXG4gKlxuICogQHBhcmFtIHtPYmplY3R9ICAgb3B0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICovXG52YXIgb0F1dGgyQ29kZUZsb3cgPSBmdW5jdGlvbiAob3B0aW9ucywgZG9uZSkge1xuICBpZiAoIV8uaXNTdHJpbmcob3B0aW9ucy5jbGllbnRJZCkpIHtcbiAgICByZXR1cm4gZG9uZShuZXcgVHlwZUVycm9yKCdcImNsaWVudElkXCIgZXhwZWN0ZWQnKSk7XG4gIH1cblxuICBpZiAoIV8uaXNTdHJpbmcob3B0aW9ucy5jbGllbnRTZWNyZXQpKSB7XG4gICAgcmV0dXJuIGRvbmUobmV3IFR5cGVFcnJvcignXCJjbGllbnRTZWNyZXRcIiBleHBlY3RlZCcpKTtcbiAgfVxuXG4gIGlmICghXy5pc1N0cmluZyhvcHRpb25zLmFjY2Vzc1Rva2VuVXJpKSkge1xuICAgIHJldHVybiBkb25lKG5ldyBUeXBlRXJyb3IoJ1wiYWNjZXNzVG9rZW5VcmlcIiBleHBlY3RlZCcpKTtcbiAgfVxuXG4gIGlmICghXy5pc1N0cmluZyhvcHRpb25zLmF1dGhvcml6YXRpb25VcmkpKSB7XG4gICAgcmV0dXJuIGRvbmUobmV3IFR5cGVFcnJvcignXCJhdXRob3JpemF0aW9uVXJpXCIgZXhwZWN0ZWQnKSk7XG4gIH1cblxuICB2YXIgc3RhdGUgPSAoJycgKyBNYXRoLnJhbmRvbSgpKS5zdWJzdHIoMik7XG4gIHZhciBwb3B1cCA9IGF1dGhXaW5kb3cob3B0aW9ucy5hdXRob3JpemF0aW9uVXJpICsgJz8nICsgcXMuc3RyaW5naWZ5KHtcbiAgICAnc3RhdGUnOiAgICAgICAgIHN0YXRlLFxuICAgICdzY29wZSc6ICAgICAgICAgb3B0aW9ucy5zY29wZSxcbiAgICAnY2xpZW50X2lkJzogICAgIG9wdGlvbnMuY2xpZW50SWQsXG4gICAgJ3JlZGlyZWN0X3VyaSc6ICBvcHRpb25zLnJlZGlyZWN0VXJpLFxuICAgICdyZXNwb25zZV90eXBlJzogJ2NvZGUnXG4gIH0pLCBvcHRpb25zLCBkb25lKTtcblxuICAvKipcbiAgICogQXNzaWducyBhIGdsb2JhbCB2YXJpYWJsZSB0aGF0IHRoZSBvYXV0aCBhdXRoZW50aWNhdGlvbiB3aW5kb3cgc2hvdWxkXG4gICAqIGJlIGFibGUgdG8gYWNjZXNzIGFuZCBzZW5kIHRoZSBjYWxsYmFjayBkYXRhLlxuICAgKi9cbiAgZ2xvYmFsLmF1dGhlbnRpY2F0ZU9BdXRoID0gZnVuY3Rpb24gKGhyZWYpIHtcbiAgICBwb3B1cC5jbG9zZSgpO1xuICAgIGRlbGV0ZSBnbG9iYWwuYXV0aGVudGljYXRlT0F1dGg7XG5cbiAgICAvLyBQYXJzZSB0aGUgdXJsIGFuZCBwcmVwYXJlIHRvIGRvIGFuIFBPU1QgcmVxdWVzdCB0byBnZXQgdGhlIGFjY2VzcyB0b2tlbi5cbiAgICB2YXIgcXVlcnkgPSB1cmwucGFyc2UoaHJlZiwgdHJ1ZSkucXVlcnk7XG5cbiAgICBpZiAoaHJlZi5zdWJzdHIoMCwgb3B0aW9ucy5yZWRpcmVjdFVyaS5sZW5ndGgpICE9PSBvcHRpb25zLnJlZGlyZWN0VXJpKSB7XG4gICAgICByZXR1cm4gZG9uZShuZXcgRXJyb3IoJ0ludmFsaWQgcmVkaXJlY3QgdXJpJykpO1xuICAgIH1cblxuICAgIGlmIChlcnJvcmVkUmVzcG9uc2UocXVlcnkpKSB7XG4gICAgICByZXR1cm4gZG9uZShuZXcgRXJyb3IoZXJyb3JlZFJlc3BvbnNlKHF1ZXJ5KSkpO1xuICAgIH1cblxuICAgIGlmIChxdWVyeS5zdGF0ZSAhPT0gc3RhdGUpIHtcbiAgICAgIHJldHVybiBkb25lKG5ldyBFcnJvcignU3RhdGUgbWlzbWF0Y2gnKSk7XG4gICAgfVxuXG4gICAgaWYgKCFxdWVyeS5jb2RlKSB7XG4gICAgICByZXR1cm4gZG9uZShuZXcgRXJyb3IoJ1Jlc3BvbnNlIGNvZGUgbWlzc2luZycpKTtcbiAgICB9XG5cbiAgICBBcHAubWlkZGxld2FyZS50cmlnZ2VyKCdhamF4Jywge1xuICAgICAgdXJsOiBvcHRpb25zLmFjY2Vzc1Rva2VuVXJpLFxuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdBY2NlcHQnOiAgICAgICAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xuICAgICAgfSxcbiAgICAgIGRhdGE6IHFzLnN0cmluZ2lmeSh7XG4gICAgICAgICdjb2RlJzogICAgICAgICAgcXVlcnkuY29kZSxcbiAgICAgICAgJ2dyYW50X3R5cGUnOiAgICAnYXV0aG9yaXphdGlvbl9jb2RlJyxcbiAgICAgICAgJ3JlZGlyZWN0X3VyaSc6ICBvcHRpb25zLnJlZGlyZWN0VXJpLFxuICAgICAgICAnY2xpZW50X2lkJzogICAgIG9wdGlvbnMuY2xpZW50SWQsXG4gICAgICAgICdjbGllbnRfc2VjcmV0Jzogb3B0aW9ucy5jbGllbnRTZWNyZXRcbiAgICAgIH0pXG4gICAgfSwgZnVuY3Rpb24gKGVyciwgeGhyKSB7XG4gICAgICBpZiAoZXJyKSB7IHJldHVybiBkb25lKGVycik7IH1cblxuICAgICAgcmV0dXJuIGF1dGhSZXNwb25zZShvcHRpb25zLCBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpLCBkb25lKTtcbiAgICB9KTtcbiAgfTtcbn07XG5cbi8qKlxuICogTWFwIGF1dGhlbnRpY2F0aW9uIG1ldGhvZHMgdG8gYSBmdW5jdGlvbi5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgYXV0aGVudGljYXRlID0ge1xuICBjb2RlOiAgb0F1dGgyQ29kZUZsb3csXG4gIHRva2VuOiBvYXV0aDJUb2tlbkZsb3dcbn07XG5cbi8qKlxuICogVHJpZ2dlciBhdXRoZW50aWNhdGlvbiB2aWEgT0F1dGgyLjAgaW4gdGhlIGJyb3dzZXIuIFZhbGlkIGRhdGEgcHJvcGVydGllczpcbiAqXG4gKiAgIGBhY2Nlc3NUb2tlblVyaWAgICAgICAtIFwiaHR0cHM6Ly93d3cuZXhhbXBsZS5jb20vb2F1dGgyL3Rva2VuXCJcbiAqICAgYGF1dGhvcml6YXRpb25VcmlgICAgIC0gXCJodHRwczovL3d3dy5leGFtcGxlLmNvbS9vYXV0aDIvYXV0aG9yaXplXCJcbiAqICAgYGNsaWVudElkYCAgICAgICAgICAgIC0gRVhBTVBMRV9DTElFTlRfSURcbiAqICAgYGNsaWVudFNlY3JldGAgICAgICAgIC0gRVhBTVBMRV9DTElFTlRfU0VDUkVUXG4gKiAgIGBhdXRob3JpemF0aW9uR3JhbnRzYCAtIFtcImNvZGVcIl1cbiAqICAgYHNjb3Blc2AgICAgICAgICAgICAgIC0gW1widXNlclwiLCBcInJlYWRcIiwgXCJ3cml0ZVwiXVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSAgIG9wdGlvbnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAqL1xubWlkZGxld2FyZS5yZWdpc3RlcignYXV0aGVudGljYXRlJywgZnVuY3Rpb24gKG9wdGlvbnMsIG5leHQsIGRvbmUpIHtcbiAgaWYgKG9wdGlvbnMudHlwZSAhPT0gJ09BdXRoIDIuMCcpIHtcbiAgICByZXR1cm4gbmV4dCgpO1xuICB9XG5cbiAgLy8gU2FuaXRpemUgYXV0aG9yaXphdGlvbiBncmFudHMgdG8gYW4gYXJyYXkuXG4gIGlmIChfLmlzU3RyaW5nKG9wdGlvbnMuYXV0aG9yaXphdGlvbkdyYW50cykpIHtcbiAgICBvcHRpb25zLmF1dGhvcml6YXRpb25HcmFudHMgPSBbb3B0aW9ucy5hdXRob3JpemF0aW9uR3JhbnRzXTtcbiAgfVxuXG4gIC8vIFVzZSBpbnNlY3Rpb24gdG8gZ2V0IHRoZSBhY2NlcHRlZCBncmFudCB0eXBlcyBpbiB0aGUgb3JkZXIgb2YgdGhlXG4gIC8vIHN1cHBvcnRlZCBncmFudCB0eXBlcyAod2hpY2ggYXJlIG9yZGVyZWQgYnkgcHJlZmVyZW5jZSkuXG4gIHZhciBncmFudFR5cGUgPSBfLmludGVyc2VjdGlvbihcbiAgICBTVVBQT1JURURfR1JBTlRTLCBvcHRpb25zLmF1dGhvcml6YXRpb25HcmFudHNcbiAgKVswXTtcblxuICBpZiAoIWdyYW50VHlwZSkge1xuICAgIHJldHVybiBkb25lKG5ldyBFcnJvcihcbiAgICAgICdVbnN1cHBvcnRlZCBPQXV0aDIgR3JhbnQgRmxvdy4gU3VwcG9ydGVkIGZsb3dzIGluY2x1ZGUgJyArXG4gICAgICBTVVBQT1JURURfR1JBTlRTLmpvaW4oJywgJylcbiAgICApKTtcbiAgfVxuXG4gIHJldHVybiBhdXRoZW50aWNhdGVbZ3JhbnRUeXBlXShzYW5pdGl6ZU9wdGlvbnMob3B0aW9ucyksIGRvbmUpO1xufSk7XG5cbi8qKlxuICogQWxsb3cgYSBuZXcgYWpheCBmbG93IGZvciBPQXV0aDItYmFzZWQgVVJMcy4gQWNjZXB0cyBhbiBgb2F1dGgyYCBwcm9wZXJ0eVxuICogb24gdGhlIGRhdGEgb2JqZWN0IGluIHRoZSBmb3JtYXQgdGhhdCBpcyByZXR1cm5lZCBmcm9tIHRoZSBtaWRkbGV3YXJlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSAgIGRhdGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHRcbiAqL1xubWlkZGxld2FyZS5yZWdpc3RlcignYWpheDpvYXV0aDInLCBmdW5jdGlvbiAoZGF0YSwgbmV4dCkge1xuICAvLyBDaGVjayB0aGF0IHdlIGhhdmUgYW4gYWNjZXNzIHRva2VuIHRvIHVzZSBmb3IgdGhlIHJlcXVlc3QgYW5kIG1peCBpdCBpbi5cbiAgaWYgKF8uaXNPYmplY3QoZGF0YS5vYXV0aDIpICYmIGRhdGEub2F1dGgyLmFjY2Vzc1Rva2VuKSB7XG4gICAgaWYgKGRhdGEub2F1dGgyLnRva2VuVHlwZSA9PT0gJ2JlYXJlcicpIHtcbiAgICAgIGRhdGEuaGVhZGVycyA9IF8uZXh0ZW5kKHtcbiAgICAgICAgJ0F1dGhvcml6YXRpb24nOiAnQmVhcmVyICcgKyBkYXRhLm9hdXRoMi5hY2Nlc3NUb2tlblxuICAgICAgfSwgZGF0YS5oZWFkZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQWRkIHRoZSBhY2Nlc3MgdG9rZW4gdG8gdGhlIHJlcXVlc3QgcXVlcnkuXG4gICAgICB2YXIgdXJpID0gdXJsLnBhcnNlKGRhdGEudXJsLCB0cnVlKTtcbiAgICAgIHVyaS5xdWVyeS5hY2Nlc3NfdG9rZW4gPSBkYXRhLm9hdXRoMi5hY2Nlc3NUb2tlbjtcbiAgICAgIGRlbGV0ZSB1cmkuc2VhcmNoO1xuXG4gICAgICAvLyBVcGRhdGUgYWpheCBkYXRhIGhlYWRlcnMgYW5kIHVybC5cbiAgICAgIGRhdGEudXJsID0gdXJsLmZvcm1hdCh1cmkpO1xuICAgICAgZGF0YS5oZWFkZXJzID0gXy5leHRlbmQoe1xuICAgICAgICAnUHJhZ21hJzogICAgICAgICduby1zdG9yZScsXG4gICAgICAgICdDYWNoZS1Db250cm9sJzogJ25vLXN0b3JlJ1xuICAgICAgfSwgZGF0YS5oZWFkZXJzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWlkZGxld2FyZS50cmlnZ2VyKCdhamF4JywgZGF0YSwgbmV4dCk7XG59KTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCJ2YXIgXyAgICAgICAgICA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBtaWRkbGV3YXJlID0gcmVxdWlyZSgnLi4vLi4vc3RhdGUvbWlkZGxld2FyZScpO1xudmFyIGlzSW5TY29wZSAgPSByZXF1aXJlKCcuLi8uLi9saWIvY29kZW1pcnJvci9pcy1pbi1zY29wZScpO1xuXG4vKipcbiAqIFJlc2VydmVkIGtleXdvcmQgbGlzdCAoaHR0cDovL21kbi5pby9yZXNlcnZlZClcbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgS0VZV09SRFMgPSBfLm9iamVjdChfLm1hcChcbiAgKCdicmVhayBjYXNlIGNhdGNoIGNvbnRpbnVlIGRlYnVnZ2VyIGRlZmF1bHQgZGVsZXRlIGRvIGVsc2UgJyArXG4gICdmYWxzZSBmaW5hbGx5IGZvciBmdW5jdGlvbiBpZiBpbiBpbnN0YW5jZW9mIG5ldyBudWxsIHJldHVybiBzd2l0Y2ggdGhpcyAnICtcbiAgJ3Rocm93IHRydWUgdHJ5IHR5cGVvZiB2YXIgdm9pZCB3aGlsZSB3aXRoJykuc3BsaXQoJyAnKSxcbiAgZnVuY3Rpb24gKGtleXdvcmQpIHtcbiAgICByZXR1cm4gW2tleXdvcmQsIHtcbiAgICAgIHZhbHVlOiBrZXl3b3JkLFxuICAgICAgdHlwZTogJ2tleXdvcmQnXG4gICAgfV07XG4gIH1cbikpO1xuXG4vKipcbiAqIENvZGVNaXJyb3IgcHJvdmlkZXMgYWNjZXNzIHRvIGlubGluZSB2YXJpYWJsZXMgZGVmaW5lZCB3aXRoaW4gdGhlIG5vdGVib29rXG4gKiB1c2luZyBuZXN0ZWQgb2JqZWN0cyB0byByZXByZXNlbnQgZWFjaCBzY29wZSBsZXZlbCBpbiB0aGUgZWRpdG9yLiBUaGlzIHdpbGxcbiAqIHNxdWFzaCB0aGUgdmFyaWFibGVzIHRvIGEgc2luZ2xlIGxldmVsLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gc2NvcGVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xudmFyIHZhcnNUb09iamVjdCA9IGZ1bmN0aW9uIChzY29wZSwgaW5mbykge1xuICB2YXIgb2JqID0ge307XG5cbiAgd2hpbGUgKHNjb3BlICYmIHNjb3BlLm5hbWUpIHtcbiAgICBvYmpbc2NvcGUubmFtZV0gPSBpbmZvIHx8IHRydWU7XG4gICAgc2NvcGUgPSBzY29wZS5uZXh0O1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSB2YXJpYWJsZSBuYW1lIGlzIHZhbGlkLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gIG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnZhciBpc1ZhbGlkVmFyaWFibGVOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuICgvXlthLXpBLVpfJF1bMC05YS16QS1aXyRdKiQvKS50ZXN0KG5hbWUpO1xufTtcblxuLyoqXG4gKiBTYWRseSB3ZSBuZWVkIHRvIGRvIHNvbWUgYWRkaXRpb25hbCBwcm9jZXNzaW5nIGZvciBwcmltaXRpdmUgdHlwZXMgYW5kIGVuc3VyZVxuICogdGhleSB3aWxsIHVzZSB0aGUgcHJpbWl0aXZlIHByb3RvdHlwZSBmcm9tIHRoZSBjb3JyZWN0IGdsb2JhbCBjb250ZXh0LiBUaGlzXG4gKiBpcyBiZWNhdXNlIHByaW1pdGl2ZXMgbG9zZSB0aGVpciBwcm90b3R5cGVzIHdoZW4gYnJvdWdodCB0aHJvdWdoIGlmcmFtZXMsXG4gKiByZWdhcmRsZXNzIG9mIHRoZSBvcmlnaW4uXG4gKlxuICogQHBhcmFtICB7Kn0gICAgICBvYmplY3RcbiAqIEBwYXJhbSAge09iamVjdH0gZ2xvYmFsXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbnZhciBtYXBPYmplY3QgPSBmdW5jdGlvbiAob2JqZWN0LCBnbG9iYWwpIHtcbiAgLy8gU2FkbHkgd2UgbmVlZCB0byBkbyBzb21lIGFkZGl0aW9uYWwgaGVscCBmb3IgcHJpbWl0aXZlcyBzaW5jZSB0aGVcbiAgLy8gcHJvdG90eXBlIGlzIGxvc3QgYmV0d2VlbiB0aGUgaWZyYW1lIGFuZCBtYWluIGZyYW1lLlxuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZ2xvYmFsLlN0cmluZy5wcm90b3R5cGU7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gZ2xvYmFsLk51bWJlci5wcm90b3R5cGU7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIGdsb2JhbC5Cb29sZWFuLnByb3RvdHlwZTtcbiAgfVxuXG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBmbGF0IG9iamVjdCBvZiBhbGwgdmFsaWQgSmF2YVNjcmlwdCBsaXRlcmFsIHByb3BlcnR5IG5hbWVzLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gb2JqXG4gKiBAcGFyYW0gIHtPYmplY3R9IGdsb2JhbFxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG52YXIgZ2V0UHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIChjb250ZXh0LCBnbG9iYWwpIHtcbiAgLy8gQ3JlYXRlIHdpdGggYSBudWxsIHByb3RvdHlwZSwgb3RoZXJ3aXNlIHdlIGhhdmUgaXNzdWVzIHRyeWluZyB0byBzZXQgdGhlXG4gIC8vIGBfX3Byb3RvX19gIGtleS5cbiAgdmFyIHByb3BzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIG9iaiAgID0gY29udGV4dDtcblxuICAvKipcbiAgICogQWRkcyB0aGUgcHJvcGVydHkgdG8gdGhlIHByb3BlcnR5IG5hbWVzIG9iamVjdC4gU2tpcHMgYW55IHByb3BlcnR5IG5hbWVzXG4gICAqIHRoYXQgYXJlbid0IHZhbGlkIEphdmFTY3JpcHQgbGl0ZXJhbHMgc2luY2UgY29tcGxldGlvbiBzaG91bGQgbm90IGRpc3BsYXlcbiAgICogaW52YWxpZCBKYXZhU2NyaXB0IHN1Z2dlc3Rpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICovXG4gIHZhciBhZGRQcm9wID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgaWYgKCFpc1ZhbGlkVmFyaWFibGVOYW1lKHByb3BlcnR5KSkgeyByZXR1cm47IH1cblxuICAgIHZhciBwcm9wID0gcHJvcHNbcHJvcGVydHldID0ge307XG5cbiAgICAvLyBDaGVja2luZyB0eXBlb2Ygb24gdGhlIGB3aW5kb3dgIHByb3RvdHlwZSBpbiBGaXJlZm94IDI2IGNhdXNlcyBhbiBlcnJvclxuICAgIC8vIHRvIGJlIHRocm93bjogXCJJbGxlZ2FsIG9wZXJhdGlvbiBvbiBXcmFwcGVkTmF0aXZlIHByb3RvdHlwZSBvYmplY3RcIi5cbiAgICB0cnkge1xuICAgICAgLy8gTG9va3VwIGZyb20gdGhlIGN1cnJlbnQgY29udGV4dCBvYmplY3QgdG8gYXZvaWQgZmFpbHVyZXMgaW4gRmlyZWZveC5cbiAgICAgIHByb3AudHlwZSA9IHR5cGVvZiBjb250ZXh0W3Byb3BlcnR5XTtcbiAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgcHJvcC52YWx1ZSA9IHByb3BlcnR5O1xuICB9O1xuXG4gIC8vIFNhbml0aXplIHRoZSBvYmplY3QgdG8gYSB0eXBlIHRoYXQgd2UgY2FuIGdyYWIga2V5cyBmcm9tLiBJZiBpdCBzdGlsbCBpc24ndFxuICAvLyBhbiBvYmplY3QgYWZ0ZXIgYmVpbmcgc2FuaXRpemVkLCBicmVhayBiZWZvcmUgd2UgdHJ5IHRvIGdldCBrZXlzLlxuICBpZiAoIV8uaXNPYmplY3Qob2JqID0gbWFwT2JqZWN0KG9iaiwgZ2xvYmFsKSkpIHtcbiAgICByZXR1cm4gcHJvcHM7XG4gIH1cblxuICBkbyB7XG4gICAgXy5lYWNoKGdsb2JhbC5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLCBhZGRQcm9wKTtcbiAgfSB3aGlsZSAob2JqID0gZ2xvYmFsLk9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopKTtcblxuICByZXR1cm4gcHJvcHM7XG59O1xuXG4vKipcbiAqIENvbXBsZXRlcyB0aGUgY29tcGxldGlvbiB2YXJpYWJsZSBzdWdnZXN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gICBkYXRhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0XG4gKi9cbm1pZGRsZXdhcmUucmVnaXN0ZXIoJ2NvbXBsZXRpb246dmFyaWFibGUnLCBmdW5jdGlvbiAoZGF0YSwgbmV4dCkge1xuICB2YXIgdG9rZW4gPSBkYXRhLnRva2VuO1xuXG4gIC8vIENvbGxlY3QgcHJvcGVydGllcyBmcm9tIHRoZSBnbG9iYWwgZW52aXJvbm1lbnQgZmlyc3QuXG4gIF8uZXh0ZW5kKGRhdGEucmVzdWx0cywgZ2V0UHJvcGVydHlOYW1lcyhkYXRhLmNvbnRleHQsIGRhdGEud2luZG93KSk7XG5cbiAgLy8gRXh0ZW5kIHRoZSByZXN1bHRzIHdpdGggZ2xvYmFsIHZhcmlhYmxlcy5cbiAgXy5leHRlbmQoZGF0YS5yZXN1bHRzLCB2YXJzVG9PYmplY3QodG9rZW4uc3RhdGUuZ2xvYmFsVmFycykpO1xuXG4gIC8vIEV4dGVuZCB0aGUgcmVzdWx0cyB3aXRoIGFyZ3VtZW50cyBmcm9tIHRoZSBsb2NhbCBmdW5jdGlvbiBjb250ZXh0LlxuICBfLmV4dGVuZChkYXRhLnJlc3VsdHMsIHZhcnNUb09iamVjdCh0b2tlbi5zdGF0ZS5sb2NhbFZhcnMsIHtcbiAgICB0eXBlOiAnYXJndW1lbnQnXG4gIH0pKTtcblxuICAvLyBFeHRlbmQgdGhlIHZhcmlhYmxlcyBvYmplY3Qgd2l0aCBlYWNoIGNvbnRleHQgbGV2ZWxcbiAgdmFyIGNvbnRleHQgPSB0b2tlbi5zdGF0ZS5jb250ZXh0O1xuICB3aGlsZSAoY29udGV4dCkge1xuICAgIF8uZXh0ZW5kKGRhdGEucmVzdWx0cywgdmFyc1RvT2JqZWN0KGNvbnRleHQudmFycykpO1xuICAgIGNvbnRleHQgPSBjb250ZXh0LnByZXY7XG4gIH1cblxuICAvLyBGaW5hbGx5LCBleHRlbmQgb3ZlciB0aGUgdG9wIHdpdGgga2V5d29yZHMuXG4gIF8uZXh0ZW5kKGRhdGEucmVzdWx0cywgS0VZV09SRFMpO1xuXG4gIC8vIE92ZXJyaWRlIHRoZSBgYXJndW1lbnRzYCBkZWZpbml0aW9uIChidXQgb25seSBpZiB3ZSBoYXZlIG9uZSkuXG4gIGlmIChkYXRhLnJlc3VsdHMuYXJndW1lbnRzKSB7XG4gICAgZGF0YS5yZXN1bHRzLmFyZ3VtZW50cyA9IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBuZXh0KCk7XG59KTtcblxuLyoqXG4gKiBBdWdtZW50cyB0aGUgcHJvcGVydHkgY29tcGxldGlvbiBkYXRhIHdpdGggYWxsIHByb3BlcnR5IG5hbWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSAgIGRhdGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHRcbiAqL1xubWlkZGxld2FyZS5yZWdpc3RlcignY29tcGxldGlvbjpwcm9wZXJ0eScsIGZ1bmN0aW9uIChkYXRhLCBuZXh0KSB7XG4gIF8uZXh0ZW5kKGRhdGEucmVzdWx0cywgZ2V0UHJvcGVydHlOYW1lcyhkYXRhLmNvbnRleHQsIGRhdGEud2luZG93KSk7XG4gIHJldHVybiBuZXh0KCk7XG59KTtcblxuLyoqXG4gKiBDb3JyZWN0cyB0aGUgY29tcGxldGlvbiBsb29rdXAgY29udGV4dC4gTG9va3MgdXAgdmFyaWFibGVzL3Byb3BlcnRpZXMgaW5cbiAqIHRoZSBnbG9iYWwgc2NvcGUgYW5kIGNvZXJjZXMgb3RoZXIgdHlwZXMgZGV0ZWN0ZWQgYnkgQ29kZU1pcnJvciAoc3VjaCBhc1xuICogc3RyaW5ncyBhbmQgbnVtYmVycykgaW50byB0aGUgY29ycmVjdCByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBJbXBvcnRhbnQ6IE5lZWRzIHRvIHVzZSB0aGUgYGdsb2JhbGAgcHJvcGVydHkgd2hlbiByZWNyZWF0aW5nIG9iamVjdHMgc29cbiAqIHRoYXQgbWlkZGxld2FyZSB3aWxsIGNvbnRpbnVlIHRvIGdldCB0aGUgY29ycmVjdCBjb250ZXh0LiBPdGhlcndpc2UgeW91XG4gKiB3aWxsIGJlIHN3aXRjaGluZyBnbG9iYWwgY29udGV4dHMgdG8gdGhlIG1haW4gZnJhbWUgYW5kIHRoZXJlIHdpbGwgYmVcbiAqIGRpc2NyZXBhbmNpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9ICAgZGF0YVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbmV4dFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICovXG5taWRkbGV3YXJlLnJlZ2lzdGVyKCdjb21wbGV0aW9uOmNvbnRleHQnLCBmdW5jdGlvbiAoZGF0YSwgbmV4dCwgZG9uZSkge1xuICB2YXIgdG9rZW4gID0gZGF0YS50b2tlbjtcbiAgdmFyIHR5cGUgICA9IHRva2VuLnR5cGU7XG4gIHZhciBzdHJpbmcgPSB0b2tlbi5zdHJpbmc7XG5cbiAgaWYgKHR5cGUgPT09ICd2YXJpYWJsZScpIHtcbiAgICAvLyBDaGVjayBpZiB0aGUgY3VycmVudCB2YXJpYWJsZSBpcyBhIGdsb2JhbCBvciBhbiBhcmd1bWVudC5cbiAgICBkYXRhLmNvbnRleHQgPSBpc0luU2NvcGUodG9rZW4sIHN0cmluZykgPyBudWxsIDogZGF0YS5jb250ZXh0W3N0cmluZ107XG4gICAgcmV0dXJuIGRvbmUoKTtcbiAgfVxuXG4gIGlmICh0eXBlID09PSAncHJvcGVydHknKSB7XG4gICAgZGF0YS5jb250ZXh0ID0gbWFwT2JqZWN0KGRhdGEuY29udGV4dCwgZGF0YS53aW5kb3cpO1xuICAgIGRhdGEuY29udGV4dCA9IGRhdGEuY29udGV4dFtzdHJpbmddO1xuICAgIHJldHVybiBkb25lKCk7XG4gIH1cblxuICBpZiAodHlwZSA9PT0gJ2FycmF5Jykge1xuICAgIGRhdGEuY29udGV4dCA9IG5ldyBkYXRhLndpbmRvdy5BcnJheSgpO1xuICAgIHJldHVybiBkb25lKCk7XG4gIH1cblxuICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBkYXRhLmNvbnRleHQgPSBkYXRhLndpbmRvdy5TdHJpbmcoc3RyaW5nLnNsaWNlKDEsIC0xKSk7XG4gICAgcmV0dXJuIGRvbmUoKTtcbiAgfVxuXG4gIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgIGRhdGEuY29udGV4dCA9IGRhdGEud2luZG93Lk51bWJlcihzdHJpbmcpO1xuICAgIHJldHVybiBkb25lKCk7XG4gIH1cblxuICBpZiAodHlwZSA9PT0gJ3N0cmluZy0yJykge1xuICAgIHZhciBwYXJ0cyA9IHRva2VuLnN0cmluZy5zcGxpdCgnLycpO1xuICAgIGRhdGEuY29udGV4dCA9IG5ldyBkYXRhLndpbmRvdy5SZWdFeHAoXG4gICAgICBwYXJ0c1sxXS5yZXBsYWNlKCdcXFxcJywgJ1xcXFxcXFxcJyksIHBhcnRzWzJdXG4gICAgKTtcbiAgICByZXR1cm4gZG9uZSgpO1xuICB9XG5cbiAgaWYgKHR5cGUgPT09ICdhdG9tJykge1xuICAgIGlmIChzdHJpbmcgPT09ICd0cnVlJyB8fCBzdHJpbmcgPT09ICdmYWxzZScpIHtcbiAgICAgIGRhdGEuY29udGV4dCA9IGRhdGEud2luZG93LkJvb2xlYW4oc3RyaW5nKTtcbiAgICB9IGVsc2UgaWYgKHN0cmluZyA9PT0gJ251bGwnKSB7XG4gICAgICBkYXRhLmNvbnRleHQgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAoc3RyaW5nID09PSAndW5kZWZpbmVkJykge1xuICAgICAgZGF0YS5jb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiBkb25lKCk7XG4gIH1cblxuICBkYXRhLmNvbnRleHQgPSBudWxsO1xuICByZXR1cm4gZG9uZSgpO1xufSk7XG5cbi8qKlxuICogRmlsdGVyIGF1dG9jb21wbGV0aW9uIHN1Z2dlc3Rpb25zLiBDaGVja3MgdGhlIGdpdmVuIHN1Z2dlc3Rpb24gaXMgYWN0dWFsbHlcbiAqIHRoZSBzdGFydCBvZiB0aGUgY3VycmVudCB0b2tlbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gICBkYXRhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gKi9cbm1pZGRsZXdhcmUucmVnaXN0ZXIoJ2NvbXBsZXRpb246ZmlsdGVyJywgZnVuY3Rpb24gKGRhdGEsIG5leHQsIGRvbmUpIHtcbiAgdmFyIHZhbHVlICA9IGRhdGEucmVzdWx0LnZhbHVlO1xuICB2YXIgc3RyaW5nID0gZGF0YS50b2tlbi5zdHJpbmc7XG4gIHZhciBsZW5ndGggPSB2YWx1ZS5sZW5ndGggPj0gc3RyaW5nLmxlbmd0aDtcblxuICByZXR1cm4gZG9uZShudWxsLCBsZW5ndGggJiYgdmFsdWUuc3Vic3RyKDAsIHN0cmluZy5sZW5ndGgpID09PSBzdHJpbmcpO1xufSk7XG4iLCJ2YXIgXyAgICAgICAgICA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSAgID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciBtaWRkbGV3YXJlID0gcmVxdWlyZSgnLi4vLi4vc3RhdGUvbWlkZGxld2FyZScpO1xudmFyIENvZGVNaXJyb3IgPSByZXF1aXJlKCdjb2RlbWlycm9yJyk7XG5cbnJlcXVpcmUoJy4vdWknKTtcbnJlcXVpcmUoJy4vYWpheCcpO1xucmVxdWlyZSgnLi9zYW5kYm94Jyk7XG5yZXF1aXJlKCcuL2NvbXBsZXRpb24nKTtcbnJlcXVpcmUoJy4vcmVzdWx0LWNlbGwnKTtcbnJlcXVpcmUoJy4vcGVyc2lzdGVuY2UnKTtcbnJlcXVpcmUoJy4vYXBwbGljYXRpb24nKTtcbnJlcXVpcmUoJy4vYXV0aGVudGljYXRpb24nKTtcblxuLy8gVHJpZ2dlciBtaWRkbGV3YXJlIGZvciBrZXlkb3duIGV2ZW50cy5cbkJhY2tib25lLiQoZG9jdW1lbnQpLm9uKCdrZXlkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgdmFyIGtleU5hbWUgPSBDb2RlTWlycm9yLmtleU5hbWUoZSwgZS53aGljaCA9PT0gMTYpO1xuXG4gIG1pZGRsZXdhcmUudHJpZ2dlcigna2V5ZG93bjonICsga2V5TmFtZSwge1xuICAgIHByZXZlbnREZWZhdWx0OiBfLmJpbmQoZS5wcmV2ZW50RGVmYXVsdCwgZSlcbiAgfSk7XG59KTtcbiIsInZhciBfICAgICAgICAgID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIGNvbmZpZyAgICAgPSByZXF1aXJlKCcuLi8uLi9zdGF0ZS9jb25maWcnKTtcbnZhciBtaWRkbGV3YXJlID0gcmVxdWlyZSgnLi4vLi4vc3RhdGUvbWlkZGxld2FyZScpO1xuXG52YXIgT1BFTl9DT0RFX0JMT0NLICAgICA9ICdgYGBqYXZhc2NyaXB0JztcbnZhciBDTE9TRV9DT0RFX0JMT0NLICAgID0gJ2BgYCc7XG52YXIgTUVUQV9EQVRBX0RFTElNSVRFUiA9ICctLS0nO1xuXG4vKipcbiAqIFNldCB0aGUgZGVmYXVsdCBjb250ZW50IGludG8gdGhlIGNvbmZpZyBvYmplY3QuXG4gKi9cbmNvbmZpZy5zZXQoJ2RlZmF1bHRDb250ZW50JywgW1xuICBPUEVOX0NPREVfQkxPQ0ssXG4gICcnLFxuICBDTE9TRV9DT0RFX0JMT0NLXG5dLmpvaW4oJ1xcbicpKTtcblxuLyoqXG4gKiBTZXJpYWxpemUgdGhlIG5vdGVib29rIHRvIGEgc3RyaW5nIGJhc2VkIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gICBkYXRhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gKi9cbm1pZGRsZXdhcmUucmVnaXN0ZXIoJ3BlcnNpc3RlbmNlOnNlcmlhbGl6ZScsIGZ1bmN0aW9uIChkYXRhLCBuZXh0LCBkb25lKSB7XG4gIHZhciBoYXNDb250ZW50ID0gZmFsc2U7XG5cbiAgLy8gUHJlcGVuZCB0aGUgZnJvbnQgbWF0dGVyLlxuICBkYXRhLmNvbnRlbnQgPSBbXG4gICAgTUVUQV9EQVRBX0RFTElNSVRFUixcbiAgICBfLm1hcChkYXRhLm1ldGEsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICByZXR1cm4ga2V5ICsgJzogJyArIHZhbHVlO1xuICAgIH0pLmpvaW4oJ1xcbicpLFxuICAgIE1FVEFfREFUQV9ERUxJTUlURVJcbiAgXS5qb2luKCdcXG4nKTtcblxuICAvLyBTcGxpdCB0aGUgbWFya2Rvd24gY29udGVudCBmcm9tIHRoZSBmcm9udCBtYXR0ZXIuXG4gIGRhdGEuY29udGVudCArPSAnXFxuXFxuJztcblxuICAvLyBBcHBlbmRzIHRoZSBub3RlYm9vayBjb250ZW50IGFzIE1hcmtkb3duLlxuICBkYXRhLmNvbnRlbnQgKz0gXy5jaGFpbihkYXRhLmNlbGxzKVxuICAgIC5zbGljZSgpXG4gICAgLnJldmVyc2UoKVxuICAgIC5maWx0ZXIoZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgIGlmICghaGFzQ29udGVudCAmJiAhL15cXHMqJC8udGVzdChjZWxsLnZhbHVlKSkge1xuICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc0NvbnRlbnQ7XG4gICAgfSlcbiAgICAucmV2ZXJzZSgpXG4gICAgLm1hcChmdW5jdGlvbiAoY2VsbCkge1xuICAgICAgaWYgKGNlbGwudHlwZSA9PT0gJ3RleHQnKSB7IHJldHVybiBjZWxsLnZhbHVlOyB9XG4gICAgICAvLyBXcmFwIGNvZGUgY2VsbHMgYXMgYSBKYXZhU2NyaXB0IGNvZGUgYmxvY2sgZm9yIE1hcmtkb3duXG4gICAgICByZXR1cm4gW09QRU5fQ09ERV9CTE9DSywgY2VsbC52YWx1ZSwgQ0xPU0VfQ09ERV9CTE9DS10uam9pbignXFxuJyk7XG4gICAgfSkudmFsdWUoKS5qb2luKCdcXG5cXG4nKTtcblxuICByZXR1cm4gZG9uZSgpO1xufSk7XG5cbi8qKlxuICogRGVzc2VyaWFsaXplIHRoZSBub3RlYm9vayBmcm9tIGEgc3RyaW5nIGludG8gYW4gYXJyYXkgb2YgY2VsbCBkYXRhLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSAgIGRhdGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAqL1xubWlkZGxld2FyZS5yZWdpc3RlcigncGVyc2lzdGVuY2U6ZGVzZXJpYWxpemUnLCBmdW5jdGlvbiAoZGF0YSwgbmV4dCwgZG9uZSkge1xuICB2YXIgcHJlYW1ibGVSZWdFeHAgPSBuZXcgUmVnRXhwKFtcbiAgICAnXicsXG4gICAgTUVUQV9EQVRBX0RFTElNSVRFUixcbiAgICAnXFxcXG4oW1xcXFxTXFxcXHNdKylcXFxcbicsXG4gICAgTUVUQV9EQVRBX0RFTElNSVRFUixcbiAgICAnXFxcXG4nXG4gIF0uam9pbignJykpO1xuXG4gIC8vIFJlcGxhY2UgcG90ZW50aWFsIG1ldGEgZGF0YSB3aXRoIG5vdGhpbmcgYW5kIHBhcnNlIGl0IHNlcGFyYXRlbHkuXG4gIHZhciBjb250ZW50ID0gZGF0YS5jb250ZW50LnJlcGxhY2UocHJlYW1ibGVSZWdFeHAsIGZ1bmN0aW9uIChjb250ZW50LCBib2R5KSB7XG4gICAgLy8gU3BsaXQgZWFjaCBsaW5lIG9mIHRoZSBtZXRhZGF0YSBhbmQgc2V0IG9uIHRoZSBgZGF0YWAgZXhwb3J0IG9iamVjdC5cbiAgICBfLmVhY2goYm9keS5zcGxpdCgnXFxuJyksIGZ1bmN0aW9uIChtZXRhKSB7XG4gICAgICB2YXIgcGFydHMgPSBtZXRhLnNwbGl0KCc6ICcpO1xuXG4gICAgICAvLyBJZ25vcmUgdGhlIGxpbmUgaWYgd2UgZG9uJ3QgaGF2ZSBhIGB0aXRsZTogZGF0YWAgY29tYmluYXRpb24uXG4gICAgICBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGRhdGEubWV0YVtwYXJ0c1swXV0gPSBwYXJ0c1sxXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiAnJztcbiAgfSk7XG5cbiAgZGF0YS5jZWxscyA9IF8uY2hhaW4oY29udGVudC5zcGxpdCgnXFxuJykpLnJlZHVjZShmdW5jdGlvbiAoY2VsbHMsIGxpbmUpIHtcbiAgICB2YXIgY2VsbCA9IGNlbGxzW2NlbGxzLmxlbmd0aCAtIDFdO1xuXG4gICAgLy8gQW4gb3BlbiBjb2RlIGJsb2NrIHdpbGwgcmV0dXJuIGEgbmV3IGNvZGUgY2VsbC5cbiAgICBpZiAobGluZSA9PT0gT1BFTl9DT0RFX0JMT0NLKSB7XG4gICAgICBjZWxscy5wdXNoKHtcbiAgICAgICAgdHlwZTogICdjb2RlJyxcbiAgICAgICAgdmFsdWU6ICcnXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGNlbGxzO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGhpdCBhIGNsb3NpbmcgY29kZSBibG9jayBhbmQgd2UgYXJlIGEgY29kZSBjZWxsLCByZXR1cm4gYSBmcmVzaFxuICAgIC8vIHRleHQgY2VsbC5cbiAgICBpZiAoY2VsbC50eXBlID09PSAnY29kZScgJiYgbGluZSA9PT0gQ0xPU0VfQ09ERV9CTE9DSykge1xuICAgICAgY2VsbHMucHVzaCh7XG4gICAgICAgIHR5cGU6ICAndGV4dCcsXG4gICAgICAgIHZhbHVlOiAnJ1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBjZWxscztcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2Ugd2UgY2FuIGp1c3QgYXBwZW5kIHRvIHRoZSBjZWxsIGNvbnRlbnQgYW5kIHJldHVybiB0aGUgY2VsbC5cbiAgICBjZWxsLnZhbHVlICs9IGxpbmUgKyAnXFxuJztcbiAgICByZXR1cm4gY2VsbHM7XG4gIH0sIFt7XG4gICAgdHlwZTogICd0ZXh0JyxcbiAgICB2YWx1ZTogJydcbiAgfV0pLmZpbHRlcihmdW5jdGlvbiAoY2VsbCwgaW5kZXgsIG5vdGVib29rKSB7XG4gICAgY2VsbC52YWx1ZSA9IGNlbGwudmFsdWUuc2xpY2UoXG4gICAgICAvLyBUZXh0IGNlbGxzIHdpbGwgc3RhcnQgd2l0aCBhIG5ldyBsaW5lLlxuICAgICAgY2VsbC50eXBlID09PSAndGV4dCcgJiYgY2VsbC52YWx1ZS5jaGFyQXQoMCkgPT09ICdcXG4nID8gMSAgOiAwLFxuICAgICAgLy8gVGV4dCBjZWxscyB3aWxsIGhhdmUgYSB0cmFpbGluZyBuZXcgbGluZSAoaWYgdGhleSBhcmVuJ3QgdGhlIGxhc3RcbiAgICAgIC8vIGNlbGwgaW4gdGhlIHdob2xlIG5vdGVib29rKS5cbiAgICAgIGNlbGwudHlwZSA9PT0gJ3RleHQnICYmIGluZGV4ICE9PSBub3RlYm9vay5sZW5ndGggLSAxID8gLTIgOiAtMVxuICAgICk7XG5cbiAgICAvLyBSZW1vdmVzIGVtcHR5IHRleHQgY2VsbHMuXG4gICAgcmV0dXJuICEoY2VsbC50eXBlID09PSAndGV4dCcgJiYgY2VsbC52YWx1ZSA9PT0gJycpO1xuICB9KS52YWx1ZSgpO1xuXG4gIHJldHVybiBkb25lKCk7XG59KTtcblxuLyoqXG4gKiBEZWZhdWx0IG1pZGRsZXdhcmUgdGhhdCBsb2FkcyB0aGUgaW5pdGlhbCBub3RlYm9vayBhcyBhIHNpbmdsZSBjb2RlIGNlbGwuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9ICAgZGF0YVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbmV4dFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICovXG5taWRkbGV3YXJlLnJlZ2lzdGVyKCdwZXJzaXN0ZW5jZTpsb2FkJywgZnVuY3Rpb24gKGRhdGEsIG5leHQsIGRvbmUpIHtcbiAgZGF0YS5pZCAgICAgID0gbnVsbDtcbiAgZGF0YS5jb250ZW50ID0gY29uZmlnLmdldCgnZGVmYXVsdENvbnRlbnQnKTtcblxuICByZXR1cm4gZG9uZSgpO1xufSk7XG5cbi8qKlxuICogQWRkIGEgXCIoY2xvbmVkKVwiIG1hcmtlciB0byBjbG9uZWQgbm90ZWJvb2sgdGl0bGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSAgIGRhdGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHRcbiAqL1xubWlkZGxld2FyZS5yZWdpc3RlcigncGVyc2lzdGVuY2U6Y2xvbmUnLCBmdW5jdGlvbiAoZGF0YSwgbmV4dCkge1xuICBkYXRhLm1ldGEudGl0bGUgKz0gJyAoY2xvbmVkKSc7XG5cbiAgcmV0dXJuIG5leHQoKTtcbn0pO1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgcGVyc2lzdGVuY2UgbWV0YSBkYXRhIHdoZW4gd2UgYXR0ZW1wdCB0byBzYXZlLlxuICovXG5taWRkbGV3YXJlLnJlZ2lzdGVyKCdwZXJzaXN0ZW5jZTpzYXZlJywgZnVuY3Rpb24gKGRhdGEsIG5leHQpIHtcbiAgXy5leHRlbmQoZGF0YS5tZXRhLCB7XG4gICAgc2l0ZTogICAgICAgICAgICAgICBjb25maWcuZ2V0KCd1cmwnKSxcbiAgICBhcGlOb3RlYm9va1ZlcnNpb246IHtcIm5hbWVcIjpcImFwaS1ub3RlYm9va1wiLFwidmVyc2lvblwiOlwiMS4xLjI1XCIsXCJkZXNjcmlwdGlvblwiOlwiRXhlY3V0YWJsZSBKYXZhU2NyaXB0IGVudmlyb25tZW50IGZvciBydW5uaW5nIEFQSSBleGFtcGxlcy5cIixcInByaXZhdGVcIjp0cnVlLFwiYnJvd3NlcmlmeVwiOntcInRyYW5zZm9ybVwiOltcImRvbWJhcnNpZnlcIixcImVudmlmeS1jb25maWdcIl19LFwiZGVwZW5kZW5jaWVzXCI6e1wiYXN5bmNcIjpcIjAuMi45XCIsXCJiYWNrYm9uZVwiOlwiMS4xLjBcIixcImJhY2tib25lLm5hdGl2ZVwiOlwiMS4wLjBcIixcImNoYW5nZS1jYXNlXCI6XCIxLjAuNlwiLFwiY29kZW1pcnJvclwiOlwiNC4xLjBcIixcImNvbmZpZ1wiOlwiMC40LjMzXCIsXCJjc3MtY29tcG9uZW50XCI6XCIwLjAuMlwiLFwiZG9taWZ5XCI6XCIxLjIuMVwiLFwiZXM2LWNvbGxlY3Rpb25zXCI6XCIwLjIuMFwiLFwiZXNjYXBlLXJlZ2V4cFwiOlwiMC4wLjFcIixcImZvcmVhY2hcIjpcIjIuMC40XCIsXCJrYW1pbm9cIjpcImdpdDovL2dpdGh1Yi5jb20vdGlsZGVpby9rYW1pbm8uanMjdjAuMC4yXCIsXCJsb2FkLXNjcmlwdFwiOlwiMC4wLjJcIixcIm1hcmtlZFwiOlwiMC4zLjBcIixcIm1pbWUtY29tcG9uZW50XCI6XCIwLjAuMVwiLFwibm9ybWFsaXplLWNzc1wiOlwiMi4zLjBcIixcInFzXCI6XCIwLjYuNlwiLFwicmFtbC1wYXJzZXJcIjpcIjAuOC43XCIsXCJzdG9yZVwiOlwiMS4zLjE0XCIsXCJ1bmRlcnNjb3JlXCI6XCIxLjYuMFwiLFwidXJpdGVtcGxhdGVcIjpcIjAuMy40XCJ9LFwiZGV2RGVwZW5kZW5jaWVzXCI6e1wiYnJmc1wiOlwifjAuMi4xXCIsXCJicm93c2VyaWZ5XCI6XCIzLjI4LjBcIixcImNoYWlcIjpcIn4xLjkuMFwiLFwiZG9tYmFyc1wiOlwifjAuNS4yXCIsXCJkb21iYXJzaWZ5XCI6XCJ+MC4wLjNcIixcImVudmlmeS1jb25maWdcIjpcIn4wLjAuMVwiLFwiZ3J1bnRcIjpcIn4wLjQuMlwiLFwiZ3J1bnQtYnJvd3NlcmlmeVwiOlwifjEuMy4wXCIsXCJncnVudC1jbGlcIjpcIn4wLjEuMTFcIixcImdydW50LWNvbnRyaWItY2xlYW5cIjpcIn4wLjUuMFwiLFwiZ3J1bnQtY29udHJpYi1jb25uZWN0XCI6XCJ+MC42LjBcIixcImdydW50LWNvbnRyaWItY29weVwiOlwifjAuNS4wXCIsXCJncnVudC1jb250cmliLWpzaGludFwiOlwifjAuOC4wXCIsXCJncnVudC1jb250cmliLXN0eWx1c1wiOlwifjAuMTIuMFwiLFwiZ3J1bnQtY29udHJpYi13YXRjaFwiOlwifjAuNS4zXCIsXCJncnVudC1uZXdlclwiOlwifjAuNi4wXCIsXCJncnVudC1zaGVsbFwiOlwifjAuNy4wXCIsXCJsb2FkLWdydW50LXRhc2tzXCI6XCJ+MC4zLjBcIixcIm1vY2hhXCI6XCJ+MS4xNy4xXCIsXCJtb2NoYS1waGFudG9tanNcIjpcIn4zLjMuMFwiLFwicmVxdWVzdFwiOlwifjIuMzQuMFwiLFwic2lub25cIjpcIn4xLjcuM1wiLFwic2lub24tY2hhaVwiOlwifjIuNS4wXCIsXCJ1Z2xpZnlpZnlcIjpcIn4xLjIuMVwifSxcInNjcmlwdHNcIjp7XCJidWlsZFwiOlwiLi9ub2RlX21vZHVsZXMvLmJpbi9ncnVudCBidWlsZFwiLFwidGVzdFwiOlwiLi9ub2RlX21vZHVsZXMvLmJpbi9ncnVudCB0ZXN0XCIsXCJzdGFydFwiOlwibm9kZSBzZXJ2ZXJcIn0sXCJyZXBvc2l0b3J5XCI6e1widHlwZVwiOlwiZ2l0XCIsXCJ1cmxcIjpcImdpdDovL2dpdGh1Yi5jb20vbXVsZXNvZnQvYXBpLW5vdGVib29rLmdpdFwifSxcImJ1Z3NcIjp7XCJ1cmxcIjpcImh0dHBzOi8vZ2l0aHViLmNvbS9tdWxlc29mdC9hcGktbm90ZWJvb2svaXNzdWVzXCJ9LFwiYXV0aG9yXCI6XCJGb3JtaWRhYmxlIExhYnNcIixcImxpY2Vuc2VcIjpcIkJTRFwiLFwicmVhZG1lRmlsZW5hbWVcIjpcIlJFQURNRS5tZFwifS52ZXJzaW9uXG4gIH0pO1xuXG4gIHJldHVybiBuZXh0KCk7XG59KTtcbiIsInZhciBfICAgICAgICAgICAgICA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciB0eXBlT2YgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL2xpYi90eXBlJyk7XG52YXIgSW5zcGVjdG9yICAgICAgPSByZXF1aXJlKCcuLi8uLi92aWV3cy9pbnNwZWN0b3InKTtcbnZhciBFcnJvckluc3BlY3RvciA9IHJlcXVpcmUoJy4uLy4uL3ZpZXdzL2Vycm9yLWluc3BlY3RvcicpO1xudmFyIG1pZGRsZXdhcmUgICAgID0gcmVxdWlyZSgnLi4vLi4vc3RhdGUvbWlkZGxld2FyZScpO1xuXG4vKipcbiAqIFJlbmRlciB0aGUgcmVzdWx0IGNlbGwgY29udGVudHMuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSAgIGRhdGFcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBuZXh0XG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gZG9uZVxuICovXG5taWRkbGV3YXJlLnJlZ2lzdGVyKCdyZXN1bHQ6cmVuZGVyJywgZnVuY3Rpb24gKGRhdGEsIG5leHQsIGRvbmUpIHtcbiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgd2luZG93OiAgZGF0YS53aW5kb3csXG4gICAgaW5zcGVjdDogZGF0YS5pbnNwZWN0XG4gIH07XG5cbiAgdmFyIGluc3BlY3RvcjtcblxuICBpZiAoIWRhdGEuaXNFcnJvcikge1xuICAgIGluc3BlY3RvciA9IG5ldyBJbnNwZWN0b3Iob3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgaW5zcGVjdG9yID0gbmV3IEVycm9ySW5zcGVjdG9yKG9wdGlvbnMpO1xuICB9XG5cbiAgaW5zcGVjdG9yLnJlbmRlcigpLmFwcGVuZFRvKGRhdGEuZWwpO1xuXG4gIC8vIE9wZW5zIHRoZSBpbnNwZWN0b3IgYXV0b21hdGljYWxseSB3aGVuIHRoZSB0eXBlIGlzIGFuIG9iamVjdC5cbiAgdmFyIHR5cGUgPSB0eXBlT2YoZGF0YS5pbnNwZWN0KTtcblxuICBpZiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2FycmF5Jykge1xuICAgIGluc3BlY3Rvci5vcGVuKCk7XG4gIH1cblxuICByZXR1cm4gZG9uZShudWxsLCBfLmJpbmQoaW5zcGVjdG9yLnJlbW92ZSwgaW5zcGVjdG9yKSk7XG59KTtcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG52YXIgbG9hZFNjcmlwdCA9IHJlcXVpcmUoJy4uLy4uL2xpYi9icm93c2VyL2xvYWQtc2NyaXB0Jyk7XG52YXIgbWlkZGxld2FyZSA9IHJlcXVpcmUoJy4uLy4uL3N0YXRlL21pZGRsZXdhcmUnKTtcblxudmFyIEFTWU5DX1RJTUVPVVQgPSAyMDAwO1xudmFyIFBST1hZX1VSTCAgICAgPSB7fS5wcm94eSAmJiB7fS5wcm94eS51cmw7XG5cbi8qKlxuICogU2V0IHRoZSBzb21lIGFkZGl0aW9uYWwgY29udGV4dCB2YXJpYWJsZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9ICAgY29udGV4dFxuICogQHBhcmFtIHtGdW5jdGlvbn0gbmV4dFxuICovXG5taWRkbGV3YXJlLnJlZ2lzdGVyKCdzYW5kYm94OmNvbnRleHQnLCBmdW5jdGlvbiAoY29udGV4dCwgbmV4dCkge1xuICAvLyBVbmZvcnR1bmF0ZWx5IGl0IGlzbid0IGFzIGVhc3kgYXMgdGhpcyBzaW5jZSB3ZSBoYXZlIHNjb3BpbmcgaXNzdWVzIHdpdGhcbiAgLy8gdGhlIHdyb25nIHdpbmRvdyBvYmplY3QuIEl0IHdvdWxkIGxvYWQgdGhlIHNjcmlwdCBpbiB0aGUgd3Jvbmcgd2luZG93LlxuICBjb250ZXh0LmxvYWQgICAgPSBmdW5jdGlvbiAoLyogc3JjLCBkb25lICovKSB7fTtcbiAgY29udGV4dC5hc3luYyAgID0gZnVuY3Rpb24gKCkge307XG4gIGNvbnRleHQudGltZW91dCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIHJldHVybiBuZXh0KCk7XG59KTtcblxuLyoqXG4gKiBTZXRzIHVwIHRoZSBwcmUtZXhlY3V0aW9uIHBsdWdpbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gICBkYXRhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gKi9cbm1pZGRsZXdhcmUucmVnaXN0ZXIoJ3NhbmRib3g6ZXhlY3V0ZScsIGZ1bmN0aW9uIChkYXRhLCBuZXh0LCBkb25lKSB7XG4gIC8qIGdsb2JhbCBBcHAgKi9cbiAgdmFyIGNvZGUgICAgPSAnd2l0aCAod2luZG93LmNvbnNvbGUuX25vdGVib29rQXBpKSB7XFxuJyArIGRhdGEuY29kZSArICdcXG59JztcbiAgdmFyIGFzeW5jICAgPSBmYWxzZTtcbiAgdmFyIGV4ZWMgICAgPSB7fTtcbiAgdmFyIGNvbnRleHQgPSBkYXRhLmNvbnRleHQ7XG4gIHZhciBmYWxsYmFjaztcblxuICAvLyBQcm92aWRlcyBhZGRpdGlvbmFsIGNvbnRleHQgdW5kZXIgdGhlIGBjb25zb2xlYCBvYmplY3QuIFRoaXMgd29ya3MgaW4gdGhlXG4gIC8vIHNhbWUgZmFzaGlvbiBhcyBob3cgQ2hyb21lJ3MgY29uc29sZSBpcyBpbXBsZW1lbnRlZCwgYW5kIGhhcyB0aGUgYmVuZWZpdFxuICAvLyBvZiBhbnkgY29udGV4dCB2YXJpYWJsZXMgbm90IHdpcGluZyBvdXQgYHdpbmRvd2AgdmFyaWFibGVzICh0aGV5IHdpbGxcbiAgLy8ganVzdCBiZSBzaGFkb3dlZCB1c2luZyBgd2l0aGApLlxuICBkYXRhLndpbmRvdy5jb25zb2xlID0gZGF0YS53aW5kb3cuY29uc29sZSB8fCB7fTtcbiAgZGF0YS53aW5kb3cuY29uc29sZS5fbm90ZWJvb2tBcGkgPSBjb250ZXh0O1xuXG4gIC8qKlxuICAgKiBDb21wbGV0ZWQgY29kZSBjZWxsIGV4ZWN1dGlvbiBhbmQgcmVtb3ZlcyBsZWZ0IG92ZXIgY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIHtFcnJvcn0gIGVyclxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKi9cbiAgdmFyIGNvbXBsZXRlID0gZnVuY3Rpb24gKGVyciwgcmVzcG9uc2UpIHtcbiAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGZhbGxiYWNrKTtcbiAgICBkZWxldGUgQXBwLl9leGVjdXRlV2luZG93O1xuICAgIGRlbGV0ZSBBcHAuX2V4ZWN1dGVDb250ZXh0O1xuICAgIGRlbGV0ZSBkYXRhLndpbmRvdy5jb25zb2xlLl9ub3RlYm9va0FwaTtcbiAgICByZXR1cm4gZG9uZShlcnIsIHJlc3BvbnNlKTtcbiAgfTtcblxuICAvKipcbiAgICogUGFzcyBpbiBhIHRpbWVvdXQgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byByZXNldCB0aGUgYXN5bmMgdGltZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICAgKi9cbiAgdmFyIHRpbWVvdXQgPSBjb250ZXh0LnRpbWVvdXQgPSBmdW5jdGlvbiAobXMpIHtcbiAgICB2YXIgdGltZW91dCA9ICttcztcblxuICAgIC8vIENsZWFycyB0aGUgb2xkIHRpbWVvdXQgYmVmb3JlIHNldHRpbmcgdGhlIG5ldyBvbmUuXG4gICAgd2luZG93LmNsZWFyVGltZW91dChmYWxsYmFjayk7XG5cbiAgICAvLyBCcmVhayBpbW1lZGlhdGVseSBpZiB0aGUgdGltZW91dCBpcyBhbiB1bmtub3duIG51bWJlci5cbiAgICBpZiAoaXNOYU4odGltZW91dCkgfHwgdGltZW91dCA8IDApIHtcbiAgICAgIHJldHVybiBjb21wbGV0ZShuZXcgRXJyb3IoJ0Nhbm5vdCB1c2UgdGltZW91dCBvZiAnICsgbXMgKyAnbXMnKSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIGEgZmFsbGJhY2sgY2F0Y2ggaW4gY2FzZSB3ZSBhcmUgdXNpbmcgdGhlIGBhc3luY2AgZnVuY3Rpb24gYWNjaWRlbnRseVxuICAgIC8vIG9yIG5vdCBoYW5kbGluZyBzb21lIGVkZ2UgY2FzZS4gVGhpcyBpZGVhIGNvbWVzIGZyb20gYE1vY2hhYCBhc3luYyB0ZXN0cyxcbiAgICAvLyBidXQgd2UgY2hhbmdlIHRoZSB0aW1lb3V0IGJ5IHVzaW5nIGB0aW1lb3V0ID0gSW5maW5pdHlgLlxuICAgIGlmIChpc0Zpbml0ZSh0aW1lb3V0KSkge1xuICAgICAgZmFsbGJhY2sgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjb21wbGV0ZShcbiAgICAgICAgICBuZXcgRXJyb3IoJ1RpbWVvdXQgb2YgJyArIHRpbWVvdXQgKyAnbXMgZXhjZWVkZWQnKSwgZXhlY1xuICAgICAgICApO1xuICAgICAgfSwgdGltZW91dCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsIHRoZSBhc3luYyBmdW5jdGlvbiB3aXRoaW4gYSBjb2RlIGNlbGwgdG8gdHJpZ2dlciBhc3luYyBtb2RlLiBJdCB3aWxsXG4gICAqIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gZW5kIHRoZSBhc3luYyBleGVjdXRpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKi9cbiAgY29udGV4dC5hc3luYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTZXRzIHRoZSBhc3luYyBmbGFnIHRvIHRydWUgc28gd2UgZG9uJ3QgdHJpZ2dlciB0aGUgY2FsbGJhY2sgaW1tZWRpYXRlbHkuXG4gICAgYXN5bmMgPSB0cnVlO1xuXG4gICAgLy8gUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgZXhlY3V0ZWQgdG8gZW5kIHRoZSBhc3luYyBvcGVyYXRpb24gaW5zaWRlXG4gICAgLy8gdGhlIGNlbGwuIFRoaXMgaXMgaGFuZHkgZm9yIGFsbCBzb3J0cyBvZiB0aGluZ3MsIGxpa2UgYWpheCByZXF1ZXN0cy5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XG4gICAgICAvLyBQYXNzZXMgaXRlcmF0aW9uIG9mZiB0byB0aGUgbWlkZGxld2FyZSBzaW5jZSBpdCBhbHJlYWR5IGNhdGVycyBmb3JcbiAgICAgIC8vIGFzeW5jIGV4ZWN1dGlvbiBsaWtlIHRoaXMuIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyB0d28gcGFyYW1ldGVycywgbGlrZVxuICAgICAgLy8gYSBub3JtYWwgYXN5bmMgY2FsbGJhY2ssIGJ1dCBpbnN0ZWFkIG9mZiBwYXNzaW5nIGl0IGRpcmVjdGx5IG9mZiB0b1xuICAgICAgLy8gYGRvbmVgLCB3ZSBuZWVkIHRvIHRyYW5zZm9ybSBpdCBpbnRvIHRoZSBkYXRhIGZvcm1hdCB0aGUgcmVzdWx0XG4gICAgICAvLyBjZWxsIHVuZGVyc3RhbmRzIGFuZCBwYXNzIGBudWxsYCBhcyB0aGUgZXJyb3Igc2luY2Ugd2UgZG9uJ3QgaGF2ZSBhblxuICAgICAgLy8gZXhlY3V0aW9uIGVycm9yIGluIHRoaXMgY29udGV4dCAoaXQgY2FtZSBmcm9tIHRoZSBzYW5kYm94KS5cbiAgICAgIGV4ZWMucmVzdWx0ICA9IGVyciB8fCByZXN1bHQ7XG4gICAgICBleGVjLmlzRXJyb3IgPSAhIWVycjtcbiAgICAgIHJldHVybiBjb21wbGV0ZShudWxsLCBleGVjKTtcbiAgICB9O1xuICB9O1xuXG4gIC8qIGpzaGludCBldmlsOiB0cnVlICovXG4gIGRhdGEud2luZG93LmV2YWwoW1xuICAgICdjb25zb2xlLl9ub3RlYm9va0FwaS5sb2FkID0gZnVuY3Rpb24gKHNyYywgZG9uZSkgeycsXG4gICAgJyAgY29uc29sZS5fbm90ZWJvb2tBcGkudGltZW91dChJbmZpbml0eSk7JywgLy8gSW5jcmVhc2UgQUpBWCB0aW1lb3V0LlxuICAgICcgIGlmICghL15odHRwcz86XFxcXC9cXFxcLy8udGVzdChzcmMpKSB7JyxcbiAgICAnICAgIHNyYyA9ICcgKyAoUFJPWFlfVVJMID8gJ1wiJyArIFBST1hZX1VSTCArICcvXCIgKyAnIDogJycpICsgJ3NyYycsXG4gICAgJyAgfScsXG4gICAgJyAgcmV0dXJuICgnICsgbG9hZFNjcmlwdCArICcpKHNyYywgZG9uZSB8fCBjb25zb2xlLl9ub3RlYm9va0FwaS5hc3luYygpKTsnLFxuICAgICd9OydcbiAgXS5qb2luKCdcXG4nKSk7XG5cbiAgLy8gVXNlcyBhbiBhc3luY2hyb25vdXMgY2FsbGJhY2sgdG8gY2xlYXIgdGhlIGFueSBwb3NzaWJsZSBzdGFjayB0cmFjZVxuICAvLyB0aGF0IHdvdWxkIGluY2x1ZGUgaW1wbGVtZW50YXRpb24gbG9naWMuXG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgIEFwcC5fZXhlY3V0ZVdpbmRvdyAgPSBkYXRhLndpbmRvdztcbiAgICBBcHAuX2V4ZWN1dGVDb250ZXh0ID0gY29udGV4dDtcblxuICAgIC8vIFNldHMgdXAgdGhlIGluaXRpYWwgdGltZW91dC5cbiAgICB0aW1lb3V0KEFTWU5DX1RJTUVPVVQpO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8qIGpzaGludCBldmlsOiB0cnVlICovXG4gICAgICBleGVjLnJlc3VsdCAgPSBkYXRhLndpbmRvdy5ldmFsKGNvZGUpO1xuICAgICAgZXhlYy5pc0Vycm9yID0gZmFsc2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGV4ZWMucmVzdWx0ICA9IGVycm9yO1xuICAgICAgZXhlYy5pc0Vycm9yID0gdHJ1ZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gSWYgdGhlIGV4ZWN1dGlvbiBpcyBub3QgYXN5bmNocm9ub3VzIG9yIGFuIGVycm9yIGhhcyBiZWVuIHRocm93bixcbiAgICAgIC8vIHRyaWdnZXIgY29tcGxldGlvbiBvZiB0aGUgY2VsbCBleGVjdXRpb24uXG4gICAgICBpZiAoIWFzeW5jIHx8IGV4ZWMuaXNFcnJvcikge1xuICAgICAgICByZXR1cm4gY29tcGxldGUobnVsbCwgZXhlYyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn0pO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luc2VydC1tb2R1bGUtZ2xvYmFscy9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXCIpKSIsInZhciBfICAgICAgICAgID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIGRvbWlmeSAgICAgPSByZXF1aXJlKCdkb21pZnknKTtcbnZhciBCYWNrYm9uZSAgID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciBtaWRkbGV3YXJlID0gcmVxdWlyZSgnLi4vLi4vc3RhdGUvbWlkZGxld2FyZScpO1xuXG4vKipcbiAqIEdlbmVyYXRlIHRoZSBIVE1MIGZvciBhIG1vZGFsIHBvcHVwLlxuICpcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqL1xudmFyIHRlbXBsYXRlID0gXy50ZW1wbGF0ZShbXG4gICc8ZGl2IGNsYXNzPVwibW9kYWxcIiB0YWJpbmRleD1cIi0xXCI+JyxcbiAgJzxkaXYgY2xhc3M9XCJtb2RhbC1kaWFsb2dcIj4nLFxuICAnPGRpdiBjbGFzcz1cIm1vZGFsLWNvbnRlbnRcIj4nLFxuICAnPCUgaWYgKHRpdGxlKSB7ICU+JyxcbiAgJzxkaXYgY2xhc3M9XCJtb2RhbC1oZWFkZXJcIj4nLFxuICAnPGJ1dHRvbiBjbGFzcz1cIm1vZGFsLWNsb3NlXCIgZGF0YS1kaXNtaXNzPiZ0aW1lczs8L2J1dHRvbj4nLFxuICAnPGg0IGNsYXNzPVwibW9kYWwtdGl0bGVcIj48JS0gdGl0bGUgJT48L2g0PicsXG4gICc8L2Rpdj4nLFxuICAnPCUgfSAlPicsXG4gICc8ZGl2IGNsYXNzPVwibW9kYWwtYm9keVwiPicsXG4gICc8JT0gY29udGVudCAlPicsXG4gICc8L2Rpdj4nLFxuICAnPC9kaXY+JyxcbiAgJzwvZGl2PicsXG4gICc8L2Rpdj4nXG5dLmpvaW4oJ1xcbicpKTtcblxuLyoqXG4gKiBTaW1wbGUgbWlkZGxld2FyZSBoYW5kbGVyIGZvciBvcGVuaW5nIG1vZGFsIHdpbmRvd3MuIEl0IHNob3VsZCBwcm9jZWVkIHRvXG4gKiB0aGUgbmV4dCBmdW5jdGlvbiBpbiB0aGUgZXhlY3V0aW9uIHN0YWNrIHdoZW4gdGhlIG1vZGFsIHdpbmRvdyBpcyBjbG9zZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9ICAgb3B0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gbmV4dFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICovXG5taWRkbGV3YXJlLnJlZ2lzdGVyKCd1aTptb2RhbCcsIGZ1bmN0aW9uIChvcHRpb25zLCBuZXh0LCBkb25lKSB7XG4gIC8vIEFsbG93IGFzeW5jaHJvbm91cyB0ZW1wbGF0ZSBsb2FkcyBiYXNlZCBvbiBjb250ZW50IHR5cGUgYW5kIG51bWJlciBvZlxuICAvLyBmdW5jdGlvbiBhcmd1bWVudHMuXG4gIHZhciBhc3luYyA9IGZhbHNlO1xuICB2YXIgdGVtcGxhdGVPcHRpb25zID0ge1xuICAgIHRpdGxlOiAgIG9wdGlvbnMudGl0bGUsXG4gICAgY29udGVudDogb3B0aW9ucy5jb250ZW50XG4gIH07XG5cbiAgLy8gQ2hlY2sgaWYgY29udGVudCBpcyBhIGZ1bmN0aW9uLiBJZiBpdCBpcywganVzdCBleGVjdXRlIGl0IG9yIHB1dCB0aGUgbW9kYWxcbiAgLy8gaW50byBhc3luYyBtb2RlLlxuICBpZiAoXy5pc0Z1bmN0aW9uKG9wdGlvbnMuY29udGVudCkpIHtcbiAgICBpZiAoIW9wdGlvbnMuY29udGVudC5sZW5ndGgpIHtcbiAgICAgIHRlbXBsYXRlT3B0aW9ucy5jb250ZW50ID0gb3B0aW9ucy5jb250ZW50KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzeW5jID0gdHJ1ZTtcbiAgICAgIHRlbXBsYXRlT3B0aW9ucy5jb250ZW50ID0gW1xuICAgICAgICAnPGRpdiBjbGFzcz1cInRleHQtY2VudGVyXCI+JyxcbiAgICAgICAgJzxpIGNsYXNzPVwiaWNvbi1hcnJvd3MtY3cgYW5pbWF0ZS1zcGluXCI+PC9pPicsXG4gICAgICAgICc8L2Rpdj4nXG4gICAgICBdLmpvaW4oJ1xcbicpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlbmRlciB0aGUgbW9kYWwgd2l0aCBhIGNsb3NlIGZ1bmN0aW9uLlxuICB2YXIgbW9kYWwgPSB7XG4gICAgZWw6IGRvbWlmeSh0ZW1wbGF0ZSh0ZW1wbGF0ZU9wdGlvbnMpKSxcbiAgICBjbG9zZTogZnVuY3Rpb24gKGVycikge1xuICAgICAgbW9kYWwuY2xvc2VkID0gdHJ1ZTtcbiAgICAgIG1pZGRsZXdhcmUuZGVyZWdpc3Rlcigna2V5ZG93bjpFc2MnLCBlc2NNaWRkbGV3YXJlKTtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQobW9kYWwuZWwpO1xuICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKCdtb2RhbC12aXNpYmxlJyk7XG4gICAgICByZXR1cm4gZG9uZShlcnIpO1xuICAgIH0sXG4gICAgY2xvc2VkOiBmYWxzZVxuICB9O1xuXG4gIC8vIEhvb2sgaW50byB0aGUgZXNjIGtleSBhbmQgcmVtb3ZlIHRoZSBtb2RhbC5cbiAgdmFyIGVzY01pZGRsZXdhcmUgPSBmdW5jdGlvbiAoZXZlbnQsIG5leHQsIGRvbmUpIHtcbiAgICBtb2RhbC5jbG9zZSgpO1xuICAgIHJldHVybiBkb25lKCk7XG4gIH07XG5cbiAgLy8gVHJpZ2dlciB0aGUgYXN5bmMgZnVuY3Rpb24gY2FsbGJhY2sgYW5kIHJlbmRlciB0aGUgbW9kYWwgYm9keS5cbiAgaWYgKGFzeW5jKSB7XG4gICAgb3B0aW9ucy5jb250ZW50KGZ1bmN0aW9uIChlcnIsIGNvbnRlbnQpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgbW9kYWwuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuIGRvbmUoZXJyKTtcbiAgICAgIH1cblxuICAgICAgbW9kYWwuZWwucXVlcnlTZWxlY3RvcignLm1vZGFsLWJvZHknKS5pbm5lckhUTUwgPSBjb250ZW50O1xuICAgIH0pO1xuICB9XG5cbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChtb2RhbC5lbCk7XG4gIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCgnbW9kYWwtdmlzaWJsZScpO1xuXG4gIC8vIEZvY3VzIHRoZSBjdXJyZW50IG1vZGFsIHRvIG1ha2UgdGFiYmluZyBlYXNpZXIuXG4gIG1vZGFsLmVsLmZvY3VzKCk7XG5cbiAgbWlkZGxld2FyZS5yZWdpc3Rlcigna2V5ZG93bjpFc2MnLCBlc2NNaWRkbGV3YXJlKTtcbiAgQmFja2JvbmUuJChtb2RhbC5lbClcbiAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChlLnRhcmdldCAhPT0gbW9kYWwuZWwpIHsgcmV0dXJuOyB9XG5cbiAgICAgIHJldHVybiBtb2RhbC5jbG9zZSgpO1xuICAgIH0pXG4gICAgLm9uKCdjbGljaycsICdbZGF0YS1kaXNtaXNzXScsIF8uYmluZChtb2RhbC5jbG9zZSwgbnVsbCwgbnVsbCkpO1xuXG4gIC8vIEV4ZWN1dGUgdGhlIGFmdGVyIHJlbmRlciBmdW5jdGlvbiB3aGljaCBjYW4gYmUgdXNlZCB0byBhdHRhY2ggbW9yZVxuICAvLyBmdW5jdGlvbmFsaXR5IHRvIHRoZSBtb2RhbC5cbiAgcmV0dXJuIF8uaXNGdW5jdGlvbihvcHRpb25zLnNob3cpICYmIG9wdGlvbnMuc2hvdyhtb2RhbCk7XG59KTtcblxuLyoqXG4gKiBFeHRlbmRzIHRoZSBtb2RhbCBtaWRkbGV3YXJlIGZvciBwcm92aWRpbmcgYSBjb25maXJtYXRpb24gZGlhbG9nIHdpbmRvdy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gICBkYXRhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gKi9cbm1pZGRsZXdhcmUucmVnaXN0ZXIoJ3VpOmNvbmZpcm0nLCBmdW5jdGlvbiAoZGF0YSwgbmV4dCwgZG9uZSkge1xuICB2YXIgY29uZmlybWVkID0gZmFsc2U7XG5cbiAgcmV0dXJuIG1pZGRsZXdhcmUudHJpZ2dlcigndWk6bW9kYWwnLCB7XG4gICAgdGl0bGU6IGRhdGEudGl0bGUsXG4gICAgY29udGVudDogZGF0YS5jb250ZW50LFxuICAgIHNob3c6IGZ1bmN0aW9uIChtb2RhbCkge1xuICAgICAgQmFja2JvbmUuJChtb2RhbC5lbCkub24oJ2NsaWNrJywgJ1tkYXRhLWNvbmZpcm1dJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25maXJtZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbW9kYWwuY2xvc2UoKTtcbiAgICAgIH0pO1xuXG4gICAgICBtb2RhbC5lbC5xdWVyeVNlbGVjdG9yKCcubW9kYWwtYm9keScpLmFwcGVuZENoaWxkKGRvbWlmeShcbiAgICAgICAgJzxkaXYgY2xhc3M9XCJidG4tbGlzdCB0ZXh0LWNlbnRlclwiPicgK1xuICAgICAgICAnPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tc2Vjb25kYXJ5XCIgZGF0YS1kaXNtaXNzPkNhbmNlbDwvYnV0dG9uPicgK1xuICAgICAgICAnPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tcHJpbWFyeVwiIGRhdGEtY29uZmlybT5PSzwvYnV0dG9uPicgK1xuICAgICAgICAnPC9kaXY+J1xuICAgICAgKSk7XG5cbiAgICAgIG1vZGFsLmVsLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWNvbmZpcm1dJykuZm9jdXMoKTtcbiAgICB9XG4gIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICByZXR1cm4gZG9uZShlcnIsIGNvbmZpcm1lZCk7XG4gIH0pO1xufSk7XG5cbi8qKlxuICogTm90aWZ5IHRoZSB1c2VyIG9mIHNvbWV0aGluZy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gICBkYXRhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0XG4gKi9cbm1pZGRsZXdhcmUucmVnaXN0ZXIoJ3VpOm5vdGlmeScsIGZ1bmN0aW9uIChkYXRhLCBuZXh0KSB7XG4gIHZhciB0aXRsZSA9ICcnO1xuXG4gIGlmIChkYXRhLnRpdGxlKSB7XG4gICAgdGl0bGUgPSBbXG4gICAgICAnPHAgY2xhc3M9XCJtb2RhbC1oZWFkbGluZVwiPicsXG4gICAgICAnPHN0cm9uZz4nICsgXy5lc2NhcGUoZGF0YS50aXRsZSkgKyAnPC9zdHJvbmc+JyxcbiAgICAgICc8L3A+J1xuICAgIF0uam9pbignXFxuJyk7XG4gIH1cblxuICByZXR1cm4gbWlkZGxld2FyZS50cmlnZ2VyKCd1aTptb2RhbCcsIHtcbiAgICBjb250ZW50OiBbXG4gICAgICB0aXRsZSArICc8cD4nICsgXy5lc2NhcGUoZGF0YS5tZXNzYWdlKSArICc8L3A+JyxcbiAgICAgICc8ZGl2IGNsYXNzPVwidGV4dC1jZW50ZXJcIj4nLFxuICAgICAgJzxidXR0b24gY2xhc3M9XCJidG4gYnRuLXByaW1hcnlcIiBkYXRhLWRpc21pc3M+T0s8L2J1dHRvbj4nLFxuICAgICAgJzwvZGl2PidcbiAgICBdLmpvaW4oJ1xcbicpLFxuICAgIHNob3c6IGZ1bmN0aW9uIChtb2RhbCkge1xuICAgICAgbW9kYWwuZWwuY2xhc3NOYW1lICs9ICcgbW9kYWwtbm90aWZ5JztcbiAgICAgIG1vZGFsLmVsLnF1ZXJ5U2VsZWN0b3IoJy5idG4nKS5mb2N1cygpO1xuICAgIH1cbiAgfSwgbmV4dCk7XG59KTtcbiIsInZhciBfICAgICAgICA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG5cbi8qKlxuICogSG9sZHMgYWxsIHRoZSBub3RlYm9vayBjZWxsIGNvbnRlbnRzLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xudmFyIE5vdGVib29rID0gbW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZS5Db2xsZWN0aW9uLmV4dGVuZCh7XG4gIG1vZGVsOiByZXF1aXJlKCcuLi9tb2RlbHMvY2VsbCcpLFxuICBjb21wYXJhdG9yOiBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICBpZiAoIW1vZGVsLnZpZXcgfHwgIW1vZGVsLnZpZXcuZWwucGFyZW50Tm9kZSkgeyByZXR1cm4gdGhpcy5sZW5ndGg7IH1cbiAgICAvLyBTb3J0aW5nIHRoZSBjb2xsZWN0aW9uIGJhc2VkIG9uIHBvc2l0aW9ucyBpbiB0aGUgRE9NXG4gICAgcmV0dXJuIF8uaW5kZXhPZihtb2RlbC52aWV3LmVsLnBhcmVudE5vZGUuY2hpbGROb2RlcywgbW9kZWwudmlldy5lbCk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFJldHVybiB0aGUgbmV4dCBtb2RlbCBpbiB0aGUgY29sbGVjdGlvbi5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IG1vZGVsXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbk5vdGVib29rLnByb3RvdHlwZS5nZXROZXh0ID0gZnVuY3Rpb24gKG1vZGVsKSB7XG4gIHZhciBpbmRleCA9IHRoaXMuaW5kZXhPZihtb2RlbCk7XG4gIC8vIENhdGNoIG5vdCBmb3VuZCBpbmRleGVzLCB3aGVyZSBhZGRpbmcgb25lIHdvdWxkIHJlc3VsdCBpbiB0aGUgZmlyc3QgbW9kZWwuXG4gIHJldHVybiBpbmRleCA+IC0xID8gdGhpcy5hdChpbmRleCArIDEpIDogdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHByZXZpb3VzIG1vZGVsIGluIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gbW9kZWxcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuTm90ZWJvb2sucHJvdG90eXBlLmdldFByZXYgPSBmdW5jdGlvbiAobW9kZWwpIHtcbiAgcmV0dXJuIHRoaXMuYXQodGhpcy5pbmRleE9mKG1vZGVsKSAtIDEpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG5leHQgY29kZSBjZWxsIGluIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gbW9kZWxcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuTm90ZWJvb2sucHJvdG90eXBlLmdldE5leHRDb2RlID0gZnVuY3Rpb24gKG1vZGVsKSB7XG4gIHdoaWxlIChtb2RlbCA9IHRoaXMuZ2V0TmV4dChtb2RlbCkpIHtcbiAgICBpZiAobW9kZWwuZ2V0KCd0eXBlJykgPT09ICdjb2RlJykge1xuICAgICAgcmV0dXJuIG1vZGVsO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHByZXZpb3VzIGNvZGUgY2VsbCBpbiB0aGUgY29sbGVjdGlvbi5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IG1vZGVsXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbk5vdGVib29rLnByb3RvdHlwZS5nZXRQcmV2Q29kZSA9IGZ1bmN0aW9uIChtb2RlbCkge1xuICB3aGlsZSAobW9kZWwgPSB0aGlzLmdldFByZXYobW9kZWwpKSB7XG4gICAgaWYgKG1vZGVsLmdldCgndHlwZScpID09PSAnY29kZScpIHtcbiAgICAgIHJldHVybiBtb2RlbDtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBpbmRleCBvZiB0aGUgbW9kZWwgaXRlcmF0aW5nIG92ZXIgb25seSBjb2RlIGNlbGxzLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gbW9kZWxcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuTm90ZWJvb2sucHJvdG90eXBlLmNvZGVJbmRleE9mID0gZnVuY3Rpb24gKG1vZGVsKSB7XG4gIHJldHVybiBfLmluZGV4T2YodGhpcy5maWx0ZXIoZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgcmV0dXJuIG1vZGVsLmdldCgndHlwZScpID09PSAnY29kZSc7XG4gIH0pLCBtb2RlbCk7XG59O1xuIiwidmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcblxuLyoqXG4gKiBBIEJhY2tib25lIENvbGxlY3Rpb24gZGVzaWduZWQgdG8ga2VlcCB0cmFjayBvZiBhbGwgbm90ZWJvb2tzLCBhbGxvd2luZ1xuICogdXMgdG8gaGl0IHRoZSBuZXR3b3JrIGFzIGluZnJlcXVlbnRseSBhcyBwb3NzaWJsZS5cbiAqXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKi9cbnZhciBQZXJzaXN0ZW5jZUl0ZW1zID0gbW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZS5Db2xsZWN0aW9uLmV4dGVuZCh7XG4gIG1vZGVsOiByZXF1aXJlKCcuLi9tb2RlbHMvcGVyc2lzdGVuY2UtaXRlbScpXG59KTtcblxuLyoqXG4gKiBIZXJlIHdlIHJlZ2lzdGVyIHRvIGhhdmUgQmFja2JvbmUga2VlcCB0aGlzIGNvbGxlY3Rpb24gc29ydGVkIGZvciB1cy5cbiAqXG4gKiBAcGFyYW0gIHtQZXJzaXN0ZW5jZUl0ZW19IGFcbiAqIEBwYXJhbSAge1BlcnNpc3RlbmNlSXRlbX0gYlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5QZXJzaXN0ZW5jZUl0ZW1zLnByb3RvdHlwZS5jb21wYXJhdG9yID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgcmV0dXJuICthLmdldCgndXBkYXRlZEF0JykgPiArYi5nZXQoJ3VwZGF0ZWRBdCcpID8gLTEgOiAxO1xufTtcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG5yZXF1aXJlKCcuL2Jvb3RzdHJhcCcpO1xuXG4vKipcbiAqIFRoZSBtYWluIGFwcGxpY2F0aW9uIGlzIGFsaWFzZWQgdG8gdGhlIGB3aW5kb3dgIGZvciBleHRlcm5hbCBhY2Nlc3MuXG4gKlxuICogQHR5cGUge0Z1bmN0aW9ufVxuICovXG52YXIgQXBwID0gbW9kdWxlLmV4cG9ydHMgPSB3aW5kb3cuQXBwID0ge307XG5cbkFwcC5MaWJyYXJ5ID0ge1xuICBxczogICAgICAgICByZXF1aXJlKCdxcycpLFxuICB1cmw6ICAgICAgICByZXF1aXJlKCd1cmwnKSxcbiAgYXN5bmM6ICAgICAgcmVxdWlyZSgnYXN5bmMnKSxcbiAgZG9taWZ5OiAgICAgcmVxdWlyZSgnZG9taWZ5JyksXG4gIG1hcmtlZDogICAgIHJlcXVpcmUoJ21hcmtlZCcpLFxuICBCYWNrYm9uZTogICByZXF1aXJlKCdiYWNrYm9uZScpLFxuICBET01CYXJzOiAgICByZXF1aXJlKCcuL2xpYi9kb21iYXJzJyksXG4gIGNoYW5nZUNhc2U6IHJlcXVpcmUoJ2NoYW5nZS1jYXNlJylcbn07XG5cbkFwcC5fICAgICAgICA9IEFwcC5MaWJyYXJ5Ll8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5BcHAubmV4dFRpY2sgPSBwcm9jZXNzLm5leHRUaWNrO1xuXG4vLyBFeHBvc2VzIGNvbmZpZ3VyYXRpb24gZGV0YWlscyBnbG9iYWxseVxuQXBwLnN0YXRlICAgICAgID0gcmVxdWlyZSgnLi9zdGF0ZS9zdGF0ZScpO1xuQXBwLnN0b3JlICAgICAgID0gcmVxdWlyZSgnLi9zdGF0ZS9zdG9yZScpO1xuQXBwLmNvbmZpZyAgICAgID0gcmVxdWlyZSgnLi9zdGF0ZS9jb25maWcnKTtcbkFwcC5tZXNzYWdlcyAgICA9IHJlcXVpcmUoJy4vc3RhdGUvbWVzc2FnZXMnKTtcbkFwcC5taWRkbGV3YXJlICA9IHJlcXVpcmUoJy4vc3RhdGUvbWlkZGxld2FyZScpO1xuQXBwLnBlcnNpc3RlbmNlID0gcmVxdWlyZSgnLi9zdGF0ZS9wZXJzaXN0ZW5jZScpO1xuQXBwLlNhbmRib3ggICAgID0gcmVxdWlyZSgnLi9saWIvc2FuZGJveCcpO1xuQXBwLlBvc3RNZXNzYWdlID0gcmVxdWlyZSgnLi9saWIvcG9zdC1tZXNzYWdlJyk7XG5cblxuLy8gRXhwb3NlcyBDb2RlTWlycm9yIHRvIHRoZSB3b3JsZCB3aXRoIG91ciBjdXN0b20gbW9kcy5cbkFwcC5Db2RlTWlycm9yID0ge1xuICBFZGl0b3I6ICAgICAgICAgICAgcmVxdWlyZSgnY29kZW1pcnJvcicpLFxuICBDb21wbGV0aW9uOiAgICAgICAgcmVxdWlyZSgnLi9saWIvY29tcGxldGlvbicpLFxuICBzYW5kYm94Q29tcGxldGlvbjogcmVxdWlyZSgnLi9saWIvc2FuZGJveC1jb21wbGV0aW9uJylcbn07XG5cbi8vIEV4cG9zZSBhbGwgYXBwbGljYXRpb24gdmlld3MuXG5BcHAuVmlldyA9IHtcbiAgQXBwOiAgICAgICAgICAgIHJlcXVpcmUoJy4vdmlld3MvYXBwJyksXG4gIFZpZXc6ICAgICAgICAgICByZXF1aXJlKCcuL3ZpZXdzL3ZpZXcnKSxcbiAgTm90ZWJvb2s6ICAgICAgIHJlcXVpcmUoJy4vdmlld3Mvbm90ZWJvb2snKSxcbiAgRWRpdE5vdGVib29rOiAgIHJlcXVpcmUoJy4vdmlld3MvZWRpdC1ub3RlYm9vaycpLFxuICBJbnNwZWN0b3I6ICAgICAgcmVxdWlyZSgnLi92aWV3cy9pbnNwZWN0b3InKSxcbiAgRXJyb3JJbnNwZWN0b3I6IHJlcXVpcmUoJy4vdmlld3MvZXJyb3ItaW5zcGVjdG9yJyksXG4gIENvZGVDZWxsOiAgICAgICByZXF1aXJlKCcuL3ZpZXdzL2NvZGUtY2VsbCcpLFxuICBUZXh0Q2VsbDogICAgICAgcmVxdWlyZSgnLi92aWV3cy90ZXh0LWNlbGwnKSxcbiAgRWRpdG9yQ2VsbDogICAgIHJlcXVpcmUoJy4vdmlld3MvZWRpdG9yLWNlbGwnKSxcbiAgUmVzdWx0Q2VsbDogICAgIHJlcXVpcmUoJy4vdmlld3MvcmVzdWx0LWNlbGwnKSxcbiAgQ2VsbEJ1dHRvbnM6ICAgIHJlcXVpcmUoJy4vdmlld3MvY2VsbC1idXR0b25zJyksXG4gIENlbGxDb250cm9sczogICByZXF1aXJlKCcuL3ZpZXdzL2NlbGwtY29udHJvbHMnKVxufTtcblxuLy8gRXhwb3NlIGFwcGxpY2F0aW9uIG1vZGVscy5cbkFwcC5Nb2RlbCA9IHtcbiAgQ2VsbDogICAgIHJlcXVpcmUoJy4vbW9kZWxzL2NlbGwnKSxcbiAgTWV0YTogICAgIHJlcXVpcmUoJy4vbW9kZWxzL21ldGEnKSxcbiAgTm90ZWJvb2s6IHJlcXVpcmUoJy4vbW9kZWxzL25vdGVib29rJylcbn07XG5cbi8vIEV4cG9zZSBhcHBsaWNhdGlvbiBjb2xsZWN0aW9ucy5cbkFwcC5Db2xsZWN0aW9uID0ge1xuICBDZWxsczogcmVxdWlyZSgnLi9jb2xsZWN0aW9ucy9jZWxscycpXG59O1xuXG4vKipcbiAqIERlZmluZSBhIGN1c3RvbSBzdGFydCBtZXRob2Qgc28gdGhhdCB0aGUgYXBwbGljYXRpb24gY2FuIGJpbmQgbWlkZGxld2FyZSBhbmRcbiAqIHByZXBhcmUgc3RhdGUgYmVmb3JlIHdlIGFjdHVhbGx5IGFwcGVuZCB0aGUgbm90ZWJvb2sgd2hpY2ggcmVsaWVzIG9uIHNvbWUgb2ZcbiAqIHRoZSBtaWRkbGV3YXJlIGJlaW5nIGF2YWlsYWJsZS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufEVsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgIFtjb25maWddXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSAgICAgICAgIGRvbmVcbiAqL1xuQXBwLnN0YXJ0ID0gZnVuY3Rpb24gKGVsIC8qLCBvcHRpb25zICovLCBkb25lKSB7XG4gIHZhciBvcHRpb25zID0ge307XG5cbiAgaWYgKHR5cGVvZiBkb25lID09PSAnb2JqZWN0Jykge1xuICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbMV07XG4gICAgZG9uZSAgICA9IGFyZ3VtZW50c1syXTtcbiAgfVxuXG4gIHJldHVybiBBcHAubWlkZGxld2FyZS50cmlnZ2VyKCdhcHBsaWNhdGlvbjpzdGFydCcsIG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gZG9uZSAmJiBkb25lKGVycik7XG4gICAgfVxuXG4gICAgdmFyIGFwcCA9IG5ldyBBcHAuVmlldy5BcHAoKS5yZW5kZXIoKS5hcHBlbmRUbyhlbCk7XG5cbiAgICAvLyBTZW5kIGEgYHJlbmRlcmVkYCBldmVudCBiYWNrIHRvIHRoZSBwYXJlbnQgZnJhbWUgd2hlbiB3ZSBhcmUgZW1iZWRkZWQuXG4gICAgaWYgKEFwcC5wb3N0TWVzc2FnZSkge1xuICAgICAgQXBwLnBvc3RNZXNzYWdlLnRyaWdnZXIoJ3JlbmRlcmVkJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEFwcC5taWRkbGV3YXJlLnRyaWdnZXIoJ2FwcGxpY2F0aW9uOnJlYWR5JywgYXBwLCBkb25lKTtcbiAgfSk7XG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luc2VydC1tb2R1bGUtZ2xvYmFscy9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXCIpKSIsIi8qKlxuICogRXhlY3V0ZSBhIGZ1bmN0aW9uIGFuZCByZXR1cm4gaXQgYmFjayBkaXJlY3RseSBhZnRlciBleGVjdXRpb24uXG4gKlxuICogQHBhcmFtICB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGZuLmNhbGwoY29udGV4dCksIGZuO1xufTtcbiIsImV4cG9ydHMubWFjID0gL01hYy8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xuIiwiLyoqXG4gKiBJbnNlcnRzIGEgRE9NIG5vZGUgYWZ0ZXIgYW5vdGhlciBub2RlLlxuICpcbiAqIEBwYXJhbSAge05vZGV9IGVsXG4gKiBAcGFyYW0gIHtOb2RlfSBiZWZvcmVcbiAqIEByZXR1cm4ge05vZGV9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGVsLCBiZWZvcmUpIHtcbiAgcmV0dXJuIGJlZm9yZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbCwgYmVmb3JlLm5leHRTaWJsaW5nKTtcbn07XG4iLCIvKipcbiAqIExvYWRzIGEgc2NyaXB0IGludG8gdGhlIGRvY3VtZW50LiBBbGwgZnVuY3Rpb25hbGl0eSBtdXN0IGJlIGlubGluZWQgc2luY2VcbiAqIGl0IHdpbGwgYmUgZXZhbGVkIGludG8gdGhlIHNhbmRib3ggY29udGV4dC5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgc3JjXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gZG9uZVxuICogQHJldHVybiB7Tm9kZX1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3JjLCBkb25lKSB7XG4gIHZhciBoZWFkICAgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblxuICBzY3JpcHQuc3JjICAgICA9IHNyYztcbiAgc2NyaXB0LmFzeW5jICAgPSB0cnVlO1xuICBzY3JpcHQudHlwZSAgICA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICBzY3JpcHQuY2hhcnNldCA9ICd1dGY4JztcblxuICBpZiAoZG9uZSkge1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIGBvbmxvYWRgIHByb3BlcnR5IHRvIGxpc3RlbiB0bywgZmFsbCBiYWNrIHRvIGxpc3RlbmluZyB0b1xuICAgIC8vIHN0YXRlIGNoYW5nZXMgaW4gSUUuXG4gICAgaWYgKCdvbmxvYWQnIGluIHNjcmlwdCkge1xuICAgICAgc2NyaXB0Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vbmVycm9yID0gdGhpcy5vbmxvYWQgPSBudWxsO1xuICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgfTtcblxuICAgICAgc2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub25lcnJvciA9IHRoaXMub25sb2FkID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGRvbmUobmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCAnICsgc3JjKSk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSAnY29tcGxldGUnKSB7IHJldHVybjsgfVxuICAgICAgICB0aGlzLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIHdheSB0byBjYXRjaCBsb2FkIGVycm9ycyBpbiBJRTguXG4gICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBoZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG59O1xuIiwidmFyIF8gICAgICAgICAgPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgZ2V0VG9rZW4gICA9IHJlcXVpcmUoJy4vZ2V0LXRva2VuJyk7XG52YXIgQ29kZU1pcnJvciA9IHJlcXVpcmUoJ2NvZGVtaXJyb3InKTtcblxuLyoqXG4gKiBHcmFicyBhbmQgY29ycmVjdHMgdGhlIGdyYWJiZWQgdG9rZW4uIFVzZWZ1bCByZWFsbHkgb25seSBmb3Igc2FuaXRpc2luZyBhXG4gKiBgLmAgYXMgYSBwcm9wZXJ0eS4gVGhpcyBoZWxwcyB3aGVuIHdlIG5lZWQgdG8gZG8gY29tcGxldGlvbiBvbiB0aGUgaW5pdGlhbFxuICogYC5gIHRoYXQgaXMgdHlwZXMuXG4gKlxuICogQHBhcmFtICB7Q29kZU1pcnJvcn0gY21cbiAqIEBwYXJhbSAge09iamVjdH0gICAgIHBvc1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjbSwgcG9zKSB7XG4gIHZhciB0b2tlbiA9IGdldFRva2VuKGNtLCBwb3MpO1xuXG4gIHRva2VuLnN0YXRlID0gQ29kZU1pcnJvci5pbm5lck1vZGUoY20uZ2V0TW9kZSgpLCB0b2tlbi5zdGF0ZSkuc3RhdGU7XG5cbiAgaWYgKHRva2VuLnN0cmluZyA9PT0gJy4nKSB7XG4gICAgXy5leHRlbmQodG9rZW4sIHtcbiAgICAgIHN0YXJ0OiAgdG9rZW4uZW5kLFxuICAgICAgZW5kOiAgICB0b2tlbi5lbmQsXG4gICAgICBzdHJpbmc6ICcnLFxuICAgICAgdHlwZTogICAncHJvcGVydHknXG4gICAgfSk7XG5cbiAgICAvLyBJbmNyZW1lbnQgdG9rZW4gcG9zaXRpb24uXG4gICAgdG9rZW4ucG9zLmNoID0gdG9rZW4uc3RhcnQ7XG4gIH1cblxuICByZXR1cm4gdG9rZW47XG59O1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdG9rZW4gYXQgYSBnaXZlbiBwb3NpdGlvbi4gQXVnbWVudHMgdGhlIHRva2VuIG9iamVjdCB3aXRoXG4gKiB0aGUgdG9rZW4gc3RhcnQgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtICB7Q29kZU1pcnJvcn0gICAgIGNtXG4gKiBAcGFyYW0gIHtDb2RlTWlycm9yLlBvc30gcG9zXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNtLCBwb3MpIHtcbiAgdmFyIHRva2VuID0gY20uZ2V0VG9rZW5BdChwb3MpO1xuXG4gIC8vIEV4dGVuZCB0aGUgYmFzZSB0b2tlbiB3aXRoIGl0cyBwb3NpdGlvbiBpbiB0aGUgZWRpdG9yLiBUaGlzIGlzIGVzc2VudGlhbCB0b1xuICAvLyByZWN1cnNpdmVseSB0cmF2ZXJzZSBET00gdG9rZW5zLlxuICBfLmV4dGVuZCh0b2tlbiwge1xuICAgIHBvczogXy5leHRlbmQoe30sIHBvcywge1xuICAgICAgY2g6IHRva2VuLnN0YXJ0XG4gICAgfSlcbiAgfSk7XG5cbiAgcmV0dXJuIHRva2VuO1xufTtcbiIsInZhciB2YXJzSGFzVmFsdWUgPSByZXF1aXJlKCcuL3ZhcnMtaGFzLXZhbHVlJyk7XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBpbiB0aGUgdG9rZW4gc2NvcGUuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSAgdG9rZW5cbiAqIEBwYXJhbSAge1N0cmluZ30gIHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0b2tlbiwgdmFsdWUpIHtcbiAgdmFyIGNvbnRleHQgICAgPSB0b2tlbi5zdGF0ZS5jb250ZXh0O1xuICB2YXIgbG9jYWxWYXJzICA9IHRva2VuLnN0YXRlLmxvY2FsVmFycztcbiAgdmFyIGdsb2JhbFZhcnMgPSB0b2tlbi5zdGF0ZS5nbG9iYWxWYXJzO1xuXG4gIGlmICh2YXJzSGFzVmFsdWUobG9jYWxWYXJzLCB2YWx1ZSkgfHwgdmFyc0hhc1ZhbHVlKGdsb2JhbFZhcnMsIHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgd2hpbGUgKGNvbnRleHQpIHtcbiAgICBpZiAodmFyc0hhc1ZhbHVlKGNvbnRleHQudmFycywgdmFsdWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb250ZXh0ID0gY29udGV4dC5wcmV2O1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcbiIsInZhciBfICAgICAgICAgICAgPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgZ2V0VG9rZW4gICAgID0gcmVxdWlyZSgnLi9nZXQtdG9rZW4nKTtcbnZhciBtaWRkbGV3YXJlICAgPSByZXF1aXJlKCcuLi8uLi9zdGF0ZS9taWRkbGV3YXJlJyk7XG52YXIgdG9rZW5IZWxwZXJzID0gcmVxdWlyZSgnLi90b2tlbi1oZWxwZXJzJyk7XG5cbi8qKlxuICogQW4gbWFwIG9mIHBvc3NpYmxlIGZ1bmN0aW9uIHR5cGVzLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBGVU5DVElPTl9UWVBFUyA9IHtcbiAgdmFyaWFibGU6IHRydWUsXG4gIHByb3BlcnR5OiB0cnVlXG59O1xuXG4vKipcbiAqIENvbGxlY3QgZGF0YSBmb3IgZGlzcGxheWluZyBhIHRvb2x0aXAuIFBhc3NlcyBhbiBmYWxzeSB2YWx1ZSB0byB0aGUgY2FsbGJhY2tcbiAqIHRvIHJlcHJlc2VudCBubyBkYXRhIGF2YWlsYWJsZSB0byBkaXNwbGF5LlxuICpcbiAqIEBwYXJhbSAge0NvZGVNaXJyb3J9IGNtXG4gKiBAcGFyYW0gIHtPYmplY3R9ICAgICBvcHRpb25zXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gICBkb25lXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNtLCBvcHRpb25zLCBkb25lKSB7XG4gIC8vIERvbid0IHNob3cgdGhlIHRvb2x0aXAgd2hlbiB3ZSBoYXZlIGhhdmUgZGF0YSBzZWxlY3RlZC5cbiAgaWYgKGNtLmRvYy5zb21ldGhpbmdTZWxlY3RlZCgpKSB7XG4gICAgcmV0dXJuIGRvbmUoKTtcbiAgfVxuXG4gIHZhciBjdXIgICA9IGNtLmdldEN1cnNvcigpO1xuICB2YXIgdG9rZW4gPSBnZXRUb2tlbihjbSwgY3VyKTtcbiAgdmFyIGJyYWNrZXQ7XG5cbiAgd2hpbGUgKHRva2VuKSB7XG4gICAgYnJhY2tldCA9IHRva2VuSGVscGVycy5nZXRQcmV2QnJhY2tldChjbSwgdG9rZW4pO1xuICAgIHRva2VuICAgPSBicmFja2V0ICYmIHRva2VuSGVscGVycy5lYXRFbXB0eUFuZE1vdmUoY20sIGJyYWNrZXQpO1xuXG4gICAgaWYgKCF0b2tlbiB8fCBGVU5DVElPTl9UWVBFU1t0b2tlbi50eXBlXSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF0b2tlbikge1xuICAgIHJldHVybiBkb25lKCk7XG4gIH1cblxuICByZXR1cm4gdG9rZW5IZWxwZXJzLmdldFByb3BlcnR5KGNtLCB0b2tlbiwgb3B0aW9ucywgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgIGlmIChlcnIgfHwgIV8uaXNGdW5jdGlvbihkYXRhLmNvbnRleHQpKSB7XG4gICAgICByZXR1cm4gZG9uZShlcnIpO1xuICAgIH1cblxuICAgIC8vIFdoZW4gdGhlIGNvbnRleHQgaXMgYSBmdW5jdGlvbiwgcmV0cmlldmUgdGhlIHJlbGV2YW50IGRvY3VtZW50YXRpb24uXG4gICAgbWlkZGxld2FyZS50cmlnZ2VyKCdjb21wbGV0aW9uOmRlc2NyaWJlJywgZGF0YSwgZnVuY3Rpb24gKGVyciwgZGVzY3JpYmUpIHtcbiAgICAgIHJldHVybiBkb25lKGVyciwgXy5leHRlbmQoZGF0YSwge1xuICAgICAgICBkZXNjcmlwdGlvbjogZGVzY3JpYmUsXG4gICAgICAgIHRvOiAgICAgICAgICBjdXIsXG4gICAgICAgIHRva2VuOiAgICAgICBicmFja2V0LFxuICAgICAgICBmcm9tOiAgICAgICAgYnJhY2tldC5wb3NcbiAgICAgIH0pKTtcbiAgICB9LCB0cnVlKTtcbiAgfSk7XG59O1xuIiwidmFyIF8gICAgICAgICAgICA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBQb3MgICAgICAgICAgPSByZXF1aXJlKCdjb2RlbWlycm9yJykuUG9zO1xudmFyIG1pZGRsZXdhcmUgICA9IHJlcXVpcmUoJy4uLy4uL3N0YXRlL21pZGRsZXdhcmUnKTtcbnZhciB0b2tlbkhlbHBlcnMgPSByZXF1aXJlKCcuL3Rva2VuLWhlbHBlcnMnKTtcbnZhciBjb3JyZWN0VG9rZW4gPSByZXF1aXJlKCcuL2NvcnJlY3QtdG9rZW4nKTtcblxuLyoqXG4gKiBQcm94eSB0aGUgcmV0dXJuIG9iamVjdHMgZm9yIHRoZSBwcm9wZXJ0eSBhbmQgdmFyaWFibGUgbWlkZGxld2FyZSBhbmQgdHVyblxuICogaXQgaW50byBzb21ldGhpbmcgYWN0aW9uYWJsZSBmb3IgdGhlIHdpZGdldCBkaXNwbGF5LlxuICpcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBkb25lXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xudmFyIGNvbXBsZXRlUmVzdWx0cyA9IGZ1bmN0aW9uIChkb25lKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgLy8gU29ydHMgdGhlIGtleXMgYW5kIG1hcHMgdG8gYW4gb2JqZWN0IHRoYXQgdGhlIHdpZGdldCBjYW4gdW5kZXJzdGFuZC5cbiAgICB2YXIgcmVzdWx0cyA9IF8ubWFwKF8ua2V5cyhkYXRhLnJlc3VsdHMpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAoIV8uaXNPYmplY3QoZGF0YS5yZXN1bHRzW2tleV0pKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdGl0bGU6IGtleSxcbiAgICAgICAgICB2YWx1ZToga2V5XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRpdGxlOiBrZXksXG4gICAgICAgIHR5cGU6ICBkYXRhLnJlc3VsdHNba2V5XS50eXBlLFxuICAgICAgICB2YWx1ZTogZGF0YS5yZXN1bHRzW2tleV0udmFsdWUgfHwga2V5XG4gICAgICB9O1xuICAgIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLnRpdGxlID4gYi50aXRsZSA/IDEgOiAtMTtcbiAgICB9KTtcblxuICAgIHJldHVybiBkb25lKGVyciwge1xuICAgICAgY29udGV4dDogZGF0YS5jb250ZXh0LFxuICAgICAgcmVzdWx0czogcmVzdWx0c1xuICAgIH0pO1xuICB9O1xufTtcblxuLyoqXG4gKiBDb21wbGV0ZSB2YXJpYWJsZSBjb21wbGV0aW9uIHN1Z2dlc3Rpb25zLlxuICpcbiAqIEBwYXJhbSAge0NvZGVNaXJyb3J9IGNtXG4gKiBAcGFyYW0gIHtPYmplY3R9ICAgICB0b2tlblxuICogQHBhcmFtICB7T2JqZWN0fSAgICAgb3B0aW9uc1xuICogQHBhcmFtICB7RnVuY3Rpb259ICAgZG9uZVxuICovXG52YXIgY29tcGxldGVWYXJpYWJsZSA9IGZ1bmN0aW9uIChjbSwgdG9rZW4sIG9wdGlvbnMsIGRvbmUpIHtcbiAgLy8gVHJpZ2dlciB0aGUgY29tcGxldGlvbiBtaWRkbGV3YXJlIHRvIHJ1blxuICBtaWRkbGV3YXJlLnRyaWdnZXIoJ2NvbXBsZXRpb246dmFyaWFibGUnLCBfLmV4dGVuZCh7XG4gICAgdG9rZW46ICAgdG9rZW4sXG4gICAgZWRpdG9yOiAgY20sXG4gICAgY29udGV4dDogb3B0aW9ucy53aW5kb3csXG4gICAgcmVzdWx0czoge31cbiAgfSwgb3B0aW9ucyksIGNvbXBsZXRlUmVzdWx0cyhkb25lKSk7XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIGNvbXBsZXRpb24gc3VnZ2VzdGlvbnMgZm9yIGEgcHJvcGVydHkuXG4gKlxuICogQHBhcmFtICB7Q29kZU1pcnJvcn0gY21cbiAqIEBwYXJhbSAge09iamVjdH0gICAgIHRva2VuXG4gKiBAcGFyYW0gIHtPYmplY3R9ICAgICBvcHRpb25zXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gICBkb25lXG4gKi9cbnZhciBjb21wbGV0ZVByb3BlcnR5ID0gZnVuY3Rpb24gKGNtLCB0b2tlbiwgb3B0aW9ucywgZG9uZSkge1xuICB0b2tlbkhlbHBlcnMuZ2V0UHJvcGVydHlPYmplY3QoY20sIHRva2VuLCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgbWlkZGxld2FyZS50cmlnZ2VyKCdjb21wbGV0aW9uOnByb3BlcnR5JywgXy5leHRlbmQoe1xuICAgICAgcmVzdWx0czoge31cbiAgICB9LCBkYXRhKSwgY29tcGxldGVSZXN1bHRzKGRvbmUpKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFRyaWdnZXIgdGhlIGNvbXBsZXRpb24gbW9kdWxlIGJ5IHBhc3NpbmcgaW4gdGhlIGN1cnJlbnQgQ29kZU1pcnJvciBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0gIHtDb2RlTWlycm9yfSBjbVxuICogQHBhcmFtICB7T2JqZWN0fSAgICAgb3B0aW9uc1xuICogQHBhcmFtICB7RnVuY3Rpb259ICAgZG9uZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjbSwgb3B0aW9ucywgZG9uZSkge1xuICB2YXIgY3VyICAgPSBjbS5nZXRDdXJzb3IoKTtcbiAgdmFyIHRva2VuID0gY29ycmVjdFRva2VuKGNtLCBjdXIpO1xuICB2YXIgdHlwZSAgPSB0b2tlbi50eXBlO1xuXG4gIHZhciBjYiA9IGZ1bmN0aW9uIChlcnIsIGNvbXBsZXRpb24pIHtcbiAgICBjb21wbGV0aW9uID0gY29tcGxldGlvbiB8fCB7fTtcblxuICAgIHJldHVybiBkb25lKGVyciwge1xuICAgICAgdG9rZW46ICAgdG9rZW4sXG4gICAgICBjb250ZXh0OiBjb21wbGV0aW9uLmNvbnRleHQsXG4gICAgICByZXN1bHRzOiBjb21wbGV0aW9uLnJlc3VsdHMsXG4gICAgICB0bzogICAgICBuZXcgUG9zKGN1ci5saW5lLCB0b2tlbi5lbmQpLFxuICAgICAgZnJvbTogICAgbmV3IFBvcyhjdXIubGluZSwgdG9rZW4uc3RhcnQpXG4gICAgfSk7XG4gIH07XG5cbiAgaWYgKHR5cGUgPT09ICdrZXl3b3JkJyB8fCB0eXBlID09PSAndmFyaWFibGUnKSB7XG4gICAgcmV0dXJuIGNvbXBsZXRlVmFyaWFibGUoY20sIHRva2VuLCBvcHRpb25zLCBjYik7XG4gIH1cblxuICBpZiAodHlwZSA9PT0gJ3Byb3BlcnR5Jykge1xuICAgIHJldHVybiBjb21wbGV0ZVByb3BlcnR5KGNtLCB0b2tlbiwgb3B0aW9ucywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIGRvbmUoKTtcbn07XG4iLCJ2YXIgXyAgICAgICAgICA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBhc3luYyAgICAgID0gcmVxdWlyZSgnYXN5bmMnKTtcbnZhciBnZXRUb2tlbiAgID0gcmVxdWlyZSgnLi9nZXQtdG9rZW4nKTtcbnZhciBtaWRkbGV3YXJlID0gcmVxdWlyZSgnLi4vLi4vc3RhdGUvbWlkZGxld2FyZScpO1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIHRva2VuIGlzIGEgcG9zc2libGUgYWNjZXNzb3IgdG9rZW4gKGNhbiByZWFkIGEgcmVzdWx0KS5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9ICB0b2tlblxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGNhbkFjY2VzcyA9IGZ1bmN0aW9uICh0b2tlbikge1xuICBpZiAoIV8uY29udGFpbnMoW251bGwsICdrZXl3b3JkJywgJ2ludmFsaWQnLCAnY29tbWVudCddLCB0b2tlbi50eXBlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRva2VuLnR5cGUgPT09IG51bGwgJiYgXy5jb250YWlucyhbJyknLCAnXSddLCB0b2tlbi5zdHJpbmcpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjbG9zZXN0IHByZXZpb3VzIG9wZW5pbmcgYnJhY2tldCB0b2tlbiB0byB0aGUgcGFzc2VkIGluIHRva2VuLlxuICpcbiAqIEBwYXJhbSAge0NvZGVNaXJyb3J9IGNtXG4gKiBAcGFyYW0gIHtPYmplY3R9ICAgICB0b2tlblxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5leHBvcnRzLmdldFByZXZCcmFja2V0ID0gZnVuY3Rpb24gKGNtLCB0b2tlbikge1xuICB2YXIgbGV2ZWwgPSAwO1xuXG4gIGRvIHtcbiAgICBpZiAodG9rZW4uc3RyaW5nID09PSAnKCcpIHtcbiAgICAgIGlmIChsZXZlbCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9XG5cbiAgICAgIGxldmVsLS07XG4gICAgfSBlbHNlIGlmICh0b2tlbi5zdHJpbmcgPT09ICcpJykge1xuICAgICAgbGV2ZWwrKztcbiAgICB9XG4gIH0gd2hpbGUgKHRva2VuID0gZXhwb3J0cy5nZXRQcmV2VG9rZW4oY20sIHRva2VuKSk7XG5cbiAgcmV0dXJuIHRva2VuO1xufTtcblxuLyoqXG4gKiBSZXNvbHZlcyB0b2tlbnMgcHJvcGVybHkgYmVmb3JlIHVzZS5cbiAqXG4gKiBAcGFyYW0ge0NvZGVNaXJyb3J9IGNtXG4gKiBAcGFyYW0ge0FycmF5fSAgICAgIHRva2Vuc1xuICogQHBhcmFtIHtPYmplY3R9ICAgICBvcHRpb25zXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSAgIGRvbmVcbiAqL1xuZXhwb3J0cy5yZXNvbHZlVG9rZW5zID0gZnVuY3Rpb24gKGNtLCB0b2tlbnMsIG9wdGlvbnMsIGRvbmUpIHtcbiAgYXN5bmMubWFwKHRva2VucywgZnVuY3Rpb24gKHRva2VuLCBjYikge1xuICAgIC8vIER5bmFtaWMgcHJvcGVydHkgY2FsY3VsYXRpb25zIGFyZSBydW4gaW5saW5lIGJlZm9yZSB3ZSByZXNvbHZlIHRoZSB3aG9sZVxuICAgIC8vIG9iamVjdC5cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2R5bmFtaWMtcHJvcGVydHknKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5wcm9wZXJ0eUxvb2t1cChcbiAgICAgICAgY20sXG4gICAgICAgIHRva2VuLnRva2VucyxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgICAgICAgIGlmIChlcnIpIHsgIHJldHVybiBjYihlcnIpOyB9XG5cbiAgICAgICAgICB2YXIgc3RyaW5nO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN0cmluZyA9ICcnICsgZGF0YS5jb250ZXh0O1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ1Byb3BlcnR5IHJlc29sdXRpb24gaXMgaW1wb3NzaWJsZScpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBSZW1vdmUgdGhlIHRva2VucyBsb29rdXAgYXJyYXkuXG4gICAgICAgICAgZGVsZXRlIHRva2VuLnRva2VucztcblxuICAgICAgICAgIC8vIFJldHVybnMgYSB2YWxpZCB0b2tlbiBmb3IgdGhlIHJlc3Qgb2YgdGhlIHJlc29sdXRpb24uXG4gICAgICAgICAgcmV0dXJuIGNiKGVyciwgXy5leHRlbmQodG9rZW4sIHtcbiAgICAgICAgICAgIHR5cGU6ICAgJ3Byb3BlcnR5JyxcbiAgICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBjYihudWxsLCB0b2tlbik7XG4gIH0sIGRvbmUpO1xufTtcblxuLyoqXG4gKiBSdW4gcHJvcGVydHkgbG9va3VwIG1pZGRsZXdhcmUuICpQbGVhc2Ugbm90ZTogVGhpcyBhc3N1bWVzIHJlc29sdmVkIHRva2Vucy4qXG4gKlxuICogQHBhcmFtIHtDb2RlTWlycm9yfSBjbVxuICogQHBhcmFtIHtBcnJheX0gICAgICB0b2tlbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgb3B0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gICBkb25lXG4gKi9cbnZhciBkb1Byb3BlcnR5TG9va3VwID0gZnVuY3Rpb24gKGNtLCB0b2tlbnMsIG9wdGlvbnMsIGRvbmUpIHtcbiAgdmFyIHByZXZDb250ZXh0ID0gb3B0aW9ucy5jb250ZXh0O1xuXG4gIG1pZGRsZXdhcmUudHJpZ2dlcignY29tcGxldGlvbjpjb250ZXh0JywgXy5leHRlbmQoe1xuICAgIHRva2VuOiAgIHRva2Vucy5wb3AoKSxcbiAgICBjb250ZXh0OiBvcHRpb25zLndpbmRvdyxcbiAgICBlZGl0b3I6ICBjbVxuICB9LCBvcHRpb25zKSwgZnVuY3Rpb24gYWdhaW4gKGVyciwgZGF0YSkge1xuICAgIHZhciB0b2tlbiA9IGRhdGEudG9rZW47XG5cbiAgICAvLyBCcmVhayB0aGUgY29udGV4dCBsb29rdXAuXG4gICAgaWYgKGVycikgeyByZXR1cm4gZG9uZShlcnIsIG51bGwpOyB9XG5cbiAgICAvLyBVcGRhdGUgdGhlIHBhcmVudCBjb250ZXh0IHByb3BlcnR5LlxuICAgIGRhdGEucGFyZW50ID0gcHJldkNvbnRleHQ7XG5cbiAgICAvLyBGdW5jdGlvbiBjb250ZXh0IGxvb2t1cHMgb2NjdXIgYWZ0ZXIgdGhlIHByb3BlcnR5IGxvb2t1cC5cbiAgICBpZiAodG9rZW4gJiYgdG9rZW4uaXNGdW5jdGlvbikge1xuICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgcHJvcGVydHkgaXMgYWxzbyBhIGZ1bmN0aW9uLCBvdGhlcndpc2Ugd2Ugc2hvdWxkXG4gICAgICAvLyBza2lwIGl0IGFuZCBsZWF2ZSBpdCB1cCB0byB0aGUgdXNlciB0byB3b3JrIG91dC5cbiAgICAgIGlmICghXy5pc0Z1bmN0aW9uKGRhdGEuY29udGV4dCkpIHtcbiAgICAgICAgZGF0YS50b2tlbiAgID0gbnVsbDtcbiAgICAgICAgZGF0YS5jb250ZXh0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGFnYWluKGVyciwgZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtaWRkbGV3YXJlLnRyaWdnZXIoJ2NvbXBsZXRpb246ZnVuY3Rpb24nLCBfLmV4dGVuZCh7XG4gICAgICAgIG5hbWU6ICAgICAgICAgIHRva2VuLnN0cmluZyxcbiAgICAgICAgaXNDb25zdHJ1Y3RvcjogISF0b2tlbi5pc0NvbnN0cnVjdG9yXG4gICAgICB9LCBkYXRhKSwgZnVuY3Rpb24gKGVyciwgY29udGV4dCkge1xuICAgICAgICBkYXRhLnRva2VuICAgPSB0b2tlbnMucG9wKCk7XG4gICAgICAgIGRhdGEuY29udGV4dCA9IHByZXZDb250ZXh0ID0gY29udGV4dDtcblxuICAgICAgICAvLyBJbW1lZGlhdGVseSBpbnZva2VkIGZ1bmN0aW9ucyBzaG91bGQgc2tpcCB0aGUgY29udGV4dCBwcm9jZXNzaW5nXG4gICAgICAgIC8vIHN0ZXAuIEl0J3MgYWxzbyBwb3NzaWJsZSB0aGF0IHRoaXMgdG9rZW4gd2FzIHRoZSBsYXN0IHRvIHByb2Nlc3MuXG4gICAgICAgIGlmIChkYXRhLnRva2VuICYmIGRhdGEudG9rZW4udHlwZSAhPT0gJ2ltbWVkJykge1xuICAgICAgICAgIHJldHVybiBtaWRkbGV3YXJlLnRyaWdnZXIoJ2NvbXBsZXRpb246Y29udGV4dCcsIGRhdGEsIGFnYWluKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhZ2FpbihlcnIsIGRhdGEpO1xuICAgICAgfSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHRva2Vucy5sZW5ndGggJiYgZGF0YS5jb250ZXh0ICE9IG51bGwpIHtcbiAgICAgIGRhdGEudG9rZW4gID0gdG9rZW5zLnBvcCgpO1xuICAgICAgcHJldkNvbnRleHQgPSBkYXRhLmNvbnRleHQ7XG4gICAgICByZXR1cm4gbWlkZGxld2FyZS50cmlnZ2VyKCdjb21wbGV0aW9uOmNvbnRleHQnLCBkYXRhLCBhZ2Fpbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRvbmUobnVsbCwgZGF0YSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZXNvbHZlIHRoZSBwcm9wZXJ0eSBsb29rdXAgdG9rZW5zLlxuICpcbiAqIEBwYXJhbSB7Q29kZU1pcnJvcn0gY21cbiAqIEBwYXJhbSB7QXJyYXl9ICAgICAgdG9rZW5zXG4gKiBAcGFyYW0ge09iamVjdH0gICAgIG9wdGlvbnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259ICAgZG9uZVxuICovXG5leHBvcnRzLnByb3BlcnR5TG9va3VwID0gZnVuY3Rpb24gKGNtLCB0b2tlbnMsIG9wdGlvbnMsIGRvbmUpIHtcbiAgLy8gTm8gdG9rZW5zIGV4aXN0LCB3aGljaCBtZWFucyB3ZSBhcmUgZG9pbmcgYSBsb29rdXAgYXQgdGhlIGdsb2JhbCBsZXZlbC5cbiAgaWYgKCF0b2tlbnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGRvbmUobmV3IEVycm9yKCdDb21wbGV0aW9uIG5vdCBhdmFpbGFibGUgZm9yIG9iamVjdCBwcm9wZXJ0aWVzJykpO1xuICB9XG5cbiAgdmFyIGludmFsaWQgPSBfLnNvbWUodG9rZW5zLCBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICByZXR1cm4gdG9rZW4udHlwZSA9PT0gJ2ludmFsaWQnO1xuICB9KTtcblxuICAvLyBJZiBhbnkgaW52YWxpZCB0b2tlbnMgZXhpc3QsIGZhaWwgY29tcGxldGlvbi5cbiAgaWYgKGludmFsaWQpIHtcbiAgICByZXR1cm4gZG9uZShuZXcgRXJyb3IoJ0NvbXBsZXRpb24gaXMgbm90IHBvc3NpYmxlJykpO1xuICB9XG5cbiAgLy8gUnVuIHRoZSBwcm9wZXJ0eSBsb29rdXAgZnVuY3Rpb25hbGl0eS5cbiAgZXhwb3J0cy5yZXNvbHZlVG9rZW5zKGNtLCB0b2tlbnMsIG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIsIHRva2Vucykge1xuICAgIGlmIChlcnIpIHsgcmV0dXJuIGRvbmUoZXJyKTsgfVxuXG4gICAgcmV0dXJuIGRvUHJvcGVydHlMb29rdXAoY20sIHRva2Vucywgb3B0aW9ucywgZG9uZSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBWZXJpZmllcyB3aGV0aGVyIGEgZ2l2ZW4gdG9rZW4gaXMgd2hpdGVzcGFjZSBvciBub3QuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSAgdG9rZW5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNXaGl0ZXNwYWNlVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuLnR5cGUgPT09IG51bGwgJiYgL15cXHMqJC8udGVzdCh0b2tlbi5zdHJpbmcpO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgcHJldmlvdXMgdG9rZW4gaW4gdGhlIGVkaXRvciwgdGFraW5nIGludG8gYWNjb3VudCBuZXcgbGluZXMuXG4gKlxuICogQHBhcmFtICB7Q29kZU1pcnJvcn0gY21cbiAqIEBwYXJhbSAge09iamVjdH0gICAgIHRva2VuXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuZ2V0UHJldlRva2VuID0gZnVuY3Rpb24gKGNtLCB0b2tlbikge1xuICAvLyBHZXQgdGhlIGxhc3QgdG9rZW4gb2YgdGhlIHByZXZpb3VzIGxpbmUuIElmIHdlIGFyZSBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZVxuICAvLyBlZGl0b3IgYWxyZWFkeSwgcmV0dXJuIGBudWxsYC5cbiAgaWYgKHRva2VuLnBvcy5jaCA9PT0gMCkge1xuICAgIGlmICh0b2tlbi5wb3MubGluZSA+IDApIHtcbiAgICAgIHJldHVybiBnZXRUb2tlbihjbSwge1xuICAgICAgICBjaDogICBJbmZpbml0eSxcbiAgICAgICAgbGluZTogdG9rZW4ucG9zLmxpbmUgLSAxXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGdldFRva2VuKGNtLCB0b2tlbi5wb3MpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgdG9rZW4gaXMgZW1wdHkgKG5vdCB1c2VmdWwgdG8gcGFyc2luZykuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSAgdG9rZW5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNFbXB0eVRva2VuID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gIHJldHVybiBleHBvcnRzLmlzV2hpdGVzcGFjZVRva2VuKHRva2VuKSB8fCB0b2tlbi50eXBlID09PSAnY29tbWVudCc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgdG9rZW4gcG9zaXRpb24sIHJlbW92aW5nIHBvdGVudGlhbCB3aGl0ZXNwYWNlIHRva2Vucy5cbiAqXG4gKiBAcGFyYW0gIHtDb2RlTWlycm9yfSBjbVxuICogQHBhcmFtICB7T2JqZWN0fSAgICAgdG9rZW5cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZXhwb3J0cy5lYXRFbXB0eSA9IGZ1bmN0aW9uIChjbSwgdG9rZW4pIHtcbiAgd2hpbGUgKHRva2VuICYmIGV4cG9ydHMuaXNFbXB0eVRva2VuKHRva2VuKSkge1xuICAgIHRva2VuID0gZXhwb3J0cy5nZXRQcmV2VG9rZW4oY20sIHRva2VuKTtcbiAgfVxuXG4gIHJldHVybiB0b2tlbjtcbn07XG5cbi8qKlxuICogU2ltaWxhciB0byBgZWF0RW1wdHlgLCBidXQgYWxzbyB0YWtlcyBtb3ZlcyB0aGUgY3VycmVudCB0b2tlbiBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0gIHtDb2RlTWlycm9yfSBjbVxuICogQHBhcmFtICB7T2JqZWN0fSAgICAgdG9rZW5cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZXhwb3J0cy5lYXRFbXB0eUFuZE1vdmUgPSBmdW5jdGlvbiAoY20sIHRva2VuKSB7XG4gIC8vIE5vIHRva2VuLCBicmVhay5cbiAgaWYgKCF0b2tlbikgeyByZXR1cm4gdG9rZW47IH1cblxuICByZXR1cm4gZXhwb3J0cy5lYXRFbXB0eShjbSwgZXhwb3J0cy5nZXRQcmV2VG9rZW4oY20sIHRva2VuKSk7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIHByb3BlcnR5IGNvbnRleHQgZm9yIGNvbXBsZXRpbmcgYSBwcm9wZXJ0eSBieSBsb29waW5nIHRocm91Z2ggZWFjaFxuICogb2YgdGhlIGNvbnRleHQgdG9rZW5zLiBQcm92aWRlcyBzb21lIGFkZGl0aW9uYWwgaGVscCBieSBtb3ZpbmcgcHJpbWl0aXZlcyB0b1xuICogdGhlaXIgcHJvdG90eXBlIG9iamVjdHMgc28gaXQgY2FuIGNvbnRpbnVlIGF1dG9jb21wbGV0aW9uLlxuICpcbiAqIEBwYXJhbSB7Q29kZU1pcnJvcn0gY21cbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgdG9rZW5cbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgb3B0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gICBkb25lXG4gKi9cbmV4cG9ydHMuZ2V0UHJvcGVydHlPYmplY3QgPSBmdW5jdGlvbiAoY20sIHRva2VuLCBvcHRpb25zLCBkb25lKSB7XG4gIC8vIERlZmVyIHRvIHRoZSBgZ2V0UHJvcGVydHlgIGZ1bmN0aW9uLlxuICByZXR1cm4gZXhwb3J0cy5nZXRQcm9wZXJ0eShcbiAgICBjbSwgZXhwb3J0cy5lYXRFbXB0eUFuZE1vdmUoY20sIHRva2VuKSwgb3B0aW9ucywgZG9uZVxuICApO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGV4YWN0IHZhbHVlIG9mIGEgdG9rZW4uXG4gKlxuICogQHBhcmFtIHtDb2RlTWlycm9yfSBjbVxuICogQHBhcmFtIHtPYmplY3R9ICAgICB0b2tlblxuICogQHBhcmFtIHtPYmplY3R9ICAgICBvcHRpb25zXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSAgIGRvbmVcbiAqL1xuZXhwb3J0cy5nZXRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChjbSwgdG9rZW4sIG9wdGlvbnMsIGRvbmUpIHtcbiAgcmV0dXJuIGV4cG9ydHMucHJvcGVydHlMb29rdXAoXG4gICAgY20sIGV4cG9ydHMuZ2V0UHJvcGVydHlQYXRoKGNtLCB0b2tlbiksIG9wdGlvbnMsIGRvbmVcbiAgKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBmdWxsIHByb3BlcnR5IHBhdGggdG8gYSBwcm9wZXJ0eSB0b2tlbi5cbiAqXG4gKiBAcGFyYW0gIHtDb2RlTWlycm9yfSBjbVxuICogQHBhcmFtICB7T2JqZWN0fSAgICAgdG9rZW5cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5leHBvcnRzLmdldFByb3BlcnR5UGF0aCA9IGZ1bmN0aW9uIChjbSwgdG9rZW4pIHtcbiAgdmFyIGNvbnRleHQgPSBbXTtcblxuICAvKipcbiAgICogTWl4IGluIHRvIHdpdGggYSB0b2tlbiBpbmRpY2F0ZSBhbiBpbnZhbGlkL3VuZXhwZWN0ZWQgdG9rZW4uXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB2YXIgaW52YWxpZFRva2VuID0ge1xuICAgIHR5cGU6ICdpbnZhbGlkJyxcbiAgICBzdHJpbmc6IG51bGxcbiAgfTtcblxuICAvKipcbiAgICogRWF0cyB0aGUgY3VycmVudCB0b2tlbiBhbmQgYW55IHdoaXRlc3BhY2UuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gdG9rZW5cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgdmFyIGVhdFRva2VuID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZWF0RW1wdHlBbmRNb3ZlKGNtLCB0b2tlbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlc29sdmVzIHJlZ3VsYXIgcHJvcGVydHkgbm90YXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gdG9rZW5cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgdmFyIHJlc29sdmVUb2tlbiA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgIGNvbnRleHQucHVzaCh0b2tlbik7XG4gICAgcmV0dXJuIGVhdFRva2VuKHRva2VuKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVzb2x2ZXMgc3F1YXJlIGJyYWNrZXQgbm90YXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gdG9rZW5cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgdmFyIHJlc29sdmVEeW5hbWljUHJvcGVydHkgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICB2YXIgbGV2ZWwgPSAxO1xuICAgIHZhciBwcmV2ICA9IHRva2VuO1xuXG4gICAgd2hpbGUgKGxldmVsID4gMCAmJiAodG9rZW4gPSBleHBvcnRzLmdldFByZXZUb2tlbihjbSwgdG9rZW4pKSkge1xuICAgICAgaWYgKHRva2VuLnN0cmluZyA9PT0gJ10nKSB7XG4gICAgICAgIGxldmVsKys7XG4gICAgICB9IGVsc2UgaWYgKHRva2VuLnN0cmluZyA9PT0gJ1snKSB7XG4gICAgICAgIGxldmVsLS07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgb3BlbiB0b2tlbiB0byBjb25maXJtIHRoZSBsb2NhdGlvbiBpbiB0aGUgYnJhY2tldFxuICAgIC8vIHJlc29sdXRpb24uXG4gICAgdmFyIHN0YXJ0VG9rZW4gPSB0b2tlbjtcbiAgICB0b2tlbiA9IGVhdFRva2VuKHRva2VuKTtcblxuICAgIC8vIFJlc29sdmUgdGhlIGNvbnRlbnRzIG9mIHRoZSBicmFja2V0cyBhcyBhIHRleHQgc3RyaW5nLlxuICAgIHZhciBzdHJpbmcgPSBjbS5kb2MuZ2V0UmFuZ2Uoe1xuICAgICAgY2g6ICAgc3RhcnRUb2tlbi5zdGFydCxcbiAgICAgIGxpbmU6IHN0YXJ0VG9rZW4ucG9zLmxpbmVcbiAgICB9LCB7XG4gICAgICBjaDogICBwcmV2LmVuZCxcbiAgICAgIGxpbmU6IHByZXYucG9zLmxpbmVcbiAgICB9KTtcblxuICAgIC8vIE9ubHkga2ljayBpbnRvIGJyYWNrZXQgbm90YXRpb24gbW9kZSB3aGVuIHRoZSBwcmVjZWRpbmcgdG9rZW4gaXMgYVxuICAgIC8vIHByb3BlcnR5LCB2YXJpYWJsZSwgc3RyaW5nLCBldGMuIE9ubHkgdGhpbmdzIHlvdSBjYW4ndCB1c2UgaXQgb24gYXJlXG4gICAgLy8gYHVuZGVmaW5lZGAgYW5kIGBudWxsYCAoYW5kIHN5bnRheCwgb2YgY291cnNlKS5cbiAgICBpZiAodG9rZW4gJiYgY2FuQWNjZXNzKHRva2VuKSkge1xuICAgICAgaWYgKGVhdFRva2VuKHByZXYpLnN0cmluZyA9PT0gJ1snKSB7XG4gICAgICAgIGNvbnRleHQucHVzaChfLmV4dGVuZCh0b2tlbiwgaW52YWxpZFRva2VuKSk7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIH1cblxuICAgICAgdmFyIHN1YkNvbnRleHQgPSBleHBvcnRzLmdldFByb3BlcnR5UGF0aChjbSwgZWF0VG9rZW4ocHJldikpO1xuICAgICAgdmFyIHN0YXJ0UG9zICAgPSBlYXRUb2tlbihzdWJDb250ZXh0W3N1YkNvbnRleHQubGVuZ3RoIC0gMV0pLnN0YXJ0O1xuXG4gICAgICAvLyBFbnN1cmVzIHRoYXQgdGhlIG9ubHkgdG9rZW5zIGJlaW5nIHJlc29sdmVkIGNhbiBiZSBkb25lIHN0YXRpY2FsbHkuXG4gICAgICBpZiAoc3RhcnRQb3MgPT09IHN0YXJ0VG9rZW4uc3RhcnQpIHtcbiAgICAgICAgY29udGV4dC5wdXNoKF8uZXh0ZW5kKHByZXYsIHtcbiAgICAgICAgICBzdGFydDogIHN1YkNvbnRleHRbc3ViQ29udGV4dC5sZW5ndGggLSAxXS5zdGFydCxcbiAgICAgICAgICBlbmQ6ICAgIHN1YkNvbnRleHRbMF0uZW5kLFxuICAgICAgICAgIHN0cmluZzogc3RyaW5nLFxuICAgICAgICAgIHRva2Vuczogc3ViQ29udGV4dCxcbiAgICAgICAgICBzdGF0ZTogIHByZXYuc3RhdGUsXG4gICAgICAgICAgdHlwZTogICAnZHluYW1pYy1wcm9wZXJ0eSdcbiAgICAgICAgfSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5wdXNoKF8uZXh0ZW5kKHRva2VuLCBpbnZhbGlkVG9rZW4pKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cblxuICAgIGlmICghdG9rZW4gfHwgdG9rZW4udHlwZSA9PT0gbnVsbCkge1xuICAgICAgY29udGV4dC5wdXNoKHtcbiAgICAgICAgc3RhcnQ6ICBzdGFydFRva2VuLnN0YXJ0LFxuICAgICAgICBlbmQ6ICAgIHByZXYuZW5kLFxuICAgICAgICBzdHJpbmc6IHN0cmluZyxcbiAgICAgICAgc3RhdGU6ICBwcmV2LnN0YXRlLFxuICAgICAgICB0eXBlOiAgICdhcnJheSdcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0b2tlbjtcbiAgfTtcblxuICAvKipcbiAgICogUmVzb2x2ZXMgdGhlIGNsb3NpbmcgcGFyZW50aGVzaXMgdG8gYSBwb3NzaWJsZSBmdW5jdGlvbiBvciBjb250ZXh0IGNoYW5nZS5cbiAgICpcbiAgICogQHBhcmFtICB7W3R5cGVdfSB0b2tlbiBbZGVzY3JpcHRpb25dXG4gICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgdmFyIHJlc29sdmVQb3NzaWJsZUZ1bmN0aW9uID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgdmFyIGxldmVsID0gMTtcbiAgICB2YXIgcHJldiAgPSB0b2tlbjtcblxuICAgIC8vIFdoaWxlIHN0aWxsIGluIHBhcmVucyAqYW5kIG5vdCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBlZGl0b3IqXG4gICAgd2hpbGUgKGxldmVsID4gMCAmJiAodG9rZW4gPSBleHBvcnRzLmdldFByZXZUb2tlbihjbSwgdG9rZW4pKSkge1xuICAgICAgaWYgKHRva2VuLnN0cmluZyA9PT0gJyknKSB7XG4gICAgICAgIGxldmVsKys7XG4gICAgICB9IGVsc2UgaWYgKHRva2VuLnN0cmluZyA9PT0gJygnKSB7XG4gICAgICAgIGxldmVsLS07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTm8gc3VwcG9ydCBmb3IgcmVzb2x2aW5nIGFjcm9zcyBtdWx0aXBsZSBsaW5lcy4uIHlldC5cbiAgICBpZiAobGV2ZWwgPiAwKSB7XG4gICAgICBjb250ZXh0LnB1c2goXy5leHRlbmQodG9rZW4gfHwge30sIGludmFsaWRUb2tlbikpO1xuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cblxuICAgIHRva2VuID0gZWF0VG9rZW4odG9rZW4pO1xuXG4gICAgLy8gUmVzb2x2ZXMgYXMgYSBmdW5jdGlvbiBhcmd1bWVudC5cbiAgICBpZiAodG9rZW4gJiYgY2FuQWNjZXNzKHRva2VuKSkge1xuICAgICAgLy8gSWYgdGhlIHByZXZpb3VzIHRva2VuIHdhcyBhIGZ1bmN0aW9uIChFLmcuIHRoZSBjbG9zaW5nIHBhcmVuKSBpdCBtdXN0XG4gICAgICAvLyBiZSBhbiBpbW1lZGlhdGVseSBpbnZva2VkIHByb3BlcnR5LlxuICAgICAgaWYgKHByZXYuaXNGdW5jdGlvbikge1xuICAgICAgICBjb250ZXh0LnB1c2goXy5leHRlbmQocHJldiwge1xuICAgICAgICAgIHR5cGU6ICAgICAgICdpbW1lZCcsXG4gICAgICAgICAgc3RyaW5nOiAgICAgbnVsbCxcbiAgICAgICAgICBpc0Z1bmN0aW9uOiB0cnVlXG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgdG9rZW4uaXNGdW5jdGlvbiA9IHRydWU7XG4gICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuXG4gICAgLy8gU2V0IGB0b2tlbmAgdG8gYmUgdGhlIHRva2VuIGluc2lkZSB0aGUgcGFyZW5zIGFuZCBzdGFydCB3b3JraW5nIGZyb21cbiAgICAvLyB0aGF0IGluc3RlYWQuXG4gICAgaWYgKCF0b2tlbiB8fCB0b2tlbi50eXBlID09PSBudWxsKSB7XG4gICAgICB2YXIgc3ViQ29udGV4dCA9IGV4cG9ydHMuZ2V0UHJvcGVydHlQYXRoKGNtLCBlYXRUb2tlbihwcmV2KSk7XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0IGNvdWxkIGJlIGJlaW5nIGludm9rZWQgYXMgYSBmdW5jdGlvbi5cbiAgICAgIGlmIChwcmV2LmlzRnVuY3Rpb24gJiYgc3ViQ29udGV4dC5sZW5ndGgpIHtcbiAgICAgICAgc3ViQ29udGV4dFswXS5pc0Z1bmN0aW9uID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIHN1YmNvbnRleHQgaGFzIGNvcnJlY3RseSBzZXQgdGhlIGBuZXdgIGZsYWcuXG4gICAgICBpZiAoc3ViQ29udGV4dC5oYXNOZXcgJiYgc3ViQ29udGV4dC5sZW5ndGgpIHtcbiAgICAgICAgc3ViQ29udGV4dFswXS5pc0Z1bmN0aW9uICAgID0gdHJ1ZTtcbiAgICAgICAgc3ViQ29udGV4dFswXS5pc0NvbnN0cnVjdG9yID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5wdXNoLmFwcGx5KGNvbnRleHQsIHN1YkNvbnRleHQpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBlYXRUb2tlbih0b2tlbik7XG4gIH07XG5cbiAgd2hpbGUgKHRva2VuICYmICh0b2tlbi5zdHJpbmcgPT09ICcuJyB8fCBjYW5BY2Nlc3ModG9rZW4pKSkge1xuICAgIC8vIFNraXAgb3ZlciBwZXJpb2Qgbm90YXRpb24uXG4gICAgaWYgKHRva2VuLnR5cGUgPT09IG51bGwgJiYgdG9rZW4uc3RyaW5nID09PSAnLicpIHtcbiAgICAgIHRva2VuID0gZWF0VG9rZW4odG9rZW4pO1xuICAgIH1cblxuICAgIC8vIFNwZWNpYWwgY2FzZSB2YXJpYWJsZSB0b2tlbnMgc2luY2Ugd2UgZG9uJ3Qgd2FudCB0aGUgY29udGV4dCB0byBjb250aW51ZVxuICAgIC8vIGNvbXBsZXRpbmcgYWZ0ZXIgd2UgaGl0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGNoYWluLlxuICAgIGlmICh0b2tlbi50eXBlID09PSAndmFyaWFibGUnKSB7XG4gICAgICB0b2tlbiA9IHJlc29sdmVUb2tlbih0b2tlbik7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBBdHRlbXB0IHRvIHJlc29sdmUgYSBkeW5tYWljIHByb3BlcnR5IG9yIGFycmF5IGxpdGVyYWwuXG4gICAgaWYgKHRva2VuLnN0cmluZyA9PT0gJ10nKSB7XG4gICAgICB0b2tlbiA9IHJlc29sdmVEeW5hbWljUHJvcGVydHkodG9rZW4pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gQXR0ZW1wdCB0byByZXNvbHZlIGEgZnVuY3Rpb24gaW52b2thdGlvbiwgc2ltcGx5IHVzaW5nIHBhcmVudGhlc2lzIHRvXG4gICAgLy8gZW5jbG9zZSBhIHByb3BlcnR5L3ZhcmlhYmxlLCB1c2luZyB0aGUgcGFyZW50aGVzaXMgd2l0aCBgbmV3YCwgZXRjLlxuICAgIGlmICh0b2tlbi5zdHJpbmcgPT09ICcpJykge1xuICAgICAgdG9rZW4gPSByZXNvbHZlUG9zc2libGVGdW5jdGlvbih0b2tlbik7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBSZXNvbHZlIGFueSBvdGhlciBwcm9wZXJ0eSB0aGF0IGFsbG93cyBhY2Nlc3MgYXMgbm9ybWFsLlxuICAgIGlmIChjYW5BY2Nlc3ModG9rZW4pKSB7XG4gICAgICB0b2tlbiA9IHJlc29sdmVUb2tlbih0b2tlbik7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBtYWRlIGl0IHRvIHRoaXMgcG9pbnQsIHRoZSB0b2tlbiBpcyBpbnZhbGlkLlxuICAgIHRva2VuID0gXy5leHRlbmQodG9rZW4sIGludmFsaWRUb2tlbik7XG4gICAgY29udGV4dC5wdXNoKHRva2VuKTtcbiAgICBicmVhaztcbiAgfVxuXG4gIC8vIFVzaW5nIHRoZSBuZXcga2V5d29yZCBkb2Vzbid0IGFjdHVhbGx5IHJlcXVpcmUgcGFyZW5zIHRvIGludm9rZSwgc28gd2UgbmVlZFxuICAvLyB0byBkbyBhIHF1aWNrIHNwZWNpYWwgY2FzZSBjaGVjayBoZXJlLlxuICBpZiAodG9rZW4gJiYgdG9rZW4udHlwZSA9PT0gJ2tleXdvcmQnICYmIHRva2VuLnN0cmluZyA9PT0gJ25ldycpIHtcbiAgICBjb250ZXh0Lmhhc05ldyA9IHRydWU7XG5cbiAgICAvLyBUcnkgdG8gc2V0IHRoZSBmaXJzdCBmdW5jdGlvbiB0byBiZSB0aGUgY29uc3RydWN0b3IgZnVuY3Rpb24uIFRoZVxuICAgIC8vIGNvbnRleHQgYXJyYXkgaXMgaW4gcmV2ZXJzZSwgc28gd2UgbmVlZCB0byBpdGVyYXRlIGFjY29yZGluZ2x5LlxuICAgIHZhciBsZW5ndGggPSBjb250ZXh0Lmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgLy8gUmVtb3ZlIHRoZSBnbG9iYWwgY29udGV4dCBgaGFzTmV3YCBmbGFnIGFuZCBzZXQgdGhlIGZvdW5kIGZ1bmN0aW9uXG4gICAgICAvLyB0byBiZSBhIGNvbnN0cnVjdG9yLlxuICAgICAgaWYgKGNvbnRleHRbbGVuZ3RoXS5pc0Z1bmN0aW9uKSB7XG4gICAgICAgIGRlbGV0ZSBjb250ZXh0Lmhhc05ldztcbiAgICAgICAgY29udGV4dFtsZW5ndGhdLmlzQ29uc3RydWN0b3IgPSB0cnVlO1xuXG4gICAgICAgIC8vIEJyZWFrIGJlZm9yZSBzZXR0aW5nIGFueSBvdGhlciBjb250ZXh0IHByb3BlcnRpZXMuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb250ZXh0O1xufTtcbiIsIi8qKlxuICogQ2hlY2sgaWYgdGhlIHNjb3BlIGNoYWluIGNvbnRhaW5zIGEgc3BlY2lmaWMgdmFsdWUuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSAgc2NvcGVcbiAqIEBwYXJhbSAge1N0cmluZ30gIHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzY29wZSwgdmFsdWUpIHtcbiAgd2hpbGUgKHNjb3BlKSB7XG4gICAgaWYgKHNjb3BlLm5hbWUgPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBzY29wZSA9IHNjb3BlLm5leHQ7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuIiwidmFyIF8gICAgICAgICAgICA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBnZXRUb2tlbiAgICAgPSByZXF1aXJlKCcuLi9jb2RlbWlycm9yL2dldC10b2tlbicpO1xudmFyIHRva2VuSGVscGVycyA9IHJlcXVpcmUoJy4uL2NvZGVtaXJyb3IvdG9rZW4taGVscGVycycpO1xudmFyIG1lc3NhZ2VzICAgICA9IHJlcXVpcmUoJy4uLy4uL3N0YXRlL21lc3NhZ2VzJyk7XG52YXIgZm9ybWF0RG9jcyAgID0gcmVxdWlyZSgnLi9mb3JtYXQtZG9jdW1lbnRhdGlvbicpO1xuXG4vKipcbiAqIEFuIG1hcCBvZiBwb3NzaWJsZSBmdW5jdGlvbiB0eXBlcy5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgRlVOQ1RJT05fVFlQRVMgPSB7XG4gIHZhcmlhYmxlOiB0cnVlLFxuICBwcm9wZXJ0eTogdHJ1ZVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIHRva2VuIGlzIGJlZm9yZSBhbm90aGVyIHRva2VuLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gIHBvc1xuICogQHBhcmFtICB7T2JqZWN0fSAgYmVmb3JlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG52YXIgaXNUb2tlbkJlZm9yZSA9IGZ1bmN0aW9uIChwb3MsIGJlZm9yZSkge1xuICBpZiAocG9zLmxpbmUgPCBiZWZvcmUubGluZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHBvcy5saW5lID09PSBiZWZvcmUubGluZSAmJiBwb3MuY2ggPCBiZWZvcmUuY2gpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmVuZGVyIGEgbmV3IGFyZ3VtZW50IGRvY3VtZW50YXRpb24uXG4gKlxuICogQHBhcmFtICB7Q29tcGxldGlvbn0gICBjb21wbGV0aW9uXG4gKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgIGRhdGFcbiAqIEByZXR1cm4ge0FyZ3VtZW50RG9jc31cbiAqL1xudmFyIEFyZ3VtZW50RG9jcyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNvbXBsZXRpb24sIGRhdGEpIHtcbiAgdGhpcy5kYXRhICAgICAgID0gZGF0YTtcbiAgdGhpcy5jb21wbGV0aW9uID0gY29tcGxldGlvbjtcblxuICB2YXIgcGFyYW1zICAgICAgICA9IHRoaXMucGFyYW1zID0gW107XG4gIHZhciBjbSAgICAgICAgICAgID0gdGhpcy5jb21wbGV0aW9uLmNtO1xuICB2YXIgY3VyTGluZSAgICAgICA9IHRoaXMuY3VyTGluZSA9IGNtLmdldEN1cnNvcigpLmxpbmU7XG4gIHZhciBkb2N1bWVudGF0aW9uID0gdGhpcy5kb2N1bWVudGF0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHZhciB0eXBlICAgICAgICAgID0gZGF0YS5kZXNjcmlwdGlvblsnIXR5cGUnXTtcbiAgdmFyIHJlc3VsdCAgICAgICAgPSBkYXRhLmRlc2NyaXB0aW9uWychcmV0dXJuJ107XG4gIHZhciB0aXRsZSAgICAgICAgID0gZG9jdW1lbnRhdGlvbi5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG5cbiAgdGl0bGUuY2xhc3NOYW1lICAgICAgICAgPSAnQ29kZU1pcnJvci1kb2N1bWVudGF0aW9uLXRpdGxlJztcbiAgZG9jdW1lbnRhdGlvbi5jbGFzc05hbWUgPSAnQ29kZU1pcnJvci1kb2N1bWVudGF0aW9uJztcblxuICAvLyBHZXQgdGhlIGZ1bmN0aW9uIG5hbWUgYXMgdGhlIHZhcmlhYmxlIHByZWNlZGluZyB0aGUgb3BlbmluZyBicmFja2V0LlxuICB2YXIgZm5OYW1lID0gdGhpcy5mbk5hbWUgPSB0b2tlbkhlbHBlcnMuZWF0RW1wdHkoXG4gICAgY20sIGdldFRva2VuKGNtLCB0aGlzLmRhdGEuZnJvbSlcbiAgKS5zdHJpbmc7XG5cbiAgLy8gQXBwZW5kIGEgdGV4dCBub2RlIHdpdGggdGhlIGNvcnJlY3QgdG9rZW4gc3RyaW5nLlxuICB0aXRsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShmbk5hbWUgKyAnKCcpKTtcblxuICBfLmVhY2goL15mblxcKCguKilcXCkvLmV4ZWModHlwZSlbMV0uc3BsaXQoJywgJyksIGZ1bmN0aW9uIChhcmcsIGluZGV4LCBhcmdzKSB7XG4gICAgdmFyIHBhcmFtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIHBhcmFtLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGFyZykpO1xuXG4gICAgcGFyYW1zLnB1c2gocGFyYW0pO1xuICAgIHRpdGxlLmFwcGVuZENoaWxkKHBhcmFtKTtcblxuICAgIGlmIChpbmRleCA8IGFyZ3MubGVuZ3RoIC0gMSkge1xuICAgICAgdGl0bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJywgJykpO1xuICAgIH1cbiAgfSk7XG5cbiAgdGl0bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJyknKSk7XG5cbiAgaWYgKHJlc3VsdCkge1xuICAgIHRpdGxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcgLT4gJyArIHJlc3VsdCkpO1xuICB9XG5cbiAgLy8gQXBwZW5kIGEgc3RhdGljIGNvbnRhaW5lciBmb3IgZG9jdW1lbnRhdGlvbi5cbiAgdGhpcy5kZXNjcmlwdGlvbiA9IGRvY3VtZW50YXRpb24uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpO1xuICB0aGlzLmRlc2NyaXB0aW9uLmNsYXNzTmFtZSA9ICdDb2RlTWlycm9yLWRvY3VtZW50YXRpb24tZGVzY3JpcHRpb24nO1xuXG4gIC8vIEF0dGFjaCB0aGUgd2lkZ2V0IGJlbG93IHRoZSBjdXJyZW50IGxpbmUuXG4gIHRoaXMud2lkZ2V0ID0gY20uYWRkTGluZVdpZGdldChjdXJMaW5lLCBkb2N1bWVudGF0aW9uKTtcblxuICB0aGlzLnVwZGF0ZSgpO1xufTtcblxuLyoqXG4gKiBTaG93IHRoZSBkb2N1bWVudGF0aW9uIGZvciBhIHNwZWNpZmljIGFyZ3VtZW50LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICovXG5Bcmd1bWVudERvY3MucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICB2YXIgcHJlZml4ICAgPSAnQ29kZU1pcnJvci1kb2N1bWVudGF0aW9uLWRlc2NyaXB0aW9uLSc7XG4gIHZhciBhcmd1bWVudCA9IHRoaXMuZGF0YS5kZXNjcmlwdGlvblsnIWFyZ3MnXVtpbmRleF07XG4gIHZhciBjbSAgICAgICA9IHRoaXMuY29tcGxldGlvbi5jbTtcbiAgdmFyIGN1ckxpbmUgID0gY20uZ2V0Q3Vyc29yKCkubGluZTtcblxuICAvLyBNYWtlIGl0IGZvbGxvdyB0aGUgc2VsZWN0ZWQgbGluZS5cbiAgaWYgKGN1ckxpbmUgIT09IHRoaXMuY3VyTGluZSkge1xuICAgIHRoaXMucmVtb3ZlV2lkZ2V0KCk7XG4gICAgdGhpcy53aWRnZXQgID0gY20uYWRkTGluZVdpZGdldChjdXJMaW5lLCB0aGlzLmRvY3VtZW50YXRpb24pO1xuICAgIHRoaXMuY3VyTGluZSA9IGN1ckxpbmU7XG4gIH1cblxuICAvLyBBdm9pZGluZyByZXNlbGVjdGluZyB0aGUgc2FtZSBhcmd1bWVudC5cbiAgaWYgKHRoaXMuY3VycmVudEFyZ3VtZW50ID09PSBpbmRleCkgeyByZXR1cm47IH1cblxuICAvLyBTZXQgdGhlIGNvcnJlY3QgYXJndW1lbnQgdG8gYWN0aXZlLlxuICBfLmVhY2godGhpcy5wYXJhbXMsIGZ1bmN0aW9uIChwYXJhbSwgcG9zaXRpb24pIHtcbiAgICBwYXJhbS5jbGFzc0xpc3RbaW5kZXggPT09IHBvc2l0aW9uID8gJ2FkZCcgOiAncmVtb3ZlJ10oXG4gICAgICAnQ29kZU1pcnJvci1kb2N1bWVudGF0aW9uLWFyZ3VtZW50LWFjdGl2ZSdcbiAgICApO1xuICB9KTtcblxuICAvLyBFbXB0eSB0aGUgZGVzY3JpcHRpb24gZWxlbWVudCBiZWZvcmUgYXBwZW5kaW5nIG5ldyBkb2NzLlxuICB0aGlzLmRlc2NyaXB0aW9uLmlubmVySFRNTCA9ICcnO1xuICB0aGlzLmN1cnJlbnRBcmd1bWVudCAgICAgICA9IGluZGV4O1xuXG4gIGlmICghYXJndW1lbnQpIHtcbiAgICB0aGlzLndpZGdldC5jaGFuZ2VkKCk7XG4gICAgcmV0dXJuIG1lc3NhZ2VzLnRyaWdnZXIoJ3Jlc2l6ZScpO1xuICB9XG5cbiAgLy8gTWFwIHRoZSBkb2N1bWVudGF0aW9uIHRvIHRoZSBkZXNjcmlwdGlvbiByZW5kZXJpbmcuXG4gIHZhciBkb2NzID0gXy5vYmplY3QoXy5tYXAoZm9ybWF0RG9jcyhhcmd1bWVudCksIGZ1bmN0aW9uIChkb2NzLCB0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT09ICd1cmwnKSB7XG4gICAgICBkb2NzID0gJzxhIGhyZWY9XCInICsgZG9jcyArICdcIiB0YXJnZXQ9XCJfYmxhbmtcIj5SZWFkIG1vcmU8L2E+JztcbiAgICB9XG5cbiAgICByZXR1cm4gW3R5cGUsICc8ZGl2IGNsYXNzPVwiJyArIHByZWZpeCArIHR5cGUgKyAnXCI+JyArIGRvY3MgKyAnPC9kaXY+J107XG4gIH0pKTtcblxuICB0aGlzLmRlc2NyaXB0aW9uLmlubmVySFRNTCArPSBkb2NzLnR5cGUgfHwgJyc7XG4gIHRoaXMuZGVzY3JpcHRpb24uaW5uZXJIVE1MICs9IGRvY3MuZG9jICB8fCAnJztcbiAgdGhpcy5kZXNjcmlwdGlvbi5pbm5lckhUTUwgKz0gZG9jcy51cmwgIHx8ICcnO1xuXG4gIHRoaXMud2lkZ2V0LmNoYW5nZWQoKTtcbiAgcmV0dXJuIG1lc3NhZ2VzLnRyaWdnZXIoJ3Jlc2l6ZScpO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIGFyZ3VtZW50IGRvY3VtZW50YXRpb24gcG9zaXRpb24uXG4gKi9cbkFyZ3VtZW50RG9jcy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY20gPSB0aGlzLmNvbXBsZXRpb24uY207XG5cbiAgLy8gUmVtb3ZlIHRoZSBkb2N1bWVudGF0aW9uIHdoZW4gbXVsdGlwbGUgY2hhcmFjdGVycyBhcmUgc2VsZWN0ZWQuXG4gIGlmIChjbS5kb2Muc29tZXRoaW5nU2VsZWN0ZWQoKSkge1xuICAgIHJldHVybiB0aGlzLnJlbW92ZSgpO1xuICB9XG5cbiAgdmFyIGN1ciAgICAgICAgPSB0aGlzLmRhdGEudG8gPSBjbS5nZXRDdXJzb3IoKTtcbiAgdmFyIGZyb20gICAgICAgPSB0aGlzLmRhdGEuZnJvbTtcbiAgdmFyIHRva2VuICAgICAgPSBnZXRUb2tlbihjbSwgY3VyKTtcbiAgdmFyIGluZGV4ICAgICAgPSAwO1xuICB2YXIgY3VyQ291bnQgICA9IDA7XG4gIHZhciByb3VuZExldmVsID0gMDtcbiAgdmFyIGN1cmx5TGV2ZWwgPSAwO1xuXG4gIC8vIFJlbW92ZSB0aGUgZG9jdW1lbnRhdGlvbiBpZiB3ZSBhcmUgc3RhdGluZyBiZWZvcmUgdGhlIG9wZW5pbmcgYnJhY2tldC5cbiAgaWYgKGlzVG9rZW5CZWZvcmUodG9rZW4ucG9zLCBmcm9tKSkge1xuICAgIHJldHVybiB0aGlzLnJlbW92ZSgpO1xuICB9XG5cbiAgLy8gSXRlcmF0ZSBvdmVyIGV2ZXJ5IG5ldyBibG9jayBhbmQgdHJhY2sgb3VyIGFyZ3VtZW50IGluZGV4LiBJZiB3ZSBoaXRcbiAgLy8gYSBuZXcgZnVuY3Rpb24gaW5zaWRlIHRoZSBjdXJyZW50IGFyZ3VtZW50cywgcmVtb3ZlIHRoZSBjdXJyZW50IHdpZGdldC5cbiAgd2hpbGUgKCFpc1Rva2VuQmVmb3JlKHRva2VuLnBvcywgZnJvbSkpIHtcbiAgICBpZiAodG9rZW4udHlwZSA9PT0gbnVsbCkge1xuICAgICAgaWYgKHRva2VuLnN0cmluZyA9PT0gJygnKSB7XG4gICAgICAgIHJvdW5kTGV2ZWwrKztcblxuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcmVzb2x2ZWQgcm91bmQgbGV2ZWwsIGl0IHdvdWxkIGhhdmUganVzdCBjb21wbGV0ZWRcbiAgICAgICAgLy8gYnJhY2tldCBub3RhdGlvbiB3aGljaCBjYW4gY29udGFpbiBjb21tYXMuXG4gICAgICAgIGlmIChyb3VuZExldmVsID4gLTEpIHtcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgZG9uJ3QgcmVzZXQgb24gdGhlIHJlYWwgb3BlbmluZyBicmFja2V0LlxuICAgICAgICAgIGlmICghKHRva2VuLnBvcy5jaCA9PT0gZnJvbS5jaCAmJiB0b2tlbi5wb3MubGluZSA9PT0gZnJvbS5saW5lKSkge1xuICAgICAgICAgICAgaW5kZXggLT0gY3VyQ291bnQ7XG4gICAgICAgICAgICBjdXJDb3VudCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHByZXZpb3VzIHRva2VuIGlzIGEgZnVuY3Rpb24gdHlwZS5cbiAgICAgICAgdmFyIHByZXYgID0gdG9rZW5IZWxwZXJzLmVhdEVtcHR5QW5kTW92ZShjbSwgdG9rZW4pO1xuICAgICAgICB2YXIgbWF0Y2ggPSB0b2tlbi5zdGFydCA9PT0gZnJvbS5jaCAmJiB0b2tlbi5wb3MubGluZSA9PT0gZnJvbS5saW5lO1xuXG4gICAgICAgIGlmIChyb3VuZExldmVsID4gMCAmJiBGVU5DVElPTl9UWVBFU1twcmV2LnR5cGVdICYmICFtYXRjaCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRva2VuLnN0cmluZyA9PT0gJyknKSB7XG4gICAgICAgIHJvdW5kTGV2ZWwtLTtcblxuICAgICAgICBpZiAocm91bmRMZXZlbCA8IC0xKSB7XG4gICAgICAgICAgaW5kZXggLT0gY3VyQ291bnQ7XG4gICAgICAgICAgY3VyQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKHJvdW5kTGV2ZWwgPT09IC0xKSB7XG4gICAgICAgICAgY3VyQ291bnQgPSAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRva2VuLnN0cmluZyA9PT0gJ3snKSB7XG4gICAgICAgIGN1cmx5TGV2ZWwrKztcblxuICAgICAgICBpZiAoY3VybHlMZXZlbCA+IC0xKSB7XG4gICAgICAgICAgaW5kZXggLT0gY3VyQ291bnQ7XG4gICAgICAgICAgY3VyQ291bnQgPSAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRva2VuLnN0cmluZyA9PT0gJ30nKSB7XG4gICAgICAgIGN1cmx5TGV2ZWwtLTtcblxuICAgICAgICBpZiAoY3VybHlMZXZlbCA8IC0xKSB7XG4gICAgICAgICAgaW5kZXggLT0gY3VyQ291bnQ7XG4gICAgICAgICAgY3VyQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGN1cmx5TGV2ZWwgPT09IC0xKSB7XG4gICAgICAgICAgY3VyQ291bnQgPSAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRva2VuLnN0cmluZyA9PT0gJywnKSB7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICAgIGN1ckNvdW50Kys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdG9rZW4gPSB0b2tlbkhlbHBlcnMuZWF0RW1wdHlBbmRNb3ZlKGNtLCB0b2tlbik7XG4gIH1cblxuICAvLyBJZiB0aGVyZSBpcyBubyBibG9jayBsZXZlbCwgd2UgYXJlIG5vIGxvbmdlciBpbnNpZGUgdGhlIGFyZ3VtZW50cy5cbiAgaWYgKHJvdW5kTGV2ZWwgPCAxKSB7XG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlKCk7XG4gIH1cblxuICB0aGlzLnNlbGVjdChpbmRleCk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgd2lkZ2V0IGZyb20gdGhlIGVkaXRvci5cbiAqL1xuQXJndW1lbnREb2NzLnByb3RvdHlwZS5yZW1vdmVXaWRnZXQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLndpZGdldCkge1xuICAgIHRoaXMud2lkZ2V0LmNsZWFyKCk7XG4gICAgbWVzc2FnZXMudHJpZ2dlcigncmVzaXplJyk7XG4gICAgZGVsZXRlIHRoaXMud2lkZ2V0O1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgYXJndW1lbnQgZG9jdW1lbnRhdGlvbiBmcm9tIHRoZSBlZGl0b3IuXG4gKi9cbkFyZ3VtZW50RG9jcy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJlbW92ZVdpZGdldCgpO1xuICBkZWxldGUgdGhpcy5kb2N1bWVudGF0aW9uO1xuICBkZWxldGUgdGhpcy5jb21wbGV0aW9uLmRvY3VtZW50YXRpb247XG59O1xuIiwidmFyIG1hcmtlZCA9IHJlcXVpcmUoJ21hcmtlZCcpO1xuXG4vKipcbiAqIEZvcm1hdCB0aGUgc3RhbmRhcmQgZGVzY3JpcHRpb24gb2JqZWN0IGZvciByZW5kZXJpbmcgaW4gdGhlIGJyb3dzZXIuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBkZXNjcmlwdGlvblxuICogQHBhcmFtICB7U3RyaW5nfSB2YXJpYWJsZVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkZXNjcmlwdGlvbiwgdmFyaWFibGUpIHtcbiAgdmFyIGZvcm1hdHRlZCA9IHt9O1xuXG4gIGlmIChkZXNjcmlwdGlvblsnIWRvYyddKSB7XG4gICAgZm9ybWF0dGVkLmRvYyA9IG1hcmtlZChkZXNjcmlwdGlvblsnIWRvYyddLCB7XG4gICAgICBnZm06IHRydWUsXG4gICAgICB0YWJsZXM6IHRydWUsXG4gICAgICBzYW5pdGl6ZTogdHJ1ZSxcbiAgICAgIHNtYXJ0TGlzdHM6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChkZXNjcmlwdGlvblsnIXVybCddKSB7XG4gICAgZm9ybWF0dGVkLnVybCA9IGRlc2NyaXB0aW9uWychdXJsJ107XG4gIH1cblxuICBpZiAoZGVzY3JpcHRpb25bJyF0eXBlJ10pIHtcbiAgICBmb3JtYXR0ZWQudHlwZSA9IGRlc2NyaXB0aW9uWychdHlwZSddO1xuXG4gICAgaWYgKHZhcmlhYmxlICYmIC9eZm5cXCgvLnRlc3QoZm9ybWF0dGVkLnR5cGUpKSB7XG4gICAgICBmb3JtYXR0ZWQudHlwZSA9IHZhcmlhYmxlICsgZm9ybWF0dGVkLnR5cGUuc3Vic3RyKDIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmb3JtYXR0ZWQ7XG59O1xuIiwidmFyIF8gICAgICAgID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBnaG9zdCB0ZXh0IHdpZGdldCB0aGF0IGlzIHVzZWQgdG8gcmVuZGVyIENocm9tZS1zdHlsZSBjb21wbGV0aW9uLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gd2lkZ2V0XG4gKiBAcGFyYW0gIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSAge1N0cmluZ30gdGV4dFxuICogQHJldHVybiB7R2hvc3R9XG4gKi9cbnZhciBHaG9zdCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHdpZGdldCwgcmVzdWx0KSB7XG4gIHRoaXMuY20gICAgID0gd2lkZ2V0LmNvbXBsZXRpb24uY207XG4gIHRoaXMucmVzdWx0ID0gcmVzdWx0O1xuICB0aGlzLndpZGdldCA9IHdpZGdldDtcblxuICB2YXIgdGhhdCAgICAgID0gdGhpcztcbiAgdmFyIHRleHQgICAgICA9ICcnO1xuICB2YXIgZGF0YSAgICAgID0gd2lkZ2V0LmRhdGE7XG4gIHZhciBzdWJzdHJpbmcgPSB0aGlzLnJlc3VsdC52YWx1ZS5zdWJzdHIoMCwgZGF0YS50by5jaCAtIGRhdGEuZnJvbS5jaCk7XG5cbiAgaWYgKHN1YnN0cmluZyA9PT0gZGF0YS50b2tlbi5zdHJpbmcpIHtcbiAgICB0ZXh0ID0gdGhpcy5yZXN1bHQudmFsdWUuc3Vic3RyKGRhdGEudG8uY2ggLSBkYXRhLmZyb20uY2gpO1xuICB9XG5cbiAgLy8gRG9uJ3QgY3JlYXRlIHRoZSBnaG9zdCBlbGVtZW50IGlmIHRoZXJlIGlzIG5vIHRleHQgdG8gZGlzcGxheS4gSXQgbWFrZXNcbiAgLy8gZm9yIGEgamFua3kgVUkgd2hlcmUga2V5cyBhcmUgYmxvY2tlZCB0aGFua3MgdG8gdGhlIGdob3N0IHNob3J0Y3V0cy5cbiAgaWYgKCF0ZXh0KSB7IHJldHVybjsgfVxuXG4gIHRoaXMuY20uYWRkS2V5TWFwKHRoaXMua2V5TWFwID0ge1xuICAgICdUYWInOiAgIGZ1bmN0aW9uICgpIHsgdGhhdC5hY2NlcHQoKTsgfSxcbiAgICAnUmlnaHQnOiBmdW5jdGlvbiAoKSB7IHRoYXQuYWNjZXB0KCk7IH1cbiAgfSk7XG5cbiAgLy8gQ3JlYXRlcyB0aGUgZ2hvc3QgZWxlbWVudCB0byBiZSBzdHlsZWQuXG4gIHZhciBnaG9zdEhpbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gIGdob3N0SGludC5jbGFzc05hbWUgPSAnQ29kZU1pcnJvci1oaW50LWdob3N0JztcbiAgZ2hvc3RIaW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpKTtcblxuICAvLyBBYnVzZSB0aGUgYm9va21hcmsgZmVhdHVyZSBvZiBDb2RlTWlycm9yIHRvIGFjaGlldmUgdGhlIGRlc2lyZWQgY29tcGxldGlvblxuICAvLyBlZmZlY3Qgd2l0aG91dCBtb2RpZnlpbmcgc291cmNlIGNvZGUuXG4gIHRoaXMuZ2hvc3QgPSB0aGlzLmNtLnNldEJvb2ttYXJrKGRhdGEudG8sIHtcbiAgICB3aWRnZXQ6ICAgICBnaG9zdEhpbnQsXG4gICAgaW5zZXJ0TGVmdDogdHJ1ZVxuICB9KTtcbn07XG5cbi8qKlxuICogRXh0ZW5kIHRoZSBnaG9zdCB3aXRoIGV2ZW50cy5cbiAqL1xuXy5leHRlbmQoR2hvc3QucHJvdG90eXBlLCBCYWNrYm9uZS5FdmVudHMpO1xuXG4vKipcbiAqIEFjY2VwdCB0aGUgZGlzcGxheSBnaG9zdCB0ZXh0LlxuICovXG5HaG9zdC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnRyaWdnZXIoJ2FjY2VwdCcsIHRoaXMucmVzdWx0KTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBnaG9zdCBzdWdnZXN0aW9uLlxuICovXG5HaG9zdC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5naG9zdCkge1xuICAgIHRoaXMuZ2hvc3QuY2xlYXIoKTtcbiAgfVxuXG4gIGlmICh0aGlzLmtleU1hcCkge1xuICAgIHRoaXMuY20ucmVtb3ZlS2V5TWFwKHRoaXMua2V5TWFwKTtcbiAgfVxuXG4gIGRlbGV0ZSB0aGlzLnRleHQ7XG4gIGRlbGV0ZSB0aGlzLmdob3N0O1xuICBkZWxldGUgdGhpcy53aWRnZXQuZ2hvc3Q7XG59O1xuIiwidmFyIF8gICAgICAgID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciBzdGF0ZSAgICA9IHJlcXVpcmUoJy4uLy4uL3N0YXRlL3N0YXRlJyk7XG52YXIgZm9ybWF0ICAgPSByZXF1aXJlKCcuL2Zvcm1hdC1kb2N1bWVudGF0aW9uJyk7XG5cbi8qKlxuICogQ3JlYXRlIGEgZmxvYXRpbmcgZG9jdW1lbnRhdGlvbiB3aWRnZXQgbmV4dCB0byB0aGUgY3VycmVudCBoaW50IHdpZGdldC5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSAge0hpbnRzfSAgICBoaW50c1xuICogQHBhcmFtICB7T2JqZWN0fSAgIGRlc2NyaXB0aW9uXG4gKiBAcmV0dXJuIHtIaW50RG9jc31cbiAqL1xudmFyIEhpbnREb2NzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaGludHMsIGRlc2NyaXB0aW9uKSB7XG4gIHRoaXMuaGludHMgPSBoaW50cztcblxuICB2YXIgcHJlZml4ICA9ICdDb2RlTWlycm9yLWhpbnQtZG9jdW1lbnRhdGlvbi0nO1xuICB2YXIgZm5OYW1lICA9IGhpbnRzLnJlc3VsdHNbaGludHMuY3VycmVudEhpbnRdLnZhbHVlO1xuICB2YXIgdG9vbHRpcCA9IHRoaXMudG9vbHRpcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gIC8vIE1hcCB0aGUgZG9jdW1lbnRhdGlvbiB0byB0aGUgdG9vbHRpcCByZW5kZXJpbmcuXG4gIHZhciBkb2NzID0gXy5vYmplY3QoXy5tYXAoZm9ybWF0KGRlc2NyaXB0aW9uLCBmbk5hbWUpLCBmdW5jdGlvbiAoZG9jcywgdHlwZSkge1xuICAgIGlmICh0eXBlID09PSAndXJsJykge1xuICAgICAgZG9jcyA9ICc8YSBocmVmPVwiJyArIGRvY3MgKyAnXCIgdGFyZ2V0PVwiX2JsYW5rXCI+UmVhZCBtb3JlPC9hPic7XG4gICAgfVxuXG4gICAgcmV0dXJuIFt0eXBlLCAnPGRpdiBjbGFzcz1cIicgKyBwcmVmaXggKyB0eXBlICsgJ1wiPicgKyBkb2NzICsgJzwvZGl2PiddO1xuICB9KSk7XG5cbiAgdG9vbHRpcC5jbGFzc05hbWUgPSAnQ29kZU1pcnJvci1oaW50LWRvY3VtZW50YXRpb24nO1xuICB0b29sdGlwLnNldEF0dHJpYnV0ZSgnZGF0YS1vdmVyZmxvdy1zY3JvbGwnLCAndHJ1ZScpO1xuXG4gIC8vIEFwcGVuZCBlYWNoIHBhcnQgb2YgdGhlIGRvY3VtZW50YXRpb24uXG4gIHRvb2x0aXAuaW5uZXJIVE1MICs9IGRvY3MudHlwZSB8fCAnJztcbiAgdG9vbHRpcC5pbm5lckhUTUwgKz0gZG9jcy5kb2MgIHx8ICcnO1xuICB0b29sdGlwLmlubmVySFRNTCArPSBkb2NzLnVybCAgfHwgJyc7XG5cbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0b29sdGlwKTtcblxuICB0aGlzLnJlcG9zaXRpb24oKTtcbiAgdGhpcy5saXN0ZW5UbyhoaW50cywgJ3JlcG9zaXRpb24nLCB0aGlzLnJlcG9zaXRpb24sIHRoaXMpO1xufTtcblxuLyoqXG4gKiBFeHRlbmQgdGhlIGRvY3VtZW50YXRpb24gdG9vbHRpcCB3aXRoIGV2ZW50cy5cbiAqL1xuXy5leHRlbmQoSGludERvY3MucHJvdG90eXBlLCBCYWNrYm9uZS5FdmVudHMpO1xuXG4vKipcbiAqIFJlcG9zaXRpb24gdGhlIGRvY3VtZW50YXRpb24gdG9vbHRpcCBiZXNpZGUgdGhlIGhpbnRzIG1lbnUuXG4gKi9cbkhpbnREb2NzLnByb3RvdHlwZS5yZXBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaGludHMgICAgID0gdGhpcy5oaW50cy5oaW50cztcbiAgdmFyIGJveCAgICAgICA9IGhpbnRzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgdG9vbHRpcCAgID0gdGhpcy50b29sdGlwO1xuICB2YXIgbWFyZ2luICAgID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUodG9vbHRpcCkubWFyZ2luVG9wLCAxMCk7XG4gIHZhciB3aW5XaWR0aCAgPSBzdGF0ZS5nZXQoJ3ZpZXdwb3J0V2lkdGgnKTtcbiAgdmFyIGRvY0hlaWdodCA9IHN0YXRlLmdldCgnZG9jdW1lbnRIZWlnaHQnKTtcblxuICB0b29sdGlwLnN0eWxlLnRvcCAgICA9IGhpbnRzLm9mZnNldFRvcCAtIG1hcmdpbiArICdweCc7XG4gIHRvb2x0aXAuc3R5bGUubGVmdCAgID0gYm94LnJpZ2h0ICsgJ3B4JztcbiAgdG9vbHRpcC5zdHlsZS5yaWdodCAgPSAnYXV0byc7XG4gIHRvb2x0aXAuc3R5bGUuYm90dG9tID0gJ2F1dG8nO1xuXG4gIGlmICh3aW5XaWR0aCAtIGJveC5yaWdodCA8IGJveC5sZWZ0KSB7XG4gICAgdG9vbHRpcC5zdHlsZS5sZWZ0ICA9ICdhdXRvJztcbiAgICB0b29sdGlwLnN0eWxlLnJpZ2h0ID0gd2luV2lkdGggLSBib3gubGVmdCArICdweCc7XG4gIH1cblxuICBpZiAoaGludHMuY2xhc3NOYW1lLmluZGV4T2YoJ0NvZGVNaXJyb3ItaGludHMtdG9wJykgPiAtMSkge1xuICAgIHZhciBib3R0b20gPSBkb2NIZWlnaHQgLSB3aW5kb3cuc2Nyb2xsWSAtIGJveC5ib3R0b20gLSBtYXJnaW47XG5cbiAgICB0b29sdGlwLnN0eWxlLnRvcCAgICA9ICdhdXRvJztcbiAgICB0b29sdGlwLnN0eWxlLmJvdHRvbSA9IGJvdHRvbSArICdweCc7XG4gIH1cblxuICB0aGlzLnRyaWdnZXIoJ3JlcG9zaXRpb24nKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBoaW50IGRvY3VtZW50YXRpb24gZnJvbSB0aGUgRE9NLlxuICovXG5IaW50RG9jcy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnN0b3BMaXN0ZW5pbmcoKTtcbiAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLnRvb2x0aXApO1xuICBkZWxldGUgdGhpcy50b29sdGlwO1xuICBkZWxldGUgdGhpcy5oaW50cy5kb2N1bWVudGF0aW9uO1xufTtcbiIsInZhciBfICAgICAgICAgID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lICAgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIHN0YXRlICAgICAgPSByZXF1aXJlKCcuLi8uLi9zdGF0ZS9zdGF0ZScpO1xudmFyIG1pZGRsZXdhcmUgPSByZXF1aXJlKCcuLi8uLi9zdGF0ZS9taWRkbGV3YXJlJyk7XG52YXIgSGludERvY3MgICA9IHJlcXVpcmUoJy4vaGludC1kb2N1bWVudGF0aW9uJyk7XG5cbi8qKlxuICogQ3JlYXRlIGEgaGludHMgcG9wb3Zlci5cbiAqXG4gKiBAcGFyYW0gIHtXaWRnZXR9IHdpZGdldFxuICogQHBhcmFtICB7QXJyYXl9ICByZXN1bHRzXG4gKiBAcmV0dXJuIHtIaW50c31cbiAqL1xudmFyIEhpbnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAod2lkZ2V0LCByZXN1bHRzKSB7XG4gIHZhciB0aGF0ICA9IHRoaXM7XG4gIHZhciBjbSAgICA9IHRoaXMuY20gICAgPSB3aWRnZXQuY29tcGxldGlvbi5jbTtcbiAgdmFyIGhpbnRzID0gdGhpcy5oaW50cyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XG4gIHZhciBkYXRhICA9IHRoaXMuZGF0YSAgPSB3aWRnZXQuZGF0YTtcbiAgdmFyIHRleHQgID0gY20uZ2V0UmFuZ2UoZGF0YS5mcm9tLCBkYXRhLnRvKTtcblxuICB0aGlzLndpZGdldCA9IHdpZGdldDtcblxuICBfLmVhY2godGhpcy5yZXN1bHRzID0gcmVzdWx0cywgZnVuY3Rpb24gKHJlc3VsdCwgaW5kZXgpIHtcbiAgICB2YXIgZWwgICAgID0gaGludHMuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKSk7XG4gICAgdmFyIGhpbnRFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICB2YXIgaW5kZXhPZjtcblxuICAgIGVsLmhpbnRJZCAgICAgICAgPSBpbmRleDtcbiAgICBlbC5jbGFzc05hbWUgICAgID0gJ0NvZGVNaXJyb3ItaGludCc7XG4gICAgaGludEVsLmNsYXNzTmFtZSA9ICdDb2RlTWlycm9yLWhpbnQtdGV4dCc7XG5cbiAgICBpZiAoKGluZGV4T2YgPSByZXN1bHQudGl0bGUuaW5kZXhPZih0ZXh0KSkgPiAtMSkge1xuICAgICAgdmFyIHByZWZpeCAgPSByZXN1bHQudGl0bGUuc3Vic3RyKDAsIGluZGV4T2YpO1xuICAgICAgdmFyIG1hdGNoICAgPSByZXN1bHQudGl0bGUuc3Vic3RyKGluZGV4T2YsIHRleHQubGVuZ3RoKTtcbiAgICAgIHZhciBzdWZmaXggID0gcmVzdWx0LnRpdGxlLnN1YnN0cihpbmRleE9mICsgdGV4dC5sZW5ndGgpO1xuICAgICAgdmFyIG1hdGNoRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG5cbiAgICAgIG1hdGNoRWwuY2xhc3NOYW1lICAgPSAnQ29kZU1pcnJvci1oaW50LW1hdGNoJztcbiAgICAgIG1hdGNoRWwudGV4dENvbnRlbnQgPSBtYXRjaDtcblxuICAgICAgaGludEVsLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHByZWZpeCkpO1xuICAgICAgaGludEVsLmFwcGVuZENoaWxkKG1hdGNoRWwpO1xuICAgICAgaGludEVsLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHN1ZmZpeCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoaW50RWwudGV4dENvbnRlbnQgPSByZXN1bHQudGl0bGU7XG4gICAgfVxuXG4gICAgZWwuYXBwZW5kQ2hpbGQoaGludEVsKTtcblxuICAgIGlmIChyZXN1bHQudHlwZSkge1xuICAgICAgdmFyIHR5cGVFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgIHR5cGVFbC5jbGFzc05hbWUgICA9ICdDb2RlTWlycm9yLWhpbnQtdHlwZSc7XG4gICAgICB0eXBlRWwudGV4dENvbnRlbnQgPSByZXN1bHQudHlwZTtcblxuICAgICAgZWwuYXBwZW5kQ2hpbGQodHlwZUVsKTtcbiAgICB9XG4gIH0pO1xuXG4gIGhpbnRzLmNsYXNzTmFtZSA9ICdDb2RlTWlycm9yLWhpbnRzJztcbiAgaGludHMuc2V0QXR0cmlidXRlKCdkYXRhLW92ZXJmbG93LXNjcm9sbCcsICd0cnVlJyk7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaGludHMpO1xuXG4gIGNtLmFkZEtleU1hcCh0aGlzLmtleU1hcCA9IHtcbiAgICAnVXAnOiAgICAgZnVuY3Rpb24gKCkgeyB0aGF0LnNlbGVjdCh0aGF0LmN1cnJlbnRIaW50IC0gMSk7IH0sXG4gICAgJ0Rvd24nOiAgIGZ1bmN0aW9uICgpIHsgdGhhdC5zZWxlY3QodGhhdC5jdXJyZW50SGludCArIDEpOyB9LFxuICAgICdIb21lJzogICBmdW5jdGlvbiAoKSB7IHRoYXQuc2VsZWN0KDApOyB9LFxuICAgICdFbmQnOiAgICBmdW5jdGlvbiAoKSB7IHRoYXQuc2VsZWN0KC0xKTsgfSxcbiAgICAnRW50ZXInOiAgZnVuY3Rpb24gKCkgeyB0aGF0LmFjY2VwdCh0aGF0LmN1cnJlbnRIaW50KTsgfSxcbiAgICAnUGFnZVVwJzogZnVuY3Rpb24gKCkge1xuICAgICAgdGhhdC5zZWxlY3QodGhhdC5jdXJyZW50SGludCAtIHRoYXQuc2NyZWVuQW1vdW50KCksIHRydWUpO1xuICAgIH0sXG4gICAgJ1BhZ2VEb3duJzogZnVuY3Rpb24gKCkge1xuICAgICAgdGhhdC5zZWxlY3QodGhhdC5jdXJyZW50SGludCArIHRoYXQuc2NyZWVuQW1vdW50KCksIHRydWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgQmFja2JvbmUuJChoaW50cylcbiAgICAub24oJ2NsaWNrJywgJ2xpJywgZnVuY3Rpb24gKGUsIHRhcmdldCkge1xuICAgICAgaWYgKGlzTmFOKHRhcmdldC5oaW50SWQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhhdC5hY2NlcHQodGFyZ2V0LmhpbnRJZCk7XG4gICAgfSlcbiAgICAub24oJ21vdXNlZG93bicsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgY20uZm9jdXMoKTsgfSwgMjApO1xuICAgIH0pO1xuXG4gIHRoaXMubGlzdGVuVG8oc3RhdGUsICdjaGFuZ2U6dmlld3BvcnRXaWR0aCcsICB0aGlzLnJlcG9zaXRpb24pO1xuICB0aGlzLmxpc3RlblRvKHN0YXRlLCAnY2hhbmdlOnZpZXdwb3J0SGVpZ2h0JywgdGhpcy5yZXBvc2l0aW9uKTtcbiAgdGhpcy5saXN0ZW5UbyhzdGF0ZSwgJ2NoYW5nZTpkb2N1bWVudFdpZHRoJywgIHRoaXMucmVwb3NpdGlvbik7XG4gIHRoaXMubGlzdGVuVG8oc3RhdGUsICdjaGFuZ2U6ZG9jdW1lbnRIZWlnaHQnLCB0aGlzLnJlcG9zaXRpb24pO1xuXG4gIHRoaXMuc2VsZWN0KDApO1xuICB0aGlzLnJlcG9zaXRpb24oKTtcbn07XG5cbi8qKlxuICogSW5oZXJpdCBldmVudHMgZnJvbSBCYWNrYm9uZS5cbiAqL1xuXy5leHRlbmQoSGludHMucHJvdG90eXBlLCBCYWNrYm9uZS5FdmVudHMpO1xuXG4vKipcbiAqIEFjY2VwdCBhIGhpbnQgcmVzdWx0LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICovXG5IaW50cy5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gIHRoaXMudHJpZ2dlcignYWNjZXB0JywgdGhpcy5yZXN1bHRzW2luZGV4XSk7XG59O1xuXG4vKipcbiAqIFNlbGVjdCBhIGhpbnQgb3B0aW9uLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSAgaW5kZXhcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gbm9XcmFwXG4gKi9cbkhpbnRzLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAoaW5kZXgsIG5vV3JhcCkge1xuICB2YXIgdGhhdCAgPSB0aGlzO1xuICB2YXIgZGF0YSAgPSB0aGlzLmRhdGE7XG4gIHZhciB0b3RhbCA9IHRoaXMuaGludHMuY2hpbGROb2Rlcy5sZW5ndGg7XG5cbiAgLy8gQ29udmVydCB0aGUgaW5kZXggdG8gdGhlIGNsb3Nlc3QgbnVtYmVyIHVzYWJsZSBudW1iZXIuXG4gIGluZGV4ID0gaW5kZXggJSB0b3RhbDtcblxuICAvLyBBdm9pZCB3cmFwcGluZyBhcm91bmQgdGhlIG1lbnUuXG4gIGlmIChub1dyYXAgJiYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRvdGFsKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFdoZW4gd2UgaGF2ZSBhIG5lZ2F0aXZlIG51bWJlciwgd2UgbmVlZCB0byBzdWJ0cmFjdCBpdCBmcm9tIHRoZSBib3R0b21cbiAgLy8gb2YgdGhlIGhpbnRzIG1lbnUuIFRoaXMgZ2l2ZXMgdXMgdGhlIGxvb3BpbmcgYXJvdW5kIGVmZmVjdC5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIGluZGV4ID0gdG90YWwgKyBpbmRleDtcbiAgfVxuXG4gIC8vIEF2b2lkIHJlc2V0dGluZyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGhpbnQuXG4gIGlmICh0aGlzLmN1cnJlbnRIaW50ID09PSBpbmRleCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFJlbW92ZSB0aGUgb2xkIGFjdGl2ZSBoaW50IGlmIHdlIGhhdmUgYSBzZWxlY3RlZCBoaW50IGlkLlxuICBpZiAoIWlzTmFOKHRoaXMuY3VycmVudEhpbnQpKSB7XG4gICAgdGhpcy5yZW1vdmVEb2N1bWVudGF0aW9uKCk7XG5cbiAgICB2YXIgb2xkID0gdGhpcy5oaW50cy5jaGlsZE5vZGVzW3RoaXMuY3VycmVudEhpbnRdO1xuICAgIG9sZC5jbGFzc05hbWUgPSBvbGQuY2xhc3NOYW1lLnJlcGxhY2UoJyBDb2RlTWlycm9yLWhpbnQtYWN0aXZlJywgJycpO1xuICB9XG5cbiAgLy8gQWRkIHRoZSBjbGFzcyB0byB0aGUgbmV3IGFjdGl2ZSBoaW50XG4gIHZhciBub2RlID0gdGhpcy5oaW50cy5jaGlsZE5vZGVzW3RoaXMuY3VycmVudEhpbnQgPSBpbmRleF07XG4gIG5vZGUuY2xhc3NOYW1lICs9ICcgQ29kZU1pcnJvci1oaW50LWFjdGl2ZSc7XG5cbiAgdmFyIHJlc3VsdCA9IHRoaXMucmVzdWx0c1t0aGlzLmN1cnJlbnRIaW50XTtcblxuICB0aGlzLnRyaWdnZXIoJ3NlbGVjdCcsIHJlc3VsdCk7XG5cbiAgaWYgKG5vZGUub2Zmc2V0VG9wIDwgdGhpcy5oaW50cy5zY3JvbGxUb3ApIHtcbiAgICB0aGlzLmhpbnRzLnNjcm9sbFRvcCA9IG5vZGUub2Zmc2V0VG9wIC0gMztcbiAgfSBlbHNlIHtcbiAgICB2YXIgdG90YWxPZmZzZXQgPSBub2RlLm9mZnNldFRvcCArIG5vZGUub2Zmc2V0SGVpZ2h0O1xuICAgIGlmICh0b3RhbE9mZnNldCA+IHRoaXMuaGludHMuc2Nyb2xsVG9wICsgdGhpcy5oaW50cy5jbGllbnRIZWlnaHQpIHtcbiAgICAgIHRoaXMuaGludHMuc2Nyb2xsVG9wID0gdG90YWxPZmZzZXQgLSB0aGlzLmhpbnRzLmNsaWVudEhlaWdodCArIDM7XG4gICAgfVxuICB9XG5cbiAgbWlkZGxld2FyZS50cmlnZ2VyKFxuICAgICdjb21wbGV0aW9uOmRlc2NyaWJlJyxcbiAgICBfLmV4dGVuZCh7fSwgdGhpcy53aWRnZXQuY29tcGxldGlvbi5vcHRpb25zLCB7XG4gICAgICBwYXJlbnQ6IGRhdGEuY29udGV4dCxcbiAgICAgIGNvbnRleHQ6IG51bGwsXG4gICAgICB0b2tlbjogXy5leHRlbmQoe30sIGRhdGEudG9rZW4sIHtcbiAgICAgICAgc3RyaW5nOiByZXN1bHQudmFsdWVcbiAgICAgIH0pXG4gICAgfSksXG4gICAgZnVuY3Rpb24gKGVyciwgZGVzY3JpYmUpIHtcbiAgICAgIC8vIEF2b2lkIGF0dGFjaGluZyBvYnNjdXJlIGRvY3VtZW50YXRpb24uXG4gICAgICBpZiAoZXJyIHx8ICFkZXNjcmliZSB8fCAoIWRlc2NyaWJlWychdHlwZSddICYmICFkZXNjcmliZVsnIWRvYyddKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoYXQuZG9jdW1lbnRhdGlvbiA9IG5ldyBIaW50RG9jcyh0aGF0LCBkZXNjcmliZSk7XG4gICAgfSxcbiAgICB0cnVlXG4gICk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgaGludCBwb3NpdGlvbmluZy5cbiAqL1xuSGludHMucHJvdG90eXBlLnJlcG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjbSAgICAgID0gdGhpcy5jbTtcbiAgdmFyIHBvcyAgICAgPSBjbS5jdXJzb3JDb29yZHModGhpcy5kYXRhLmZyb20sICd3aW5kb3cnKTtcbiAgdmFyIGhpbnRzICAgPSB0aGlzLmhpbnRzO1xuICB2YXIgbWFyZ2luICA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGhpbnRzKS5tYXJnaW5Ub3AsIDEwKTtcbiAgdmFyIHNjcm9sbFkgPSB3aW5kb3cuc2Nyb2xsWTtcbiAgdmFyIHNjcm9sbFggPSB3aW5kb3cuc2Nyb2xsWDtcblxuICBoaW50cy5jbGFzc05hbWUgICAgPSBoaW50cy5jbGFzc05hbWUucmVwbGFjZSgnIENvZGVNaXJyb3ItaGludHMtdG9wJywgJycpO1xuICBoaW50cy5zdHlsZS50b3AgICAgPSBzY3JvbGxZICsgcG9zLmJvdHRvbSAtIG1hcmdpbiArICdweCc7XG4gIGhpbnRzLnN0eWxlLmxlZnQgICA9IHNjcm9sbFggKyBwb3MubGVmdCAtIG1hcmdpbiArICdweCc7XG4gIGhpbnRzLnN0eWxlLnJpZ2h0ICA9ICdhdXRvJztcbiAgaGludHMuc3R5bGUuYm90dG9tID0gJ2F1dG8nO1xuICBoaW50cy5zdHlsZS53aWR0aCAgPSAnYXV0byc7XG4gIGhpbnRzLnN0eWxlLmhlaWdodCA9ICdhdXRvJztcblxuICB2YXIgYm94ICAgICAgID0gaGludHMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciB3aW5XaWR0aCAgPSBzdGF0ZS5nZXQoJ3ZpZXdwb3J0V2lkdGgnKTtcbiAgdmFyIHdpbkhlaWdodCA9IHN0YXRlLmdldCgndmlld3BvcnRIZWlnaHQnKTtcbiAgdmFyIGRvY1dpZHRoICA9IHN0YXRlLmdldCgnZG9jdW1lbnRXaWR0aCcpO1xuICB2YXIgZG9jSGVpZ2h0ID0gc3RhdGUuZ2V0KCdkb2N1bWVudEhlaWdodCcpO1xuICB2YXIgaGVpZ2h0ICAgID0gYm94LmJvdHRvbSAtIGJveC50b3A7XG5cbiAgaWYgKHBvcy50b3AgPiB3aW5IZWlnaHQgLSBwb3MuYm90dG9tIC0gbWFyZ2luKSB7XG4gICAgaGludHMuY2xhc3NOYW1lICs9ICcgQ29kZU1pcnJvci1oaW50cy10b3AnO1xuXG4gICAgaWYgKGhlaWdodCArIG1hcmdpbiA+IHBvcy50b3ApIHtcbiAgICAgIGhpbnRzLnN0eWxlLmhlaWdodCA9IHBvcy50b3AgLSBtYXJnaW4gKyAncHgnO1xuICAgIH1cblxuICAgIGhpbnRzLnN0eWxlLnRvcCAgICA9ICdhdXRvJztcbiAgICBoaW50cy5zdHlsZS5ib3R0b20gPSBkb2NIZWlnaHQgLSBwb3MudG9wIC0gc2Nyb2xsWSAtIG1hcmdpbiArICdweCc7XG4gIH0gZWxzZSBpZiAoaGVpZ2h0ICsgbWFyZ2luID4gd2luSGVpZ2h0IC0gcG9zLmJvdHRvbSkge1xuICAgIGhpbnRzLnN0eWxlLmhlaWdodCA9IHdpbkhlaWdodCAtIHBvcy5ib3R0b20gLSBtYXJnaW4gKyAncHgnO1xuICB9XG5cbiAgaWYgKGJveC5yaWdodCArIG1hcmdpbiA+IHdpbldpZHRoKSB7XG4gICAgaGludHMuc3R5bGUubGVmdCAgPSAnYXV0byc7XG4gICAgaGludHMuc3R5bGUucmlnaHQgPSBkb2NXaWR0aCAtIHNjcm9sbFggLSB3aW5XaWR0aCArICdweCc7XG4gIH1cblxuICB0aGlzLnRyaWdnZXIoJ3JlcG9zaXRpb24nKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBudW1iZXIgb2YgaGludHMgdGhlIGN1cnJlbnQgbWVudSBpcyBkaXNwbGF5aW5nLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuSGludHMucHJvdG90eXBlLnNjcmVlbkFtb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFtb3VudCA9IHRoaXMuaGludHMuY2xpZW50SGVpZ2h0IC8gdGhpcy5oaW50cy5maXJzdENoaWxkLm9mZnNldEhlaWdodDtcbiAgcmV0dXJuIE1hdGgubWF4KE1hdGguZmxvb3IoYW1vdW50KSwgMSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgZG9jdW1lbnRhdGlvbiB3aWRnZXQgZnJvbSB0aGUgRE9NLlxuICovXG5IaW50cy5wcm90b3R5cGUucmVtb3ZlRG9jdW1lbnRhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuZG9jdW1lbnRhdGlvbikge1xuICAgIHRoaXMuZG9jdW1lbnRhdGlvbi5yZW1vdmUoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGhpbnRzIG1lbnUuXG4gKi9cbkhpbnRzLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucmVtb3ZlRG9jdW1lbnRhdGlvbigpO1xuICB0aGlzLnN0b3BMaXN0ZW5pbmcoKTtcbiAgdGhpcy5jbS5yZW1vdmVLZXlNYXAodGhpcy5rZXlNYXApO1xuICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMuaGludHMpO1xuICBkZWxldGUgdGhpcy5oaW50cztcbiAgZGVsZXRlIHRoaXMua2V5TWFwO1xuICBkZWxldGUgdGhpcy53aWRnZXQuaGludHM7XG59O1xuIiwidmFyIFdpZGdldCAgICAgICAgID0gcmVxdWlyZSgnLi93aWRnZXQnKTtcbnZhciBBcmd1bWVudERvY3MgICA9IHJlcXVpcmUoJy4vYXJndW1lbnQtZG9jdW1lbnRhdGlvbicpO1xudmFyIGxvYWRBcmd1bWVudHMgID0gcmVxdWlyZSgnLi4vY29kZW1pcnJvci9zYW5kYm94LWFyZ3VtZW50cycpO1xudmFyIGxvYWRDb21wbGV0aW9uID0gcmVxdWlyZSgnLi4vY29kZW1pcnJvci9zYW5kYm94LWNvbXBsZXRpb24nKTtcblxudmFyIENMT1NFX1JFR0VYUCA9IC9bXiRfYS16QS1aMC05XS87XG5cbi8qKlxuICogQ3JlYXRlIGEgY29tcGxldGlvbiBpbnN0YW5jZSBmb3IgYSBDb2RlTWlycm9yIGVkaXRvci5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSAge0NvZGVNaXJyb3J9IGNtXG4gKiBAcGFyYW0gIHtPYmplY3R9ICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHtDb21wbGV0aW9ufVxuICovXG52YXIgQ29tcGxldGlvbiA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNtLCBvcHRpb25zKSB7XG4gIHZhciB0aGF0ICAgICAgICAgID0gdGhpcztcbiAgdmFyIGNsb3NlT25DdXJzb3IgPSB0cnVlO1xuICB2YXIgY2xvc2VPbkJsdXI7XG5cbiAgdGhpcy5jbSAgICAgID0gY207XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdGhpcy5jbS5zdGF0ZS5jb21wbGV0aW9uQWN0aXZlID0gdGhpcztcblxuICAvKipcbiAgICogQ2xvc2UgdGhlIGN1cnJlbnRseSBvcGVuIHdpZGdldCB3aGVuIHdlIGV4aXQgdGhlIGVkaXRvci5cbiAgICovXG4gIHRoaXMub25CbHVyID0gZnVuY3Rpb24gKCkge1xuICAgIGNsb3NlT25CbHVyID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdGhhdC5yZW1vdmVXaWRnZXQoKTtcbiAgICAgIHRoYXQucmVtb3ZlQXJndW1lbnREb2N1bWVudGF0aW9uKCk7XG4gICAgfSwgMjApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBPbiBlZGl0b3IgZm9jdXMsIHdlIGNsZWFyIHRoZSBjdXJyZW50IGJsdXIgdGltZW91dC5cbiAgICovXG4gIHRoaXMub25Gb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBUaW1lb3V0IGRvY3VtZW50YXRpb24gZGlzcGxheSB0byBhdm9pZCBpbmNvcnJlY3QgY3Vyc29yIHBvc2l0aW9uaW5nLlxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGF0LmRvY3VtZW50YXRpb24pIHtcbiAgICAgICAgdGhhdC5zaG93QXJndW1lbnREb2N1bWVudGF0aW9uKCk7XG4gICAgICB9XG4gICAgfSwgMTApO1xuXG4gICAgd2luZG93LmNsZWFyVGltZW91dChjbG9zZU9uQmx1cik7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoYW5nZSBldmVudHMgYXJlIHdoZXJlIGFsbCB0aGUgYWN0aW9uIGhhcHBlbnMuXG4gICAqIEBwYXJhbSAge0NvZGVNaXJyb3J9IGNtXG4gICAqIEBwYXJhbSAge09iamVjdH0gICAgIGV2ZW50XG4gICAqL1xuICB0aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKGNtLCBldmVudCkge1xuICAgIGNsb3NlT25DdXJzb3IgPSBmYWxzZTtcblxuICAgIC8vIE9ubHkgdXBkYXRlIHRoZSBkaXNwbGF5IHdoZW4gd2UgYXJlIGluc2VydGluZyBvciBkZWxldGluZyBjaGFyYWN0ZXJzXG4gICAgaWYgKCFldmVudC5vcmlnaW4gfHwgZXZlbnQub3JpZ2luLmNoYXJBdCgwKSAhPT0gJysnKSB7XG4gICAgICByZXR1cm4gdGhhdC5yZW1vdmVXaWRnZXQoKTtcbiAgICB9XG5cbiAgICB2YXIgcmVtb3ZlICA9IGV2ZW50Lm9yaWdpbiA9PT0gJytkZWxldGUnO1xuICAgIHZhciB0ZXh0ICAgID0gZXZlbnRbcmVtb3ZlID8gJ3JlbW92ZWQnIDogJ3RleHQnXS5qb2luKCdcXG4nKTtcbiAgICB2YXIgbGluZSAgICA9IGNtLmdldExpbmUoZXZlbnQuZnJvbS5saW5lKTtcbiAgICB2YXIgY3VyUG9zICA9IGV2ZW50LmZyb20uY2ggKyAocmVtb3ZlID8gLTEgOiAwKTtcbiAgICB2YXIgY3VyQ2hhciA9IGxpbmUuY2hhckF0KGN1clBvcyk7XG5cbiAgICAvLyBDaGVja3Mgd2hldGhlciBhbnkgb2YgdGhlIGNoYXJhY3RlcnMgYXJlIGEgY2xvc2UgY2hhcmFjdGVyLiBJZiB0aGV5IGFyZSxcbiAgICAvLyBjbG9zZSB0aGUgd2lkZ2V0IGFuZCByZW1vdmUgZnJvbSB0aGUgRE9NLiBIb3dldmVyLCB3ZSBzaG91bGQgYWxzbyBjbG9zZVxuICAgIC8vIHRoZSB3aWRnZXQgd2hlbiB0aGVyZSBpcyBubyBwcmV2aW91cyBjaGFyYWN0ZXIuXG4gICAgaWYgKCFjdXJDaGFyIHx8IENMT1NFX1JFR0VYUC50ZXN0KGN1ckNoYXIpIHx8IENMT1NFX1JFR0VYUC50ZXN0KHRleHQpKSB7XG4gICAgICB0aGF0LnJlbW92ZVdpZGdldCgpO1xuICAgIH0gZWxzZSBpZiAoY3VyUG9zID4gMCAmJiBDTE9TRV9SRUdFWFAudGVzdChsaW5lLmNoYXJBdChjdXJQb3MgLSAxKSkpIHtcbiAgICAgIHRoYXQucmVtb3ZlV2lkZ2V0KCk7XG4gICAgfVxuXG4gICAgdmFyIG5leHRDaGFyID0gbGluZS5jaGFyQXQoY3VyUG9zICsgMSk7XG5cbiAgICAvLyBJZiBjb21wbGV0aW9uIGlzIGN1cnJlbnRseSBhY3RpdmUsIHRyaWdnZXIgYSByZWZyZXNoIGV2ZW50IChmaWx0ZXIgdGhlXG4gICAgLy8gY3VycmVudCBzdWdnZXN0aW9ucyB1c2luZyB1cGRhdGVkIGNoYXJhY3RlciBwb3NpdGlvbiBpbmZvcm1hdGlvbikuXG4gICAgLy8gT3RoZXJ3aXNlLCB3ZSBuZWVkIHRvIHNob3cgYSBmcmVzaCB3aWRnZXQuXG4gICAgaWYgKHRoYXQud2lkZ2V0KSB7XG4gICAgICB0aGF0LndpZGdldC51cGRhdGUoKTtcbiAgICB9IGVsc2UgaWYgKCFuZXh0Q2hhciB8fCBDTE9TRV9SRUdFWFAudGVzdChuZXh0Q2hhcikpIHtcbiAgICAgIHRoYXQuc2hvd1dpZGdldCgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3Vyc29yIGFjdGl2aXR5IHNob3VsZCBjbG9zZSB0aGUgd2lkZ2V0LCBleGNlcHQgZm9yIHdoZW4gdGhlIGFjdGl2aXR5IGlzXG4gICAqIGFjdHVhbGx5IHRoZSByZXN1bHQgb2Ygc29tZSB0ZXh0IGlucHV0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtDb2RlTWlycm9yfSBjbVxuICAgKi9cbiAgdGhpcy5vbkN1cnNvckFjdGl2aXR5ID0gZnVuY3Rpb24gKGNtKSB7XG4gICAgLy8gQ3Vyc29yIGFjdGl2aXR5IGlzIGdldHRpbmcgdHJpZ2dlcmVkIHdoZW4gd2UgZG9uJ3QgaGF2ZSBmb2N1cy5cbiAgICBpZiAoIWNtLmhhc0ZvY3VzKCkgfHwgY20uZ2V0T3B0aW9uKCdyZWFkT25seScpKSB7IHJldHVybjsgfVxuXG4gICAgLy8gSWYgd2UgYWxyZWFkeSBoYXZlIGFjdGl2ZSBkb2N1bWVudGF0aW9uIHZpc2libGUsIHRyaWdnZXIgYW4gdXBkYXRlLiBUaGVcbiAgICAvLyBkb2N1bWVudGF0aW9uIG1heSBkZWNpZGUgaXQncyBubyBsb25nZXIgcmVsZXZhbnQgYW5kIHJlbW92ZSBpdHNlbGYuXG4gICAgaWYgKHRoYXQuZG9jdW1lbnRhdGlvbikge1xuICAgICAgdGhhdC5kb2N1bWVudGF0aW9uLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGlzIGN1cnJlbnRseSBubyBkb2N1bWVudGF0aW9uIHJlbmRlcmVkLCBhdHRlbXB0IHRvIGRpc3BsYXkgaXQuXG4gICAgaWYgKCF0aGF0LmRvY3VtZW50YXRpb24pIHtcbiAgICAgIHRoYXQuc2hvd0FyZ3VtZW50RG9jdW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIC8vIERlc3Ryb3kgdGhlIGNvbXBsZXRpb24gd2lkZ2V0IHdoZW4gd2UgbW92ZSB0aGUgY3Vyc29yIGF3YXkgZnJvbSB0aGVcbiAgICAvLyBjdXJyZW50IHR5cGluZyBwb3NpdGlvbi4gSXQncyBub3QgcmVsZXZhbnQgd2hlcmUgaXQgbW92ZWQgdG8gc2luY2UgaXQnbGxcbiAgICAvLyBiZSBpbnZhbGlkIGVpdGhlciB3YXkuXG4gICAgaWYgKGNsb3NlT25DdXJzb3IpIHtcbiAgICAgIHJldHVybiB0aGF0LnJlbW92ZVdpZGdldCgpO1xuICAgIH1cblxuICAgIGNsb3NlT25DdXJzb3IgPSB0cnVlO1xuICB9O1xuXG4gIHRoaXMuY20ub24oJ2JsdXInLCAgICAgICAgICAgdGhpcy5vbkJsdXIpO1xuICB0aGlzLmNtLm9uKCdmb2N1cycsICAgICAgICAgIHRoaXMub25Gb2N1cyk7XG4gIHRoaXMuY20ub24oJ2NoYW5nZScsICAgICAgICAgdGhpcy5vbkNoYW5nZSk7XG4gIHRoaXMuY20ub24oJ2N1cnNvckFjdGl2aXR5JywgdGhpcy5vbkN1cnNvckFjdGl2aXR5KTtcbn07XG5cbi8qKlxuICogU2hvdyBhIHNjcm9sbGFibGUgY29tcGxldGlvbiB3aWRnZXQuXG4gKi9cbkNvbXBsZXRpb24ucHJvdG90eXBlLnNob3dXaWRnZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0aGF0ID0gdGhpcztcblxuICBsb2FkQ29tcGxldGlvbih0aGlzLmNtLCB0aGlzLm9wdGlvbnMsIGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICB0aGF0LnJlbW92ZVdpZGdldCgpO1xuXG4gICAgcmV0dXJuIGRhdGEgJiYgKHRoYXQud2lkZ2V0ID0gbmV3IFdpZGdldCh0aGF0LCBkYXRhKSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBjdXJyZW50bHkgZGlzcGxheSB3aWRnZXQuXG4gKi9cbkNvbXBsZXRpb24ucHJvdG90eXBlLnJlbW92ZVdpZGdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMud2lkZ2V0ICYmIHRoaXMud2lkZ2V0LnJlbW92ZSgpO1xufTtcblxuLyoqXG4gKiBTaG93IGFuIG92ZXJsYXkgdG9vbHRpcCB3aXRoIHJlbGV2YW50IGRvY3VtZW50YXRpb24uXG4gKi9cbkNvbXBsZXRpb24ucHJvdG90eXBlLnNob3dBcmd1bWVudERvY3VtZW50YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0aGF0ID0gdGhpcztcblxuICBsb2FkQXJndW1lbnRzKHRoaXMuY20sIHRoaXMub3B0aW9ucywgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgIHRoYXQucmVtb3ZlQXJndW1lbnREb2N1bWVudGF0aW9uKCk7XG5cbiAgICByZXR1cm4gZGF0YSAmJiAodGhhdC5kb2N1bWVudGF0aW9uID0gbmV3IEFyZ3VtZW50RG9jcyh0aGF0LCBkYXRhKSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIG92ZXJsYXkgdG9vbGlwLlxuICovXG5Db21wbGV0aW9uLnByb3RvdHlwZS5yZW1vdmVBcmd1bWVudERvY3VtZW50YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmRvY3VtZW50YXRpb24gJiYgdGhpcy5kb2N1bWVudGF0aW9uLnJlbW92ZSgpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGNvbXBsZXRpb24gd2lkZ2V0LlxuICovXG5Db21wbGV0aW9uLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucmVtb3ZlV2lkZ2V0KCk7XG4gIHRoaXMucmVtb3ZlQXJndW1lbnREb2N1bWVudGF0aW9uKCk7XG4gIGRlbGV0ZSB0aGlzLmNtLnN0YXRlLmNvbXBsZXRpb25BY3RpdmU7XG4gIHRoaXMuY20ub2ZmKCdibHVyJywgICAgICAgICAgIHRoaXMub25CbHVyKTtcbiAgdGhpcy5jbS5vZmYoJ2ZvY3VzJywgICAgICAgICAgdGhpcy5vbkZvY3VzKTtcbiAgdGhpcy5jbS5vZmYoJ2NoYW5nZScsICAgICAgICAgdGhpcy5vbkNoYW5nZSk7XG4gIHRoaXMuY20ub2ZmKCdjdXJzb3JBY3Rpdml0eScsIHRoaXMub25DdXJzb3JBY3Rpdml0eSk7XG59O1xuIiwidmFyIF8gICAgICAgICAgICA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBhc3luYyAgICAgICAgPSByZXF1aXJlKCdhc3luYycpO1xudmFyIEJhY2tib25lICAgICA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgSGludHMgICAgICAgID0gcmVxdWlyZSgnLi9oaW50cycpO1xudmFyIEdob3N0ICAgICAgICA9IHJlcXVpcmUoJy4vZ2hvc3QnKTtcbnZhciBtaWRkbGV3YXJlICAgPSByZXF1aXJlKCcuLi8uLi9zdGF0ZS9taWRkbGV3YXJlJyk7XG52YXIgQ29kZU1pcnJvciAgID0gcmVxdWlyZSgnY29kZW1pcnJvcicpO1xudmFyIGNvcnJlY3RUb2tlbiA9IHJlcXVpcmUoJy4uL2NvZGVtaXJyb3IvY29ycmVjdC10b2tlbicpO1xuXG4vKipcbiAqIFJlbmRlciBhIGNvbXBsZXRpb24gd2lkZ2V0LlxuICpcbiAqIEBwYXJhbSAge0NvbXBsZXRpb259IGNvbXBsZXRpb25cbiAqIEBwYXJhbSAge09iamVjdH0gICAgIGRhdGFcbiAqIEByZXR1cm4ge1dpZGdldH1cbiAqL1xudmFyIFdpZGdldCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNvbXBsZXRpb24sIGRhdGEpIHtcbiAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gIHRoaXMuZGF0YSAgICAgICA9IGRhdGE7XG4gIHRoaXMuY29tcGxldGlvbiA9IGNvbXBsZXRpb247XG5cbiAgQ29kZU1pcnJvci5zaWduYWwoY29tcGxldGlvbi5jbSwgJ3N0YXJ0Q29tcGxldGlvbicsIGNvbXBsZXRpb24uY20pO1xuXG4gIGNvbXBsZXRpb24uY20uYWRkS2V5TWFwKHRoaXMua2V5TWFwID0ge1xuICAgICdFc2MnOiBmdW5jdGlvbiAoKSB7IHRoYXQucmVtb3ZlKCk7IH1cbiAgfSk7XG5cbiAgdGhpcy51cGRhdGUoKTtcbn07XG5cbi8qKlxuICogRXh0ZW5kIHRoZSB3aWRnZXQgcHJvdG90eXBlIHdpdGggZXZlbnRzLlxuICovXG5fLmV4dGVuZChXaWRnZXQucHJvdG90eXBlLCBCYWNrYm9uZS5FdmVudHMpO1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgY29tcGxldGlvbiBtZW51LlxuICovXG5XaWRnZXQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmRhdGEucmVzdWx0cykgeyByZXR1cm47IH1cblxuICB2YXIgdGhhdCAgICA9IHRoaXM7XG4gIHZhciBjbSAgICAgID0gdGhpcy5jb21wbGV0aW9uLmNtO1xuICB2YXIgcmVzdWx0cyA9IHRoaXMuZGF0YS5yZXN1bHRzO1xuXG4gIHRoaXMucmVtb3ZlSGludHMoKTtcbiAgdGhpcy5yZW1vdmVHaG9zdCgpO1xuXG4gIC8vIFVwZGF0ZSB0aGUgZGF0YSBwb3NpdGlvbnMuXG4gIHRoaXMuZGF0YS50byAgICA9IGNtLmdldEN1cnNvcigpO1xuICB0aGlzLmRhdGEudG9rZW4gPSBjb3JyZWN0VG9rZW4oY20sIHRoaXMuZGF0YS50byk7XG5cbiAgYXN5bmMuZmlsdGVyKHJlc3VsdHMsIF8uYmluZCh0aGlzLmZpbHRlciwgdGhpcyksIGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gICAgdGhhdC5yZW1vdmVIaW50cygpO1xuICAgIHRoYXQucmVtb3ZlR2hvc3QoKTtcbiAgICBDb2RlTWlycm9yLnNpZ25hbChjbSwgJ3JlZnJlc2hDb21wbGV0aW9uJywgY20sIHJlc3VsdHMpO1xuXG4gICAgLy8gQXZvaWQgcmVuZGVyaW5nIHRoZSBoaW50cyBtZW51IHdoZW4gdGhlcmUgaXMgbm90aGluZyB0byBkaXNwbGF5LlxuICAgIGlmIChyZXN1bHRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybiByZXN1bHRzLmxlbmd0aCA9PT0gMSA/IHRoYXQuc2VsZWN0KHJlc3VsdHNbMF0pIDogZmFsc2U7XG4gICAgfVxuXG4gICAgdGhhdC5oaW50cyA9IG5ldyBIaW50cyh0aGF0LCByZXN1bHRzKTtcblxuICAgIHRoYXQuc2VsZWN0KHJlc3VsdHNbMF0pO1xuICAgIHRoYXQubGlzdGVuVG8odGhhdC5oaW50cywgJ2FjY2VwdCcsIHRoYXQuYWNjZXB0LCB0aGF0KTtcbiAgICB0aGF0Lmxpc3RlblRvKHRoYXQuaGludHMsICdzZWxlY3QnLCB0aGF0LnNlbGVjdCwgdGhhdCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBBY2NlcHRzIGEgcmVzdWx0IGFzIHRoZSBjb21wbGV0aW9uIHJlc3VsdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcmVzdWx0XG4gKi9cbldpZGdldC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICB0aGlzLmNvbXBsZXRpb24uY20ucmVwbGFjZVJhbmdlKHJlc3VsdC52YWx1ZSwgdGhpcy5kYXRhLmZyb20sIHRoaXMuZGF0YS50byk7XG4gIHRoaXMucmVtb3ZlKCk7XG59O1xuXG4vKipcbiAqIFNlbGVjdCBhIHJlc3VsdCBmcm9tIHRoZSBoaW50cyBtZW51IHRvIGRpc3BsYXkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHJlc3VsdFxuICovXG5XaWRnZXQucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgdGhpcy5yZW1vdmVHaG9zdCgpO1xuICB0aGlzLmdob3N0ID0gbmV3IEdob3N0KHRoaXMsIHJlc3VsdCk7XG4gIHRoaXMubGlzdGVuVG8odGhpcy5naG9zdCwgJ2FjY2VwdCcsIHRoaXMuYWNjZXB0KTtcbn07XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciBhIHJlc3VsdCBzaG91bGQgYmUgZmlsdGVyZWQgZnJvbSB0aGUgZGlzcGxheS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gICByZXN1bHRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAqL1xuV2lkZ2V0LnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiAocmVzdWx0LCBkb25lKSB7XG4gIG1pZGRsZXdhcmUudHJpZ2dlcignY29tcGxldGlvbjpmaWx0ZXInLCB7XG4gICAgdG9rZW46ICAgdGhpcy5kYXRhLnRva2VuLFxuICAgIHJlc3VsdDogIHJlc3VsdCxcbiAgICBjb250ZXh0OiB0aGlzLmRhdGEuY29udGV4dFxuICB9LCBmdW5jdGlvbiAoZXJyLCBmaWx0ZXIpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRvbmUoZmlsdGVyKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgaGludHMgbWVudSBmcm9tIHRoZSBlZGl0b3IuXG4gKi9cbldpZGdldC5wcm90b3R5cGUucmVtb3ZlSGludHMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmhpbnRzKSB7XG4gICAgdGhpcy5zdG9wTGlzdGVuaW5nKHRoaXMuaGludHMpO1xuICAgIHRoaXMuaGludHMucmVtb3ZlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBjdXJyZW50IGdob3N0IGZyb20gdGhlIGRpc3BsYXkuXG4gKi9cbldpZGdldC5wcm90b3R5cGUucmVtb3ZlR2hvc3QgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmdob3N0KSB7XG4gICAgdGhpcy5zdG9wTGlzdGVuaW5nKHRoaXMuZ2hvc3QpO1xuICAgIHRoaXMuZ2hvc3QucmVtb3ZlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBjdXJyZW50IHdpZGdldCBmcm9tIHRoZSBlZGl0b3IuXG4gKi9cbldpZGdldC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJlbW92ZUhpbnRzKCk7XG4gIHRoaXMucmVtb3ZlR2hvc3QoKTtcblxuICB0aGlzLmNvbXBsZXRpb24uY20ucmVtb3ZlS2V5TWFwKHRoaXMua2V5TWFwKTtcblxuICBkZWxldGUgdGhpcy5rZXlNYXA7XG4gIGRlbGV0ZSB0aGlzLmNvbXBsZXRpb24ud2lkZ2V0O1xuICBDb2RlTWlycm9yLnNpZ25hbCh0aGlzLmNvbXBsZXRpb24uY20sICdlbmRDb21wbGV0aW9uJywgdGhpcy5jb21wbGV0aW9uLmNtKTtcbn07XG4iLCJ2YXIgXyAgICAgPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgaXNNYWMgPSByZXF1aXJlKCcuLi9saWIvYnJvd3Nlci9hYm91dCcpLm1hYztcblxuZXhwb3J0cy5jb2RlICAgPSBbXTtcbmV4cG9ydHMudGV4dCAgID0gW107XG5leHBvcnRzLmVkaXRvciA9IFtdO1xuXG4vLyBVc2VkIGZvciBtYXBwaW5nIGtleSBuYW1lcyB0byB0aGVpciBmYW5jaWVyIHZpc3VhbCBvdXRwdXQuXG52YXIga2V5TWFwID0ge1xuICAnVXAnOiAgICfihpEnLFxuICAnRG93bic6ICfihpMnXG59O1xuXG4vLyBBZGRpdGlvbmFsIGtleW1hcCBmb3IgTWFjIHVzZXJzLlxuaWYgKGlzTWFjKSB7XG4gIGtleU1hcC5BbHQgPSAnT3B0Jztcbn1cblxuLyoqXG4gKiBKb2luIGEgbnVtYmVyIG9mIGtleWJvYXJkIGFyZ3VtZW50cyB0b2dldGhlci5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IC4uLlxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG52YXIgam9pbiA9IGZ1bmN0aW9uIChrZXlzKSB7XG4gIHJldHVybiBrZXlzLmpvaW4oJy0nKTtcbn07XG5cbi8qKlxuICogSm9pbiBhIG51bWJlciBvZiBrZXlib2FyZCBhcmd1bWVudHMgdG9nZXRoZXIsIHBhc3NpbmcgaXQgdGhyb3VnaCBhIGtleVxuICogZm9ybWF0dGVyIGZvciBjbGVhbmVyIG91dHB1dC5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IC4uLlxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG52YXIgZm9ybWF0ID0gZnVuY3Rpb24gKGtleXMpIHtcbiAgcmV0dXJuIF8ubWFwKGtleXMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gKGtleSBpbiBrZXlNYXAgPyBrZXlNYXBba2V5XSA6IGtleSk7XG4gIH0pLmpvaW4oJy0nKTtcbn07XG5cbi8qKlxuICogQXVnbWVudHMgYSBiYXNpYyBvcHRpb25zIG1hcCB0byBiZSBmdWxseSBjb21wYXRpYmxlIHdpdGggdGhlIG91dHB1dC5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xudmFyIGRlZmluZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBkZWZpbmVkID0ge307XG5cbiAgZGVmaW5lZC5sYWJlbCAgICAgICA9IG9wdGlvbnMubGFiZWw7XG4gIGRlZmluZWQuc2hvcnRjdXQgICAgPSBvcHRpb25zLnNob3J0Y3V0O1xuICBkZWZpbmVkLmNvbW1hbmQgICAgID0gb3B0aW9ucy5jb21tYW5kO1xuICBkZWZpbmVkLmRlc2NyaXB0aW9uID0gb3B0aW9ucy5kZXNjcmlwdGlvbjtcblxuICBpZiAob3B0aW9ucy5rZXlNYXApIHtcbiAgICBkZWZpbmVkLmtleU1hcCA9ICBqb2luKG9wdGlvbnMua2V5TWFwKTtcbiAgICBkZWZpbmVkLmtleUNvZGUgPSBmb3JtYXQob3B0aW9ucy5rZXlNYXApO1xuICB9XG5cbiAgcmV0dXJuIGRlZmluZWQ7XG59O1xuXG4vKipcbiAqIERlZmluZSBhIHNob3J0Y3V0IGZvciBlZGl0b3IgY2VsbHMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xudmFyIGRlZmluZUVkaXRvclNob3J0Y3V0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgZXhwb3J0cy5lZGl0b3IucHVzaChkZWZpbmUob3B0aW9ucykpO1xufTtcblxuLyoqXG4gKiBEZWZpbmUgYSBzaG9ydGN1dCBmb3IgY29kZSBjZWxscy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG52YXIgZGVmaW5lQ29kZVNob3J0Y3V0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgZXhwb3J0cy5jb2RlLnB1c2goZGVmaW5lKG9wdGlvbnMpKTtcbn07XG5cbmRlZmluZUVkaXRvclNob3J0Y3V0KHtcbiAgbGFiZWw6ICdNb3ZlIFVwJyxcbiAgY29tbWFuZDogJ21vdmVVcCcsXG4gIGtleU1hcDogW2lzTWFjID8gJ0NtZCcgOiAnQ3RybCcsICdBbHQnLCAnVXAnXSxcbiAgZGVzY3JpcHRpb246ICdNb3ZlIGNlbGwgdXAgb25lIHBvc2l0aW9uJ1xufSk7XG5cbmRlZmluZUVkaXRvclNob3J0Y3V0KHtcbiAgbGFiZWw6ICdNb3ZlIERvd24nLFxuICBjb21tYW5kOiAnbW92ZURvd24nLFxuICBrZXlNYXA6IFtpc01hYyA/ICdDbWQnIDogJ0N0cmwnLCAnQWx0JywgJ0Rvd24nXSxcbiAgZGVzY3JpcHRpb246ICdNb3ZlIGNlbGwgZG93biBvbmUgcG9zaXRpb24nXG59KTtcblxuZGVmaW5lRWRpdG9yU2hvcnRjdXQoe1xuICBsYWJlbDogJ1N3aXRjaCBNb2RlJyxcbiAgY29tbWFuZDogJ3N3aXRjaCcsXG4gIGtleU1hcDogW2lzTWFjID8gJ0NtZCcgOiAnQ3RybCcsICdBbHQnLCAnQiddLFxuICBkZXNjcmlwdGlvbjogJ0NoYW5nZSBjZWxsIHR5cGUgKHRleHQvY29kZSknXG59KTtcblxuZGVmaW5lRWRpdG9yU2hvcnRjdXQoe1xuICBsYWJlbDogJ01ha2UgQ29weScsXG4gIGNvbW1hbmQ6ICdjbG9uZScsXG4gIGtleU1hcDogWydDdHJsJywgJ0FsdCcsICdDJ10sXG4gIGRlc2NyaXB0aW9uOiAnQ29weSBjZWxsJ1xufSk7XG5cbmRlZmluZUVkaXRvclNob3J0Y3V0KHtcbiAgbGFiZWw6ICdEZWxldGUnLFxuICBjb21tYW5kOiAnZGVsZXRlJyxcbiAga2V5TWFwOiBbaXNNYWMgPyAnQ21kJyA6ICdDdHJsJywgJ0JhY2tzcGFjZSddLFxuICBkZXNjcmlwdGlvbjogJ0RlbGV0ZSBjZWxsJ1xufSk7XG5cbmRlZmluZUVkaXRvclNob3J0Y3V0KHtcbiAgbGFiZWw6ICdOZXcgQ2VsbCcsXG4gIGNvbW1hbmQ6ICdhcHBlbmROZXcnLFxuICBrZXlNYXA6IFsnQ3RybCcsICdBbHQnLCAnTiddLFxuICBkZXNjcmlwdGlvbjogJ0FwcGVuZCBhIG5ldyBjb2RlIGNlbGwnXG59KTtcblxuZGVmaW5lRWRpdG9yU2hvcnRjdXQoe1xuICBsYWJlbDogJ05ldyBMaW5lIEJlbG93JyxcbiAgY29tbWFuZDogJ25ld0xpbmVCZWxvdycsXG4gIGtleU1hcDogW2lzTWFjID8gJ0NtZCcgOiAnQ3RybCcsICdFbnRlciddLFxuICBkZXNjcmlwdGlvbjogJ0luc2VydCBhIG5ldyBsaW5lIGJlbG93IHRoZSBjdXJyZW50IGxpbmUnXG59KTtcblxuZGVmaW5lRWRpdG9yU2hvcnRjdXQoe1xuICBsYWJlbDogJ1RvZ2dsZSBDb21tZW50JyxcbiAgY29tbWFuZDogJ3RvZ2dsZUNvbW1lbnQnLFxuICBrZXlNYXA6IFtpc01hYyA/ICdDbWQnIDogJ0N0cmwnLCAnLyddLFxuICBkZXNjcmlwdGlvbjogJ1RvZ2dsZSBjb21tZW50cyBvbiB0aGUgY3VycmVudCBsaW5lJ1xufSk7XG5cbmRlZmluZUVkaXRvclNob3J0Y3V0KHtcbiAgbGFiZWw6ICdCcm93c2UgVXAnLFxuICBjb21tYW5kOiAnYnJvd3NlVXAnLFxuICBrZXlNYXA6IFsnVXAnXSxcbiAgZGVzY3JpcHRpb246ICdOYXRpZ2F0ZSB1cCB0byB0aGUgcHJldmlvdXMgbGluZSdcbn0pO1xuXG5kZWZpbmVFZGl0b3JTaG9ydGN1dCh7XG4gIGxhYmVsOiAnQnJvd3NlIERvd24nLFxuICBjb21tYW5kOiAnYnJvd3NlRG93bicsXG4gIGtleU1hcDogWydEb3duJ10sXG4gIGRlc2NyaXB0aW9uOiAnTmF2aWdhdGUgZG93biB0byB0aGUgbmV4dCBsaW5lJ1xufSk7XG5cbmRlZmluZUNvZGVTaG9ydGN1dCh7XG4gIGxhYmVsOiAnRXhlY3V0ZScsXG4gIGNvbW1hbmQ6ICdleGVjdXRlJyxcbiAga2V5TWFwOiBbJ0VudGVyJ10sXG4gIGRlc2NyaXB0aW9uOiAnRXhlY3V0ZSB0aGUgY29kZSBjZWxsIGNvbnRlbnRzJ1xufSk7XG5cbmRlZmluZUNvZGVTaG9ydGN1dCh7XG4gIGxhYmVsOiAnTmV3IExpbmUnLFxuICBjb21tYW5kOiAnbmV3TGluZScsXG4gIGtleU1hcDogWydTaGlmdCcsICdFbnRlciddLFxuICBkZXNjcmlwdGlvbjogJ0luc2VydCBhIG5ldyBsaW5lJ1xufSk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgRE9NIGVsZW1lbnQgaW50byBhIEJhY2tib25lIGxpc3RlbmVyIGNvbXBhdGlibGUgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSAge0VsZW1lbnR9IGVsXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGVsKSB7XG4gIHZhciBsaXN0ZW5lcnMgPSBbXTtcblxuICB2YXIgbGlzdGVuZXIgPSB7XG4gICAgb246IGZ1bmN0aW9uIChldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgICAgIHZhciBjYiA9IF8uYmluZChmbiwgY29udGV4dCk7XG5cbiAgICAgIGlmIChlbCkge1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBjYiwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMucHVzaCh7XG4gICAgICAgIGV2ZW50OiAgIGV2ZW50LFxuICAgICAgICBmbjogICAgICBmbixcbiAgICAgICAgY2I6ICAgICAgY2IsXG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgb25jZTogZnVuY3Rpb24gKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICAgICAgdmFyIGNiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsaXN0ZW5lci5vZmYoZXZlbnQsIGNiLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gbGlzdGVuZXIub24oZXZlbnQsIGNiLCBjb250ZXh0KTtcbiAgICB9LFxuICAgIG9mZjogZnVuY3Rpb24gKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICAgICAgbGlzdGVuZXJzID0gXy5maWx0ZXIobGlzdGVuZXJzLCBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIGZucyAgICAgID0gKCFmbiAgICAgIHx8IGZuICAgICAgPT09IGxpc3RlbmVyLmZuKTtcbiAgICAgICAgdmFyIGV2ZW50cyAgID0gKCFldmVudCAgIHx8IGV2ZW50ICAgPT09IGxpc3RlbmVyLmV2ZW50KTtcbiAgICAgICAgdmFyIGNvbnRleHRzID0gKCFjb250ZXh0IHx8IGNvbnRleHQgPT09IGxpc3RlbmVyLmNvbnRleHQpO1xuXG4gICAgICAgIC8vIENoZWNrIGVhY2ggb2YgdGhlIGFyZ3VtZW50cyBtYXRjaCBhbmQgcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAgICAgICAgaWYgKGZucyAmJiBldmVudHMgJiYgY29udGV4dHMpIHtcbiAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIobGlzdGVuZXIuZXZlbnQsIGxpc3RlbmVyLmNiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBsaXN0ZW5lcjtcbn07XG4iLCJ2YXIgXyAgICAgICA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBET01CYXJzID0gcmVxdWlyZSgnZG9tYmFycy9ydW50aW1lJyk7XG5cbi8qKlxuICogUmVuZGVyIGEgQmFja2JvbmUgY29sbGVjdGlvbiBpbnNpZGUgYSBET01CYXJzIHZpZXdzLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gY29sbGVjdGlvblxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtOb2RlfVxuICovXG5ET01CYXJzLnJlZ2lzdGVySGVscGVyKCdjb2xsZWN0aW9uJywgZnVuY3Rpb24gKGNvbGxlY3Rpb24sIG9wdGlvbnMpIHtcbiAgdmFyIGVsZW1lbnQgICA9IERPTUJhcnMuVXRpbHMudHJhY2tOb2RlKCk7XG4gIHZhciB0ZW1wbGF0ZXMgPSB7fTtcblxuICBpZiAoIWNvbGxlY3Rpb24gfHwgYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXIgYSBtb2RlbCB1c2luZyB0aGUgaGVscGVyIGZ1bmN0aW9uLiBDYWNoZSB0aGUgcmVuZGVyZWQgY2hpbGQgbm9kZXNcbiAgICogYW5kIHJldHVybmVkIGZyYWdtZW50IGZvciByZW1vdmFsLlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG1vZGVsXG4gICAqIEByZXR1cm4ge05vZGV9XG4gICAqL1xuICB2YXIgcmVuZGVyID0gZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgdmFyIGNoaWxkID0gdGVtcGxhdGVzW21vZGVsLmNpZF0gPSBvcHRpb25zLmZuKG1vZGVsKTtcblxuICAgIC8vIFdyYXAgdGhlIG5vZGUgdmFsdWUgaW4gYSB0cmFja2luZyBub2RlLlxuICAgIHJldHVybiBjaGlsZC52YWx1ZSA9IERPTUJhcnMuVXRpbHMudHJhY2tOb2RlKGNoaWxkLnZhbHVlKTtcbiAgfTtcblxuICAvKipcbiAgICogQXBwZW5kIGEgbmV3IG1vZGVsIGRpcmVjdGx5IHRvIHRoZSBjdXJyZW50IGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbFxuICAgKi9cbiAgdmFyIGFkZCA9IGZ1bmN0aW9uIChtb2RlbCkge1xuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQocmVuZGVyKG1vZGVsKS5mcmFnbWVudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNvcnQgRE9NIG5vZGVzIGJ5IHJlbW92aW5nIGZyb20gdGhlIERPTSBhbmQgcmUtYWRkaW5nIGluIHNvcnRlZCBvcmRlci5cbiAgICovXG4gIHZhciBzb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgIF8uZWFjaCh0ZW1wbGF0ZXMsIGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xuICAgICAgcmV0dXJuIHRlbXBsYXRlLnZhbHVlLnJlbW92ZSgpO1xuICAgIH0pO1xuXG4gICAgY29sbGVjdGlvbi5lYWNoKGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZCh0ZW1wbGF0ZXNbbW9kZWwuY2lkXS52YWx1ZS5mcmFnbWVudCk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlc3Ryb3kgYSB0ZW1wbGF0ZSBmcm9tIGV4aXN0ZW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNpZFxuICAgKi9cbiAgdmFyIGRlc3Ryb3kgPSBmdW5jdGlvbiAoY2lkKSB7XG4gICAgdGVtcGxhdGVzW2NpZF0udW5zdWJzY3JpYmUoKTtcbiAgICB0ZW1wbGF0ZXNbY2lkXS52YWx1ZS5yZW1vdmUoKTtcbiAgICBkZWxldGUgdGVtcGxhdGVzW2NpZF07XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBub2RlcyBmcm9tIHRoZSBET00uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbFxuICAgKi9cbiAgdmFyIHJlbW92ZSA9IGZ1bmN0aW9uIChtb2RlbCkge1xuICAgIHJldHVybiBkZXN0cm95KG1vZGVsLmNpZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbGwgRE9NIG5vZGVzIGZyb20gdGhlIERPTS5cbiAgICpcbiAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXG4gICAqL1xuICB2YXIgcmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgXy5lYWNoKHRlbXBsYXRlcywgZnVuY3Rpb24gKHRlbXBsYXRlLCBrZXkpIHtcbiAgICAgIHJldHVybiBkZXN0cm95KGtleSk7XG4gICAgfSk7XG4gIH07XG5cbiAgb3B0aW9ucy51bnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgY29sbGVjdGlvbi5vZmYoJ2FkZCcsICAgIGFkZCk7XG4gICAgY29sbGVjdGlvbi5vZmYoJ3NvcnQnLCAgIHNvcnQpO1xuICAgIGNvbGxlY3Rpb24ub2ZmKCdyZXNldCcsICByZXNldCk7XG4gICAgY29sbGVjdGlvbi5vZmYoJ3JlbW92ZScsIHJlbW92ZSk7XG4gIH0pO1xuXG4gIGNvbGxlY3Rpb24ub24oJ2FkZCcsICAgIGFkZCk7XG4gIGNvbGxlY3Rpb24ub24oJ3NvcnQnLCAgIHNvcnQpO1xuICBjb2xsZWN0aW9uLm9uKCdyZXNldCcsICByZXNldCk7XG4gIGNvbGxlY3Rpb24ub24oJ3JlbW92ZScsIHJlbW92ZSk7XG5cbiAgY29sbGVjdGlvbi5lYWNoKGFkZCk7XG5cbiAgcmV0dXJuIGVsZW1lbnQuZnJhZ21lbnQ7XG59KTtcbiIsInZhciBET01CYXJzID0gcmVxdWlyZSgnZG9tYmFycy9ydW50aW1lJyk7XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciBhbGwgdmFsdWVzIGluIGFuIGFycmF5IGFyZSBlcXVhbC5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gICBhcnJheVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzRXF1YWwgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJheVswXSAhPT0gYXJyYXlbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXIgYXMgdGhlIGVxdWFsIGhlbHBlci5cbiAqXG4gKiBAcmV0dXJuIHsqfVxuICovXG5ET01CYXJzLnJlZ2lzdGVySGVscGVyKCdlcXVhbCcsIGZ1bmN0aW9uICgvKiAuLi5hcmdzLCBvcHRpb25zICovKSB7XG4gIHZhciBhcmdzICAgID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgdmFyIG9wdGlvbnMgPSBhcmdzLnBvcCgpO1xuXG4gIGlmICghb3B0aW9ucy5mbikge1xuICAgIHJldHVybiBpc0VxdWFsKGFyZ3MpO1xuICB9XG5cbiAgaWYgKGlzRXF1YWwoYXJncykpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5mbih0aGlzKS52YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvcHRpb25zLmludmVyc2UodGhpcykudmFsdWU7XG59KTtcblxuLyoqXG4gKiBSZWdpc3RlciB0aGUgb3Bwb3NpdGUgbm90IGVxdWFsIGZ1bmN0aW9uYWxpdHkuXG4gKlxuICogQHJldHVybiB7Kn1cbiAqL1xuRE9NQmFycy5yZWdpc3RlckhlbHBlcigndW5sZXNzRXF1YWwnLCBmdW5jdGlvbiAoLyogLi4uYXJncywgb3B0aW9ucyAqLykge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG5cbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDAsIC0xKS5jb25jYXQoe1xuICAgIGZuOiAgICAgIG9wdGlvbnMuaW52ZXJzZSxcbiAgICBpbnZlcnNlOiBvcHRpb25zLmZuLFxuICAgIGhhc2g6ICAgIG9wdGlvbnMuaGFzaFxuICB9KTtcblxuICByZXR1cm4gRE9NQmFycy5oZWxwZXJzLmVxdWFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xufSk7XG4iLCJ2YXIgXyAgICAgICAgID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIERPTUJhcnMgICA9IHJlcXVpcmUoJ2RvbWJhcnMvcnVudGltZScpO1xudmFyIGhic0lmICAgICA9IERPTUJhcnMuaGVscGVycy5pZjtcbnZhciBoYnNVbmxlc3MgPSBET01CYXJzLmhlbHBlcnMudW5sZXNzO1xuXG4vKipcbiAqIE92ZXJsb2FkIHRoZSBIYW5kbGViYXJzIGlmIGhlbHBlciB0byBhY2NlcHQgbXVsdGlwbGUgYXJndW1lbnRzLlxuICovXG5ET01CYXJzLnJlZ2lzdGVySGVscGVyKCdpZicsIGZ1bmN0aW9uICgvKiAuLi5hcmdzLCBvcHRpb25zICovKSB7XG4gIHZhciBhcmdzICAgID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwLCAtMSk7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgdmFyIGNoZWNrICAgPSBfLmV2ZXJ5KGFyZ3MsIGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH0pO1xuXG4gIHJldHVybiBoYnNJZi5jYWxsKHRoaXMsIGNoZWNrLCBvcHRpb25zKTtcbn0pO1xuXG4vKipcbiAqIE92ZXJsb2FkIHRoZSB1bmxlc3MgaGVscGVyIHRvIGFjY2VwdCBtdWx0aXBsZSBhcmd1bWVudHMuXG4gKi9cbkRPTUJhcnMucmVnaXN0ZXJIZWxwZXIoJ3VubGVzcycsIGZ1bmN0aW9uICgvKiAuLi5hcmdzLCBvcHRpb25zICovKSB7XG4gIHZhciBhcmdzICAgID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwLCAtMSk7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgdmFyIGNoZWNrICAgPSBfLmV2ZXJ5KGFyZ3MsIGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH0pO1xuXG4gIHJldHVybiBoYnNVbmxlc3MuY2FsbCh0aGlzLCBjaGVjaywgb3B0aW9ucyk7XG59KTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gYGFueWAgaGVscGVyIHRoYXQgd2lsbCBydW4gYW55IHRpbWUgYW55IG9mIHRoZSBhcmd1bWVudHMgYXJlIHRydWUuXG4gKi9cbkRPTUJhcnMucmVnaXN0ZXJIZWxwZXIoJ2FueScsIGZ1bmN0aW9uICgvKiAuLi5hcmdzLCBvcHRpb25zICovKSB7XG4gIHZhciBhcmdzICAgID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwLCAtMSk7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgdmFyIGNoZWNrICAgPSBfLmFueShhcmdzLCBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9KTtcblxuICByZXR1cm4gaGJzSWYuY2FsbCh0aGlzLCBjaGVjaywgb3B0aW9ucyk7XG59KTtcbiIsInZhciBET01CYXJzID0gcmVxdWlyZSgnZG9tYmFycy9ydW50aW1lJyk7XG5cbi8qKlxuICogUmVnaXN0ZXIgdG8gRE9NQmFycyBhcyB0aGUgdmlldyBoZWxwZXIuXG4gKlxuICogQHBhcmFtICB7QmFja2JvbmUuVmlld30gdmlld1xuICogQHJldHVybiB7Tm9kZX1cbiAqL1xuRE9NQmFycy5yZWdpc3RlckhlbHBlcigndmlldycsIGZ1bmN0aW9uICh2aWV3LCBvcHRpb25zKSB7XG4gIGlmICghdmlldykgeyByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpOyB9XG5cbiAgb3B0aW9ucy51bnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHZpZXcucmVtb3ZlKCk7XG4gIH0pO1xuXG4gIHJldHVybiBuZXcgRE9NQmFycy5TYWZlU3RyaW5nKHZpZXcucmVuZGVyKCkuZWwpO1xufSk7XG4iLCJ2YXIgRE9NQmFycyAgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2RvbWJhcnMvcnVudGltZScpO1xudmFyIF8gICAgICAgID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIGN1c3RvbSBnZXQgbWV0aG9kIGZvciBCYWNrYm9uZSB2aWV3cy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9ialxuICogQHBhcmFtICB7U3RyaW5nfSBwcm9wZXJ0eVxuICogQHJldHVybiB7Kn1cbiAqL1xuRE9NQmFycy5nZXQgPSBmdW5jdGlvbiAob2JqLCBwcm9wZXJ0eSkge1xuICBpZiAob2JqIGluc3RhbmNlb2YgQmFja2JvbmUuTW9kZWwpIHtcbiAgICByZXR1cm4gb2JqLmdldChwcm9wZXJ0eSk7XG4gIH1cblxuICByZXR1cm4gb2JqW3Byb3BlcnR5XTtcbn07XG5cbi8qKlxuICogUHJvdmlkZSBhIHN1YnNjcmlwdGlvbiBtZXRob2QgZm9yIGhhbmRsaW5nIEJhY2tib25lIG1vZGVscy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gICBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSAgIHByb3BlcnR5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5ET01CYXJzLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChvYmosIHByb3BlcnR5LCBmbikge1xuICBpZiAoIShvYmogaW5zdGFuY2VvZiBCYWNrYm9uZS5Nb2RlbCkpIHsgcmV0dXJuOyB9XG5cbiAgb2JqLm9uKCdjaGFuZ2U6JyArIHByb3BlcnR5LCBmbik7XG59O1xuXG4vKipcbiAqIFByb3ZpZGUgYW4gdW5zdWJzY3JpYmUgbWV0aG9kIGZvciByZW1vdmluZyBCYWNrYm9uZSBtb2RlbCBsaXN0ZW5lcnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9ICAgb2JqXG4gKiBAcGFyYW0ge1N0cmluZ30gICBwcm9wZXJ0eVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuRE9NQmFycy51bnN1YnNjcmliZSA9IGZ1bmN0aW9uIChvYmosIHByb3BlcnR5LCBmbikge1xuICBpZiAoIShvYmogaW5zdGFuY2VvZiBCYWNrYm9uZS5Nb2RlbCkpIHsgcmV0dXJuOyB9XG5cbiAgb2JqLm9mZignY2hhbmdlOicgKyBwcm9wZXJ0eSwgZm4pO1xufTtcblxuLyoqXG4gKiBBZGQgYSB1dGlsaXR5IGZ1bmN0aW9uIGZvciBtZXJnaW5nIG11bHRpcGxlIHRlbXBsYXRlcyB0b2dldGhlci5cbiAqXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuRE9NQmFycy5VdGlscy5tZXJnZVRlbXBsYXRlcyA9IGZ1bmN0aW9uICgvKiAuLi50ZW1wbGF0ZXMgKi8pIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgfVxuXG4gIHZhciBhcmdzID0gXy50b0FycmF5KGFyZ3VtZW50cyk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgLy8gU2V0IHRoZSB2YWx1ZSB0byBiZSBhIGRvY3VtZW50IGZyYWdtZW50LlxuICAgIHJlc3VsdC52YWx1ZSA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciBlYWNoIG9mIHRoZSB0ZW1wbGF0ZXMgYW5kIHRyYWNrIHRoZSByZXR1cm5lZCBjaGlsZC5cbiAgICB2YXIgdGVtcGxhdGVzID0gXy5tYXAoYXJncywgZnVuY3Rpb24gKHRlbXBsYXRlKSB7XG4gICAgICByZXR1cm4gdGVtcGxhdGUoY29udGV4dCwgb3B0aW9ucyk7XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYW4gdW5zdWJzY3JpYmUgbWV0aG9kIHRoZSB3aWxsIGRlbGVnYXRlIHRvIGVhY2ggb2YgdGhlIHRlbXBsYXRlcy5cbiAgICByZXN1bHQudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfLmVhY2godGVtcGxhdGVzLCBmdW5jdGlvbiAodGVtcGxhdGUpIHtcbiAgICAgICAgdGVtcGxhdGUudW5zdWJzY3JpYmUoKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBBcHBlbmQgYWxsIHRoZSB0ZW1wbGF0ZXMgdG8gdGhlIGRvY3VtZW50IGZyYWdtZW50LlxuICAgIF8uZWFjaCh0ZW1wbGF0ZXMsIGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xuICAgICAgaWYgKCF0ZW1wbGF0ZS52YWx1ZSkgeyByZXR1cm47IH1cblxuICAgICAgcmVzdWx0LnZhbHVlLmFwcGVuZENoaWxkKHRlbXBsYXRlLnZhbHVlKTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVyIERPTUJhcnMgaGVscGVycy5cbiAqL1xucmVxdWlyZSgnLi9oZWxwZXJzL2lmJyk7XG5yZXF1aXJlKCcuL2hlbHBlcnMvdmlldycpO1xucmVxdWlyZSgnLi9oZWxwZXJzL2VxdWFsJyk7XG5yZXF1aXJlKCcuL2hlbHBlcnMvY29sbGVjdGlvbicpO1xuIiwiLyoqXG4gKiBBY2NlcHRzIGFuIGFycmF5IG9mIHN0cmluZ3MgdGhhdCByZXByZXNlbnQgYSByZWZlcmVuY2UgdG8gYSB2YWx1ZSBvbiBhblxuICogb2JqZWN0LiBTdXBwb3J0cyBwYXNzaW5nIGFuIG9wdGlvbmFsIHNldHRlciwgdG8gc2V0IHRoZSB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9iamVjdFxuICogQHBhcmFtICB7QXJyYXl9ICBwYXRoXG4gKiBAcGFyYW0gIHsqfSAgICAgIFtzZXR0ZXJdXG4gKiBAcmV0dXJuIHsqfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIHBhdGgsIHNldHRlcikge1xuICB2YXIgaXNTZXR0ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcCA9IHBhdGhbaV07XG5cbiAgICBpZiAoaXNTZXR0ZXIpIHtcbiAgICAgIGlmIChpID09PSBwYXRoLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgb2JqZWN0W3Byb3BdID0gc2V0dGVyO1xuICAgICAgfSBlbHNlIGlmICghKHByb3AgaW4gb2JqZWN0KSkge1xuICAgICAgICBvYmplY3RbcHJvcF0gPSB7fTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBvYmplY3QgPSBvYmplY3RbcHJvcF07XG4gIH1cblxuICAvLyBSZXR1cm4gdGhlIHVwZGF0ZWQgb2JqZWN0IHJlZmVyZW5jZS5cbiAgcmV0dXJuIG9iamVjdDtcbn07XG4iLCJ2YXIgbWlkZGxld2FyZSA9IHJlcXVpcmUoJy4uL3N0YXRlL21pZGRsZXdhcmUnKTtcblxuLyoqXG4gKiBGdW5jdGlvbiBmb3IgZGlzcGxheWluZyBlcnJvcnMgdGhhdCBvY2N1ciB0byB0aGUgdXNlci5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGl0bGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoIWVycikgeyByZXR1cm47IH1cblxuICAgIHJldHVybiBtaWRkbGV3YXJlLnRyaWdnZXIoJ3VpOm5vdGlmeScsIHtcbiAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgIG1lc3NhZ2U6IGVyci5tZXNzYWdlXG4gICAgfSk7XG4gIH07XG59O1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xudmFyIF8gICAgICA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBFdmVudHMgPSByZXF1aXJlKCdiYWNrYm9uZScpLkV2ZW50cztcbnZhciBLYW1pbm8gPSByZXF1aXJlKCdrYW1pbm8nKTtcblxuLyoqXG4gKiBTZXQgdXAgZXZlbnQgbWVzc2FnaW5nIHdpdGggYW4gZXh0ZXJuYWwgZnJhbWUuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBwYXJlbnRGcmFtZVxuICogQHJldHVybiB7UG9zdE1lc3NhZ2V9XG4gKi9cbnZhciBQb3N0TWVzc2FnZSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHBhcmVudEZyYW1lKSB7XG4gIGlmICghKCdwb3N0TWVzc2FnZScgaW4gcGFyZW50RnJhbWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOZWVkIGFuIGluc3RhbmNlIG9mIGFub3RoZXIgZnJhbWUgdG8gY29tbXVuaWNhdGUuJyk7XG4gIH1cblxuICB0aGlzLnBhcmVudEZyYW1lID0gcGFyZW50RnJhbWU7XG5cbiAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBfLmJpbmQoZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5zb3VyY2UgIT09IHBhcmVudEZyYW1lKSB7IHJldHVybjsgfVxuXG4gICAgaWYgKHRoaXMub3JpZ2luICYmIHRoaXMub3JpZ2luICE9PSAnbnVsbCcpIHtcbiAgICAgIHRoaXMub3JpZ2luID0gZS5vcmlnaW47XG4gICAgfVxuXG4gICAgdGhpcy5fZnJhbWVFdmVudCA9IGU7XG4gICAgLy8gTWVzc2FnZXMgYmVpbmcgcGFzc2VkIGJ5IHRoZSBwYXJlbnQgd2luZG93IHNob3VsZCBhbHdheXMgYmUgaW4gYW4gYXJyYXlcbiAgICB0aGlzLnRyaWdnZXIuYXBwbHkodGhpcywgS2FtaW5vLnBhcnNlKGUuZGF0YSkpO1xuICB9LCB0aGlzKSwgZmFsc2UpO1xufTtcblxuXy5leHRlbmQoUG9zdE1lc3NhZ2UucHJvdG90eXBlLCBFdmVudHMpO1xuXG4vKipcbiAqIFRyaWdnZXIgYW4gZXZlbnQgb24gdGhlIHRocm91Z2ggdGhlIGZyYW1lLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gbmFtZVxuICogQHBhcmFtICB7Kn0gICAgICAuLi5cbiAqIEByZXR1cm4ge1Bvc3RNZXNzYWdlfVxuICovXG5Qb3N0TWVzc2FnZS5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uICgvKiBuYW1lICwgLi4uYXJncyAqLykge1xuICAvLyBJZiB3ZSBoYXZlIGEgZnJhbWUgZXZlbnQsIHVzZSBgdHJpZ2dlcmAgbm9ybWFsbHkgYW5kIHRyaWdnZXIgdGhlIGV2ZW50XG4gIC8vIGZvciBsb2NhbCBldmVudCBsaXN0ZW5lcnMuXG4gIGlmICh0aGlzLl9mcmFtZUV2ZW50KSB7XG4gICAgZGVsZXRlIHRoaXMuX2ZyYW1lRXZlbnQ7XG4gICAgcmV0dXJuIEV2ZW50cy50cmlnZ2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICB0aGlzLnBhcmVudEZyYW1lLnBvc3RNZXNzYWdlKFxuICAgIEthbWluby5zdHJpbmdpZnkoXy50b0FycmF5KGFyZ3VtZW50cykpLFxuICAgIHRoaXMub3JpZ2luIHx8ICcqJ1xuICApO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiIW5hbWVcIjogXCJicm93c2VyXCIsXG4gIFwibG9jYXRpb25cIjoge1xuICAgIFwiYXNzaWduXCI6IHtcbiAgICAgIFwiIXR5cGVcIjogXCJmbih1cmw6IHN0cmluZylcIixcbiAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL3dpbmRvdy5sb2NhdGlvblwiLFxuICAgICAgXCIhZG9jXCI6IFwiTG9hZCB0aGUgZG9jdW1lbnQgYXQgdGhlIHByb3ZpZGVkIFVSTC5cIlxuICAgIH0sXG4gICAgXCJyZXBsYWNlXCI6IHtcbiAgICAgIFwiIXR5cGVcIjogXCJmbih1cmw6IHN0cmluZylcIixcbiAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL3dpbmRvdy5sb2NhdGlvblwiLFxuICAgICAgXCIhZG9jXCI6IFwiUmVwbGFjZSB0aGUgY3VycmVudCBkb2N1bWVudCB3aXRoIHRoZSBvbmUgYXQgdGhlIHByb3ZpZGVkIFVSTC4gVGhlIGRpZmZlcmVuY2UgZnJvbSB0aGUgYXNzaWduKCkgbWV0aG9kIGlzIHRoYXQgYWZ0ZXIgdXNpbmcgcmVwbGFjZSgpIHRoZSBjdXJyZW50IHBhZ2Ugd2lsbCBub3QgYmUgc2F2ZWQgaW4gc2Vzc2lvbiBoaXN0b3J5LCBtZWFuaW5nIHRoZSB1c2VyIHdvbid0IGJlIGFibGUgdG8gdXNlIHRoZSBCYWNrIGJ1dHRvbiB0byBuYXZpZ2F0ZSB0byBpdC5cIlxuICAgIH0sXG4gICAgXCJyZWxvYWRcIjoge1xuICAgICAgXCIhdHlwZVwiOiBcImZuKClcIixcbiAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL3dpbmRvdy5sb2NhdGlvblwiLFxuICAgICAgXCIhZG9jXCI6IFwiUmVsb2FkIHRoZSBkb2N1bWVudCBmcm9tIHRoZSBjdXJyZW50IFVSTC4gZm9yY2VnZXQgaXMgYSBib29sZWFuLCB3aGljaCwgd2hlbiBpdCBpcyB0cnVlLCBjYXVzZXMgdGhlIHBhZ2UgdG8gYWx3YXlzIGJlIHJlbG9hZGVkIGZyb20gdGhlIHNlcnZlci4gSWYgaXQgaXMgZmFsc2Ugb3Igbm90IHNwZWNpZmllZCwgdGhlIGJyb3dzZXIgbWF5IHJlbG9hZCB0aGUgcGFnZSBmcm9tIGl0cyBjYWNoZS5cIlxuICAgIH0sXG4gICAgXCJvcmlnaW5cIjoge1xuICAgICAgXCIhdHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vd2luZG93LmxvY2F0aW9uXCIsXG4gICAgICBcIiFkb2NcIjogXCJUaGUgb3JpZ2luIG9mIHRoZSBVUkwuXCJcbiAgICB9LFxuICAgIFwiaGFzaFwiOiB7XG4gICAgICBcIiF0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS93aW5kb3cubG9jYXRpb25cIixcbiAgICAgIFwiIWRvY1wiOiBcIlRoZSBwYXJ0IG9mIHRoZSBVUkwgdGhhdCBmb2xsb3dzIHRoZSAjIHN5bWJvbCwgaW5jbHVkaW5nIHRoZSAjIHN5bWJvbC5cIlxuICAgIH0sXG4gICAgXCJzZWFyY2hcIjoge1xuICAgICAgXCIhdHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vd2luZG93LmxvY2F0aW9uXCIsXG4gICAgICBcIiFkb2NcIjogXCJUaGUgcGFydCBvZiB0aGUgVVJMIHRoYXQgZm9sbG93cyB0aGUgPyBzeW1ib2wsIGluY2x1ZGluZyB0aGUgPyBzeW1ib2wuXCJcbiAgICB9LFxuICAgIFwicGF0aG5hbWVcIjoge1xuICAgICAgXCIhdHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vd2luZG93LmxvY2F0aW9uXCIsXG4gICAgICBcIiFkb2NcIjogXCJUaGUgcGF0aCAocmVsYXRpdmUgdG8gdGhlIGhvc3QpLlwiXG4gICAgfSxcbiAgICBcInBvcnRcIjoge1xuICAgICAgXCIhdHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vd2luZG93LmxvY2F0aW9uXCIsXG4gICAgICBcIiFkb2NcIjogXCJUaGUgcG9ydCBudW1iZXIgb2YgdGhlIFVSTC5cIlxuICAgIH0sXG4gICAgXCJob3N0bmFtZVwiOiB7XG4gICAgICBcIiF0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS93aW5kb3cubG9jYXRpb25cIixcbiAgICAgIFwiIWRvY1wiOiBcIlRoZSBob3N0IG5hbWUgKHdpdGhvdXQgdGhlIHBvcnQgbnVtYmVyIG9yIHNxdWFyZSBicmFja2V0cykuXCJcbiAgICB9LFxuICAgIFwiaG9zdFwiOiB7XG4gICAgICBcIiF0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS93aW5kb3cubG9jYXRpb25cIixcbiAgICAgIFwiIWRvY1wiOiBcIlRoZSBob3N0IG5hbWUgYW5kIHBvcnQgbnVtYmVyLlwiXG4gICAgfSxcbiAgICBcInByb3RvY29sXCI6IHtcbiAgICAgIFwiIXR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL3dpbmRvdy5sb2NhdGlvblwiLFxuICAgICAgXCIhZG9jXCI6IFwiVGhlIHByb3RvY29sIG9mIHRoZSBVUkwuXCJcbiAgICB9LFxuICAgIFwiaHJlZlwiOiB7XG4gICAgICBcIiF0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS93aW5kb3cubG9jYXRpb25cIixcbiAgICAgIFwiIWRvY1wiOiBcIlRoZSBlbnRpcmUgVVJMLlwiXG4gICAgfSxcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS93aW5kb3cubG9jYXRpb25cIixcbiAgICBcIiFkb2NcIjogXCJSZXR1cm5zIGEgbG9jYXRpb24gb2JqZWN0IHdpdGggaW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnQgbG9jYXRpb24gb2YgdGhlIGRvY3VtZW50LiBBc3NpZ25pbmcgdG8gdGhlIGxvY2F0aW9uIHByb3BlcnR5IGNoYW5nZXMgdGhlIGN1cnJlbnQgcGFnZSB0byB0aGUgbmV3IGFkZHJlc3MuXCJcbiAgfSxcbiAgXCJOb2RlXCI6IHtcbiAgICBcIiF0eXBlXCI6IFwiZm4oKVwiLFxuICAgIFwicHJvdG90eXBlXCI6IHtcbiAgICAgIFwicGFyZW50RWxlbWVudFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCIrRWxlbWVudFwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9Ob2RlLnBhcmVudEVsZW1lbnRcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgRE9NIG5vZGUncyBwYXJlbnQgRWxlbWVudCwgb3IgbnVsbCBpZiB0aGUgbm9kZSBlaXRoZXIgaGFzIG5vIHBhcmVudCwgb3IgaXRzIHBhcmVudCBpc24ndCBhIERPTSBFbGVtZW50LlwiXG4gICAgICB9LFxuICAgICAgXCJ0ZXh0Q29udGVudFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vTm9kZS50ZXh0Q29udGVudFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJHZXRzIG9yIHNldHMgdGhlIHRleHQgY29udGVudCBvZiBhIG5vZGUgYW5kIGl0cyBkZXNjZW5kYW50cy5cIlxuICAgICAgfSxcbiAgICAgIFwiYmFzZVVSSVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vTm9kZS5iYXNlVVJJXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlRoZSBhYnNvbHV0ZSBiYXNlIFVSSSBvZiBhIG5vZGUgb3IgbnVsbCBpZiB1bmFibGUgdG8gb2J0YWluIGFuIGFic29sdXRlIFVSSS5cIlxuICAgICAgfSxcbiAgICAgIFwibG9jYWxOYW1lXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9Ob2RlLmxvY2FsTmFtZVwiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIHRoZSBsb2NhbCBwYXJ0IG9mIHRoZSBxdWFsaWZpZWQgbmFtZSBvZiB0aGlzIG5vZGUuXCJcbiAgICAgIH0sXG4gICAgICBcInByZWZpeFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vTm9kZS5wcmVmaXhcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgbmFtZXNwYWNlIHByZWZpeCBvZiB0aGUgc3BlY2lmaWVkIG5vZGUsIG9yIG51bGwgaWYgbm8gcHJlZml4IGlzIHNwZWNpZmllZC4gVGhpcyBwcm9wZXJ0eSBpcyByZWFkIG9ubHkuXCJcbiAgICAgIH0sXG4gICAgICBcIm5hbWVzcGFjZVVSSVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vTm9kZS5uYW1lc3BhY2VVUklcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiVGhlIG5hbWVzcGFjZSBVUkkgb2YgdGhlIG5vZGUsIG9yIG51bGwgaWYgdGhlIG5vZGUgaXMgbm90IGluIGEgbmFtZXNwYWNlIChyZWFkLW9ubHkpLiBXaGVuIHRoZSBub2RlIGlzIGEgZG9jdW1lbnQsIGl0IHJldHVybnMgdGhlIFhNTCBuYW1lc3BhY2UgZm9yIHRoZSBjdXJyZW50IGRvY3VtZW50LlwiXG4gICAgICB9LFxuICAgICAgXCJvd25lckRvY3VtZW50XCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIitEb2N1bWVudFwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9Ob2RlLm93bmVyRG9jdW1lbnRcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiVGhlIG93bmVyRG9jdW1lbnQgcHJvcGVydHkgcmV0dXJucyB0aGUgdG9wLWxldmVsIGRvY3VtZW50IG9iamVjdCBmb3IgdGhpcyBub2RlLlwiXG4gICAgICB9LFxuICAgICAgXCJhdHRyaWJ1dGVzXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIitOYW1lZE5vZGVNYXBcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vTm9kZS5hdHRyaWJ1dGVzXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIkEgY29sbGVjdGlvbiBvZiBhbGwgYXR0cmlidXRlIG5vZGVzIHJlZ2lzdGVyZWQgdG8gdGhlIHNwZWNpZmllZCBub2RlLiBJdCBpcyBhIE5hbWVkTm9kZU1hcCxub3QgYW4gQXJyYXksIHNvIGl0IGhhcyBubyBBcnJheSBtZXRob2RzIGFuZCB0aGUgQXR0ciBub2RlcycgaW5kZXhlcyBtYXkgZGlmZmVyIGFtb25nIGJyb3dzZXJzLlwiXG4gICAgICB9LFxuICAgICAgXCJuZXh0U2libGluZ1wiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCIrRWxlbWVudFwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9Ob2RlLm5leHRTaWJsaW5nXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIG5vZGUgaW1tZWRpYXRlbHkgZm9sbG93aW5nIHRoZSBzcGVjaWZpZWQgb25lIGluIGl0cyBwYXJlbnQncyBjaGlsZE5vZGVzIGxpc3QsIG9yIG51bGwgaWYgdGhlIHNwZWNpZmllZCBub2RlIGlzIHRoZSBsYXN0IG5vZGUgaW4gdGhhdCBsaXN0LlwiXG4gICAgICB9LFxuICAgICAgXCJwcmV2aW91c1NpYmxpbmdcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiK0VsZW1lbnRcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vTm9kZS5wcmV2aW91c1NpYmxpbmdcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgbm9kZSBpbW1lZGlhdGVseSBwcmVjZWRpbmcgdGhlIHNwZWNpZmllZCBvbmUgaW4gaXRzIHBhcmVudCdzIGNoaWxkTm9kZXMgbGlzdCwgbnVsbCBpZiB0aGUgc3BlY2lmaWVkIG5vZGUgaXMgdGhlIGZpcnN0IGluIHRoYXQgbGlzdC5cIlxuICAgICAgfSxcbiAgICAgIFwibGFzdENoaWxkXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIitFbGVtZW50XCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL05vZGUubGFzdENoaWxkXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIGxhc3QgY2hpbGQgb2YgYSBub2RlLlwiXG4gICAgICB9LFxuICAgICAgXCJmaXJzdENoaWxkXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIitFbGVtZW50XCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL05vZGUuZmlyc3RDaGlsZFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIHRoZSBub2RlJ3MgZmlyc3QgY2hpbGQgaW4gdGhlIHRyZWUsIG9yIG51bGwgaWYgdGhlIG5vZGUgaXMgY2hpbGRsZXNzLiBJZiB0aGUgbm9kZSBpcyBhIERvY3VtZW50LCBpdCByZXR1cm5zIHRoZSBmaXJzdCBub2RlIGluIHRoZSBsaXN0IG9mIGl0cyBkaXJlY3QgY2hpbGRyZW4uXCJcbiAgICAgIH0sXG4gICAgICBcImNoaWxkTm9kZXNcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiK05vZGVMaXN0XCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL05vZGUuY2hpbGROb2Rlc1wiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIGEgY29sbGVjdGlvbiBvZiBjaGlsZCBub2RlcyBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cIlxuICAgICAgfSxcbiAgICAgIFwicGFyZW50Tm9kZVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCIrRWxlbWVudFwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9Ob2RlLnBhcmVudE5vZGVcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgcGFyZW50IG9mIHRoZSBzcGVjaWZpZWQgbm9kZSBpbiB0aGUgRE9NIHRyZWUuXCJcbiAgICAgIH0sXG4gICAgICBcIm5vZGVUeXBlXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9Ob2RlLm5vZGVUeXBlXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgYW4gaW50ZWdlciBjb2RlIHJlcHJlc2VudGluZyB0aGUgdHlwZSBvZiB0aGUgbm9kZS5cIlxuICAgICAgfSxcbiAgICAgIFwibm9kZVZhbHVlXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9Ob2RlLm5vZGVWYWx1ZVwiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIG9yIHNldHMgdGhlIHZhbHVlIG9mIHRoZSBjdXJyZW50IG5vZGUuXCJcbiAgICAgIH0sXG4gICAgICBcIm5vZGVOYW1lXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9Ob2RlLm5vZGVOYW1lXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnQgbm9kZSBhcyBhIHN0cmluZy5cIlxuICAgICAgfSxcbiAgICAgIFwidGFnTmFtZVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vTm9kZS5ub2RlTmFtZVwiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IG5vZGUgYXMgYSBzdHJpbmcuXCJcbiAgICAgIH0sXG4gICAgICBcImluc2VydEJlZm9yZVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihuZXdFbHQ6ICtFbGVtZW50LCBiZWZvcmU6ICtFbGVtZW50KSAtPiArRWxlbWVudFwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9Ob2RlLmluc2VydEJlZm9yZVwiLFxuICAgICAgICBcIiFkb2NcIjogXCJJbnNlcnRzIHRoZSBzcGVjaWZpZWQgbm9kZSBiZWZvcmUgYSByZWZlcmVuY2UgZWxlbWVudCBhcyBhIGNoaWxkIG9mIHRoZSBjdXJyZW50IG5vZGUuXCJcbiAgICAgIH0sXG4gICAgICBcInJlcGxhY2VDaGlsZFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihuZXdFbHQ6ICtFbGVtZW50LCBvbGRFbHQ6ICtFbGVtZW50KSAtPiArRWxlbWVudFwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9Ob2RlLnJlcGxhY2VDaGlsZFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXBsYWNlcyBvbmUgY2hpbGQgbm9kZSBvZiB0aGUgc3BlY2lmaWVkIGVsZW1lbnQgd2l0aCBhbm90aGVyLlwiXG4gICAgICB9LFxuICAgICAgXCJyZW1vdmVDaGlsZFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihvbGRFbHQ6ICtFbGVtZW50KSAtPiArRWxlbWVudFwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9Ob2RlLnJlbW92ZUNoaWxkXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJlbW92ZXMgYSBjaGlsZCBub2RlIGZyb20gdGhlIERPTS4gUmV0dXJucyByZW1vdmVkIG5vZGUuXCJcbiAgICAgIH0sXG4gICAgICBcImFwcGVuZENoaWxkXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKG5ld0VsdDogK0VsZW1lbnQpIC0+ICtFbGVtZW50XCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL05vZGUuYXBwZW5kQ2hpbGRcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiQWRkcyBhIG5vZGUgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdCBvZiBjaGlsZHJlbiBvZiBhIHNwZWNpZmllZCBwYXJlbnQgbm9kZS4gSWYgdGhlIG5vZGUgYWxyZWFkeSBleGlzdHMgaXQgaXMgcmVtb3ZlZCBmcm9tIGN1cnJlbnQgcGFyZW50IG5vZGUsIHRoZW4gYWRkZWQgdG8gbmV3IHBhcmVudCBub2RlLlwiXG4gICAgICB9LFxuICAgICAgXCJoYXNDaGlsZE5vZGVzXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKCkgLT4gYm9vbFwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9Ob2RlLmhhc0NoaWxkTm9kZXNcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyBhIEJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBjdXJyZW50IE5vZGUgaGFzIGNoaWxkIG5vZGVzIG9yIG5vdC5cIlxuICAgICAgfSxcbiAgICAgIFwiY2xvbmVOb2RlXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKGRlZXA6IGJvb2wpIC0+ICtFbGVtZW50XCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL05vZGUuY2xvbmVOb2RlXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgYSBkdXBsaWNhdGUgb2YgdGhlIG5vZGUgb24gd2hpY2ggdGhpcyBtZXRob2Qgd2FzIGNhbGxlZC5cIlxuICAgICAgfSxcbiAgICAgIFwibm9ybWFsaXplXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKClcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vTm9kZS5ub3JtYWxpemVcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUHV0cyB0aGUgc3BlY2lmaWVkIG5vZGUgYW5kIGFsbCBvZiBpdHMgc3VidHJlZSBpbnRvIGEgXFxcIm5vcm1hbGl6ZWRcXFwiIGZvcm0uIEluIGEgbm9ybWFsaXplZCBzdWJ0cmVlLCBubyB0ZXh0IG5vZGVzIGluIHRoZSBzdWJ0cmVlIGFyZSBlbXB0eSBhbmQgdGhlcmUgYXJlIG5vIGFkamFjZW50IHRleHQgbm9kZXMuXCJcbiAgICAgIH0sXG4gICAgICBcImlzU3VwcG9ydGVkXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKGZlYXR1cmVzOiBzdHJpbmcsIHZlcnNpb246IG51bWJlcikgLT4gYm9vbFwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9Ob2RlLmlzU3VwcG9ydGVkXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlRlc3RzIHdoZXRoZXIgdGhlIERPTSBpbXBsZW1lbnRhdGlvbiBpbXBsZW1lbnRzIGEgc3BlY2lmaWMgZmVhdHVyZSBhbmQgdGhhdCBmZWF0dXJlIGlzIHN1cHBvcnRlZCBieSB0aGlzIG5vZGUuXCJcbiAgICAgIH0sXG4gICAgICBcImhhc0F0dHJpYnV0ZXNcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oKSAtPiBib29sXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL05vZGUuaGFzQXR0cmlidXRlc1wiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIGEgYm9vbGVhbiB2YWx1ZSBvZiB0cnVlIG9yIGZhbHNlLCBpbmRpY2F0aW5nIGlmIHRoZSBjdXJyZW50IGVsZW1lbnQgaGFzIGFueSBhdHRyaWJ1dGVzIG9yIG5vdC5cIlxuICAgICAgfSxcbiAgICAgIFwibG9va3VwUHJlZml4XCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKHVyaTogc3RyaW5nKSAtPiBzdHJpbmdcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vTm9kZS5sb29rdXBQcmVmaXhcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgcHJlZml4IGZvciBhIGdpdmVuIG5hbWVzcGFjZVVSSSBpZiBwcmVzZW50LCBhbmQgbnVsbCBpZiBub3QuIFdoZW4gbXVsdGlwbGUgcHJlZml4ZXMgYXJlIHBvc3NpYmxlLCB0aGUgcmVzdWx0IGlzIGltcGxlbWVudGF0aW9uLWRlcGVuZGVudC5cIlxuICAgICAgfSxcbiAgICAgIFwiaXNEZWZhdWx0TmFtZXNwYWNlXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKHVyaTogc3RyaW5nKSAtPiBib29sXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL05vZGUuaXNEZWZhdWx0TmFtZXNwYWNlXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIkFjY2VwdHMgYSBuYW1lc3BhY2UgVVJJIGFzIGFuIGFyZ3VtZW50IGFuZCByZXR1cm5zIHRydWUgaWYgdGhlIG5hbWVzcGFjZSBpcyB0aGUgZGVmYXVsdCBuYW1lc3BhY2Ugb24gdGhlIGdpdmVuIG5vZGUgb3IgZmFsc2UgaWYgbm90LlwiXG4gICAgICB9LFxuICAgICAgXCJsb29rdXBOYW1lc3BhY2VVUklcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4odXJpOiBzdHJpbmcpIC0+IHN0cmluZ1wiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9Ob2RlLmxvb2t1cE5hbWVzcGFjZVVSSVwiLFxuICAgICAgICBcIiFkb2NcIjogXCJUYWtlcyBhIHByZWZpeCBhbmQgcmV0dXJucyB0aGUgbmFtZXNwYWNlVVJJIGFzc29jaWF0ZWQgd2l0aCBpdCBvbiB0aGUgZ2l2ZW4gbm9kZSBpZiBmb3VuZCAoYW5kIG51bGwgaWYgbm90KS4gU3VwcGx5aW5nIG51bGwgZm9yIHRoZSBwcmVmaXggd2lsbCByZXR1cm4gdGhlIGRlZmF1bHQgbmFtZXNwYWNlLlwiXG4gICAgICB9LFxuICAgICAgXCJhZGRFdmVudExpc3RlbmVyXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKHR5cGU6IHN0cmluZywgbGlzdGVuZXI6IGZuKGU6ICtFdmVudCksIGNhcHR1cmU6IGJvb2wpXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL0V2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXJcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmVnaXN0ZXJzIGEgc2luZ2xlIGV2ZW50IGxpc3RlbmVyIG9uIGEgc2luZ2xlIHRhcmdldC4gVGhlIGV2ZW50IHRhcmdldCBtYXkgYmUgYSBzaW5nbGUgZWxlbWVudCBpbiBhIGRvY3VtZW50LCB0aGUgZG9jdW1lbnQgaXRzZWxmLCBhIHdpbmRvdywgb3IgYW4gWE1MSHR0cFJlcXVlc3QuXCJcbiAgICAgIH0sXG4gICAgICBcInJlbW92ZUV2ZW50TGlzdGVuZXJcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4odHlwZTogc3RyaW5nLCBsaXN0ZW5lcjogZm4oKSwgY2FwdHVyZTogYm9vbClcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vRXZlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lclwiLFxuICAgICAgICBcIiFkb2NcIjogXCJBbGxvd3MgdGhlIHJlbW92YWwgb2YgZXZlbnQgbGlzdGVuZXJzIGZyb20gdGhlIGV2ZW50IHRhcmdldC5cIlxuICAgICAgfSxcbiAgICAgIFwiaXNTYW1lTm9kZVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihvdGhlcjogK05vZGUpIC0+IGJvb2xcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vTm9kZS5pc1NhbWVOb2RlXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlRlc3RzIHdoZXRoZXIgdHdvIG5vZGVzIGFyZSB0aGUgc2FtZSwgdGhhdCBpcyB0aGV5IHJlZmVyZW5jZSB0aGUgc2FtZSBvYmplY3QuXCJcbiAgICAgIH0sXG4gICAgICBcImlzRXF1YWxOb2RlXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKG90aGVyOiArTm9kZSkgLT4gYm9vbFwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9Ob2RlLmlzRXF1YWxOb2RlXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlRlc3RzIHdoZXRoZXIgdHdvIG5vZGVzIGFyZSBlcXVhbC5cIlxuICAgICAgfSxcbiAgICAgIFwiY29tcGFyZURvY3VtZW50UG9zaXRpb25cIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4ob3RoZXI6ICtOb2RlKSAtPiBudW1iZXJcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvblwiLFxuICAgICAgICBcIiFkb2NcIjogXCJDb21wYXJlcyB0aGUgcG9zaXRpb24gb2YgdGhlIGN1cnJlbnQgbm9kZSBhZ2FpbnN0IGFub3RoZXIgbm9kZSBpbiBhbnkgb3RoZXIgZG9jdW1lbnQuXCJcbiAgICAgIH0sXG4gICAgICBcImNvbnRhaW5zXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKG90aGVyOiArTm9kZSkgLT4gYm9vbFwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9Ob2RlLmNvbnRhaW5zXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIkluZGljYXRlcyB3aGV0aGVyIGEgbm9kZSBpcyBhIGRlc2NlbmRlbnQgb2YgYSBnaXZlbiBub2RlLlwiXG4gICAgICB9LFxuICAgICAgXCJkaXNwYXRjaEV2ZW50XCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKGV2ZW50OiArRXZlbnQpIC0+IGJvb2xcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vRXZlbnRUYXJnZXQuZGlzcGF0Y2hFdmVudFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJEaXNwYXRjaGVzIGFuIGV2ZW50IGludG8gdGhlIGV2ZW50IHN5c3RlbS4gVGhlIGV2ZW50IGlzIHN1YmplY3QgdG8gdGhlIHNhbWUgY2FwdHVyaW5nIGFuZCBidWJibGluZyBiZWhhdmlvciBhcyBkaXJlY3RseSBkaXNwYXRjaGVkIGV2ZW50cy5cIlxuICAgICAgfSxcbiAgICAgIFwiRUxFTUVOVF9OT0RFXCI6IFwibnVtYmVyXCIsXG4gICAgICBcIkFUVFJJQlVURV9OT0RFXCI6IFwibnVtYmVyXCIsXG4gICAgICBcIlRFWFRfTk9ERVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJDREFUQV9TRUNUSU9OX05PREVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiRU5USVRZX1JFRkVSRU5DRV9OT0RFXCI6IFwibnVtYmVyXCIsXG4gICAgICBcIkVOVElUWV9OT0RFXCI6IFwibnVtYmVyXCIsXG4gICAgICBcIlBST0NFU1NJTkdfSU5TVFJVQ1RJT05fTk9ERVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJDT01NRU5UX05PREVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiRE9DVU1FTlRfTk9ERVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJET0NVTUVOVF9UWVBFX05PREVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiRE9DVU1FTlRfRlJBR01FTlRfTk9ERVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJOT1RBVElPTl9OT0RFXCI6IFwibnVtYmVyXCIsXG4gICAgICBcIkRPQ1VNRU5UX1BPU0lUSU9OX0RJU0NPTk5FQ1RFRFwiOiBcIm51bWJlclwiLFxuICAgICAgXCJET0NVTUVOVF9QT1NJVElPTl9QUkVDRURJTkdcIjogXCJudW1iZXJcIixcbiAgICAgIFwiRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HXCI6IFwibnVtYmVyXCIsXG4gICAgICBcIkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5TXCI6IFwibnVtYmVyXCIsXG4gICAgICBcIkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5FRF9CWVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJET0NVTUVOVF9QT1NJVElPTl9JTVBMRU1FTlRBVElPTl9TUEVDSUZJQ1wiOiBcIm51bWJlclwiXG4gICAgfSxcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9Ob2RlXCIsXG4gICAgXCIhZG9jXCI6IFwiQSBOb2RlIGlzIGFuIGludGVyZmFjZSBmcm9tIHdoaWNoIGEgbnVtYmVyIG9mIERPTSB0eXBlcyBpbmhlcml0LCBhbmQgYWxsb3dzIHRoZXNlIHZhcmlvdXMgdHlwZXMgdG8gYmUgdHJlYXRlZCAob3IgdGVzdGVkKSBzaW1pbGFybHkuXCJcbiAgfSxcbiAgXCJFbGVtZW50XCI6IHtcbiAgICBcIiF0eXBlXCI6IFwiZm4oKVwiLFxuICAgIFwicHJvdG90eXBlXCI6IHtcbiAgICAgIFwiIXByb3RvXCI6IFwiTm9kZS5wcm90b3R5cGVcIixcbiAgICAgIFwiZ2V0QXR0cmlidXRlXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKG5hbWU6IHN0cmluZykgLT4gc3RyaW5nXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2VsZW1lbnQuZ2V0QXR0cmlidXRlXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBuYW1lZCBhdHRyaWJ1dGUgb24gdGhlIHNwZWNpZmllZCBlbGVtZW50LiBJZiB0aGUgbmFtZWQgYXR0cmlidXRlIGRvZXMgbm90IGV4aXN0LCB0aGUgdmFsdWUgcmV0dXJuZWQgd2lsbCBlaXRoZXIgYmUgbnVsbCBvciBcXFwiXFxcIiAodGhlIGVtcHR5IHN0cmluZykuXCJcbiAgICAgIH0sXG4gICAgICBcInNldEF0dHJpYnV0ZVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihuYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2VsZW1lbnQuc2V0QXR0cmlidXRlXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIkFkZHMgYSBuZXcgYXR0cmlidXRlIG9yIGNoYW5nZXMgdGhlIHZhbHVlIG9mIGFuIGV4aXN0aW5nIGF0dHJpYnV0ZSBvbiB0aGUgc3BlY2lmaWVkIGVsZW1lbnQuXCJcbiAgICAgIH0sXG4gICAgICBcInJlbW92ZUF0dHJpYnV0ZVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihuYW1lOiBzdHJpbmcpXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJlbW92ZXMgYW4gYXR0cmlidXRlIGZyb20gdGhlIHNwZWNpZmllZCBlbGVtZW50LlwiXG4gICAgICB9LFxuICAgICAgXCJnZXRBdHRyaWJ1dGVOb2RlXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKG5hbWU6IHN0cmluZykgLT4gK0F0dHJcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZWxlbWVudC5nZXRBdHRyaWJ1dGVOb2RlXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIHNwZWNpZmllZCBhdHRyaWJ1dGUgb2YgdGhlIHNwZWNpZmllZCBlbGVtZW50LCBhcyBhbiBBdHRyIG5vZGUuXCJcbiAgICAgIH0sXG4gICAgICBcImdldEVsZW1lbnRzQnlUYWdOYW1lXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKHRhZ05hbWU6IHN0cmluZykgLT4gK05vZGVMaXN0XCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2VsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWVcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyBhIGxpc3Qgb2YgZWxlbWVudHMgd2l0aCB0aGUgZ2l2ZW4gdGFnIG5hbWUuIFRoZSBzdWJ0cmVlIHVuZGVybmVhdGggdGhlIHNwZWNpZmllZCBlbGVtZW50IGlzIHNlYXJjaGVkLCBleGNsdWRpbmcgdGhlIGVsZW1lbnQgaXRzZWxmLiBUaGUgcmV0dXJuZWQgbGlzdCBpcyBsaXZlLCBtZWFuaW5nIHRoYXQgaXQgdXBkYXRlcyBpdHNlbGYgd2l0aCB0aGUgRE9NIHRyZWUgYXV0b21hdGljYWxseS4gQ29uc2VxdWVudGx5LCB0aGVyZSBpcyBubyBuZWVkIHRvIGNhbGwgc2V2ZXJhbCB0aW1lcyBlbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lIHdpdGggdGhlIHNhbWUgZWxlbWVudCBhbmQgYXJndW1lbnRzLlwiXG4gICAgICB9LFxuICAgICAgXCJnZXRFbGVtZW50c0J5VGFnTmFtZU5TXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKG5zOiBzdHJpbmcsIHRhZ05hbWU6IHN0cmluZykgLT4gK05vZGVMaXN0XCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2VsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWVOU1wiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIGEgbGlzdCBvZiBlbGVtZW50cyB3aXRoIHRoZSBnaXZlbiB0YWcgbmFtZSBiZWxvbmdpbmcgdG8gdGhlIGdpdmVuIG5hbWVzcGFjZS5cIlxuICAgICAgfSxcbiAgICAgIFwiZ2V0QXR0cmlidXRlTlNcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4obnM6IHN0cmluZywgbmFtZTogc3RyaW5nKSAtPiBzdHJpbmdcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZWxlbWVudC5nZXRBdHRyaWJ1dGVOU1wiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIHRoZSBzdHJpbmcgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZXNwYWNlIGFuZCBuYW1lLiBJZiB0aGUgbmFtZWQgYXR0cmlidXRlIGRvZXMgbm90IGV4aXN0LCB0aGUgdmFsdWUgcmV0dXJuZWQgd2lsbCBlaXRoZXIgYmUgbnVsbCBvciBcXFwiXFxcIiAodGhlIGVtcHR5IHN0cmluZykuXCJcbiAgICAgIH0sXG4gICAgICBcInNldEF0dHJpYnV0ZU5TXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKG5zOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZylcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZWxlbWVudC5zZXRBdHRyaWJ1dGVOU1wiLFxuICAgICAgICBcIiFkb2NcIjogXCJBZGRzIGEgbmV3IGF0dHJpYnV0ZSBvciBjaGFuZ2VzIHRoZSB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUgd2l0aCB0aGUgZ2l2ZW4gbmFtZXNwYWNlIGFuZCBuYW1lLlwiXG4gICAgICB9LFxuICAgICAgXCJyZW1vdmVBdHRyaWJ1dGVOU1wiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihuczogc3RyaW5nLCBuYW1lOiBzdHJpbmcpXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlTlNcIixcbiAgICAgICAgXCIhZG9jXCI6IFwicmVtb3ZlQXR0cmlidXRlTlMgcmVtb3ZlcyB0aGUgc3BlY2lmaWVkIGF0dHJpYnV0ZSBmcm9tIGFuIGVsZW1lbnQuXCJcbiAgICAgIH0sXG4gICAgICBcImdldEF0dHJpYnV0ZU5vZGVOU1wiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihuczogc3RyaW5nLCBuYW1lOiBzdHJpbmcpIC0+ICtBdHRyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2VsZW1lbnQuZ2V0QXR0cmlidXRlTm9kZU5TXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIEF0dHIgbm9kZSBmb3IgdGhlIGF0dHJpYnV0ZSB3aXRoIHRoZSBnaXZlbiBuYW1lc3BhY2UgYW5kIG5hbWUuXCJcbiAgICAgIH0sXG4gICAgICBcImhhc0F0dHJpYnV0ZVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihuYW1lOiBzdHJpbmcpIC0+IGJvb2xcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZWxlbWVudC5oYXNBdHRyaWJ1dGVcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiaGFzQXR0cmlidXRlIHJldHVybnMgYSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgc3BlY2lmaWVkIGVsZW1lbnQgaGFzIHRoZSBzcGVjaWZpZWQgYXR0cmlidXRlIG9yIG5vdC5cIlxuICAgICAgfSxcbiAgICAgIFwiaGFzQXR0cmlidXRlTlNcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4obnM6IHN0cmluZywgbmFtZTogc3RyaW5nKSAtPiBib29sXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2VsZW1lbnQuaGFzQXR0cmlidXRlTlNcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiaGFzQXR0cmlidXRlTlMgcmV0dXJucyBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBjdXJyZW50IGVsZW1lbnQgaGFzIHRoZSBzcGVjaWZpZWQgYXR0cmlidXRlLlwiXG4gICAgICB9LFxuICAgICAgXCJmb2N1c1wiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbigpXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2VsZW1lbnQuZm9jdXNcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiU2V0cyBmb2N1cyBvbiB0aGUgc3BlY2lmaWVkIGVsZW1lbnQsIGlmIGl0IGNhbiBiZSBmb2N1c2VkLlwiXG4gICAgICB9LFxuICAgICAgXCJibHVyXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKClcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZWxlbWVudC5ibHVyXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlRoZSBibHVyIG1ldGhvZCByZW1vdmVzIGtleWJvYXJkIGZvY3VzIGZyb20gdGhlIGN1cnJlbnQgZWxlbWVudC5cIlxuICAgICAgfSxcbiAgICAgIFwic2Nyb2xsSW50b1ZpZXdcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4odG9wOiBib29sKVwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9lbGVtZW50LnNjcm9sbEludG9WaWV3XCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlRoZSBzY3JvbGxJbnRvVmlldygpIG1ldGhvZCBzY3JvbGxzIHRoZSBlbGVtZW50IGludG8gdmlldy5cIlxuICAgICAgfSxcbiAgICAgIFwic2Nyb2xsQnlMaW5lc1wiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihsaW5lczogbnVtYmVyKVwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS93aW5kb3cuc2Nyb2xsQnlMaW5lc1wiLFxuICAgICAgICBcIiFkb2NcIjogXCJTY3JvbGxzIHRoZSBkb2N1bWVudCBieSB0aGUgZ2l2ZW4gbnVtYmVyIG9mIGxpbmVzLlwiXG4gICAgICB9LFxuICAgICAgXCJzY3JvbGxCeVBhZ2VzXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKHBhZ2VzOiBudW1iZXIpXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL3dpbmRvdy5zY3JvbGxCeVBhZ2VzXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlNjcm9sbHMgdGhlIGN1cnJlbnQgZG9jdW1lbnQgYnkgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgcGFnZXMuXCJcbiAgICAgIH0sXG4gICAgICBcImdldEVsZW1lbnRzQnlDbGFzc05hbWVcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4obmFtZTogc3RyaW5nKSAtPiArTm9kZUxpc3RcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZVwiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIGEgc2V0IG9mIGVsZW1lbnRzIHdoaWNoIGhhdmUgYWxsIHRoZSBnaXZlbiBjbGFzcyBuYW1lcy4gV2hlbiBjYWxsZWQgb24gdGhlIGRvY3VtZW50IG9iamVjdCwgdGhlIGNvbXBsZXRlIGRvY3VtZW50IGlzIHNlYXJjaGVkLCBpbmNsdWRpbmcgdGhlIHJvb3Qgbm9kZS4gWW91IG1heSBhbHNvIGNhbGwgZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSBvbiBhbnkgZWxlbWVudDsgaXQgd2lsbCByZXR1cm4gb25seSBlbGVtZW50cyB3aGljaCBhcmUgZGVzY2VuZGFudHMgb2YgdGhlIHNwZWNpZmllZCByb290IGVsZW1lbnQgd2l0aCB0aGUgZ2l2ZW4gY2xhc3MgbmFtZXMuXCJcbiAgICAgIH0sXG4gICAgICBcInF1ZXJ5U2VsZWN0b3JcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oc2VsZWN0b3JzOiBzdHJpbmcpIC0+ICtOb2RlXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL0VsZW1lbnQucXVlcnlTZWxlY3RvclwiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaXMgYSBkZXNjZW5kZW50IG9mIHRoZSBlbGVtZW50IG9uIHdoaWNoIGl0IGlzIGludm9rZWQgdGhhdCBtYXRjaGVzIHRoZSBzcGVjaWZpZWQgZ3JvdXAgb2Ygc2VsZWN0b3JzLlwiXG4gICAgICB9LFxuICAgICAgXCJxdWVyeVNlbGVjdG9yQWxsXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKHNlbGVjdG9yczogc3RyaW5nKSAtPiArTm9kZUxpc3RcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vRWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgYSBub24tbGl2ZSBOb2RlTGlzdCBvZiBhbGwgZWxlbWVudHMgZGVzY2VuZGVkIGZyb20gdGhlIGVsZW1lbnQgb24gd2hpY2ggaXQgaXMgaW52b2tlZCB0aGF0IG1hdGNoIHRoZSBzcGVjaWZpZWQgZ3JvdXAgb2YgQ1NTIHNlbGVjdG9ycy5cIlxuICAgICAgfSxcbiAgICAgIFwiZ2V0Q2xpZW50UmVjdHNcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oKSAtPiBbK0NsaWVudFJlY3RdXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2VsZW1lbnQuZ2V0Q2xpZW50UmVjdHNcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyBhIGNvbGxlY3Rpb24gb2YgcmVjdGFuZ2xlcyB0aGF0IGluZGljYXRlIHRoZSBib3VuZGluZyByZWN0YW5nbGVzIGZvciBlYWNoIGJveCBpbiBhIGNsaWVudC5cIlxuICAgICAgfSxcbiAgICAgIFwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0XCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKCkgLT4gK0NsaWVudFJlY3RcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3RcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyBhIHRleHQgcmVjdGFuZ2xlIG9iamVjdCB0aGF0IGVuY2xvc2VzIGEgZ3JvdXAgb2YgdGV4dCByZWN0YW5nbGVzLlwiXG4gICAgICB9LFxuICAgICAgXCJzZXRBdHRyaWJ1dGVOb2RlXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKGF0dHI6ICtBdHRyKSAtPiArQXR0clwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9lbGVtZW50LnNldEF0dHJpYnV0ZU5vZGVcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiQWRkcyBhIG5ldyBBdHRyIG5vZGUgdG8gdGhlIHNwZWNpZmllZCBlbGVtZW50LlwiXG4gICAgICB9LFxuICAgICAgXCJyZW1vdmVBdHRyaWJ1dGVOb2RlXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKGF0dHI6ICtBdHRyKSAtPiArQXR0clwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZU5vZGVcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmVtb3ZlcyB0aGUgc3BlY2lmaWVkIGF0dHJpYnV0ZSBmcm9tIHRoZSBjdXJyZW50IGVsZW1lbnQuXCJcbiAgICAgIH0sXG4gICAgICBcInNldEF0dHJpYnV0ZU5vZGVOU1wiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihhdHRyOiArQXR0cikgLT4gK0F0dHJcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZWxlbWVudC5zZXRBdHRyaWJ1dGVOb2RlTlNcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiQWRkcyBhIG5ldyBuYW1lc3BhY2VkIGF0dHJpYnV0ZSBub2RlIHRvIGFuIGVsZW1lbnQuXCJcbiAgICAgIH0sXG4gICAgICBcImluc2VydEFkamFjZW50SFRNTFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihwb3NpdGlvbjogc3RyaW5nLCB0ZXh0OiBzdHJpbmcpXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2VsZW1lbnQuaW5zZXJ0QWRqYWNlbnRIVE1MXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlBhcnNlcyB0aGUgc3BlY2lmaWVkIHRleHQgYXMgSFRNTCBvciBYTUwgYW5kIGluc2VydHMgdGhlIHJlc3VsdGluZyBub2RlcyBpbnRvIHRoZSBET00gdHJlZSBhdCBhIHNwZWNpZmllZCBwb3NpdGlvbi4gSXQgZG9lcyBub3QgcmVwYXJzZSB0aGUgZWxlbWVudCBpdCBpcyBiZWluZyB1c2VkIG9uIGFuZCB0aHVzIGl0IGRvZXMgbm90IGNvcnJ1cHQgdGhlIGV4aXN0aW5nIGVsZW1lbnRzIGluc2lkZSB0aGUgZWxlbWVudC4gVGhpcywgYW5kIGF2b2lkaW5nIHRoZSBleHRyYSBzdGVwIG9mIHNlcmlhbGl6YXRpb24gbWFrZSBpdCBtdWNoIGZhc3RlciB0aGFuIGRpcmVjdCBpbm5lckhUTUwgbWFuaXB1bGF0aW9uLlwiXG4gICAgICB9LFxuICAgICAgXCJjaGlsZHJlblwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCIrSFRNTENvbGxlY3Rpb25cIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vRWxlbWVudC5jaGlsZHJlblwiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIGEgY29sbGVjdGlvbiBvZiBjaGlsZCBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cIlxuICAgICAgfSxcbiAgICAgIFwiY2hpbGRFbGVtZW50Q291bnRcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL0VsZW1lbnQuY2hpbGRFbGVtZW50Q291bnRcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgbnVtYmVyIG9mIGNoaWxkIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBlbGVtZW50LlwiXG4gICAgICB9LFxuICAgICAgXCJjbGFzc05hbWVcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2VsZW1lbnQuY2xhc3NOYW1lXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIkdldHMgYW5kIHNldHMgdGhlIHZhbHVlIG9mIHRoZSBjbGFzcyBhdHRyaWJ1dGUgb2YgdGhlIHNwZWNpZmllZCBlbGVtZW50LlwiXG4gICAgICB9LFxuICAgICAgXCJzdHlsZVwiOiB7XG4gICAgICAgIFwiY3NzVGV4dFwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImFsaWdubWVudEJhc2VsaW5lXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiYmFja2dyb3VuZFwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImJhY2tncm91bmRBdHRhY2htZW50XCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiYmFja2dyb3VuZENsaXBcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJiYWNrZ3JvdW5kQ29sb3JcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJiYWNrZ3JvdW5kSW1hZ2VcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJiYWNrZ3JvdW5kT3JpZ2luXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiYmFja2dyb3VuZFBvc2l0aW9uXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiYmFja2dyb3VuZFBvc2l0aW9uWFwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImJhY2tncm91bmRQb3NpdGlvbllcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJiYWNrZ3JvdW5kUmVwZWF0XCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiYmFja2dyb3VuZFJlcGVhdFhcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJiYWNrZ3JvdW5kUmVwZWF0WVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImJhY2tncm91bmRTaXplXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiYmFzZWxpbmVTaGlmdFwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImJvcmRlclwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImJvcmRlckJvdHRvbVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImJvcmRlckJvdHRvbUNvbG9yXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiYm9yZGVyQm90dG9tTGVmdFJhZGl1c1wiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiYm9yZGVyQm90dG9tU3R5bGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJib3JkZXJCb3R0b21XaWR0aFwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImJvcmRlckNvbGxhcHNlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiYm9yZGVyQ29sb3JcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJib3JkZXJJbWFnZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImJvcmRlckltYWdlT3V0c2V0XCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiYm9yZGVySW1hZ2VSZXBlYXRcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJib3JkZXJJbWFnZVNsaWNlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiYm9yZGVySW1hZ2VTb3VyY2VcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJib3JkZXJJbWFnZVdpZHRoXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiYm9yZGVyTGVmdFwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImJvcmRlckxlZnRDb2xvclwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImJvcmRlckxlZnRTdHlsZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImJvcmRlckxlZnRXaWR0aFwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImJvcmRlclJhZGl1c1wiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImJvcmRlclJpZ2h0XCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiYm9yZGVyUmlnaHRDb2xvclwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImJvcmRlclJpZ2h0U3R5bGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJib3JkZXJSaWdodFdpZHRoXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiYm9yZGVyU3BhY2luZ1wiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImJvcmRlclN0eWxlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiYm9yZGVyVG9wXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiYm9yZGVyVG9wQ29sb3JcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJib3JkZXJUb3BMZWZ0UmFkaXVzXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiYm9yZGVyVG9wUmlnaHRSYWRpdXNcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJib3JkZXJUb3BTdHlsZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImJvcmRlclRvcFdpZHRoXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiYm9yZGVyV2lkdGhcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJib3R0b21cIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJib3hTaGFkb3dcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJib3hTaXppbmdcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJjYXB0aW9uU2lkZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImNsZWFyXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiY2xpcFwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImNsaXBQYXRoXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiY2xpcFJ1bGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJjb2xvclwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImNvbG9ySW50ZXJwb2xhdGlvblwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImNvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnNcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJjb2xvclByb2ZpbGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJjb2xvclJlbmRlcmluZ1wiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImNvbnRlbnRcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJjb3VudGVySW5jcmVtZW50XCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiY291bnRlclJlc2V0XCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiY3Vyc29yXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiZGlyZWN0aW9uXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiZGlzcGxheVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImRvbWluYW50QmFzZWxpbmVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJlbXB0eUNlbGxzXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiZW5hYmxlQmFja2dyb3VuZFwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImZpbGxcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJmaWxsT3BhY2l0eVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImZpbGxSdWxlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiZmlsdGVyXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiZmxvYXRcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJmbG9vZENvbG9yXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiZmxvb2RPcGFjaXR5XCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiZm9udFwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImZvbnRGYW1pbHlcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJmb250U2l6ZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImZvbnRTdHJldGNoXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiZm9udFN0eWxlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiZm9udFZhcmlhbnRcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJmb250V2VpZ2h0XCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWxcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJnbHlwaE9yaWVudGF0aW9uVmVydGljYWxcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJoZWlnaHRcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpbWFnZVJlbmRlcmluZ1wiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImtlcm5pbmdcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJsZWZ0XCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwibGV0dGVyU3BhY2luZ1wiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImxpZ2h0aW5nQ29sb3JcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJsaW5lSGVpZ2h0XCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwibGlzdFN0eWxlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwibGlzdFN0eWxlSW1hZ2VcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJsaXN0U3R5bGVQb3NpdGlvblwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImxpc3RTdHlsZVR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJtYXJnaW5cIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJtYXJnaW5Cb3R0b21cIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJtYXJnaW5MZWZ0XCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwibWFyZ2luUmlnaHRcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJtYXJnaW5Ub3BcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJtYXJrZXJcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJtYXJrZXJFbmRcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJtYXJrZXJNaWRcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJtYXJrZXJTdGFydFwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcIm1hc2tcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJtYXhIZWlnaHRcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJtYXhXaWR0aFwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcIm1pbkhlaWdodFwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcIm1pbldpZHRoXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwib3BhY2l0eVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcIm9ycGhhbnNcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJvdXRsaW5lXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwib3V0bGluZUNvbG9yXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwib3V0bGluZU9mZnNldFwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcIm91dGxpbmVTdHlsZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcIm91dGxpbmVXaWR0aFwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcIm92ZXJmbG93XCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwib3ZlcmZsb3dXcmFwXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwib3ZlcmZsb3dYXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwib3ZlcmZsb3dZXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwicGFkZGluZ1wiOiBcInN0cmluZ1wiLFxuICAgICAgICBcInBhZGRpbmdCb3R0b21cIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJwYWRkaW5nTGVmdFwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcInBhZGRpbmdSaWdodFwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcInBhZGRpbmdUb3BcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJwYWdlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwicGFnZUJyZWFrQWZ0ZXJcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJwYWdlQnJlYWtCZWZvcmVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJwYWdlQnJlYWtJbnNpZGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJwb2ludGVyRXZlbnRzXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwicG9zaXRpb25cIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJxdW90ZXNcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJyZXNpemVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJyaWdodFwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcInNoYXBlUmVuZGVyaW5nXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwic2l6ZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcInNwZWFrXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwic3JjXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwic3RvcENvbG9yXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwic3RvcE9wYWNpdHlcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJzdHJva2VcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJzdHJva2VEYXNoYXJyYXlcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJzdHJva2VEYXNob2Zmc2V0XCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwic3Ryb2tlTGluZWNhcFwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcInN0cm9rZUxpbmVqb2luXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwic3Ryb2tlTWl0ZXJsaW1pdFwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcInN0cm9rZU9wYWNpdHlcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJzdHJva2VXaWR0aFwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcInRhYlNpemVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJ0YWJsZUxheW91dFwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcInRleHRBbGlnblwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcInRleHRBbmNob3JcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJ0ZXh0RGVjb3JhdGlvblwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcInRleHRJbmRlbnRcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJ0ZXh0TGluZVRocm91Z2hcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJ0ZXh0TGluZVRocm91Z2hDb2xvclwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcInRleHRMaW5lVGhyb3VnaE1vZGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJ0ZXh0TGluZVRocm91Z2hTdHlsZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcInRleHRMaW5lVGhyb3VnaFdpZHRoXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwidGV4dE92ZXJmbG93XCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwidGV4dE92ZXJsaW5lXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwidGV4dE92ZXJsaW5lQ29sb3JcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJ0ZXh0T3ZlcmxpbmVNb2RlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwidGV4dE92ZXJsaW5lU3R5bGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJ0ZXh0T3ZlcmxpbmVXaWR0aFwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcInRleHRSZW5kZXJpbmdcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJ0ZXh0U2hhZG93XCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwidGV4dFRyYW5zZm9ybVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcInRleHRVbmRlcmxpbmVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJ0ZXh0VW5kZXJsaW5lQ29sb3JcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJ0ZXh0VW5kZXJsaW5lTW9kZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcInRleHRVbmRlcmxpbmVTdHlsZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcInRleHRVbmRlcmxpbmVXaWR0aFwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcInRvcFwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcInVuaWNvZGVCaWRpXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwidW5pY29kZVJhbmdlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwidmVjdG9yRWZmZWN0XCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwidmVydGljYWxBbGlnblwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcInZpc2liaWxpdHlcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJ3aGl0ZVNwYWNlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwid2lkdGhcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJ3b3JkQnJlYWtcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJ3b3JkU3BhY2luZ1wiOiBcInN0cmluZ1wiLFxuICAgICAgICBcIndvcmRXcmFwXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwid3JpdGluZ01vZGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJ6SW5kZXhcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJ6b29tXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2VsZW1lbnQuc3R5bGVcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyBhbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBlbGVtZW50J3Mgc3R5bGUgYXR0cmlidXRlLlwiXG4gICAgICB9LFxuICAgICAgXCJjbGFzc0xpc3RcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiK0RPTVRva2VuTGlzdFwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9lbGVtZW50LmNsYXNzTGlzdFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIGEgdG9rZW4gbGlzdCBvZiB0aGUgY2xhc3MgYXR0cmlidXRlIG9mIHRoZSBlbGVtZW50LlwiXG4gICAgICB9LFxuICAgICAgXCJjb250ZW50RWRpdGFibGVcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiYm9vbFwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9FbGVtZW50LmNvbnRlbnRFZGl0YWJsZVwiLFxuICAgICAgICBcIiFkb2NcIjogXCJJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdGhlIGVsZW1lbnQgaXMgZWRpdGFibGUuXCJcbiAgICAgIH0sXG4gICAgICBcImZpcnN0RWxlbWVudENoaWxkXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIitFbGVtZW50XCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL0VsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGRcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgZWxlbWVudCdzIGZpcnN0IGNoaWxkIGVsZW1lbnQgb3IgbnVsbCBpZiB0aGVyZSBhcmUgbm8gY2hpbGQgZWxlbWVudHMuXCJcbiAgICAgIH0sXG4gICAgICBcImxhc3RFbGVtZW50Q2hpbGRcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiK0VsZW1lbnRcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vRWxlbWVudC5sYXN0RWxlbWVudENoaWxkXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIGVsZW1lbnQncyBsYXN0IGNoaWxkIGVsZW1lbnQgb3IgbnVsbCBpZiB0aGVyZSBhcmUgbm8gY2hpbGQgZWxlbWVudHMuXCJcbiAgICAgIH0sXG4gICAgICBcIm5leHRFbGVtZW50U2libGluZ1wiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCIrRWxlbWVudFwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9FbGVtZW50Lm5leHRFbGVtZW50U2libGluZ1wiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIHRoZSBlbGVtZW50IGltbWVkaWF0ZWx5IGZvbGxvd2luZyB0aGUgc3BlY2lmaWVkIG9uZSBpbiBpdHMgcGFyZW50J3MgY2hpbGRyZW4gbGlzdCwgb3IgbnVsbCBpZiB0aGUgc3BlY2lmaWVkIGVsZW1lbnQgaXMgdGhlIGxhc3Qgb25lIGluIHRoZSBsaXN0LlwiXG4gICAgICB9LFxuICAgICAgXCJwcmV2aW91c0VsZW1lbnRTaWJsaW5nXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIitFbGVtZW50XCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL0VsZW1lbnQucHJldmlvdXNFbGVtZW50U2libGluZ1wiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIHRoZSBlbGVtZW50IGltbWVkaWF0ZWx5IHByaW9yIHRvIHRoZSBzcGVjaWZpZWQgb25lIGluIGl0cyBwYXJlbnQncyBjaGlsZHJlbiBsaXN0LCBvciBudWxsIGlmIHRoZSBzcGVjaWZpZWQgZWxlbWVudCBpcyB0aGUgZmlyc3Qgb25lIGluIHRoZSBsaXN0LlwiXG4gICAgICB9LFxuICAgICAgXCJ0YWJJbmRleFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZWxlbWVudC50YWJJbmRleFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJHZXRzL3NldHMgdGhlIHRhYiBvcmRlciBvZiB0aGUgY3VycmVudCBlbGVtZW50LlwiXG4gICAgICB9LFxuICAgICAgXCJ0aXRsZVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZWxlbWVudC50aXRsZVwiLFxuICAgICAgICBcIiFkb2NcIjogXCJFc3RhYmxpc2hlcyB0aGUgdGV4dCB0byBiZSBkaXNwbGF5ZWQgaW4gYSAndG9vbCB0aXAnIHBvcHVwIHdoZW4gdGhlIG1vdXNlIGlzIG92ZXIgdGhlIGRpc3BsYXllZCBub2RlLlwiXG4gICAgICB9LFxuICAgICAgXCJ3aWR0aFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZWxlbWVudC5vZmZzZXRXaWR0aFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIHRoZSBsYXlvdXQgd2lkdGggb2YgYW4gZWxlbWVudC5cIlxuICAgICAgfSxcbiAgICAgIFwiaGVpZ2h0XCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9lbGVtZW50Lm9mZnNldEhlaWdodFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJIZWlnaHQgb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byB0aGUgZWxlbWVudCdzIG9mZnNldFBhcmVudC5cIlxuICAgICAgfSxcbiAgICAgIFwiZ2V0Q29udGV4dFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihpZDogc3RyaW5nKSAtPiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vSFRNTENhbnZhc0VsZW1lbnRcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiRE9NIGNhbnZhcyBlbGVtZW50cyBleHBvc2UgdGhlIEhUTUxDYW52YXNFbGVtZW50IGludGVyZmFjZSwgd2hpY2ggcHJvdmlkZXMgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBmb3IgbWFuaXB1bGF0aW5nIHRoZSBsYXlvdXQgYW5kIHByZXNlbnRhdGlvbiBvZiBjYW52YXMgZWxlbWVudHMuIFRoZSBIVE1MQ2FudmFzRWxlbWVudCBpbnRlcmZhY2UgaW5oZXJpdHMgdGhlIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgb2YgdGhlIGVsZW1lbnQgb2JqZWN0IGludGVyZmFjZS5cIlxuICAgICAgfSxcbiAgICAgIFwic3VwcG9ydHNDb250ZXh0XCI6IFwiZm4oaWQ6IHN0cmluZykgLT4gYm9vbFwiLFxuICAgICAgXCJvbmNvcHlcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiP1wiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9lbGVtZW50Lm9uY29weVwiLFxuICAgICAgICBcIiFkb2NcIjogXCJUaGUgb25jb3B5IHByb3BlcnR5IHJldHVybnMgdGhlIG9uQ29weSBldmVudCBoYW5kbGVyIGNvZGUgb24gdGhlIGN1cnJlbnQgZWxlbWVudC5cIlxuICAgICAgfSxcbiAgICAgIFwib25jdXRcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiP1wiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9lbGVtZW50Lm9uY3V0XCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlRoZSBvbmN1dCBwcm9wZXJ0eSByZXR1cm5zIHRoZSBvbkN1dCBldmVudCBoYW5kbGVyIGNvZGUgb24gdGhlIGN1cnJlbnQgZWxlbWVudC5cIlxuICAgICAgfSxcbiAgICAgIFwib25wYXN0ZVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCI/XCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2VsZW1lbnQub25wYXN0ZVwiLFxuICAgICAgICBcIiFkb2NcIjogXCJUaGUgb25wYXN0ZSBwcm9wZXJ0eSByZXR1cm5zIHRoZSBvblBhc3RlIGV2ZW50IGhhbmRsZXIgY29kZSBvbiB0aGUgY3VycmVudCBlbGVtZW50LlwiXG4gICAgICB9LFxuICAgICAgXCJvbmJlZm9yZXVubG9hZFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCI/XCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvSFRNTC9FbGVtZW50L2JvZHlcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiVGhlIEhUTUwgPGJvZHk+IGVsZW1lbnQgcmVwcmVzZW50cyB0aGUgbWFpbiBjb250ZW50IG9mIGFuIEhUTUwgZG9jdW1lbnQuIFRoZXJlIGlzIG9ubHkgb25lIDxib2R5PiBlbGVtZW50IGluIGEgZG9jdW1lbnQuXCJcbiAgICAgIH0sXG4gICAgICBcIm9uZm9jdXNcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiP1wiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9lbGVtZW50Lm9uZm9jdXNcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiVGhlIG9uZm9jdXMgcHJvcGVydHkgcmV0dXJucyB0aGUgb25Gb2N1cyBldmVudCBoYW5kbGVyIGNvZGUgb24gdGhlIGN1cnJlbnQgZWxlbWVudC5cIlxuICAgICAgfSxcbiAgICAgIFwib25ibHVyXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIj9cIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZWxlbWVudC5vbmJsdXJcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiVGhlIG9uYmx1ciBwcm9wZXJ0eSByZXR1cm5zIHRoZSBvbkJsdXIgZXZlbnQgaGFuZGxlciBjb2RlLCBpZiBhbnksIHRoYXQgZXhpc3RzIG9uIHRoZSBjdXJyZW50IGVsZW1lbnQuXCJcbiAgICAgIH0sXG4gICAgICBcIm9uY2hhbmdlXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIj9cIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZWxlbWVudC5vbmNoYW5nZVwiLFxuICAgICAgICBcIiFkb2NcIjogXCJUaGUgb25jaGFuZ2UgcHJvcGVydHkgc2V0cyBhbmQgcmV0dXJucyB0aGUgb25DaGFuZ2UgZXZlbnQgaGFuZGxlciBjb2RlIGZvciB0aGUgY3VycmVudCBlbGVtZW50LlwiXG4gICAgICB9LFxuICAgICAgXCJvbmNsaWNrXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIj9cIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZWxlbWVudC5vbmNsaWNrXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlRoZSBvbmNsaWNrIHByb3BlcnR5IHJldHVybnMgdGhlIG9uQ2xpY2sgZXZlbnQgaGFuZGxlciBjb2RlIG9uIHRoZSBjdXJyZW50IGVsZW1lbnQuXCJcbiAgICAgIH0sXG4gICAgICBcIm9uZGJsY2xpY2tcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiP1wiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9lbGVtZW50Lm9uZGJsY2xpY2tcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiVGhlIG9uZGJsY2xpY2sgcHJvcGVydHkgcmV0dXJucyB0aGUgb25EYmxDbGljayBldmVudCBoYW5kbGVyIGNvZGUgb24gdGhlIGN1cnJlbnQgZWxlbWVudC5cIlxuICAgICAgfSxcbiAgICAgIFwib25tb3VzZWRvd25cIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiP1wiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9lbGVtZW50Lm9ubW91c2Vkb3duXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlRoZSBvbm1vdXNlZG93biBwcm9wZXJ0eSByZXR1cm5zIHRoZSBvbk1vdXNlRG93biBldmVudCBoYW5kbGVyIGNvZGUgb24gdGhlIGN1cnJlbnQgZWxlbWVudC5cIlxuICAgICAgfSxcbiAgICAgIFwib25tb3VzZXVwXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIj9cIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZWxlbWVudC5vbm1vdXNldXBcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiVGhlIG9ubW91c2V1cCBwcm9wZXJ0eSByZXR1cm5zIHRoZSBvbk1vdXNlVXAgZXZlbnQgaGFuZGxlciBjb2RlIG9uIHRoZSBjdXJyZW50IGVsZW1lbnQuXCJcbiAgICAgIH0sXG4gICAgICBcIm9ubW91c2V3aGVlbFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCI/XCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL01vemlsbGFfZXZlbnRfcmVmZXJlbmNlL3doZWVsXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlRoZSB3aGVlbCBldmVudCBpcyBmaXJlZCB3aGVuIGEgd2hlZWwgYnV0dG9uIG9mIGEgcG9pbnRpbmcgZGV2aWNlICh1c3VhbGx5IGEgbW91c2UpIGlzIHJvdGF0ZWQuIFRoaXMgZXZlbnQgZGVwcmVjYXRlcyB0aGUgbGVnYWN5IG1vdXNld2hlZWwgZXZlbnQuXCJcbiAgICAgIH0sXG4gICAgICBcIm9ubW91c2VvdmVyXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIj9cIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZWxlbWVudC5vbm1vdXNlb3ZlclwiLFxuICAgICAgICBcIiFkb2NcIjogXCJUaGUgb25tb3VzZW92ZXIgcHJvcGVydHkgcmV0dXJucyB0aGUgb25Nb3VzZU92ZXIgZXZlbnQgaGFuZGxlciBjb2RlIG9uIHRoZSBjdXJyZW50IGVsZW1lbnQuXCJcbiAgICAgIH0sXG4gICAgICBcIm9ubW91c2VvdXRcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiP1wiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9lbGVtZW50Lm9ubW91c2VvdXRcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiVGhlIG9ubW91c2VvdXQgcHJvcGVydHkgcmV0dXJucyB0aGUgb25Nb3VzZU91dCBldmVudCBoYW5kbGVyIGNvZGUgb24gdGhlIGN1cnJlbnQgZWxlbWVudC5cIlxuICAgICAgfSxcbiAgICAgIFwib25tb3VzZW1vdmVcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiP1wiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9lbGVtZW50Lm9ubW91c2Vtb3ZlXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlRoZSBvbm1vdXNlbW92ZSBwcm9wZXJ0eSByZXR1cm5zIHRoZSBtb3VzZW1vdmUgZXZlbnQgaGFuZGxlciBjb2RlIG9uIHRoZSBjdXJyZW50IGVsZW1lbnQuXCJcbiAgICAgIH0sXG4gICAgICBcIm9uY29udGV4dG1lbnVcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiP1wiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS93aW5kb3cub25jb250ZXh0bWVudVwiLFxuICAgICAgICBcIiFkb2NcIjogXCJBbiBldmVudCBoYW5kbGVyIHByb3BlcnR5IGZvciByaWdodC1jbGljayBldmVudHMgb24gdGhlIHdpbmRvdy4gVW5sZXNzIHRoZSBkZWZhdWx0IGJlaGF2aW9yIGlzIHByZXZlbnRlZCwgdGhlIGJyb3dzZXIgY29udGV4dCBtZW51IHdpbGwgYWN0aXZhdGUuIE5vdGUgdGhhdCB0aGlzIGV2ZW50IHdpbGwgb2NjdXIgd2l0aCBhbnkgbm9uLWRpc2FibGVkIHJpZ2h0LWNsaWNrIGV2ZW50IGFuZCBkb2VzIG5vdCBkZXBlbmQgb24gYW4gZWxlbWVudCBwb3NzZXNzaW5nIHRoZSBcXFwiY29udGV4dG1lbnVcXFwiIGF0dHJpYnV0ZS5cIlxuICAgICAgfSxcbiAgICAgIFwib25rZXlkb3duXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIj9cIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZWxlbWVudC5vbmtleWRvd25cIixcbiAgICAgICAgXCIhZG9jXCI6IFwiVGhlIG9ua2V5ZG93biBwcm9wZXJ0eSByZXR1cm5zIHRoZSBvbktleURvd24gZXZlbnQgaGFuZGxlciBjb2RlIG9uIHRoZSBjdXJyZW50IGVsZW1lbnQuXCJcbiAgICAgIH0sXG4gICAgICBcIm9ua2V5dXBcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiP1wiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9lbGVtZW50Lm9ua2V5dXBcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiVGhlIG9ua2V5dXAgcHJvcGVydHkgcmV0dXJucyB0aGUgb25LZXlVcCBldmVudCBoYW5kbGVyIGNvZGUgZm9yIHRoZSBjdXJyZW50IGVsZW1lbnQuXCJcbiAgICAgIH0sXG4gICAgICBcIm9ua2V5cHJlc3NcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiP1wiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9lbGVtZW50Lm9ua2V5cHJlc3NcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiVGhlIG9ua2V5cHJlc3MgcHJvcGVydHkgc2V0cyBhbmQgcmV0dXJucyB0aGUgb25LZXlQcmVzcyBldmVudCBoYW5kbGVyIGNvZGUgZm9yIHRoZSBjdXJyZW50IGVsZW1lbnQuXCJcbiAgICAgIH0sXG4gICAgICBcIm9ucmVzaXplXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIj9cIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZWxlbWVudC5vbnJlc2l6ZVwiLFxuICAgICAgICBcIiFkb2NcIjogXCJvbnJlc2l6ZSByZXR1cm5zIHRoZSBlbGVtZW50J3Mgb25yZXNpemUgZXZlbnQgaGFuZGxlciBjb2RlLiBJdCBjYW4gYWxzbyBiZSB1c2VkIHRvIHNldCB0aGUgY29kZSB0byBiZSBleGVjdXRlZCB3aGVuIHRoZSByZXNpemUgZXZlbnQgb2NjdXJzLlwiXG4gICAgICB9LFxuICAgICAgXCJvbnNjcm9sbFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCI/XCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2VsZW1lbnQub25zY3JvbGxcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiVGhlIG9uc2Nyb2xsIHByb3BlcnR5IHJldHVybnMgdGhlIG9uU2Nyb2xsIGV2ZW50IGhhbmRsZXIgY29kZSBvbiB0aGUgY3VycmVudCBlbGVtZW50LlwiXG4gICAgICB9LFxuICAgICAgXCJvbmRyYWdzdGFydFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCI/XCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRHJhZ0Ryb3AvRHJhZ19PcGVyYXRpb25zXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlRoZSBmb2xsb3dpbmcgZGVzY3JpYmVzIHRoZSBzdGVwcyB0aGF0IG9jY3VyIGR1cmluZyBhIGRyYWcgYW5kIGRyb3Agb3BlcmF0aW9uLlwiXG4gICAgICB9LFxuICAgICAgXCJvbmRyYWdvdmVyXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIj9cIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vTW96aWxsYV9ldmVudF9yZWZlcmVuY2UvZHJhZ292ZXJcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiVGhlIGRyYWdvdmVyIGV2ZW50IGlzIGZpcmVkIHdoZW4gYW4gZWxlbWVudCBvciB0ZXh0IHNlbGVjdGlvbiBpcyBiZWluZyBkcmFnZ2VkIG92ZXIgYSB2YWxpZCBkcm9wIHRhcmdldCAoZXZlcnkgZmV3IGh1bmRyZWQgbWlsbGlzZWNvbmRzKS5cIlxuICAgICAgfSxcbiAgICAgIFwib25kcmFnbGVhdmVcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiP1wiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9Nb3ppbGxhX2V2ZW50X3JlZmVyZW5jZS9kcmFnbGVhdmVcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiVGhlIGRyYWdsZWF2ZSBldmVudCBpcyBmaXJlZCB3aGVuIGEgZHJhZ2dlZCBlbGVtZW50IG9yIHRleHQgc2VsZWN0aW9uIGxlYXZlcyBhIHZhbGlkIGRyb3AgdGFyZ2V0LlwiXG4gICAgICB9LFxuICAgICAgXCJvbmRyYWdlbnRlclwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCI/XCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL01vemlsbGFfZXZlbnRfcmVmZXJlbmNlL2RyYWdlbnRlclwiLFxuICAgICAgICBcIiFkb2NcIjogXCJUaGUgZHJhZ2VudGVyIGV2ZW50IGlzIGZpcmVkIHdoZW4gYSBkcmFnZ2VkIGVsZW1lbnQgb3IgdGV4dCBzZWxlY3Rpb24gZW50ZXJzIGEgdmFsaWQgZHJvcCB0YXJnZXQuXCJcbiAgICAgIH0sXG4gICAgICBcIm9uZHJhZ2VuZFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCI/XCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL01vemlsbGFfZXZlbnRfcmVmZXJlbmNlL2RyYWdlbmRcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiVGhlIGRyYWdlbmQgZXZlbnQgaXMgZmlyZWQgd2hlbiBhIGRyYWcgb3BlcmF0aW9uIGlzIGJlaW5nIGVuZGVkIChieSByZWxlYXNpbmcgYSBtb3VzZSBidXR0b24gb3IgaGl0dGluZyB0aGUgZXNjYXBlIGtleSkuXCJcbiAgICAgIH0sXG4gICAgICBcIm9uZHJhZ1wiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCI/XCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL01vemlsbGFfZXZlbnRfcmVmZXJlbmNlL2RyYWdcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiVGhlIGRyYWcgZXZlbnQgaXMgZmlyZWQgd2hlbiBhbiBlbGVtZW50IG9yIHRleHQgc2VsZWN0aW9uIGlzIGJlaW5nIGRyYWdnZWQgKGV2ZXJ5IGZldyBodW5kcmVkIG1pbGxpc2Vjb25kcykuXCJcbiAgICAgIH0sXG4gICAgICBcIm9mZnNldFRvcFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZWxlbWVudC5vZmZzZXRUb3BcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgZGlzdGFuY2Ugb2YgdGhlIGN1cnJlbnQgZWxlbWVudCByZWxhdGl2ZSB0byB0aGUgdG9wIG9mIHRoZSBvZmZzZXRQYXJlbnQgbm9kZS5cIlxuICAgICAgfSxcbiAgICAgIFwib2Zmc2V0TGVmdFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZWxlbWVudC5vZmZzZXRMZWZ0XCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIG51bWJlciBvZiBwaXhlbHMgdGhhdCB0aGUgdXBwZXIgbGVmdCBjb3JuZXIgb2YgdGhlIGN1cnJlbnQgZWxlbWVudCBpcyBvZmZzZXQgdG8gdGhlIGxlZnQgd2l0aGluIHRoZSBvZmZzZXRQYXJlbnQgbm9kZS5cIlxuICAgICAgfSxcbiAgICAgIFwib2Zmc2V0SGVpZ2h0XCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9lbGVtZW50Lm9mZnNldEhlaWdodFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJIZWlnaHQgb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byB0aGUgZWxlbWVudCdzIG9mZnNldFBhcmVudC5cIlxuICAgICAgfSxcbiAgICAgIFwib2Zmc2V0V2lkdGhcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2VsZW1lbnQub2Zmc2V0V2lkdGhcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgbGF5b3V0IHdpZHRoIG9mIGFuIGVsZW1lbnQuXCJcbiAgICAgIH0sXG4gICAgICBcInNjcm9sbFRvcFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZWxlbWVudC5zY3JvbGxUb3BcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiR2V0cyBvciBzZXRzIHRoZSBudW1iZXIgb2YgcGl4ZWxzIHRoYXQgdGhlIGNvbnRlbnQgb2YgYW4gZWxlbWVudCBpcyBzY3JvbGxlZCB1cHdhcmQuXCJcbiAgICAgIH0sXG4gICAgICBcInNjcm9sbExlZnRcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2VsZW1lbnQuc2Nyb2xsTGVmdFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJHZXRzIG9yIHNldHMgdGhlIG51bWJlciBvZiBwaXhlbHMgdGhhdCBhbiBlbGVtZW50J3MgY29udGVudCBpcyBzY3JvbGxlZCB0byB0aGUgbGVmdC5cIlxuICAgICAgfSxcbiAgICAgIFwic2Nyb2xsSGVpZ2h0XCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9lbGVtZW50LnNjcm9sbEhlaWdodFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJIZWlnaHQgb2YgdGhlIHNjcm9sbCB2aWV3IG9mIGFuIGVsZW1lbnQ7IGl0IGluY2x1ZGVzIHRoZSBlbGVtZW50IHBhZGRpbmcgYnV0IG5vdCBpdHMgbWFyZ2luLlwiXG4gICAgICB9LFxuICAgICAgXCJzY3JvbGxXaWR0aFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZWxlbWVudC5zY3JvbGxXaWR0aFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZWFkLW9ubHkgcHJvcGVydHkgdGhhdCByZXR1cm5zIGVpdGhlciB0aGUgd2lkdGggaW4gcGl4ZWxzIG9mIHRoZSBjb250ZW50IG9mIGFuIGVsZW1lbnQgb3IgdGhlIHdpZHRoIG9mIHRoZSBlbGVtZW50IGl0c2VsZiwgd2hpY2hldmVyIGlzIGdyZWF0ZXIuXCJcbiAgICAgIH0sXG4gICAgICBcImNsaWVudFRvcFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZWxlbWVudC5jbGllbnRUb3BcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiVGhlIHdpZHRoIG9mIHRoZSB0b3AgYm9yZGVyIG9mIGFuIGVsZW1lbnQgaW4gcGl4ZWxzLiBJdCBkb2VzIG5vdCBpbmNsdWRlIHRoZSB0b3AgbWFyZ2luIG9yIHBhZGRpbmcuIGNsaWVudFRvcCBpcyByZWFkLW9ubHkuXCJcbiAgICAgIH0sXG4gICAgICBcImNsaWVudExlZnRcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2VsZW1lbnQuY2xpZW50TGVmdFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJUaGUgd2lkdGggb2YgdGhlIGxlZnQgYm9yZGVyIG9mIGFuIGVsZW1lbnQgaW4gcGl4ZWxzLiBJdCBpbmNsdWRlcyB0aGUgd2lkdGggb2YgdGhlIHZlcnRpY2FsIHNjcm9sbGJhciBpZiB0aGUgdGV4dCBkaXJlY3Rpb24gb2YgdGhlIGVsZW1lbnQgaXMgcmlnaHQtdG8tbGVmdCBhbmQgaWYgdGhlcmUgaXMgYW4gb3ZlcmZsb3cgY2F1c2luZyBhIGxlZnQgdmVydGljYWwgc2Nyb2xsYmFyIHRvIGJlIHJlbmRlcmVkLiBjbGllbnRMZWZ0IGRvZXMgbm90IGluY2x1ZGUgdGhlIGxlZnQgbWFyZ2luIG9yIHRoZSBsZWZ0IHBhZGRpbmcuIGNsaWVudExlZnQgaXMgcmVhZC1vbmx5LlwiXG4gICAgICB9LFxuICAgICAgXCJjbGllbnRIZWlnaHRcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2VsZW1lbnQuY2xpZW50SGVpZ2h0XCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIGlubmVyIGhlaWdodCBvZiBhbiBlbGVtZW50IGluIHBpeGVscywgaW5jbHVkaW5nIHBhZGRpbmcgYnV0IG5vdCB0aGUgaG9yaXpvbnRhbCBzY3JvbGxiYXIgaGVpZ2h0LCBib3JkZXIsIG9yIG1hcmdpbi5cIlxuICAgICAgfSxcbiAgICAgIFwiY2xpZW50V2lkdGhcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2VsZW1lbnQuY2xpZW50V2lkdGhcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiVGhlIGlubmVyIHdpZHRoIG9mIGFuIGVsZW1lbnQgaW4gcGl4ZWxzLiBJdCBpbmNsdWRlcyBwYWRkaW5nIGJ1dCBub3QgdGhlIHZlcnRpY2FsIHNjcm9sbGJhciAoaWYgcHJlc2VudCwgaWYgcmVuZGVyZWQpLCBib3JkZXIgb3IgbWFyZ2luLlwiXG4gICAgICB9LFxuICAgICAgXCJpbm5lckhUTUxcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2VsZW1lbnQuaW5uZXJIVE1MXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlNldHMgb3IgZ2V0cyB0aGUgSFRNTCBzeW50YXggZGVzY3JpYmluZyB0aGUgZWxlbWVudCdzIGRlc2NlbmRhbnRzLlwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9FbGVtZW50XCIsXG4gICAgXCIhZG9jXCI6IFwiUmVwcmVzZW50cyBhbiBlbGVtZW50IGluIGFuIEhUTUwgb3IgWE1MIGRvY3VtZW50LlwiXG4gIH0sXG4gIFwiVGV4dFwiOiB7XG4gICAgXCIhdHlwZVwiOiBcImZuKClcIixcbiAgICBcInByb3RvdHlwZVwiOiB7XG4gICAgICBcIiFwcm90b1wiOiBcIk5vZGUucHJvdG90eXBlXCIsXG4gICAgICBcIndob2xlVGV4dFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vVGV4dC53aG9sZVRleHRcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyBhbGwgdGV4dCBvZiBhbGwgVGV4dCBub2RlcyBsb2dpY2FsbHkgYWRqYWNlbnQgdG8gdGhlIG5vZGUuICBUaGUgdGV4dCBpcyBjb25jYXRlbmF0ZWQgaW4gZG9jdW1lbnQgb3JkZXIuICBUaGlzIGFsbG93cyB5b3UgdG8gc3BlY2lmeSBhbnkgdGV4dCBub2RlIGFuZCBvYnRhaW4gYWxsIGFkamFjZW50IHRleHQgYXMgYSBzaW5nbGUgc3RyaW5nLlwiXG4gICAgICB9LFxuICAgICAgXCJzcGxpdFRleHRcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4ob2Zmc2V0OiBudW1iZXIpIC0+ICtUZXh0XCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL1RleHQuc3BsaXRUZXh0XCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIkJyZWFrcyB0aGUgVGV4dCBub2RlIGludG8gdHdvIG5vZGVzIGF0IHRoZSBzcGVjaWZpZWQgb2Zmc2V0LCBrZWVwaW5nIGJvdGggbm9kZXMgaW4gdGhlIHRyZWUgYXMgc2libGluZ3MuXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL1RleHRcIixcbiAgICBcIiFkb2NcIjogXCJJbiB0aGUgRE9NLCB0aGUgVGV4dCBpbnRlcmZhY2UgcmVwcmVzZW50cyB0aGUgdGV4dHVhbCBjb250ZW50IG9mIGFuIEVsZW1lbnQgb3IgQXR0ci4gIElmIGFuIGVsZW1lbnQgaGFzIG5vIG1hcmt1cCB3aXRoaW4gaXRzIGNvbnRlbnQsIGl0IGhhcyBhIHNpbmdsZSBjaGlsZCBpbXBsZW1lbnRpbmcgVGV4dCB0aGF0IGNvbnRhaW5zIHRoZSBlbGVtZW50J3MgdGV4dC4gIEhvd2V2ZXIsIGlmIHRoZSBlbGVtZW50IGNvbnRhaW5zIG1hcmt1cCwgaXQgaXMgcGFyc2VkIGludG8gaW5mb3JtYXRpb24gaXRlbXMgYW5kIFRleHQgbm9kZXMgdGhhdCBmb3JtIGl0cyBjaGlsZHJlbi5cIlxuICB9LFxuICBcIkRvY3VtZW50XCI6IHtcbiAgICBcIiF0eXBlXCI6IFwiZm4oKVwiLFxuICAgIFwicHJvdG90eXBlXCI6IHtcbiAgICAgIFwiIXByb3RvXCI6IFwiTm9kZS5wcm90b3R5cGVcIixcbiAgICAgIFwiYWN0aXZlRWxlbWVudFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCIrRWxlbWVudFwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9kb2N1bWVudC5hY3RpdmVFbGVtZW50XCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIGN1cnJlbnRseSBmb2N1c2VkIGVsZW1lbnQsIHRoYXQgaXMsIHRoZSBlbGVtZW50IHRoYXQgd2lsbCBnZXQga2V5c3Ryb2tlIGV2ZW50cyBpZiB0aGUgdXNlciB0eXBlcyBhbnkuIFRoaXMgYXR0cmlidXRlIGlzIHJlYWQgb25seS5cIlxuICAgICAgfSxcbiAgICAgIFwiY29tcGF0TW9kZVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZG9jdW1lbnQuY29tcGF0TW9kZVwiLFxuICAgICAgICBcIiFkb2NcIjogXCJJbmRpY2F0ZXMgd2hldGhlciB0aGUgZG9jdW1lbnQgaXMgcmVuZGVyZWQgaW4gUXVpcmtzIG1vZGUgb3IgU3RyaWN0IG1vZGUuXCJcbiAgICAgIH0sXG4gICAgICBcImRlc2lnbk1vZGVcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2RvY3VtZW50LmRlc2lnbk1vZGVcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiQ2FuIGJlIHVzZWQgdG8gbWFrZSBhbnkgZG9jdW1lbnQgZWRpdGFibGUsIGZvciBleGFtcGxlIGluIGEgPGlmcmFtZSAvPjpcIlxuICAgICAgfSxcbiAgICAgIFwiZGlyXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9Eb2N1bWVudC5kaXJcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiVGhpcyBwcm9wZXJ0eSBzaG91bGQgaW5kaWNhdGUgYW5kIGFsbG93IHRoZSBzZXR0aW5nIG9mIHRoZSBkaXJlY3Rpb25hbGl0eSBvZiB0aGUgdGV4dCBvZiB0aGUgZG9jdW1lbnQsIHdoZXRoZXIgbGVmdCB0byByaWdodCAoZGVmYXVsdCkgb3IgcmlnaHQgdG8gbGVmdC5cIlxuICAgICAgfSxcbiAgICAgIFwiaGVpZ2h0XCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9kb2N1bWVudC5oZWlnaHRcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgaGVpZ2h0IG9mIHRoZSA8Ym9keT4gZWxlbWVudCBvZiB0aGUgY3VycmVudCBkb2N1bWVudC5cIlxuICAgICAgfSxcbiAgICAgIFwid2lkdGhcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2RvY3VtZW50LndpZHRoXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSA8Ym9keT4gZWxlbWVudCBvZiB0aGUgY3VycmVudCBkb2N1bWVudCBpbiBwaXhlbHMuXCJcbiAgICAgIH0sXG4gICAgICBcImNoYXJhY3RlclNldFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZG9jdW1lbnQuY2hhcmFjdGVyU2V0XCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIGNoYXJhY3RlciBlbmNvZGluZyBvZiB0aGUgY3VycmVudCBkb2N1bWVudC5cIlxuICAgICAgfSxcbiAgICAgIFwicmVhZHlTdGF0ZVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZG9jdW1lbnQucmVhZHlTdGF0ZVwiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIFxcXCJsb2FkaW5nXFxcIiB3aGlsZSB0aGUgZG9jdW1lbnQgaXMgbG9hZGluZywgXFxcImludGVyYWN0aXZlXFxcIiBvbmNlIGl0IGlzIGZpbmlzaGVkIHBhcnNpbmcgYnV0IHN0aWxsIGxvYWRpbmcgc3ViLXJlc291cmNlcywgYW5kIFxcXCJjb21wbGV0ZVxcXCIgb25jZSBpdCBoYXMgbG9hZGVkLlwiXG4gICAgICB9LFxuICAgICAgXCJsb2NhdGlvblwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJsb2NhdGlvblwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9kb2N1bWVudC5sb2NhdGlvblwiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIGEgTG9jYXRpb24gb2JqZWN0LCB3aGljaCBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgVVJMIG9mIHRoZSBkb2N1bWVudCBhbmQgcHJvdmlkZXMgbWV0aG9kcyBmb3IgY2hhbmdpbmcgdGhhdCBVUkwuXCJcbiAgICAgIH0sXG4gICAgICBcImxhc3RNb2RpZmllZFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZG9jdW1lbnQubGFzdE1vZGlmaWVkXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgYSBzdHJpbmcgY29udGFpbmluZyB0aGUgZGF0ZSBhbmQgdGltZSBvbiB3aGljaCB0aGUgY3VycmVudCBkb2N1bWVudCB3YXMgbGFzdCBtb2RpZmllZC5cIlxuICAgICAgfSxcbiAgICAgIFwiaGVhZFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCIrRWxlbWVudFwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9kb2N1bWVudC5oZWFkXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIDxoZWFkPiBlbGVtZW50IG9mIHRoZSBjdXJyZW50IGRvY3VtZW50LiBJZiB0aGVyZSBhcmUgbW9yZSB0aGFuIG9uZSA8aGVhZD4gZWxlbWVudHMsIHRoZSBmaXJzdCBvbmUgaXMgcmV0dXJuZWQuXCJcbiAgICAgIH0sXG4gICAgICBcImJvZHlcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiK0VsZW1lbnRcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZG9jdW1lbnQuYm9keVwiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIHRoZSA8Ym9keT4gb3IgPGZyYW1lc2V0PiBub2RlIG9mIHRoZSBjdXJyZW50IGRvY3VtZW50LlwiXG4gICAgICB9LFxuICAgICAgXCJjb29raWVcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2RvY3VtZW50LmNvb2tpZVwiLFxuICAgICAgICBcIiFkb2NcIjogXCJHZXQgYW5kIHNldCB0aGUgY29va2llcyBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnQgZG9jdW1lbnQuXCJcbiAgICAgIH0sXG4gICAgICBcIlVSTFwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb21haW5cIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2RvY3VtZW50LmRvbWFpblwiLFxuICAgICAgICBcIiFkb2NcIjogXCJHZXRzL3NldHMgdGhlIGRvbWFpbiBwb3J0aW9uIG9mIHRoZSBvcmlnaW4gb2YgdGhlIGN1cnJlbnQgZG9jdW1lbnQsIGFzIHVzZWQgYnkgdGhlIHNhbWUgb3JpZ2luIHBvbGljeS5cIlxuICAgICAgfSxcbiAgICAgIFwicmVmZXJyZXJcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2RvY3VtZW50LnJlZmVycmVyXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIFVSSSBvZiB0aGUgcGFnZSB0aGF0IGxpbmtlZCB0byB0aGlzIHBhZ2UuXCJcbiAgICAgIH0sXG4gICAgICBcInRpdGxlXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9kb2N1bWVudC50aXRsZVwiLFxuICAgICAgICBcIiFkb2NcIjogXCJHZXRzIG9yIHNldHMgdGhlIHRpdGxlIG9mIHRoZSBkb2N1bWVudC5cIlxuICAgICAgfSxcbiAgICAgIFwiZGVmYXVsdFZpZXdcIjoge1xuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9kb2N1bWVudC5kZWZhdWx0Vmlld1wiLFxuICAgICAgICBcIiFkb2NcIjogXCJJbiBicm93c2VycyByZXR1cm5zIHRoZSB3aW5kb3cgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGUgZG9jdW1lbnQgb3IgbnVsbCBpZiBub25lIGF2YWlsYWJsZS5cIlxuICAgICAgfSxcbiAgICAgIFwiZG9jdW1lbnRVUklcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2RvY3VtZW50LmRvY3VtZW50VVJJXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIGRvY3VtZW50IGxvY2F0aW9uIGFzIHN0cmluZy4gSXQgaXMgcmVhZC1vbmx5IHBlciBET000IHNwZWNpZmljYXRpb24uXCJcbiAgICAgIH0sXG4gICAgICBcInhtbFN0YW5kYWxvbmVcIjogXCJib29sXCIsXG4gICAgICBcInhtbFZlcnNpb25cIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2RvY3VtZW50LnhtbFZlcnNpb25cIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgdmVyc2lvbiBudW1iZXIgYXMgc3BlY2lmaWVkIGluIHRoZSBYTUwgZGVjbGFyYXRpb24gKGUuZy4sIDw/eG1sIHZlcnNpb249XFxcIjEuMFxcXCI/Pikgb3IgXFxcIjEuMFxcXCIgaWYgdGhlIGRlY2xhcmF0aW9uIGlzIGFic2VudC5cIlxuICAgICAgfSxcbiAgICAgIFwieG1sRW5jb2RpbmdcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL0RvY3VtZW50LnhtbEVuY29kaW5nXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIGVuY29kaW5nIGFzIGRldGVybWluZWQgYnkgdGhlIFhNTCBkZWNsYXJhdGlvbi4gU2hvdWxkIGJlIG51bGwgaWYgdW5zcGVjaWZpZWQgb3IgdW5rbm93bi5cIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRFbmNvZGluZ1wiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZG9jdW1lbnQuaW5wdXRFbmNvZGluZ1wiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZW5jb2RpbmcgdW5kZXIgd2hpY2ggdGhlIGRvY3VtZW50IHdhcyBwYXJzZWQgKGUuZy4gSVNPLTg4NTktMSkuXCJcbiAgICAgIH0sXG4gICAgICBcImRvY3VtZW50RWxlbWVudFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCIrRWxlbWVudFwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmVhZC1vbmx5XCJcbiAgICAgIH0sXG4gICAgICBcImltcGxlbWVudGF0aW9uXCI6IHtcbiAgICAgICAgXCJoYXNGZWF0dXJlXCI6IFwiZm4oZmVhdHVyZTogc3RyaW5nLCB2ZXJzaW9uOiBudW1iZXIpIC0+IGJvb2xcIixcbiAgICAgICAgXCJjcmVhdGVEb2N1bWVudFR5cGVcIjoge1xuICAgICAgICAgIFwiIXR5cGVcIjogXCJmbihxdWFsaWZpZWROYW1lOiBzdHJpbmcsIHB1YmxpY0lkOiBzdHJpbmcsIHN5c3RlbUlkOiBzdHJpbmcpIC0+ICtOb2RlXCIsXG4gICAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vRE9NSW1wbGVtZW50YXRpb24uY3JlYXRlRG9jdW1lbnRUeXBlXCIsXG4gICAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyBhIERvY3VtZW50VHlwZSBvYmplY3Qgd2hpY2ggY2FuIGVpdGhlciBiZSB1c2VkIHdpdGggRE9NSW1wbGVtZW50YXRpb24uY3JlYXRlRG9jdW1lbnQgdXBvbiBkb2N1bWVudCBjcmVhdGlvbiBvciB0aGV5IGNhbiBiZSBwdXQgaW50byB0aGUgZG9jdW1lbnQgdmlhIE5vZGUuaW5zZXJ0QmVmb3JlKCkgb3IgTm9kZS5yZXBsYWNlQ2hpbGQoKTogaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtQ29yLi4ubCNJRC1CNjNFRDFBMzEgKGxlc3MgaWRlYWwgZHVlIHRvIGZlYXR1cmVzIG5vdCBsaWtlbHkgYmVpbmcgYXMgYWNjZXNzaWJsZTogaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtQ29yLi4uY3JlYXRlRG9jdW1lbnQgKS4gSW4gYW55IGNhc2UsIGVudGl0eSBkZWNsYXJhdGlvbnMgYW5kIG5vdGF0aW9ucyB3aWxsIG5vdCBiZSBhdmFpbGFibGU6IGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUNvci4uLi1jcmVhdGVEb2NUeXBlICAgXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjcmVhdGVIVE1MRG9jdW1lbnRcIjoge1xuICAgICAgICAgIFwiIXR5cGVcIjogXCJmbih0aXRsZTogc3RyaW5nKSAtPiArRG9jdW1lbnRcIixcbiAgICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9ET01JbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnRcIixcbiAgICAgICAgICBcIiFkb2NcIjogXCJUaGlzIG1ldGhvZCAoYXZhaWxhYmxlIGZyb20gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24pIGNyZWF0ZXMgYSBuZXcgSFRNTCBkb2N1bWVudC5cIlxuICAgICAgICB9LFxuICAgICAgICBcImNyZWF0ZURvY3VtZW50XCI6IHtcbiAgICAgICAgICBcIiF0eXBlXCI6IFwiZm4obmFtZXNwYWNlVVJJOiBzdHJpbmcsIHF1YWxpZmllZE5hbWU6IHN0cmluZywgdHlwZTogK05vZGUpIC0+ICtEb2N1bWVudFwiLFxuICAgICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvRE9NL0RPTUltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudFwiLFxuICAgICAgICAgIFwiIWRvY1wiOiBcIlRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBuZXcgSFRNTCBkb2N1bWVudC5cIlxuICAgICAgICB9LFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9kb2N1bWVudC5pbXBsZW1lbnRhdGlvblwiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIGEgRE9NSW1wbGVtZW50YXRpb24gb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGUgY3VycmVudCBkb2N1bWVudC5cIlxuICAgICAgfSxcbiAgICAgIFwiZG9jdHlwZVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCIrTm9kZVwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9kb2N1bWVudC5kb2N0eXBlXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIERvY3VtZW50IFR5cGUgRGVjbGFyYXRpb24gKERURCkgYXNzb2NpYXRlZCB3aXRoIGN1cnJlbnQgZG9jdW1lbnQuIFRoZSByZXR1cm5lZCBvYmplY3QgaW1wbGVtZW50cyB0aGUgRG9jdW1lbnRUeXBlIGludGVyZmFjZS4gVXNlIERPTUltcGxlbWVudGF0aW9uLmNyZWF0ZURvY3VtZW50VHlwZSgpIHRvIGNyZWF0ZSBhIERvY3VtZW50VHlwZS5cIlxuICAgICAgfSxcbiAgICAgIFwib3BlblwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbigpXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2RvY3VtZW50Lm9wZW5cIixcbiAgICAgICAgXCIhZG9jXCI6IFwiVGhlIGRvY3VtZW50Lm9wZW4oKSBtZXRob2Qgb3BlbnMgYSBkb2N1bWVudCBmb3Igd3JpdGluZy5cIlxuICAgICAgfSxcbiAgICAgIFwiY2xvc2VcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oKVwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9kb2N1bWVudC5jbG9zZVwiLFxuICAgICAgICBcIiFkb2NcIjogXCJUaGUgZG9jdW1lbnQuY2xvc2UoKSBtZXRob2QgZmluaXNoZXMgd3JpdGluZyB0byBhIGRvY3VtZW50LCBvcGVuZWQgd2l0aCBkb2N1bWVudC5vcGVuKCkuXCJcbiAgICAgIH0sXG4gICAgICBcIndyaXRlXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKGh0bWw6IHN0cmluZylcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZG9jdW1lbnQud3JpdGVcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiV3JpdGVzIGEgc3RyaW5nIG9mIHRleHQgdG8gYSBkb2N1bWVudCBzdHJlYW0gb3BlbmVkIGJ5IGRvY3VtZW50Lm9wZW4oKS5cIlxuICAgICAgfSxcbiAgICAgIFwid3JpdGVsblwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihodG1sOiBzdHJpbmcpXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2RvY3VtZW50LndyaXRlbG5cIixcbiAgICAgICAgXCIhZG9jXCI6IFwiV3JpdGVzIGEgc3RyaW5nIG9mIHRleHQgZm9sbG93ZWQgYnkgYSBuZXdsaW5lIGNoYXJhY3RlciB0byBhIGRvY3VtZW50LlwiXG4gICAgICB9LFxuICAgICAgXCJjbGVhclwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbigpXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2RvY3VtZW50LmNsZWFyXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIkluIHJlY2VudCB2ZXJzaW9ucyBvZiBNb3ppbGxhLWJhc2VkIGFwcGxpY2F0aW9ucyBhcyB3ZWxsIGFzIGluIEludGVybmV0IEV4cGxvcmVyIGFuZCBOZXRzY2FwZSA0IHRoaXMgbWV0aG9kIGRvZXMgbm90aGluZy5cIlxuICAgICAgfSxcbiAgICAgIFwiaGFzRm9jdXNcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oKSAtPiBib29sXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2RvY3VtZW50Lmhhc0ZvY3VzXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgYSBCb29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgZG9jdW1lbnQgb3IgYW55IGVsZW1lbnQgaW5zaWRlIHRoZSBkb2N1bWVudCBoYXMgZm9jdXMuIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBhY3RpdmUgZWxlbWVudCBpbiBhIGRvY3VtZW50IGhhcyBmb2N1cy5cIlxuICAgICAgfSxcbiAgICAgIFwiY3JlYXRlRWxlbWVudFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbih0YWdOYW1lOiBzdHJpbmcpIC0+ICtFbGVtZW50XCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2RvY3VtZW50LmNyZWF0ZUVsZW1lbnRcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiQ3JlYXRlcyB0aGUgc3BlY2lmaWVkIGVsZW1lbnQuXCJcbiAgICAgIH0sXG4gICAgICBcImNyZWF0ZUVsZW1lbnROU1wiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihuczogc3RyaW5nLCB0YWdOYW1lOiBzdHJpbmcpIC0+ICtFbGVtZW50XCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROU1wiLFxuICAgICAgICBcIiFkb2NcIjogXCJDcmVhdGVzIGFuIGVsZW1lbnQgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWVzcGFjZSBVUkkgYW5kIHF1YWxpZmllZCBuYW1lLlwiXG4gICAgICB9LFxuICAgICAgXCJjcmVhdGVEb2N1bWVudEZyYWdtZW50XCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKCkgLT4gK0RvY3VtZW50RnJhZ21lbnRcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJDcmVhdGVzIGEgbmV3IGVtcHR5IERvY3VtZW50RnJhZ21lbnQuXCJcbiAgICAgIH0sXG4gICAgICBcImNyZWF0ZVRleHROb2RlXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKGNvbnRlbnQ6IHN0cmluZykgLT4gK1RleHRcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGVcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiQ3JlYXRlcyBhIG5ldyBUZXh0IG5vZGUuXCJcbiAgICAgIH0sXG4gICAgICBcImNyZWF0ZUNvbW1lbnRcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oY29udGVudDogc3RyaW5nKSAtPiArTm9kZVwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9kb2N1bWVudC5jcmVhdGVDb21tZW50XCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIkNyZWF0ZXMgYSBuZXcgY29tbWVudCBub2RlLCBhbmQgcmV0dXJucyBpdC5cIlxuICAgICAgfSxcbiAgICAgIFwiY3JlYXRlQ0RBVEFTZWN0aW9uXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKGNvbnRlbnQ6IHN0cmluZykgLT4gK05vZGVcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZG9jdW1lbnQuY3JlYXRlQ0RBVEFTZWN0aW9uXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIkNyZWF0ZXMgYSBuZXcgQ0RBVEEgc2VjdGlvbiBub2RlLCBhbmQgcmV0dXJucyBpdC4gXCJcbiAgICAgIH0sXG4gICAgICBcImNyZWF0ZVByb2Nlc3NpbmdJbnN0cnVjdGlvblwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihjb250ZW50OiBzdHJpbmcpIC0+ICtOb2RlXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2RvY3VtZW50LmNyZWF0ZVByb2Nlc3NpbmdJbnN0cnVjdGlvblwiLFxuICAgICAgICBcIiFkb2NcIjogXCJDcmVhdGVzIGEgbmV3IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbm9kZSwgYW5kIHJldHVybnMgaXQuXCJcbiAgICAgIH0sXG4gICAgICBcImNyZWF0ZUF0dHJpYnV0ZVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihuYW1lOiBzdHJpbmcpIC0+ICtBdHRyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2RvY3VtZW50LmNyZWF0ZUF0dHJpYnV0ZVwiLFxuICAgICAgICBcIiFkb2NcIjogXCJDcmVhdGVzIGEgbmV3IGF0dHJpYnV0ZSBub2RlLCBhbmQgcmV0dXJucyBpdC5cIlxuICAgICAgfSxcbiAgICAgIFwiY3JlYXRlQXR0cmlidXRlTlNcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4obnM6IHN0cmluZywgbmFtZTogc3RyaW5nKSAtPiArQXR0clwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9BdHRyXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlRoaXMgdHlwZSByZXByZXNlbnRzIGEgRE9NIGVsZW1lbnQncyBhdHRyaWJ1dGUgYXMgYW4gb2JqZWN0LiBJbiBtb3N0IERPTSBtZXRob2RzLCB5b3Ugd2lsbCBwcm9iYWJseSBkaXJlY3RseSByZXRyaWV2ZSB0aGUgYXR0cmlidXRlIGFzIGEgc3RyaW5nIChlLmcuLCBFbGVtZW50LmdldEF0dHJpYnV0ZSgpLCBidXQgY2VydGFpbiBmdW5jdGlvbnMgKGUuZy4sIEVsZW1lbnQuZ2V0QXR0cmlidXRlTm9kZSgpKSBvciBtZWFucyBvZiBpdGVyYXRpbmcgZ2l2ZSBBdHRyIHR5cGVzLlwiXG4gICAgICB9LFxuICAgICAgXCJpbXBvcnROb2RlXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKG5vZGU6ICtOb2RlLCBkZWVwOiBib29sKSAtPiArRWxlbWVudFwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9kb2N1bWVudC5pbXBvcnROb2RlXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIkNyZWF0ZXMgYSBjb3B5IG9mIGEgbm9kZSBmcm9tIGFuIGV4dGVybmFsIGRvY3VtZW50IHRoYXQgY2FuIGJlIGluc2VydGVkIGludG8gdGhlIGN1cnJlbnQgZG9jdW1lbnQuXCJcbiAgICAgIH0sXG4gICAgICBcImdldEVsZW1lbnRCeUlkXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKGlkOiBzdHJpbmcpIC0+ICtFbGVtZW50XCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2RvY3VtZW50LmdldEVsZW1lbnRCeUlkXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQgYnkgaXRzIElELlwiXG4gICAgICB9LFxuICAgICAgXCJnZXRFbGVtZW50c0J5VGFnTmFtZVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbih0YWdOYW1lOiBzdHJpbmcpIC0+ICtOb2RlTGlzdFwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZVwiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIGEgTm9kZUxpc3Qgb2YgZWxlbWVudHMgd2l0aCB0aGUgZ2l2ZW4gdGFnIG5hbWUuIFRoZSBjb21wbGV0ZSBkb2N1bWVudCBpcyBzZWFyY2hlZCwgaW5jbHVkaW5nIHRoZSByb290IG5vZGUuIFRoZSByZXR1cm5lZCBOb2RlTGlzdCBpcyBsaXZlLCBtZWFuaW5nIHRoYXQgaXQgdXBkYXRlcyBpdHNlbGYgYXV0b21hdGljYWxseSB0byBzdGF5IGluIHN5bmMgd2l0aCB0aGUgRE9NIHRyZWUgd2l0aG91dCBoYXZpbmcgdG8gY2FsbCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSBhZ2Fpbi5cIlxuICAgICAgfSxcbiAgICAgIFwiZ2V0RWxlbWVudHNCeVRhZ05hbWVOU1wiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihuczogc3RyaW5nLCB0YWdOYW1lOiBzdHJpbmcpIC0+ICtOb2RlTGlzdFwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZU5TXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgYSBsaXN0IG9mIGVsZW1lbnRzIHdpdGggdGhlIGdpdmVuIHRhZyBuYW1lIGJlbG9uZ2luZyB0byB0aGUgZ2l2ZW4gbmFtZXNwYWNlLiBUaGUgY29tcGxldGUgZG9jdW1lbnQgaXMgc2VhcmNoZWQsIGluY2x1ZGluZyB0aGUgcm9vdCBub2RlLlwiXG4gICAgICB9LFxuICAgICAgXCJjcmVhdGVFdmVudFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbih0eXBlOiBzdHJpbmcpIC0+ICtFdmVudFwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9kb2N1bWVudC5jcmVhdGVFdmVudFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJDcmVhdGVzIGFuIGV2ZW50IG9mIHRoZSB0eXBlIHNwZWNpZmllZC4gVGhlIHJldHVybmVkIG9iamVjdCBzaG91bGQgYmUgZmlyc3QgaW5pdGlhbGl6ZWQgYW5kIGNhbiB0aGVuIGJlIHBhc3NlZCB0byBlbGVtZW50LmRpc3BhdGNoRXZlbnQuXCJcbiAgICAgIH0sXG4gICAgICBcImNyZWF0ZVJhbmdlXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKCkgLT4gK1JhbmdlXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2RvY3VtZW50LmNyZWF0ZVJhbmdlXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgYSBuZXcgUmFuZ2Ugb2JqZWN0LlwiXG4gICAgICB9LFxuICAgICAgXCJldmFsdWF0ZVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihleHByOiA/KSAtPiArWFBhdGhSZXN1bHRcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZG9jdW1lbnQuZXZhbHVhdGVcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyBhbiBYUGF0aFJlc3VsdCBiYXNlZCBvbiBhbiBYUGF0aCBleHByZXNzaW9uIGFuZCBvdGhlciBnaXZlbiBwYXJhbWV0ZXJzLlwiXG4gICAgICB9LFxuICAgICAgXCJleGVjQ29tbWFuZFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihjbWQ6IHN0cmluZylcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9SaWNoLVRleHRfRWRpdGluZ19pbl9Nb3ppbGxhI0V4ZWN1dGluZ19Db21tYW5kc1wiLFxuICAgICAgICBcIiFkb2NcIjogXCJSdW4gY29tbWFuZCB0byBtYW5pcHVsYXRlIHRoZSBjb250ZW50cyBvZiBhbiBlZGl0YWJsZSByZWdpb24uXCJcbiAgICAgIH0sXG4gICAgICBcInF1ZXJ5Q29tbWFuZEVuYWJsZWRcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oY21kOiBzdHJpbmcpIC0+IGJvb2xcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZG9jdW1lbnRcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0cnVlIGlmIHRoZSBNaWRhcyBjb21tYW5kIGNhbiBiZSBleGVjdXRlZCBvbiB0aGUgY3VycmVudCByYW5nZS5cIlxuICAgICAgfSxcbiAgICAgIFwicXVlcnlDb21tYW5kSW5kZXRlcm1cIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oY21kOiBzdHJpbmcpIC0+IGJvb2xcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZG9jdW1lbnRcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0cnVlIGlmIHRoZSBNaWRhcyBjb21tYW5kIGlzIGluIGEgaW5kZXRlcm1pbmF0ZSBzdGF0ZSBvbiB0aGUgY3VycmVudCByYW5nZS5cIlxuICAgICAgfSxcbiAgICAgIFwicXVlcnlDb21tYW5kU3RhdGVcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oY21kOiBzdHJpbmcpIC0+IGJvb2xcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZG9jdW1lbnRcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0cnVlIGlmIHRoZSBNaWRhcyBjb21tYW5kIGhhcyBiZWVuIGV4ZWN1dGVkIG9uIHRoZSBjdXJyZW50IHJhbmdlLlwiXG4gICAgICB9LFxuICAgICAgXCJxdWVyeUNvbW1hbmRTdXBwb3J0ZWRcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oY21kOiBzdHJpbmcpIC0+IGJvb2xcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZG9jdW1lbnQucXVlcnlDb21tYW5kU3VwcG9ydGVkXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJlcG9ydHMgd2hldGhlciBvciBub3QgdGhlIHNwZWNpZmllZCBlZGl0b3IgcXVlcnkgY29tbWFuZCBpcyBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIuXCJcbiAgICAgIH0sXG4gICAgICBcInF1ZXJ5Q29tbWFuZFZhbHVlXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKGNtZDogc3RyaW5nKSAtPiBzdHJpbmdcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZG9jdW1lbnRcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgY3VycmVudCByYW5nZSBmb3IgTWlkYXMgY29tbWFuZC5cIlxuICAgICAgfSxcbiAgICAgIFwiZ2V0RWxlbWVudHNCeU5hbWVcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4obmFtZTogc3RyaW5nKSAtPiArSFRNTENvbGxlY3Rpb25cIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWVcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyBhIGxpc3Qgb2YgZWxlbWVudHMgd2l0aCBhIGdpdmVuIG5hbWUgaW4gdGhlIEhUTUwgZG9jdW1lbnQuXCJcbiAgICAgIH0sXG4gICAgICBcImVsZW1lbnRGcm9tUG9pbnRcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oeDogbnVtYmVyLCB5OiBudW1iZXIpIC0+ICtFbGVtZW50XCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2RvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnRcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgZWxlbWVudCBmcm9tIHRoZSBkb2N1bWVudCB3aG9zZSBlbGVtZW50RnJvbVBvaW50IG1ldGhvZCBpcyBiZWluZyBjYWxsZWQgd2hpY2ggaXMgdGhlIHRvcG1vc3QgZWxlbWVudCB3aGljaCBsaWVzIHVuZGVyIHRoZSBnaXZlbiBwb2ludC4gIFRvIGdldCBhbiBlbGVtZW50LCBzcGVjaWZ5IHRoZSBwb2ludCB2aWEgY29vcmRpbmF0ZXMsIGluIENTUyBwaXhlbHMsIHJlbGF0aXZlIHRvIHRoZSB1cHBlci1sZWZ0LW1vc3QgcG9pbnQgaW4gdGhlIHdpbmRvdyBvciBmcmFtZSBjb250YWluaW5nIHRoZSBkb2N1bWVudC5cIlxuICAgICAgfSxcbiAgICAgIFwiZ2V0U2VsZWN0aW9uXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKCkgLT4gK1NlbGVjdGlvblwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9kb2N1bWVudC5nZXRTZWxlY3Rpb25cIixcbiAgICAgICAgXCIhZG9jXCI6IFwiVGhlIERPTSBnZXRTZWxlY3Rpb24oKSBtZXRob2QgaXMgYXZhaWxhYmxlIG9uIHRoZSBXaW5kb3cgYW5kIERvY3VtZW50IGludGVyZmFjZXMuXCJcbiAgICAgIH0sXG4gICAgICBcImFkb3B0Tm9kZVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihub2RlOiArTm9kZSkgLT4gK0VsZW1lbnRcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZG9jdW1lbnQuYWRvcHROb2RlXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIkFkb3B0cyBhIG5vZGUgZnJvbSBhbiBleHRlcm5hbCBkb2N1bWVudC4gVGhlIG5vZGUgYW5kIGl0cyBzdWJ0cmVlIGlzIHJlbW92ZWQgZnJvbSB0aGUgZG9jdW1lbnQgaXQncyBpbiAoaWYgYW55KSwgYW5kIGl0cyBvd25lckRvY3VtZW50IGlzIGNoYW5nZWQgdG8gdGhlIGN1cnJlbnQgZG9jdW1lbnQuIFRoZSBub2RlIGNhbiB0aGVuIGJlIGluc2VydGVkIGludG8gdGhlIGN1cnJlbnQgZG9jdW1lbnQuXCJcbiAgICAgIH0sXG4gICAgICBcImNyZWF0ZVRyZWVXYWxrZXJcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4ocm9vdDogK05vZGUsIG1hc2s6IG51bWJlcikgLT4gP1wiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9kb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgYSBuZXcgVHJlZVdhbGtlciBvYmplY3QuXCJcbiAgICAgIH0sXG4gICAgICBcImNyZWF0ZUV4cHJlc3Npb25cIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4odGV4dDogc3RyaW5nKSAtPiA/XCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2RvY3VtZW50LmNyZWF0ZUV4cHJlc3Npb25cIixcbiAgICAgICAgXCIhZG9jXCI6IFwiVGhpcyBtZXRob2QgY29tcGlsZXMgYW4gWFBhdGhFeHByZXNzaW9uIHdoaWNoIGNhbiB0aGVuIGJlIHVzZWQgZm9yIChyZXBlYXRlZCkgZXZhbHVhdGlvbnMuXCJcbiAgICAgIH0sXG4gICAgICBcImNyZWF0ZU5TUmVzb2x2ZXJcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4obm9kZTogK05vZGUpXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2RvY3VtZW50LmNyZWF0ZU5TUmVzb2x2ZXJcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiQ3JlYXRlcyBhbiBYUGF0aE5TUmVzb2x2ZXIgd2hpY2ggcmVzb2x2ZXMgbmFtZXNwYWNlcyB3aXRoIHJlc3BlY3QgdG8gdGhlIGRlZmluaXRpb25zIGluIHNjb3BlIGZvciBhIHNwZWNpZmllZCBub2RlLlwiXG4gICAgICB9LFxuICAgICAgXCJzY3JpcHRzXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIitIVE1MQ29sbGVjdGlvblwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9Eb2N1bWVudC5zY3JpcHRzXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgYSBsaXN0IG9mIHRoZSA8c2NyaXB0PiBlbGVtZW50cyBpbiB0aGUgZG9jdW1lbnQuIFRoZSByZXR1cm5lZCBvYmplY3QgaXMgYW4gSFRNTENvbGxlY3Rpb24uXCJcbiAgICAgIH0sXG4gICAgICBcInBsdWdpbnNcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiK0hUTUxDb2xsZWN0aW9uXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2RvY3VtZW50LnBsdWdpbnNcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyBhbiBIVE1MQ29sbGVjdGlvbiBvYmplY3QgY29udGFpbmluZyBvbmUgb3IgbW9yZSBIVE1MRW1iZWRFbGVtZW50cyBvciBudWxsIHdoaWNoIHJlcHJlc2VudCB0aGUgPGVtYmVkPiBlbGVtZW50cyBpbiB0aGUgY3VycmVudCBkb2N1bWVudC5cIlxuICAgICAgfSxcbiAgICAgIFwiZW1iZWRzXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIitIVE1MQ29sbGVjdGlvblwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9kb2N1bWVudC5lbWJlZHNcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyBhIGxpc3Qgb2YgdGhlIGVtYmVkZGVkIE9CSkVDVFMgd2l0aGluIHRoZSBjdXJyZW50IGRvY3VtZW50LlwiXG4gICAgICB9LFxuICAgICAgXCJhbmNob3JzXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIitIVE1MQ29sbGVjdGlvblwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9kb2N1bWVudC5hbmNob3JzXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgYSBsaXN0IG9mIGFsbCBvZiB0aGUgYW5jaG9ycyBpbiB0aGUgZG9jdW1lbnQuXCJcbiAgICAgIH0sXG4gICAgICBcImxpbmtzXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIitIVE1MQ29sbGVjdGlvblwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9kb2N1bWVudC5saW5rc1wiLFxuICAgICAgICBcIiFkb2NcIjogXCJUaGUgbGlua3MgcHJvcGVydHkgcmV0dXJucyBhIGNvbGxlY3Rpb24gb2YgYWxsIEFSRUEgZWxlbWVudHMgYW5kIGFuY2hvciBlbGVtZW50cyBpbiBhIGRvY3VtZW50IHdpdGggYSB2YWx1ZSBmb3IgdGhlIGhyZWYgYXR0cmlidXRlLiBcIlxuICAgICAgfSxcbiAgICAgIFwiZm9ybXNcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiK0hUTUxDb2xsZWN0aW9uXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2RvY3VtZW50LmZvcm1zXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgYSBjb2xsZWN0aW9uIChhbiBIVE1MQ29sbGVjdGlvbikgb2YgdGhlIGZvcm0gZWxlbWVudHMgd2l0aGluIHRoZSBjdXJyZW50IGRvY3VtZW50LlwiXG4gICAgICB9LFxuICAgICAgXCJzdHlsZVNoZWV0c1wiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCIrSFRNTENvbGxlY3Rpb25cIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZG9jdW1lbnQuc3R5bGVTaGVldHNcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyBhIGxpc3Qgb2Ygc3R5bGVzaGVldCBvYmplY3RzIGZvciBzdHlsZXNoZWV0cyBleHBsaWNpdGx5IGxpbmtlZCBpbnRvIG9yIGVtYmVkZGVkIGluIGEgZG9jdW1lbnQuXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2RvY3VtZW50XCIsXG4gICAgXCIhZG9jXCI6IFwiRWFjaCB3ZWIgcGFnZSBsb2FkZWQgaW4gdGhlIGJyb3dzZXIgaGFzIGl0cyBvd24gZG9jdW1lbnQgb2JqZWN0LiBUaGlzIG9iamVjdCBzZXJ2ZXMgYXMgYW4gZW50cnkgcG9pbnQgdG8gdGhlIHdlYiBwYWdlJ3MgY29udGVudCAodGhlIERPTSB0cmVlLCBpbmNsdWRpbmcgZWxlbWVudHMgc3VjaCBhcyA8Ym9keT4gYW5kIDx0YWJsZT4pIGFuZCBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGdsb2JhbCB0byB0aGUgZG9jdW1lbnQgKHN1Y2ggYXMgb2J0YWluaW5nIHRoZSBwYWdlJ3MgVVJMIGFuZCBjcmVhdGluZyBuZXcgZWxlbWVudHMgaW4gdGhlIGRvY3VtZW50KS5cIlxuICB9LFxuICBcImRvY3VtZW50XCI6IHtcbiAgICBcIiF0eXBlXCI6IFwiK0RvY3VtZW50XCIsXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZG9jdW1lbnRcIixcbiAgICBcIiFkb2NcIjogXCJFYWNoIHdlYiBwYWdlIGxvYWRlZCBpbiB0aGUgYnJvd3NlciBoYXMgaXRzIG93biBkb2N1bWVudCBvYmplY3QuIFRoaXMgb2JqZWN0IHNlcnZlcyBhcyBhbiBlbnRyeSBwb2ludCB0byB0aGUgd2ViIHBhZ2UncyBjb250ZW50ICh0aGUgRE9NIHRyZWUsIGluY2x1ZGluZyBlbGVtZW50cyBzdWNoIGFzIDxib2R5PiBhbmQgPHRhYmxlPikgYW5kIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZ2xvYmFsIHRvIHRoZSBkb2N1bWVudCAoc3VjaCBhcyBvYnRhaW5pbmcgdGhlIHBhZ2UncyBVUkwgYW5kIGNyZWF0aW5nIG5ldyBlbGVtZW50cyBpbiB0aGUgZG9jdW1lbnQpLlwiXG4gIH0sXG4gIFwiWE1MRG9jdW1lbnRcIjoge1xuICAgIFwiIXR5cGVcIjogXCJmbigpXCIsXG4gICAgXCJwcm90b3R5cGVcIjogXCJEb2N1bWVudC5wcm90b3R5cGVcIixcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1BhcnNpbmdfYW5kX3NlcmlhbGl6aW5nX1hNTFwiLFxuICAgIFwiIWRvY1wiOiBcIlRoZSBXZWIgcGxhdGZvcm0gcHJvdmlkZXMgdGhlIGZvbGxvd2luZyBvYmplY3RzIGZvciBwYXJzaW5nIGFuZCBzZXJpYWxpemluZyBYTUw6XCJcbiAgfSxcbiAgXCJBdHRyXCI6IHtcbiAgICBcIiF0eXBlXCI6IFwiZm4oKVwiLFxuICAgIFwicHJvdG90eXBlXCI6IHtcbiAgICAgIFwiaXNJZFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJib29sXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL0F0dHJcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiVGhpcyB0eXBlIHJlcHJlc2VudHMgYSBET00gZWxlbWVudCdzIGF0dHJpYnV0ZSBhcyBhbiBvYmplY3QuIEluIG1vc3QgRE9NIG1ldGhvZHMsIHlvdSB3aWxsIHByb2JhYmx5IGRpcmVjdGx5IHJldHJpZXZlIHRoZSBhdHRyaWJ1dGUgYXMgYSBzdHJpbmcgKGUuZy4sIEVsZW1lbnQuZ2V0QXR0cmlidXRlKCksIGJ1dCBjZXJ0YWluIGZ1bmN0aW9ucyAoZS5nLiwgRWxlbWVudC5nZXRBdHRyaWJ1dGVOb2RlKCkpIG9yIG1lYW5zIG9mIGl0ZXJhdGluZyBnaXZlIEF0dHIgdHlwZXMuXCJcbiAgICAgIH0sXG4gICAgICBcIm5hbWVcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL0F0dHJcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiVGhpcyB0eXBlIHJlcHJlc2VudHMgYSBET00gZWxlbWVudCdzIGF0dHJpYnV0ZSBhcyBhbiBvYmplY3QuIEluIG1vc3QgRE9NIG1ldGhvZHMsIHlvdSB3aWxsIHByb2JhYmx5IGRpcmVjdGx5IHJldHJpZXZlIHRoZSBhdHRyaWJ1dGUgYXMgYSBzdHJpbmcgKGUuZy4sIEVsZW1lbnQuZ2V0QXR0cmlidXRlKCksIGJ1dCBjZXJ0YWluIGZ1bmN0aW9ucyAoZS5nLiwgRWxlbWVudC5nZXRBdHRyaWJ1dGVOb2RlKCkpIG9yIG1lYW5zIG9mIGl0ZXJhdGluZyBnaXZlIEF0dHIgdHlwZXMuXCJcbiAgICAgIH0sXG4gICAgICBcInZhbHVlXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9BdHRyXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlRoaXMgdHlwZSByZXByZXNlbnRzIGEgRE9NIGVsZW1lbnQncyBhdHRyaWJ1dGUgYXMgYW4gb2JqZWN0LiBJbiBtb3N0IERPTSBtZXRob2RzLCB5b3Ugd2lsbCBwcm9iYWJseSBkaXJlY3RseSByZXRyaWV2ZSB0aGUgYXR0cmlidXRlIGFzIGEgc3RyaW5nIChlLmcuLCBFbGVtZW50LmdldEF0dHJpYnV0ZSgpLCBidXQgY2VydGFpbiBmdW5jdGlvbnMgKGUuZy4sIEVsZW1lbnQuZ2V0QXR0cmlidXRlTm9kZSgpKSBvciBtZWFucyBvZiBpdGVyYXRpbmcgZ2l2ZSBBdHRyIHR5cGVzLlwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9BdHRyXCIsXG4gICAgXCIhZG9jXCI6IFwiVGhpcyB0eXBlIHJlcHJlc2VudHMgYSBET00gZWxlbWVudCdzIGF0dHJpYnV0ZSBhcyBhbiBvYmplY3QuIEluIG1vc3QgRE9NIG1ldGhvZHMsIHlvdSB3aWxsIHByb2JhYmx5IGRpcmVjdGx5IHJldHJpZXZlIHRoZSBhdHRyaWJ1dGUgYXMgYSBzdHJpbmcgKGUuZy4sIEVsZW1lbnQuZ2V0QXR0cmlidXRlKCksIGJ1dCBjZXJ0YWluIGZ1bmN0aW9ucyAoZS5nLiwgRWxlbWVudC5nZXRBdHRyaWJ1dGVOb2RlKCkpIG9yIG1lYW5zIG9mIGl0ZXJhdGluZyBnaXZlIEF0dHIgdHlwZXMuXCJcbiAgfSxcbiAgXCJOb2RlTGlzdFwiOiB7XG4gICAgXCIhdHlwZVwiOiBcImZuKClcIixcbiAgICBcInByb3RvdHlwZVwiOiB7XG4gICAgICBcImxlbmd0aFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZWxlbWVudC5sZW5ndGhcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgbnVtYmVyIG9mIGl0ZW1zIGluIGEgTm9kZUxpc3QuXCJcbiAgICAgIH0sXG4gICAgICBcIml0ZW1cIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oaTogbnVtYmVyKSAtPiArRWxlbWVudFwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9Ob2RlTGlzdC5pdGVtXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgYSBub2RlIGZyb20gYSBOb2RlTGlzdCBieSBpbmRleC5cIlxuICAgICAgfSxcbiAgICAgIFwiPGk+XCI6IFwiK0VsZW1lbnRcIlxuICAgIH0sXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vTm9kZUxpc3RcIixcbiAgICBcIiFkb2NcIjogXCJOb2RlTGlzdCBvYmplY3RzIGFyZSBjb2xsZWN0aW9ucyBvZiBub2RlcyByZXR1cm5lZCBieSBnZXRFbGVtZW50c0J5VGFnTmFtZSwgZ2V0RWxlbWVudHNCeVRhZ05hbWVOUywgTm9kZS5jaGlsZE5vZGVzLCBxdWVyeVNlbGVjdG9yQWxsLCBnZXRFbGVtZW50c0J5Q2xhc3NOYW1lLCBldGMuXCJcbiAgfSxcbiAgXCJIVE1MQ29sbGVjdGlvblwiOiB7XG4gICAgXCIhdHlwZVwiOiBcImZuKClcIixcbiAgICBcInByb3RvdHlwZVwiOiB7XG4gICAgICBcImxlbmd0aFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vSFRNTENvbGxlY3Rpb25cIixcbiAgICAgICAgXCIhZG9jXCI6IFwiVGhlIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgY29sbGVjdGlvbi5cIlxuICAgICAgfSxcbiAgICAgIFwiaXRlbVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihpOiBudW1iZXIpIC0+ICtFbGVtZW50XCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL0hUTUxDb2xsZWN0aW9uXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIHNwZWNpZmljIG5vZGUgYXQgdGhlIGdpdmVuIHplcm8tYmFzZWQgaW5kZXggaW50byB0aGUgbGlzdC4gUmV0dXJucyBudWxsIGlmIHRoZSBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXCJcbiAgICAgIH0sXG4gICAgICBcIm5hbWVkSXRlbVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihuYW1lOiBzdHJpbmcpIC0+ICtFbGVtZW50XCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL0hUTUxDb2xsZWN0aW9uXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIHNwZWNpZmljIG5vZGUgd2hvc2UgSUQgb3IsIGFzIGEgZmFsbGJhY2ssIG5hbWUgbWF0Y2hlcyB0aGUgc3RyaW5nIHNwZWNpZmllZCBieSBuYW1lLiBNYXRjaGluZyBieSBuYW1lIGlzIG9ubHkgZG9uZSBhcyBhIGxhc3QgcmVzb3J0LCBvbmx5IGluIEhUTUwsIGFuZCBvbmx5IGlmIHRoZSByZWZlcmVuY2VkIGVsZW1lbnQgc3VwcG9ydHMgdGhlIG5hbWUgYXR0cmlidXRlLiBSZXR1cm5zIG51bGwgaWYgbm8gbm9kZSBleGlzdHMgYnkgdGhlIGdpdmVuIG5hbWUuXCJcbiAgICAgIH0sXG4gICAgICBcIjxpPlwiOiBcIitFbGVtZW50XCJcbiAgICB9LFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL0hUTUxDb2xsZWN0aW9uXCIsXG4gICAgXCIhZG9jXCI6IFwiSFRNTENvbGxlY3Rpb24gaXMgYW4gaW50ZXJmYWNlIHJlcHJlc2VudGluZyBhIGdlbmVyaWMgY29sbGVjdGlvbiBvZiBlbGVtZW50cyAoaW4gZG9jdW1lbnQgb3JkZXIpIGFuZCBvZmZlcnMgbWV0aG9kcyBhbmQgcHJvcGVydGllcyBmb3IgdHJhdmVyc2luZyB0aGUgbGlzdC5cIlxuICB9LFxuICBcIk5hbWVkTm9kZU1hcFwiOiB7XG4gICAgXCIhdHlwZVwiOiBcImZuKClcIixcbiAgICBcInByb3RvdHlwZVwiOiB7XG4gICAgICBcImxlbmd0aFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vTmFtZWROb2RlTWFwXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlRoZSBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIG1hcC5cIlxuICAgICAgfSxcbiAgICAgIFwiZ2V0TmFtZWRJdGVtXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKG5hbWU6IHN0cmluZykgLT4gK05vZGVcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vTmFtZWROb2RlTWFwXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIkdldHMgYSBub2RlIGJ5IG5hbWUuXCJcbiAgICAgIH0sXG4gICAgICBcInNldE5hbWVkSXRlbVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihub2RlOiArTm9kZSkgLT4gK05vZGVcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vTmFtZWROb2RlTWFwXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIkFkZHMgKG9yIHJlcGxhY2VzKSBhIG5vZGUgYnkgaXRzIG5vZGVOYW1lLlwiXG4gICAgICB9LFxuICAgICAgXCJyZW1vdmVOYW1lZEl0ZW1cIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4obmFtZTogc3RyaW5nKSAtPiArTm9kZVwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9OYW1lZE5vZGVNYXBcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmVtb3ZlcyBhIG5vZGUgKG9yIGlmIGFuIGF0dHJpYnV0ZSwgbWF5IHJldmVhbCBhIGRlZmF1bHQgaWYgcHJlc2VudCkuXCJcbiAgICAgIH0sXG4gICAgICBcIml0ZW1cIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oaTogbnVtYmVyKSAtPiArTm9kZVwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9OYW1lZE5vZGVNYXBcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgaXRlbSBhdCB0aGUgZ2l2ZW4gaW5kZXggKG9yIG51bGwgaWYgdGhlIGluZGV4IGlzIGhpZ2hlciBvciBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIG5vZGVzKS5cIlxuICAgICAgfSxcbiAgICAgIFwiZ2V0TmFtZWRJdGVtTlNcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4obnM6IHN0cmluZywgbmFtZTogc3RyaW5nKSAtPiArTm9kZVwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9OYW1lZE5vZGVNYXBcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiR2V0cyBhIG5vZGUgYnkgbmFtZXNwYWNlIGFuZCBsb2NhbE5hbWUuXCJcbiAgICAgIH0sXG4gICAgICBcInNldE5hbWVkSXRlbU5TXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKG5vZGU6ICtOb2RlKSAtPiArTm9kZVwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9OYW1lZE5vZGVNYXBcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiQWRkcyAob3IgcmVwbGFjZXMpIGEgbm9kZSBieSBpdHMgbG9jYWxOYW1lIGFuZCBuYW1lc3BhY2VVUkkuXCJcbiAgICAgIH0sXG4gICAgICBcInJlbW92ZU5hbWVkSXRlbU5TXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKG5zOiBzdHJpbmcsIG5hbWU6IHN0cmluZykgLT4gK05vZGVcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vTmFtZWROb2RlTWFwXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJlbW92ZXMgYSBub2RlIChvciBpZiBhbiBhdHRyaWJ1dGUsIG1heSByZXZlYWwgYSBkZWZhdWx0IGlmIHByZXNlbnQpLlwiXG4gICAgICB9LFxuICAgICAgXCI8aT5cIjogXCIrTm9kZVwiXG4gICAgfSxcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9OYW1lZE5vZGVNYXBcIixcbiAgICBcIiFkb2NcIjogXCJBIGNvbGxlY3Rpb24gb2Ygbm9kZXMgcmV0dXJuZWQgYnkgRWxlbWVudC5hdHRyaWJ1dGVzIChhbHNvIHBvdGVudGlhbGx5IGZvciBEb2N1bWVudFR5cGUuZW50aXRpZXMsIERvY3VtZW50VHlwZS5ub3RhdGlvbnMpLiBOYW1lZE5vZGVNYXBzIGFyZSBub3QgaW4gYW55IHBhcnRpY3VsYXIgb3JkZXIgKHVubGlrZSBOb2RlTGlzdCksIGFsdGhvdWdoIHRoZXkgbWF5IGJlIGFjY2Vzc2VkIGJ5IGFuIGluZGV4IGFzIGluIGFuIGFycmF5ICh0aGV5IG1heSBhbHNvIGJlIGFjY2Vzc2VkIHdpdGggdGhlIGl0ZW0oKSBtZXRob2QpLiBBIE5hbWVkTm9kZU1hcCBvYmplY3QgYXJlIGxpdmUgYW5kIHdpbGwgdGh1cyBiZSBhdXRvLXVwZGF0ZWQgaWYgY2hhbmdlcyBhcmUgbWFkZSB0byB0aGVpciBjb250ZW50cyBpbnRlcm5hbGx5IG9yIGVsc2V3aGVyZS5cIlxuICB9LFxuICBcIkRvY3VtZW50RnJhZ21lbnRcIjoge1xuICAgIFwiIXR5cGVcIjogXCJmbigpXCIsXG4gICAgXCJwcm90b3R5cGVcIjoge1xuICAgICAgXCIhcHJvdG9cIjogXCJOb2RlLnByb3RvdHlwZVwiXG4gICAgfSxcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50XCIsXG4gICAgXCIhZG9jXCI6IFwiQ3JlYXRlcyBhIG5ldyBlbXB0eSBEb2N1bWVudEZyYWdtZW50LlwiXG4gIH0sXG4gIFwiRE9NVG9rZW5MaXN0XCI6IHtcbiAgICBcIiF0eXBlXCI6IFwiZm4oKVwiLFxuICAgIFwicHJvdG90eXBlXCI6IHtcbiAgICAgIFwibGVuZ3RoXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9ET01Ub2tlbkxpc3RcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiVGhlIGFtb3VudCBvZiBpdGVtcyBpbiB0aGUgbGlzdC5cIlxuICAgICAgfSxcbiAgICAgIFwiaXRlbVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihpOiBudW1iZXIpIC0+IHN0cmluZ1wiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9ET01Ub2tlbkxpc3RcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyBhbiBpdGVtIGluIHRoZSBsaXN0IGJ5IGl0cyBpbmRleC5cIlxuICAgICAgfSxcbiAgICAgIFwiY29udGFpbnNcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4odG9rZW46IHN0cmluZykgLT4gYm9vbFwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9ET01Ub2tlbkxpc3RcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJuIHRydWUgaWYgdGhlIHVuZGVybHlpbmcgc3RyaW5nIGNvbnRhaW5zIHRva2VuLCBvdGhlcndpc2UgZmFsc2UuXCJcbiAgICAgIH0sXG4gICAgICBcImFkZFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbih0b2tlbjogc3RyaW5nKVwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9ET01Ub2tlbkxpc3RcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiQWRkcyB0b2tlbiB0byB0aGUgdW5kZXJseWluZyBzdHJpbmcuXCJcbiAgICAgIH0sXG4gICAgICBcInJlbW92ZVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbih0b2tlbjogc3RyaW5nKVwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9ET01Ub2tlbkxpc3RcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmVtb3ZlIHRva2VuIGZyb20gdGhlIHVuZGVybHlpbmcgc3RyaW5nLlwiXG4gICAgICB9LFxuICAgICAgXCJ0b2dnbGVcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4odG9rZW46IHN0cmluZykgLT4gYm9vbFwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9ET01Ub2tlbkxpc3RcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmVtb3ZlcyB0b2tlbiBmcm9tIHN0cmluZyBhbmQgcmV0dXJucyBmYWxzZS4gSWYgdG9rZW4gZG9lc24ndCBleGlzdCBpdCdzIGFkZGVkIGFuZCB0aGUgZnVuY3Rpb24gcmV0dXJucyB0cnVlLlwiXG4gICAgICB9LFxuICAgICAgXCI8aT5cIjogXCJzdHJpbmdcIlxuICAgIH0sXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vRE9NVG9rZW5MaXN0XCIsXG4gICAgXCIhZG9jXCI6IFwiVGhpcyB0eXBlIHJlcHJlc2VudHMgYSBzZXQgb2Ygc3BhY2Utc2VwYXJhdGVkIHRva2Vucy4gQ29tbW9ubHkgcmV0dXJuZWQgYnkgSFRNTEVsZW1lbnQuY2xhc3NMaXN0LCBIVE1MTGlua0VsZW1lbnQucmVsTGlzdCwgSFRNTEFuY2hvckVsZW1lbnQucmVsTGlzdCBvciBIVE1MQXJlYUVsZW1lbnQucmVsTGlzdC4gSXQgaXMgaW5kZXhlZCBiZWdpbm5pbmcgd2l0aCAwIGFzIHdpdGggSmF2YVNjcmlwdCBhcnJheXMuIERPTVRva2VuTGlzdCBpcyBhbHdheXMgY2FzZS1zZW5zaXRpdmUuXCJcbiAgfSxcbiAgXCJYUGF0aFJlc3VsdFwiOiB7XG4gICAgXCIhdHlwZVwiOiBcImZuKClcIixcbiAgICBcInByb3RvdHlwZVwiOiB7XG4gICAgICBcImJvb2xWYWx1ZVwiOiBcImJvb2xcIixcbiAgICAgIFwiaW52YWxpZEl0ZXJhdG9yU3RhdGVcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiYm9vbFwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0ludHJvZHVjdGlvbl90b191c2luZ19YUGF0aF9pbl9KYXZhU2NyaXB0XCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlRoaXMgZG9jdW1lbnQgZGVzY3JpYmVzIHRoZSBpbnRlcmZhY2UgZm9yIHVzaW5nIFhQYXRoIGluIEphdmFTY3JpcHQgaW50ZXJuYWxseSwgaW4gZXh0ZW5zaW9ucywgYW5kIGZyb20gd2Vic2l0ZXMuIE1vemlsbGEgaW1wbGVtZW50cyBhIGZhaXIgYW1vdW50IG9mIHRoZSBET00gMyBYUGF0aC4gV2hpY2ggbWVhbnMgdGhhdCBYUGF0aCBleHByZXNzaW9ucyBjYW4gYmUgcnVuIGFnYWluc3QgYm90aCBIVE1MIGFuZCBYTUwgZG9jdW1lbnRzLlwiXG4gICAgICB9LFxuICAgICAgXCJudW1iZXJWYWx1ZVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9YUGF0aFJlc3VsdFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZWZlciB0byBuc0lET01YUGF0aFJlc3VsdCBmb3IgbW9yZSBkZXRhaWwuXCJcbiAgICAgIH0sXG4gICAgICBcInJlc3VsdFR5cGVcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2RvY3VtZW50LmV2YWx1YXRlXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgYW4gWFBhdGhSZXN1bHQgYmFzZWQgb24gYW4gWFBhdGggZXhwcmVzc2lvbiBhbmQgb3RoZXIgZ2l2ZW4gcGFyYW1ldGVycy5cIlxuICAgICAgfSxcbiAgICAgIFwic2luZ2xlTm9kZVZhbHVlXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIitFbGVtZW50XCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvSW50cm9kdWN0aW9uX3RvX3VzaW5nX1hQYXRoX2luX0phdmFTY3JpcHRcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiVGhpcyBkb2N1bWVudCBkZXNjcmliZXMgdGhlIGludGVyZmFjZSBmb3IgdXNpbmcgWFBhdGggaW4gSmF2YVNjcmlwdCBpbnRlcm5hbGx5LCBpbiBleHRlbnNpb25zLCBhbmQgZnJvbSB3ZWJzaXRlcy4gTW96aWxsYSBpbXBsZW1lbnRzIGEgZmFpciBhbW91bnQgb2YgdGhlIERPTSAzIFhQYXRoLiBXaGljaCBtZWFucyB0aGF0IFhQYXRoIGV4cHJlc3Npb25zIGNhbiBiZSBydW4gYWdhaW5zdCBib3RoIEhUTUwgYW5kIFhNTCBkb2N1bWVudHMuXCJcbiAgICAgIH0sXG4gICAgICBcInNuYXBzaG90TGVuZ3RoXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1hQYXRoUmVzdWx0XCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJlZmVyIHRvIG5zSURPTVhQYXRoUmVzdWx0IGZvciBtb3JlIGRldGFpbC5cIlxuICAgICAgfSxcbiAgICAgIFwic3RyaW5nVmFsdWVcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvSW50cm9kdWN0aW9uX3RvX3VzaW5nX1hQYXRoX2luX0phdmFTY3JpcHRcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiVGhpcyBkb2N1bWVudCBkZXNjcmliZXMgdGhlIGludGVyZmFjZSBmb3IgdXNpbmcgWFBhdGggaW4gSmF2YVNjcmlwdCBpbnRlcm5hbGx5LCBpbiBleHRlbnNpb25zLCBhbmQgZnJvbSB3ZWJzaXRlcy4gTW96aWxsYSBpbXBsZW1lbnRzIGEgZmFpciBhbW91bnQgb2YgdGhlIERPTSAzIFhQYXRoLiBXaGljaCBtZWFucyB0aGF0IFhQYXRoIGV4cHJlc3Npb25zIGNhbiBiZSBydW4gYWdhaW5zdCBib3RoIEhUTUwgYW5kIFhNTCBkb2N1bWVudHMuXCJcbiAgICAgIH0sXG4gICAgICBcIml0ZXJhdGVOZXh0XCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKClcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9JbnRyb2R1Y3Rpb25fdG9fdXNpbmdfWFBhdGhfaW5fSmF2YVNjcmlwdFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJUaGlzIGRvY3VtZW50IGRlc2NyaWJlcyB0aGUgaW50ZXJmYWNlIGZvciB1c2luZyBYUGF0aCBpbiBKYXZhU2NyaXB0IGludGVybmFsbHksIGluIGV4dGVuc2lvbnMsIGFuZCBmcm9tIHdlYnNpdGVzLiBNb3ppbGxhIGltcGxlbWVudHMgYSBmYWlyIGFtb3VudCBvZiB0aGUgRE9NIDMgWFBhdGguIFdoaWNoIG1lYW5zIHRoYXQgWFBhdGggZXhwcmVzc2lvbnMgY2FuIGJlIHJ1biBhZ2FpbnN0IGJvdGggSFRNTCBhbmQgWE1MIGRvY3VtZW50cy5cIlxuICAgICAgfSxcbiAgICAgIFwic25hcHNob3RJdGVtXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKClcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9YUGF0aFJlc3VsdCNzbmFwc2hvdEl0ZW0oKVwiXG4gICAgICB9LFxuICAgICAgXCJBTllfVFlQRVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJOVU1CRVJfVFlQRVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJTVFJJTkdfVFlQRVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJCT09MX1RZUEVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiVU5PUkRFUkVEX05PREVfSVRFUkFUT1JfVFlQRVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJPUkRFUkVEX05PREVfSVRFUkFUT1JfVFlQRVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJVTk9SREVSRURfTk9ERV9TTkFQU0hPVF9UWVBFXCI6IFwibnVtYmVyXCIsXG4gICAgICBcIk9SREVSRURfTk9ERV9TTkFQU0hPVF9UWVBFXCI6IFwibnVtYmVyXCIsXG4gICAgICBcIkFOWV9VTk9SREVSRURfTk9ERV9UWVBFXCI6IFwibnVtYmVyXCIsXG4gICAgICBcIkZJUlNUX09SREVSRURfTk9ERV9UWVBFXCI6IFwibnVtYmVyXCJcbiAgICB9LFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvWFBhdGhSZXN1bHRcIixcbiAgICBcIiFkb2NcIjogXCJSZWZlciB0byBuc0lET01YUGF0aFJlc3VsdCBmb3IgbW9yZSBkZXRhaWwuXCJcbiAgfSxcbiAgXCJDbGllbnRSZWN0XCI6IHtcbiAgICBcIiF0eXBlXCI6IFwiZm4oKVwiLFxuICAgIFwicHJvdG90eXBlXCI6IHtcbiAgICAgIFwidG9wXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9lbGVtZW50LmdldENsaWVudFJlY3RzXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlRvcCBvZiB0aGUgYm94LCBpbiBwaXhlbHMsIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydC5cIlxuICAgICAgfSxcbiAgICAgIFwibGVmdFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZWxlbWVudC5nZXRDbGllbnRSZWN0c1wiLFxuICAgICAgICBcIiFkb2NcIjogXCJMZWZ0IG9mIHRoZSBib3gsIGluIHBpeGVscywgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0LlwiXG4gICAgICB9LFxuICAgICAgXCJib3R0b21cIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2VsZW1lbnQuZ2V0Q2xpZW50UmVjdHNcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiQm90dG9tIG9mIHRoZSBib3gsIGluIHBpeGVscywgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0LlwiXG4gICAgICB9LFxuICAgICAgXCJyaWdodFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZWxlbWVudC5nZXRDbGllbnRSZWN0c1wiLFxuICAgICAgICBcIiFkb2NcIjogXCJSaWdodCBvZiB0aGUgYm94LCBpbiBwaXhlbHMsIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydC5cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZWxlbWVudC5nZXRDbGllbnRSZWN0c1wiLFxuICAgIFwiIWRvY1wiOiBcIlJldHVybnMgYSBjb2xsZWN0aW9uIG9mIHJlY3RhbmdsZXMgdGhhdCBpbmRpY2F0ZSB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlcyBmb3IgZWFjaCBib3ggaW4gYSBjbGllbnQuXCJcbiAgfSxcbiAgXCJFdmVudFwiOiB7XG4gICAgXCIhdHlwZVwiOiBcImZuKClcIixcbiAgICBcInByb3RvdHlwZVwiOiB7XG4gICAgICBcInN0b3BQcm9wYWdhdGlvblwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbigpXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2V2ZW50LnN0b3BQcm9wYWdhdGlvblwiLFxuICAgICAgICBcIiFkb2NcIjogXCJQcmV2ZW50cyBmdXJ0aGVyIHByb3BhZ2F0aW9uIG9mIHRoZSBjdXJyZW50IGV2ZW50LlwiXG4gICAgICB9LFxuICAgICAgXCJwcmV2ZW50RGVmYXVsdFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbigpXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2V2ZW50LnByZXZlbnREZWZhdWx0XCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIkNhbmNlbHMgdGhlIGV2ZW50IGlmIGl0IGlzIGNhbmNlbGFibGUsIHdpdGhvdXQgc3RvcHBpbmcgZnVydGhlciBwcm9wYWdhdGlvbiBvZiB0aGUgZXZlbnQuXCJcbiAgICAgIH0sXG4gICAgICBcImluaXRFdmVudFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbih0eXBlOiBzdHJpbmcsIGJ1YmJsZXM6IGJvb2wsIGNhbmNlbGFibGU6IGJvb2wpXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2V2ZW50LmluaXRFdmVudFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJUaGUgaW5pdEV2ZW50IG1ldGhvZCBpcyB1c2VkIHRvIGluaXRpYWxpemUgdGhlIHZhbHVlIG9mIGFuIGV2ZW50IGNyZWF0ZWQgdXNpbmcgZG9jdW1lbnQuY3JlYXRlRXZlbnQuXCJcbiAgICAgIH0sXG4gICAgICBcInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvblwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbigpXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2V2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvblwiLFxuICAgICAgICBcIiFkb2NcIjogXCJQcmV2ZW50cyBvdGhlciBsaXN0ZW5lcnMgb2YgdGhlIHNhbWUgZXZlbnQgdG8gYmUgY2FsbGVkLlwiXG4gICAgICB9LFxuICAgICAgXCJOT05FXCI6IFwibnVtYmVyXCIsXG4gICAgICBcIkNBUFRVUklOR19QSEFTRVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJBVF9UQVJHRVRcIjogXCJudW1iZXJcIixcbiAgICAgIFwiQlVCQkxJTkdfUEhBU0VcIjogXCJudW1iZXJcIixcbiAgICAgIFwiTU9VU0VET1dOXCI6IFwibnVtYmVyXCIsXG4gICAgICBcIk1PVVNFVVBcIjogXCJudW1iZXJcIixcbiAgICAgIFwiTU9VU0VPVkVSXCI6IFwibnVtYmVyXCIsXG4gICAgICBcIk1PVVNFT1VUXCI6IFwibnVtYmVyXCIsXG4gICAgICBcIk1PVVNFTU9WRVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJNT1VTRURSQUdcIjogXCJudW1iZXJcIixcbiAgICAgIFwiQ0xJQ0tcIjogXCJudW1iZXJcIixcbiAgICAgIFwiREJMQ0xJQ0tcIjogXCJudW1iZXJcIixcbiAgICAgIFwiS0VZRE9XTlwiOiBcIm51bWJlclwiLFxuICAgICAgXCJLRVlVUFwiOiBcIm51bWJlclwiLFxuICAgICAgXCJLRVlQUkVTU1wiOiBcIm51bWJlclwiLFxuICAgICAgXCJEUkFHRFJPUFwiOiBcIm51bWJlclwiLFxuICAgICAgXCJGT0NVU1wiOiBcIm51bWJlclwiLFxuICAgICAgXCJCTFVSXCI6IFwibnVtYmVyXCIsXG4gICAgICBcIlNFTEVDVFwiOiBcIm51bWJlclwiLFxuICAgICAgXCJDSEFOR0VcIjogXCJudW1iZXJcIixcbiAgICAgIFwidGFyZ2V0XCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIitFbGVtZW50XCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL0V2ZW50VGFyZ2V0XCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIkFuIEV2ZW50VGFyZ2V0IGlzIGEgRE9NIGludGVyZmFjZSBpbXBsZW1lbnRlZCBieSBvYmplY3RzIHRoYXQgY2FuIHJlY2VpdmUgRE9NIGV2ZW50cyBhbmQgaGF2ZSBsaXN0ZW5lcnMgZm9yIHRoZW0uIFRoZSBtb3N0IGNvbW1vbiBFdmVudFRhcmdldHMgYXJlIERPTSBlbGVtZW50cywgYWx0aG91Z2ggb3RoZXIgb2JqZWN0cyBjYW4gYmUgRXZlbnRUYXJnZXRzIHRvbywgZm9yIGV4YW1wbGUgZG9jdW1lbnQsIHdpbmRvdywgWE1MSHR0cFJlcXVlc3QsIGFuZCBvdGhlcnMuXCJcbiAgICAgIH0sXG4gICAgICBcInJlbGF0ZWRUYXJnZXRcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiK0VsZW1lbnRcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZXZlbnQucmVsYXRlZFRhcmdldFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJJZGVudGlmaWVzIGEgc2Vjb25kYXJ5IHRhcmdldCBmb3IgdGhlIGV2ZW50LlwiXG4gICAgICB9LFxuICAgICAgXCJwYWdlWFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZXZlbnQucGFnZVhcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgaG9yaXpvbnRhbCBjb29yZGluYXRlIG9mIHRoZSBldmVudCByZWxhdGl2ZSB0byB3aG9sZSBkb2N1bWVudC5cIlxuICAgICAgfSxcbiAgICAgIFwicGFnZVlcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2V2ZW50LnBhZ2VZXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIHZlcnRpY2FsIGNvb3JkaW5hdGUgb2YgdGhlIGV2ZW50IHJlbGF0aXZlIHRvIHRoZSB3aG9sZSBkb2N1bWVudC5cIlxuICAgICAgfSxcbiAgICAgIFwiY2xpZW50WFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZXZlbnQuY2xpZW50WFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIHRoZSBob3Jpem9udGFsIGNvb3JkaW5hdGUgd2l0aGluIHRoZSBhcHBsaWNhdGlvbidzIGNsaWVudCBhcmVhIGF0IHdoaWNoIHRoZSBldmVudCBvY2N1cnJlZCAoYXMgb3Bwb3NlZCB0byB0aGUgY29vcmRpbmF0ZXMgd2l0aGluIHRoZSBwYWdlKS4gRm9yIGV4YW1wbGUsIGNsaWNraW5nIGluIHRoZSB0b3AtbGVmdCBjb3JuZXIgb2YgdGhlIGNsaWVudCBhcmVhIHdpbGwgYWx3YXlzIHJlc3VsdCBpbiBhIG1vdXNlIGV2ZW50IHdpdGggYSBjbGllbnRYIHZhbHVlIG9mIDAsIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgcGFnZSBpcyBzY3JvbGxlZCBob3Jpem9udGFsbHkuXCJcbiAgICAgIH0sXG4gICAgICBcImNsaWVudFlcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2V2ZW50LmNsaWVudFlcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgdmVydGljYWwgY29vcmRpbmF0ZSB3aXRoaW4gdGhlIGFwcGxpY2F0aW9uJ3MgY2xpZW50IGFyZWEgYXQgd2hpY2ggdGhlIGV2ZW50IG9jY3VycmVkIChhcyBvcHBvc2VkIHRvIHRoZSBjb29yZGluYXRlcyB3aXRoaW4gdGhlIHBhZ2UpLiBGb3IgZXhhbXBsZSwgY2xpY2tpbmcgaW4gdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgY2xpZW50IGFyZWEgd2lsbCBhbHdheXMgcmVzdWx0IGluIGEgbW91c2UgZXZlbnQgd2l0aCBhIGNsaWVudFkgdmFsdWUgb2YgMCwgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZSBwYWdlIGlzIHNjcm9sbGVkIHZlcnRpY2FsbHkuXCJcbiAgICAgIH0sXG4gICAgICBcImtleUNvZGVcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2V2ZW50LmtleUNvZGVcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgVW5pY29kZSB2YWx1ZSBvZiBhIG5vbi1jaGFyYWN0ZXIga2V5IGluIGEga2V5cHJlc3MgZXZlbnQgb3IgYW55IGtleSBpbiBhbnkgb3RoZXIgdHlwZSBvZiBrZXlib2FyZCBldmVudC5cIlxuICAgICAgfSxcbiAgICAgIFwiY2hhckNvZGVcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2V2ZW50LmNoYXJDb2RlXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIFVuaWNvZGUgdmFsdWUgb2YgYSBjaGFyYWN0ZXIga2V5IHByZXNzZWQgZHVyaW5nIGEga2V5cHJlc3MgZXZlbnQuXCJcbiAgICAgIH0sXG4gICAgICBcIndoaWNoXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9ldmVudC53aGljaFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIHRoZSBudW1lcmljIGtleUNvZGUgb2YgdGhlIGtleSBwcmVzc2VkLCBvciB0aGUgY2hhcmFjdGVyIGNvZGUgKGNoYXJDb2RlKSBmb3IgYW4gYWxwaGFudW1lcmljIGtleSBwcmVzc2VkLlwiXG4gICAgICB9LFxuICAgICAgXCJidXR0b25cIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2V2ZW50LmJ1dHRvblwiLFxuICAgICAgICBcIiFkb2NcIjogXCJJbmRpY2F0ZXMgd2hpY2ggbW91c2UgYnV0dG9uIGNhdXNlZCB0aGUgZXZlbnQuXCJcbiAgICAgIH0sXG4gICAgICBcInNoaWZ0S2V5XCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImJvb2xcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZXZlbnQuc2hpZnRLZXlcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiSW5kaWNhdGVzIHdoZXRoZXIgdGhlIFNISUZUIGtleSB3YXMgcHJlc3NlZCB3aGVuIHRoZSBldmVudCBmaXJlZC5cIlxuICAgICAgfSxcbiAgICAgIFwiY3RybEtleVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJib29sXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2V2ZW50LmN0cmxLZXlcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiSW5kaWNhdGVzIHdoZXRoZXIgdGhlIENUUkwga2V5IHdhcyBwcmVzc2VkIHdoZW4gdGhlIGV2ZW50IGZpcmVkLlwiXG4gICAgICB9LFxuICAgICAgXCJhbHRLZXlcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiYm9vbFwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9ldmVudC5hbHRLZXlcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiSW5kaWNhdGVzIHdoZXRoZXIgdGhlIEFMVCBrZXkgd2FzIHByZXNzZWQgd2hlbiB0aGUgZXZlbnQgZmlyZWQuXCJcbiAgICAgIH0sXG4gICAgICBcIm1ldGFLZXlcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiYm9vbFwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9ldmVudC5tZXRhS2V5XCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIkluZGljYXRlcyB3aGV0aGVyIHRoZSBNRVRBIGtleSB3YXMgcHJlc3NlZCB3aGVuIHRoZSBldmVudCBmaXJlZC5cIlxuICAgICAgfSxcbiAgICAgIFwicmV0dXJuVmFsdWVcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiYm9vbFwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS93aW5kb3cub25iZWZvcmV1bmxvYWRcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiQW4gZXZlbnQgdGhhdCBmaXJlcyB3aGVuIGEgd2luZG93IGlzIGFib3V0IHRvIHVubG9hZCBpdHMgcmVzb3VyY2VzLiBUaGUgZG9jdW1lbnQgaXMgc3RpbGwgdmlzaWJsZSBhbmQgdGhlIGV2ZW50IGlzIHN0aWxsIGNhbmNlbGFibGUuXCJcbiAgICAgIH0sXG4gICAgICBcImNhbmNlbEJ1YmJsZVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJib29sXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2V2ZW50LmNhbmNlbEJ1YmJsZVwiLFxuICAgICAgICBcIiFkb2NcIjogXCJib29sIGlzIHRoZSBib29sZWFuIHZhbHVlIG9mIHRydWUgb3IgZmFsc2UuXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGFUcmFuc2ZlclwiOiB7XG4gICAgICAgIFwiZHJvcEVmZmVjdFwiOiB7XG4gICAgICAgICAgXCIhdHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRHJhZ0Ryb3AvRGF0YVRyYW5zZmVyXCIsXG4gICAgICAgICAgXCIhZG9jXCI6IFwiVGhlIGFjdHVhbCBlZmZlY3QgdGhhdCB3aWxsIGJlIHVzZWQsIGFuZCBzaG91bGQgYWx3YXlzIGJlIG9uZSBvZiB0aGUgcG9zc2libGUgdmFsdWVzIG9mIGVmZmVjdEFsbG93ZWQuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJlZmZlY3RBbGxvd2VkXCI6IHtcbiAgICAgICAgICBcIiF0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9EcmFnRHJvcC9EcmFnX09wZXJhdGlvbnNcIixcbiAgICAgICAgICBcIiFkb2NcIjogXCJTcGVjaWZpZXMgdGhlIGVmZmVjdHMgdGhhdCBhcmUgYWxsb3dlZCBmb3IgdGhpcyBkcmFnLlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZmlsZXNcIjoge1xuICAgICAgICAgIFwiIXR5cGVcIjogXCIrRmlsZUxpc3RcIixcbiAgICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RyYWdEcm9wL0RhdGFUcmFuc2ZlclwiLFxuICAgICAgICAgIFwiIWRvY1wiOiBcIkNvbnRhaW5zIGEgbGlzdCBvZiBhbGwgdGhlIGxvY2FsIGZpbGVzIGF2YWlsYWJsZSBvbiB0aGUgZGF0YSB0cmFuc2Zlci5cIlxuICAgICAgICB9LFxuICAgICAgICBcInR5cGVzXCI6IHtcbiAgICAgICAgICBcIiF0eXBlXCI6IFwiW3N0cmluZ11cIixcbiAgICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0RyYWdEcm9wL0RhdGFUcmFuc2ZlclwiLFxuICAgICAgICAgIFwiIWRvY1wiOiBcIkhvbGRzIGEgbGlzdCBvZiB0aGUgZm9ybWF0IHR5cGVzIG9mIHRoZSBkYXRhIHRoYXQgaXMgc3RvcmVkIGZvciB0aGUgZmlyc3QgaXRlbSwgaW4gdGhlIHNhbWUgb3JkZXIgdGhlIGRhdGEgd2FzIGFkZGVkLiBBbiBlbXB0eSBsaXN0IHdpbGwgYmUgcmV0dXJuZWQgaWYgbm8gZGF0YSB3YXMgYWRkZWQuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJhZGRFbGVtZW50XCI6IHtcbiAgICAgICAgICBcIiF0eXBlXCI6IFwiZm4oZWxlbWVudDogK0VsZW1lbnQpXCIsXG4gICAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9EcmFnRHJvcC9EYXRhVHJhbnNmZXJcIixcbiAgICAgICAgICBcIiFkb2NcIjogXCJTZXQgdGhlIGRyYWcgc291cmNlLlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY2xlYXJEYXRhXCI6IHtcbiAgICAgICAgICBcIiF0eXBlXCI6IFwiZm4odHlwZT86IHN0cmluZylcIixcbiAgICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RyYWdEcm9wL0RyYWdfT3BlcmF0aW9uc1wiLFxuICAgICAgICAgIFwiIWRvY1wiOiBcIlJlbW92ZSB0aGUgZGF0YSBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiB0eXBlLlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZ2V0RGF0YVwiOiB7XG4gICAgICAgICAgXCIhdHlwZVwiOiBcImZuKHR5cGU6IHN0cmluZykgLT4gc3RyaW5nXCIsXG4gICAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9EcmFnRHJvcC9EcmFnX09wZXJhdGlvbnNcIixcbiAgICAgICAgICBcIiFkb2NcIjogXCJSZXRyaWV2ZXMgdGhlIGRhdGEgZm9yIGEgZ2l2ZW4gdHlwZSwgb3IgYW4gZW1wdHkgc3RyaW5nIGlmIGRhdGEgZm9yIHRoYXQgdHlwZSBkb2VzIG5vdCBleGlzdCBvciB0aGUgZGF0YSB0cmFuc2ZlciBjb250YWlucyBubyBkYXRhLlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwic2V0RGF0YVwiOiB7XG4gICAgICAgICAgXCIhdHlwZVwiOiBcImZuKHR5cGU6IHN0cmluZywgZGF0YTogc3RyaW5nKVwiLFxuICAgICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRHJhZ0Ryb3AvRHJhZ19PcGVyYXRpb25zXCIsXG4gICAgICAgICAgXCIhZG9jXCI6IFwiU2V0IHRoZSBkYXRhIGZvciBhIGdpdmVuIHR5cGUuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzZXREcmFnSW1hZ2VcIjoge1xuICAgICAgICAgIFwiIXR5cGVcIjogXCJmbihpbWFnZTogK0VsZW1lbnQpXCIsXG4gICAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9EcmFnRHJvcC9EcmFnX09wZXJhdGlvbnNcIixcbiAgICAgICAgICBcIiFkb2NcIjogXCJTZXQgdGhlIGltYWdlIHRvIGJlIHVzZWQgZm9yIGRyYWdnaW5nIGlmIGEgY3VzdG9tIG9uZSBpcyBkZXNpcmVkLlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRHJhZ0Ryb3AvRGF0YVRyYW5zZmVyXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlRoaXMgb2JqZWN0IGlzIGF2YWlsYWJsZSBmcm9tIHRoZSBkYXRhVHJhbnNmZXIgcHJvcGVydHkgb2YgYWxsIGRyYWcgZXZlbnRzLiBJdCBjYW5ub3QgYmUgY3JlYXRlZCBzZXBhcmF0ZWx5LlwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0RPTS9ldmVudFwiLFxuICAgIFwiIWRvY1wiOiBcIlRoZSBET00gRXZlbnQgaW50ZXJmYWNlIGlzIGFjY2Vzc2libGUgZnJvbSB3aXRoaW4gdGhlIGhhbmRsZXIgZnVuY3Rpb24sIHZpYSB0aGUgZXZlbnQgb2JqZWN0IHBhc3NlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXCJcbiAgfSxcbiAgXCJUb3VjaEV2ZW50XCI6IHtcbiAgICBcIiF0eXBlXCI6IFwiZm4oKVwiLFxuICAgIFwicHJvdG90eXBlXCI6IFwiRXZlbnQucHJvdG90eXBlXCIsXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vVG91Y2hfZXZlbnRzXCIsXG4gICAgXCIhZG9jXCI6IFwiSW4gb3JkZXIgdG8gcHJvdmlkZSBxdWFsaXR5IHN1cHBvcnQgZm9yIHRvdWNoLWJhc2VkIHVzZXIgaW50ZXJmYWNlcywgdG91Y2ggZXZlbnRzIG9mZmVyIHRoZSBhYmlsaXR5IHRvIGludGVycHJldCBmaW5nZXIgYWN0aXZpdHkgb24gdG91Y2ggc2NyZWVucyBvciB0cmFja3BhZHMuXCJcbiAgfSxcbiAgXCJXaGVlbEV2ZW50XCI6IHtcbiAgICBcIiF0eXBlXCI6IFwiZm4oKVwiLFxuICAgIFwicHJvdG90eXBlXCI6IFwiRXZlbnQucHJvdG90eXBlXCIsXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vV2hlZWxFdmVudFwiLFxuICAgIFwiIWRvY1wiOiBcIlRoZSBET00gV2hlZWxFdmVudCByZXByZXNlbnRzIGV2ZW50cyB0aGF0IG9jY3VyIGR1ZSB0byB0aGUgdXNlciBtb3ZpbmcgYSBtb3VzZSB3aGVlbCBvciBzaW1pbGFyIGlucHV0IGRldmljZS5cIlxuICB9LFxuICBcIk1vdXNlRXZlbnRcIjoge1xuICAgIFwiIXR5cGVcIjogXCJmbigpXCIsXG4gICAgXCJwcm90b3R5cGVcIjogXCJFdmVudC5wcm90b3R5cGVcIixcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9Nb3VzZUV2ZW50XCIsXG4gICAgXCIhZG9jXCI6IFwiVGhlIERPTSBNb3VzZUV2ZW50IHJlcHJlc2VudHMgZXZlbnRzIHRoYXQgb2NjdXIgZHVlIHRvIHRoZSB1c2VyIGludGVyYWN0aW5nIHdpdGggYSBwb2ludGluZyBkZXZpY2UgKHN1Y2ggYXMgYSBtb3VzZSkuIEl0J3MgcmVwcmVzZW50ZWQgYnkgdGhlIG5zSU5TRE9NTW91c2VFdmVudCBpbnRlcmZhY2UsIHdoaWNoIGV4dGVuZHMgdGhlIG5zSURPTU1vdXNlRXZlbnQgaW50ZXJmYWNlLlwiXG4gIH0sXG4gIFwiS2V5Ym9hcmRFdmVudFwiOiB7XG4gICAgXCIhdHlwZVwiOiBcImZuKClcIixcbiAgICBcInByb3RvdHlwZVwiOiBcIkV2ZW50LnByb3RvdHlwZVwiLFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL0tleWJvYXJkRXZlbnRcIixcbiAgICBcIiFkb2NcIjogXCJLZXlib2FyZEV2ZW50IG9iamVjdHMgZGVzY3JpYmUgYSB1c2VyIGludGVyYWN0aW9uIHdpdGggdGhlIGtleWJvYXJkLiBFYWNoIGV2ZW50IGRlc2NyaWJlcyBhIGtleTsgdGhlIGV2ZW50IHR5cGUgKGtleWRvd24sIGtleXByZXNzLCBvciBrZXl1cCkgaWRlbnRpZmllcyB3aGF0IGtpbmQgb2YgYWN0aXZpdHkgd2FzIHBlcmZvcm1lZC5cIlxuICB9LFxuICBcIkhhc2hDaGFuZ2VFdmVudFwiOiB7XG4gICAgXCIhdHlwZVwiOiBcImZuKClcIixcbiAgICBcInByb3RvdHlwZVwiOiBcIkV2ZW50LnByb3RvdHlwZVwiLFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL3dpbmRvdy5vbmhhc2hjaGFuZ2VcIixcbiAgICBcIiFkb2NcIjogXCJUaGUgaGFzaGNoYW5nZSBldmVudCBmaXJlcyB3aGVuIGEgd2luZG93J3MgaGFzaCBjaGFuZ2VzLlwiXG4gIH0sXG4gIFwiRXJyb3JFdmVudFwiOiB7XG4gICAgXCIhdHlwZVwiOiBcImZuKClcIixcbiAgICBcInByb3RvdHlwZVwiOiBcIkV2ZW50LnByb3RvdHlwZVwiLFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL0RPTV9ldmVudF9yZWZlcmVuY2UvZXJyb3JcIixcbiAgICBcIiFkb2NcIjogXCJUaGUgZXJyb3IgZXZlbnQgaXMgZmlyZWQgd2hlbmV2ZXIgYSByZXNvdXJjZSBmYWlscyB0byBsb2FkLlwiXG4gIH0sXG4gIFwiQ3VzdG9tRXZlbnRcIjoge1xuICAgIFwiIXR5cGVcIjogXCJmbigpXCIsXG4gICAgXCJwcm90b3R5cGVcIjogXCJFdmVudC5wcm90b3R5cGVcIixcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9FdmVudC9DdXN0b21FdmVudFwiLFxuICAgIFwiIWRvY1wiOiBcIlRoZSBET00gQ3VzdG9tRXZlbnQgYXJlIGV2ZW50cyBpbml0aWFsaXplZCBieSBhbiBhcHBsaWNhdGlvbiBmb3IgYW55IHB1cnBvc2UuXCJcbiAgfSxcbiAgXCJCZWZvcmVMb2FkRXZlbnRcIjoge1xuICAgIFwiIXR5cGVcIjogXCJmbigpXCIsXG4gICAgXCJwcm90b3R5cGVcIjogXCJFdmVudC5wcm90b3R5cGVcIixcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS93aW5kb3dcIixcbiAgICBcIiFkb2NcIjogXCJUaGlzIHNlY3Rpb24gcHJvdmlkZXMgYSBicmllZiByZWZlcmVuY2UgZm9yIGFsbCBvZiB0aGUgbWV0aG9kcywgcHJvcGVydGllcywgYW5kIGV2ZW50cyBhdmFpbGFibGUgdGhyb3VnaCB0aGUgRE9NIHdpbmRvdyBvYmplY3QuIFRoZSB3aW5kb3cgb2JqZWN0IGltcGxlbWVudHMgdGhlIFdpbmRvdyBpbnRlcmZhY2UsIHdoaWNoIGluIHR1cm4gaW5oZXJpdHMgZnJvbSB0aGUgQWJzdHJhY3RWaWV3IGludGVyZmFjZS4gU29tZSBhZGRpdGlvbmFsIGdsb2JhbCBmdW5jdGlvbnMsIG5hbWVzcGFjZXMgb2JqZWN0cywgYW5kIGNvbnN0cnVjdG9ycywgbm90IHR5cGljYWxseSBhc3NvY2lhdGVkIHdpdGggdGhlIHdpbmRvdywgYnV0IGF2YWlsYWJsZSBvbiBpdCwgYXJlIGxpc3RlZCBpbiB0aGUgSmF2YVNjcmlwdCBSZWZlcmVuY2UuXCJcbiAgfSxcbiAgXCJXZWJTb2NrZXRcIjoge1xuICAgIFwiIXR5cGVcIjogXCJmbih1cmw6IHN0cmluZylcIixcbiAgICBcInByb3RvdHlwZVwiOiB7XG4gICAgICBcImNsb3NlXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKClcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWJTb2NrZXRzL1dlYlNvY2tldHNfcmVmZXJlbmNlL0Nsb3NlRXZlbnRcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiQSBDbG9zZUV2ZW50IGlzIHNlbnQgdG8gY2xpZW50cyB1c2luZyBXZWJTb2NrZXRzIHdoZW4gdGhlIGNvbm5lY3Rpb24gaXMgY2xvc2VkLiBUaGlzIGlzIGRlbGl2ZXJlZCB0byB0aGUgbGlzdGVuZXIgaW5kaWNhdGVkIGJ5IHRoZSBXZWJTb2NrZXQgb2JqZWN0J3Mgb25jbG9zZSBhdHRyaWJ1dGUuXCJcbiAgICAgIH0sXG4gICAgICBcInNlbmRcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oZGF0YTogc3RyaW5nKVwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYlNvY2tldHMvV2ViU29ja2V0c19yZWZlcmVuY2UvV2ViU29ja2V0XCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlRoZSBXZWJTb2NrZXQgb2JqZWN0IHByb3ZpZGVzIHRoZSBBUEkgZm9yIGNyZWF0aW5nIGFuZCBtYW5hZ2luZyBhIFdlYlNvY2tldCBjb25uZWN0aW9uIHRvIGEgc2VydmVyLCBhcyB3ZWxsIGFzIGZvciBzZW5kaW5nIGFuZCByZWNlaXZpbmcgZGF0YSBvbiB0aGUgY29ubmVjdGlvbi5cIlxuICAgICAgfSxcbiAgICAgIFwiYmluYXJ5VHlwZVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWJTb2NrZXRzL1dlYlNvY2tldHNfcmVmZXJlbmNlL1dlYlNvY2tldFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJUaGUgV2ViU29ja2V0IG9iamVjdCBwcm92aWRlcyB0aGUgQVBJIGZvciBjcmVhdGluZyBhbmQgbWFuYWdpbmcgYSBXZWJTb2NrZXQgY29ubmVjdGlvbiB0byBhIHNlcnZlciwgYXMgd2VsbCBhcyBmb3Igc2VuZGluZyBhbmQgcmVjZWl2aW5nIGRhdGEgb24gdGhlIGNvbm5lY3Rpb24uXCJcbiAgICAgIH0sXG4gICAgICBcImJ1ZmZlcmVkQW1vdW50XCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYlNvY2tldHMvV3JpdGluZ19XZWJTb2NrZXRfY2xpZW50X2FwcGxpY2F0aW9uc1wiLFxuICAgICAgICBcIiFkb2NcIjogXCJXZWJTb2NrZXRzIGlzIGEgdGVjaG5vbG9neSB0aGF0IG1ha2VzIGl0IHBvc3NpYmxlIHRvIG9wZW4gYW4gaW50ZXJhY3RpdmUgY29tbXVuaWNhdGlvbiBzZXNzaW9uIGJldHdlZW4gdGhlIHVzZXIncyBicm93c2VyIGFuZCBhIHNlcnZlci4gVXNpbmcgYSBXZWJTb2NrZXQgY29ubmVjdGlvbiwgV2ViIGFwcGxpY2F0aW9ucyBjYW4gcGVyZm9ybSByZWFsLXRpbWUgY29tbXVuaWNhdGlvbiBpbnN0ZWFkIG9mIGhhdmluZyB0byBwb2xsIGZvciBjaGFuZ2VzIGJhY2sgYW5kIGZvcnRoLlwiXG4gICAgICB9LFxuICAgICAgXCJleHRlbnNpb25zXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYlNvY2tldHMvV2ViU29ja2V0c19yZWZlcmVuY2UvV2ViU29ja2V0XCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlRoZSBXZWJTb2NrZXQgb2JqZWN0IHByb3ZpZGVzIHRoZSBBUEkgZm9yIGNyZWF0aW5nIGFuZCBtYW5hZ2luZyBhIFdlYlNvY2tldCBjb25uZWN0aW9uIHRvIGEgc2VydmVyLCBhcyB3ZWxsIGFzIGZvciBzZW5kaW5nIGFuZCByZWNlaXZpbmcgZGF0YSBvbiB0aGUgY29ubmVjdGlvbi5cIlxuICAgICAgfSxcbiAgICAgIFwib25jbG9zZVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCI/XCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViU29ja2V0cy9XZWJTb2NrZXRzX3JlZmVyZW5jZS9DbG9zZUV2ZW50XCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIkEgQ2xvc2VFdmVudCBpcyBzZW50IHRvIGNsaWVudHMgdXNpbmcgV2ViU29ja2V0cyB3aGVuIHRoZSBjb25uZWN0aW9uIGlzIGNsb3NlZC4gVGhpcyBpcyBkZWxpdmVyZWQgdG8gdGhlIGxpc3RlbmVyIGluZGljYXRlZCBieSB0aGUgV2ViU29ja2V0IG9iamVjdCdzIG9uY2xvc2UgYXR0cmlidXRlLlwiXG4gICAgICB9LFxuICAgICAgXCJvbmVycm9yXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIj9cIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWJTb2NrZXRzL1dyaXRpbmdfV2ViU29ja2V0X2NsaWVudF9hcHBsaWNhdGlvbnNcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiV2ViU29ja2V0cyBpcyBhIHRlY2hub2xvZ3kgdGhhdCBtYWtlcyBpdCBwb3NzaWJsZSB0byBvcGVuIGFuIGludGVyYWN0aXZlIGNvbW11bmljYXRpb24gc2Vzc2lvbiBiZXR3ZWVuIHRoZSB1c2VyJ3MgYnJvd3NlciBhbmQgYSBzZXJ2ZXIuIFVzaW5nIGEgV2ViU29ja2V0IGNvbm5lY3Rpb24sIFdlYiBhcHBsaWNhdGlvbnMgY2FuIHBlcmZvcm0gcmVhbC10aW1lIGNvbW11bmljYXRpb24gaW5zdGVhZCBvZiBoYXZpbmcgdG8gcG9sbCBmb3IgY2hhbmdlcyBiYWNrIGFuZCBmb3J0aC5cIlxuICAgICAgfSxcbiAgICAgIFwib25tZXNzYWdlXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIj9cIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWJTb2NrZXRzL1dlYlNvY2tldHNfcmVmZXJlbmNlL1dlYlNvY2tldFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJUaGUgV2ViU29ja2V0IG9iamVjdCBwcm92aWRlcyB0aGUgQVBJIGZvciBjcmVhdGluZyBhbmQgbWFuYWdpbmcgYSBXZWJTb2NrZXQgY29ubmVjdGlvbiB0byBhIHNlcnZlciwgYXMgd2VsbCBhcyBmb3Igc2VuZGluZyBhbmQgcmVjZWl2aW5nIGRhdGEgb24gdGhlIGNvbm5lY3Rpb24uXCJcbiAgICAgIH0sXG4gICAgICBcIm9ub3BlblwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCI/XCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViU29ja2V0cy9XZWJTb2NrZXRzX3JlZmVyZW5jZS9XZWJTb2NrZXRcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiVGhlIFdlYlNvY2tldCBvYmplY3QgcHJvdmlkZXMgdGhlIEFQSSBmb3IgY3JlYXRpbmcgYW5kIG1hbmFnaW5nIGEgV2ViU29ja2V0IGNvbm5lY3Rpb24gdG8gYSBzZXJ2ZXIsIGFzIHdlbGwgYXMgZm9yIHNlbmRpbmcgYW5kIHJlY2VpdmluZyBkYXRhIG9uIHRoZSBjb25uZWN0aW9uLlwiXG4gICAgICB9LFxuICAgICAgXCJwcm90b2NvbFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWJTb2NrZXRzXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIldlYlNvY2tldHMgaXMgYW4gYWR2YW5jZWQgdGVjaG5vbG9neSB0aGF0IG1ha2VzIGl0IHBvc3NpYmxlIHRvIG9wZW4gYW4gaW50ZXJhY3RpdmUgY29tbXVuaWNhdGlvbiBzZXNzaW9uIGJldHdlZW4gdGhlIHVzZXIncyBicm93c2VyIGFuZCBhIHNlcnZlci4gV2l0aCB0aGlzIEFQSSwgeW91IGNhbiBzZW5kIG1lc3NhZ2VzIHRvIGEgc2VydmVyIGFuZCByZWNlaXZlIGV2ZW50LWRyaXZlbiByZXNwb25zZXMgd2l0aG91dCBoYXZpbmcgdG8gcG9sbCB0aGUgc2VydmVyIGZvciBhIHJlcGx5LlwiXG4gICAgICB9LFxuICAgICAgXCJ1cmxcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViU29ja2V0cy9Xcml0aW5nX1dlYlNvY2tldF9jbGllbnRfYXBwbGljYXRpb25zXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIldlYlNvY2tldHMgaXMgYSB0ZWNobm9sb2d5IHRoYXQgbWFrZXMgaXQgcG9zc2libGUgdG8gb3BlbiBhbiBpbnRlcmFjdGl2ZSBjb21tdW5pY2F0aW9uIHNlc3Npb24gYmV0d2VlbiB0aGUgdXNlcidzIGJyb3dzZXIgYW5kIGEgc2VydmVyLiBVc2luZyBhIFdlYlNvY2tldCBjb25uZWN0aW9uLCBXZWIgYXBwbGljYXRpb25zIGNhbiBwZXJmb3JtIHJlYWwtdGltZSBjb21tdW5pY2F0aW9uIGluc3RlYWQgb2YgaGF2aW5nIHRvIHBvbGwgZm9yIGNoYW5nZXMgYmFjayBhbmQgZm9ydGguXCJcbiAgICAgIH0sXG4gICAgICBcIkNPTk5FQ1RJTkdcIjogXCJudW1iZXJcIixcbiAgICAgIFwiT1BFTlwiOiBcIm51bWJlclwiLFxuICAgICAgXCJDTE9TSU5HXCI6IFwibnVtYmVyXCIsXG4gICAgICBcIkNMT1NFRFwiOiBcIm51bWJlclwiXG4gICAgfSxcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYlNvY2tldHNcIixcbiAgICBcIiFkb2NcIjogXCJXZWJTb2NrZXRzIGlzIGFuIGFkdmFuY2VkIHRlY2hub2xvZ3kgdGhhdCBtYWtlcyBpdCBwb3NzaWJsZSB0byBvcGVuIGFuIGludGVyYWN0aXZlIGNvbW11bmljYXRpb24gc2Vzc2lvbiBiZXR3ZWVuIHRoZSB1c2VyJ3MgYnJvd3NlciBhbmQgYSBzZXJ2ZXIuIFdpdGggdGhpcyBBUEksIHlvdSBjYW4gc2VuZCBtZXNzYWdlcyB0byBhIHNlcnZlciBhbmQgcmVjZWl2ZSBldmVudC1kcml2ZW4gcmVzcG9uc2VzIHdpdGhvdXQgaGF2aW5nIHRvIHBvbGwgdGhlIHNlcnZlciBmb3IgYSByZXBseS5cIlxuICB9LFxuICBcIldvcmtlclwiOiB7XG4gICAgXCIhdHlwZVwiOiBcImZuKHNjcmlwdFVSTDogc3RyaW5nKVwiLFxuICAgIFwicHJvdG90eXBlXCI6IHtcbiAgICAgIFwicG9zdE1lc3NhZ2VcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4obWVzc2FnZTogPylcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vV29ya2VyXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlNlbmRzIGEgbWVzc2FnZSB0byB0aGUgd29ya2VyJ3MgaW5uZXIgc2NvcGUuIFRoaXMgYWNjZXB0cyBhIHNpbmdsZSBwYXJhbWV0ZXIsIHdoaWNoIGlzIHRoZSBkYXRhIHRvIHNlbmQgdG8gdGhlIHdvcmtlci4gVGhlIGRhdGEgbWF5IGJlIGFueSB2YWx1ZSBvciBKYXZhU2NyaXB0IG9iamVjdCBoYW5kbGVkIGJ5IHRoZSBzdHJ1Y3R1cmVkIGNsb25lIGFsZ29yaXRobSwgd2hpY2ggaW5jbHVkZXMgY3ljbGljYWwgcmVmZXJlbmNlcy5cIlxuICAgICAgfSxcbiAgICAgIFwidGVybWluYXRlXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKClcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vV29ya2VyXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIkltbWVkaWF0ZWx5IHRlcm1pbmF0ZXMgdGhlIHdvcmtlci4gVGhpcyBkb2VzIG5vdCBvZmZlciB0aGUgd29ya2VyIGFuIG9wcG9ydHVuaXR5IHRvIGZpbmlzaCBpdHMgb3BlcmF0aW9uczsgaXQgaXMgc2ltcGx5IHN0b3BwZWQgYXQgb25jZS5cIlxuICAgICAgfSxcbiAgICAgIFwib25tZXNzYWdlXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIj9cIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vV29ya2VyXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIkFuIGV2ZW50IGxpc3RlbmVyIHRoYXQgaXMgY2FsbGVkIHdoZW5ldmVyIGEgTWVzc2FnZUV2ZW50IHdpdGggdHlwZSBtZXNzYWdlIGJ1YmJsZXMgdGhyb3VnaCB0aGUgd29ya2VyLiBUaGUgbWVzc2FnZSBpcyBzdG9yZWQgaW4gdGhlIGV2ZW50J3MgZGF0YSBtZW1iZXIuXCJcbiAgICAgIH0sXG4gICAgICBcIm9uZXJyb3JcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiP1wiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9Xb3JrZXJcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiQW4gZXZlbnQgbGlzdGVuZXIgdGhhdCBpcyBjYWxsZWQgd2hlbmV2ZXIgYW4gRXJyb3JFdmVudCB3aXRoIHR5cGUgZXJyb3IgYnViYmxlcyB0aHJvdWdoIHRoZSB3b3JrZXIuXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL1dvcmtlclwiLFxuICAgIFwiIWRvY1wiOiBcIldvcmtlcnMgYXJlIGJhY2tncm91bmQgdGFza3MgdGhhdCBjYW4gYmUgZWFzaWx5IGNyZWF0ZWQgYW5kIGNhbiBzZW5kIG1lc3NhZ2VzIGJhY2sgdG8gdGhlaXIgY3JlYXRvcnMuIENyZWF0aW5nIGEgd29ya2VyIGlzIGFzIHNpbXBsZSBhcyBjYWxsaW5nIHRoZSBXb3JrZXIoKSBjb25zdHJ1Y3Rvciwgc3BlY2lmeWluZyBhIHNjcmlwdCB0byBiZSBydW4gaW4gdGhlIHdvcmtlciB0aHJlYWQuXCJcbiAgfSxcbiAgXCJsb2NhbFN0b3JhZ2VcIjoge1xuICAgIFwic2V0SXRlbVwiOiB7XG4gICAgICBcIiF0eXBlXCI6IFwiZm4obmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKVwiLFxuICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vU3RvcmFnZVwiLFxuICAgICAgXCIhZG9jXCI6IFwiU3RvcmUgYW4gaXRlbSBpbiBzdG9yYWdlLlwiXG4gICAgfSxcbiAgICBcImdldEl0ZW1cIjoge1xuICAgICAgXCIhdHlwZVwiOiBcImZuKG5hbWU6IHN0cmluZykgLT4gc3RyaW5nXCIsXG4gICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9TdG9yYWdlXCIsXG4gICAgICBcIiFkb2NcIjogXCJSZXRyaWV2ZSBhbiBpdGVtIGZyb20gc3RvcmFnZS5cIlxuICAgIH0sXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vU3RvcmFnZVwiLFxuICAgIFwiIWRvY1wiOiBcIlRoZSBET00gU3RvcmFnZSBtZWNoYW5pc20gaXMgYSBtZWFucyB0aHJvdWdoIHdoaWNoIHN0cmluZyBrZXkvdmFsdWUgcGFpcnMgY2FuIGJlIHNlY3VyZWx5IHN0b3JlZCBhbmQgbGF0ZXIgcmV0cmlldmVkIGZvciB1c2UuXCJcbiAgfSxcbiAgXCJzZXNzaW9uU3RvcmFnZVwiOiB7XG4gICAgXCJzZXRJdGVtXCI6IHtcbiAgICAgIFwiIXR5cGVcIjogXCJmbihuYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpXCIsXG4gICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9TdG9yYWdlXCIsXG4gICAgICBcIiFkb2NcIjogXCJTdG9yZSBhbiBpdGVtIGluIHN0b3JhZ2UuXCJcbiAgICB9LFxuICAgIFwiZ2V0SXRlbVwiOiB7XG4gICAgICBcIiF0eXBlXCI6IFwiZm4obmFtZTogc3RyaW5nKSAtPiBzdHJpbmdcIixcbiAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL1N0b3JhZ2VcIixcbiAgICAgIFwiIWRvY1wiOiBcIlJldHJpZXZlIGFuIGl0ZW0gZnJvbSBzdG9yYWdlLlwiXG4gICAgfSxcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9TdG9yYWdlXCIsXG4gICAgXCIhZG9jXCI6IFwiVGhpcyBpcyBhIGdsb2JhbCBvYmplY3QgKHNlc3Npb25TdG9yYWdlKSB0aGF0IG1haW50YWlucyBhIHN0b3JhZ2UgYXJlYSB0aGF0J3MgYXZhaWxhYmxlIGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIHBhZ2Ugc2Vzc2lvbi4gQSBwYWdlIHNlc3Npb24gbGFzdHMgZm9yIGFzIGxvbmcgYXMgdGhlIGJyb3dzZXIgaXMgb3BlbiBhbmQgc3Vydml2ZXMgb3ZlciBwYWdlIHJlbG9hZHMgYW5kIHJlc3RvcmVzLiBPcGVuaW5nIGEgcGFnZSBpbiBhIG5ldyB0YWIgb3Igd2luZG93IHdpbGwgY2F1c2UgYSBuZXcgc2Vzc2lvbiB0byBiZSBpbml0aWF0ZWQuXCJcbiAgfSxcbiAgXCJGaWxlTGlzdFwiOiB7XG4gICAgXCIhdHlwZVwiOiBcImZuKClcIixcbiAgICBcInByb3RvdHlwZVwiOiB7XG4gICAgICBcImxlbmd0aFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vRmlsZUxpc3RcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiQSByZWFkLW9ubHkgdmFsdWUgaW5kaWNhdGluZyB0aGUgbnVtYmVyIG9mIGZpbGVzIGluIHRoZSBsaXN0LlwiXG4gICAgICB9LFxuICAgICAgXCJpdGVtXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKGk6IG51bWJlcikgLT4gK0ZpbGVcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vRmlsZUxpc3RcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyBhIEZpbGUgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgZmlsZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4IGluIHRoZSBmaWxlIGxpc3QuXCJcbiAgICAgIH0sXG4gICAgICBcIjxpPlwiOiBcIitGaWxlXCJcbiAgICB9LFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL0ZpbGVMaXN0XCIsXG4gICAgXCIhZG9jXCI6IFwiQW4gb2JqZWN0IG9mIHRoaXMgdHlwZSBpcyByZXR1cm5lZCBieSB0aGUgZmlsZXMgcHJvcGVydHkgb2YgdGhlIEhUTUwgaW5wdXQgZWxlbWVudDsgdGhpcyBsZXRzIHlvdSBhY2Nlc3MgdGhlIGxpc3Qgb2YgZmlsZXMgc2VsZWN0ZWQgd2l0aCB0aGUgPGlucHV0IHR5cGU9XFxcImZpbGVcXFwiPiBlbGVtZW50LiBJdCdzIGFsc28gdXNlZCBmb3IgYSBsaXN0IG9mIGZpbGVzIGRyb3BwZWQgaW50byB3ZWIgY29udGVudCB3aGVuIHVzaW5nIHRoZSBkcmFnIGFuZCBkcm9wIEFQSS5cIlxuICB9LFxuICBcIkZpbGVcIjoge1xuICAgIFwiIXR5cGVcIjogXCJmbigpXCIsXG4gICAgXCJwcm90b3R5cGVcIjoge1xuICAgICAgXCIhcHJvdG9cIjogXCJCbG9iLnByb3RvdHlwZVwiLFxuICAgICAgXCJmaWxlTmFtZVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vRmlsZS5maWxlTmFtZVwiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBmaWxlLiBGb3Igc2VjdXJpdHkgcmVhc29ucyB0aGUgcGF0aCBpcyBleGNsdWRlZCBmcm9tIHRoaXMgcHJvcGVydHkuXCJcbiAgICAgIH0sXG4gICAgICBcImZpbGVTaXplXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9GaWxlLmZpbGVTaXplXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIHNpemUgb2YgYSBmaWxlIGluIGJ5dGVzLlwiXG4gICAgICB9LFxuICAgICAgXCJsYXN0TW9kaWZpZWREYXRlXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIj9cIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vRmlsZS5sYXN0TW9kaWZpZWREYXRlXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIGxhc3QgbW9kaWZpZWQgZGF0ZSBvZiB0aGUgZmlsZS4gRmlsZXMgd2l0aG91dCBhIGtub3duIGxhc3QgbW9kaWZpZWQgZGF0ZSB1c2UgdGhlIGN1cnJlbnQgZGF0ZSBpbnN0ZWFkLlwiXG4gICAgICB9LFxuICAgICAgXCJuYW1lXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9GaWxlLm5hbWVcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgZmlsZS4gRm9yIHNlY3VyaXR5IHJlYXNvbnMsIHRoZSBwYXRoIGlzIGV4Y2x1ZGVkIGZyb20gdGhpcyBwcm9wZXJ0eS5cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vRmlsZVwiLFxuICAgIFwiIWRvY1wiOiBcIlRoZSBGaWxlIG9iamVjdCBwcm92aWRlcyBpbmZvcm1hdGlvbiBhYm91dCAtLSBhbmQgYWNjZXNzIHRvIHRoZSBjb250ZW50cyBvZiAtLSBmaWxlcy4gVGhlc2UgYXJlIGdlbmVyYWxseSByZXRyaWV2ZWQgZnJvbSBhIEZpbGVMaXN0IG9iamVjdCByZXR1cm5lZCBhcyBhIHJlc3VsdCBvZiBhIHVzZXIgc2VsZWN0aW5nIGZpbGVzIHVzaW5nIHRoZSBpbnB1dCBlbGVtZW50LCBvciBmcm9tIGEgZHJhZyBhbmQgZHJvcCBvcGVyYXRpb24ncyBEYXRhVHJhbnNmZXIgb2JqZWN0LlwiXG4gIH0sXG4gIFwiQmxvYlwiOiB7XG4gICAgXCIhdHlwZVwiOiBcImZuKHBhcnRzOiBbP10sIHByb3BlcnRpZXM/OiA/KVwiLFxuICAgIFwicHJvdG90eXBlXCI6IHtcbiAgICAgIFwic2l6ZVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vQmxvYlwiLFxuICAgICAgICBcIiFkb2NcIjogXCJUaGUgc2l6ZSwgaW4gYnl0ZXMsIG9mIHRoZSBkYXRhIGNvbnRhaW5lZCBpbiB0aGUgQmxvYiBvYmplY3QuIFJlYWQgb25seS5cIlxuICAgICAgfSxcbiAgICAgIFwidHlwZVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vQmxvYlwiLFxuICAgICAgICBcIiFkb2NcIjogXCJBbiBBU0NJSS1lbmNvZGVkIHN0cmluZywgaW4gYWxsIGxvd2VyIGNhc2UsIGluZGljYXRpbmcgdGhlIE1JTUUgdHlwZSBvZiB0aGUgZGF0YSBjb250YWluZWQgaW4gdGhlIEJsb2IuIElmIHRoZSB0eXBlIGlzIHVua25vd24sIHRoaXMgc3RyaW5nIGlzIGVtcHR5LiBSZWFkIG9ubHkuXCJcbiAgICAgIH0sXG4gICAgICBcInNsaWNlXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKHN0YXJ0OiBudW1iZXIsIGVuZD86IG51bWJlciwgdHlwZT86IHN0cmluZykgLT4gK0Jsb2JcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vQmxvYlwiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIGEgbmV3IEJsb2Igb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGRhdGEgaW4gdGhlIHNwZWNpZmllZCByYW5nZSBvZiBieXRlcyBvZiB0aGUgc291cmNlIEJsb2IuXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL0Jsb2JcIixcbiAgICBcIiFkb2NcIjogXCJBIEJsb2Igb2JqZWN0IHJlcHJlc2VudHMgYSBmaWxlLWxpa2Ugb2JqZWN0IG9mIGltbXV0YWJsZSwgcmF3IGRhdGEuIEJsb2JzIHJlcHJlc2VudCBkYXRhIHRoYXQgaXNuJ3QgbmVjZXNzYXJpbHkgaW4gYSBKYXZhU2NyaXB0LW5hdGl2ZSBmb3JtYXQuIFRoZSBGaWxlIGludGVyZmFjZSBpcyBiYXNlZCBvbiBCbG9iLCBpbmhlcml0aW5nIGJsb2IgZnVuY3Rpb25hbGl0eSBhbmQgZXhwYW5kaW5nIGl0IHRvIHN1cHBvcnQgZmlsZXMgb24gdGhlIHVzZXIncyBzeXN0ZW0uXCJcbiAgfSxcbiAgXCJGaWxlUmVhZGVyXCI6IHtcbiAgICBcIiF0eXBlXCI6IFwiZm4oKVwiLFxuICAgIFwicHJvdG90eXBlXCI6IHtcbiAgICAgIFwiYWJvcnRcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oKVwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9GaWxlUmVhZGVyXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIkFib3J0cyB0aGUgcmVhZCBvcGVyYXRpb24uIFVwb24gcmV0dXJuLCB0aGUgcmVhZHlTdGF0ZSB3aWxsIGJlIERPTkUuXCJcbiAgICAgIH0sXG4gICAgICBcInJlYWRBc0FycmF5QnVmZmVyXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKGJsb2I6ICtCbG9iKVwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9GaWxlUmVhZGVyXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlN0YXJ0cyByZWFkaW5nIHRoZSBjb250ZW50cyBvZiB0aGUgc3BlY2lmaWVkIEJsb2IsIHByb2R1Y2luZyBhbiBBcnJheUJ1ZmZlci5cIlxuICAgICAgfSxcbiAgICAgIFwicmVhZEFzQmluYXJ5U3RyaW5nXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKGJsb2I6ICtCbG9iKVwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9GaWxlUmVhZGVyXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlN0YXJ0cyByZWFkaW5nIHRoZSBjb250ZW50cyBvZiB0aGUgc3BlY2lmaWVkIEJsb2IsIHByb2R1Y2luZyByYXcgYmluYXJ5IGRhdGEuXCJcbiAgICAgIH0sXG4gICAgICBcInJlYWRBc0RhdGFVUkxcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oYmxvYjogK0Jsb2IpXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL0ZpbGVSZWFkZXJcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiU3RhcnRzIHJlYWRpbmcgdGhlIGNvbnRlbnRzIG9mIHRoZSBzcGVjaWZpZWQgQmxvYiwgcHJvZHVjaW5nIGEgZGF0YTogdXJsLlwiXG4gICAgICB9LFxuICAgICAgXCJyZWFkQXNUZXh0XCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKGJsb2I6ICtCbG9iLCBlbmNvZGluZz86IHN0cmluZylcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vRmlsZVJlYWRlclwiLFxuICAgICAgICBcIiFkb2NcIjogXCJTdGFydHMgcmVhZGluZyB0aGUgY29udGVudHMgb2YgdGhlIHNwZWNpZmllZCBCbG9iLCBwcm9kdWNpbmcgYSBzdHJpbmcuXCJcbiAgICAgIH0sXG4gICAgICBcIkVNUFRZXCI6IFwibnVtYmVyXCIsXG4gICAgICBcIkxPQURJTkdcIjogXCJudW1iZXJcIixcbiAgICAgIFwiRE9ORVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJlcnJvclwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCI/XCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL0ZpbGVSZWFkZXJcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiVGhlIGVycm9yIHRoYXQgb2NjdXJyZWQgd2hpbGUgcmVhZGluZyB0aGUgZmlsZS4gUmVhZCBvbmx5LlwiXG4gICAgICB9LFxuICAgICAgXCJyZWFkeVN0YXRlXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9GaWxlUmVhZGVyXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIkluZGljYXRlcyB0aGUgc3RhdGUgb2YgdGhlIEZpbGVSZWFkZXIuIFRoaXMgd2lsbCBiZSBvbmUgb2YgdGhlIFN0YXRlIGNvbnN0YW50cy4gUmVhZCBvbmx5LlwiXG4gICAgICB9LFxuICAgICAgXCJyZXN1bHRcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiP1wiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9GaWxlUmVhZGVyXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlRoZSBmaWxlJ3MgY29udGVudHMuIFRoaXMgcHJvcGVydHkgaXMgb25seSB2YWxpZCBhZnRlciB0aGUgcmVhZCBvcGVyYXRpb24gaXMgY29tcGxldGUsIGFuZCB0aGUgZm9ybWF0IG9mIHRoZSBkYXRhIGRlcGVuZHMgb24gd2hpY2ggb2YgdGhlIG1ldGhvZHMgd2FzIHVzZWQgdG8gaW5pdGlhdGUgdGhlIHJlYWQgb3BlcmF0aW9uLiBSZWFkIG9ubHkuXCJcbiAgICAgIH0sXG4gICAgICBcIm9uYWJvcnRcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiP1wiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9GaWxlUmVhZGVyXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIkNhbGxlZCB3aGVuIHRoZSByZWFkIG9wZXJhdGlvbiBpcyBhYm9ydGVkLlwiXG4gICAgICB9LFxuICAgICAgXCJvbmVycm9yXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIj9cIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vRmlsZVJlYWRlclwiLFxuICAgICAgICBcIiFkb2NcIjogXCJDYWxsZWQgd2hlbiBhbiBlcnJvciBvY2N1cnMuXCJcbiAgICAgIH0sXG4gICAgICBcIm9ubG9hZFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCI/XCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL0ZpbGVSZWFkZXJcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiQ2FsbGVkIHdoZW4gdGhlIHJlYWQgb3BlcmF0aW9uIGlzIHN1Y2Nlc3NmdWxseSBjb21wbGV0ZWQuXCJcbiAgICAgIH0sXG4gICAgICBcIm9ubG9hZGVuZFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCI/XCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL0ZpbGVSZWFkZXJcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiQ2FsbGVkIHdoZW4gdGhlIHJlYWQgaXMgY29tcGxldGVkLCB3aGV0aGVyIHN1Y2Nlc3NmdWwgb3Igbm90LiBUaGlzIGlzIGNhbGxlZCBhZnRlciBlaXRoZXIgb25sb2FkIG9yIG9uZXJyb3IuXCJcbiAgICAgIH0sXG4gICAgICBcIm9ubG9hZHN0YXJ0XCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIj9cIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vRmlsZVJlYWRlclwiLFxuICAgICAgICBcIiFkb2NcIjogXCJDYWxsZWQgd2hlbiByZWFkaW5nIHRoZSBkYXRhIGlzIGFib3V0IHRvIGJlZ2luLlwiXG4gICAgICB9LFxuICAgICAgXCJvbnByb2dyZXNzXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIj9cIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vRmlsZVJlYWRlclwiLFxuICAgICAgICBcIiFkb2NcIjogXCJDYWxsZWQgcGVyaW9kaWNhbGx5IHdoaWxlIHRoZSBkYXRhIGlzIGJlaW5nIHJlYWQuXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL0ZpbGVSZWFkZXJcIixcbiAgICBcIiFkb2NcIjogXCJUaGUgRmlsZVJlYWRlciBvYmplY3QgbGV0cyB3ZWIgYXBwbGljYXRpb25zIGFzeW5jaHJvbm91c2x5IHJlYWQgdGhlIGNvbnRlbnRzIG9mIGZpbGVzIChvciByYXcgZGF0YSBidWZmZXJzKSBzdG9yZWQgb24gdGhlIHVzZXIncyBjb21wdXRlciwgdXNpbmcgRmlsZSBvciBCbG9iIG9iamVjdHMgdG8gc3BlY2lmeSB0aGUgZmlsZSBvciBkYXRhIHRvIHJlYWQuIEZpbGUgb2JqZWN0cyBtYXkgYmUgb2J0YWluZWQgZnJvbSBhIEZpbGVMaXN0IG9iamVjdCByZXR1cm5lZCBhcyBhIHJlc3VsdCBvZiBhIHVzZXIgc2VsZWN0aW5nIGZpbGVzIHVzaW5nIHRoZSA8aW5wdXQ+IGVsZW1lbnQsIGZyb20gYSBkcmFnIGFuZCBkcm9wIG9wZXJhdGlvbidzIERhdGFUcmFuc2ZlciBvYmplY3QsIG9yIGZyb20gdGhlIG1vekdldEFzRmlsZSgpIEFQSSBvbiBhbiBIVE1MQ2FudmFzRWxlbWVudC5cIlxuICB9LFxuICBcIlJhbmdlXCI6IHtcbiAgICBcIiF0eXBlXCI6IFwiZm4oKVwiLFxuICAgIFwicHJvdG90eXBlXCI6IHtcbiAgICAgIFwiY29sbGFwc2VkXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImJvb2xcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vcmFuZ2UuY29sbGFwc2VkXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgcmFuZ2UncyBzdGFydCBhbmQgZW5kIHBvaW50cyBhcmUgYXQgdGhlIHNhbWUgcG9zaXRpb24uXCJcbiAgICAgIH0sXG4gICAgICBcImNvbW1vbkFuY2VzdG9yQ29udGFpbmVyXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIitFbGVtZW50XCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL3JhbmdlLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIGRlZXBlc3QgTm9kZSB0aGF0IGNvbnRhaW5zIHRoZSAgc3RhcnRDb250YWluZXIgYW5kICBlbmRDb250YWluZXIgTm9kZXMuXCJcbiAgICAgIH0sXG4gICAgICBcImVuZENvbnRhaW5lclwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCIrRWxlbWVudFwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9yYW5nZS5lbmRDb250YWluZXJcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgTm9kZSB3aXRoaW4gd2hpY2ggdGhlIFJhbmdlIGVuZHMuXCJcbiAgICAgIH0sXG4gICAgICBcImVuZE9mZnNldFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vcmFuZ2UuZW5kT2Zmc2V0XCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgYSBudW1iZXIgcmVwcmVzZW50aW5nIHdoZXJlIGluIHRoZSAgZW5kQ29udGFpbmVyIHRoZSBSYW5nZSBlbmRzLlwiXG4gICAgICB9LFxuICAgICAgXCJzdGFydENvbnRhaW5lclwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCIrRWxlbWVudFwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9yYW5nZS5zdGFydENvbnRhaW5lclwiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIHRoZSBOb2RlIHdpdGhpbiB3aGljaCB0aGUgUmFuZ2Ugc3RhcnRzLlwiXG4gICAgICB9LFxuICAgICAgXCJzdGFydE9mZnNldFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vcmFuZ2Uuc3RhcnRPZmZzZXRcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyBhIG51bWJlciByZXByZXNlbnRpbmcgd2hlcmUgaW4gdGhlIHN0YXJ0Q29udGFpbmVyIHRoZSBSYW5nZSBzdGFydHMuXCJcbiAgICAgIH0sXG4gICAgICBcInNldFN0YXJ0XCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKG5vZGU6ICtFbGVtZW50LCBvZmZzZXQ6IG51bWJlcilcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vcmFuZ2Uuc2V0U3RhcnRcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiU2V0cyB0aGUgc3RhcnQgcG9zaXRpb24gb2YgYSBSYW5nZS5cIlxuICAgICAgfSxcbiAgICAgIFwic2V0RW5kXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKG5vZGU6ICtFbGVtZW50LCBvZmZzZXQ6IG51bWJlcilcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vcmFuZ2Uuc2V0RW5kXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlNldHMgdGhlIGVuZCBwb3NpdGlvbiBvZiBhIFJhbmdlLlwiXG4gICAgICB9LFxuICAgICAgXCJzZXRTdGFydEJlZm9yZVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihub2RlOiArRWxlbWVudClcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vcmFuZ2Uuc2V0U3RhcnRCZWZvcmVcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiU2V0cyB0aGUgc3RhcnQgcG9zaXRpb24gb2YgYSBSYW5nZSByZWxhdGl2ZSB0byBhbm90aGVyIE5vZGUuXCJcbiAgICAgIH0sXG4gICAgICBcInNldFN0YXJ0QWZ0ZXJcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4obm9kZTogK0VsZW1lbnQpXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL3JhbmdlLnNldFN0YXJ0QWZ0ZXJcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiU2V0cyB0aGUgc3RhcnQgcG9zaXRpb24gb2YgYSBSYW5nZSByZWxhdGl2ZSB0byBhIE5vZGUuXCJcbiAgICAgIH0sXG4gICAgICBcInNldEVuZEJlZm9yZVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihub2RlOiArRWxlbWVudClcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vcmFuZ2Uuc2V0RW5kQmVmb3JlXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlNldHMgdGhlIGVuZCBwb3NpdGlvbiBvZiBhIFJhbmdlIHJlbGF0aXZlIHRvIGFub3RoZXIgTm9kZS5cIlxuICAgICAgfSxcbiAgICAgIFwic2V0RW5kQWZ0ZXJcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4obm9kZTogK0VsZW1lbnQpXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL3JhbmdlLnNldEVuZEFmdGVyXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlNldHMgdGhlIGVuZCBwb3NpdGlvbiBvZiBhIFJhbmdlIHJlbGF0aXZlIHRvIGFub3RoZXIgTm9kZS5cIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0Tm9kZVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihub2RlOiArRWxlbWVudClcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vcmFuZ2Uuc2VsZWN0Tm9kZVwiLFxuICAgICAgICBcIiFkb2NcIjogXCJTZXRzIHRoZSBSYW5nZSB0byBjb250YWluIHRoZSBOb2RlIGFuZCBpdHMgY29udGVudHMuXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdE5vZGVDb250ZW50c1wiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihub2RlOiArRWxlbWVudClcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlNldHMgdGhlIFJhbmdlIHRvIGNvbnRhaW4gdGhlIGNvbnRlbnRzIG9mIGEgTm9kZS5cIlxuICAgICAgfSxcbiAgICAgIFwiY29sbGFwc2VcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4odG9TdGFydDogYm9vbClcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vcmFuZ2UuY29sbGFwc2VcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiQ29sbGFwc2VzIHRoZSBSYW5nZSB0byBvbmUgb2YgaXRzIGJvdW5kYXJ5IHBvaW50cy5cIlxuICAgICAgfSxcbiAgICAgIFwiY2xvbmVDb250ZW50c1wiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbigpIC0+ICtEb2N1bWVudEZyYWdtZW50XCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL3JhbmdlLmNsb25lQ29udGVudHNcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyBhIERvY3VtZW50RnJhZ21lbnQgY29weWluZyB0aGUgTm9kZXMgb2YgYSBSYW5nZS5cIlxuICAgICAgfSxcbiAgICAgIFwiZGVsZXRlQ29udGVudHNcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oKVwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9yYW5nZS5kZWxldGVDb250ZW50c1wiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZW1vdmVzIHRoZSBjb250ZW50cyBvZiBhIFJhbmdlIGZyb20gdGhlIERvY3VtZW50LlwiXG4gICAgICB9LFxuICAgICAgXCJleHRyYWN0Q29udGVudHNcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oKSAtPiArRG9jdW1lbnRGcmFnbWVudFwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9yYW5nZS5leHRyYWN0Q29udGVudHNcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiTW92ZXMgY29udGVudHMgb2YgYSBSYW5nZSBmcm9tIHRoZSBkb2N1bWVudCB0cmVlIGludG8gYSBEb2N1bWVudEZyYWdtZW50LlwiXG4gICAgICB9LFxuICAgICAgXCJpbnNlcnROb2RlXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKG5vZGU6ICtFbGVtZW50KVwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9yYW5nZS5pbnNlcnROb2RlXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIkluc2VydCBhIG5vZGUgYXQgdGhlIHN0YXJ0IG9mIGEgUmFuZ2UuXCJcbiAgICAgIH0sXG4gICAgICBcInN1cnJvdW5kQ29udGVudHNcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4obm9kZTogK0VsZW1lbnQpXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL3JhbmdlLnN1cnJvdW5kQ29udGVudHNcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiTW92ZXMgY29udGVudCBvZiBhIFJhbmdlIGludG8gYSBuZXcgbm9kZSwgcGxhY2luZyB0aGUgbmV3IG5vZGUgYXQgdGhlIHN0YXJ0IG9mIHRoZSBzcGVjaWZpZWQgcmFuZ2UuXCJcbiAgICAgIH0sXG4gICAgICBcImNvbXBhcmVCb3VuZGFyeVBvaW50c1wiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihob3c6IG51bWJlciwgb3RoZXI6ICtSYW5nZSkgLT4gbnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL3JhbmdlLmNvbXBhcmVCb3VuZGFyeVBvaW50c1wiLFxuICAgICAgICBcIiFkb2NcIjogXCJDb21wYXJlcyB0aGUgYm91bmRhcnkgcG9pbnRzIG9mIHR3byBSYW5nZXMuXCJcbiAgICAgIH0sXG4gICAgICBcImNsb25lUmFuZ2VcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oKSAtPiArUmFuZ2VcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vcmFuZ2UuY2xvbmVSYW5nZVwiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIGEgUmFuZ2Ugb2JqZWN0IHdpdGggYm91bmRhcnkgcG9pbnRzIGlkZW50aWNhbCB0byB0aGUgY2xvbmVkIFJhbmdlLlwiXG4gICAgICB9LFxuICAgICAgXCJkZXRhY2hcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oKVwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9yYW5nZS5kZXRhY2hcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmVsZWFzZXMgYSBSYW5nZSBmcm9tIHVzZSB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLiBUaGlzIGxldHMgdGhlIGJyb3dzZXIgY2hvb3NlIHRvIHJlbGVhc2UgcmVzb3VyY2VzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIFJhbmdlLiBTdWJzZXF1ZW50IGF0dGVtcHRzIHRvIHVzZSB0aGUgZGV0YWNoZWQgcmFuZ2Ugd2lsbCByZXN1bHQgaW4gYSBET01FeGNlcHRpb24gYmVpbmcgdGhyb3duIHdpdGggYW4gZXJyb3IgY29kZSBvZiBJTlZBTElEX1NUQVRFX0VSUi5cIlxuICAgICAgfSxcbiAgICAgIFwiRU5EX1RPX0VORFwiOiBcIm51bWJlclwiLFxuICAgICAgXCJFTkRfVE9fU1RBUlRcIjogXCJudW1iZXJcIixcbiAgICAgIFwiU1RBUlRfVE9fRU5EXCI6IFwibnVtYmVyXCIsXG4gICAgICBcIlNUQVJUX1RPX1NUQVJUXCI6IFwibnVtYmVyXCJcbiAgICB9LFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL3JhbmdlLmRldGFjaFwiLFxuICAgIFwiIWRvY1wiOiBcIlJlbGVhc2VzIGEgUmFuZ2UgZnJvbSB1c2UgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZS4gVGhpcyBsZXRzIHRoZSBicm93c2VyIGNob29zZSB0byByZWxlYXNlIHJlc291cmNlcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBSYW5nZS4gU3Vic2VxdWVudCBhdHRlbXB0cyB0byB1c2UgdGhlIGRldGFjaGVkIHJhbmdlIHdpbGwgcmVzdWx0IGluIGEgRE9NRXhjZXB0aW9uIGJlaW5nIHRocm93biB3aXRoIGFuIGVycm9yIGNvZGUgb2YgSU5WQUxJRF9TVEFURV9FUlIuXCJcbiAgfSxcbiAgXCJYTUxIdHRwUmVxdWVzdFwiOiB7XG4gICAgXCIhdHlwZVwiOiBcImZuKClcIixcbiAgICBcInByb3RvdHlwZVwiOiB7XG4gICAgICBcImFib3J0XCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKClcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vWE1MSHR0cFJlcXVlc3RcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiQWJvcnRzIHRoZSByZXF1ZXN0IGlmIGl0IGhhcyBhbHJlYWR5IGJlZW4gc2VudC5cIlxuICAgICAgfSxcbiAgICAgIFwiZ2V0QWxsUmVzcG9uc2VIZWFkZXJzXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKCkgLT4gc3RyaW5nXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL1hNTEh0dHBSZXF1ZXN0XCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgYWxsIHRoZSByZXNwb25zZSBoZWFkZXJzIGFzIGEgc3RyaW5nLCBvciBudWxsIGlmIG5vIHJlc3BvbnNlIGhhcyBiZWVuIHJlY2VpdmVkLiBOb3RlOiBGb3IgbXVsdGlwYXJ0IHJlcXVlc3RzLCB0aGlzIHJldHVybnMgdGhlIGhlYWRlcnMgZnJvbSB0aGUgY3VycmVudCBwYXJ0IG9mIHRoZSByZXF1ZXN0LCBub3QgZnJvbSB0aGUgb3JpZ2luYWwgY2hhbm5lbC5cIlxuICAgICAgfSxcbiAgICAgIFwiZ2V0UmVzcG9uc2VIZWFkZXJcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oaGVhZGVyOiBzdHJpbmcpIC0+IHN0cmluZ1wiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9YTUxIdHRwUmVxdWVzdFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIHRoZSBzdHJpbmcgY29udGFpbmluZyB0aGUgdGV4dCBvZiB0aGUgc3BlY2lmaWVkIGhlYWRlciwgb3IgbnVsbCBpZiBlaXRoZXIgdGhlIHJlc3BvbnNlIGhhcyBub3QgeWV0IGJlZW4gcmVjZWl2ZWQgb3IgdGhlIGhlYWRlciBkb2Vzbid0IGV4aXN0IGluIHRoZSByZXNwb25zZS5cIlxuICAgICAgfSxcbiAgICAgIFwib3BlblwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihtZXRob2Q6IHN0cmluZywgdXJsOiBzdHJpbmcsIGFzeW5jPzogYm9vbCwgdXNlcj86IHN0cmluZywgcGFzc3dvcmQ/OiBzdHJpbmcpXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL1hNTEh0dHBSZXF1ZXN0XCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIkluaXRpYWxpemVzIGEgcmVxdWVzdC5cIlxuICAgICAgfSxcbiAgICAgIFwib3ZlcnJpZGVNaW1lVHlwZVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbih0eXBlOiBzdHJpbmcpXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL1hNTEh0dHBSZXF1ZXN0XCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIk92ZXJyaWRlcyB0aGUgTUlNRSB0eXBlIHJldHVybmVkIGJ5IHRoZSBzZXJ2ZXIuXCJcbiAgICAgIH0sXG4gICAgICBcInNlbmRcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oZGF0YT86IHN0cmluZylcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vWE1MSHR0cFJlcXVlc3RcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiU2VuZHMgdGhlIHJlcXVlc3QuIElmIHRoZSByZXF1ZXN0IGlzIGFzeW5jaHJvbm91cyAod2hpY2ggaXMgdGhlIGRlZmF1bHQpLCB0aGlzIG1ldGhvZCByZXR1cm5zIGFzIHNvb24gYXMgdGhlIHJlcXVlc3QgaXMgc2VudC4gSWYgdGhlIHJlcXVlc3QgaXMgc3luY2hyb25vdXMsIHRoaXMgbWV0aG9kIGRvZXNuJ3QgcmV0dXJuIHVudGlsIHRoZSByZXNwb25zZSBoYXMgYXJyaXZlZC5cIlxuICAgICAgfSxcbiAgICAgIFwic2V0UmVxdWVzdEhlYWRlclwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihoZWFkZXI6IHN0cmluZywgdmFsdWU6IHN0cmluZylcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vWE1MSHR0cFJlcXVlc3RcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiU2V0cyB0aGUgdmFsdWUgb2YgYW4gSFRUUCByZXF1ZXN0IGhlYWRlci5Zb3UgbXVzdCBjYWxsIHNldFJlcXVlc3RIZWFkZXIoKSBhZnRlciBvcGVuKCksIGJ1dCBiZWZvcmUgc2VuZCgpLlwiXG4gICAgICB9LFxuICAgICAgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oKVwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9YTUxIdHRwUmVxdWVzdFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJBIEphdmFTY3JpcHQgZnVuY3Rpb24gb2JqZWN0IHRoYXQgaXMgY2FsbGVkIHdoZW5ldmVyIHRoZSByZWFkeVN0YXRlIGF0dHJpYnV0ZSBjaGFuZ2VzLlwiXG4gICAgICB9LFxuICAgICAgXCJyZWFkeVN0YXRlXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9YTUxIdHRwUmVxdWVzdFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJUaGUgc3RhdGUgb2YgdGhlIHJlcXVlc3QuICgwPXVuc2VudCwgMT1vcGVuZWQsIDI9aGVhZGVyc19yZWNlaXZlZCwgMz1sb2FkaW5nLCA0PWRvbmUpXCJcbiAgICAgIH0sXG4gICAgICBcInJlc3BvbnNlXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIitEb2N1bWVudFwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9YTUxIdHRwUmVxdWVzdFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJUaGUgcmVzcG9uc2UgZW50aXR5IGJvZHkgYWNjb3JkaW5nIHRvIHJlc3BvbnNlVHlwZSwgYXMgYW4gQXJyYXlCdWZmZXIsIEJsb2IsIERvY3VtZW50LCBKYXZhU2NyaXB0IG9iamVjdCAoZm9yIFxcXCJqc29uXFxcIiksIG9yIHN0cmluZy4gVGhpcyBpcyBudWxsIGlmIHRoZSByZXF1ZXN0IGlzIG5vdCBjb21wbGV0ZSBvciB3YXMgbm90IHN1Y2Nlc3NmdWwuXCJcbiAgICAgIH0sXG4gICAgICBcInJlc3BvbnNlVGV4dFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vWE1MSHR0cFJlcXVlc3RcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiVGhlIHJlc3BvbnNlIHRvIHRoZSByZXF1ZXN0IGFzIHRleHQsIG9yIG51bGwgaWYgdGhlIHJlcXVlc3Qgd2FzIHVuc3VjY2Vzc2Z1bCBvciBoYXMgbm90IHlldCBiZWVuIHNlbnQuXCJcbiAgICAgIH0sXG4gICAgICBcInJlc3BvbnNlVHlwZVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vWE1MSHR0cFJlcXVlc3RcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiQ2FuIGJlIHNldCB0byBjaGFuZ2UgdGhlIHJlc3BvbnNlIHR5cGUuXCJcbiAgICAgIH0sXG4gICAgICBcInJlc3BvbnNlWE1MXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIitEb2N1bWVudFwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9YTUxIdHRwUmVxdWVzdFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJUaGUgcmVzcG9uc2UgdG8gdGhlIHJlcXVlc3QgYXMgYSBET00gRG9jdW1lbnQgb2JqZWN0LCBvciBudWxsIGlmIHRoZSByZXF1ZXN0IHdhcyB1bnN1Y2Nlc3NmdWwsIGhhcyBub3QgeWV0IGJlZW4gc2VudCwgb3IgY2Fubm90IGJlIHBhcnNlZCBhcyBYTUwgb3IgSFRNTC5cIlxuICAgICAgfSxcbiAgICAgIFwic3RhdHVzXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9YTUxIdHRwUmVxdWVzdFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJUaGUgc3RhdHVzIG9mIHRoZSByZXNwb25zZSB0byB0aGUgcmVxdWVzdC4gVGhpcyBpcyB0aGUgSFRUUCByZXN1bHQgY29kZVwiXG4gICAgICB9LFxuICAgICAgXCJzdGF0dXNUZXh0XCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9YTUxIdHRwUmVxdWVzdFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJUaGUgcmVzcG9uc2Ugc3RyaW5nIHJldHVybmVkIGJ5IHRoZSBIVFRQIHNlcnZlci4gVW5saWtlIHN0YXR1cywgdGhpcyBpbmNsdWRlcyB0aGUgZW50aXJlIHRleHQgb2YgdGhlIHJlc3BvbnNlIG1lc3NhZ2UgKFxcXCIyMDAgT0tcXFwiLCBmb3IgZXhhbXBsZSkuXCJcbiAgICAgIH0sXG4gICAgICBcInRpbWVvdXRcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL1hNTEh0dHBSZXF1ZXN0L1N5bmNocm9ub3VzX2FuZF9Bc3luY2hyb25vdXNfUmVxdWVzdHNcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgYSByZXF1ZXN0IGNhbiB0YWtlIGJlZm9yZSBhdXRvbWF0aWNhbGx5IGJlaW5nIHRlcm1pbmF0ZWQuIEEgdmFsdWUgb2YgMCAod2hpY2ggaXMgdGhlIGRlZmF1bHQpIG1lYW5zIHRoZXJlIGlzIG5vIHRpbWVvdXQuXCJcbiAgICAgIH0sXG4gICAgICBcIlVOU0VOVFwiOiBcIm51bWJlclwiLFxuICAgICAgXCJPUEVORURcIjogXCJudW1iZXJcIixcbiAgICAgIFwiSEVBREVSU19SRUNFSVZFRFwiOiBcIm51bWJlclwiLFxuICAgICAgXCJMT0FESU5HXCI6IFwibnVtYmVyXCIsXG4gICAgICBcIkRPTkVcIjogXCJudW1iZXJcIlxuICAgIH0sXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vWE1MSHR0cFJlcXVlc3RcIixcbiAgICBcIiFkb2NcIjogXCJYTUxIdHRwUmVxdWVzdCBpcyBhIEphdmFTY3JpcHQgb2JqZWN0IHRoYXQgd2FzIGRlc2lnbmVkIGJ5IE1pY3Jvc29mdCBhbmQgYWRvcHRlZCBieSBNb3ppbGxhLCBBcHBsZSwgYW5kIEdvb2dsZS4gSXQncyBub3cgYmVpbmcgc3RhbmRhcmRpemVkIGluIHRoZSBXM0MuIEl0IHByb3ZpZGVzIGFuIGVhc3kgd2F5IHRvIHJldHJpZXZlIGRhdGEgYXQgYSBVUkwuIERlc3BpdGUgaXRzIG5hbWUsIFhNTEh0dHBSZXF1ZXN0IGNhbiBiZSB1c2VkIHRvIHJldHJpZXZlIGFueSB0eXBlIG9mIGRhdGEsIG5vdCBqdXN0IFhNTCwgYW5kIGl0IHN1cHBvcnRzIHByb3RvY29scyBvdGhlciB0aGFuIEhUVFAgKGluY2x1ZGluZyBmaWxlIGFuZCBmdHApLlwiXG4gIH0sXG4gIFwiRE9NUGFyc2VyXCI6IHtcbiAgICBcIiF0eXBlXCI6IFwiZm4oKVwiLFxuICAgIFwicHJvdG90eXBlXCI6IHtcbiAgICAgIFwicGFyc2VGcm9tU3RyaW5nXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKGRhdGE6IHN0cmluZywgbWltZTogc3RyaW5nKSAtPiArRG9jdW1lbnRcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vRE9NUGFyc2VyXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIkRPTVBhcnNlciBjYW4gcGFyc2UgWE1MIG9yIEhUTUwgc291cmNlIHN0b3JlZCBpbiBhIHN0cmluZyBpbnRvIGEgRE9NIERvY3VtZW50LiBET01QYXJzZXIgaXMgc3BlY2lmaWVkIGluIERPTSBQYXJzaW5nIGFuZCBTZXJpYWxpemF0aW9uLlwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9ET01QYXJzZXJcIixcbiAgICBcIiFkb2NcIjogXCJET01QYXJzZXIgY2FuIHBhcnNlIFhNTCBvciBIVE1MIHNvdXJjZSBzdG9yZWQgaW4gYSBzdHJpbmcgaW50byBhIERPTSBEb2N1bWVudC4gRE9NUGFyc2VyIGlzIHNwZWNpZmllZCBpbiBET00gUGFyc2luZyBhbmQgU2VyaWFsaXphdGlvbi5cIlxuICB9LFxuICBcIlNlbGVjdGlvblwiOiB7XG4gICAgXCIhdHlwZVwiOiBcImZuKClcIixcbiAgICBcInByb3RvdHlwZVwiOiB7XG4gICAgICBcImFuY2hvck5vZGVcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiK0VsZW1lbnRcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vU2VsZWN0aW9uL2FuY2hvck5vZGVcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgbm9kZSBpbiB3aGljaCB0aGUgc2VsZWN0aW9uIGJlZ2lucy5cIlxuICAgICAgfSxcbiAgICAgIFwiYW5jaG9yT2Zmc2V0XCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9TZWxlY3Rpb24vYW5jaG9yT2Zmc2V0XCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRoYXQgdGhlIHNlbGVjdGlvbidzIGFuY2hvciBpcyBvZmZzZXQgd2l0aGluIHRoZSBhbmNob3JOb2RlLlwiXG4gICAgICB9LFxuICAgICAgXCJmb2N1c05vZGVcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiK0VsZW1lbnRcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vU2VsZWN0aW9uL2ZvY3VzTm9kZVwiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIHRoZSBub2RlIGluIHdoaWNoIHRoZSBzZWxlY3Rpb24gZW5kcy5cIlxuICAgICAgfSxcbiAgICAgIFwiZm9jdXNPZmZzZXRcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL1NlbGVjdGlvbi9mb2N1c09mZnNldFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyB0aGF0IHRoZSBzZWxlY3Rpb24ncyBmb2N1cyBpcyBvZmZzZXQgd2l0aGluIHRoZSBmb2N1c05vZGUuIFwiXG4gICAgICB9LFxuICAgICAgXCJpc0NvbGxhcHNlZFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJib29sXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL1NlbGVjdGlvbi9pc0NvbGxhcHNlZFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHNlbGVjdGlvbidzIHN0YXJ0IGFuZCBlbmQgcG9pbnRzIGFyZSBhdCB0aGUgc2FtZSBwb3NpdGlvbi5cIlxuICAgICAgfSxcbiAgICAgIFwicmFuZ2VDb3VudFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vU2VsZWN0aW9uL3JhbmdlQ291bnRcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgbnVtYmVyIG9mIHJhbmdlcyBpbiB0aGUgc2VsZWN0aW9uLlwiXG4gICAgICB9LFxuICAgICAgXCJnZXRSYW5nZUF0XCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKGk6IG51bWJlcikgLT4gK1JhbmdlXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL1NlbGVjdGlvbi9nZXRSYW5nZUF0XCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgYSByYW5nZSBvYmplY3QgcmVwcmVzZW50aW5nIG9uZSBvZiB0aGUgcmFuZ2VzIGN1cnJlbnRseSBzZWxlY3RlZC5cIlxuICAgICAgfSxcbiAgICAgIFwiY29sbGFwc2VcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oKVwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9TZWxlY3Rpb24vY29sbGFwc2VcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiQ29sbGFwc2VzIHRoZSBjdXJyZW50IHNlbGVjdGlvbiB0byBhIHNpbmdsZSBwb2ludC4gVGhlIGRvY3VtZW50IGlzIG5vdCBtb2RpZmllZC4gSWYgdGhlIGNvbnRlbnQgaXMgZm9jdXNlZCBhbmQgZWRpdGFibGUsIHRoZSBjYXJldCB3aWxsIGJsaW5rIHRoZXJlLlwiXG4gICAgICB9LFxuICAgICAgXCJleHRlbmRcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4obm9kZTogK0VsZW1lbnQsIG9mZnNldDogbnVtYmVyKVwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9TZWxlY3Rpb24vZXh0ZW5kXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIk1vdmVzIHRoZSBmb2N1cyBvZiB0aGUgc2VsZWN0aW9uIHRvIGEgc3BlY2lmaWVkIHBvaW50LiBUaGUgYW5jaG9yIG9mIHRoZSBzZWxlY3Rpb24gZG9lcyBub3QgbW92ZS4gVGhlIHNlbGVjdGlvbiB3aWxsIGJlIGZyb20gdGhlIGFuY2hvciB0byB0aGUgbmV3IGZvY3VzIHJlZ2FyZGxlc3Mgb2YgZGlyZWN0aW9uLlwiXG4gICAgICB9LFxuICAgICAgXCJjb2xsYXBzZVRvU3RhcnRcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oKVwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9TZWxlY3Rpb24vY29sbGFwc2VUb1N0YXJ0XCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIkNvbGxhcHNlcyB0aGUgc2VsZWN0aW9uIHRvIHRoZSBzdGFydCBvZiB0aGUgZmlyc3QgcmFuZ2UgaW4gdGhlIHNlbGVjdGlvbi4gIElmIHRoZSBjb250ZW50IG9mIHRoZSBzZWxlY3Rpb24gaXMgZm9jdXNlZCBhbmQgZWRpdGFibGUsIHRoZSBjYXJldCB3aWxsIGJsaW5rIHRoZXJlLlwiXG4gICAgICB9LFxuICAgICAgXCJjb2xsYXBzZVRvRW5kXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKClcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vU2VsZWN0aW9uL2NvbGxhcHNlVG9FbmRcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiQ29sbGFwc2VzIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGVuZCBvZiB0aGUgbGFzdCByYW5nZSBpbiB0aGUgc2VsZWN0aW9uLiAgSWYgdGhlIGNvbnRlbnQgdGhlIHNlbGVjdGlvbiBpcyBpbiBpcyBmb2N1c2VkIGFuZCBlZGl0YWJsZSwgdGhlIGNhcmV0IHdpbGwgYmxpbmsgdGhlcmUuXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdEFsbENoaWxkcmVuXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKG5vZGU6ICtFbGVtZW50KVwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9TZWxlY3Rpb24vc2VsZWN0QWxsQ2hpbGRyZW5cIixcbiAgICAgICAgXCIhZG9jXCI6IFwiQWRkcyBhbGwgdGhlIGNoaWxkcmVuIG9mIHRoZSBzcGVjaWZpZWQgbm9kZSB0byB0aGUgc2VsZWN0aW9uLiBQcmV2aW91cyBzZWxlY3Rpb24gaXMgbG9zdC5cIlxuICAgICAgfSxcbiAgICAgIFwiYWRkUmFuZ2VcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4ocmFuZ2U6ICtSYW5nZSlcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vU2VsZWN0aW9uL2FkZFJhbmdlXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIkFkZHMgYSBSYW5nZSB0byBhIFNlbGVjdGlvbi5cIlxuICAgICAgfSxcbiAgICAgIFwicmVtb3ZlUmFuZ2VcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4ocmFuZ2U6ICtSYW5nZSlcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vU2VsZWN0aW9uL3JlbW92ZVJhbmdlXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJlbW92ZXMgYSByYW5nZSBmcm9tIHRoZSBzZWxlY3Rpb24uXCJcbiAgICAgIH0sXG4gICAgICBcInJlbW92ZUFsbFJhbmdlc1wiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbigpXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL1NlbGVjdGlvbi9yZW1vdmVBbGxSYW5nZXNcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmVtb3ZlcyBhbGwgcmFuZ2VzIGZyb20gdGhlIHNlbGVjdGlvbiwgbGVhdmluZyB0aGUgYW5jaG9yTm9kZSBhbmQgZm9jdXNOb2RlIHByb3BlcnRpZXMgZXF1YWwgdG8gbnVsbCBhbmQgbGVhdmluZyBub3RoaW5nIHNlbGVjdGVkLiBcIlxuICAgICAgfSxcbiAgICAgIFwiZGVsZXRlRnJvbURvY3VtZW50XCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKClcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vU2VsZWN0aW9uL2RlbGV0ZUZyb21Eb2N1bWVudFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJEZWxldGVzIHRoZSBhY3R1YWwgdGV4dCBiZWluZyByZXByZXNlbnRlZCBieSBhIHNlbGVjdGlvbiBvYmplY3QgZnJvbSB0aGUgZG9jdW1lbnQncyBET00uXCJcbiAgICAgIH0sXG4gICAgICBcImNvbnRhaW5zTm9kZVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihub2RlOiArRWxlbWVudCkgLT4gYm9vbFwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9TZWxlY3Rpb24vY29udGFpbnNOb2RlXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIkluZGljYXRlcyBpZiB0aGUgbm9kZSBpcyBwYXJ0IG9mIHRoZSBzZWxlY3Rpb24uXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL1NlbGVjdGlvblwiLFxuICAgIFwiIWRvY1wiOiBcIlNlbGVjdGlvbiBpcyB0aGUgY2xhc3Mgb2YgdGhlIG9iamVjdCByZXR1cm5lZCBieSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkgYW5kIG90aGVyIG1ldGhvZHMuIEl0IHJlcHJlc2VudHMgdGhlIHRleHQgc2VsZWN0aW9uIGluIHRoZSBncmVhdGVyIHBhZ2UsIHBvc3NpYmx5IHNwYW5uaW5nIG11bHRpcGxlIGVsZW1lbnRzLCB3aGVuIHRoZSB1c2VyIGRyYWdzIG92ZXIgc3RhdGljIHRleHQgYW5kIG90aGVyIHBhcnRzIG9mIHRoZSBwYWdlLiBGb3IgaW5mb3JtYXRpb24gYWJvdXQgdGV4dCBzZWxlY3Rpb24gaW4gYW4gaW5kaXZpZHVhbCB0ZXh0IGVkaXRpbmcgZWxlbWVudC5cIlxuICB9LFxuICBcImNvbnNvbGVcIjoge1xuICAgIFwiZXJyb3JcIjoge1xuICAgICAgXCIhdHlwZVwiOiBcImZuKHRleHQ6IHN0cmluZylcIixcbiAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2NvbnNvbGUuZXJyb3JcIixcbiAgICAgIFwiIWRvY1wiOiBcIk91dHB1dHMgYW4gZXJyb3IgbWVzc2FnZSB0byB0aGUgV2ViIENvbnNvbGUuXCJcbiAgICB9LFxuICAgIFwiaW5mb1wiOiB7XG4gICAgICBcIiF0eXBlXCI6IFwiZm4odGV4dDogc3RyaW5nKVwiLFxuICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vY29uc29sZS5pbmZvXCIsXG4gICAgICBcIiFkb2NcIjogXCJPdXRwdXRzIGFuIGluZm9ybWF0aW9uYWwgbWVzc2FnZSB0byB0aGUgV2ViIENvbnNvbGUuXCJcbiAgICB9LFxuICAgIFwibG9nXCI6IHtcbiAgICAgIFwiIXR5cGVcIjogXCJmbih0ZXh0OiBzdHJpbmcpXCIsXG4gICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9jb25zb2xlLmxvZ1wiLFxuICAgICAgXCIhZG9jXCI6IFwiT3V0cHV0cyBhIG1lc3NhZ2UgdG8gdGhlIFdlYiBDb25zb2xlLlwiXG4gICAgfSxcbiAgICBcIndhcm5cIjoge1xuICAgICAgXCIhdHlwZVwiOiBcImZuKHRleHQ6IHN0cmluZylcIixcbiAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2NvbnNvbGUud2FyblwiLFxuICAgICAgXCIhZG9jXCI6IFwiT3V0cHV0cyBhIHdhcm5pbmcgbWVzc2FnZSB0byB0aGUgV2ViIENvbnNvbGUuXCJcbiAgICB9LFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2NvbnNvbGVcIixcbiAgICBcIiFkb2NcIjogXCJUaGUgY29uc29sZSBvYmplY3QgcHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBicm93c2VyJ3MgZGVidWdnaW5nIGNvbnNvbGUuIFRoZSBzcGVjaWZpY3Mgb2YgaG93IGl0IHdvcmtzIHZhcnkgZnJvbSBicm93c2VyIHRvIGJyb3dzZXIsIGJ1dCB0aGVyZSBpcyBhIGRlIGZhY3RvIHNldCBvZiBmZWF0dXJlcyB0aGF0IGFyZSB0eXBpY2FsbHkgcHJvdmlkZWQuXCJcbiAgfSxcbiAgXCJ0b3BcIjoge1xuICAgIFwiIXR5cGVcIjogXCI8dG9wPlwiLFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL3dpbmRvdy50b3BcIixcbiAgICBcIiFkb2NcIjogXCJSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSB0b3Btb3N0IHdpbmRvdyBpbiB0aGUgd2luZG93IGhpZXJhcmNoeS5cIlxuICB9LFxuICBcInBhcmVudFwiOiB7XG4gICAgXCIhdHlwZVwiOiBcIjx0b3A+XCIsXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vd2luZG93LnBhcmVudFwiLFxuICAgIFwiIWRvY1wiOiBcIkEgcmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgb2YgdGhlIGN1cnJlbnQgd2luZG93IG9yIHN1YmZyYW1lLlwiXG4gIH0sXG4gIFwid2luZG93XCI6IHtcbiAgICBcIiF0eXBlXCI6IFwiPHRvcD5cIixcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS93aW5kb3dcIixcbiAgICBcIiFkb2NcIjogXCJUaGlzIHNlY3Rpb24gcHJvdmlkZXMgYSBicmllZiByZWZlcmVuY2UgZm9yIGFsbCBvZiB0aGUgbWV0aG9kcywgcHJvcGVydGllcywgYW5kIGV2ZW50cyBhdmFpbGFibGUgdGhyb3VnaCB0aGUgRE9NIHdpbmRvdyBvYmplY3QuIFRoZSB3aW5kb3cgb2JqZWN0IGltcGxlbWVudHMgdGhlIFdpbmRvdyBpbnRlcmZhY2UsIHdoaWNoIGluIHR1cm4gaW5oZXJpdHMgZnJvbSB0aGUgQWJzdHJhY3RWaWV3IGludGVyZmFjZS4gU29tZSBhZGRpdGlvbmFsIGdsb2JhbCBmdW5jdGlvbnMsIG5hbWVzcGFjZXMgb2JqZWN0cywgYW5kIGNvbnN0cnVjdG9ycywgbm90IHR5cGljYWxseSBhc3NvY2lhdGVkIHdpdGggdGhlIHdpbmRvdywgYnV0IGF2YWlsYWJsZSBvbiBpdCwgYXJlIGxpc3RlZCBpbiB0aGUgSmF2YVNjcmlwdCBSZWZlcmVuY2UuXCJcbiAgfSxcbiAgXCJvcGVuZXJcIjoge1xuICAgIFwiIXR5cGVcIjogXCI8dG9wPlwiLFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL3dpbmRvdy5vcGVuZXJcIixcbiAgICBcIiFkb2NcIjogXCJSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSB3aW5kb3cgdGhhdCBvcGVuZWQgdGhpcyBjdXJyZW50IHdpbmRvdy5cIlxuICB9LFxuICBcInNlbGZcIjoge1xuICAgIFwiIXR5cGVcIjogXCI8dG9wPlwiLFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL3dpbmRvdy5zZWxmXCIsXG4gICAgXCIhZG9jXCI6IFwiUmV0dXJucyBhbiBvYmplY3QgcmVmZXJlbmNlIHRvIHRoZSB3aW5kb3cgb2JqZWN0LiBcIlxuICB9LFxuICBcImRldmljZVBpeGVsUmF0aW9cIjogXCJudW1iZXJcIixcbiAgXCJuYW1lXCI6IHtcbiAgICBcIiF0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9uYW1lXCIsXG4gICAgXCIhZG9jXCI6IFwiVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uLlwiXG4gIH0sXG4gIFwiY2xvc2VkXCI6IHtcbiAgICBcIiF0eXBlXCI6IFwiYm9vbFwiLFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL3dpbmRvdy5jbG9zZWRcIixcbiAgICBcIiFkb2NcIjogXCJUaGlzIHByb3BlcnR5IGluZGljYXRlcyB3aGV0aGVyIHRoZSByZWZlcmVuY2VkIHdpbmRvdyBpcyBjbG9zZWQgb3Igbm90LlwiXG4gIH0sXG4gIFwicGFnZVlPZmZzZXRcIjoge1xuICAgIFwiIXR5cGVcIjogXCJudW1iZXJcIixcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS93aW5kb3cuc2Nyb2xsWVwiLFxuICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIG51bWJlciBvZiBwaXhlbHMgdGhhdCB0aGUgZG9jdW1lbnQgaGFzIGFscmVhZHkgYmVlbiBzY3JvbGxlZCB2ZXJ0aWNhbGx5LlwiXG4gIH0sXG4gIFwicGFnZVhPZmZzZXRcIjoge1xuICAgIFwiIXR5cGVcIjogXCJudW1iZXJcIixcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS93aW5kb3cuc2Nyb2xsWFwiLFxuICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIG51bWJlciBvZiBwaXhlbHMgdGhhdCB0aGUgZG9jdW1lbnQgaGFzIGFscmVhZHkgYmVlbiBzY3JvbGxlZCB2ZXJ0aWNhbGx5LlwiXG4gIH0sXG4gIFwic2Nyb2xsWVwiOiB7XG4gICAgXCIhdHlwZVwiOiBcIm51bWJlclwiLFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL3dpbmRvdy5zY3JvbGxZXCIsXG4gICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgbnVtYmVyIG9mIHBpeGVscyB0aGF0IHRoZSBkb2N1bWVudCBoYXMgYWxyZWFkeSBiZWVuIHNjcm9sbGVkIHZlcnRpY2FsbHkuXCJcbiAgfSxcbiAgXCJzY3JvbGxYXCI6IHtcbiAgICBcIiF0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vd2luZG93LnNjcm9sbFhcIixcbiAgICBcIiFkb2NcIjogXCJSZXR1cm5zIHRoZSBudW1iZXIgb2YgcGl4ZWxzIHRoYXQgdGhlIGRvY3VtZW50IGhhcyBhbHJlYWR5IGJlZW4gc2Nyb2xsZWQgdmVydGljYWxseS5cIlxuICB9LFxuICBcInNjcmVlblRvcFwiOiB7XG4gICAgXCIhdHlwZVwiOiBcIm51bWJlclwiLFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL3dpbmRvdy5zY3JlZW4udG9wXCIsXG4gICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgZGlzdGFuY2UgaW4gcGl4ZWxzIGZyb20gdGhlIHRvcCBzaWRlIG9mIHRoZSBjdXJyZW50IHNjcmVlbi5cIlxuICB9LFxuICBcInNjcmVlbkxlZnRcIjoge1xuICAgIFwiIXR5cGVcIjogXCJudW1iZXJcIixcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS93aW5kb3cuc2NyZWVuLmxlZnRcIixcbiAgICBcIiFkb2NcIjogXCJSZXR1cm5zIHRoZSBkaXN0YW5jZSBpbiBwaXhlbHMgZnJvbSB0aGUgbGVmdCBzaWRlIG9mIHRoZSBtYWluIHNjcmVlbiB0byB0aGUgbGVmdCBzaWRlIG9mIHRoZSBjdXJyZW50IHNjcmVlbi5cIlxuICB9LFxuICBcInNjcmVlbllcIjoge1xuICAgIFwiIXR5cGVcIjogXCJudW1iZXJcIixcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9ldmVudC5zY3JlZW5ZXCIsXG4gICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgdmVydGljYWwgY29vcmRpbmF0ZSBvZiB0aGUgZXZlbnQgd2l0aGluIHRoZSBzY3JlZW4gYXMgYSB3aG9sZS5cIlxuICB9LFxuICBcInNjcmVlblhcIjoge1xuICAgIFwiIXR5cGVcIjogXCJudW1iZXJcIixcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9ldmVudC5zY3JlZW5YXCIsXG4gICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgaG9yaXpvbnRhbCBjb29yZGluYXRlIG9mIHRoZSBldmVudCB3aXRoaW4gdGhlIHNjcmVlbiBhcyBhIHdob2xlLlwiXG4gIH0sXG4gIFwiaW5uZXJXaWR0aFwiOiB7XG4gICAgXCIhdHlwZVwiOiBcIm51bWJlclwiLFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL3dpbmRvdy5pbm5lcldpZHRoXCIsXG4gICAgXCIhZG9jXCI6IFwiV2lkdGggKGluIHBpeGVscykgb2YgdGhlIGJyb3dzZXIgd2luZG93IHZpZXdwb3J0IGluY2x1ZGluZywgaWYgcmVuZGVyZWQsIHRoZSB2ZXJ0aWNhbCBzY3JvbGxiYXIuXCJcbiAgfSxcbiAgXCJpbm5lckhlaWdodFwiOiB7XG4gICAgXCIhdHlwZVwiOiBcIm51bWJlclwiLFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL3dpbmRvdy5pbm5lckhlaWdodFwiLFxuICAgIFwiIWRvY1wiOiBcIkhlaWdodCAoaW4gcGl4ZWxzKSBvZiB0aGUgYnJvd3NlciB3aW5kb3cgdmlld3BvcnQgaW5jbHVkaW5nLCBpZiByZW5kZXJlZCwgdGhlIGhvcml6b250YWwgc2Nyb2xsYmFyLlwiXG4gIH0sXG4gIFwib3V0ZXJXaWR0aFwiOiB7XG4gICAgXCIhdHlwZVwiOiBcIm51bWJlclwiLFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL3dpbmRvdy5vdXRlcldpZHRoXCIsXG4gICAgXCIhZG9jXCI6IFwid2luZG93Lm91dGVyV2lkdGggZ2V0cyB0aGUgd2lkdGggb2YgdGhlIG91dHNpZGUgb2YgdGhlIGJyb3dzZXIgd2luZG93LiBJdCByZXByZXNlbnRzIHRoZSB3aWR0aCBvZiB0aGUgd2hvbGUgYnJvd3NlciB3aW5kb3cgaW5jbHVkaW5nIHNpZGViYXIgKGlmIGV4cGFuZGVkKSwgd2luZG93IGNocm9tZSBhbmQgd2luZG93IHJlc2l6aW5nIGJvcmRlcnMvaGFuZGxlcy5cIlxuICB9LFxuICBcIm91dGVySGVpZ2h0XCI6IHtcbiAgICBcIiF0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vd2luZG93Lm91dGVySGVpZ2h0XCIsXG4gICAgXCIhZG9jXCI6IFwid2luZG93Lm91dGVySGVpZ2h0IGdldHMgdGhlIGhlaWdodCBpbiBwaXhlbHMgb2YgdGhlIHdob2xlIGJyb3dzZXIgd2luZG93LlwiXG4gIH0sXG4gIFwiZnJhbWVFbGVtZW50XCI6IHtcbiAgICBcIiF0eXBlXCI6IFwiK0VsZW1lbnRcIixcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS93aW5kb3cuZnJhbWVFbGVtZW50XCIsXG4gICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgZWxlbWVudCAoc3VjaCBhcyA8aWZyYW1lPiBvciA8b2JqZWN0PikgaW4gd2hpY2ggdGhlIHdpbmRvdyBpcyBlbWJlZGRlZCwgb3IgbnVsbCBpZiB0aGUgd2luZG93IGlzIHRvcC1sZXZlbC5cIlxuICB9LFxuICBcImNyeXB0b1wiOiB7XG4gICAgXCJnZXRSYW5kb21WYWx1ZXNcIjoge1xuICAgICAgXCIhdHlwZVwiOiBcImZuKFtudW1iZXJdKVwiLFxuICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXNcIixcbiAgICAgIFwiIWRvY1wiOiBcIlRoaXMgbWV0aG9kcyBsZXRzIHlvdSBnZXQgY3J5cHRvZ3JhcGhpY2FsbHkgcmFuZG9tIHZhbHVlcy5cIlxuICAgIH0sXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXNcIixcbiAgICBcIiFkb2NcIjogXCJUaGlzIG1ldGhvZHMgbGV0cyB5b3UgZ2V0IGNyeXB0b2dyYXBoaWNhbGx5IHJhbmRvbSB2YWx1ZXMuXCJcbiAgfSxcbiAgXCJuYXZpZ2F0b3JcIjoge1xuICAgIFwiYXBwTmFtZVwiOiB7XG4gICAgICBcIiF0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS93aW5kb3cubmF2aWdhdG9yLmFwcE5hbWVcIixcbiAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIG5hbWUgb2YgdGhlIGJyb3dzZXIuIFRoZSBIVE1MNSBzcGVjaWZpY2F0aW9uIGFsc28gYWxsb3dzIGFueSBicm93c2VyIHRvIHJldHVybiBcXFwiTmV0c2NhcGVcXFwiIGhlcmUsIGZvciBjb21wYXRpYmlsaXR5IHJlYXNvbnMuXCJcbiAgICB9LFxuICAgIFwiYXBwVmVyc2lvblwiOiB7XG4gICAgICBcIiF0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS93aW5kb3cubmF2aWdhdG9yLmFwcFZlcnNpb25cIixcbiAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIHZlcnNpb24gb2YgdGhlIGJyb3dzZXIgYXMgYSBzdHJpbmcuIEl0IG1heSBiZSBlaXRoZXIgYSBwbGFpbiB2ZXJzaW9uIG51bWJlciwgbGlrZSBcXFwiNS4wXFxcIiwgb3IgYSB2ZXJzaW9uIG51bWJlciBmb2xsb3dlZCBieSBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uLiBUaGUgSFRNTDUgc3BlY2lmaWNhdGlvbiBhbHNvIGFsbG93cyBhbnkgYnJvd3NlciB0byByZXR1cm4gXFxcIjQuMFxcXCIgaGVyZSwgZm9yIGNvbXBhdGliaWxpdHkgcmVhc29ucy5cIlxuICAgIH0sXG4gICAgXCJsYW5ndWFnZVwiOiB7XG4gICAgICBcIiF0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS93aW5kb3cubmF2aWdhdG9yLmxhbmd1YWdlXCIsXG4gICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgbGFuZ3VhZ2UgdmVyc2lvbiBvZiB0aGUgYnJvd3Nlci5cIlxuICAgIH0sXG4gICAgXCJwbGF0Zm9ybVwiOiB7XG4gICAgICBcIiF0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS93aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtXCIsXG4gICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgcGxhdGZvcm0gb2YgdGhlIGJyb3dzZXIuXCJcbiAgICB9LFxuICAgIFwicGx1Z2luc1wiOiB7XG4gICAgICBcIiF0eXBlXCI6IFwiWz9dXCIsXG4gICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS93aW5kb3cubmF2aWdhdG9yLnBsdWdpbnNcIixcbiAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgYSBQbHVnaW5BcnJheSBvYmplY3QsIGxpc3RpbmcgdGhlIHBsdWdpbnMgaW5zdGFsbGVkIGluIHRoZSBhcHBsaWNhdGlvbi5cIlxuICAgIH0sXG4gICAgXCJ1c2VyQWdlbnRcIjoge1xuICAgICAgXCIhdHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnRcIixcbiAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIHVzZXIgYWdlbnQgc3RyaW5nIGZvciB0aGUgY3VycmVudCBicm93c2VyLlwiXG4gICAgfSxcbiAgICBcInZlbmRvclwiOiB7XG4gICAgICBcIiF0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS93aW5kb3cubmF2aWdhdG9yLnZlbmRvclwiLFxuICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgYnJvd3NlciB2ZW5kb3IgZm9yIHRoZSBjdXJyZW50IGJyb3dzZXIuXCJcbiAgICB9LFxuICAgIFwiamF2YUVuYWJsZWRcIjoge1xuICAgICAgXCIhdHlwZVwiOiBcImJvb2xcIixcbiAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL3dpbmRvdy5uYXZpZ2F0b3IuamF2YUVuYWJsZWRcIixcbiAgICAgIFwiIWRvY1wiOiBcIlRoaXMgbWV0aG9kIGluZGljYXRlcyB3aGV0aGVyIHRoZSBjdXJyZW50IGJyb3dzZXIgaXMgSmF2YS1lbmFibGVkIG9yIG5vdC5cIlxuICAgIH0sXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vd2luZG93Lm5hdmlnYXRvclwiLFxuICAgIFwiIWRvY1wiOiBcIlJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIG5hdmlnYXRvciBvYmplY3QsIHdoaWNoIGNhbiBiZSBxdWVyaWVkIGZvciBpbmZvcm1hdGlvbiBhYm91dCB0aGUgYXBwbGljYXRpb24gcnVubmluZyB0aGUgc2NyaXB0LlwiXG4gIH0sXG4gIFwiaGlzdG9yeVwiOiB7XG4gICAgXCJzdGF0ZVwiOiB7XG4gICAgICBcIiF0eXBlXCI6IFwiP1wiLFxuICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vTWFuaXB1bGF0aW5nX3RoZV9icm93c2VyX2hpc3RvcnlcIixcbiAgICAgIFwiIWRvY1wiOiBcIlRoZSBET00gd2luZG93IG9iamVjdCBwcm92aWRlcyBhY2Nlc3MgdG8gdGhlIGJyb3dzZXIncyBoaXN0b3J5IHRocm91Z2ggdGhlIGhpc3Rvcnkgb2JqZWN0LiBJdCBleHBvc2VzIHVzZWZ1bCBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzIHRoYXQgbGV0IHlvdSBtb3ZlIGJhY2sgYW5kIGZvcnRoIHRocm91Z2ggdGhlIHVzZXIncyBoaXN0b3J5LCBhcyB3ZWxsIGFzIC0tIHN0YXJ0aW5nIHdpdGggSFRNTDUgLS0gbWFuaXB1bGF0ZSB0aGUgY29udGVudHMgb2YgdGhlIGhpc3Rvcnkgc3RhY2suXCJcbiAgICB9LFxuICAgIFwibGVuZ3RoXCI6IHtcbiAgICAgIFwiIXR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL01hbmlwdWxhdGluZ190aGVfYnJvd3Nlcl9oaXN0b3J5XCIsXG4gICAgICBcIiFkb2NcIjogXCJUaGUgRE9NIHdpbmRvdyBvYmplY3QgcHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBicm93c2VyJ3MgaGlzdG9yeSB0aHJvdWdoIHRoZSBoaXN0b3J5IG9iamVjdC4gSXQgZXhwb3NlcyB1c2VmdWwgbWV0aG9kcyBhbmQgcHJvcGVydGllcyB0aGF0IGxldCB5b3UgbW92ZSBiYWNrIGFuZCBmb3J0aCB0aHJvdWdoIHRoZSB1c2VyJ3MgaGlzdG9yeSwgYXMgd2VsbCBhcyAtLSBzdGFydGluZyB3aXRoIEhUTUw1IC0tIG1hbmlwdWxhdGUgdGhlIGNvbnRlbnRzIG9mIHRoZSBoaXN0b3J5IHN0YWNrLlwiXG4gICAgfSxcbiAgICBcImdvXCI6IHtcbiAgICAgIFwiIXR5cGVcIjogXCJmbihkZWx0YTogbnVtYmVyKVwiLFxuICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vd2luZG93Lmhpc3RvcnlcIixcbiAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIEhpc3Rvcnkgb2JqZWN0LCB3aGljaCBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIG1hbmlwdWxhdGluZyB0aGUgYnJvd3NlciBzZXNzaW9uIGhpc3RvcnkgKHBhZ2VzIHZpc2l0ZWQgaW4gdGhlIHRhYiBvciBmcmFtZSB0aGF0IHRoZSBjdXJyZW50IHBhZ2UgaXMgbG9hZGVkIGluKS5cIlxuICAgIH0sXG4gICAgXCJmb3J3YXJkXCI6IHtcbiAgICAgIFwiIXR5cGVcIjogXCJmbigpXCIsXG4gICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9NYW5pcHVsYXRpbmdfdGhlX2Jyb3dzZXJfaGlzdG9yeVwiLFxuICAgICAgXCIhZG9jXCI6IFwiVGhlIERPTSB3aW5kb3cgb2JqZWN0IHByb3ZpZGVzIGFjY2VzcyB0byB0aGUgYnJvd3NlcidzIGhpc3RvcnkgdGhyb3VnaCB0aGUgaGlzdG9yeSBvYmplY3QuIEl0IGV4cG9zZXMgdXNlZnVsIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgdGhhdCBsZXQgeW91IG1vdmUgYmFjayBhbmQgZm9ydGggdGhyb3VnaCB0aGUgdXNlcidzIGhpc3RvcnksIGFzIHdlbGwgYXMgLS0gc3RhcnRpbmcgd2l0aCBIVE1MNSAtLSBtYW5pcHVsYXRlIHRoZSBjb250ZW50cyBvZiB0aGUgaGlzdG9yeSBzdGFjay5cIlxuICAgIH0sXG4gICAgXCJiYWNrXCI6IHtcbiAgICAgIFwiIXR5cGVcIjogXCJmbigpXCIsXG4gICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9NYW5pcHVsYXRpbmdfdGhlX2Jyb3dzZXJfaGlzdG9yeVwiLFxuICAgICAgXCIhZG9jXCI6IFwiVGhlIERPTSB3aW5kb3cgb2JqZWN0IHByb3ZpZGVzIGFjY2VzcyB0byB0aGUgYnJvd3NlcidzIGhpc3RvcnkgdGhyb3VnaCB0aGUgaGlzdG9yeSBvYmplY3QuIEl0IGV4cG9zZXMgdXNlZnVsIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgdGhhdCBsZXQgeW91IG1vdmUgYmFjayBhbmQgZm9ydGggdGhyb3VnaCB0aGUgdXNlcidzIGhpc3RvcnksIGFzIHdlbGwgYXMgLS0gc3RhcnRpbmcgd2l0aCBIVE1MNSAtLSBtYW5pcHVsYXRlIHRoZSBjb250ZW50cyBvZiB0aGUgaGlzdG9yeSBzdGFjay5cIlxuICAgIH0sXG4gICAgXCJwdXNoU3RhdGVcIjoge1xuICAgICAgXCIhdHlwZVwiOiBcImZuKGRhdGE6ID8sIHRpdGxlOiBzdHJpbmcsIHVybD86IHN0cmluZylcIixcbiAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL01hbmlwdWxhdGluZ190aGVfYnJvd3Nlcl9oaXN0b3J5XCIsXG4gICAgICBcIiFkb2NcIjogXCJUaGUgRE9NIHdpbmRvdyBvYmplY3QgcHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBicm93c2VyJ3MgaGlzdG9yeSB0aHJvdWdoIHRoZSBoaXN0b3J5IG9iamVjdC4gSXQgZXhwb3NlcyB1c2VmdWwgbWV0aG9kcyBhbmQgcHJvcGVydGllcyB0aGF0IGxldCB5b3UgbW92ZSBiYWNrIGFuZCBmb3J0aCB0aHJvdWdoIHRoZSB1c2VyJ3MgaGlzdG9yeSwgYXMgd2VsbCBhcyAtLSBzdGFydGluZyB3aXRoIEhUTUw1IC0tIG1hbmlwdWxhdGUgdGhlIGNvbnRlbnRzIG9mIHRoZSBoaXN0b3J5IHN0YWNrLlwiXG4gICAgfSxcbiAgICBcInJlcGxhY2VTdGF0ZVwiOiB7XG4gICAgICBcIiF0eXBlXCI6IFwiZm4oZGF0YTogPywgdGl0bGU6IHN0cmluZywgdXJsPzogc3RyaW5nKVwiLFxuICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vTWFuaXB1bGF0aW5nX3RoZV9icm93c2VyX2hpc3RvcnlcIixcbiAgICAgIFwiIWRvY1wiOiBcIlRoZSBET00gd2luZG93IG9iamVjdCBwcm92aWRlcyBhY2Nlc3MgdG8gdGhlIGJyb3dzZXIncyBoaXN0b3J5IHRocm91Z2ggdGhlIGhpc3Rvcnkgb2JqZWN0LiBJdCBleHBvc2VzIHVzZWZ1bCBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzIHRoYXQgbGV0IHlvdSBtb3ZlIGJhY2sgYW5kIGZvcnRoIHRocm91Z2ggdGhlIHVzZXIncyBoaXN0b3J5LCBhcyB3ZWxsIGFzIC0tIHN0YXJ0aW5nIHdpdGggSFRNTDUgLS0gbWFuaXB1bGF0ZSB0aGUgY29udGVudHMgb2YgdGhlIGhpc3Rvcnkgc3RhY2suXCJcbiAgICB9LFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL01hbmlwdWxhdGluZ190aGVfYnJvd3Nlcl9oaXN0b3J5XCIsXG4gICAgXCIhZG9jXCI6IFwiVGhlIERPTSB3aW5kb3cgb2JqZWN0IHByb3ZpZGVzIGFjY2VzcyB0byB0aGUgYnJvd3NlcidzIGhpc3RvcnkgdGhyb3VnaCB0aGUgaGlzdG9yeSBvYmplY3QuIEl0IGV4cG9zZXMgdXNlZnVsIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgdGhhdCBsZXQgeW91IG1vdmUgYmFjayBhbmQgZm9ydGggdGhyb3VnaCB0aGUgdXNlcidzIGhpc3RvcnksIGFzIHdlbGwgYXMgLS0gc3RhcnRpbmcgd2l0aCBIVE1MNSAtLSBtYW5pcHVsYXRlIHRoZSBjb250ZW50cyBvZiB0aGUgaGlzdG9yeSBzdGFjay5cIlxuICB9LFxuICBcInNjcmVlblwiOiB7XG4gICAgXCJhdmFpbFdpZHRoXCI6IHtcbiAgICAgIFwiIXR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL3dpbmRvdy5zY3JlZW4uYXZhaWxXaWR0aFwiLFxuICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgYW1vdW50IG9mIGhvcml6b250YWwgc3BhY2UgaW4gcGl4ZWxzIGF2YWlsYWJsZSB0byB0aGUgd2luZG93LlwiXG4gICAgfSxcbiAgICBcImF2YWlsSGVpZ2h0XCI6IHtcbiAgICAgIFwiIXR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL3dpbmRvdy5zY3JlZW4uYXZhaWxIZWlnaHRcIixcbiAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIGFtb3VudCBvZiB2ZXJ0aWNhbCBzcGFjZSBhdmFpbGFibGUgdG8gdGhlIHdpbmRvdyBvbiB0aGUgc2NyZWVuLlwiXG4gICAgfSxcbiAgICBcImF2YWlsVG9wXCI6IHtcbiAgICAgIFwiIXR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL3dpbmRvdy5zY3JlZW4uYXZhaWxUb3BcIixcbiAgICAgIFwiIWRvY1wiOiBcIlNwZWNpZmllcyB0aGUgeS1jb29yZGluYXRlIG9mIHRoZSBmaXJzdCBwaXhlbCB0aGF0IGlzIG5vdCBhbGxvY2F0ZWQgdG8gcGVybWFuZW50IG9yIHNlbWlwZXJtYW5lbnQgdXNlciBpbnRlcmZhY2UgZmVhdHVyZXMuXCJcbiAgICB9LFxuICAgIFwiYXZhaWxMZWZ0XCI6IHtcbiAgICAgIFwiIXR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL3dpbmRvdy5zY3JlZW4uYXZhaWxMZWZ0XCIsXG4gICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIHRoZSBmaXJzdCBhdmFpbGFibGUgcGl4ZWwgYXZhaWxhYmxlIGZyb20gdGhlIGxlZnQgc2lkZSBvZiB0aGUgc2NyZWVuLlwiXG4gICAgfSxcbiAgICBcInBpeGVsRGVwdGhcIjoge1xuICAgICAgXCIhdHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vd2luZG93LnNjcmVlbi5waXhlbERlcHRoXCIsXG4gICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIHRoZSBiaXQgZGVwdGggb2YgdGhlIHNjcmVlbi5cIlxuICAgIH0sXG4gICAgXCJjb2xvckRlcHRoXCI6IHtcbiAgICAgIFwiIXR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL3dpbmRvdy5zY3JlZW4uY29sb3JEZXB0aFwiLFxuICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgY29sb3IgZGVwdGggb2YgdGhlIHNjcmVlbi5cIlxuICAgIH0sXG4gICAgXCJ3aWR0aFwiOiB7XG4gICAgICBcIiF0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS93aW5kb3cuc2NyZWVuLndpZHRoXCIsXG4gICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgc2NyZWVuLlwiXG4gICAgfSxcbiAgICBcImhlaWdodFwiOiB7XG4gICAgICBcIiF0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS93aW5kb3cuc2NyZWVuLmhlaWdodFwiLFxuICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgaGVpZ2h0IG9mIHRoZSBzY3JlZW4gaW4gcGl4ZWxzLlwiXG4gICAgfSxcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS93aW5kb3cuc2NyZWVuXCIsXG4gICAgXCIhZG9jXCI6IFwiUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgc2NyZWVuIG9iamVjdCBhc3NvY2lhdGVkIHdpdGggdGhlIHdpbmRvdy5cIlxuICB9LFxuICBcInBvc3RNZXNzYWdlXCI6IHtcbiAgICBcIiF0eXBlXCI6IFwiZm4obWVzc2FnZTogc3RyaW5nLCB0YXJnZXRPcmlnaW46IHN0cmluZylcIixcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcIixcbiAgICBcIiFkb2NcIjogXCJ3aW5kb3cucG9zdE1lc3NhZ2UsIHdoZW4gY2FsbGVkLCBjYXVzZXMgYSBNZXNzYWdlRXZlbnQgdG8gYmUgZGlzcGF0Y2hlZCBhdCB0aGUgdGFyZ2V0IHdpbmRvdyB3aGVuIGFueSBwZW5kaW5nIHNjcmlwdCB0aGF0IG11c3QgYmUgZXhlY3V0ZWQgY29tcGxldGVzIChlLmcuIHJlbWFpbmluZyBldmVudCBoYW5kbGVycyBpZiB3aW5kb3cucG9zdE1lc3NhZ2UgaXMgY2FsbGVkIGZyb20gYW4gZXZlbnQgaGFuZGxlciwgcHJldmlvdXNseS1zZXQgcGVuZGluZyB0aW1lb3V0cywgZXRjLikuIFRoZSBNZXNzYWdlRXZlbnQgaGFzIHRoZSB0eXBlIG1lc3NhZ2UsIGEgZGF0YSBwcm9wZXJ0eSB3aGljaCBpcyBzZXQgdG8gdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBhcmd1bWVudCBwcm92aWRlZCB0byB3aW5kb3cucG9zdE1lc3NhZ2UsIGFuIG9yaWdpbiBwcm9wZXJ0eSBjb3JyZXNwb25kaW5nIHRvIHRoZSBvcmlnaW4gb2YgdGhlIG1haW4gZG9jdW1lbnQgaW4gdGhlIHdpbmRvdyBjYWxsaW5nIHdpbmRvdy5wb3N0TWVzc2FnZSBhdCB0aGUgdGltZSB3aW5kb3cucG9zdE1lc3NhZ2Ugd2FzIGNhbGxlZCwgYW5kIGEgc291cmNlIHByb3BlcnR5IHdoaWNoIGlzIHRoZSB3aW5kb3cgZnJvbSB3aGljaCB3aW5kb3cucG9zdE1lc3NhZ2UgaXMgY2FsbGVkLiAoT3RoZXIgc3RhbmRhcmQgcHJvcGVydGllcyBvZiBldmVudHMgYXJlIHByZXNlbnQgd2l0aCB0aGVpciBleHBlY3RlZCB2YWx1ZXMuKVwiXG4gIH0sXG4gIFwiY2xvc2VcIjoge1xuICAgIFwiIXR5cGVcIjogXCJmbigpXCIsXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vd2luZG93LmNsb3NlXCIsXG4gICAgXCIhZG9jXCI6IFwiQ2xvc2VzIHRoZSBjdXJyZW50IHdpbmRvdywgb3IgYSByZWZlcmVuY2VkIHdpbmRvdy5cIlxuICB9LFxuICBcImJsdXJcIjoge1xuICAgIFwiIXR5cGVcIjogXCJmbigpXCIsXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZWxlbWVudC5ibHVyXCIsXG4gICAgXCIhZG9jXCI6IFwiVGhlIGJsdXIgbWV0aG9kIHJlbW92ZXMga2V5Ym9hcmQgZm9jdXMgZnJvbSB0aGUgY3VycmVudCBlbGVtZW50LlwiXG4gIH0sXG4gIFwiZm9jdXNcIjoge1xuICAgIFwiIXR5cGVcIjogXCJmbigpXCIsXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZWxlbWVudC5mb2N1c1wiLFxuICAgIFwiIWRvY1wiOiBcIlNldHMgZm9jdXMgb24gdGhlIHNwZWNpZmllZCBlbGVtZW50LCBpZiBpdCBjYW4gYmUgZm9jdXNlZC5cIlxuICB9LFxuICBcIm9ubG9hZFwiOiB7XG4gICAgXCIhdHlwZVwiOiBcIj9cIixcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS93aW5kb3cub25sb2FkXCIsXG4gICAgXCIhZG9jXCI6IFwiQW4gZXZlbnQgaGFuZGxlciBmb3IgdGhlIGxvYWQgZXZlbnQgb2YgYSB3aW5kb3cuXCJcbiAgfSxcbiAgXCJvbnVubG9hZFwiOiB7XG4gICAgXCIhdHlwZVwiOiBcIj9cIixcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS93aW5kb3cub251bmxvYWRcIixcbiAgICBcIiFkb2NcIjogXCJUaGUgdW5sb2FkIGV2ZW50IGlzIHJhaXNlZCB3aGVuIHRoZSB3aW5kb3cgaXMgdW5sb2FkaW5nIGl0cyBjb250ZW50IGFuZCByZXNvdXJjZXMuIFRoZSByZXNvdXJjZXMgcmVtb3ZhbCBpcyBwcm9jZXNzZWQgYWZ0ZXIgdGhlIHVubG9hZCBldmVudCBvY2N1cnMuXCJcbiAgfSxcbiAgXCJvbnNjcm9sbFwiOiB7XG4gICAgXCIhdHlwZVwiOiBcIj9cIixcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS93aW5kb3cub25zY3JvbGxcIixcbiAgICBcIiFkb2NcIjogXCJTcGVjaWZpZXMgdGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSB3aW5kb3cgaXMgc2Nyb2xsZWQuXCJcbiAgfSxcbiAgXCJvbnJlc2l6ZVwiOiB7XG4gICAgXCIhdHlwZVwiOiBcIj9cIixcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS93aW5kb3cub25yZXNpemVcIixcbiAgICBcIiFkb2NcIjogXCJBbiBldmVudCBoYW5kbGVyIGZvciB0aGUgcmVzaXplIGV2ZW50IG9uIHRoZSB3aW5kb3cuXCJcbiAgfSxcbiAgXCJvbm9ubGluZVwiOiB7XG4gICAgXCIhdHlwZVwiOiBcIj9cIixcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9kb2N1bWVudC5vbm9ubGluZVwiLFxuICAgIFwiIWRvY1wiOiBcIixmZ2ggcyBkZ2tsamdzZGZsIGRmamcgc2RsZ2ogc2RsZyBzZGxmaiBkbGcgamtkZmtqIGRmamdkZmtnbHNkZmpzZGxma2dqIGhkZmxrZyBoZGxrZmpnaCBkZmtqZ2hcIlxuICB9LFxuICBcIm9ub2ZmbGluZVwiOiB7XG4gICAgXCIhdHlwZVwiOiBcIj9cIixcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL09ubGluZV9hbmRfb2ZmbGluZV9ldmVudHNcIixcbiAgICBcIiFkb2NcIjogXCJTb21lIGJyb3dzZXJzIGltcGxlbWVudCBPbmxpbmUvT2ZmbGluZSBldmVudHMgZnJvbSB0aGUgV0hBVFdHIFdlYiBBcHBsaWNhdGlvbnMgMS4wIHNwZWNpZmljYXRpb24uXCJcbiAgfSxcbiAgXCJvbm1vdXNld2hlZWxcIjoge1xuICAgIFwiIXR5cGVcIjogXCI/XCIsXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vRE9NX2V2ZW50X3JlZmVyZW5jZS9tb3VzZXdoZWVsXCIsXG4gICAgXCIhZG9jXCI6IFwiVGhlIERPTSBtb3VzZXdoZWVsIGV2ZW50IGlzIGZpcmVkIGFzeW5jaHJvbm91c2x5IHdoZW4gbW91c2Ugd2hlZWwgb3Igc2ltaWxhciBkZXZpY2UgaXMgb3BlcmF0ZWQuIEl0J3MgcmVwcmVzZW50ZWQgYnkgdGhlIE1vdXNlV2hlZWxFdmVudCBpbnRlcmZhY2UuXCJcbiAgfSxcbiAgXCJvbm1vdXNldXBcIjoge1xuICAgIFwiIXR5cGVcIjogXCI/XCIsXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vd2luZG93Lm9ubW91c2V1cFwiLFxuICAgIFwiIWRvY1wiOiBcIkFuIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBtb3VzZXVwIGV2ZW50IG9uIHRoZSB3aW5kb3cuXCJcbiAgfSxcbiAgXCJvbm1vdXNlb3ZlclwiOiB7XG4gICAgXCIhdHlwZVwiOiBcIj9cIixcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9lbGVtZW50Lm9ubW91c2VvdmVyXCIsXG4gICAgXCIhZG9jXCI6IFwiVGhlIG9ubW91c2VvdmVyIHByb3BlcnR5IHJldHVybnMgdGhlIG9uTW91c2VPdmVyIGV2ZW50IGhhbmRsZXIgY29kZSBvbiB0aGUgY3VycmVudCBlbGVtZW50LlwiXG4gIH0sXG4gIFwib25tb3VzZW91dFwiOiB7XG4gICAgXCIhdHlwZVwiOiBcIj9cIixcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9lbGVtZW50Lm9ubW91c2VvdXRcIixcbiAgICBcIiFkb2NcIjogXCJUaGUgb25tb3VzZW91dCBwcm9wZXJ0eSByZXR1cm5zIHRoZSBvbk1vdXNlT3V0IGV2ZW50IGhhbmRsZXIgY29kZSBvbiB0aGUgY3VycmVudCBlbGVtZW50LlwiXG4gIH0sXG4gIFwib25tb3VzZW1vdmVcIjoge1xuICAgIFwiIXR5cGVcIjogXCI/XCIsXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZWxlbWVudC5vbm1vdXNlbW92ZVwiLFxuICAgIFwiIWRvY1wiOiBcIlRoZSBvbm1vdXNlbW92ZSBwcm9wZXJ0eSByZXR1cm5zIHRoZSBtb3VzZW1vdmUgZXZlbnQgaGFuZGxlciBjb2RlIG9uIHRoZSBjdXJyZW50IGVsZW1lbnQuXCJcbiAgfSxcbiAgXCJvbm1vdXNlZG93blwiOiB7XG4gICAgXCIhdHlwZVwiOiBcIj9cIixcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS93aW5kb3cub25tb3VzZWRvd25cIixcbiAgICBcIiFkb2NcIjogXCJBbiBldmVudCBoYW5kbGVyIGZvciB0aGUgbW91c2Vkb3duIGV2ZW50IG9uIHRoZSB3aW5kb3cuXCJcbiAgfSxcbiAgXCJvbmNsaWNrXCI6IHtcbiAgICBcIiF0eXBlXCI6IFwiP1wiLFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2VsZW1lbnQub25jbGlja1wiLFxuICAgIFwiIWRvY1wiOiBcIlRoZSBvbmNsaWNrIHByb3BlcnR5IHJldHVybnMgdGhlIG9uQ2xpY2sgZXZlbnQgaGFuZGxlciBjb2RlIG9uIHRoZSBjdXJyZW50IGVsZW1lbnQuXCJcbiAgfSxcbiAgXCJvbmRibGNsaWNrXCI6IHtcbiAgICBcIiF0eXBlXCI6IFwiP1wiLFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2VsZW1lbnQub25kYmxjbGlja1wiLFxuICAgIFwiIWRvY1wiOiBcIlRoZSBvbmRibGNsaWNrIHByb3BlcnR5IHJldHVybnMgdGhlIG9uRGJsQ2xpY2sgZXZlbnQgaGFuZGxlciBjb2RlIG9uIHRoZSBjdXJyZW50IGVsZW1lbnQuXCJcbiAgfSxcbiAgXCJvbm1lc3NhZ2VcIjoge1xuICAgIFwiIXR5cGVcIjogXCI/XCIsXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vV29ya2VyXCIsXG4gICAgXCIhZG9jXCI6IFwiRGVkaWNhdGVkIFdlYiBXb3JrZXJzIHByb3ZpZGUgYSBzaW1wbGUgbWVhbnMgZm9yIHdlYiBjb250ZW50IHRvIHJ1biBzY3JpcHRzIGluIGJhY2tncm91bmQgdGhyZWFkcy4gIE9uY2UgY3JlYXRlZCwgYSB3b3JrZXIgY2FuIHNlbmQgbWVzc2FnZXMgdG8gdGhlIHNwYXduaW5nIHRhc2sgYnkgcG9zdGluZyBtZXNzYWdlcyB0byBhbiBldmVudCBoYW5kbGVyIHNwZWNpZmllZCBieSB0aGUgY3JlYXRvci5cIlxuICB9LFxuICBcIm9ua2V5dXBcIjoge1xuICAgIFwiIXR5cGVcIjogXCI/XCIsXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZWxlbWVudC5vbmtleXVwXCIsXG4gICAgXCIhZG9jXCI6IFwiVGhlIG9ua2V5dXAgcHJvcGVydHkgcmV0dXJucyB0aGUgb25LZXlVcCBldmVudCBoYW5kbGVyIGNvZGUgZm9yIHRoZSBjdXJyZW50IGVsZW1lbnQuXCJcbiAgfSxcbiAgXCJvbmtleXByZXNzXCI6IHtcbiAgICBcIiF0eXBlXCI6IFwiP1wiLFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2VsZW1lbnQub25rZXlwcmVzc1wiLFxuICAgIFwiIWRvY1wiOiBcIlRoZSBvbmtleXByZXNzIHByb3BlcnR5IHNldHMgYW5kIHJldHVybnMgdGhlIG9uS2V5UHJlc3MgZXZlbnQgaGFuZGxlciBjb2RlIGZvciB0aGUgY3VycmVudCBlbGVtZW50LlwiXG4gIH0sXG4gIFwib25rZXlkb3duXCI6IHtcbiAgICBcIiF0eXBlXCI6IFwiP1wiLFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL3dpbmRvdy5vbmtleWRvd25cIixcbiAgICBcIiFkb2NcIjogXCJBbiBldmVudCBoYW5kbGVyIGZvciB0aGUga2V5ZG93biBldmVudCBvbiB0aGUgd2luZG93LlwiXG4gIH0sXG4gIFwib25pbnB1dFwiOiB7XG4gICAgXCIhdHlwZVwiOiBcIj9cIixcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS9ET01fZXZlbnRfcmVmZXJlbmNlL2lucHV0XCIsXG4gICAgXCIhZG9jXCI6IFwiVGhlIERPTSBpbnB1dCBldmVudCBpcyBmaXJlZCBzeW5jaHJvbm91c2x5IHdoZW4gdGhlIHZhbHVlIG9mIGFuIDxpbnB1dD4gb3IgPHRleHRhcmVhPiBlbGVtZW50IGlzIGNoYW5nZWQuIEFkZGl0aW9uYWxseSwgaXQncyBhbHNvIGZpcmVkIG9uIGNvbnRlbnRlZGl0YWJsZSBlZGl0b3JzIHdoZW4gaXRzIGNvbnRlbnRzIGFyZSBjaGFuZ2VkLiBJbiB0aGlzIGNhc2UsIHRoZSBldmVudCB0YXJnZXQgaXMgdGhlIGVkaXRpbmcgaG9zdCBlbGVtZW50LiBJZiB0aGVyZSBhcmUgdHdvIG9yIG1vcmUgZWxlbWVudHMgd2hpY2ggaGF2ZSBjb250ZW50ZWRpdGFibGUgYXMgdHJ1ZSwgXFxcImVkaXRpbmcgaG9zdFxcXCIgaXMgdGhlIG5lYXJlc3QgYW5jZXN0b3IgZWxlbWVudCB3aG9zZSBwYXJlbnQgaXNuJ3QgZWRpdGFibGUuIFNpbWlsYXJseSwgaXQncyBhbHNvIGZpcmVkIG9uIHJvb3QgZWxlbWVudCBvZiBkZXNpZ25Nb2RlIGVkaXRvcnMuXCJcbiAgfSxcbiAgXCJvbnBvcHN0YXRlXCI6IHtcbiAgICBcIiF0eXBlXCI6IFwiP1wiLFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL3dpbmRvdy5vbnBvcHN0YXRlXCIsXG4gICAgXCIhZG9jXCI6IFwiQW4gZXZlbnQgaGFuZGxlciBmb3IgdGhlIHBvcHN0YXRlIGV2ZW50IG9uIHRoZSB3aW5kb3cuXCJcbiAgfSxcbiAgXCJvbmhhc2hjaGFuZ2VcIjoge1xuICAgIFwiIXR5cGVcIjogXCI/XCIsXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vd2luZG93Lm9uaGFzaGNoYW5nZVwiLFxuICAgIFwiIWRvY1wiOiBcIlRoZSBoYXNoY2hhbmdlIGV2ZW50IGZpcmVzIHdoZW4gYSB3aW5kb3cncyBoYXNoIGNoYW5nZXMuXCJcbiAgfSxcbiAgXCJvbmZvY3VzXCI6IHtcbiAgICBcIiF0eXBlXCI6IFwiP1wiLFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL2VsZW1lbnQub25mb2N1c1wiLFxuICAgIFwiIWRvY1wiOiBcIlRoZSBvbmZvY3VzIHByb3BlcnR5IHJldHVybnMgdGhlIG9uRm9jdXMgZXZlbnQgaGFuZGxlciBjb2RlIG9uIHRoZSBjdXJyZW50IGVsZW1lbnQuXCJcbiAgfSxcbiAgXCJvbmJsdXJcIjoge1xuICAgIFwiIXR5cGVcIjogXCI/XCIsXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZWxlbWVudC5vbmJsdXJcIixcbiAgICBcIiFkb2NcIjogXCJUaGUgb25ibHVyIHByb3BlcnR5IHJldHVybnMgdGhlIG9uQmx1ciBldmVudCBoYW5kbGVyIGNvZGUsIGlmIGFueSwgdGhhdCBleGlzdHMgb24gdGhlIGN1cnJlbnQgZWxlbWVudC5cIlxuICB9LFxuICBcIm9uZXJyb3JcIjoge1xuICAgIFwiIXR5cGVcIjogXCI/XCIsXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vd2luZG93Lm9uZXJyb3JcIixcbiAgICBcIiFkb2NcIjogXCJBbiBldmVudCBoYW5kbGVyIGZvciBydW50aW1lIHNjcmlwdCBlcnJvcnMuXCJcbiAgfSxcbiAgXCJvbmRyb3BcIjoge1xuICAgIFwiIXR5cGVcIjogXCI/XCIsXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9ET00vTW96aWxsYV9ldmVudF9yZWZlcmVuY2UvZHJvcFwiLFxuICAgIFwiIWRvY1wiOiBcIlRoZSBkcm9wIGV2ZW50IGlzIGZpcmVkIHdoZW4gYW4gZWxlbWVudCBvciB0ZXh0IHNlbGVjdGlvbiBpcyBkcm9wcGVkIG9uIGEgdmFsaWQgZHJvcCB0YXJnZXQuXCJcbiAgfSxcbiAgXCJvbmRyYWdzdGFydFwiOiB7XG4gICAgXCIhdHlwZVwiOiBcIj9cIixcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0RPTS9Nb3ppbGxhX2V2ZW50X3JlZmVyZW5jZS9kcmFnc3RhcnRcIixcbiAgICBcIiFkb2NcIjogXCJUaGUgZHJhZ3N0YXJ0IGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nIGFuIGVsZW1lbnQgb3IgdGV4dCBzZWxlY3Rpb24uXCJcbiAgfSxcbiAgXCJvbmRyYWdvdmVyXCI6IHtcbiAgICBcIiF0eXBlXCI6IFwiP1wiLFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvRE9NL01vemlsbGFfZXZlbnRfcmVmZXJlbmNlL2RyYWdvdmVyXCIsXG4gICAgXCIhZG9jXCI6IFwiVGhlIGRyYWdvdmVyIGV2ZW50IGlzIGZpcmVkIHdoZW4gYW4gZWxlbWVudCBvciB0ZXh0IHNlbGVjdGlvbiBpcyBiZWluZyBkcmFnZ2VkIG92ZXIgYSB2YWxpZCBkcm9wIHRhcmdldCAoZXZlcnkgZmV3IGh1bmRyZWQgbWlsbGlzZWNvbmRzKS5cIlxuICB9LFxuICBcIm9uZHJhZ2xlYXZlXCI6IHtcbiAgICBcIiF0eXBlXCI6IFwiP1wiLFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvRE9NL01vemlsbGFfZXZlbnRfcmVmZXJlbmNlL2RyYWdsZWF2ZVwiLFxuICAgIFwiIWRvY1wiOiBcIlRoZSBkcmFnbGVhdmUgZXZlbnQgaXMgZmlyZWQgd2hlbiBhIGRyYWdnZWQgZWxlbWVudCBvciB0ZXh0IHNlbGVjdGlvbiBsZWF2ZXMgYSB2YWxpZCBkcm9wIHRhcmdldC5cIlxuICB9LFxuICBcIm9uZHJhZ2VudGVyXCI6IHtcbiAgICBcIiF0eXBlXCI6IFwiP1wiLFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvRE9NL01vemlsbGFfZXZlbnRfcmVmZXJlbmNlL2RyYWdlbnRlclwiLFxuICAgIFwiIWRvY1wiOiBcIlRoZSBkcmFnZW50ZXIgZXZlbnQgaXMgZmlyZWQgd2hlbiBhIGRyYWdnZWQgZWxlbWVudCBvciB0ZXh0IHNlbGVjdGlvbiBlbnRlcnMgYSB2YWxpZCBkcm9wIHRhcmdldC5cIlxuICB9LFxuICBcIm9uZHJhZ2VuZFwiOiB7XG4gICAgXCIhdHlwZVwiOiBcIj9cIixcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0RPTS9Nb3ppbGxhX2V2ZW50X3JlZmVyZW5jZS9kcmFnZW5kXCIsXG4gICAgXCIhZG9jXCI6IFwiVGhlIGRyYWdlbmQgZXZlbnQgaXMgZmlyZWQgd2hlbiBhIGRyYWcgb3BlcmF0aW9uIGlzIGJlaW5nIGVuZGVkIChieSByZWxlYXNpbmcgYSBtb3VzZSBidXR0b24gb3IgaGl0dGluZyB0aGUgZXNjYXBlIGtleSkuXCJcbiAgfSxcbiAgXCJvbmRyYWdcIjoge1xuICAgIFwiIXR5cGVcIjogXCI/XCIsXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9ET00vTW96aWxsYV9ldmVudF9yZWZlcmVuY2UvZHJhZ1wiLFxuICAgIFwiIWRvY1wiOiBcIlRoZSBkcmFnIGV2ZW50IGlzIGZpcmVkIHdoZW4gYW4gZWxlbWVudCBvciB0ZXh0IHNlbGVjdGlvbiBpcyBiZWluZyBkcmFnZ2VkIChldmVyeSBmZXcgaHVuZHJlZCBtaWxsaXNlY29uZHMpLlwiXG4gIH0sXG4gIFwib25jb250ZXh0bWVudVwiOiB7XG4gICAgXCIhdHlwZVwiOiBcIj9cIixcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS93aW5kb3cub25jb250ZXh0bWVudVwiLFxuICAgIFwiIWRvY1wiOiBcIkFuIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgZm9yIHJpZ2h0LWNsaWNrIGV2ZW50cyBvbiB0aGUgd2luZG93LiBVbmxlc3MgdGhlIGRlZmF1bHQgYmVoYXZpb3IgaXMgcHJldmVudGVkLCB0aGUgYnJvd3NlciBjb250ZXh0IG1lbnUgd2lsbCBhY3RpdmF0ZSAodGhvdWdoIElFOCBoYXMgYSBidWcgd2l0aCB0aGlzIGFuZCB3aWxsIG5vdCBhY3RpdmF0ZSB0aGUgY29udGV4dCBtZW51IGlmIGEgY29udGV4dG1lbnUgZXZlbnQgaGFuZGxlciBpcyBkZWZpbmVkKS4gTm90ZSB0aGF0IHRoaXMgZXZlbnQgd2lsbCBvY2N1ciB3aXRoIGFueSBub24tZGlzYWJsZWQgcmlnaHQtY2xpY2sgZXZlbnQgYW5kIGRvZXMgbm90IGRlcGVuZCBvbiBhbiBlbGVtZW50IHBvc3Nlc3NpbmcgdGhlIFxcXCJjb250ZXh0bWVudVxcXCIgYXR0cmlidXRlLlwiXG4gIH0sXG4gIFwib25jaGFuZ2VcIjoge1xuICAgIFwiIXR5cGVcIjogXCI/XCIsXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vZWxlbWVudC5vbmNoYW5nZVwiLFxuICAgIFwiIWRvY1wiOiBcIlRoZSBvbmNoYW5nZSBwcm9wZXJ0eSBzZXRzIGFuZCByZXR1cm5zIHRoZSBvbkNoYW5nZSBldmVudCBoYW5kbGVyIGNvZGUgZm9yIHRoZSBjdXJyZW50IGVsZW1lbnQuXCJcbiAgfSxcbiAgXCJvbmJlZm9yZXVubG9hZFwiOiB7XG4gICAgXCIhdHlwZVwiOiBcIj9cIixcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS93aW5kb3cub25iZWZvcmV1bmxvYWRcIixcbiAgICBcIiFkb2NcIjogXCJBbiBldmVudCB0aGF0IGZpcmVzIHdoZW4gYSB3aW5kb3cgaXMgYWJvdXQgdG8gdW5sb2FkIGl0cyByZXNvdXJjZXMuIFRoZSBkb2N1bWVudCBpcyBzdGlsbCB2aXNpYmxlIGFuZCB0aGUgZXZlbnQgaXMgc3RpbGwgY2FuY2VsYWJsZS5cIlxuICB9LFxuICBcIm9uYWJvcnRcIjoge1xuICAgIFwiIXR5cGVcIjogXCI/XCIsXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vd2luZG93Lm9uYWJvcnRcIixcbiAgICBcIiFkb2NcIjogXCJBbiBldmVudCBoYW5kbGVyIGZvciBhYm9ydCBldmVudHMgc2VudCB0byB0aGUgd2luZG93LlwiXG4gIH0sXG4gIFwiZ2V0U2VsZWN0aW9uXCI6IHtcbiAgICBcIiF0eXBlXCI6IFwiZm4oKSAtPiArU2VsZWN0aW9uXCIsXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vd2luZG93LmdldFNlbGVjdGlvblwiLFxuICAgIFwiIWRvY1wiOiBcIlJldHVybnMgYSBzZWxlY3Rpb24gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcmFuZ2Ugb2YgdGV4dCBzZWxlY3RlZCBieSB0aGUgdXNlci4gXCJcbiAgfSxcbiAgXCJhbGVydFwiOiB7XG4gICAgXCIhdHlwZVwiOiBcImZuKG1lc3NhZ2U6IHN0cmluZylcIixcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS93aW5kb3cuYWxlcnRcIixcbiAgICBcIiFkb2NcIjogXCJEaXNwbGF5IGFuIGFsZXJ0IGRpYWxvZyB3aXRoIHRoZSBzcGVjaWZpZWQgY29udGVudCBhbmQgYW4gT0sgYnV0dG9uLlwiXG4gIH0sXG4gIFwiY29uZmlybVwiOiB7XG4gICAgXCIhdHlwZVwiOiBcImZuKG1lc3NhZ2U6IHN0cmluZykgLT4gYm9vbFwiLFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL3dpbmRvdy5jb25maXJtXCIsXG4gICAgXCIhZG9jXCI6IFwiRGlzcGxheXMgYSBtb2RhbCBkaWFsb2cgd2l0aCBhIG1lc3NhZ2UgYW5kIHR3byBidXR0b25zLCBPSyBhbmQgQ2FuY2VsLlwiXG4gIH0sXG4gIFwicHJvbXB0XCI6IHtcbiAgICBcIiF0eXBlXCI6IFwiZm4obWVzc2FnZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSAtPiBzdHJpbmdcIixcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS93aW5kb3cucHJvbXB0XCIsXG4gICAgXCIhZG9jXCI6IFwiRGlzcGxheXMgYSBkaWFsb2cgd2l0aCBhIG1lc3NhZ2UgcHJvbXB0aW5nIHRoZSB1c2VyIHRvIGlucHV0IHNvbWUgdGV4dC5cIlxuICB9LFxuICBcInNjcm9sbEJ5XCI6IHtcbiAgICBcIiF0eXBlXCI6IFwiZm4oeDogbnVtYmVyLCB5OiBudW1iZXIpXCIsXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vd2luZG93LnNjcm9sbEJ5XCIsXG4gICAgXCIhZG9jXCI6IFwiU2Nyb2xscyB0aGUgZG9jdW1lbnQgaW4gdGhlIHdpbmRvdyBieSB0aGUgZ2l2ZW4gYW1vdW50LlwiXG4gIH0sXG4gIFwic2Nyb2xsVG9cIjoge1xuICAgIFwiIXR5cGVcIjogXCJmbih4OiBudW1iZXIsIHk6IG51bWJlcilcIixcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0RPTS93aW5kb3cuc2Nyb2xsVG9cIixcbiAgICBcIiFkb2NcIjogXCJTY3JvbGxzIHRvIGEgcGFydGljdWxhciBzZXQgb2YgY29vcmRpbmF0ZXMgaW4gdGhlIGRvY3VtZW50LlwiXG4gIH0sXG4gIFwic2Nyb2xsXCI6IHtcbiAgICBcIiF0eXBlXCI6IFwiZm4oeDogbnVtYmVyLCB5OiBudW1iZXIpXCIsXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vd2luZG93LnNjcm9sbFwiLFxuICAgIFwiIWRvY1wiOiBcIlNjcm9sbHMgdGhlIHdpbmRvdyB0byBhIHBhcnRpY3VsYXIgcGxhY2UgaW4gdGhlIGRvY3VtZW50LlwiXG4gIH0sXG4gIFwic2V0VGltZW91dFwiOiB7XG4gICAgXCIhdHlwZVwiOiBcImZuKGY6IGZuKCksIG1zOiBudW1iZXIpIC0+IG51bWJlclwiLFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL3dpbmRvdy5zZXRUaW1lb3V0XCIsXG4gICAgXCIhZG9jXCI6IFwiQ2FsbHMgYSBmdW5jdGlvbiBvciBleGVjdXRlcyBhIGNvZGUgc25pcHBldCBhZnRlciBzcGVjaWZpZWQgZGVsYXkuXCJcbiAgfSxcbiAgXCJjbGVhclRpbWVvdXRcIjoge1xuICAgIFwiIXR5cGVcIjogXCJmbih0aW1lb3V0OiBudW1iZXIpXCIsXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vd2luZG93LmNsZWFyVGltZW91dFwiLFxuICAgIFwiIWRvY1wiOiBcIkNsZWFycyB0aGUgZGVsYXkgc2V0IGJ5IHdpbmRvdy5zZXRUaW1lb3V0KCkuXCJcbiAgfSxcbiAgXCJzZXRJbnRlcnZhbFwiOiB7XG4gICAgXCIhdHlwZVwiOiBcImZuKGY6IGZuKCksIG1zOiBudW1iZXIpIC0+IG51bWJlclwiLFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL3dpbmRvdy5zZXRJbnRlcnZhbFwiLFxuICAgIFwiIWRvY1wiOiBcIkNhbGxzIGEgZnVuY3Rpb24gb3IgZXhlY3V0ZXMgYSBjb2RlIHNuaXBwZXQgcmVwZWF0ZWRseSwgd2l0aCBhIGZpeGVkIHRpbWUgZGVsYXkgYmV0d2VlbiBlYWNoIGNhbGwgdG8gdGhhdCBmdW5jdGlvbi5cIlxuICB9LFxuICBcImNsZWFySW50ZXJ2YWxcIjoge1xuICAgIFwiIXR5cGVcIjogXCJmbihpbnRlcnZhbDogbnVtYmVyKVwiLFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL3dpbmRvdy5jbGVhckludGVydmFsXCIsXG4gICAgXCIhZG9jXCI6IFwiQ2FuY2VscyByZXBlYXRlZCBhY3Rpb24gd2hpY2ggd2FzIHNldCB1cCB1c2luZyBzZXRJbnRlcnZhbC5cIlxuICB9LFxuICBcImF0b2JcIjoge1xuICAgIFwiIXR5cGVcIjogXCJmbihlbmNvZGVkOiBzdHJpbmcpIC0+IHN0cmluZ1wiLFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL3dpbmRvdy5hdG9iXCIsXG4gICAgXCIhZG9jXCI6IFwiRGVjb2RlcyBhIHN0cmluZyBvZiBkYXRhIHdoaWNoIGhhcyBiZWVuIGVuY29kZWQgdXNpbmcgYmFzZS02NCBlbmNvZGluZy5cIlxuICB9LFxuICBcImJ0b2FcIjoge1xuICAgIFwiIXR5cGVcIjogXCJmbihkYXRhOiBzdHJpbmcpIC0+IHN0cmluZ1wiLFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL3dpbmRvdy5idG9hXCIsXG4gICAgXCIhZG9jXCI6IFwiQ3JlYXRlcyBhIGJhc2UtNjQgZW5jb2RlZCBBU0NJSSBzdHJpbmcgZnJvbSBhIHN0cmluZyBvZiBiaW5hcnkgZGF0YS5cIlxuICB9LFxuICBcImFkZEV2ZW50TGlzdGVuZXJcIjoge1xuICAgIFwiIXR5cGVcIjogXCJmbih0eXBlOiBzdHJpbmcsIGxpc3RlbmVyOiBmbihlOiArRXZlbnQpLCBjYXB0dXJlOiBib29sKVwiLFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL0V2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXJcIixcbiAgICBcIiFkb2NcIjogXCJSZWdpc3RlcnMgYSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIgb24gYSBzaW5nbGUgdGFyZ2V0LiBUaGUgZXZlbnQgdGFyZ2V0IG1heSBiZSBhIHNpbmdsZSBlbGVtZW50IGluIGEgZG9jdW1lbnQsIHRoZSBkb2N1bWVudCBpdHNlbGYsIGEgd2luZG93LCBvciBhbiBYTUxIdHRwUmVxdWVzdC5cIlxuICB9LFxuICBcInJlbW92ZUV2ZW50TGlzdGVuZXJcIjoge1xuICAgIFwiIXR5cGVcIjogXCJmbih0eXBlOiBzdHJpbmcsIGxpc3RlbmVyOiBmbigpLCBjYXB0dXJlOiBib29sKVwiLFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvRE9NL0V2ZW50VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXJcIixcbiAgICBcIiFkb2NcIjogXCJBbGxvd3MgdGhlIHJlbW92YWwgb2YgZXZlbnQgbGlzdGVuZXJzIGZyb20gdGhlIGV2ZW50IHRhcmdldC5cIlxuICB9LFxuICBcImRpc3BhdGNoRXZlbnRcIjoge1xuICAgIFwiIXR5cGVcIjogXCJmbihldmVudDogK0V2ZW50KSAtPiBib29sXCIsXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vRXZlbnRUYXJnZXQuZGlzcGF0Y2hFdmVudFwiLFxuICAgIFwiIWRvY1wiOiBcIkRpc3BhdGNoZXMgYW4gZXZlbnQgaW50byB0aGUgZXZlbnQgc3lzdGVtLiBUaGUgZXZlbnQgaXMgc3ViamVjdCB0byB0aGUgc2FtZSBjYXB0dXJpbmcgYW5kIGJ1YmJsaW5nIGJlaGF2aW9yIGFzIGRpcmVjdGx5IGRpc3BhdGNoZWQgZXZlbnRzLlwiXG4gIH0sXG4gIFwiZ2V0Q29tcHV0ZWRTdHlsZVwiOiB7XG4gICAgXCIhdHlwZVwiOiBcImZuKG5vZGU6ICtFbGVtZW50LCBwc2V1ZG8/OiBzdHJpbmcpIC0+IEVsZW1lbnQucHJvdG90eXBlLnN0eWxlXCIsXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9ET00vd2luZG93LmdldENvbXB1dGVkU3R5bGVcIixcbiAgICBcIiFkb2NcIjogXCJHaXZlcyB0aGUgZmluYWwgdXNlZCB2YWx1ZXMgb2YgYWxsIHRoZSBDU1MgcHJvcGVydGllcyBvZiBhbiBlbGVtZW50LlwiXG4gIH0sXG4gIFwiQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEXCI6IHtcbiAgICBcImNhbnZhc1wiOiBcIitFbGVtZW50XCIsXG4gICAgXCJ3aWR0aFwiOiBcIm51bWJlclwiLFxuICAgIFwiaGVpZ2h0XCI6IFwibnVtYmVyXCIsXG4gICAgXCJjb21taXRcIjogXCJmbigpXCIsXG4gICAgXCJzYXZlXCI6IFwiZm4oKVwiLFxuICAgIFwicmVzdG9yZVwiOiBcImZuKClcIixcbiAgICBcImN1cnJlbnRUcmFuc2Zvcm1cIjogXCI/XCIsXG4gICAgXCJzY2FsZVwiOiBcImZuKHg6IG51bWJlciwgeTogbnVtYmVyKVwiLFxuICAgIFwicm90YXRlXCI6IFwiZm4oYW5nbGU6IG51bWJlcilcIixcbiAgICBcInRyYW5zbGF0ZVwiOiBcImZuKHg6IG51bWJlciwgeTogbnVtYmVyKVwiLFxuICAgIFwidHJhbnNmb3JtXCI6IFwiZm4oYTogbnVtYmVyLCBiOiBudW1iZXIsIGM6IG51bWJlciwgZDogbnVtYmVyLCBlOiBudW1iZXIsIGY6IG51bWJlcilcIixcbiAgICBcInNldFRyYW5zZm9ybVwiOiBcImZuKGE6IG51bWJlciwgYjogbnVtYmVyLCBjOiBudW1iZXIsIGQ6IG51bWJlciwgZTogbnVtYmVyLCBmOiBudW1iZXIpXCIsXG4gICAgXCJyZXNldFRyYW5zZm9ybVwiOiBcImZuKClcIixcbiAgICBcImdsb2JhbEFscGhhXCI6IFwibnVtYmVyXCIsXG4gICAgXCJnbG9iYWxDb21wb3NpdGVPcGVyYXRpb25cIjogXCJzdHJpbmdcIixcbiAgICBcImltYWdlU21vb3RoaW5nRW5hYmxlZFwiOiBcImJvb2xcIixcbiAgICBcInN0cm9rZVN0eWxlXCI6IFwic3RyaW5nXCIsXG4gICAgXCJmaWxsU3R5bGVcIjogXCJzdHJpbmdcIixcbiAgICBcImNyZWF0ZUxpbmVhckdyYWRpZW50XCI6IFwiZm4oeDA6IG51bWJlciwgeTA6IG51bWJlciwgeDE6IG51bWJlciwgeTE6IG51bWJlcikgLT4gP1wiLFxuICAgIFwiY3JlYXRlUGF0dGVyblwiOiBcImZuKGltYWdlOiA/LCByZXBldGl0aW9uOiBzdHJpbmcpIC0+ID9cIixcbiAgICBcInNoYWRvd09mZnNldFhcIjogXCJudW1iZXJcIixcbiAgICBcInNoYWRvd09mZnNldFlcIjogXCJudW1iZXJcIixcbiAgICBcInNoYWRvd0JsdXJcIjogXCJudW1iZXJcIixcbiAgICBcInNoYWRvd0NvbG9yXCI6IFwic3RyaW5nXCIsXG4gICAgXCJjbGVhclJlY3RcIjogXCJmbih4OiBudW1iZXIsIHk6IG51bWJlciwgdzogbnVtYmVyLCBoOiBudW1iZXIpXCIsXG4gICAgXCJmaWxsUmVjdFwiOiBcImZuKHg6IG51bWJlciwgeTogbnVtYmVyLCB3OiBudW1iZXIsIGg6IG51bWJlcilcIixcbiAgICBcInN0cm9rZVJlY3RcIjogXCJmbih4OiBudW1iZXIsIHk6IG51bWJlciwgdzogbnVtYmVyLCBoOiBudW1iZXIpXCIsXG4gICAgXCJmaWxsUnVsZVwiOiBcInN0cmluZ1wiLFxuICAgIFwiZmlsbFwiOiBcImZuKClcIixcbiAgICBcImJlZ2luUGF0aFwiOiBcImZuKClcIixcbiAgICBcInN0cm9rZVwiOiBcImZuKClcIixcbiAgICBcImNsaXBcIjogXCJmbigpXCIsXG4gICAgXCJyZXNldENsaXBcIjogXCJmbigpXCIsXG4gICAgXCJtZWFzdXJlVGV4dFwiOiBcImZuKHRleHQ6IHN0cmluZykgLT4gP1wiLFxuICAgIFwiZHJhd0ltYWdlXCI6IFwiZm4oaW1hZ2U6ID8sIGR4OiBudW1iZXIsIGR5OiBudW1iZXIpXCIsXG4gICAgXCJjcmVhdGVJbWFnZURhdGFcIjogXCJmbihzdzogbnVtYmVyLCBzaDogbnVtYmVyKSAtPiA/XCIsXG4gICAgXCJnZXRJbWFnZURhdGFcIjogXCJmbihzeDogbnVtYmVyLCBzeTogbnVtYmVyLCBzdzogbnVtYmVyLCBzaDogbnVtYmVyKSAtPiA/XCIsXG4gICAgXCJwdXRJbWFnZURhdGFcIjogXCJmbihpbWFnZWRhdGE6ID8sIGR4OiBudW1iZXIsIGR5OiBudW1iZXIpXCIsXG4gICAgXCJsaW5lV2lkdGhcIjogXCJudW1iZXJcIixcbiAgICBcImxpbmVDYXBcIjogXCJzdHJpbmdcIixcbiAgICBcImxpbmVKb2luXCI6IFwic3RyaW5nXCIsXG4gICAgXCJtaXRlckxpbWl0XCI6IFwibnVtYmVyXCIsXG4gICAgXCJzZXRMaW5lRGFzaFwiOiBcImZuKHNlZ21lbnRzOiBbbnVtYmVyXSlcIixcbiAgICBcImdldExpbmVEYXNoXCI6IFwiZm4oKSAtPiBbbnVtYmVyXVwiLFxuICAgIFwibGluZURhc2hPZmZzZXRcIjogXCJudW1iZXJcIixcbiAgICBcImZvbnRcIjogXCJzdHJpbmdcIixcbiAgICBcInRleHRBbGlnblwiOiBcInN0cmluZ1wiLFxuICAgIFwidGV4dEJhc2VsaW5lXCI6IFwic3RyaW5nXCIsXG4gICAgXCJkaXJlY3Rpb25cIjogXCJzdHJpbmdcIixcbiAgICBcImNsb3NlUGF0aFwiOiBcImZuKClcIixcbiAgICBcIm1vdmVUb1wiOiBcImZuKHg6IG51bWJlciwgeTogbnVtYmVyKVwiLFxuICAgIFwibGluZVRvXCI6IFwiZm4oeDogbnVtYmVyLCB5OiBudW1iZXIpXCIsXG4gICAgXCJxdWFkcmF0aWNDdXJ2ZVRvXCI6IFwiZm4oY3B4OiBudW1iZXIsIGNweTogbnVtYmVyLCB4OiBudW1iZXIsIHk6IG51bWJlcilcIixcbiAgICBcImJlemllckN1cnZlVG9cIjogXCJmbihjcDF4OiBudW1iZXIsIGNwMXk6IG51bWJlciwgY3AyeDogbnVtYmVyLCBjcDJ5OiBudW1iZXIsIHg6IG51bWJlciwgeTogbnVtYmVyKVwiLFxuICAgIFwiYXJjVG9cIjogXCJmbih4MTogbnVtYmVyLCB5MTogbnVtYmVyLCB4MjogbnVtYmVyLCB5MjogbnVtYmVyLCByYWRpdXM6IG51bWJlcilcIixcbiAgICBcInJlY3RcIjogXCJmbih4OiBudW1iZXIsIHk6IG51bWJlciwgdzogbnVtYmVyLCBoOiBudW1iZXIpXCIsXG4gICAgXCJhcmNcIjogXCJmbih4OiBudW1iZXIsIHk6IG51bWJlciwgcmFkaXVzOiBudW1iZXIsIHN0YXJ0QW5nbGU6IG51bWJlciwgZW5kQW5nbGU6IG51bWJlciwgYW50aWNsb2Nrd2lzZT86IGJvb2wpXCIsXG4gICAgXCJlbGxpcHNlXCI6IFwiZm4oeDogbnVtYmVyLCB5OiBudW1iZXIsIHJhZGl1c1g6IG51bWJlciwgcmFkaXVzWTogbnVtYmVyLCByb3RhdGlvbjogbnVtYmVyLCBzdGFydEFuZ2xlOiBudW1iZXIsIGVuZEFuZ2xlOiBudW1iZXIsIGFudGljbG9ja3dpc2U6IGJvb2wpXCJcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiFuYW1lXCI6IFwiZWNtYTVcIixcbiAgXCIhZGVmaW5lXCI6IHtcIkVycm9yLnByb3RvdHlwZVwiOiBcIkVycm9yLnByb3RvdHlwZVwifSxcbiAgXCJJbmZpbml0eVwiOiB7XG4gICAgXCIhdHlwZVwiOiBcIm51bWJlclwiLFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvSW5maW5pdHlcIixcbiAgICBcIiFkb2NcIjogXCJBIG51bWVyaWMgdmFsdWUgcmVwcmVzZW50aW5nIGluZmluaXR5LlwiXG4gIH0sXG4gIFwidW5kZWZpbmVkXCI6IHtcbiAgICBcIiF0eXBlXCI6IFwiP1wiLFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvdW5kZWZpbmVkXCIsXG4gICAgXCIhZG9jXCI6IFwiVGhlIHZhbHVlIHVuZGVmaW5lZC5cIlxuICB9LFxuICBcIk5hTlwiOiB7XG4gICAgXCIhdHlwZVwiOiBcIm51bWJlclwiLFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTmFOXCIsXG4gICAgXCIhZG9jXCI6IFwiQSB2YWx1ZSByZXByZXNlbnRpbmcgTm90LUEtTnVtYmVyLlwiXG4gIH0sXG4gIFwiT2JqZWN0XCI6IHtcbiAgICBcIiF0eXBlXCI6IFwiZm4oKVwiLFxuICAgIFwiZ2V0UHJvdG90eXBlT2ZcIjoge1xuICAgICAgXCIhdHlwZVwiOiBcImZuKG9iajogPykgLT4gP1wiLFxuICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvZ2V0UHJvdG90eXBlT2ZcIixcbiAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIHByb3RvdHlwZSAoaS5lLiB0aGUgaW50ZXJuYWwgcHJvdG90eXBlKSBvZiB0aGUgc3BlY2lmaWVkIG9iamVjdC5cIlxuICAgIH0sXG4gICAgXCJjcmVhdGVcIjoge1xuICAgICAgXCIhdHlwZVwiOiBcImZuKHByb3RvOiA/KSAtPiAhY3VzdG9tOk9iamVjdF9jcmVhdGVcIixcbiAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2NyZWF0ZVwiLFxuICAgICAgXCIhZG9jXCI6IFwiQ3JlYXRlcyBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgc3BlY2lmaWVkIHByb3RvdHlwZSBvYmplY3QgYW5kIHByb3BlcnRpZXMuXCJcbiAgICB9LFxuICAgIFwiZGVmaW5lUHJvcGVydHlcIjoge1xuICAgICAgXCIhdHlwZVwiOiBcImZuKG9iajogPywgcHJvcDogc3RyaW5nLCBkZXNjOiA/KVwiLFxuICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvZGVmaW5lUHJvcGVydHlcIixcbiAgICAgIFwiIWRvY1wiOiBcIkRlZmluZXMgYSBuZXcgcHJvcGVydHkgZGlyZWN0bHkgb24gYW4gb2JqZWN0LCBvciBtb2RpZmllcyBhbiBleGlzdGluZyBwcm9wZXJ0eSBvbiBhbiBvYmplY3QsIGFuZCByZXR1cm5zIHRoZSBvYmplY3QuIElmIHlvdSB3YW50IHRvIHNlZSBob3cgdG8gdXNlIHRoZSBPYmplY3QuZGVmaW5lUHJvcGVydHkgbWV0aG9kIHdpdGggYSBiaW5hcnktZmxhZ3MtbGlrZSBzeW50YXgsIHNlZSB0aGlzIGFydGljbGUuXCJcbiAgICB9LFxuICAgIFwiZGVmaW5lUHJvcGVydGllc1wiOiB7XG4gICAgICBcIiF0eXBlXCI6IFwiZm4ob2JqOiA/LCBwcm9wczogPylcIixcbiAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2RlZmluZVByb3BlcnR5XCIsXG4gICAgICBcIiFkb2NcIjogXCJEZWZpbmVzIGEgbmV3IHByb3BlcnR5IGRpcmVjdGx5IG9uIGFuIG9iamVjdCwgb3IgbW9kaWZpZXMgYW4gZXhpc3RpbmcgcHJvcGVydHkgb24gYW4gb2JqZWN0LCBhbmQgcmV0dXJucyB0aGUgb2JqZWN0LiBJZiB5b3Ugd2FudCB0byBzZWUgaG93IHRvIHVzZSB0aGUgT2JqZWN0LmRlZmluZVByb3BlcnR5IG1ldGhvZCB3aXRoIGEgYmluYXJ5LWZsYWdzLWxpa2Ugc3ludGF4LCBzZWUgdGhpcyBhcnRpY2xlLlwiXG4gICAgfSxcbiAgICBcImdldE93blByb3BlcnR5RGVzY3JpcHRvclwiOiB7XG4gICAgICBcIiF0eXBlXCI6IFwiZm4ob2JqOiA/LCBwcm9wOiBzdHJpbmcpIC0+ID9cIixcbiAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2dldE93blByb3BlcnR5RGVzY3JpcHRvclwiLFxuICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyBhIHByb3BlcnR5IGRlc2NyaXB0b3IgZm9yIGFuIG93biBwcm9wZXJ0eSAodGhhdCBpcywgb25lIGRpcmVjdGx5IHByZXNlbnQgb24gYW4gb2JqZWN0LCBub3QgcHJlc2VudCBieSBkaW50IG9mIGJlaW5nIGFsb25nIGFuIG9iamVjdCdzIHByb3RvdHlwZSBjaGFpbikgb2YgYSBnaXZlbiBvYmplY3QuXCJcbiAgICB9LFxuICAgIFwia2V5c1wiOiB7XG4gICAgICBcIiF0eXBlXCI6IFwiZm4ob2JqOiA/KSAtPiBbc3RyaW5nXVwiLFxuICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3Qva2V5c1wiLFxuICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyBhbiBhcnJheSBvZiBhIGdpdmVuIG9iamVjdCdzIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMsIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoYXQgcHJvdmlkZWQgYnkgYSBmb3ItaW4gbG9vcCAodGhlIGRpZmZlcmVuY2UgYmVpbmcgdGhhdCBhIGZvci1pbiBsb29wIGVudW1lcmF0ZXMgcHJvcGVydGllcyBpbiB0aGUgcHJvdG90eXBlIGNoYWluIGFzIHdlbGwpLlwiXG4gICAgfSxcbiAgICBcImdldE93blByb3BlcnR5TmFtZXNcIjoge1xuICAgICAgXCIhdHlwZVwiOiBcImZuKG9iajogPykgLT4gW3N0cmluZ11cIixcbiAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2dldE93blByb3BlcnR5TmFtZXNcIixcbiAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgYW4gYXJyYXkgb2YgYWxsIHByb3BlcnRpZXMgKGVudW1lcmFibGUgb3Igbm90KSBmb3VuZCBkaXJlY3RseSB1cG9uIGEgZ2l2ZW4gb2JqZWN0LlwiXG4gICAgfSxcbiAgICBcInNlYWxcIjoge1xuICAgICAgXCIhdHlwZVwiOiBcImZuKG9iajogPylcIixcbiAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L3NlYWxcIixcbiAgICAgIFwiIWRvY1wiOiBcIlNlYWxzIGFuIG9iamVjdCwgcHJldmVudGluZyBuZXcgcHJvcGVydGllcyBmcm9tIGJlaW5nIGFkZGVkIHRvIGl0IGFuZCBtYXJraW5nIGFsbCBleGlzdGluZyBwcm9wZXJ0aWVzIGFzIG5vbi1jb25maWd1cmFibGUuIFZhbHVlcyBvZiBwcmVzZW50IHByb3BlcnRpZXMgY2FuIHN0aWxsIGJlIGNoYW5nZWQgYXMgbG9uZyBhcyB0aGV5IGFyZSB3cml0YWJsZS5cIlxuICAgIH0sXG4gICAgXCJpc1NlYWxlZFwiOiB7XG4gICAgICBcIiF0eXBlXCI6IFwiZm4ob2JqOiA/KSAtPiBib29sXCIsXG4gICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1NlYWxlZFwiLFxuICAgICAgXCIhZG9jXCI6IFwiRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBzZWFsZWQuXCJcbiAgICB9LFxuICAgIFwiZnJlZXplXCI6IHtcbiAgICAgIFwiIXR5cGVcIjogXCJmbihvYmo6ID8pXCIsXG4gICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9mcmVlemVcIixcbiAgICAgIFwiIWRvY1wiOiBcIkZyZWV6ZXMgYW4gb2JqZWN0OiB0aGF0IGlzLCBwcmV2ZW50cyBuZXcgcHJvcGVydGllcyBmcm9tIGJlaW5nIGFkZGVkIHRvIGl0OyBwcmV2ZW50cyBleGlzdGluZyBwcm9wZXJ0aWVzIGZyb20gYmVpbmcgcmVtb3ZlZDsgYW5kIHByZXZlbnRzIGV4aXN0aW5nIHByb3BlcnRpZXMsIG9yIHRoZWlyIGVudW1lcmFiaWxpdHksIGNvbmZpZ3VyYWJpbGl0eSwgb3Igd3JpdGFiaWxpdHksIGZyb20gYmVpbmcgY2hhbmdlZC4gSW4gZXNzZW5jZSB0aGUgb2JqZWN0IGlzIG1hZGUgZWZmZWN0aXZlbHkgaW1tdXRhYmxlLiBUaGUgbWV0aG9kIHJldHVybnMgdGhlIG9iamVjdCBiZWluZyBmcm96ZW4uXCJcbiAgICB9LFxuICAgIFwiaXNGcm96ZW5cIjoge1xuICAgICAgXCIhdHlwZVwiOiBcImZuKG9iajogPykgLT4gYm9vbFwiLFxuICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNGcm96ZW5cIixcbiAgICAgIFwiIWRvY1wiOiBcIkRldGVybWluZSBpZiBhbiBvYmplY3QgaXMgZnJvemVuLlwiXG4gICAgfSxcbiAgICBcInByb3RvdHlwZVwiOiB7XG4gICAgICBcIiFzdGRQcm90b1wiOiBcIk9iamVjdFwiLFxuICAgICAgXCJ0b1N0cmluZ1wiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbigpIC0+IHN0cmluZ1wiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC90b1N0cmluZ1wiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgb2JqZWN0LlwiXG4gICAgICB9LFxuICAgICAgXCJ0b0xvY2FsZVN0cmluZ1wiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbigpIC0+IHN0cmluZ1wiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC90b0xvY2FsZVN0cmluZ1wiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgb2JqZWN0LiBUaGlzIG1ldGhvZCBpcyBtZWFudCB0byBiZSBvdmVycmlkZW4gYnkgZGVyaXZlZCBvYmplY3RzIGZvciBsb2NhbGUtc3BlY2lmaWMgcHVycG9zZXMuXCJcbiAgICAgIH0sXG4gICAgICBcInZhbHVlT2ZcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oKSAtPiBudW1iZXJcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvdmFsdWVPZlwiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIHRoZSBwcmltaXRpdmUgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBvYmplY3RcIlxuICAgICAgfSxcbiAgICAgIFwiaGFzT3duUHJvcGVydHlcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4ocHJvcDogc3RyaW5nKSAtPiBib29sXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2hhc093blByb3BlcnR5XCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgb2JqZWN0IGhhcyB0aGUgc3BlY2lmaWVkIHByb3BlcnR5LlwiXG4gICAgICB9LFxuICAgICAgXCJwcm9wZXJ0eUlzRW51bWVyYWJsZVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihwcm9wOiBzdHJpbmcpIC0+IGJvb2xcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvcHJvcGVydHlJc0VudW1lcmFibGVcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyBhIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgcHJvcGVydHkgaXMgZW51bWVyYWJsZS5cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3RcIixcbiAgICBcIiFkb2NcIjogXCJDcmVhdGVzIGFuIG9iamVjdCB3cmFwcGVyLlwiXG4gIH0sXG4gIFwiRnVuY3Rpb25cIjoge1xuICAgIFwiIXR5cGVcIjogXCJmbihib2R5OiBzdHJpbmcpIC0+IGZuKClcIixcbiAgICBcInByb3RvdHlwZVwiOiB7XG4gICAgICBcIiFzdGRQcm90b1wiOiBcIkZ1bmN0aW9uXCIsXG4gICAgICBcImFwcGx5XCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKHRoaXM6ID8sIGFyZ3M6IFs/XSlcIixcbiAgICAgICAgXCIhZWZmZWN0c1wiOiBbXG4gICAgICAgICAgXCJjYWxsIGFuZCByZXR1cm4gIXRoaXMgdGhpcz0hMCAhMS48aT4gITEuPGk+ICExLjxpPlwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYXBwbHlcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiQ2FsbHMgYSBmdW5jdGlvbiB3aXRoIGEgZ2l2ZW4gdGhpcyB2YWx1ZSBhbmQgYXJndW1lbnRzIHByb3ZpZGVkIGFzIGFuIGFycmF5IChvciBhbiBhcnJheSBsaWtlIG9iamVjdCkuXCJcbiAgICAgIH0sXG4gICAgICBcImNhbGxcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4odGhpczogPywgYXJncz86ID8pIC0+ICF0aGlzLiFyZXRcIixcbiAgICAgICAgXCIhZWZmZWN0c1wiOiBbXG4gICAgICAgICAgXCJjYWxsIGFuZCByZXR1cm4gIXRoaXMgdGhpcz0hMCAhMSAhMiAhMyAhNFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vY2FsbFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJDYWxscyBhIGZ1bmN0aW9uIHdpdGggYSBnaXZlbiB0aGlzIHZhbHVlIGFuZCBhcmd1bWVudHMgcHJvdmlkZWQgaW5kaXZpZHVhbGx5LlwiXG4gICAgICB9LFxuICAgICAgXCJiaW5kXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKHRoaXM6ID8sIGFyZ3M/OiA/KSAtPiAhY3VzdG9tOkZ1bmN0aW9uX2JpbmRcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9iaW5kXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIkNyZWF0ZXMgYSBuZXcgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIGhhcyBpdHMgdGhpcyBrZXl3b3JkIHNldCB0byB0aGUgcHJvdmlkZWQgdmFsdWUsIHdpdGggYSBnaXZlbiBzZXF1ZW5jZSBvZiBhcmd1bWVudHMgcHJlY2VkaW5nIGFueSBwcm92aWRlZCB3aGVuIHRoZSBuZXcgZnVuY3Rpb24gd2FzIGNhbGxlZC5cIlxuICAgICAgfSxcbiAgICAgIFwicHJvdG90eXBlXCI6IFwiP1wiXG4gICAgfSxcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uXCIsXG4gICAgXCIhZG9jXCI6IFwiRXZlcnkgZnVuY3Rpb24gaW4gSmF2YVNjcmlwdCBpcyBhY3R1YWxseSBhIEZ1bmN0aW9uIG9iamVjdC5cIlxuICB9LFxuICBcIkFycmF5XCI6IHtcbiAgICBcIiF0eXBlXCI6IFwiZm4oc2l6ZTogbnVtYmVyKSAtPiAhY3VzdG9tOkFycmF5X2N0b3JcIixcbiAgICBcImlzQXJyYXlcIjoge1xuICAgICAgXCIhdHlwZVwiOiBcImZuKHZhbHVlOiA/KSAtPiBib29sXCIsXG4gICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2lzQXJyYXlcIixcbiAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdHJ1ZSBpZiBhbiBvYmplY3QgaXMgYW4gYXJyYXksIGZhbHNlIGlmIGl0IGlzIG5vdC5cIlxuICAgIH0sXG4gICAgXCJwcm90b3R5cGVcIjoge1xuICAgICAgXCIhc3RkUHJvdG9cIjogXCJBcnJheVwiLFxuICAgICAgXCJsZW5ndGhcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvbGVuZ3RoXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIkFuIHVuc2lnbmVkLCAzMi1iaXQgaW50ZWdlciB0aGF0IHNwZWNpZmllcyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIGFuIGFycmF5LlwiXG4gICAgICB9LFxuICAgICAgXCJjb25jYXRcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4ob3RoZXI6IFs/XSkgLT4gIXRoaXNcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9jb25jYXRcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyBhIG5ldyBhcnJheSBjb21wcmlzZWQgb2YgdGhpcyBhcnJheSBqb2luZWQgd2l0aCBvdGhlciBhcnJheShzKSBhbmQvb3IgdmFsdWUocykuXCJcbiAgICAgIH0sXG4gICAgICBcImpvaW5cIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oc2VwYXJhdG9yPzogc3RyaW5nKSAtPiBzdHJpbmdcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9qb2luXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIkpvaW5zIGFsbCBlbGVtZW50cyBvZiBhbiBhcnJheSBpbnRvIGEgc3RyaW5nLlwiXG4gICAgICB9LFxuICAgICAgXCJzcGxpY2VcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4ocG9zOiBudW1iZXIsIGFtb3VudDogbnVtYmVyKVwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NwbGljZVwiLFxuICAgICAgICBcIiFkb2NcIjogXCJDaGFuZ2VzIHRoZSBjb250ZW50IG9mIGFuIGFycmF5LCBhZGRpbmcgbmV3IGVsZW1lbnRzIHdoaWxlIHJlbW92aW5nIG9sZCBlbGVtZW50cy5cIlxuICAgICAgfSxcbiAgICAgIFwicG9wXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKCkgLT4gIXRoaXMuPGk+XCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvcG9wXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJlbW92ZXMgdGhlIGxhc3QgZWxlbWVudCBmcm9tIGFuIGFycmF5IGFuZCByZXR1cm5zIHRoYXQgZWxlbWVudC5cIlxuICAgICAgfSxcbiAgICAgIFwicHVzaFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihuZXdlbHQ6ID8pIC0+IG51bWJlclwiLFxuICAgICAgICBcIiFlZmZlY3RzXCI6IFtcbiAgICAgICAgICBcInByb3BhZ2F0ZSAhMCAhdGhpcy48aT5cIlxuICAgICAgICBdLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3B1c2hcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiTXV0YXRlcyBhbiBhcnJheSBieSBhcHBlbmRpbmcgdGhlIGdpdmVuIGVsZW1lbnRzIGFuZCByZXR1cm5pbmcgdGhlIG5ldyBsZW5ndGggb2YgdGhlIGFycmF5LlwiXG4gICAgICB9LFxuICAgICAgXCJzaGlmdFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbigpIC0+ICF0aGlzLjxpPlwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NoaWZ0XCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJlbW92ZXMgdGhlIGZpcnN0IGVsZW1lbnQgZnJvbSBhbiBhcnJheSBhbmQgcmV0dXJucyB0aGF0IGVsZW1lbnQuIFRoaXMgbWV0aG9kIGNoYW5nZXMgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuXCJcbiAgICAgIH0sXG4gICAgICBcInVuc2hpZnRcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4obmV3ZWx0OiA/KSAtPiBudW1iZXJcIixcbiAgICAgICAgXCIhZWZmZWN0c1wiOiBbXG4gICAgICAgICAgXCJwcm9wYWdhdGUgITAgIXRoaXMuPGk+XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS91bnNoaWZ0XCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIkFkZHMgb25lIG9yIG1vcmUgZWxlbWVudHMgdG8gdGhlIGJlZ2lubmluZyBvZiBhbiBhcnJheSBhbmQgcmV0dXJucyB0aGUgbmV3IGxlbmd0aCBvZiB0aGUgYXJyYXkuXCJcbiAgICAgIH0sXG4gICAgICBcInNsaWNlXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKGZyb206IG51bWJlciwgdG8/OiBudW1iZXIpIC0+ICF0aGlzXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc2xpY2VcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyBhIHNoYWxsb3cgY29weSBvZiBhIHBvcnRpb24gb2YgYW4gYXJyYXkuXCJcbiAgICAgIH0sXG4gICAgICBcInJldmVyc2VcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oKVwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3JldmVyc2VcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV2ZXJzZXMgYW4gYXJyYXkgaW4gcGxhY2UuICBUaGUgZmlyc3QgYXJyYXkgZWxlbWVudCBiZWNvbWVzIHRoZSBsYXN0IGFuZCB0aGUgbGFzdCBiZWNvbWVzIHRoZSBmaXJzdC5cIlxuICAgICAgfSxcbiAgICAgIFwic29ydFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihjb21wYXJlPzogZm4oYTogPywgYjogPykgLT4gbnVtYmVyKVwiLFxuICAgICAgICBcIiFlZmZlY3RzXCI6IFtcbiAgICAgICAgICBcImNhbGwgITAgIXRoaXMuPGk+ICF0aGlzLjxpPlwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc29ydFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJTb3J0cyB0aGUgZWxlbWVudHMgb2YgYW4gYXJyYXkgaW4gcGxhY2UgYW5kIHJldHVybnMgdGhlIGFycmF5LlwiXG4gICAgICB9LFxuICAgICAgXCJpbmRleE9mXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKGVsdDogPywgZnJvbT86IG51bWJlcikgLT4gbnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaW5kZXhPZlwiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBhdCB3aGljaCBhIGdpdmVuIGVsZW1lbnQgY2FuIGJlIGZvdW5kIGluIHRoZSBhcnJheSwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuXCJcbiAgICAgIH0sXG4gICAgICBcImxhc3RJbmRleE9mXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKGVsdDogPywgZnJvbT86IG51bWJlcikgLT4gbnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvbGFzdEluZGV4T2ZcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgbGFzdCBpbmRleCBhdCB3aGljaCBhIGdpdmVuIGVsZW1lbnQgY2FuIGJlIGZvdW5kIGluIHRoZSBhcnJheSwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuIFRoZSBhcnJheSBpcyBzZWFyY2hlZCBiYWNrd2FyZHMsIHN0YXJ0aW5nIGF0IGZyb21JbmRleC5cIlxuICAgICAgfSxcbiAgICAgIFwiZXZlcnlcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4odGVzdDogZm4oZWx0OiA/LCBpOiBudW1iZXIpIC0+IGJvb2wsIGNvbnRleHQ/OiA/KSAtPiBib29sXCIsXG4gICAgICAgIFwiIWVmZmVjdHNcIjogW1xuICAgICAgICAgIFwiY2FsbCAhMCB0aGlzPSExICF0aGlzLjxpPiBudW1iZXJcIlxuICAgICAgICBdLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2V2ZXJ5XCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlRlc3RzIHdoZXRoZXIgYWxsIGVsZW1lbnRzIGluIHRoZSBhcnJheSBwYXNzIHRoZSB0ZXN0IGltcGxlbWVudGVkIGJ5IHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cIlxuICAgICAgfSxcbiAgICAgIFwic29tZVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbih0ZXN0OiBmbihlbHQ6ID8sIGk6IG51bWJlcikgLT4gYm9vbCwgY29udGV4dD86ID8pIC0+IGJvb2xcIixcbiAgICAgICAgXCIhZWZmZWN0c1wiOiBbXG4gICAgICAgICAgXCJjYWxsICEwIHRoaXM9ITEgIXRoaXMuPGk+IG51bWJlclwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc29tZVwiLFxuICAgICAgICBcIiFkb2NcIjogXCJUZXN0cyB3aGV0aGVyIHNvbWUgZWxlbWVudCBpbiB0aGUgYXJyYXkgcGFzc2VzIHRoZSB0ZXN0IGltcGxlbWVudGVkIGJ5IHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cIlxuICAgICAgfSxcbiAgICAgIFwiZmlsdGVyXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKHRlc3Q6IGZuKGVsdDogPywgaTogbnVtYmVyKSAtPiBib29sLCBjb250ZXh0PzogPykgLT4gIXRoaXNcIixcbiAgICAgICAgXCIhZWZmZWN0c1wiOiBbXG4gICAgICAgICAgXCJjYWxsICEwIHRoaXM9ITEgIXRoaXMuPGk+IG51bWJlclwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZmlsdGVyXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIkNyZWF0ZXMgYSBuZXcgYXJyYXkgd2l0aCBhbGwgZWxlbWVudHMgdGhhdCBwYXNzIHRoZSB0ZXN0IGltcGxlbWVudGVkIGJ5IHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cIlxuICAgICAgfSxcbiAgICAgIFwiZm9yRWFjaFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihmOiBmbihlbHQ6ID8sIGk6IG51bWJlciksIGNvbnRleHQ/OiA/KVwiLFxuICAgICAgICBcIiFlZmZlY3RzXCI6IFtcbiAgICAgICAgICBcImNhbGwgITAgdGhpcz0hMSAhdGhpcy48aT4gbnVtYmVyXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9mb3JFYWNoXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIkV4ZWN1dGVzIGEgcHJvdmlkZWQgZnVuY3Rpb24gb25jZSBwZXIgYXJyYXkgZWxlbWVudC5cIlxuICAgICAgfSxcbiAgICAgIFwibWFwXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKGY6IGZuKGVsdDogPywgaTogbnVtYmVyKSAtPiA/LCBjb250ZXh0PzogPykgLT4gWyEwLiFyZXRdXCIsXG4gICAgICAgIFwiIWVmZmVjdHNcIjogW1xuICAgICAgICAgIFwiY2FsbCAhMCB0aGlzPSExICF0aGlzLjxpPiBudW1iZXJcIlxuICAgICAgICBdLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L21hcFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJDcmVhdGVzIGEgbmV3IGFycmF5IHdpdGggdGhlIHJlc3VsdHMgb2YgY2FsbGluZyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uIGV2ZXJ5IGVsZW1lbnQgaW4gdGhpcyBhcnJheS5cIlxuICAgICAgfSxcbiAgICAgIFwicmVkdWNlXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKGNvbWJpbmU6IGZuKHN1bTogPywgZWx0OiA/LCBpOiBudW1iZXIpIC0+ID8sIGluaXQ/OiA/KSAtPiAhMC4hcmV0XCIsXG4gICAgICAgIFwiIWVmZmVjdHNcIjogW1xuICAgICAgICAgIFwiY2FsbCAhMCAhMSAhdGhpcy48aT4gbnVtYmVyXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9SZWR1Y2VcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiQXBwbHkgYSBmdW5jdGlvbiBhZ2FpbnN0IGFuIGFjY3VtdWxhdG9yIGFuZCBlYWNoIHZhbHVlIG9mIHRoZSBhcnJheSAoZnJvbSBsZWZ0LXRvLXJpZ2h0KSBhcyB0byByZWR1Y2UgaXQgdG8gYSBzaW5nbGUgdmFsdWUuXCJcbiAgICAgIH0sXG4gICAgICBcInJlZHVjZVJpZ2h0XCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKGNvbWJpbmU6IGZuKHN1bTogPywgZWx0OiA/LCBpOiBudW1iZXIpIC0+ID8sIGluaXQ/OiA/KSAtPiAhMC4hcmV0XCIsXG4gICAgICAgIFwiIWVmZmVjdHNcIjogW1xuICAgICAgICAgIFwiY2FsbCAhMCAhMSAhdGhpcy48aT4gbnVtYmVyXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9SZWR1Y2VSaWdodFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJBcHBseSBhIGZ1bmN0aW9uIHNpbXVsdGFuZW91c2x5IGFnYWluc3QgdHdvIHZhbHVlcyBvZiB0aGUgYXJyYXkgKGZyb20gcmlnaHQtdG8tbGVmdCkgYXMgdG8gcmVkdWNlIGl0IHRvIGEgc2luZ2xlIHZhbHVlLlwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5XCIsXG4gICAgXCIhZG9jXCI6IFwiVGhlIEphdmFTY3JpcHQgQXJyYXkgZ2xvYmFsIG9iamVjdCBpcyBhIGNvbnN0cnVjdG9yIGZvciBhcnJheXMsIHdoaWNoIGFyZSBoaWdoLWxldmVsLCBsaXN0LWxpa2Ugb2JqZWN0cy5cIlxuICB9LFxuICBcIlN0cmluZ1wiOiB7XG4gICAgXCIhdHlwZVwiOiBcImZuKHZhbHVlOiA/KSAtPiBzdHJpbmdcIixcbiAgICBcImZyb21DaGFyQ29kZVwiOiB7XG4gICAgICBcIiF0eXBlXCI6IFwiZm4oY29kZTogbnVtYmVyKSAtPiBzdHJpbmdcIixcbiAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2Zyb21DaGFyQ29kZVwiLFxuICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyBhIHN0cmluZyBjcmVhdGVkIGJ5IHVzaW5nIHRoZSBzcGVjaWZpZWQgc2VxdWVuY2Ugb2YgVW5pY29kZSB2YWx1ZXMuXCJcbiAgICB9LFxuICAgIFwicHJvdG90eXBlXCI6IHtcbiAgICAgIFwiIXN0ZFByb3RvXCI6IFwiU3RyaW5nXCIsXG4gICAgICBcImxlbmd0aFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmdcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiVGhlIFN0cmluZyBnbG9iYWwgb2JqZWN0IGlzIGEgY29uc3RydWN0b3IgZm9yIHN0cmluZ3MsIG9yIGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycy5cIlxuICAgICAgfSxcbiAgICAgIFwiPGk+XCI6IFwic3RyaW5nXCIsXG4gICAgICBcImNoYXJBdFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihpOiBudW1iZXIpIC0+IHN0cmluZ1wiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9jaGFyQXRcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgc3BlY2lmaWVkIGNoYXJhY3RlciBmcm9tIGEgc3RyaW5nLlwiXG4gICAgICB9LFxuICAgICAgXCJjaGFyQ29kZUF0XCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKGk6IG51bWJlcikgLT4gbnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2NoYXJDb2RlQXRcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgbnVtZXJpYyBVbmljb2RlIHZhbHVlIG9mIHRoZSBjaGFyYWN0ZXIgYXQgdGhlIGdpdmVuIGluZGV4IChleGNlcHQgZm9yIHVuaWNvZGUgY29kZXBvaW50cyA+IDB4MTAwMDApLlwiXG4gICAgICB9LFxuICAgICAgXCJpbmRleE9mXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKGNoYXI6IHN0cmluZywgZnJvbT86IG51bWJlcikgLT4gbnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2luZGV4T2ZcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgaW5kZXggd2l0aGluIHRoZSBjYWxsaW5nIFN0cmluZyBvYmplY3Qgb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgdGhlIHNwZWNpZmllZCB2YWx1ZSwgc3RhcnRpbmcgdGhlIHNlYXJjaCBhdCBmcm9tSW5kZXgsXFxucmV0dXJucyAtMSBpZiB0aGUgdmFsdWUgaXMgbm90IGZvdW5kLlwiXG4gICAgICB9LFxuICAgICAgXCJsYXN0SW5kZXhPZlwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihjaGFyOiBzdHJpbmcsIGZyb20/OiBudW1iZXIpIC0+IG51bWJlclwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9sYXN0SW5kZXhPZlwiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIHRoZSBpbmRleCB3aXRoaW4gdGhlIGNhbGxpbmcgU3RyaW5nIG9iamVjdCBvZiB0aGUgbGFzdCBvY2N1cnJlbmNlIG9mIHRoZSBzcGVjaWZpZWQgdmFsdWUsIG9yIC0xIGlmIG5vdCBmb3VuZC4gVGhlIGNhbGxpbmcgc3RyaW5nIGlzIHNlYXJjaGVkIGJhY2t3YXJkLCBzdGFydGluZyBhdCBmcm9tSW5kZXguXCJcbiAgICAgIH0sXG4gICAgICBcInN1YnN0cmluZ1wiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihmcm9tOiBudW1iZXIsIHRvPzogbnVtYmVyKSAtPiBzdHJpbmdcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvc3Vic3RyaW5nXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgYSBzdWJzZXQgb2YgYSBzdHJpbmcgYmV0d2VlbiBvbmUgaW5kZXggYW5kIGFub3RoZXIsIG9yIHRocm91Z2ggdGhlIGVuZCBvZiB0aGUgc3RyaW5nLlwiXG4gICAgICB9LFxuICAgICAgXCJzdWJzdHJcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oZnJvbTogbnVtYmVyLCBsZW5ndGg/OiBudW1iZXIpIC0+IHN0cmluZ1wiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9zdWJzdHJcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgY2hhcmFjdGVycyBpbiBhIHN0cmluZyBiZWdpbm5pbmcgYXQgdGhlIHNwZWNpZmllZCBsb2NhdGlvbiB0aHJvdWdoIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGNoYXJhY3RlcnMuXCJcbiAgICAgIH0sXG4gICAgICBcInNsaWNlXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKGZyb206IG51bWJlciwgdG8/OiBudW1iZXIpIC0+IHN0cmluZ1wiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9zbGljZVwiLFxuICAgICAgICBcIiFkb2NcIjogXCJFeHRyYWN0cyBhIHNlY3Rpb24gb2YgYSBzdHJpbmcgYW5kIHJldHVybnMgYSBuZXcgc3RyaW5nLlwiXG4gICAgICB9LFxuICAgICAgXCJ0cmltXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKCkgLT4gc3RyaW5nXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL1RyaW1cIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmVtb3ZlcyB3aGl0ZXNwYWNlIGZyb20gYm90aCBlbmRzIG9mIHRoZSBzdHJpbmcuXCJcbiAgICAgIH0sXG4gICAgICBcInRyaW1MZWZ0XCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKCkgLT4gc3RyaW5nXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL1RyaW1MZWZ0XCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJlbW92ZXMgd2hpdGVzcGFjZSBmcm9tIHRoZSBsZWZ0IGVuZCBvZiB0aGUgc3RyaW5nLlwiXG4gICAgICB9LFxuICAgICAgXCJ0cmltUmlnaHRcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oKSAtPiBzdHJpbmdcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvVHJpbVJpZ2h0XCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJlbW92ZXMgd2hpdGVzcGFjZSBmcm9tIHRoZSByaWdodCBlbmQgb2YgdGhlIHN0cmluZy5cIlxuICAgICAgfSxcbiAgICAgIFwidG9VcHBlckNhc2VcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oKSAtPiBzdHJpbmdcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvdG9VcHBlckNhc2VcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgY2FsbGluZyBzdHJpbmcgdmFsdWUgY29udmVydGVkIHRvIHVwcGVyY2FzZS5cIlxuICAgICAgfSxcbiAgICAgIFwidG9Mb3dlckNhc2VcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oKSAtPiBzdHJpbmdcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvdG9Mb3dlckNhc2VcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgY2FsbGluZyBzdHJpbmcgdmFsdWUgY29udmVydGVkIHRvIGxvd2VyY2FzZS5cIlxuICAgICAgfSxcbiAgICAgIFwidG9Mb2NhbGVVcHBlckNhc2VcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oKSAtPiBzdHJpbmdcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvdG9Mb2NhbGVVcHBlckNhc2VcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgY2FsbGluZyBzdHJpbmcgdmFsdWUgY29udmVydGVkIHRvIHVwcGVyIGNhc2UsIGFjY29yZGluZyB0byBhbnkgbG9jYWxlLXNwZWNpZmljIGNhc2UgbWFwcGluZ3MuXCJcbiAgICAgIH0sXG4gICAgICBcInRvTG9jYWxlTG93ZXJDYXNlXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKCkgLT4gc3RyaW5nXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3RvTG9jYWxlTG93ZXJDYXNlXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIGNhbGxpbmcgc3RyaW5nIHZhbHVlIGNvbnZlcnRlZCB0byBsb3dlciBjYXNlLCBhY2NvcmRpbmcgdG8gYW55IGxvY2FsZS1zcGVjaWZpYyBjYXNlIG1hcHBpbmdzLlwiXG4gICAgICB9LFxuICAgICAgXCJzcGxpdFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihwYXR0ZXJuOiBzdHJpbmcpIC0+IFtzdHJpbmddXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3NwbGl0XCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlNwbGl0cyBhIFN0cmluZyBvYmplY3QgaW50byBhbiBhcnJheSBvZiBzdHJpbmdzIGJ5IHNlcGFyYXRpbmcgdGhlIHN0cmluZyBpbnRvIHN1YnN0cmluZ3MuXCJcbiAgICAgIH0sXG4gICAgICBcImNvbmNhdFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihvdGhlcjogc3RyaW5nKSAtPiBzdHJpbmdcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvY29uY2F0XCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIkNvbWJpbmVzIHRoZSB0ZXh0IG9mIHR3byBvciBtb3JlIHN0cmluZ3MgYW5kIHJldHVybnMgYSBuZXcgc3RyaW5nLlwiXG4gICAgICB9LFxuICAgICAgXCJsb2NhbGVDb21wYXJlXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKG90aGVyOiBzdHJpbmcpIC0+IG51bWJlclwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9sb2NhbGVDb21wYXJlXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgYSBudW1iZXIgaW5kaWNhdGluZyB3aGV0aGVyIGEgcmVmZXJlbmNlIHN0cmluZyBjb21lcyBiZWZvcmUgb3IgYWZ0ZXIgb3IgaXMgdGhlIHNhbWUgYXMgdGhlIGdpdmVuIHN0cmluZyBpbiBzb3J0IG9yZGVyLlwiXG4gICAgICB9LFxuICAgICAgXCJtYXRjaFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihwYXR0ZXJuOiArUmVnRXhwKSAtPiBbc3RyaW5nXVwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9tYXRjaFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJVc2VkIHRvIHJldHJpZXZlIHRoZSBtYXRjaGVzIHdoZW4gbWF0Y2hpbmcgYSBzdHJpbmcgYWdhaW5zdCBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cIlxuICAgICAgfSxcbiAgICAgIFwicmVwbGFjZVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihwYXR0ZXJuOiArUmVnRXhwLCByZXBsYWNlbWVudDogc3RyaW5nKSAtPiBzdHJpbmdcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvcmVwbGFjZVwiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIGEgbmV3IHN0cmluZyB3aXRoIHNvbWUgb3IgYWxsIG1hdGNoZXMgb2YgYSBwYXR0ZXJuIHJlcGxhY2VkIGJ5IGEgcmVwbGFjZW1lbnQuICBUaGUgcGF0dGVybiBjYW4gYmUgYSBzdHJpbmcgb3IgYSBSZWdFeHAsIGFuZCB0aGUgcmVwbGFjZW1lbnQgY2FuIGJlIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGZvciBlYWNoIG1hdGNoLlwiXG4gICAgICB9LFxuICAgICAgXCJzZWFyY2hcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4ocGF0dGVybjogK1JlZ0V4cCkgLT4gbnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3NlYXJjaFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJFeGVjdXRlcyB0aGUgc2VhcmNoIGZvciBhIG1hdGNoIGJldHdlZW4gYSByZWd1bGFyIGV4cHJlc3Npb24gYW5kIHRoaXMgU3RyaW5nIG9iamVjdC5cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmdcIixcbiAgICBcIiFkb2NcIjogXCJUaGUgU3RyaW5nIGdsb2JhbCBvYmplY3QgaXMgYSBjb25zdHJ1Y3RvciBmb3Igc3RyaW5ncywgb3IgYSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzLlwiXG4gIH0sXG4gIFwiTnVtYmVyXCI6IHtcbiAgICBcIiF0eXBlXCI6IFwiZm4odmFsdWU6ID8pIC0+IG51bWJlclwiLFxuICAgIFwiTUFYX1ZBTFVFXCI6IHtcbiAgICAgIFwiIXR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL01BWF9WQUxVRVwiLFxuICAgICAgXCIhZG9jXCI6IFwiVGhlIG1heGltdW0gbnVtZXJpYyB2YWx1ZSByZXByZXNlbnRhYmxlIGluIEphdmFTY3JpcHQuXCJcbiAgICB9LFxuICAgIFwiTUlOX1ZBTFVFXCI6IHtcbiAgICAgIFwiIXR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL01JTl9WQUxVRVwiLFxuICAgICAgXCIhZG9jXCI6IFwiVGhlIHNtYWxsZXN0IHBvc2l0aXZlIG51bWVyaWMgdmFsdWUgcmVwcmVzZW50YWJsZSBpbiBKYXZhU2NyaXB0LlwiXG4gICAgfSxcbiAgICBcIlBPU0lUSVZFX0lORklOSVRZXCI6IHtcbiAgICAgIFwiIXR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL1BPU0lUSVZFX0lORklOSVRZXCIsXG4gICAgICBcIiFkb2NcIjogXCJBIHZhbHVlIHJlcHJlc2VudGluZyB0aGUgcG9zaXRpdmUgSW5maW5pdHkgdmFsdWUuXCJcbiAgICB9LFxuICAgIFwiTkVHQVRJVkVfSU5GSU5JVFlcIjoge1xuICAgICAgXCIhdHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9OdW1iZXIvTkVHQVRJVkVfSU5GSU5JVFlcIixcbiAgICAgIFwiIWRvY1wiOiBcIkEgdmFsdWUgcmVwcmVzZW50aW5nIHRoZSBuZWdhdGl2ZSBJbmZpbml0eSB2YWx1ZS5cIlxuICAgIH0sXG4gICAgXCJwcm90b3R5cGVcIjoge1xuICAgICAgXCIhc3RkUHJvdG9cIjogXCJOdW1iZXJcIixcbiAgICAgIFwidG9TdHJpbmdcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4ocmFkaXg/OiBudW1iZXIpIC0+IHN0cmluZ1wiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL051bWJlci90b1N0cmluZ1wiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgc3BlY2lmaWVkIE51bWJlciBvYmplY3RcIlxuICAgICAgfSxcbiAgICAgIFwidG9GaXhlZFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihkaWdpdHM6IG51bWJlcikgLT4gc3RyaW5nXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL3RvRml4ZWRcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiRm9ybWF0cyBhIG51bWJlciB1c2luZyBmaXhlZC1wb2ludCBub3RhdGlvblwiXG4gICAgICB9LFxuICAgICAgXCJ0b0V4cG9uZW50aWFsXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKGRpZ2l0czogbnVtYmVyKSAtPiBzdHJpbmdcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9OdW1iZXIvdG9FeHBvbmVudGlhbFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgTnVtYmVyIG9iamVjdCBpbiBleHBvbmVudGlhbCBub3RhdGlvblwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL051bWJlclwiLFxuICAgIFwiIWRvY1wiOiBcIlRoZSBOdW1iZXIgSmF2YVNjcmlwdCBvYmplY3QgaXMgYSB3cmFwcGVyIG9iamVjdCBhbGxvd2luZyB5b3UgdG8gd29yayB3aXRoIG51bWVyaWNhbCB2YWx1ZXMuIEEgTnVtYmVyIG9iamVjdCBpcyBjcmVhdGVkIHVzaW5nIHRoZSBOdW1iZXIoKSBjb25zdHJ1Y3Rvci5cIlxuICB9LFxuICBcIkJvb2xlYW5cIjoge1xuICAgIFwiIXR5cGVcIjogXCJmbih2YWx1ZTogPykgLT4gYm9vbFwiLFxuICAgIFwicHJvdG90eXBlXCI6IHtcbiAgICAgIFwiIXN0ZFByb3RvXCI6IFwiQm9vbGVhblwiXG4gICAgfSxcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Jvb2xlYW5cIixcbiAgICBcIiFkb2NcIjogXCJUaGUgQm9vbGVhbiBvYmplY3QgaXMgYW4gb2JqZWN0IHdyYXBwZXIgZm9yIGEgYm9vbGVhbiB2YWx1ZS5cIlxuICB9LFxuICBcIlJlZ0V4cFwiOiB7XG4gICAgXCIhdHlwZVwiOiBcImZuKHNvdXJjZTogc3RyaW5nLCBmbGFncz86IHN0cmluZylcIixcbiAgICBcInByb3RvdHlwZVwiOiB7XG4gICAgICBcIiFzdGRQcm90b1wiOiBcIlJlZ0V4cFwiLFxuICAgICAgXCJleGVjXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKGlucHV0OiBzdHJpbmcpIC0+IFtzdHJpbmddXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUmVnRXhwL2V4ZWNcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiRXhlY3V0ZXMgYSBzZWFyY2ggZm9yIGEgbWF0Y2ggaW4gYSBzcGVjaWZpZWQgc3RyaW5nLiBSZXR1cm5zIGEgcmVzdWx0IGFycmF5LCBvciBudWxsLlwiXG4gICAgICB9LFxuICAgICAgXCJjb21waWxlXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKHNvdXJjZTogc3RyaW5nLCBmbGFncz86IHN0cmluZylcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9SZWdFeHBcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiQ3JlYXRlcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBvYmplY3QgZm9yIG1hdGNoaW5nIHRleHQgd2l0aCBhIHBhdHRlcm4uXCJcbiAgICAgIH0sXG4gICAgICBcInRlc3RcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oaW5wdXQ6IHN0cmluZykgLT4gYm9vbFwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1JlZ0V4cC90ZXN0XCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIkV4ZWN1dGVzIHRoZSBzZWFyY2ggZm9yIGEgbWF0Y2ggYmV0d2VlbiBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBhbmQgYSBzcGVjaWZpZWQgc3RyaW5nLiBSZXR1cm5zIHRydWUgb3IgZmFsc2UuXCJcbiAgICAgIH0sXG4gICAgICBcImdsb2JhbFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJib29sXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUmVnRXhwXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIkNyZWF0ZXMgYSByZWd1bGFyIGV4cHJlc3Npb24gb2JqZWN0IGZvciBtYXRjaGluZyB0ZXh0IHdpdGggYSBwYXR0ZXJuLlwiXG4gICAgICB9LFxuICAgICAgXCJpZ25vcmVDYXNlXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImJvb2xcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9SZWdFeHBcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiQ3JlYXRlcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBvYmplY3QgZm9yIG1hdGNoaW5nIHRleHQgd2l0aCBhIHBhdHRlcm4uXCJcbiAgICAgIH0sXG4gICAgICBcIm11bHRpbGluZVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJib29sXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUmVnRXhwL211bHRpbGluZVwiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZWZsZWN0cyB3aGV0aGVyIG9yIG5vdCB0byBzZWFyY2ggaW4gc3RyaW5ncyBhY3Jvc3MgbXVsdGlwbGUgbGluZXMuXFxuXCJcbiAgICAgIH0sXG4gICAgICBcInNvdXJjZVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9SZWdFeHAvc291cmNlXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIkEgcmVhZC1vbmx5IHByb3BlcnR5IHRoYXQgY29udGFpbnMgdGhlIHRleHQgb2YgdGhlIHBhdHRlcm4sIGV4Y2x1ZGluZyB0aGUgZm9yd2FyZCBzbGFzaGVzLlxcblwiXG4gICAgICB9LFxuICAgICAgXCJsYXN0SW5kZXhcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUmVnRXhwL2xhc3RJbmRleFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJBIHJlYWQvd3JpdGUgaW50ZWdlciBwcm9wZXJ0eSB0aGF0IHNwZWNpZmllcyB0aGUgaW5kZXggYXQgd2hpY2ggdG8gc3RhcnQgdGhlIG5leHQgbWF0Y2guXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUmVnRXhwXCIsXG4gICAgXCIhZG9jXCI6IFwiQ3JlYXRlcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBvYmplY3QgZm9yIG1hdGNoaW5nIHRleHQgd2l0aCBhIHBhdHRlcm4uXCJcbiAgfSxcbiAgXCJEYXRlXCI6IHtcbiAgICBcIiF0eXBlXCI6IFwiZm4obXM6IG51bWJlcilcIixcbiAgICBcInBhcnNlXCI6IHtcbiAgICAgIFwiIXR5cGVcIjogXCJmbihzb3VyY2U6IHN0cmluZykgLT4gK0RhdGVcIixcbiAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS9wYXJzZVwiLFxuICAgICAgXCIhZG9jXCI6IFwiUGFyc2VzIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgZGF0ZSwgYW5kIHJldHVybnMgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgSmFudWFyeSAxLCAxOTcwLCAwMDowMDowMCBVVEMuXCJcbiAgICB9LFxuICAgIFwiVVRDXCI6IHtcbiAgICAgIFwiIXR5cGVcIjogXCJmbih5ZWFyOiBudW1iZXIsIG1vbnRoOiBudW1iZXIsIGRhdGU6IG51bWJlciwgaG91cj86IG51bWJlciwgbWluPzogbnVtYmVyLCBzZWM/OiBudW1iZXIsIG1zPzogbnVtYmVyKSAtPiBudW1iZXJcIixcbiAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS9VVENcIixcbiAgICAgIFwiIWRvY1wiOiBcIkFjY2VwdHMgdGhlIHNhbWUgcGFyYW1ldGVycyBhcyB0aGUgbG9uZ2VzdCBmb3JtIG9mIHRoZSBjb25zdHJ1Y3RvciwgYW5kIHJldHVybnMgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaW4gYSBEYXRlIG9iamVjdCBzaW5jZSBKYW51YXJ5IDEsIDE5NzAsIDAwOjAwOjAwLCB1bml2ZXJzYWwgdGltZS5cIlxuICAgIH0sXG4gICAgXCJub3dcIjoge1xuICAgICAgXCIhdHlwZVwiOiBcImZuKCkgLT4gbnVtYmVyXCIsXG4gICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUvbm93XCIsXG4gICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGVsYXBzZWQgc2luY2UgMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDLlwiXG4gICAgfSxcbiAgICBcInByb3RvdHlwZVwiOiB7XG4gICAgICBcInRvVVRDU3RyaW5nXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKCkgLT4gc3RyaW5nXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS90b1VUQ1N0cmluZ1wiLFxuICAgICAgICBcIiFkb2NcIjogXCJDb252ZXJ0cyBhIGRhdGUgdG8gYSBzdHJpbmcsIHVzaW5nIHRoZSB1bml2ZXJzYWwgdGltZSBjb252ZW50aW9uLlwiXG4gICAgICB9LFxuICAgICAgXCJ0b0lTT1N0cmluZ1wiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbigpIC0+IHN0cmluZ1wiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUvdG9JU09TdHJpbmdcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiSmF2YVNjcmlwdCBwcm92aWRlcyBhIGRpcmVjdCB3YXkgdG8gY29udmVydCBhIGRhdGUgb2JqZWN0IGludG8gYSBzdHJpbmcgaW4gSVNPIGZvcm1hdCwgdGhlIElTTyA4NjAxIEV4dGVuZGVkIEZvcm1hdC5cIlxuICAgICAgfSxcbiAgICAgIFwidG9EYXRlU3RyaW5nXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKCkgLT4gc3RyaW5nXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS90b0RhdGVTdHJpbmdcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgZGF0ZSBwb3J0aW9uIG9mIGEgRGF0ZSBvYmplY3QgaW4gaHVtYW4gcmVhZGFibGUgZm9ybSBpbiBBbWVyaWNhbiBFbmdsaXNoLlwiXG4gICAgICB9LFxuICAgICAgXCJ0b1RpbWVTdHJpbmdcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oKSAtPiBzdHJpbmdcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL3RvVGltZVN0cmluZ1wiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIHRoZSB0aW1lIHBvcnRpb24gb2YgYSBEYXRlIG9iamVjdCBpbiBodW1hbiByZWFkYWJsZSBmb3JtIGluIEFtZXJpY2FuIEVuZ2xpc2guXCJcbiAgICAgIH0sXG4gICAgICBcInRvTG9jYWxlRGF0ZVN0cmluZ1wiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbigpIC0+IHN0cmluZ1wiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUvdG9Mb2NhbGVEYXRlU3RyaW5nXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIkNvbnZlcnRzIGEgZGF0ZSB0byBhIHN0cmluZywgcmV0dXJuaW5nIHRoZSBcXFwiZGF0ZVxcXCIgcG9ydGlvbiB1c2luZyB0aGUgb3BlcmF0aW5nIHN5c3RlbSdzIGxvY2FsZSdzIGNvbnZlbnRpb25zLlxcblwiXG4gICAgICB9LFxuICAgICAgXCJ0b0xvY2FsZVRpbWVTdHJpbmdcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oKSAtPiBzdHJpbmdcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL3RvTG9jYWxlVGltZVN0cmluZ1wiLFxuICAgICAgICBcIiFkb2NcIjogXCJDb252ZXJ0cyBhIGRhdGUgdG8gYSBzdHJpbmcsIHJldHVybmluZyB0aGUgXFxcInRpbWVcXFwiIHBvcnRpb24gdXNpbmcgdGhlIGN1cnJlbnQgbG9jYWxlJ3MgY29udmVudGlvbnMuXCJcbiAgICAgIH0sXG4gICAgICBcImdldFRpbWVcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oKSAtPiBudW1iZXJcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL2dldFRpbWVcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgbnVtZXJpYyB2YWx1ZSBjb3JyZXNwb25kaW5nIHRvIHRoZSB0aW1lIGZvciB0aGUgc3BlY2lmaWVkIGRhdGUgYWNjb3JkaW5nIHRvIHVuaXZlcnNhbCB0aW1lLlwiXG4gICAgICB9LFxuICAgICAgXCJnZXRGdWxsWWVhclwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbigpIC0+IG51bWJlclwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUvZ2V0RnVsbFllYXJcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgeWVhciBvZiB0aGUgc3BlY2lmaWVkIGRhdGUgYWNjb3JkaW5nIHRvIGxvY2FsIHRpbWUuXCJcbiAgICAgIH0sXG4gICAgICBcImdldFllYXJcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oKSAtPiBudW1iZXJcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL2dldFllYXJcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgeWVhciBpbiB0aGUgc3BlY2lmaWVkIGRhdGUgYWNjb3JkaW5nIHRvIGxvY2FsIHRpbWUuXCJcbiAgICAgIH0sXG4gICAgICBcImdldE1vbnRoXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKCkgLT4gbnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS9nZXRNb250aFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIHRoZSBtb250aCBpbiB0aGUgc3BlY2lmaWVkIGRhdGUgYWNjb3JkaW5nIHRvIGxvY2FsIHRpbWUuXCJcbiAgICAgIH0sXG4gICAgICBcImdldFVUQ01vbnRoXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKCkgLT4gbnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS9nZXRVVENNb250aFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIHRoZSBtb250aCBvZiB0aGUgc3BlY2lmaWVkIGRhdGUgYWNjb3JkaW5nIHRvIHVuaXZlcnNhbCB0aW1lLlxcblwiXG4gICAgICB9LFxuICAgICAgXCJnZXREYXRlXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKCkgLT4gbnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS9nZXREYXRlXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIGRheSBvZiB0aGUgbW9udGggZm9yIHRoZSBzcGVjaWZpZWQgZGF0ZSBhY2NvcmRpbmcgdG8gbG9jYWwgdGltZS5cIlxuICAgICAgfSxcbiAgICAgIFwiZ2V0VVRDRGF0ZVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbigpIC0+IG51bWJlclwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUvZ2V0VVRDRGF0ZVwiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIHRoZSBkYXkgKGRhdGUpIG9mIHRoZSBtb250aCBpbiB0aGUgc3BlY2lmaWVkIGRhdGUgYWNjb3JkaW5nIHRvIHVuaXZlcnNhbCB0aW1lLlxcblwiXG4gICAgICB9LFxuICAgICAgXCJnZXREYXlcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oKSAtPiBudW1iZXJcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL2dldERheVwiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIHRoZSBkYXkgb2YgdGhlIHdlZWsgZm9yIHRoZSBzcGVjaWZpZWQgZGF0ZSBhY2NvcmRpbmcgdG8gbG9jYWwgdGltZS5cIlxuICAgICAgfSxcbiAgICAgIFwiZ2V0VVRDRGF5XCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKCkgLT4gbnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS9nZXRVVENEYXlcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgZGF5IG9mIHRoZSB3ZWVrIGluIHRoZSBzcGVjaWZpZWQgZGF0ZSBhY2NvcmRpbmcgdG8gdW5pdmVyc2FsIHRpbWUuXFxuXCJcbiAgICAgIH0sXG4gICAgICBcImdldEhvdXJzXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKCkgLT4gbnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS9nZXRIb3Vyc1wiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIHRoZSBob3VyIGZvciB0aGUgc3BlY2lmaWVkIGRhdGUgYWNjb3JkaW5nIHRvIGxvY2FsIHRpbWUuXCJcbiAgICAgIH0sXG4gICAgICBcImdldFVUQ0hvdXJzXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKCkgLT4gbnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS9nZXRVVENIb3Vyc1wiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIHRoZSBob3VycyBpbiB0aGUgc3BlY2lmaWVkIGRhdGUgYWNjb3JkaW5nIHRvIHVuaXZlcnNhbCB0aW1lLlxcblwiXG4gICAgICB9LFxuICAgICAgXCJnZXRNaW51dGVzXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKCkgLT4gbnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS9nZXRNaW51dGVzXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIG1pbnV0ZXMgaW4gdGhlIHNwZWNpZmllZCBkYXRlIGFjY29yZGluZyB0byBsb2NhbCB0aW1lLlwiXG4gICAgICB9LFxuICAgICAgXCJnZXRVVENNaW51dGVzXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKCkgLT4gbnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZVwiLFxuICAgICAgICBcIiFkb2NcIjogXCJDcmVhdGVzIEphdmFTY3JpcHQgRGF0ZSBpbnN0YW5jZXMgd2hpY2ggbGV0IHlvdSB3b3JrIHdpdGggZGF0ZXMgYW5kIHRpbWVzLlwiXG4gICAgICB9LFxuICAgICAgXCJnZXRTZWNvbmRzXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKCkgLT4gbnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS9nZXRTZWNvbmRzXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIHNlY29uZHMgaW4gdGhlIHNwZWNpZmllZCBkYXRlIGFjY29yZGluZyB0byBsb2NhbCB0aW1lLlwiXG4gICAgICB9LFxuICAgICAgXCJnZXRVVENTZWNvbmRzXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKCkgLT4gbnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS9nZXRVVENTZWNvbmRzXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIHNlY29uZHMgaW4gdGhlIHNwZWNpZmllZCBkYXRlIGFjY29yZGluZyB0byB1bml2ZXJzYWwgdGltZS5cXG5cIlxuICAgICAgfSxcbiAgICAgIFwiZ2V0TWlsbGlzZWNvbmRzXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKCkgLT4gbnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS9nZXRNaWxsaXNlY29uZHNcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgbWlsbGlzZWNvbmRzIGluIHRoZSBzcGVjaWZpZWQgZGF0ZSBhY2NvcmRpbmcgdG8gbG9jYWwgdGltZS5cIlxuICAgICAgfSxcbiAgICAgIFwiZ2V0VVRDTWlsbGlzZWNvbmRzXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKCkgLT4gbnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS9nZXRVVENNaWxsaXNlY29uZHNcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgbWlsbGlzZWNvbmRzIGluIHRoZSBzcGVjaWZpZWQgZGF0ZSBhY2NvcmRpbmcgdG8gdW5pdmVyc2FsIHRpbWUuXFxuXCJcbiAgICAgIH0sXG4gICAgICBcImdldFRpbWV6b25lT2Zmc2V0XCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKCkgLT4gbnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS9nZXRUaW1lem9uZU9mZnNldFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIHRoZSB0aW1lLXpvbmUgb2Zmc2V0IGZyb20gVVRDLCBpbiBtaW51dGVzLCBmb3IgdGhlIGN1cnJlbnQgbG9jYWxlLlwiXG4gICAgICB9LFxuICAgICAgXCJzZXRUaW1lXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKGRhdGU6ICtEYXRlKSAtPiBudW1iZXJcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL3NldFRpbWVcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiU2V0cyB0aGUgRGF0ZSBvYmplY3QgdG8gdGhlIHRpbWUgcmVwcmVzZW50ZWQgYnkgYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIEphbnVhcnkgMSwgMTk3MCwgMDA6MDA6MDAgVVRDLlxcblwiXG4gICAgICB9LFxuICAgICAgXCJzZXRGdWxsWWVhclwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbih5ZWFyOiBudW1iZXIpIC0+IG51bWJlclwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUvc2V0RnVsbFllYXJcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiU2V0cyB0aGUgZnVsbCB5ZWFyIGZvciBhIHNwZWNpZmllZCBkYXRlIGFjY29yZGluZyB0byBsb2NhbCB0aW1lLlxcblwiXG4gICAgICB9LFxuICAgICAgXCJzZXRVVENGdWxsWWVhclwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbih5ZWFyOiBudW1iZXIpIC0+IG51bWJlclwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUvc2V0VVRDRnVsbFllYXJcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiU2V0cyB0aGUgZnVsbCB5ZWFyIGZvciBhIHNwZWNpZmllZCBkYXRlIGFjY29yZGluZyB0byB1bml2ZXJzYWwgdGltZS5cXG5cIlxuICAgICAgfSxcbiAgICAgIFwic2V0TW9udGhcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4obW9udGg6IG51bWJlcikgLT4gbnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS9zZXRNb250aFwiLFxuICAgICAgICBcIiFkb2NcIjogXCJTZXQgdGhlIG1vbnRoIGZvciBhIHNwZWNpZmllZCBkYXRlIGFjY29yZGluZyB0byBsb2NhbCB0aW1lLlwiXG4gICAgICB9LFxuICAgICAgXCJzZXRVVENNb250aFwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihtb250aDogbnVtYmVyKSAtPiBudW1iZXJcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL3NldFVUQ01vbnRoXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlNldHMgdGhlIG1vbnRoIGZvciBhIHNwZWNpZmllZCBkYXRlIGFjY29yZGluZyB0byB1bml2ZXJzYWwgdGltZS5cXG5cIlxuICAgICAgfSxcbiAgICAgIFwic2V0RGF0ZVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihkYXk6IG51bWJlcikgLT4gbnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS9zZXREYXRlXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlNldHMgdGhlIGRheSBvZiB0aGUgbW9udGggZm9yIGEgc3BlY2lmaWVkIGRhdGUgYWNjb3JkaW5nIHRvIGxvY2FsIHRpbWUuXCJcbiAgICAgIH0sXG4gICAgICBcInNldFVUQ0RhdGVcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oZGF5OiBudW1iZXIpIC0+IG51bWJlclwiLFxuICAgICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUvc2V0VVRDRGF0ZVwiLFxuICAgICAgICBcIiFkb2NcIjogXCJTZXRzIHRoZSBkYXkgb2YgdGhlIG1vbnRoIGZvciBhIHNwZWNpZmllZCBkYXRlIGFjY29yZGluZyB0byB1bml2ZXJzYWwgdGltZS5cXG5cIlxuICAgICAgfSxcbiAgICAgIFwic2V0SG91cnNcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oaG91cjogbnVtYmVyKSAtPiBudW1iZXJcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL3NldEhvdXJzXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlNldHMgdGhlIGhvdXJzIGZvciBhIHNwZWNpZmllZCBkYXRlIGFjY29yZGluZyB0byBsb2NhbCB0aW1lLCBhbmQgcmV0dXJucyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSAxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMgdW50aWwgdGhlIHRpbWUgcmVwcmVzZW50ZWQgYnkgdGhlIHVwZGF0ZWQgRGF0ZSBpbnN0YW5jZS5cIlxuICAgICAgfSxcbiAgICAgIFwic2V0VVRDSG91cnNcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4oaG91cjogbnVtYmVyKSAtPiBudW1iZXJcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL3NldFVUQ0hvdXJzXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlNldHMgdGhlIGhvdXIgZm9yIGEgc3BlY2lmaWVkIGRhdGUgYWNjb3JkaW5nIHRvIHVuaXZlcnNhbCB0aW1lLlxcblwiXG4gICAgICB9LFxuICAgICAgXCJzZXRNaW51dGVzXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKG1pbjogbnVtYmVyKSAtPiBudW1iZXJcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL3NldE1pbnV0ZXNcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiU2V0cyB0aGUgbWludXRlcyBmb3IgYSBzcGVjaWZpZWQgZGF0ZSBhY2NvcmRpbmcgdG8gbG9jYWwgdGltZS5cIlxuICAgICAgfSxcbiAgICAgIFwic2V0VVRDTWludXRlc1wiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihtaW46IG51bWJlcikgLT4gbnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS9zZXRVVENNaW51dGVzXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlNldHMgdGhlIG1pbnV0ZXMgZm9yIGEgc3BlY2lmaWVkIGRhdGUgYWNjb3JkaW5nIHRvIHVuaXZlcnNhbCB0aW1lLlxcblwiXG4gICAgICB9LFxuICAgICAgXCJzZXRTZWNvbmRzXCI6IHtcbiAgICAgICAgXCIhdHlwZVwiOiBcImZuKHNlYzogbnVtYmVyKSAtPiBudW1iZXJcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL3NldFNlY29uZHNcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiU2V0cyB0aGUgc2Vjb25kcyBmb3IgYSBzcGVjaWZpZWQgZGF0ZSBhY2NvcmRpbmcgdG8gbG9jYWwgdGltZS5cIlxuICAgICAgfSxcbiAgICAgIFwic2V0VVRDU2Vjb25kc1wiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJmbihzZWM6IG51bWJlcikgLT4gbnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS9zZXRVVENTZWNvbmRzXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIlNldHMgdGhlIHNlY29uZHMgZm9yIGEgc3BlY2lmaWVkIGRhdGUgYWNjb3JkaW5nIHRvIHVuaXZlcnNhbCB0aW1lLlxcblwiXG4gICAgICB9LFxuICAgICAgXCJzZXRNaWxsaXNlY29uZHNcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4obXM6IG51bWJlcikgLT4gbnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS9zZXRNaWxsaXNlY29uZHNcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiU2V0cyB0aGUgbWlsbGlzZWNvbmRzIGZvciBhIHNwZWNpZmllZCBkYXRlIGFjY29yZGluZyB0byBsb2NhbCB0aW1lLlxcblwiXG4gICAgICB9LFxuICAgICAgXCJzZXRVVENNaWxsaXNlY29uZHNcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwiZm4obXM6IG51bWJlcikgLT4gbnVtYmVyXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS9zZXRVVENNaWxsaXNlY29uZHNcIixcbiAgICAgICAgXCIhZG9jXCI6IFwiU2V0cyB0aGUgbWlsbGlzZWNvbmRzIGZvciBhIHNwZWNpZmllZCBkYXRlIGFjY29yZGluZyB0byB1bml2ZXJzYWwgdGltZS5cXG5cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlXCIsXG4gICAgXCIhZG9jXCI6IFwiQ3JlYXRlcyBKYXZhU2NyaXB0IERhdGUgaW5zdGFuY2VzIHdoaWNoIGxldCB5b3Ugd29yayB3aXRoIGRhdGVzIGFuZCB0aW1lcy5cIlxuICB9LFxuICBcIkVycm9yXCI6IHtcbiAgICBcIiF0eXBlXCI6IFwiZm4obWVzc2FnZTogc3RyaW5nKVwiLFxuICAgIFwicHJvdG90eXBlXCI6IHtcbiAgICAgIFwibmFtZVwiOiB7XG4gICAgICAgIFwiIXR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9FcnJvci9uYW1lXCIsXG4gICAgICAgIFwiIWRvY1wiOiBcIkEgbmFtZSBmb3IgdGhlIHR5cGUgb2YgZXJyb3IuXCJcbiAgICAgIH0sXG4gICAgICBcIm1lc3NhZ2VcIjoge1xuICAgICAgICBcIiF0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3IvbWVzc2FnZVwiLFxuICAgICAgICBcIiFkb2NcIjogXCJBIGh1bWFuLXJlYWRhYmxlIGRlc2NyaXB0aW9uIG9mIHRoZSBlcnJvci5cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9FcnJvclwiLFxuICAgIFwiIWRvY1wiOiBcIkNyZWF0ZXMgYW4gZXJyb3Igb2JqZWN0LlwiXG4gIH0sXG4gIFwiU3ludGF4RXJyb3JcIjoge1xuICAgIFwiIXR5cGVcIjogXCJmbihtZXNzYWdlOiBzdHJpbmcpXCIsXG4gICAgXCJwcm90b3R5cGVcIjogXCJFcnJvci5wcm90b3R5cGVcIixcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N5bnRheEVycm9yXCIsXG4gICAgXCIhZG9jXCI6IFwiUmVwcmVzZW50cyBhbiBlcnJvciB3aGVuIHRyeWluZyB0byBpbnRlcnByZXQgc3ludGFjdGljYWxseSBpbnZhbGlkIGNvZGUuXCJcbiAgfSxcbiAgXCJSZWZlcmVuY2VFcnJvclwiOiB7XG4gICAgXCIhdHlwZVwiOiBcImZuKG1lc3NhZ2U6IHN0cmluZylcIixcbiAgICBcInByb3RvdHlwZVwiOiBcIkVycm9yLnByb3RvdHlwZVwiLFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUmVmZXJlbmNlRXJyb3JcIixcbiAgICBcIiFkb2NcIjogXCJSZXByZXNlbnRzIGFuIGVycm9yIHdoZW4gYSBub24tZXhpc3RlbnQgdmFyaWFibGUgaXMgcmVmZXJlbmNlZC5cIlxuICB9LFxuICBcIlVSSUVycm9yXCI6IHtcbiAgICBcIiF0eXBlXCI6IFwiZm4obWVzc2FnZTogc3RyaW5nKVwiLFxuICAgIFwicHJvdG90eXBlXCI6IFwiRXJyb3IucHJvdG90eXBlXCIsXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9VUklFcnJvclwiLFxuICAgIFwiIWRvY1wiOiBcIlJlcHJlc2VudHMgYW4gZXJyb3Igd2hlbiBhIG1hbGZvcm1lZCBVUkkgaXMgZW5jb3VudGVyZWQuXCJcbiAgfSxcbiAgXCJFdmFsRXJyb3JcIjoge1xuICAgIFwiIXR5cGVcIjogXCJmbihtZXNzYWdlOiBzdHJpbmcpXCIsXG4gICAgXCJwcm90b3R5cGVcIjogXCJFcnJvci5wcm90b3R5cGVcIixcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0V2YWxFcnJvclwiLFxuICAgIFwiIWRvY1wiOiBcIlJlcHJlc2VudHMgYW4gZXJyb3IgcmVnYXJkaW5nIHRoZSBldmFsIGZ1bmN0aW9uLlwiXG4gIH0sXG4gIFwiUmFuZ2VFcnJvclwiOiB7XG4gICAgXCIhdHlwZVwiOiBcImZuKG1lc3NhZ2U6IHN0cmluZylcIixcbiAgICBcInByb3RvdHlwZVwiOiBcIkVycm9yLnByb3RvdHlwZVwiLFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUmFuZ2VFcnJvclwiLFxuICAgIFwiIWRvY1wiOiBcIlJlcHJlc2VudHMgYW4gZXJyb3Igd2hlbiBhIG51bWJlciBpcyBub3Qgd2l0aGluIHRoZSBjb3JyZWN0IHJhbmdlIGFsbG93ZWQuXCJcbiAgfSxcbiAgXCJwYXJzZUludFwiOiB7XG4gICAgXCIhdHlwZVwiOiBcImZuKHN0cmluZzogc3RyaW5nLCByYWRpeD86IG51bWJlcikgLT4gbnVtYmVyXCIsXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9wYXJzZUludFwiLFxuICAgIFwiIWRvY1wiOiBcIlBhcnNlcyBhIHN0cmluZyBhcmd1bWVudCBhbmQgcmV0dXJucyBhbiBpbnRlZ2VyIG9mIHRoZSBzcGVjaWZpZWQgcmFkaXggb3IgYmFzZS5cIlxuICB9LFxuICBcInBhcnNlRmxvYXRcIjoge1xuICAgIFwiIXR5cGVcIjogXCJmbihzdHJpbmc6IHN0cmluZykgLT4gbnVtYmVyXCIsXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9wYXJzZUZsb2F0XCIsXG4gICAgXCIhZG9jXCI6IFwiUGFyc2VzIGEgc3RyaW5nIGFyZ3VtZW50IGFuZCByZXR1cm5zIGEgZmxvYXRpbmcgcG9pbnQgbnVtYmVyLlwiXG4gIH0sXG4gIFwiaXNOYU5cIjoge1xuICAgIFwiIXR5cGVcIjogXCJmbih2YWx1ZTogbnVtYmVyKSAtPiBib29sXCIsXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9pc05hTlwiLFxuICAgIFwiIWRvY1wiOiBcIkRldGVybWluZXMgd2hldGhlciBhIHZhbHVlIGlzIE5hTiBvciBub3QuIEJlIGNhcmVmdWwsIHRoaXMgZnVuY3Rpb24gaXMgYnJva2VuLiBZb3UgbWF5IGJlIGludGVyZXN0ZWQgaW4gRUNNQVNjcmlwdCA2IE51bWJlci5pc05hTi5cIlxuICB9LFxuICBcImV2YWxcIjoge1xuICAgIFwiIXR5cGVcIjogXCJmbihjb2RlOiBzdHJpbmcpIC0+ID9cIixcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL2V2YWxcIixcbiAgICBcIiFkb2NcIjogXCJFdmFsdWF0ZXMgSmF2YVNjcmlwdCBjb2RlIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nLlwiXG4gIH0sXG4gIFwiZW5jb2RlVVJJXCI6IHtcbiAgICBcIiF0eXBlXCI6IFwiZm4odXJpOiBzdHJpbmcpIC0+IHN0cmluZ1wiLFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvZW5jb2RlVVJJXCIsXG4gICAgXCIhZG9jXCI6IFwiRW5jb2RlcyBhIFVuaWZvcm0gUmVzb3VyY2UgSWRlbnRpZmllciAoVVJJKSBieSByZXBsYWNpbmcgZWFjaCBpbnN0YW5jZSBvZiBjZXJ0YWluIGNoYXJhY3RlcnMgYnkgb25lLCB0d28sIHRocmVlLCBvciBmb3VyIGVzY2FwZSBzZXF1ZW5jZXMgcmVwcmVzZW50aW5nIHRoZSBVVEYtOCBlbmNvZGluZyBvZiB0aGUgY2hhcmFjdGVyICh3aWxsIG9ubHkgYmUgZm91ciBlc2NhcGUgc2VxdWVuY2VzIGZvciBjaGFyYWN0ZXJzIGNvbXBvc2VkIG9mIHR3byBcXFwic3Vycm9nYXRlXFxcIiBjaGFyYWN0ZXJzKS5cIlxuICB9LFxuICBcImVuY29kZVVSSUNvbXBvbmVudFwiOiB7XG4gICAgXCIhdHlwZVwiOiBcImZuKHVyaTogc3RyaW5nKSAtPiBzdHJpbmdcIixcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL2VuY29kZVVSSUNvbXBvbmVudFwiLFxuICAgIFwiIWRvY1wiOiBcIkVuY29kZXMgYSBVbmlmb3JtIFJlc291cmNlIElkZW50aWZpZXIgKFVSSSkgY29tcG9uZW50IGJ5IHJlcGxhY2luZyBlYWNoIGluc3RhbmNlIG9mIGNlcnRhaW4gY2hhcmFjdGVycyBieSBvbmUsIHR3bywgdGhyZWUsIG9yIGZvdXIgZXNjYXBlIHNlcXVlbmNlcyByZXByZXNlbnRpbmcgdGhlIFVURi04IGVuY29kaW5nIG9mIHRoZSBjaGFyYWN0ZXIgKHdpbGwgb25seSBiZSBmb3VyIGVzY2FwZSBzZXF1ZW5jZXMgZm9yIGNoYXJhY3RlcnMgY29tcG9zZWQgb2YgdHdvIFxcXCJzdXJyb2dhdGVcXFwiIGNoYXJhY3RlcnMpLlwiXG4gIH0sXG4gIFwiZGVjb2RlVVJJXCI6IHtcbiAgICBcIiF0eXBlXCI6IFwiZm4odXJpOiBzdHJpbmcpIC0+IHN0cmluZ1wiLFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvZGVjb2RlVVJJXCIsXG4gICAgXCIhZG9jXCI6IFwiRGVjb2RlcyBhIFVuaWZvcm0gUmVzb3VyY2UgSWRlbnRpZmllciAoVVJJKSBwcmV2aW91c2x5IGNyZWF0ZWQgYnkgZW5jb2RlVVJJIG9yIGJ5IGEgc2ltaWxhciByb3V0aW5lLlwiXG4gIH0sXG4gIFwiZGVjb2RlVVJJQ29tcG9uZW50XCI6IHtcbiAgICBcIiF0eXBlXCI6IFwiZm4odXJpOiBzdHJpbmcpIC0+IHN0cmluZ1wiLFxuICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvZGVjb2RlVVJJQ29tcG9uZW50XCIsXG4gICAgXCIhZG9jXCI6IFwiRGVjb2RlcyBhIFVuaWZvcm0gUmVzb3VyY2UgSWRlbnRpZmllciAoVVJJKSBjb21wb25lbnQgcHJldmlvdXNseSBjcmVhdGVkIGJ5IGVuY29kZVVSSUNvbXBvbmVudCBvciBieSBhIHNpbWlsYXIgcm91dGluZS5cIlxuICB9LFxuICBcIk1hdGhcIjoge1xuICAgIFwiRVwiOiB7XG4gICAgICBcIiF0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvRVwiLFxuICAgICAgXCIhZG9jXCI6IFwiVGhlIGJhc2Ugb2YgbmF0dXJhbCBsb2dhcml0aG1zLCBlLCBhcHByb3hpbWF0ZWx5IDIuNzE4LlwiXG4gICAgfSxcbiAgICBcIkxOMlwiOiB7XG4gICAgICBcIiF0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvTE4yXCIsXG4gICAgICBcIiFkb2NcIjogXCJUaGUgbmF0dXJhbCBsb2dhcml0aG0gb2YgMiwgYXBwcm94aW1hdGVseSAwLjY5My5cIlxuICAgIH0sXG4gICAgXCJMTjEwXCI6IHtcbiAgICAgIFwiIXR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9MTjEwXCIsXG4gICAgICBcIiFkb2NcIjogXCJUaGUgbmF0dXJhbCBsb2dhcml0aG0gb2YgMTAsIGFwcHJveGltYXRlbHkgMi4zMDIuXCJcbiAgICB9LFxuICAgIFwiTE9HMkVcIjoge1xuICAgICAgXCIhdHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL0xPRzJFXCIsXG4gICAgICBcIiFkb2NcIjogXCJUaGUgYmFzZSAyIGxvZ2FyaXRobSBvZiBFIChhcHByb3hpbWF0ZWx5IDEuNDQyKS5cIlxuICAgIH0sXG4gICAgXCJMT0cxMEVcIjoge1xuICAgICAgXCIhdHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL0xPRzEwRVwiLFxuICAgICAgXCIhZG9jXCI6IFwiVGhlIGJhc2UgMTAgbG9nYXJpdGhtIG9mIEUgKGFwcHJveGltYXRlbHkgMC40MzQpLlwiXG4gICAgfSxcbiAgICBcIlNRUlQxXzJcIjoge1xuICAgICAgXCIhdHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL1NRUlQxXzJcIixcbiAgICAgIFwiIWRvY1wiOiBcIlRoZSBzcXVhcmUgcm9vdCBvZiAxLzI7IGVxdWl2YWxlbnRseSwgMSBvdmVyIHRoZSBzcXVhcmUgcm9vdCBvZiAyLCBhcHByb3hpbWF0ZWx5IDAuNzA3LlwiXG4gICAgfSxcbiAgICBcIlNRUlQyXCI6IHtcbiAgICAgIFwiIXR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9TUVJUMlwiLFxuICAgICAgXCIhZG9jXCI6IFwiVGhlIHNxdWFyZSByb290IG9mIDIsIGFwcHJveGltYXRlbHkgMS40MTQuXCJcbiAgICB9LFxuICAgIFwiUElcIjoge1xuICAgICAgXCIhdHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL1BJXCIsXG4gICAgICBcIiFkb2NcIjogXCJUaGUgcmF0aW8gb2YgdGhlIGNpcmN1bWZlcmVuY2Ugb2YgYSBjaXJjbGUgdG8gaXRzIGRpYW1ldGVyLCBhcHByb3hpbWF0ZWx5IDMuMTQxNTkuXCJcbiAgICB9LFxuICAgIFwiYWJzXCI6IHtcbiAgICAgIFwiIXR5cGVcIjogXCJmbihudW1iZXIpIC0+IG51bWJlclwiLFxuICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2Fic1wiLFxuICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgYSBudW1iZXIuXCJcbiAgICB9LFxuICAgIFwiY29zXCI6IHtcbiAgICAgIFwiIXR5cGVcIjogXCJmbihudW1iZXIpIC0+IG51bWJlclwiLFxuICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2Nvc1wiLFxuICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgY29zaW5lIG9mIGEgbnVtYmVyLlwiXG4gICAgfSxcbiAgICBcInNpblwiOiB7XG4gICAgICBcIiF0eXBlXCI6IFwiZm4obnVtYmVyKSAtPiBudW1iZXJcIixcbiAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9zaW5cIixcbiAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIHNpbmUgb2YgYSBudW1iZXIuXCJcbiAgICB9LFxuICAgIFwidGFuXCI6IHtcbiAgICAgIFwiIXR5cGVcIjogXCJmbihudW1iZXIpIC0+IG51bWJlclwiLFxuICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3RhblwiLFxuICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgdGFuZ2VudCBvZiBhIG51bWJlci5cIlxuICAgIH0sXG4gICAgXCJhY29zXCI6IHtcbiAgICAgIFwiIXR5cGVcIjogXCJmbihudW1iZXIpIC0+IG51bWJlclwiLFxuICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2Fjb3NcIixcbiAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIGFyY2Nvc2luZSAoaW4gcmFkaWFucykgb2YgYSBudW1iZXIuXCJcbiAgICB9LFxuICAgIFwiYXNpblwiOiB7XG4gICAgICBcIiF0eXBlXCI6IFwiZm4obnVtYmVyKSAtPiBudW1iZXJcIixcbiAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9hc2luXCIsXG4gICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIHRoZSBhcmNzaW5lIChpbiByYWRpYW5zKSBvZiBhIG51bWJlci5cIlxuICAgIH0sXG4gICAgXCJhdGFuXCI6IHtcbiAgICAgIFwiIXR5cGVcIjogXCJmbihudW1iZXIpIC0+IG51bWJlclwiLFxuICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2F0YW5cIixcbiAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIGFyY3RhbmdlbnQgKGluIHJhZGlhbnMpIG9mIGEgbnVtYmVyLlwiXG4gICAgfSxcbiAgICBcImF0YW4yXCI6IHtcbiAgICAgIFwiIXR5cGVcIjogXCJmbihudW1iZXIsIG51bWJlcikgLT4gbnVtYmVyXCIsXG4gICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvYXRhbjJcIixcbiAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIGFyY3RhbmdlbnQgb2YgdGhlIHF1b3RpZW50IG9mIGl0cyBhcmd1bWVudHMuXCJcbiAgICB9LFxuICAgIFwiY2VpbFwiOiB7XG4gICAgICBcIiF0eXBlXCI6IFwiZm4obnVtYmVyKSAtPiBudW1iZXJcIixcbiAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9jZWlsXCIsXG4gICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIHRoZSBzbWFsbGVzdCBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBhIG51bWJlci5cIlxuICAgIH0sXG4gICAgXCJmbG9vclwiOiB7XG4gICAgICBcIiF0eXBlXCI6IFwiZm4obnVtYmVyKSAtPiBudW1iZXJcIixcbiAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9mbG9vclwiLFxuICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgbGFyZ2VzdCBpbnRlZ2VyIGxlc3MgdGhhbiBvciBlcXVhbCB0byBhIG51bWJlci5cIlxuICAgIH0sXG4gICAgXCJyb3VuZFwiOiB7XG4gICAgICBcIiF0eXBlXCI6IFwiZm4obnVtYmVyKSAtPiBudW1iZXJcIixcbiAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9yb3VuZFwiLFxuICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgdmFsdWUgb2YgYSBudW1iZXIgcm91bmRlZCB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyLlwiXG4gICAgfSxcbiAgICBcImV4cFwiOiB7XG4gICAgICBcIiF0eXBlXCI6IFwiZm4obnVtYmVyKSAtPiBudW1iZXJcIixcbiAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9leHBcIixcbiAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgRXgsIHdoZXJlIHggaXMgdGhlIGFyZ3VtZW50LCBhbmQgRSBpcyBFdWxlcidzIGNvbnN0YW50LCB0aGUgYmFzZSBvZiB0aGUgbmF0dXJhbCBsb2dhcml0aG1zLlwiXG4gICAgfSxcbiAgICBcImxvZ1wiOiB7XG4gICAgICBcIiF0eXBlXCI6IFwiZm4obnVtYmVyKSAtPiBudW1iZXJcIixcbiAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9sb2dcIixcbiAgICAgIFwiIWRvY1wiOiBcIlJldHVybnMgdGhlIG5hdHVyYWwgbG9nYXJpdGhtIChiYXNlIEUpIG9mIGEgbnVtYmVyLlwiXG4gICAgfSxcbiAgICBcInNxcnRcIjoge1xuICAgICAgXCIhdHlwZVwiOiBcImZuKG51bWJlcikgLT4gbnVtYmVyXCIsXG4gICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvc3FydFwiLFxuICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgc3F1YXJlIHJvb3Qgb2YgYSBudW1iZXIuXCJcbiAgICB9LFxuICAgIFwicG93XCI6IHtcbiAgICAgIFwiIXR5cGVcIjogXCJmbihudW1iZXIsIG51bWJlcikgLT4gbnVtYmVyXCIsXG4gICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvcG93XCIsXG4gICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIGJhc2UgdG8gdGhlIGV4cG9uZW50IHBvd2VyLCB0aGF0IGlzLCBiYXNlZXhwb25lbnQuXCJcbiAgICB9LFxuICAgIFwibWF4XCI6IHtcbiAgICAgIFwiIXR5cGVcIjogXCJmbihudW1iZXIsIG51bWJlcikgLT4gbnVtYmVyXCIsXG4gICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvbWF4XCIsXG4gICAgICBcIiFkb2NcIjogXCJSZXR1cm5zIHRoZSBsYXJnZXN0IG9mIHplcm8gb3IgbW9yZSBudW1iZXJzLlwiXG4gICAgfSxcbiAgICBcIm1pblwiOiB7XG4gICAgICBcIiF0eXBlXCI6IFwiZm4obnVtYmVyLCBudW1iZXIpIC0+IG51bWJlclwiLFxuICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL21pblwiLFxuICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyB0aGUgc21hbGxlc3Qgb2YgemVybyBvciBtb3JlIG51bWJlcnMuXCJcbiAgICB9LFxuICAgIFwicmFuZG9tXCI6IHtcbiAgICAgIFwiIXR5cGVcIjogXCJmbigpIC0+IG51bWJlclwiLFxuICAgICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3JhbmRvbVwiLFxuICAgICAgXCIhZG9jXCI6IFwiUmV0dXJucyBhIGZsb2F0aW5nLXBvaW50LCBwc2V1ZG8tcmFuZG9tIG51bWJlciBpbiB0aGUgcmFuZ2UgWzAsIDEpIHRoYXQgaXMsIGZyb20gMCAoaW5jbHVzaXZlKSB1cCB0byBidXQgbm90IGluY2x1ZGluZyAxIChleGNsdXNpdmUpLCB3aGljaCB5b3UgY2FuIHRoZW4gc2NhbGUgdG8geW91ciBkZXNpcmVkIHJhbmdlLlwiXG4gICAgfSxcbiAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGhcIixcbiAgICBcIiFkb2NcIjogXCJBIGJ1aWx0LWluIG9iamVjdCB0aGF0IGhhcyBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGZvciBtYXRoZW1hdGljYWwgY29uc3RhbnRzIGFuZCBmdW5jdGlvbnMuXCJcbiAgfSxcbiAgXCJKU09OXCI6IHtcbiAgICBcInBhcnNlXCI6IHtcbiAgICAgIFwiIXR5cGVcIjogXCJmbihqc29uOiBzdHJpbmcpIC0+ID9cIixcbiAgICAgIFwiIXVybFwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvSlNPTi9wYXJzZVwiLFxuICAgICAgXCIhZG9jXCI6IFwiUGFyc2UgYSBzdHJpbmcgYXMgSlNPTiwgb3B0aW9uYWxseSB0cmFuc2Zvcm1pbmcgdGhlIHZhbHVlIHByb2R1Y2VkIGJ5IHBhcnNpbmcuXCJcbiAgICB9LFxuICAgIFwic3RyaW5naWZ5XCI6IHtcbiAgICAgIFwiIXR5cGVcIjogXCJmbih2YWx1ZTogPykgLT4gc3RyaW5nXCIsXG4gICAgICBcIiF1cmxcIjogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0pTT04vc3RyaW5naWZ5XCIsXG4gICAgICBcIiFkb2NcIjogXCJDb252ZXJ0IGEgdmFsdWUgdG8gSlNPTiwgb3B0aW9uYWxseSByZXBsYWNpbmcgdmFsdWVzIGlmIGEgcmVwbGFjZXIgZnVuY3Rpb24gaXMgc3BlY2lmaWVkLCBvciBvcHRpb25hbGx5IGluY2x1ZGluZyBvbmx5IHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcyBpZiBhIHJlcGxhY2VyIGFycmF5IGlzIHNwZWNpZmllZC5cIlxuICAgIH0sXG4gICAgXCIhdXJsXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KU09OXCIsXG4gICAgXCIhZG9jXCI6IFwiSlNPTiAoSmF2YVNjcmlwdCBPYmplY3QgTm90YXRpb24pIGlzIGEgZGF0YS1pbnRlcmNoYW5nZSBmb3JtYXQuICBJdCBjbG9zZWx5IHJlc2VtYmxlcyBhIHN1YnNldCBvZiBKYXZhU2NyaXB0IHN5bnRheCwgYWx0aG91Z2ggaXQgaXMgbm90IGEgc3RyaWN0IHN1YnNldC4gKFNlZSBKU09OIGluIHRoZSBKYXZhU2NyaXB0IFJlZmVyZW5jZSBmb3IgZnVsbCBkZXRhaWxzLikgIEl0IGlzIHVzZWZ1bCB3aGVuIHdyaXRpbmcgYW55IGtpbmQgb2YgSmF2YVNjcmlwdC1iYXNlZCBhcHBsaWNhdGlvbiwgaW5jbHVkaW5nIHdlYnNpdGVzIGFuZCBicm93c2VyIGV4dGVuc2lvbnMuICBGb3IgZXhhbXBsZSwgeW91IG1pZ2h0IHN0b3JlIHVzZXIgaW5mb3JtYXRpb24gaW4gSlNPTiBmb3JtYXQgaW4gYSBjb29raWUsIG9yIHlvdSBtaWdodCBzdG9yZSBleHRlbnNpb24gcHJlZmVyZW5jZXMgaW4gSlNPTiBpbiBhIHN0cmluZy12YWx1ZWQgYnJvd3NlciBwcmVmZXJlbmNlLlwiXG4gIH1cbn1cbiIsInZhciBfICAgICAgICAgID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIG1pZGRsZXdhcmUgPSByZXF1aXJlKCcuLi8uLi9zdGF0ZS9taWRkbGV3YXJlJyk7XG52YXIgaXNJblNjb3BlICA9IHJlcXVpcmUoJy4uL2NvZGVtaXJyb3IvaXMtaW4tc2NvcGUnKTtcbnZhciBmcm9tUGF0aCAgID0gcmVxdWlyZSgnLi4vZnJvbS1wYXRoJyk7XG5cbi8qKlxuICogU3BsaXQgYXJndW1lbnRzIGludG8gYW4gYXJyYXkgb2Yga2V5IHRvIGRlZmluaXRpb24uXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG52YXIgc2FuaXRpemVGdW5jdGlvblR5cGUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHZhciBmblBhcnRzID0gc3RyaW5nLnNwbGl0KCcgLT4gJyk7XG4gIHZhciByZXN1bHQgID0gZm5QYXJ0cy5sZW5ndGggPiAxID8gZm5QYXJ0cy5wb3AoKSA6IG51bGw7XG4gIHZhciBmblR5cGUgID0gZm5QYXJ0cy5qb2luKCcgLT4gJyk7XG4gIHZhciBhcmdzICAgID0gW107XG5cbiAgLy8gTWFwIHRoZSBhcmd1bWVudHMgdG8gYSBzYW5pdGl6ZWQgc3RyaW5nLlxuICB2YXIgdHlwZSA9IGZuVHlwZS5yZXBsYWNlKC9eZm5cXCgoLiopXFwpLywgZnVuY3Rpb24gKG1hdGNoLCBwYXJhbXMpIHtcbiAgICB2YXIgbGV2ZWwgICAgPSAwO1xuICAgIHZhciBhcmdNYXAgICA9IFtdO1xuICAgIHZhciBjdXJQYXJhbSA9ICcnO1xuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIGV2ZXJ5IGNoYXJhY3RlciBjYXRlZ29yaXppbmcgaW50byBhcmd1bWVudHMuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGFyID0gcGFyYW1zW2ldO1xuXG4gICAgICBpZiAoY2hhciA9PT0gJywnICYmIGxldmVsID09PSAwKSB7XG4gICAgICAgIGFyZ01hcC5wdXNoKGN1clBhcmFtLnRyaW0oKSk7XG4gICAgICAgIGN1clBhcmFtID0gJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJQYXJhbSArPSBjaGFyO1xuXG4gICAgICAgIGlmIChjaGFyID09PSAneycgfHwgY2hhciA9PT0gJygnKSB7XG4gICAgICAgICAgbGV2ZWwrKztcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAnfScgfHwgY2hhciA9PT0gJyknKSB7XG4gICAgICAgICAgbGV2ZWwtLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGFyZ01hcC5wdXNoKGN1clBhcmFtKTtcblxuICAgIC8vIFJldHVybiBvbmx5IHRoZSBhcmd1bWVudCBuYW1lcyBhbmQgcHVzaCB0aGUgZGVmaW5pdGlvbnMgaW50byBhbiBhcnJheS5cbiAgICByZXR1cm4gJ2ZuKCcgKyBfLm1hcChhcmdNYXAsIGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgIHZhciBzcGxpdCA9IGFyZy5zcGxpdCgnOicpO1xuICAgICAgdmFyIG5hbWUgID0gc3BsaXQuc2hpZnQoKS50cmltKCk7XG5cbiAgICAgIGlmIChzcGxpdC5sZW5ndGgpIHtcbiAgICAgICAgYXJncy5wdXNoKHNhbml0aXplRGVmaW5pdGlvbih7XG4gICAgICAgICAgJyF0eXBlJzogc3BsaXQuam9pbignOicpLnRyaW0oKVxuICAgICAgICB9KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcmdzLnB1c2gobnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH0pLmpvaW4oJywgJykgKyAnKSc7XG4gIH0pO1xuXG4gIC8vIFJldHVybiBhbiBvYmplY3QgdG8gYmUgbWl4ZWQgaW4gd2l0aCB0aGUgb3JpZ2luYWwgZGVzY3JpcHRpb24uXG4gIHJldHVybiB7XG4gICAgJyF0eXBlJzogICB0eXBlLFxuICAgICchYXJncyc6ICAgYXJncyxcbiAgICAnIXJldHVybic6IHJlc3VsdFxuICB9O1xufTtcblxuLyoqXG4gKiBTYW5pdGl6ZSBhIGRlZmluaXRpb24gb2JqZWN0IGludG8gb3VyIHJlZ3VsYXIgZm9ybWF0LlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gZGVmaW5pdGlvblxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbi8qIGpzaGludCAtVzAwMyAqL1xudmFyIHNhbml0aXplRGVmaW5pdGlvbiA9IGZ1bmN0aW9uIChkZXNjcmlwdGlvbikge1xuICBfLmVhY2goZGVzY3JpcHRpb24sIGZ1bmN0aW9uIChkZXNjcmliZSwga2V5KSB7XG4gICAgLy8gU2tpcCBvdmVyIGRlZmluaXRpb24ga2V5cy5cbiAgICBpZiAoIV8uaXNPYmplY3QoZGVzY3JpYmUpIHx8IGtleS5jaGFyQXQoMCkgPT09ICchJykgeyByZXR1cm47IH1cblxuICAgIC8vIFNhbml0aXplIGEgZnVuY3Rpb24gaW50byBpdHMgaW5kaXZpZHVhbCBwYXJ0cy5cbiAgICBpZiAoL15mblxcKC8udGVzdChkZXNjcmliZVsnIXR5cGUnXSkpIHtcbiAgICAgIF8uZXh0ZW5kKGRlc2NyaWJlLCBzYW5pdGl6ZUZ1bmN0aW9uVHlwZShkZXNjcmliZVsnIXR5cGUnXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBzYW5pdGl6ZURlZmluaXRpb24oZGVzY3JpYmUpO1xuICB9KTtcblxuICByZXR1cm4gZGVzY3JpcHRpb247XG59O1xuLyoganNoaW50ICtXMDAzICovXG5cbi8qKlxuICogSmF2YVNjcmlwdCBkZXNjcmlwdGlvbiBkb2N1bWVudHMgZnJvbSBUZXJuLmpzLlxuICpcbiAqIEB0eXBlIHtBcnJheX1cbiAqL1xudmFyIERFU0NSSVBUSU9OUyA9IF8ubWFwKFtcbiAgcmVxdWlyZSgnLi9lY21hNS5qc29uJyksXG4gIHJlcXVpcmUoJy4vYnJvd3Nlci5qc29uJylcbl0sIHNhbml0aXplRGVmaW5pdGlvbik7XG5cbi8qKlxuICogUmVjdXJzZSB0aHJvdWdoIHRoZSBkZXNjcmlwdGlvbiBzdHJ1Y3R1cmUgYW5kIGF0dGFjaCBkZXNjcmlwdGlvbnMgdG8gbm9kZXNcbiAqIHVzaW5nIGEgYE1hcGAgaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSAge01hcH0gICAgbWFwXG4gKiBAcGFyYW0gIHtPYmplY3R9IGRlc2NyaWJlXG4gKiBAcGFyYW0gIHtPYmplY3R9IGdsb2JhbFxuICogQHJldHVybiB7TWFwfVxuICovXG52YXIgYXR0YWNoRGVzY3JpcHRpb25zID0gZnVuY3Rpb24gKG1hcCwgZGVzY3JpYmUsIGdsb2JhbCkge1xuICAoZnVuY3Rpb24gcmVjdXJzZSAoZGVmaW5pdGlvbiwgY29udGV4dCkge1xuICAgIC8vIEJyZWFrIHJlY3Vyc2lvbiBvbiBhIG5vbi1vYmplY3QuXG4gICAgaWYgKCFfLmlzT2JqZWN0KGNvbnRleHQpIHx8ICFfLmlzT2JqZWN0KGRlZmluaXRpb24pKSB7IHJldHVybjsgfVxuXG4gICAgLy8gU2V0IHRoZSBtYXAgb2JqZWN0IHJlZmVyZW5jZSB0byBwb2ludCB0byB0aGUgZGVzY3JpcHRpb24uXG4gICAgbWFwLnNldChjb250ZXh0LCBkZWZpbml0aW9uKTtcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUgZGVmaW5pdGlvbiBvYmplY3QgYW5kIGF0dGFjaCBtb3JlIGRlZmluaXRpb25zLlxuICAgIF8uZWFjaChkZWZpbml0aW9uLCBmdW5jdGlvbiAoZGVzY3JpYmUsIGtleSkge1xuICAgICAgLy8gRGVmaW5pdGlvbnMgYXJlIHByZXBlbmRlZCB3aXRoIGFuIGV4Y2xhbWF0aW9uIG1hcmsuXG4gICAgICBpZiAoa2V5LmNoYXJBdCgwKSA9PT0gJyEnKSB7IHJldHVybjsgfVxuXG4gICAgICAvLyBXZSBuZWVkIHRvIHVzZSBwcm9wZXJ0eSBkZXNjcmlwdG9ycyBoZXJlIHNpbmNlIEZpcmVmb3ggdGhyb3dzIGVycm9yc1xuICAgICAgLy8gd2l0aCBnZXR0ZXJzIG9uIHNvbWUgcHJvdG90eXBlIHByb3BlcnRpZXMuXG4gICAgICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29udGV4dCwga2V5KTtcblxuICAgICAgcmV0dXJuIGRlc2NyaXB0b3IgJiYgcmVjdXJzZShkZXNjcmliZSwgZGVzY3JpcHRvci52YWx1ZSk7XG4gICAgfSk7XG4gIH0pKGRlc2NyaWJlLCBnbG9iYWwpO1xuXG4gIHJldHVybiBtYXA7XG59O1xuXG4vKipcbiAqIEFjY2VwdHMgYSB3aW5kb3cgb2JqZWN0IGFuZCByZXR1cm5zIGFuIG9iamVjdCBmb3IgdXNlIHdpdGggbWlkZGxld2FyZS5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHNhbmRib3hcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZ2xvYmFsKSB7XG4gIHZhciBtYXAgICAgID0gbmV3IE1hcCgpO1xuICB2YXIgcGx1Z2lucyA9IHt9O1xuXG4gIC8vIEl0ZXJhdGUgb3ZlciB0aGUgZGVzY3JpcHRpb24gZG9jdW1lbnRzIGFuZCBhdHRhY2guXG4gIF8uZWFjaChERVNDUklQVElPTlMsIGZ1bmN0aW9uIChkZXNjcmlwdGlvbikge1xuICAgIGF0dGFjaERlc2NyaXB0aW9ucyhtYXAsIGRlc2NyaXB0aW9uLCBnbG9iYWwpO1xuICB9KTtcblxuICAvKipcbiAgICogTWlkZGxld2FyZSBwbHVnaW4gZm9yIGRlc2NyaWJpbmcgbmF0aXZlIHR5cGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gICBkYXRhXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgcGx1Z2luc1snY29tcGxldGlvbjpkZXNjcmliZSddID0gZnVuY3Rpb24gKGRhdGEsIG5leHQsIGRvbmUpIHtcbiAgICB2YXIgdG9rZW4gICA9IGRhdGEudG9rZW47XG4gICAgdmFyIGNvbnRleHQgPSBkYXRhLmNvbnRleHQ7XG4gICAgdmFyIGRlc2NyaXB0aW9uO1xuXG4gICAgLy8gQXZvaWRpbmcgZGVzY3JpYmluZyBmdW5jdGlvbiBhcmd1bWVudHMgYW5kIHZhcmlhYmxlcy5cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ3ZhcmlhYmxlJyAmJiBpc0luU2NvcGUodG9rZW4sIHRva2VuLnN0cmluZykpIHtcbiAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRleHQgPT0gbnVsbCAmJiBkYXRhLnBhcmVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29udGV4dCA9IGRhdGEucGFyZW50W3Rva2VuLnN0cmluZ107XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cblxuICAgIGlmIChfLmlzT2JqZWN0KGNvbnRleHQpKSB7XG4gICAgICBkZXNjcmlwdGlvbiA9IG1hcC5nZXQoY29udGV4dCk7XG4gICAgfVxuXG4gICAgaWYgKCFkZXNjcmlwdGlvbikge1xuICAgICAgaWYgKCFkYXRhLnBhcmVudCkge1xuICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2JqID0gZGF0YS5wYXJlbnQ7XG4gICAgICB2YXIgdHlwZTtcblxuICAgICAgd2hpbGUgKG9iaikge1xuICAgICAgICB2YXIgb2JqRGVzYyA9IG1hcC5nZXQob2JqKTtcblxuICAgICAgICBpZiAob2JqRGVzYykge1xuICAgICAgICAgIGlmICgodHlwZSA9IG9iakRlc2NbJyF0eXBlJ10pICYmIHR5cGUuY2hhckF0KDApID09PSAnKycpIHtcbiAgICAgICAgICAgIG9iaiA9IGZyb21QYXRoKGRhdGEud2luZG93LCB0eXBlLnN1YnN0cigxKS5zcGxpdCgnLicpKS5wcm90b3R5cGU7XG4gICAgICAgICAgICBvYmpEZXNjID0gbWFwLmdldChvYmopO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvYmpEZXNjW3Rva2VuLnN0cmluZ10pIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uID0gb2JqRGVzY1t0b2tlbi5zdHJpbmddO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0gZGF0YS53aW5kb3cuT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgZGlkbid0IHJldHJpZXZlIGEgZGVzY3JpcHRpb24sIGFsbG93IHRoZSBuZXh0IGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICBpZiAoZGVzY3JpcHRpb24gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZG9uZShudWxsLCBkZXNjcmlwdGlvbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1pZGRsZXdhcmUgZm9yIGxvb2tpbmcgdXAgZnVuY3Rpb24gcmV0dXJuIHR5cGVzIGZvciBuYXRpdmUgZnVuY3Rpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gICBkYXRhXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgcGx1Z2luc1snY29tcGxldGlvbjpmdW5jdGlvbiddID0gZnVuY3Rpb24gKGRhdGEsIG5leHQsIGRvbmUpIHtcbiAgICB2YXIgY29uc3RydWN0b3JzID0gW1xuICAgICAgZGF0YS53aW5kb3cuQXJyYXksXG4gICAgICBkYXRhLndpbmRvdy5TdHJpbmcsXG4gICAgICBkYXRhLndpbmRvdy5Cb29sZWFuXG4gICAgXTtcblxuICAgIC8vIENvbnN0cnVjdG9yIGZ1bmN0aW9ucyBhcmUgcmVsYXRpdmVseSBlYXN5IHRvIGhhbmRsZS5cbiAgICBpZiAoZGF0YS5pc0NvbnN0cnVjdG9yIHx8IF8uY29udGFpbnMoY29uc3RydWN0b3JzLCBkYXRhLmNvbnRleHQpKSB7XG4gICAgICByZXR1cm4gZG9uZShudWxsLCBkYXRhLmNvbnRleHQucHJvdG90eXBlKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIG1heSBiZSBhIGxpdHRsZSBkb2RneSwgYnV0IGFzIGxvbmcgYXMgc29tZW9uZSBoYXNuJ3QgZXh0ZW5kZWQgdGhlXG4gICAgLy8gbmF0aXZlIHByb3RvdHlwZSBvYmplY3Qgd2l0aCBzb21ldGhpbmcgdGhhdCBoYXMgc2lkZS1lZmZlY3RzLCB3ZSdsbCBiZVxuICAgIC8vIGZpbmUuXG4gICAgaWYgKCFfLmlzT2JqZWN0KGRhdGEucGFyZW50KSkge1xuICAgICAgcmV0dXJuIGRvbmUobnVsbCwgZGF0YS5jb250ZXh0LmNhbGwoZGF0YS5wYXJlbnQpKTtcbiAgICB9XG5cbiAgICAvLyBVc2UgdGhlIGRvY3VtZW50YXRpb24gdG8gZGV0ZWN0IHRoZSByZXR1cm4gdHlwZXMuXG4gICAgbWlkZGxld2FyZS50cmlnZ2VyKCdjb21wbGV0aW9uOmRlc2NyaWJlJywgZGF0YSwgZnVuY3Rpb24gKGVyciwgZGVzY3JpYmUpIHtcbiAgICAgIHZhciByZXR1cm5UeXBlID0gZGVzY3JpYmUgJiYgZGVzY3JpYmVbJyFyZXR1cm4nXTtcblxuICAgICAgLy8gQ2hlY2sgZm9yIGFuIGVycm9yIGFuZCBlbnN1cmUgd2UgaGF2ZSBhIHJldHVybiBkZXNjcmlwdGlvbi5cbiAgICAgIGlmIChlcnIgfHwgIS9eZm5cXCgvLnRlc3QoZGVzY3JpYmVbJyF0eXBlJ10pIHx8ICFyZXR1cm5UeXBlKSB7XG4gICAgICAgIHJldHVybiBuZXh0KGVycik7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXR1cm5UeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZG9uZShudWxsLCBkYXRhLndpbmRvdy5TdHJpbmcoKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXR1cm5UeXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gZG9uZShudWxsLCBkYXRhLndpbmRvdy5OdW1iZXIoKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXR1cm5UeXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgcmV0dXJuIGRvbmUobnVsbCwgZGF0YS53aW5kb3cuQm9vbGVhbigpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKC9cXFsuKlxcXS8udGVzdChyZXR1cm5UeXBlKSkge1xuICAgICAgICByZXR1cm4gZG9uZShudWxsLCBkYXRhLndpbmRvdy5BcnJheSgpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJldHVyblR5cGUgPT09ICdmbigpJykge1xuICAgICAgICByZXR1cm4gZG9uZShudWxsLCBkYXRhLndpbmRvdy5GdW5jdGlvbigpKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJucyBpdHMgb3duIGluc3RhbmNlLlxuICAgICAgaWYgKHJldHVyblR5cGUgPT09ICchdGhpcycpIHtcbiAgICAgICAgcmV0dXJuIGRvbmUobnVsbCwgZGF0YS5wYXJlbnQpO1xuICAgICAgfVxuXG4gICAgICAvLyBJbnN0YW5jZSB0eXBlIHJldHVybi5cbiAgICAgIGlmIChfLmlzU3RyaW5nKHJldHVyblR5cGUpICYmIHJldHVyblR5cGUuY2hhckF0KDApID09PSAnKycpIHtcbiAgICAgICAgdmFyIHBhdGggICAgICAgID0gcmV0dXJuVHlwZS5zdWJzdHIoMSkuc3BsaXQoJy4nKTtcbiAgICAgICAgdmFyIGNvbnN0cnVjdG9yID0gZnJvbVBhdGgoZGF0YS53aW5kb3csIHBhdGgpO1xuXG4gICAgICAgIGlmIChfLmlzRnVuY3Rpb24oY29uc3RydWN0b3IpKSB7XG4gICAgICAgICAgcmV0dXJuIGRvbmUobnVsbCwgY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV4dCgpO1xuICAgIH0sIHRydWUpO1xuICB9O1xuXG4gIHJldHVybiBwbHVnaW5zO1xufTtcbiIsInZhciBtaWRkbGV3YXJlID0gcmVxdWlyZSgnLi4vc3RhdGUvbWlkZGxld2FyZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzYW5kYm94IGluc3RhbmNlIGZvciBleGVjdXRpbmcgYXJiaXRyYXJ5IGNvZGUuXG4gKlxuICogQHJldHVybiB7U2FuZGJveH1cbiAqL1xudmFyIFNhbmRib3ggPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5mcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICB0aGlzLmZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5mcmFtZSk7XG4gIHRoaXMud2luZG93ID0gdGhpcy5mcmFtZS5jb250ZW50V2luZG93O1xufTtcblxuLyoqXG4gKiBFeGVjdXRlIGNvZGUgaW4gdGhlIHNhbmRib3ggZW52aXJvbm1lbnQuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSAgIGNvZGVcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBkb25lXG4gKi9cblNhbmRib3gucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoY29kZSwgZG9uZSkge1xuICB2YXIgZ2xvYmFsID0gdGhpcy53aW5kb3c7XG5cbiAgbWlkZGxld2FyZS50cmlnZ2VyKCdzYW5kYm94OmNvbnRleHQnLCB7fSwgZnVuY3Rpb24gKGVyciwgY29udGV4dCkge1xuICAgIC8vIEFsbG93IG1pZGRsZXdhcmUgdG8gcnVuIHRoZSBleGVjdXRpb24gZXZlbnQuIFRoaXMgaXMgdGhlIHBlcmZlY3QgaGFuZGxlclxuICAgIC8vIGZvciBhc3luYyBleGVjdXRpb24gY2VsbHMgYW5kIGV2ZW4gYWxsb3dzIHBlb3BsZSB0byBob29rIGludG8gdGhlIGNvZGVcbiAgICAvLyBiZWZvcmUgaXQgcnVucy4gVGhpbmsgbGludGVycywgZXRjLlxuICAgIG1pZGRsZXdhcmUudHJpZ2dlcignc2FuZGJveDpleGVjdXRlJywge1xuICAgICAgY29kZTogICAgY29kZSxcbiAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICB3aW5kb3c6ICBnbG9iYWxcbiAgICB9LCBkb25lKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgc2FuZGJveCBpbnN0YW5jZSBmcm9tIHRoZSBkb2N1bWVudC5cbiAqXG4gKiBAcmV0dXJuIHtTYW5kYm94fVxuICovXG5TYW5kYm94LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmZyYW1lKTtcbiAgZGVsZXRlIHRoaXMuZnJhbWU7XG4gIGRlbGV0ZSB0aGlzLndpbmRvdztcblxuICByZXR1cm4gdGhpcztcbn07XG4iLCJ2YXIgXyAgICAgICA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciB0eXBlT2YgID0gcmVxdWlyZSgnLi90eXBlJyk7XG52YXIgX19zbGljZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogR2V0IGEgZnVuY3Rpb25zIG5hbWUuXG4gKlxuICogQHBhcmFtICB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbnZhciBnZXRGdW5jdGlvbk5hbWUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIGZuLm5hbWU7XG59O1xuXG5pZiAoISgnbmFtZScgaW4gRnVuY3Rpb24ucHJvdG90eXBlKSkge1xuICBnZXRGdW5jdGlvbk5hbWUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICB2YXIgZm5TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChmbik7XG5cbiAgICAvLyBSdW4gYSBzaW1wbGUgcmVndWxhciBleHByZXNzaW9uIHRvIGdldCB0aGUgZnVuY3Rpb24gbmFtZSBhbmQgcmV0dXJuLlxuICAgIHJldHVybiAoL2Z1bmN0aW9uXFxzKyguezEsfSlcXHMqXFwoLykuZXhlYyhmblN0cmluZylbMV07XG4gIH07XG59XG5cbi8qKlxuICogR2V0cyBpbnRlcm5hbCBvYmplY3QgbmFtZS4gV29ya3MgbGlrZSB0aGUgQ2hyb21lIGNvbnNvbGUgYW5kIGdyYWJzIHRoZVxuICogY29udHJ1Y3RvciBuYW1lIHRvIHJlbmRlciB3aXRoIHRoZSBwcmV2aWV3LlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbnZhciBnZXRJbnRlcm5hbE5hbWUgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gIHZhciBuYW1lID0gJ09iamVjdCc7XG5cbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnICsgb2JqZWN0O1xuICB9XG5cbiAgZG8ge1xuICAgIC8vIEJ5IGRlZmF1bHQsIGdldCB0aGUgb2JqZWN0IHR5cGUgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLiBUaGlzXG4gICAgLy8gaXMgdGhlIG1vc3QgY29uc2lzdGVudCBtZXRob2QgZm9yIGJ1aWx0LWluIHR5cGVzIHJldHVybmluZyB0aGluZ3MgbGlrZVxuICAgIC8vIGBKU09OYCwgYGdsb2JhbGAsIGBIVE1MRG9jdW1lbnRgLCBldGMuXG4gICAgbmFtZSA9IF9fc2xpY2UuY2FsbChvYmplY3QpLnNsaWNlKDgsIC0xKTtcblxuICAgIC8vIElmIHRoZSBuYXRpdmUgb2JqZWN0IHR5cGUgaXMgc2ltcGx5IGBPYmplY3RgLCB0cnkgYSBtb3JlIGFkdmFuY2VkXG4gICAgLy8gd2F5IG9mIGdldHRpbmcgdGhlIHR5cGUgZnJvbSB0aGUgY29uc3RydWN0b3IgZnVuY3Rpb24uIFRoaXMgaXMgcmVhbGx5XG4gICAgLy8gb25seSB1c2VmdWwgaW4gY2xpZW50IGRlZmluZWQgY29kZSBhbmQgY29uc3RydWN0b3JzLiBXcmFwIHRoZSB3aG9sZVxuICAgIC8vIGNoZWNrIGluIGEgYHRyeS4uY2F0Y2hgIHN0YXRlbWVudCBzaW5jZSB3ZSBkb24ndCBrbm93IHdobydzIGNvbnN0cnVjdG9yXG4gICAgLy8gd2UgYXJlIGFjY2Vzc2luZyBhbmQgaWYgaXQnbGwgdGhyb3cgYW4gZXJyb3IgKEUuZy4gYHdpbmRvdy5wYXJlbnRgKS5cbiAgICBpZiAobmFtZSA9PT0gJ09iamVjdCcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChfX3NsaWNlLmNhbGwob2JqZWN0LmNvbnN0cnVjdG9yKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJykge1xuICAgICAgICAgIG5hbWUgPSBnZXRGdW5jdGlvbk5hbWUob2JqZWN0LmNvbnN0cnVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG4gIH0gd2hpbGUgKG5hbWUgPT09ICdPYmplY3QnICYmIChvYmplY3QgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KSkpO1xuXG4gIHJldHVybiBuYW1lO1xufTtcblxuLyoqXG4gKiBTdHJpbmdpZnkgYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xudmFyIHN0cmluZ2lmeVN0cmluZyA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgcmV0dXJuICdcIicgKyBzdHJpbmcucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpICsgJ1wiJztcbn07XG5cbi8qKlxuICogU3RyaW5naWZ5IGEgY2hpbGQgb2JqZWN0LCBDaHJvbWUtc3R5bGUuIFRoaXMgc3RyaW5naWZpZXMgbm9uLXByaW1pdGl2ZXMgdG9cbiAqIHRoZWlyIGJhc2UgbmFtZSBhbmQga2VlcCBwcmltaXRpdmVzIHRoZSB2aXNpYmx5IHRoZSBzYW1lLlxuICpcbiAqIEBwYXJhbSAgeyp9ICAgICAgb2JqZWN0XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbnZhciBzdHJpbmdpZnlDaGlsZCA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgLy8gT2JqZWN0cyBhcmUgcmVuZGVycyBhcyB0aGVpciBvYmplY3QgdHlwZXMuIEhvd2V2ZXIsIHNvbWUgdHlwZXMgYXJlIGtub3duXG4gIC8vIGxpc3RzIHNvIHdlIGNhbiBhZGQgdGhlIGxlbmd0aCB0byB0aGUgcHJldmlldy5cbiAgaWYgKF8uaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHZhciBpbnRlcm5hbE5hbWUgPSBnZXRJbnRlcm5hbE5hbWUob2JqZWN0KTtcblxuICAgIC8vIENoZWNrIGlmIHRoZSBlbGVtZW50IGlzIHVzdWFsbHkgYSBsaXN0LWxpa2Ugb2JqZWN0LlxuICAgIHZhciBpc0xpc3QgPSBfLmNvbnRhaW5zKFxuICAgICAgWydBcnJheScsICdOb2RlTGlzdCcsICdIVE1MQ29sbGVjdGlvbiddLCBpbnRlcm5hbE5hbWVcbiAgICApO1xuXG4gICAgcmV0dXJuIGludGVybmFsTmFtZSArIChpc0xpc3QgPyAnWycgKyBvYmplY3QubGVuZ3RoICsgJ10nIDogJycpO1xuICB9XG5cbiAgaWYgKF8uaXNTdHJpbmcob2JqZWN0KSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlTdHJpbmcob2JqZWN0KTtcbiAgfVxuXG4gIHJldHVybiAnJyArIG9iamVjdDtcbn07XG5cbi8qKlxuICogU3RyaW5naWZ5IGFuIGFycmF5IGFzIGFuIGFycmF5IGxpdGVyYWwuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9IGFycmF5XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbnZhciBzdHJpbmdpZnlBcnJheSA9IGZ1bmN0aW9uIChhcnJheSkge1xuICByZXR1cm4gJ1snICsgXy5tYXAoYXJyYXksIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlDaGlsZCh2YWx1ZSk7XG4gIH0sIHRoaXMpLmpvaW4oJywgJykgKyAnXSc7XG59O1xuXG4vKipcbiAqIFN0cmluZ2lmeSBhbiBvYmplY3QuIE9ubHkgZG9lcyBzaGFsbG93IHN0cmluZ2lmaWNhdGlvbiBvZiBlbnVtZXJhYmxlXG4gKiBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbnZhciBzdHJpbmdpZnlPYmplY3QgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gIC8vIFVzaW5nIHRoZSBga2V5c2AgZnVuY3Rpb24gdG8gZ3JhYiBhbGwgdGhlIGtleXMgYW5kIHRoZW4gaXRlcmF0ZSwgb3RoZXJ3aXNlXG4gIC8vIHdoZW4gc3RyaW5naWZ5aW5nIHNvbWV0aGluZyBsaWtlIHRoZSB3aW5kb3csIGl0IHRyaWVzIHRvIHVzZSBudW1lcmljXG4gIC8vIGluZGV4ZXMgbGlrZSBhbiBhcnJheSBiZWNhdXNlIG9mIHRoZSBgbGVuZ3RoYCBwcm9wZXJ0eS5cbiAgdmFyIG9iamVjdFN0cmluZyA9IF8ubWFwKF8ua2V5cyhvYmplY3QpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgcmV0dXJuIHN0cmluZ2lmeVN0cmluZyhrZXkpICsgJzogJyArIHN0cmluZ2lmeUNoaWxkKHZhbHVlKTtcbiAgfSwgdGhpcykuam9pbignLCAnKTtcblxuICByZXR1cm4gZ2V0SW50ZXJuYWxOYW1lKG9iamVjdCkgKyAnIHsnICsgb2JqZWN0U3RyaW5nICsgJ30nO1xufTtcblxuLyoqXG4gKiBTdHJpbmdpZnkgYW4gZXJyb3IgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtICB7RXJyb3J9IGVycm9yXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbnZhciBzdHJpbmdpZnlFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAvLyBUSUwgRE9NRXhjZXB0aW9ucyBkb24ndCBhbGxvdyBjYWxsaW5nIGB0b1N0cmluZ2AuXG4gIHJldHVybiBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlcnJvcik7XG59O1xuXG4vKipcbiAqIFN0cmluZ2lmeSBhbiBlbGVtZW50IG5vZGUuIEhhbmRsZSBldmVyeSB0eXBlIG9mIG5vZGUsIG5vdCBqdXN0IGVsZW1lbnRzIGJ1dFxuICogYWxzbyBzdHJpbmdzIGFuZCBjb21tZW50cy5cbiAqXG4gKiBAcGFyYW0gIHtOb2RlfSAgIG5vZGVcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xudmFyIHN0cmluZ2lmeUVsZW1lbnQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAvLyBTdHJpbmdpZnkgZG9jdW1lbnQgbm9kZXMgYnkgc3RyaW5naWZ5aW5nIGFsbCBjaGlsZCBub2Rlcy5cbiAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfTk9ERSkge1xuICAgIHJldHVybiBfLm1hcChub2RlLmNoaWxkTm9kZXMsIGZ1bmN0aW9uIChjaGlsZE5vZGUpIHtcbiAgICAgIHJldHVybiBzdHJpbmdpZnlFbGVtZW50KGNoaWxkTm9kZSk7XG4gICAgfSkuam9pbignJyk7XG4gIH1cblxuICAvLyBFc2NhcGUgYXR0cmlidXRlIG5vZGUgdmFsdWVzLiBUaGUgbmFtZSB3aWxsIGFscmVhZHkgYmUgZXNjYXBlZC5cbiAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuQVRUUklCVVRFX05PREUpIHtcbiAgICByZXR1cm4gbm9kZS5uYW1lICsgJz0nICsgc3RyaW5naWZ5U3RyaW5nKG5vZGUudmFsdWUpO1xuICB9XG5cbiAgLy8gVGhlIGRvY3VtZW50IHR5cGUgbm9kZSBuZWVkcyBtYW51YWwgY29uY2F0aW5hdGlvbi5cbiAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfVFlQRV9OT0RFKSB7XG4gICAgdmFyIGRvY3R5cGUgPSBbbm9kZS5ub2RlTmFtZV07XG5cbiAgICBpZiAobm9kZS5wdWJsaWNJZCkge1xuICAgICAgZG9jdHlwZS5wdXNoKCdQVUJMSUMnLCBzdHJpbmdpZnlTdHJpbmcobm9kZS5wdWJsaWNJZCkpO1xuICAgIH1cblxuICAgIGlmIChub2RlLnN5c3RlbUlkKSB7XG4gICAgICBkb2N0eXBlLnB1c2goc3RyaW5naWZ5U3RyaW5nKG5vZGUuc3lzdGVtSWQpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gJzwhRE9DVFlQRSAnICsgZG9jdHlwZS5qb2luKCcgJykgKyAnPic7XG4gIH1cblxuICAvLyBOb3QgYWxsIGVsZW1lbnRzIGNhbiBiZSBhcHBlbmRlZCwgc28gaWYgd2UgZmFpbCByZW5kZXIgaXQgYXMgYW4gb2JqZWN0LlxuICAvLyBUT0RPOiBUcmFjayBmYWlsdXJlcyBzb21ld2hlcmUgc28gSSBjYW4gYWRkIGZ1dHVyZSBzdXBwb3J0LlxuICB0cnkge1xuICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkaXYuYXBwZW5kQ2hpbGQobm9kZS5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgIHJldHVybiBkaXYuaW5uZXJIVE1MO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeU9iamVjdChub2RlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTdHJpbmd5IGFueSBlbGVtZW50cyBwYXNzZWQgaW4gZm9yIHRoZSBpbnNwZWN0b3IgcHJldmlldy5cbiAqXG4gKiBAcGFyYW0gIHsqfSBvYmplY3RcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xudmFyIHN0cmluZ2lmeSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICB2YXIgdHlwZSA9IHR5cGVPZihvYmplY3QpO1xuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeUVycm9yKG9iamVjdCk7XG4gIH1cblxuICBpZiAodHlwZSA9PT0gJ2FycmF5Jykge1xuICAgIHJldHVybiBzdHJpbmdpZnlBcnJheShvYmplY3QpO1xuICB9XG5cbiAgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeU9iamVjdChvYmplY3QpO1xuICB9XG5cbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeVN0cmluZyhvYmplY3QpO1xuICB9XG5cbiAgaWYgKHR5cGUgPT09ICdlbGVtZW50Jykge1xuICAgIHZhciBzdHJpbmdpZmllZEVsZW1lbnQgPSBzdHJpbmdpZnlFbGVtZW50KG9iamVjdCk7XG5cbiAgICAvLyBFbnN1cmUgdGhhdCBzdHJpbmdpZmllZCBlbGVtZW50cyBhbHdheXMgaGF2ZSBhbiBvdXRwdXQuIFVzZWZ1bCBmb3IgY2FzZXNcbiAgICAvLyB3aGVyZSB3ZSBtaWdodCBiZSBhdHRlbXB0aW5nIHRvIHN0cmluZ2lmeSBhbiBlbXB0eSBmcmFnbWVudC5cbiAgICByZXR1cm4gc3RyaW5naWZpZWRFbGVtZW50LnRyaW0oKSA/IHN0cmluZ2lmaWVkRWxlbWVudCA6IG9iamVjdC5ub2RlTmFtZTtcbiAgfVxuXG4gIC8vIEV2ZXJ5IG90aGVyIHR5cGUgY2FuIHNhZmVseSBiZSB0eXBlY2FzdGVkIHRvIHRoZSBleHBlY3RlZCBvdXRwdXQuXG4gIHJldHVybiAnJyArIG9iamVjdDtcbn07XG5cbi8vIEV4cG9zZSB1c2VmdWwgaW50ZXJuYWwgaGVscGVycy5cbnN0cmluZ2lmeS5zdHJpbmdpZnlDaGlsZCAgPSBzdHJpbmdpZnlDaGlsZDtcbnN0cmluZ2lmeS5nZXRJbnRlcm5hbE5hbWUgPSBnZXRJbnRlcm5hbE5hbWU7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgc3dpdGNoIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSkge1xuICBjYXNlICdbb2JqZWN0IEZ1bmN0aW9uXSc6XG4gICAgcmV0dXJuICdmdW5jdGlvbic7XG4gIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOlxuICAgIHJldHVybiAnZGF0ZSc7XG4gIGNhc2UgJ1tvYmplY3QgUmVnRXhwXSc6XG4gICAgcmV0dXJuICdyZWdleHAnO1xuICBjYXNlICdbb2JqZWN0IEFyZ3VtZW50c10nOlxuICAgIHJldHVybiAnYXJndW1lbnRzJztcbiAgY2FzZSAnW29iamVjdCBBcnJheV0nOlxuICAgIHJldHVybiAnYXJyYXknO1xuICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgIHJldHVybiAnc3RyaW5nJztcbiAgY2FzZSAnW29iamVjdCBFcnJvcl0nOlxuICAgIHJldHVybiAnZXJyb3InO1xuICBjYXNlICdbb2JqZWN0IE51bWJlcl0nOlxuICAgIHJldHVybiAnbnVtYmVyJztcbiAgfVxuXG4gIC8vIERldGVjdCB3aGV0aGVyIGFuIG9iamVjdCBpcyBhbiBlbGVtZW50IHVzaW5nIHRoZSBgbm9kZVR5cGVgIHByb3BlcnR5LlxuICBpZiAob2JqZWN0ICYmIG9iamVjdC5ub2RlVHlwZSA9PT0gK29iamVjdC5ub2RlVHlwZSkgeyByZXR1cm4gJ2VsZW1lbnQnOyB9XG5cbiAgLy8gUmV0dXJuIGEgbnVsbCB0eXBlIGNoZWNrIG9yIGRvIHRoZSByZWd1bGFyIHR5cGVvZi5cbiAgcmV0dXJuIG9iamVjdCA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBvYmplY3Q7XG59O1xuIiwidmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcblxuLyoqXG4gKiBQbGFpbiBjZWxsIG1vZGVsIGZvciB1c2UgaW4gdGhlIG5vdGVib29rIGNvbGxlY3Rpb24uXG4gKlxuICogQHR5cGUge0Z1bmN0aW9ufVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lLk1vZGVsLmV4dGVuZCh7XG4gIGRlZmF1bHRzOiB7XG4gICAgdHlwZTogJ3RleHQnLFxuICAgIHZhbHVlOiAnJ1xuICB9XG59KTtcbiIsInZhciBfICAgICAgICA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG5cbi8qKlxuICogTW9kZWwgdXNlZCBmb3IgaG9sZGluZyBhIG5vdGVib29rcyBtZXRhIGRhdGEuXG4gKlxuICogQHR5cGUge0Z1bmN0aW9ufVxuICovXG52YXIgTWV0YSA9IG1vZHVsZS5leHBvcnRzID0gQmFja2JvbmUuTW9kZWwuZXh0ZW5kKHtcbiAgZGVmYXVsdHM6IHtcbiAgICB0aXRsZTogJ1VudGl0bGVkIE5vdGVib29rJ1xuICB9XG59KTtcblxuLyoqXG4gKiBSZXNldCBhIG1vZGVsIGJ5IHJlbW92aW5nIGFueSB1bnVzZWQgYXR0cmlidXRlcyBhbmQgdXBkYXRpbmcgZXZlcnl0aGluZyBlbHNlLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gYXR0cnNcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7TWV0YX1cbiAqL1xuTWV0YS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoYXR0cnMsIG9wdGlvbnMpIHtcbiAgdGhpcy5zZXQoXG4gICAgXy5vbWl0KHRoaXMuYXR0cmlidXRlcywgXy5rZXlzKGF0dHJzKSksXG4gICAgXy5leHRlbmQoe30sIG9wdGlvbnMsIHsgdW5zZXQ6IHRydWUgfSlcbiAgKTtcblxuICB0aGlzLnNldChhdHRycyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuIiwidmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciBNZXRhICAgICA9IHJlcXVpcmUoJy4vbWV0YScpO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5vdGVib29rIGNvbnN0cnVjdG9yIGZvciBoYW5kbGluZyB0aGUgbm90ZWJvb2sgc3RhdGUuXG4gKlxuICogQHR5cGUge1t0eXBlXX1cbiAqL1xudmFyIE5vdGVib29rID0gbW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZS5Nb2RlbC5leHRlbmQoe1xuICBkZWZhdWx0czoge1xuICAgIGlkOiAgICAgIG51bGwsXG4gICAgbWV0YTogICAgbnVsbCxcbiAgICBjZWxsczogICBbXSxcbiAgICBvd25lcklkOiBudWxsLFxuICAgIGNvbnRlbnQ6ICcnXG4gIH1cbn0pO1xuXG4vKipcbiAqIEZpeCB0aGUgbm90ZWJvb2sgc2F5aW5nIGl0J3Mgbm90IG5ldyB3aGVuIGl0IGhhcyBhbiBlbXB0eSBpZC5cbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5Ob3RlYm9vay5wcm90b3R5cGUuaXNOZXcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhdGhpcy5nZXQoJ2lkJyk7XG59O1xuXG4vKipcbiAqIFNldCBmcmVzaCBtb2RlbCBkYXRhIHdoZW4gaW5pdGlhbGl6aW5nLlxuICovXG5Ob3RlYm9vay5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChhdHRycykge1xuICB0aGlzLnNldCgnbWV0YScsIChhdHRycyAmJiBhdHRycy5tZXRhKSB8fCBuZXcgTWV0YSh7XG4gICAgdGl0bGU6ICdVbnRpdGxlZCBOb3RlYm9vaydcbiAgfSkpO1xuXG4gIHRoaXMuc2V0KCdjZWxscycsIChhdHRycyAmJiBhdHRycy5jZWxscykgfHwgW10pO1xufTtcbiIsInZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG5cbi8qKlxuICogSnVzdCBhIHBsYWNlaG9sZGVyIGZvciB0aGUgbGlzdCBvZiBub3RlYm9va3MgdGhhdCB0aGUgcGVyc2lzdGVuY2UgcGx1Z2luXG4gKiBtYWludGFpbnMuIFR3byBmaWVsZHMuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmUuTW9kZWwuZXh0ZW5kKHtcbiAgZGVmYXVsdHM6IHtcbiAgICBpZDogICAgICAgIG51bGwsXG4gICAgdXBkYXRlZEF0OiBudWxsXG4gIH1cbn0pO1xuIiwidmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciBib3VuY2UgICA9IHJlcXVpcmUoJy4uL2xpYi9ib3VuY2UnKTtcblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIGlzIGEgc3RhdGljIGJhY2tib25lIG1vZGVsIHRoYXQgd2UgbGlzdGVuIHRvIGZvciBjaGFuZ2VzIGluXG4gKiBhcHBsaWNhdGlvbiBzZXR1cC5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgY29uZmlnID0gbW9kdWxlLmV4cG9ydHMgPSBuZXcgQmFja2JvbmUuTW9kZWwoe1xuICAvLyBUaGUgdXJsIGlzIHRoZSBlbWJlZGRpbmcgZnJhbWUgdXJsLlxuICAvLyBUaGUgYHVybGAgaXMgdGhlIHBhcmVudCB3aW5kb3cgdXJsLCBgZnVsbFVybGAgaXMgdGhlIHVybCB0byB0aGUgZnVsbC1zaXplXG4gIC8vIGFwcGxpY2F0aW9uIChFLmcuIEFueXBvaW50IFBsYXRmb3JtKSwgYHNpdGVVcmxgIGlzIHRoZSBzdGF0aWMgc3BvbnNvcmluZ1xuICAvLyBzaXRlIGFuZCBgc2l0ZVRpdGxlYCBpcyBhIGNvbmZpZ3VyYWJsZSBuYW1lIGZvciB0aGUgc2l0ZSBob3N0LlxuICB1cmw6ICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmLFxuICBmdWxsVXJsOiAgIHtcInVybFwiOlwiaHR0cHM6Ly9tdWxlc29mdC5naXRodWIuaW8vYXBpLW5vdGVib29rL1wiLFwidGl0bGVcIjpcIkFQSSBOb3RlYm9va1wiLFwib2F1dGhDYWxsYmFja1wiOlwiL2F1dGhlbnRpY2F0ZS9vYXV0aC5odG1sXCJ9LnVybCxcbiAgc2l0ZVVybDogICB7XCJ1cmxcIjpcImh0dHBzOi8vbXVsZXNvZnQuZ2l0aHViLmlvL2FwaS1ub3RlYm9vay9cIixcInRpdGxlXCI6XCJBUEkgTm90ZWJvb2tcIixcIm9hdXRoQ2FsbGJhY2tcIjpcIi9hdXRoZW50aWNhdGUvb2F1dGguaHRtbFwifS51cmwsXG4gIHNpdGVUaXRsZToge1widXJsXCI6XCJodHRwczovL211bGVzb2Z0LmdpdGh1Yi5pby9hcGktbm90ZWJvb2svXCIsXCJ0aXRsZVwiOlwiQVBJIE5vdGVib29rXCIsXCJvYXV0aENhbGxiYWNrXCI6XCIvYXV0aGVudGljYXRlL29hdXRoLmh0bWxcIn0udGl0bGUsXG5cbiAgLy8gQWx0ZXIgdGhlIHZpc2libGUgVUkuXG4gIGhlYWRlcjogICAgICAgICB0cnVlLFxuICBmb290ZXI6ICAgICAgICAgZmFsc2UsXG4gIHNpZGViYXI6ICAgICAgICB0cnVlLFxuICBzYXZhYmxlOiAgICAgICAgdHJ1ZSxcbiAgZW1iZWRkZWQ6ICAgICAgIGZhbHNlLFxuICB0ZXh0UmVhZE9ubHk6ICAgZmFsc2UsXG4gIGNvZGVSZWFkT25seTogICBmYWxzZSxcbiAgYXV0aGVudGljYXRpb246IHRydWUsXG5cbiAgLy8gU2V0IHRoZSBVSSB0ZXh0LlxuICBhdXRoZW50aWNhdGVUZXh0OiAgICdBdXRoZW50aWNhdGUnLFxuICB1bmF1dGhlbnRpY2F0ZVRleHQ6ICdVbmF1dGhlbnRpY2F0ZScsXG5cbiAgLy8gQ29udGVudCBvcHRpb25zLlxuICBjb250ZW50OiAgICAgICAgJycsXG4gIGRlZmF1bHRDb250ZW50OiAnJ1xufSk7XG5cbi8qKlxuICogRXZlcnkgdGltZSB0aGUgc3R5bGUgY29uZmlnIGNoYW5nZXMsIHVwZGF0ZSB0aGUgY3NzLlxuICovXG5jb25maWcubGlzdGVuVG8oY29uZmlnLCAnY2hhbmdlOnN0eWxlJywgKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhlYWRFbCAgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gIHZhciBzdHlsZUVsID0gaGVhZEVsLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJykpO1xuXG4gIHJldHVybiBib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgIHN0eWxlRWwudGV4dENvbnRlbnQgPSBjb25maWcuZ2V0KCdzdHlsZScpO1xuICB9KTtcbn0pKCkpO1xuXG4vKipcbiAqIExpc3RlbiBmb3IgY2hhbmdlcyBpbiB0aGUgZW1iZWRkZWQgY29uZmlnIG9wdGlvbiBhbmQgdXBkYXRlIGNvbmRpdGlvbmFsXG4gKiBzdHlsZXMuXG4gKi9cbmNvbmZpZy5saXN0ZW5Ubyhjb25maWcsICdjaGFuZ2U6ZW1iZWRkZWQnLCBib3VuY2UoZnVuY3Rpb24gKCkge1xuICB2YXIgaXNFbWJlZGRlZCAgICAgID0gISFjb25maWcuZ2V0KCdlbWJlZGRlZCcpO1xuICB2YXIgY2FuQXV0aGVudGljYXRlID0gISFjb25maWcuZ2V0KCdhdXRoZW50aWNhdGlvbicpO1xuXG4gIGNvbmZpZy5zZXQoe1xuICAgIGZvb3RlcjogICAgICAgaXNFbWJlZGRlZCxcbiAgICBoZWFkZXI6ICAgICAgICFpc0VtYmVkZGVkLFxuICAgIHNpZGViYXI6ICAgICAgIWlzRW1iZWRkZWQgJiYgY2FuQXV0aGVudGljYXRlLFxuICAgIHNhdmFibGU6ICAgICAgIWlzRW1iZWRkZWQgJiYgY2FuQXV0aGVudGljYXRlLFxuICAgIHRleHRSZWFkT25seTogIWlzRW1iZWRkZWRcbiAgfSk7XG5cbiAgdmFyIGNsYXNzTmFtZSA9IGRvY3VtZW50LmJvZHkuY2xhc3NOYW1lLnJlcGxhY2UoJyBub3RlYm9vay1lbWJlZGRlZCcsICcnKTtcblxuICAvLyBJZiB0aGUgbm90ZWJvb2sgaXMgZW1iZWRkZWQgYWRkIHRoZSBlbWJlZGRlZCBjbGFzcy5cbiAgaWYgKGlzRW1iZWRkZWQpIHtcbiAgICBkb2N1bWVudC5ib2R5LmNsYXNzTmFtZSA9IGNsYXNzTmFtZSArICcgbm90ZWJvb2stZW1iZWRkZWQnO1xuICB9XG59KSk7XG5cbi8qKlxuICogQ2hhbmdlcyBpbiBhdXRoZW50aWNhdGlvbiBhZmZlY3Qgb3RoZXIgcGFydHMgb2YgdGhlIGFwcGxpY2F0aW9uLlxuICovXG5jb25maWcubGlzdGVuVG8oY29uZmlnLCAnY2hhbmdlOmF1dGhlbnRpY2F0aW9uJywgYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGlzRW1iZWRkZWQgICAgICA9ICEhY29uZmlnLmdldCgnZW1iZWRkZWQnKTtcbiAgdmFyIGNhbkF1dGhlbnRpY2F0ZSA9ICEhY29uZmlnLmdldCgnYXV0aGVudGljYXRpb24nKTtcblxuICBjb25maWcuc2V0KHtcbiAgICBzaWRlYmFyOiBjYW5BdXRoZW50aWNhdGUgJiYgIWlzRW1iZWRkZWQsXG4gICAgc2F2YWJsZTogY2FuQXV0aGVudGljYXRlICYmICFpc0VtYmVkZGVkXG4gIH0pO1xufSkpO1xuIiwidmFyIF8gICAgICAgICA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSAgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIGRvbUxpc3RlbiA9IHJlcXVpcmUoJy4uL2xpYi9kb20tbGlzdGVuJyk7XG5cbi8qKlxuICogVmVyeSBzaW1wbGUgaW1wbGVtZW50YXRpb24gb2YgYSBtZXNzYWdlIGJ1cyB0aGF0IGNhbiBiZSB1c2VkIGFueXdoZXJlIHdpdGhpblxuICogdGhlIGFwcGxpY2F0aW9uLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBtZXNzYWdlcyA9IG1vZHVsZS5leHBvcnRzID0gXy5leHRlbmQoe30sIEJhY2tib25lLkV2ZW50cyk7XG5cbi8qKlxuICogUHJveHkgcmVzaXplIGV2ZW50cyB0byB0aGUgY3VycmVudCBzdGF0ZS5cbiAqL1xubWVzc2FnZXMubGlzdGVuVG8oZG9tTGlzdGVuKHdpbmRvdyksICdyZXNpemUnLCBfLnRocm90dGxlKGZ1bmN0aW9uICgpIHtcbiAgLy8gVHJpZ2dlciBhIHJlc2l6ZSBtZXNzYWdlIHRvIHRoZSBwYXJlbnQgZnJhbWUuXG4gIG1lc3NhZ2VzLnRyaWdnZXIoJ3Jlc2l6ZScpO1xufSwgNjApKTtcbiIsInZhciBfICAgICAgICA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG5cbi8qKlxuICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCB0cmFuc2Zvcm1zIGEgZnVuY3Rpb24gaW50byBhY2NlcHQgYSBzaW5nbGUgb2JqZWN0XG4gKiB3aXRoIHRoZSBrZXkgYXMgdGhlIGZpcnN0IGZ1bmN0aW9uIHBhcmFtZXRlciBhbmQgdGhlIHZhbHVlIGFzIHRoZSBzZWNvbmRcbiAqIGZ1bmN0aW9uIHBhcmFtZXRlci5cbiAqXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG52YXIgYWNjZXB0T2JqZWN0ID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gXy5lYWNoKG9iamVjdCwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cbi8qKlxuICogQW4gZXZlbnQgYmFzZWQgaW1wbGVtZW50YXRpb24gb2YgYSBuYW1lc3BhY2VkIG1pZGRsZXdhcmUgc3lzdGVtLiBQcm92aWRlcyBhXG4gKiBtZXRob2QgdG8gcmVnaXN0ZXIgbmV3IHBsdWdpbnMgYW5kIGEgcXVldWUgc3lzdGVtIHRvIHRyaWdnZXIgcGx1Z2luIGhvb2tzXG4gKiB3aGlsZSBzdGlsbCBiZWluZyBjYXBhYmxlIG9mIGhhdmluZyBhIGZhbGxiYWNrIGZ1bmN0aW9uLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBtaWRkbGV3YXJlID0gbW9kdWxlLmV4cG9ydHMgPSBfLmV4dGVuZCh7fSwgQmFja2JvbmUuRXZlbnRzKTtcblxuLyoqXG4gKiBUaGUgc3RhY2sgaXMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYWxsIHRoZSBtaWRkbGV3YXJlIGZ1bmN0aW9ucyB0byBiZVxuICogZXhlY3V0ZWQgb24gYW4gZXZlbnQuIFNpbWlsYXIgaW4gY29uY2VwdCB0byBgQmFja2JvbmUuRXZlbnRzLl9ldmVudHNgLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xubWlkZGxld2FyZS5fc3RhY2sgPSB7fTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIGZ1bmN0aW9uIGNhbGxiYWNrIGZvciB0aGUgcGx1Z2luIGhvb2suIFRoaXMgaXMgc2ltaWxhciB0byBjb25uZWN0XG4gKiBtaWRkbGV3YXJlIGV4Y2VwdCBwbHVnaW5zIGFyZSBwYXNzZWQgYSBkYXRhIG9iamVjdCwgbmV4dCBmdW5jdGlvbiBhbmQgZG9uZVxuICogZnVuY3Rpb24uIFRoZSByZWdpc3RlcmVkIHBsdWdpbnMgYWxzbyBydW4gaW4gcmV2ZXJzZSB0byBub3JtYWwsIHNpbmNlIHdlIGFkZFxuICogcGx1Z2lucyBhZnRlciBhcHBsaWNhdGlvbiBpbml0aWFsaXphdGlvbi5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgbmFtZVxuICogQHBhcmFtICB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHt0aGlzfVxuICovXG5taWRkbGV3YXJlLnJlZ2lzdGVyID0gYWNjZXB0T2JqZWN0KGZ1bmN0aW9uIChuYW1lLCBmbikge1xuICB2YXIgc3RhY2sgPSB0aGlzLl9zdGFja1tuYW1lXSB8fCAodGhpcy5fc3RhY2tbbmFtZV0gPSBbXSk7XG4gIHRoaXMudHJpZ2dlcignbWlkZGxld2FyZTpyZWdpc3RlcicsIHtcbiAgICBuYW1lOiAgIG5hbWUsXG4gICAgcGx1Z2luOiBmblxuICB9KTtcbiAgc3RhY2sucHVzaChmbik7XG4gIHJldHVybiB0aGlzO1xufSk7XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBwbHVnaW4gdGhhdCB3aWxsIG9ubHkgcnVuIG9ubHkgb25jZS5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgbmFtZVxuICogQHBhcmFtICB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHt0aGlzfVxuICovXG5taWRkbGV3YXJlLnJlZ2lzdGVyT25jZSA9IGFjY2VwdE9iamVjdChmdW5jdGlvbiAobmFtZSwgZm4pIHtcbiAgcmV0dXJuIHRoaXMucmVnaXN0ZXIobmFtZSwgZnVuY3Rpb24gc2VsZiAoKSB7XG4gICAgbWlkZGxld2FyZS5kZXJlZ2lzdGVyKG5hbWUsIHNlbGYpO1xuICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgZm4gPSBudWxsO1xuICB9KTtcbn0pO1xuXG4vKipcbiAqIFJlbW92ZXMgYSBmdW5jdGlvbiwgb3IgYWxsIGZ1bmN0aW9ucywgZnJvbSBhIGdpdmVuIG1pZGRsZXdhcmUgdHJpZ2dlci5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgbmFtZVxuICogQHBhcmFtICB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHt0aGlzfVxuICovXG5taWRkbGV3YXJlLmRlcmVnaXN0ZXIgPSBhY2NlcHRPYmplY3QoZnVuY3Rpb24gKG5hbWUsIGZuKSB7XG4gIHZhciBzdGFjayA9IHRoaXMuX3N0YWNrW25hbWVdIHx8IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIgfHwgc3RhY2tbaV0gPT09IGZuKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ21pZGRsZXdhcmU6ZGVyZWdpc3RlcicsIHtcbiAgICAgICAgbmFtZTogICBuYW1lLFxuICAgICAgICBwbHVnaW46IHN0YWNrW2ldXG4gICAgICB9KTtcbiAgICAgIHN0YWNrLnNwbGljZShpLCAxKTtcbiAgICAgIGkgLT0gMTsgLy8gRGVjcmVtZW50IHRoZSBpbmRleCBieSBvbmUgd2l0aCB0aGUgZnVuY3Rpb24gd2UganVzdCByZW1vdmVkLlxuICAgIH1cbiAgfVxuXG4gIC8vIERlbGV0ZSBlbXB0eSBhcnJheXMuXG4gIGlmICghc3RhY2subGVuZ3RoKSB7XG4gICAgZGVsZXRlIHRoaXMuX3N0YWNrW25hbWVdO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59KTtcblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIG1pZGRsZXdhcmUgc3RhY2sgZXhpc3RzIGZvciB0aGVcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5taWRkbGV3YXJlLmV4aXN0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiAhISh0aGlzLl9zdGFja1tuYW1lXSAmJiB0aGlzLl9zdGFja1tuYW1lXS5sZW5ndGgpO1xufTtcblxuLyoqXG4gKiBMaXN0ZW5zIHRvIGFueSBldmVudHMgdHJpZ2dlcmVkIG9uIHRoZSBtaWRkbGV3YXJlIHN5c3RlbSBhbmQgcnVucyB0aHJvdWdoXG4gKiB0aGUgbWlkZGxld2FyZSBzdGFjayBiYXNlZCBvbiB0aGUgZXZlbnQgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gICBuYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gICBkYXRhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkaXNjYXJkXG4gKi9cbm1pZGRsZXdhcmUubGlzdGVuVG8obWlkZGxld2FyZSwgJ2FsbCcsIGZ1bmN0aW9uIChuYW1lLCBkYXRhLCBkb25lLCBkaXNjYXJkKSB7XG4gIHZhciBzZW50ICA9IGZhbHNlO1xuICB2YXIgc3RhY2sgPSB0aGlzLl9zdGFja1tuYW1lXSB8fCBbXTtcbiAgdmFyIGluZGV4ID0gc3RhY2subGVuZ3RoO1xuICB2YXIgcHJldmlvdXNEYXRhO1xuXG4gIC8vIENhbGwgdGhlIGZpbmFsIGZ1bmN0aW9uIHdoZW4gd2UgYXJlIGRvbmUgZXhlY3V0aW5nIHRoZSBtaWRkbGV3YXJlIHN0YWNrLlxuICAvLyBJdCBzaG91bGQgYWxzbyBiZSBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIgb2YgdGhlIGRhdGEgb2JqZWN0IHRvIGVhY2hcbiAgLy8gbWlkZGxld2FyZSBvcGVyYXRpb24gc2luY2UgaXQncyBwb3NzaWJsZSB0byBzaG9ydC1jaXJjdWl0IHRoZSBlbnRpcmUgc3RhY2suXG4gIHZhciBvdmVyID0gZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgIC8vIFNldCB0aGUgZnVuY3Rpb24gdG8gaGF2ZSBiZWVuIGFscmVhZHkgXCJydW5cIiBhbmQgY2FsbCB0aGUgZmluYWwgZnVuY3Rpb24uXG4gICAgc2VudCA9IHRydWU7XG5cbiAgICBpZiAoXy5pc0Z1bmN0aW9uKGRvbmUpKSB7XG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGVub3VnaCBhcmd1bWVudHMsIHNlbmQgdGhlIHByZXZpb3VzIGRhdGEgb2JqZWN0LlxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyICYmICFkaXNjYXJkKSB7XG4gICAgICAgIGRhdGEgPSBwcmV2aW91c0RhdGE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkb25lKGVyciwgZGF0YSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIENhbGwgdGhlIG5leHQgZnVuY3Rpb24gb24gdGhlIHN0YWNrLCBwYXNzaW5nIGVycm9ycyBmcm9tIHRoZSBwcmV2aW91c1xuICAvLyBzdGFjayBjYWxsIHNvIGl0IGNvdWxkIGJlIGhhbmRsZWQgd2l0aGluIHRoZSBzdGFjayBieSBhbm90aGVyIG1pZGRsZXdhcmUuXG4gIChmdW5jdGlvbiBtb3ZlIChlcnIsIGRhdGEpIHtcbiAgICB2YXIgbGF5ZXIgPSBzdGFja1stLWluZGV4XTtcblxuICAgIC8vIElmIHdlIHdlcmUgcHJvdmlkZWQgdHdvIGFyZ3VtZW50cywgdGhlIHNlY29uZCBhcmd1bWVudCB3b3VsZCBoYXZlIGJlZW5cbiAgICAvLyBhbiB1cGRhdGVkIGRhdGEgb2JqZWN0LiBJZiB3ZSB3ZXJlbid0IHBhc3NlZCB0d28gYXJndW1lbnRzLCB1c2UgdGhlXG4gICAgLy8gcHJldmlvdXMga25vdyBkYXRhIG9iamVjdC5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIGRhdGEgPSBwcmV2aW91c0RhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZXZpb3VzRGF0YSA9IGRhdGE7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgaGF2ZSBjYWxsZWQgdGhlIGRvbmUgZnVuY3Rpb24gaW5zaWRlIGEgcGx1Z2luLCBvciB3ZSBoYXZlIGhpdFxuICAgIC8vIHRoZSBlbmQgb2YgdGhlIHN0YWNrIGxvb3AsIHdlIG5lZWQgdG8gYnJlYWsgdGhlIHJlY3Vyc2l2ZSBuZXh0IGxvb3AuXG4gICAgaWYgKHNlbnQgfHwgIWxheWVyKSB7XG4gICAgICBpZiAoIXNlbnQpIHtcbiAgICAgICAgb3ZlcihlcnIsIGRpc2NhcmQgPyBudWxsIDogZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdmFyIGFyaXR5ICA9IGxheWVyLmxlbmd0aDtcbiAgICAgIHZhciBjYWxsZWQgPSAoZnVuY3Rpb24gKGhhcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChoYXMpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgIGhhcyA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgfSkoZmFsc2UpO1xuXG4gICAgICAvLyBFcnJvciBoYW5kbGluZyBtaWRkbGV3YXJlIGNhbiBiZSByZWdpc3RlcmVkIGJ5IHVzaW5nIGEgZnVuY3Rpb24gd2l0aFxuICAgICAgLy8gZm91ciBhcmd1bWVudHMuIEUuZy4gYGZ1bmN0aW9uIChlcnIsIGRhdGEsIG5leHQsIGRvbmUpIHt9YC4gQW55XG4gICAgICAvLyBmdW5jdGlvbnMgd2l0aCBsZXNzIHRoYW4gZm91ciBhcmd1bWVudHMgd2lsbCBiZSBjYWxsZWQgd2hlbiB3ZSBkb24ndFxuICAgICAgLy8gaGF2ZSBhbiBlcnJvciBpbiB0aGUgcGlwZWxpbmUuXG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGlmIChhcml0eSA+IDMpIHtcbiAgICAgICAgICBsYXllcihlcnIsIGRhdGEsIGNhbGxlZChtb3ZlKSwgY2FsbGVkKG92ZXIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb3ZlKGVyciwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYXJpdHkgPCA0KSB7XG4gICAgICAgIGxheWVyKGRhdGEsIGNhbGxlZChtb3ZlKSwgY2FsbGVkKG92ZXIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1vdmUobnVsbCwgZGF0YSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbW92ZShlLCBkYXRhKTtcbiAgICB9XG4gIH0pKG51bGwsIGRhdGEpO1xufSk7XG4iLCJ2YXIgXyAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSAgICAgICAgID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciBjb25maWcgICAgICAgICAgID0gcmVxdWlyZSgnLi9jb25maWcnKTtcbnZhciBtZXNzYWdlcyAgICAgICAgID0gcmVxdWlyZSgnLi9tZXNzYWdlcycpO1xudmFyIG1pZGRsZXdhcmUgICAgICAgPSByZXF1aXJlKCcuL21pZGRsZXdhcmUnKTtcbnZhciBib3VuY2UgICAgICAgICAgID0gcmVxdWlyZSgnLi4vbGliL2JvdW5jZScpO1xudmFyIGlzTWFjICAgICAgICAgICAgPSByZXF1aXJlKCcuLi9saWIvYnJvd3Nlci9hYm91dCcpLm1hYztcbnZhciBOb3RlYm9vayAgICAgICAgID0gcmVxdWlyZSgnLi4vbW9kZWxzL25vdGVib29rJyk7XG52YXIgUGVyc2lzdGVuY2VJdGVtcyA9IHJlcXVpcmUoJy4uL2NvbGxlY3Rpb25zL3BlcnNpc3RlbmNlLWl0ZW1zJyk7XG5cbi8qKlxuICogUGVyc2lzdGVuY2UgaXMgYSBzdGF0aWMgbW9kZWwgdGhhdCBob2xkcyBhbGwgcGVyc2lzdGVudCBub3RlYm9vayBkYXRhLlxuICpcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqL1xudmFyIFBlcnNpc3RlbmNlID0gQmFja2JvbmUuTW9kZWwuZXh0ZW5kKHtcbiAgZGVmYXVsdHM6IHtcbiAgICBpdGVtczogICAgICBuZXcgUGVyc2lzdGVuY2VJdGVtcygpLFxuICAgIG5vdGVib29rOiAgIG5ldyBOb3RlYm9vaygpLFxuICAgIHN0YXRlOiAgICAgIDAsXG4gICAgdXNlcklkOiAgICAgbnVsbCxcbiAgICB1c2VyVGl0bGU6ICAnJyxcbiAgICByZWFkeVN0YXRlOiBmYWxzZVxuICB9XG59KTtcblxuLyoqXG4gKiBSZXByZXNlbnQgcGVyc2lzdGVuY2Ugc3RhdGVzIGluIGV2ZW50IGxpc3RlbmVycyBhcyBudW1lcmljYWwgZW50aXRpZXMuXG4gKlxuICogQHR5cGUge051bWJlcn1cbiAqL1xuUGVyc2lzdGVuY2UucHJvdG90eXBlLk5VTEwgICAgICA9IFBlcnNpc3RlbmNlLk5VTEwgICAgICA9IDA7XG5QZXJzaXN0ZW5jZS5wcm90b3R5cGUuU0FWSU5HICAgID0gUGVyc2lzdGVuY2UuU0FWSU5HICAgID0gMTtcblBlcnNpc3RlbmNlLnByb3RvdHlwZS5MT0FESU5HICAgPSBQZXJzaXN0ZW5jZS5MT0FESU5HICAgPSAyO1xuUGVyc2lzdGVuY2UucHJvdG90eXBlLlNBVkVfRkFJTCA9IFBlcnNpc3RlbmNlLlNBVkVfRkFJTCA9IDM7XG5QZXJzaXN0ZW5jZS5wcm90b3R5cGUuU0FWRV9ET05FID0gUGVyc2lzdGVuY2UuU0FWRV9ET05FID0gNDtcblBlcnNpc3RlbmNlLnByb3RvdHlwZS5MT0FEX0ZBSUwgPSBQZXJzaXN0ZW5jZS5MT0FEX0ZBSUwgPSA1O1xuUGVyc2lzdGVuY2UucHJvdG90eXBlLkxPQURfRE9ORSA9IFBlcnNpc3RlbmNlLkxPQURfRE9ORSA9IDY7XG5QZXJzaXN0ZW5jZS5wcm90b3R5cGUuQ0hBTkdFRCAgID0gUGVyc2lzdGVuY2UuQ0hBTkdFRCAgID0gNztcblBlcnNpc3RlbmNlLnByb3RvdHlwZS5DTE9OSU5HICAgPSBQZXJzaXN0ZW5jZS5DTE9OSU5HICAgPSA4O1xuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIHRoZSBjdXJyZW50IHVzZXIgc2Vzc2lvbiBpcyB0aGUgb3duZXIgb2YgdGhlIGN1cnJlbnQgbm90ZWJvb2suXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSAgbW9kZWxcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblBlcnNpc3RlbmNlLnByb3RvdHlwZS5pc093bmVyID0gZnVuY3Rpb24gKG1vZGVsKSB7XG4gIHJldHVybiAhbW9kZWwuZ2V0KCdvd25lcklkJykgfHwgbW9kZWwuZ2V0KCdvd25lcklkJykgPT09IHRoaXMuZ2V0KCd1c2VySWQnKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHVzZXIgaXMgdGhlIG93bmVyIG9mIHRoZSBjdXJyZW50IG5vdGVib29rLlxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblBlcnNpc3RlbmNlLnByb3RvdHlwZS5pc0N1cnJlbnRPd25lciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuaXNPd25lcih0aGlzLmdldCgnbm90ZWJvb2snKSk7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGEgbW9kZWwgaXMgbmV3LlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gIG1vZGVsXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5QZXJzaXN0ZW5jZS5wcm90b3R5cGUuaXNOZXcgPSBmdW5jdGlvbiAobW9kZWwpIHtcbiAgcmV0dXJuICFtb2RlbC5nZXQoJ2lkJyk7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBjdXJyZW50IG1vZGVsIGlzIG5ldy5cbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5QZXJzaXN0ZW5jZS5wcm90b3R5cGUuaXNDdXJyZW50TmV3ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5pc05ldyh0aGlzLmdldCgnbm90ZWJvb2snKSk7XG59O1xuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIGEgdXNlciBpcyBjdXJyZW50bHkgYXV0aGVudGljYXRlZC5cbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5QZXJzaXN0ZW5jZS5wcm90b3R5cGUuaXNBdXRoZW50aWNhdGVkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5oYXMoJ3VzZXJJZCcpO1xufTtcblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIHBlcnNpc3RlbmNlIG1vZGVsIGhhcyBiZWVuIHVuc2F2ZWQuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSAgbW9kZWxcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblBlcnNpc3RlbmNlLnByb3RvdHlwZS5pc1NhdmVkID0gZnVuY3Rpb24gKG1vZGVsKSB7XG4gIC8vIENoZWNrIGFnYWluc3QgYSBtYXAgb2YgdGhlIGRpZmZlcmVudCBzdGF0ZXMuXG4gIHJldHVybiBtb2RlbC5nZXQoJ3NhdmVkQ29udGVudCcpID09PSBtb2RlbC5nZXQoJ2NvbnRlbnQnKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGN1cnJlbnQgbW9kZWwgaGFzIGJlZW4gc2F2ZWQuXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuUGVyc2lzdGVuY2UucHJvdG90eXBlLmlzQ3VycmVudFNhdmVkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5pc1NhdmVkKHRoaXMuZ2V0KCdub3RlYm9vaycpKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciBhIG5vdGVib29rIHNob3VsZCBiZSBzYXZlZC4gVGhlcmUgYXJlIGEgbnVtYmVyIG9mIGZhY3RvcnMgdGhhdFxuICogZGljdGF0ZSB3aGV0aGVyIHdlICpzaG91bGQqIHNhdmUgdGhlIG5vdGVib29rLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gIG1vZGVsXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5QZXJzaXN0ZW5jZS5wcm90b3R5cGUuc2hvdWxkU2F2ZSA9IGZ1bmN0aW9uIChtb2RlbCkge1xuICByZXR1cm4gIXRoaXMuaXNOZXcobW9kZWwpICYmXG4gICAgIXRoaXMuaXNTYXZlZChtb2RlbCkgJiZcbiAgICB0aGlzLmlzT3duZXIobW9kZWwpICYmXG4gICAgdGhpcy5pc0F1dGhlbnRpY2F0ZWQoKTtcbn07XG5cbi8qKlxuICogU2VyaWFsaXplIGEgbW9kZWwgYW5kIHVwZGF0ZSB0aGUgY29udGVudCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9ICAgbW9kZWxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAqL1xuUGVyc2lzdGVuY2UucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChtb2RlbCwgZG9uZSkge1xuICBtaWRkbGV3YXJlLnRyaWdnZXIoXG4gICAgJ3BlcnNpc3RlbmNlOnNlcmlhbGl6ZScsXG4gICAgXy5leHRlbmQodGhpcy5nZXRNaWRkbGV3YXJlRGF0YShtb2RlbCksIHtcbiAgICAgIGNvbnRlbnQ6IG51bGxcbiAgICB9KSxcbiAgICBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICBtb2RlbC5zZXQoJ2NvbnRlbnQnLCBkYXRhLmNvbnRlbnQpO1xuICAgICAgcmV0dXJuIGRvbmUoZXJyLCBkYXRhKTtcbiAgICB9XG4gICk7XG59O1xuXG4vKipcbiAqIERlc2VyaWFsaXplIGEgbW9kZWxzIGNvbnRlbnQgYW5kIHNldCB0aGUgY2VsbHMgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9ICAgb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gKi9cblBlcnNpc3RlbmNlLnByb3RvdHlwZS5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChtb2RlbCwgZG9uZSkge1xuICBtaWRkbGV3YXJlLnRyaWdnZXIoXG4gICAgJ3BlcnNpc3RlbmNlOmRlc2VyaWFsaXplJyxcbiAgICBfLmV4dGVuZCh0aGlzLmdldE1pZGRsZXdhcmVEYXRhKG1vZGVsKSwge1xuICAgICAgb3duZXJJZDogbnVsbCxcbiAgICAgIGNlbGxzOiAgIG51bGxcbiAgICB9KSxcbiAgICBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICBtb2RlbC5nZXQoJ21ldGEnKS5yZXNldChkYXRhLm1ldGEpO1xuICAgICAgbW9kZWwuc2V0KCdjZWxscycsIGRhdGEuY2VsbHMpO1xuICAgICAgcmV0dXJuIGRvbmUoZXJyLCBkYXRhKTtcbiAgICB9XG4gICk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBub3RlYm9vay5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gKi9cblBlcnNpc3RlbmNlLnByb3RvdHlwZS5uZXcgPSBmdW5jdGlvbiAoZG9uZSkge1xuICB0aGlzLnNldCgnc3RhdGUnLCBQZXJzaXN0ZW5jZS5OVUxMKTtcblxuICByZXR1cm4gdGhpcy5sb2FkKG5ldyBOb3RlYm9vaygpLCBkb25lKTtcbn07XG5cbi8qKlxuICogU2F2ZSBhIG5vdGVib29rIG1vZGVsLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSAgIG1vZGVsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gKi9cblBlcnNpc3RlbmNlLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24gKG1vZGVsLCBkb25lKSB7XG4gIGlmICghY29uZmlnLmdldCgnc2F2YWJsZScpKSB7XG4gICAgcmV0dXJuIGRvbmUgJiYgZG9uZShuZXcgRXJyb3IoJ1NhdmUgaXMgbm90IGF2YWlsYWJsZScpKTtcbiAgfVxuXG4gIGlmICghdGhpcy5pc093bmVyKG1vZGVsKSkge1xuICAgIHJldHVybiBkb25lICYmIGRvbmUobmV3IEVycm9yKCdZb3UgYXJlIG5vdCB0aGUgY3VycmVudCBub3RlYm9vayBvd25lcicpKTtcbiAgfVxuXG4gIHRoaXMuc2V0KCdzdGF0ZScsIFBlcnNpc3RlbmNlLlNBVklORyk7XG5cbiAgbWlkZGxld2FyZS50cmlnZ2VyKFxuICAgICdwZXJzaXN0ZW5jZTpzYXZlJyxcbiAgICB0aGlzLmdldE1pZGRsZXdhcmVEYXRhKG1vZGVsKSxcbiAgICBfLmJpbmQoZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICB0aGlzLnNldCgnc3RhdGUnLCBQZXJzaXN0ZW5jZS5TQVZFX0ZBSUwpO1xuICAgICAgICByZXR1cm4gZG9uZSAmJiBkb25lKGVycik7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgbW9kZWwgYXR0cmlidXRlcy5cbiAgICAgIG1vZGVsLnNldCgnaWQnLCAgICAgICAgZGF0YS5pZCk7XG4gICAgICBtb2RlbC5zZXQoJ2NvbnRlbnQnLCAgIGRhdGEuY29udGVudCk7XG4gICAgICBtb2RlbC5zZXQoJ293bmVySWQnLCAgIGRhdGEub3duZXJJZCk7XG4gICAgICBtb2RlbC5zZXQoJ3VwZGF0ZWRBdCcsIG5ldyBEYXRlKCkpO1xuICAgICAgbW9kZWwuZ2V0KCdtZXRhJykucmVzZXQoZGF0YS5tZXRhKTtcbiAgICAgIG1vZGVsLnNldCgnc2F2ZWRDb250ZW50JywgbW9kZWwuZ2V0KCdjb250ZW50JykpO1xuXG4gICAgICB0aGlzLnNldCgnc3RhdGUnLCBQZXJzaXN0ZW5jZS5TQVZFX0RPTkUpO1xuXG4gICAgICAvLyBBZGQgYSBwZXJzaXN0ZW5jZSBpdGVtIGVudHJ5LlxuICAgICAgdGhpcy5nZXQoJ2l0ZW1zJykuYWRkKHtcbiAgICAgICAgaWQ6ICAgICAgICBtb2RlbC5nZXQoJ2lkJyksXG4gICAgICAgIG1ldGE6ICAgICAgbW9kZWwuZ2V0KCdtZXRhJykudG9KU09OKCksXG4gICAgICAgIHVwZGF0ZWRBdDogbW9kZWwuZ2V0KCd1cGRhdGVkQXQnKVxuICAgICAgfSwge1xuICAgICAgICBtZXJnZTogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBkb25lICYmIGRvbmUoKTtcbiAgICB9LCB0aGlzKVxuICApO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYSBnaXZlbiBub3RlYm9vaywgc3BlY2lmaWVkIGJ5IGl0cyBpZCwgd2hpY2ggaXMgcGVyc2lzdGVuY2VcbiAqIGVuZ2luZS1zcGVjaWZpYy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gICBpZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICovXG5QZXJzaXN0ZW5jZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGlkLCBkb25lKSB7XG4gIG1pZGRsZXdhcmUudHJpZ2dlcigncGVyc2lzdGVuY2U6cmVtb3ZlJywge1xuICAgIGlkOiBpZFxuICB9LCBfLmJpbmQoZnVuY3Rpb24oZXJyKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGRvbmUgJiYgZG9uZShlcnIpO1xuICAgIH1cblxuICAgIHRoaXMuZ2V0KCdpdGVtcycpLnJlbW92ZSh0aGlzLmdldCgnaXRlbXMnKS5nZXQoaWQpKTtcblxuICAgIHJldHVybiBkb25lICYmIGRvbmUoKTtcbiAgfSwgdGhpcykpO1xufTtcblxuLyoqXG4gKiBBdXRoZW50aWNhdGUgd2l0aCB0aGUgZXh0ZXJuYWwgcGVyc2lzdGVuY2UgcHJvdmlkZXIuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICovXG5QZXJzaXN0ZW5jZS5wcm90b3R5cGUuYXV0aGVudGljYXRlID0gZnVuY3Rpb24gKGRvbmUpIHtcbiAgaWYgKCFjb25maWcuZ2V0KCdhdXRoZW50aWNhdGlvbicpKSB7XG4gICAgcmV0dXJuIGRvbmUgJiYgZG9uZShuZXcgRXJyb3IoJ0F1dGhlbnRpY2F0aW9uIGhhcyBiZWVuIGRpc2FibGVkJykpO1xuICB9XG5cbiAgbWlkZGxld2FyZS50cmlnZ2VyKFxuICAgICdwZXJzaXN0ZW5jZTphdXRoZW50aWNhdGUnLFxuICAgIF8uZXh0ZW5kKHRoaXMuZ2V0TWlkZGxld2FyZURhdGEoKSwge1xuICAgICAgdXNlcklkOiAgICBudWxsLFxuICAgICAgdXNlclRpdGxlOiBudWxsXG4gICAgfSksXG4gICAgXy5iaW5kKGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICAgIHRoaXMuc2V0KCd1c2VySWQnLCAgICBkYXRhLnVzZXJJZCk7XG4gICAgICB0aGlzLnNldCgndXNlclRpdGxlJywgZGF0YS51c2VyVGl0bGUpO1xuXG4gICAgICByZXR1cm4gZG9uZSAmJiBkb25lKGVycik7XG4gICAgfSwgdGhpcylcbiAgKTtcbn07XG5cbi8qKlxuICogVW5hdXRoZW50aWNhdGUgdGhlIHBlcnNpc3RlbmNlIGxheWVyIGxvZ2luLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAqL1xuUGVyc2lzdGVuY2UucHJvdG90eXBlLnVuYXV0aGVudGljYXRlID0gZnVuY3Rpb24gKGRvbmUpIHtcbiAgbWlkZGxld2FyZS50cmlnZ2VyKFxuICAgICdwZXJzaXN0ZW5jZTp1bmF1dGhlbnRpY2F0ZScsXG4gICAgdGhpcy5nZXRNaWRkbGV3YXJlRGF0YSgpLFxuICAgIF8uYmluZChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICB0aGlzLnVuc2V0KCd1c2VySWQnKTtcbiAgICAgIHRoaXMudW5zZXQoJ3VzZXJUaXRsZScpO1xuXG4gICAgICB0aGlzLmdldCgnaXRlbXMnKS5yZXNldCgpO1xuXG4gICAgICByZXR1cm4gZG9uZSAmJiBkb25lKGVycik7XG4gICAgfSwgdGhpcylcbiAgKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBwZXJzaXN0ZW5jZSBvYmplY3QgaW4gYSBmb3JtYXQgdGhhdCBpcyBzdWl0YWJsZSBmb3IgbWlkZGxld2FyZS5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblBlcnNpc3RlbmNlLnByb3RvdHlwZS5nZXRNaWRkbGV3YXJlRGF0YSA9IGZ1bmN0aW9uIChtb2RlbCkge1xuICB2YXIgb2JqID0gbW9kZWwgPyBtb2RlbC50b0pTT04oKSA6IHt9O1xuXG4gIHJldHVybiBfLmV4dGVuZChvYmosIHtcbiAgICBtZXRhOiAgICAgICAgICAgIG1vZGVsID8gbW9kZWwuZ2V0KCdtZXRhJykudG9KU09OKCkgOiB7fSxcbiAgICBzYXZlOiAgICAgICAgICAgIF8uYmluZCh0aGlzLnNhdmUsIHRoaXMsIG1vZGVsKSxcbiAgICBpc05ldzogICAgICAgICAgIF8uYmluZCh0aGlzLmlzTmV3LCB0aGlzLCBtb2RlbCksXG4gICAgaXNPd25lcjogICAgICAgICBfLmJpbmQodGhpcy5pc093bmVyLCB0aGlzLCBtb2RlbCksXG4gICAgaXNTYXZlZDogICAgICAgICBfLmJpbmQodGhpcy5pc1NhdmVkLCB0aGlzLCBtb2RlbCksXG4gICAgc2hvdWxkU2F2ZTogICAgICBfLmJpbmQodGhpcy5zaG91bGRTYXZlLCB0aGlzLCBtb2RlbCksXG4gICAgYXV0aGVudGljYXRlOiAgICBfLmJpbmQodGhpcy5hdXRoZW50aWNhdGUsIHRoaXMpLFxuICAgIGlzQXV0aGVudGljYXRlZDogXy5iaW5kKHRoaXMuaXNBdXRoZW50aWNhdGVkLCB0aGlzKVxuICB9KTtcbn07XG5cbi8qKlxuICogTG9hZCBhIG5vdGVib29rIG1vZGVsLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSAgIG1vZGVsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gKi9cblBlcnNpc3RlbmNlLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKG1vZGVsLCBkb25lKSB7XG4gIG1vZGVsLl9sb2FkaW5nID0gdHJ1ZTtcbiAgdGhpcy5zZXQoJ3N0YXRlJywgUGVyc2lzdGVuY2UuTE9BRElORyk7XG5cbiAgcmV0dXJuIG1pZGRsZXdhcmUudHJpZ2dlcihcbiAgICAncGVyc2lzdGVuY2U6bG9hZCcsXG4gICAgXy5leHRlbmQodGhpcy5nZXRNaWRkbGV3YXJlRGF0YShtb2RlbCksIHtcbiAgICAgIG1ldGE6ICAgIHt9LFxuICAgICAgY29udGVudDogbnVsbCxcbiAgICAgIGNlbGxzOiAgIG51bGxcbiAgICB9KSxcbiAgICBfLmJpbmQoZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgICAgLy8gVXBkYXRlIGFsbCByZWxldmFudCBtb2RlbCBhdHRyaWJ1dGVzLlxuICAgICAgbW9kZWwuc2V0KHtcbiAgICAgICAgaWQ6ICAgICAgICBkYXRhLmlkLFxuICAgICAgICBvd25lcklkOiAgIGRhdGEub3duZXJJZCxcbiAgICAgICAgdXBkYXRlZEF0OiBkYXRhLnVwZGF0ZWRBdFxuICAgICAgfSk7XG5cbiAgICAgIG1vZGVsLnNldCgnY29udGVudCcsIGRhdGEuY29udGVudCwge1xuICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBkZWxldGUgbW9kZWwuX2xvYWRpbmc7XG5cbiAgICAgIHZhciBjb21wbGV0ZSA9IF8uYmluZChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMuc2V0KCdzdGF0ZScsIGVyciA/IFBlcnNpc3RlbmNlLkxPQURfRkFJTCA6IFBlcnNpc3RlbmNlLkxPQURfRE9ORSk7XG5cbiAgICAgICAgcmV0dXJuIGRvbmUgJiYgZG9uZShlcnIpO1xuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRlKGVycik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmxvYWRNb2RlbChtb2RlbCwgY29tcGxldGUpO1xuICAgIH0sIHRoaXMpXG4gICk7XG59O1xuXG4vKipcbiAqIEV4dHJlbWVseSBiYXNpYyBtb2RlbCBsb2FkIGZ1bmN0aW9uLlxuICovXG5QZXJzaXN0ZW5jZS5wcm90b3R5cGUubG9hZE1vZGVsID0gZnVuY3Rpb24gKG1vZGVsLCBkb25lKSB7XG4gIHJldHVybiB0aGlzLmRlc2VyaWFsaXplKG1vZGVsLCBfLmJpbmQoZnVuY3Rpb24gKGVycikge1xuICAgIG1vZGVsLnNldCgnc2F2ZWRDb250ZW50JywgbW9kZWwuZ2V0KCdjb250ZW50JykpO1xuXG4gICAgdGhpcy5zZXQoJ25vdGVib29rJywgbW9kZWwpO1xuICAgIGNvbmZpZy5zZXQoJ2NvbnRlbnQnLCBtb2RlbC5nZXQoJ2NvbnRlbnQnKSk7XG4gICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2VOb3RlYm9vaycpO1xuXG4gICAgcmV0dXJuIGRvbmUgJiYgZG9uZShlcnIpO1xuICB9LCB0aGlzKSk7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgbGlzdCBvZiBhbGwgbG9hZGFibGUgbm90ZWJvb2tzLiBOb3RlIHRoYXQgdGhpcyB3aWxsIG9mdGVuXG4gKiBpbnZvbHZlIGdvaW5nIHRvIHRoZSBuZXR3b3JrIG9yIGRpc2suXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICovXG5QZXJzaXN0ZW5jZS5wcm90b3R5cGUubGlzdCA9IGZ1bmN0aW9uIChkb25lKSB7XG4gIGlmICghdGhpcy5pc0F1dGhlbnRpY2F0ZWQoKSkge1xuICAgIHJldHVybiBkb25lICYmIGRvbmUobmV3IEVycm9yKCdOb3QgYXV0aGVudGljYXRlZCcpKTtcbiAgfVxuXG4gIHJldHVybiBtaWRkbGV3YXJlLnRyaWdnZXIoXG4gICAgJ3BlcnNpc3RlbmNlOmxpc3QnLCBbXSwgXy5iaW5kKGZ1bmN0aW9uIChlcnIsIGxpc3QpIHtcbiAgICAgIHRoaXMuZ2V0KCdpdGVtcycpLnNldChsaXN0KTtcblxuICAgICAgcmV0dXJuIGRvbmUoZXJyLCB0aGlzLmdldCgnaXRlbXMnKS50b0pTT04oKSk7XG4gICAgfSwgdGhpcylcbiAgKTtcbn07XG5cbi8qKlxuICogQ2xvbmUgdGhlIG5vdGVib29rIGFuZCByZXNldCB0aGUgcGVyc2lzdGVuY2UgbGF5ZXIgdG8gbG9vayBub3JtYWwgYWdhaW4uXG4gKi9cblBlcnNpc3RlbmNlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIChkb25lKSB7XG4gIHRoaXMuc2V0KCdzdGF0ZScsIFBlcnNpc3RlbmNlLkNMT05JTkcpO1xuXG4gIHZhciBtb2RlbCA9IHRoaXMuZ2V0KCdub3RlYm9vaycpLmNsb25lKCk7XG5cbiAgLy8gU2V0IHRoZSBub3RlYm9vayBpbnN0YW5jZSBpbiB0aGUgc3RhdGUuXG4gIG1vZGVsLnVuc2V0KCdpZCcpO1xuICBtb2RlbC51bnNldCgnb3duZXJJZCcpO1xuXG4gIG1pZGRsZXdhcmUudHJpZ2dlcihcbiAgICAncGVyc2lzdGVuY2U6Y2xvbmUnLFxuICAgIHRoaXMuZ2V0TWlkZGxld2FyZURhdGEobW9kZWwpLFxuICAgIF8uYmluZChmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICBtb2RlbC5zZXQoJ2NlbGxzJywgZGF0YS5jZWxscywgeyBzaWxlbnQ6IHRydWUgfSk7XG4gICAgICBtb2RlbC5nZXQoJ21ldGEnKS5yZXNldChkYXRhLm1ldGEpO1xuXG4gICAgICB0aGlzLnNldCgnc3RhdGUnLCBQZXJzaXN0ZW5jZS5OVUxMKTtcbiAgICAgIHRoaXMuc2V0KCdub3RlYm9vaycsIG1vZGVsKTtcbiAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlTm90ZWJvb2snKTtcblxuICAgICAgcmV0dXJuIGRvbmUgJiYgZG9uZShlcnIpO1xuICAgIH0sIHRoaXMpXG4gICk7XG59O1xuXG4vKipcbiAqIEV4cG9ydCBhIHN0YXRpYyBpbnN0YW5jZSBvZiB0aGUgcGVyc2lzdGVuY2UgbW9kZWwuXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIHBlcnNpc3RlbmNlID0gbW9kdWxlLmV4cG9ydHMgPSBuZXcgUGVyc2lzdGVuY2UoKTtcblxuLyoqXG4gKiBTeW5jIHRoZSBub3RlYm9vayBhbmQgc3RyaW5naWZpZWQgY29udGVudHMgdG9nZXRoZXIuXG4gKi9cbnBlcnNpc3RlbmNlLmxpc3RlblRvKHBlcnNpc3RlbmNlLCAnY2hhbmdlOm5vdGVib29rJywgYm91bmNlKChmdW5jdGlvbiAoKSB7XG4gIHZhciBtb2RlbCAgID0gcGVyc2lzdGVuY2UuZ2V0KCdub3RlYm9vaycpO1xuICB2YXIgc3luY2luZyA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBXcmFwIHN5bmMgbWV0aG9kcyB0byBwcm90ZWN0IGZyb20gYW4gaW5maW5pdGUgbG9vcC5cbiAgICpcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGZuXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKi9cbiAgdmFyIHdyYXBTeW5jID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc3luY2luZykgeyByZXR1cm47IH1cblxuICAgICAgc3luY2luZyA9IHRydWU7XG5cbiAgICAgIHJldHVybiBwZXJzaXN0ZW5jZVttZXRob2RdKG1vZGVsLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN5bmNpbmcgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIFdyYXAgc2VyaWFsaXphdGlvbiBpbiBhc3luYyBndWFyZHMuXG4gICAqL1xuICB2YXIgc2VyaWFsaXplICAgPSB3cmFwU3luYygnc2VyaWFsaXplJyk7XG4gIHZhciBkZXNlcmlhbGl6ZSA9IHdyYXBTeW5jKCdkZXNlcmlhbGl6ZScpO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGxpc3RlbmVycyBvbiB0aGUgcHJldmlvdXMgbm90ZWJvb2sgaW5zdGFuY2UuXG4gICAgICovXG4gICAgcGVyc2lzdGVuY2Uuc3RvcExpc3RlbmluZyhtb2RlbCk7XG4gICAgcGVyc2lzdGVuY2Uuc3RvcExpc3RlbmluZyhtb2RlbC5nZXQoJ21ldGEnKSk7XG4gICAgbW9kZWwgPSBwZXJzaXN0ZW5jZS5nZXQoJ25vdGVib29rJyk7XG5cbiAgICAvKipcbiAgICAgKiBEZXNlcmlhbGl6ZSB0aGUgbm90ZWJvb2sgb24gc3RhdGljIGNoYW5nZXMuXG4gICAgICovXG4gICAgcGVyc2lzdGVuY2UubGlzdGVuVG8obW9kZWwsICdjaGFuZ2U6Y29udGVudCcsIGRlc2VyaWFsaXplKTtcblxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZSB0aGUgbm90ZWJvb2sgb24gZHluYW1pYyBjaGFuZ2VzLlxuICAgICAqL1xuICAgIHBlcnNpc3RlbmNlLmxpc3RlblRvKG1vZGVsLCAnY2hhbmdlOmNlbGxzJywgc2VyaWFsaXplKTtcbiAgICBwZXJzaXN0ZW5jZS5saXN0ZW5Ubyhtb2RlbC5nZXQoJ21ldGEnKSwgJ2NoYW5nZScsIHNlcmlhbGl6ZSk7XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGNvbmZpZ3VyYXRpb24gaWQgYW55IHRpbWUgdGhlIG1vZGVsIGNoYW5nZXMuXG4gICAgICovXG4gICAgcGVyc2lzdGVuY2UubGlzdGVuVG8obW9kZWwsICdjaGFuZ2U6aWQnLCBib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgICAgY29uZmlnLnNldCgnaWQnLCBtb2RlbC5nZXQoJ2lkJykpO1xuICAgIH0pKTtcblxuICAgIC8qKlxuICAgICAqIEFueSBjaGFuZ2VzIHRoYXQgb2NjdXIgc2hvdWxkIGJlIHN5bmNlZCB3aXRoIHRoZSBzdGF0ZSBhbmQgY29uZmlnLlxuICAgICAqL1xuICAgIHBlcnNpc3RlbmNlLmxpc3RlblRvKG1vZGVsLCAnY2hhbmdlOmNvbnRlbnQnLCBib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gQXZvaWQgdHJpZ2dlcmluZyBjb250ZW50IGNoYW5nZXMgd2hlbiB0aGUgbm90ZWJvb2sgaXMgbG9hZGluZy5cbiAgICAgIGlmIChtb2RlbC5fbG9hZGluZykgeyByZXR1cm47IH1cblxuICAgICAgdmFyIGhhc0NoYW5nZWQgPSAhcGVyc2lzdGVuY2UuaXNTYXZlZChtb2RlbCk7XG5cbiAgICAgIGNvbmZpZy5zZXQoJ2NvbnRlbnQnLCBtb2RlbC5nZXQoJ2NvbnRlbnQnKSk7XG4gICAgICBwZXJzaXN0ZW5jZS5zZXQoJ3N0YXRlJywgcGVyc2lzdGVuY2VbaGFzQ2hhbmdlZCA/ICdDSEFOR0VEJyA6ICdOVUxMJ10pO1xuXG4gICAgICBtaWRkbGV3YXJlLnRyaWdnZXIoXG4gICAgICAgICdwZXJzaXN0ZW5jZTpjaGFuZ2UnLFxuICAgICAgICBwZXJzaXN0ZW5jZS5nZXRNaWRkbGV3YXJlRGF0YShwZXJzaXN0ZW5jZS5nZXQoJ25vdGVib29rJykpXG4gICAgICApO1xuICAgIH0pKTtcbiAgfTtcbn0pKCkpKTtcblxuLyoqXG4gKiBMaXN0ZW5zIHRvIGFueSBjaGFuZ2VzIHRvIHRoZSB1c2VyIGlkIGFuZCBlbWl0cyBhIGN1c3RvbSBgY2hhbmdlVXNlcmAgZXZlbnRcbiAqIHRoYXQgZGlmZmVyZW50IHBhcnRzIG9mIHRoZSBhcHBsaWNhdGlvbiBiaW5kIHRvIGFuZCBkb2VzIHRoaW5ncyBsaWtlXG4gKiByZXJlbmRlcmluZyBvZiBub3RlYm9vay5cbiAqL1xucGVyc2lzdGVuY2UubGlzdGVuVG8oXG4gIHBlcnNpc3RlbmNlLCAnY2hhbmdlOnVzZXJJZCBjaGFuZ2U6dXNlclRpdGxlJywgXy5kZWJvdW5jZShmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2VVc2VyJywgdGhpcyk7XG4gIH0sIDMwMClcbik7XG5cbi8qKlxuICogQ2hlY2sgd2l0aCBhbiBleHRlcm5hbCBzZXJ2aWNlIHdoZXRoZXIgYSB1c2VycyBzZXNzaW9uIGlzIGF1dGhlbnRpY2F0ZWQuIFRoaXNcbiAqIHNob3VsZCBvbmx5IGNoZWNrLCBhbmQgbm90IGFjdHVhbGx5IHRyaWdnZXIgYXV0aGVudGljYXRpb24gd2hpY2ggd291bGQgYmUgYVxuICogamFycmluZyBleHBlcmllbmNlLiBBbHNvIGxvYWQgdGhlIGluaXRpYWwgbm90ZWJvb2sgY29udGVudHMgYWxvbmdzaWRlLlxuICovXG5wZXJzaXN0ZW5jZS5saXN0ZW5UbyhtaWRkbGV3YXJlLCAnYXBwbGljYXRpb246cmVhZHknLCBmdW5jdGlvbiAoKSB7XG4gIGlmICghY29uZmlnLmdldCgnYXV0aGVudGljYXRpb24nKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiBtaWRkbGV3YXJlLnRyaWdnZXIoXG4gICAgJ3BlcnNpc3RlbmNlOmF1dGhlbnRpY2F0ZWQnLFxuICAgIF8uZXh0ZW5kKHRoaXMuZ2V0TWlkZGxld2FyZURhdGEoKSwge1xuICAgICAgdXNlcklkOiAgICBudWxsLFxuICAgICAgdXNlclRpdGxlOiBudWxsXG4gICAgfSksIF8uYmluZChmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICB0aGlzLnNldCgndXNlcklkJywgICAgIGRhdGEudXNlcklkKTtcbiAgICAgIHRoaXMuc2V0KCd1c2VyVGl0bGUnLCAgZGF0YS51c2VyVGl0bGUpO1xuXG4gICAgICAvLyBTZXQgdGhlIHJlYWR5IHN0YXRlIGZsYWcgZm9yIHRoZSBBUEkgTm90ZWJvb2sgU2l0ZSB0byBob29rIG9udG8uXG4gICAgICB0aGlzLnNldCgncmVhZHlTdGF0ZScsIHRydWUpO1xuXG4gICAgICBpZiAoIXRoaXMuaGFzKCdpZCcpICYmICF0aGlzLmhhcygnb3duZXJJZCcpKSB7XG4gICAgICAgIHRoaXMuc2V0KCdvd25lcklkJywgdGhpcy5nZXQoJ3VzZXJJZCcpKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKVxuICApO1xufSk7XG5cbi8qKlxuICogT24gbG9hZCBtZXNzYWdlcywgcmVsb2FkIHRoZSBjdXJyZW50IHBlcnNpc3RlbmNlIG9iamVjdC5cbiAqL1xucGVyc2lzdGVuY2UubGlzdGVuVG8obWVzc2FnZXMsICdsb2FkJywgZnVuY3Rpb24gKGlkKSB7XG4gIHJldHVybiBwZXJzaXN0ZW5jZS5sb2FkKG5ldyBOb3RlYm9vayh7IGlkOiBpZCB9KSk7XG59KTtcblxuLyoqXG4gKiBLZWVwIHRoZSBwZXJzaXN0ZW5jZSBtZXRhIGRhdGEgaW4gc3luYyB3aXRoIHRoZSBjb25maWcgb3B0aW9uLlxuICovXG5wZXJzaXN0ZW5jZS5saXN0ZW5Ubyhjb25maWcsICdjaGFuZ2U6dXJsJywgZnVuY3Rpb24gKCkge1xuICBpZiAoIWNvbmZpZy5nZXQoJ2lkJykpIHsgcmV0dXJuOyB9XG5cbiAgcGVyc2lzdGVuY2UuZ2V0KCdub3RlYm9vaycpLmdldCgnbWV0YScpLnNldCgnc2l0ZScsIGNvbmZpZy5nZXQoJ3VybCcpKTtcbn0pO1xuXG4vKipcbiAqIFdoZW4gdGhlIGFwcGxpY2F0aW9uIGlzIHJlYWR5LCBmaW5hbGx5IGF0dGVtcHQgdG8gbG9hZCB0aGUgaW5pdGlhbCBjb250ZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSAgIGFwcFxuICogQHBhcmFtIHtGdW5jdGlvbn0gbmV4dFxuICovXG5taWRkbGV3YXJlLnJlZ2lzdGVyKCdhcHBsaWNhdGlvbjpyZWFkeScsIGZ1bmN0aW9uIChhcHAsIG5leHQpIHtcbiAgdmFyIG5vdGVib29rID0gbmV3IE5vdGVib29rKHtcbiAgICBpZDogICAgICBjb25maWcuZ2V0KCdpZCcpLFxuICAgIGNvbnRlbnQ6IGNvbmZpZy5nZXQoJ2NvbnRlbnQnKVxuICB9KTtcblxuICAvLyBIYW5kbGUgY29uZmlndXJhdGlvbiBjb250ZW50IG92ZXIgYSByZW1vdGUgZGF0YSBsb2FkLlxuICBpZiAobm90ZWJvb2suZ2V0KCdjb250ZW50JykpIHtcbiAgICByZXR1cm4gcGVyc2lzdGVuY2UubG9hZE1vZGVsKG5vdGVib29rLCBuZXh0KTtcbiAgfVxuXG4gIHJldHVybiBwZXJzaXN0ZW5jZS5sb2FkKG5vdGVib29rLCBuZXh0KTtcbn0pO1xuXG4vKipcbiAqIFdoZW4gdGhlIGFwcGxpY2F0aW9uIGlzIHJlYWR5LCBzdGFydCBsaXN0ZW5pbmcgZm9yIGxpdmUgaWQgY2hhbmdlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gICBhcHBcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHRcbiAqL1xubWlkZGxld2FyZS5yZWdpc3RlcignYXBwbGljYXRpb246cmVhZHknLCBmdW5jdGlvbiAoYXBwLCBuZXh0KSB7XG4gIC8qKlxuICAgKiBMaXN0ZW5zIGZvciBnbG9iYWwgaWQgY2hhbmdlcyBhbmQgdXBkYXRlcyBwZXJzaXN0ZW5jZS4gUHJpbWFyaWx5IGZvclxuICAgKiBsb2FkaW5nIGEgbmV3IG5vdGVib29rIGZyb20gdGhlIGVtYmVkIGZyYW1lIHdoZXJlIHRoZSBjdXJyZW50IHVybCBzY2hlbWVcbiAgICogaXMgdW5saWtlbHkgdG8gYmUgbWFpbnRhaW5lZC5cbiAgICovXG4gIHBlcnNpc3RlbmNlLmxpc3RlblRvKGNvbmZpZywgJ2NoYW5nZTppZCcsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29uZmlnSWQgICA9IGNvbmZpZy5nZXQoJ2lkJyk7XG4gICAgdmFyIG5vdGVib29rSWQgPSBwZXJzaXN0ZW5jZS5nZXQoJ25vdGVib29rJykuZ2V0KCdpZCcpO1xuXG4gICAgLy8gQXZvaWQgbG9hZGluZyBvdmVyIHRoZSBzYW1lIG5vdGVib29rIGluc3RhbmNlLlxuICAgIGlmICgoIWNvbmZpZ0lkICYmICFub3RlYm9va0lkKSB8fCAoY29uZmlnSWQgPT09IG5vdGVib29rSWQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcGVyc2lzdGVuY2UubG9hZChuZXcgTm90ZWJvb2soeyBpZDogY29uZmlnSWQgfSkpO1xuICB9KTtcblxuICByZXR1cm4gbmV4dCgpO1xufSk7XG5cbi8qKlxuICogV2hlbiB0aGUgYXBwbGljYXRpb24gaXMgcmVhZHksIHN0YXJ0IGxpc3RlbmluZyBmb3IgY29uZmlnIGNvbnRlbnQgY2hhbmdlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gICBhcHBcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHRcbiAqL1xubWlkZGxld2FyZS5yZWdpc3RlcignYXBwbGljYXRpb246cmVhZHknLCBmdW5jdGlvbiAoYXBwLCBuZXh0KSB7XG4gIHBlcnNpc3RlbmNlLmxpc3RlblRvKGNvbmZpZywgJ2NoYW5nZTpjb250ZW50JywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb25maWdDb250ZW50ICAgPSBjb25maWcuZ2V0KCdjb250ZW50Jyk7XG4gICAgdmFyIG5vdGVib29rQ29udGVudCA9IHBlcnNpc3RlbmNlLmdldCgnbm90ZWJvb2snKS5nZXQoJ2NvbnRlbnQnKTtcblxuICAgIC8vIEF2b2lkIGxvYWRpbmcgb3ZlciB0aGUgc2FtZSBub3RlYm9vayBjb250ZW50LlxuICAgIGlmIChjb25maWdDb250ZW50ID09PSBub3RlYm9va0NvbnRlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwZXJzaXN0ZW5jZS5sb2FkTW9kZWwobmV3IE5vdGVib29rKHsgY29udGVudDogY29uZmlnQ29udGVudCB9KSk7XG4gIH0pO1xuXG4gIHJldHVybiBuZXh0KCk7XG59KTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIGZ1bmN0aW9uIHRvIGJsb2NrIHRoZSByZWd1bGFyIHNhdmUgYnV0dG9uIGFuZCBvdmVycmlkZSB3aXRoIHNhdmluZ1xuICogdG8gdGhlIHBlcnNpc3RlbmNlIGxheWVyLlxuICovXG5taWRkbGV3YXJlLnJlZ2lzdGVyKFxuICAna2V5ZG93bjonICsgKGlzTWFjID8gJ0NtZCcgOiAnQ3RybCcpICsgJy1TJyxcbiAgZnVuY3Rpb24gKGV2ZW50LCBuZXh0LCBkb25lKSB7XG4gICAgaWYgKCFjb25maWcuZ2V0KCdzYXZhYmxlJykpIHsgcmV0dXJuOyB9XG5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHJldHVybiBwZXJzaXN0ZW5jZS5zYXZlKHBlcnNpc3RlbmNlLmdldCgnbm90ZWJvb2snKSwgZG9uZSk7XG4gIH1cbik7XG4iLCJ2YXIgRE9NQmFycyAgPSByZXF1aXJlKCdkb21iYXJzL3J1bnRpbWUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgbWVzc2FnZXMgPSByZXF1aXJlKCcuL21lc3NhZ2VzJyk7XG5cbi8qKlxuICogRXh0ZW5kYWJsZSBpbXBsZW1lbnRhdGlvbiBvZiBhcHBsaWNhdGlvbiBzdGF0ZSBkYXRhLiBTdGF0ZSBjYW4gbGlzdGVuIHRvIHRoZVxuICogZ2xvYmFsIG1lc3NhZ2luZyBvYmplY3QsIGJ1dCBpdCBzaG91bGQgbmV2ZXIgbGlzdGVuIHRoZSBvdGhlciB3YXkgYXJvdW5kLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBzdGF0ZSA9IG1vZHVsZS5leHBvcnRzID0gbmV3IEJhY2tib25lLk1vZGVsKCk7XG5cbi8qKlxuICogS2VlcCB0cmFjayBvZiB0aGUgcHJldmlvdXMgZXhlY3V0aW9uLlxuICovXG52YXIgZXhlY1RpbWVvdXQgPSBudWxsO1xuXG4vKipcbiAqIExpc3RlbiB0byByZXNpemUgZXZlbnRzIHRocm91Z2ggdGhlIG1lc3NhZ2VzIGFuZCB1cGRhdGUgdGhlIGN1cnJlbnQgc3RhdGUuXG4gKi9cbnN0YXRlLmxpc3RlblRvKG1lc3NhZ2VzLCAncmVzaXplIHJlZnJlc2gnLCBmdW5jdGlvbiAoKSB7XG4gIGlmIChleGVjVGltZW91dCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaG91bGQgYmUgbW9zdCBwZXJmb3JtYW50IHRvIHV0aWxpemUgdGhlIHJlbmRlciBsb29wLlxuICAgKi9cbiAgZXhlY1RpbWVvdXQgPSBET01CYXJzLlZNLmV4ZWMoZnVuY3Rpb24gKCkge1xuICAgIGV4ZWNUaW1lb3V0ID0gbnVsbDtcblxuICAgIHN0YXRlLnNldCgndmlld3BvcnRXaWR0aCcsICB3aW5kb3cuaW5uZXJXaWR0aCk7XG4gICAgc3RhdGUuc2V0KCd2aWV3cG9ydEhlaWdodCcsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgc3RhdGUuc2V0KCdkb2N1bWVudFdpZHRoJywgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aCk7XG4gICAgc3RhdGUuc2V0KCdkb2N1bWVudEhlaWdodCcsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQpO1xuICB9KTtcbn0pO1xuIiwidmFyIF8gICAgICAgID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIHN0b3JhZ2UgID0gcmVxdWlyZSgnc3RvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG5cbi8qKlxuICogVGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciBhIHN0b3JlIGluc3RhbmNlLlxuICpcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqL1xudmFyIFN0b3JlID0gQmFja2JvbmUuTW9kZWwuZXh0ZW5kKCk7XG5cbi8qKlxuICogU2V0IGFsbCB0aGUgYXR0cmlidXRlcyBmcm9tIGxvY2FsU3RvcmFnZSBvbiBpbml0aWFsaXphdGlvbi5cbiAqL1xuU3RvcmUucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghc3RvcmFnZS5lbmFibGVkKSB7IHJldHVybjsgfVxuXG4gIF8uZWFjaChzdG9yYWdlLmdldEFsbCgpLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgIGlmICghdGhpcy5faXNQZXJzaXN0ZW5jZUtleShrZXkpKSB7IHJldHVybjsgfVxuXG4gICAgdGhpcy5hdHRyaWJ1dGVzW2tleS5zdWJzdHIodGhpcy5fcHJlZml4Lmxlbmd0aCArIDEpXSA9IHZhbHVlO1xuICB9LCB0aGlzKTtcbn07XG5cbi8qKlxuICogVGhlIHByZWZpeCBmb3Igc3RvcmluZyBpbiBsb2NhbFN0b3JhZ2UuXG4gKlxuICogQHR5cGUge1N0cmluZ31cbiAqL1xuU3RvcmUucHJvdG90eXBlLl9wcmVmaXggPSAnc3RvcmUnO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHBlcnNpc3RlbmNlIGtleSBmb3IgbG9jYWxTdG9yYWdlLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30ga2V5XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblN0b3JlLnByb3RvdHlwZS5fcGVyc2lzdGVuY2VLZXkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9wcmVmaXggKyAnLScgKyBrZXk7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlIGEga2V5IGFuZCBjaGVjayBpZiBpdCBpcyBhIHZhbGlkIHBlcnNpc3RlbmNlIGtleSBmb3IgdGhpcyBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICBrZXlcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblN0b3JlLnByb3RvdHlwZS5faXNQZXJzaXN0ZW5jZUtleSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIGtleS5zdWJzdHIoMCwgdGhpcy5fcHJlZml4Lmxlbmd0aCArIDEpID09PSB0aGlzLl9wcmVmaXggKyAnLSc7XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlIGBzZXRgIHRvIGFsc28gc2F2ZSB0byBsb2NhbFN0b3JhZ2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHsqfSAgICAgIHZhbHVlXG4gKi9cblN0b3JlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICB2YXIgYXR0cnM7XG5cbiAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgYXR0cnMgICA9IGtleTtcbiAgICBvcHRpb25zID0gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgKGF0dHJzID0ge30pW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIGlmIChzdG9yYWdlLmVuYWJsZWQpIHtcbiAgICAvLyBDYW4ndCBzZWVtIHRvIGlnbm9yZSB0aGUgSlNIaW50IGBmb3JgIGxvb3AgYm9keSBlcnJvciBoZXJlLCBzbyB0aGlzXG4gICAgLy8gYmVoYXZpb3VyIGlzIGluY29uc2lzdGVudCB3aXRoIGBCYWNrYm9uZS5wcm90b3R5cGUuc2V0YC5cbiAgICBmb3IgKHZhciBhdHRyIGluIGF0dHJzKSB7XG4gICAgICBpZiAoXy5oYXMoYXR0cnMsIGF0dHIpKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBvcHRpb25zICYmIG9wdGlvbnMudW5zZXQgPyAncmVtb3ZlJyA6ICdzZXQnO1xuICAgICAgICBzdG9yYWdlW21ldGhvZF0odGhpcy5fcGVyc2lzdGVuY2VLZXkoYXR0ciksIGF0dHJzW2F0dHJdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gQmFja2JvbmUuTW9kZWwucHJvdG90eXBlLnNldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBPdmVycmlkZSBgY2xlYXJgIHRvIGFsc28gZW1wdHkgbG9jYWxTdG9yYWdlLlxuICovXG5TdG9yZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIENoZWNrIGFsbCB0aGUga2V5cyBpbiBwZXJzaXN0ZW50IHN0b3JlIGFuZCByZW1vdmUga2V5cyBhY3RpdmUgZm9yIHRoaXNcbiAgLy8gaW5zdGFuY2UuXG4gIGlmIChzdG9yYWdlLmVuYWJsZWQpIHtcbiAgICBfLmVhY2goc3RvcmFnZS5nZXRBbGwoKSwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmICh0aGlzLl9pc1BlcnNpc3RlbmNlS2V5KGtleSkpIHtcbiAgICAgICAgc3RvcmFnZS5yZW1vdmUoa2V5KTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgfVxuXG4gIHJldHVybiBCYWNrYm9uZS5Nb2RlbC5wcm90b3R5cGUuY2xlYXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgYHVuc2V0YCB0byBhbHNvIHJlbW92ZSB0aGUga2V5IGZyb20gbG9jYWxTdG9yYWdlLlxuICovXG5TdG9yZS5wcm90b3R5cGUudW5zZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChzdG9yYWdlLmVuYWJsZWQpIHtcbiAgICBzdG9yYWdlLnJlbW92ZSh0aGlzLl9wZXJzaXN0ZW5jZUtleShrZXkpKTtcbiAgfVxuXG4gIHJldHVybiBCYWNrYm9uZS5Nb2RlbC5wcm90b3R5cGUudW5zZXQuY2FsbCh0aGlzLCBrZXkpO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGN1c3RvbSBzdG9yYWdlIHNjaGVtZSBhbmQgYXR0YWNoIHRvIHRoZSByZWd1bGFyIHN0b3JlLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5TdG9yZS5wcm90b3R5cGUuY3VzdG9tU3RvcmUgPSBmdW5jdGlvbiAobmFtZSkge1xuICBpZiAoIV8uaXNTdHJpbmcobmFtZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0N1c3RvbSBzdG9yZXMgcmVxdWlyZSBhIHN0b3JhZ2UgcHJlZml4Jyk7XG4gIH1cblxuICB2YXIgQ3VzdG9tU3RvcmUgPSB0aGlzLmNvbnN0cnVjdG9yLmV4dGVuZCh7XG4gICAgX3ByZWZpeDogbmFtZVxuICB9KTtcblxuICByZXR1cm4gKHRoaXMuXyB8fCAodGhpcy5fID0ge30pKVtuYW1lXSA9IG5ldyBDdXN0b21TdG9yZSgpO1xufTtcblxuLyoqXG4gKiBFeHBvcnQgYSBzdGF0aWMgaW5zdGFuY2Ugb2YgdGhlIHN0b3JlIG1vZGVsLlxuICpcbiAqIEB0eXBlIHtTdG9yZX1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBuZXcgU3RvcmUoKTtcbiIsInZhciBfICAgICAgICA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBET01CYXJzICA9IHJlcXVpcmUoJy4uL2xpYi9kb21iYXJzJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xuXG52YXIgVmlldyAgICAgICAgID0gcmVxdWlyZSgnLi90ZW1wbGF0ZScpO1xudmFyIFNpZGViYXIgICAgICA9IHJlcXVpcmUoJy4vc2lkZWJhcicpO1xudmFyIE5vdGVib29rICAgICA9IHJlcXVpcmUoJy4vbm90ZWJvb2snKTtcbnZhciBFZGl0Tm90ZWJvb2sgPSByZXF1aXJlKCcuL2VkaXQtbm90ZWJvb2snKTtcbnZhciBib3VuY2UgICAgICAgPSByZXF1aXJlKCcuLi9saWIvYm91bmNlJyk7XG52YXIgY29udHJvbHMgICAgID0gcmVxdWlyZSgnLi4vbGliL2NvbnRyb2xzJyk7XG52YXIgc3RhdGUgICAgICAgID0gcmVxdWlyZSgnLi4vc3RhdGUvc3RhdGUnKTtcbnZhciBjb25maWcgICAgICAgPSByZXF1aXJlKCcuLi9zdGF0ZS9jb25maWcnKTtcbnZhciBtZXNzYWdlcyAgICAgPSByZXF1aXJlKCcuLi9zdGF0ZS9tZXNzYWdlcycpO1xudmFyIG1pZGRsZXdhcmUgICA9IHJlcXVpcmUoJy4uL3N0YXRlL21pZGRsZXdhcmUnKTtcbnZhciBwZXJzaXN0ZW5jZSAgPSByZXF1aXJlKCcuLi9zdGF0ZS9wZXJzaXN0ZW5jZScpO1xudmFyIGRvbUxpc3RlbiAgICA9IHJlcXVpcmUoJy4uL2xpYi9kb20tbGlzdGVuJyk7XG52YXIgbm90aWZ5RXJyb3IgID0gcmVxdWlyZSgnLi4vbGliL25vdGlmeS1lcnJvcicpO1xuXG52YXIgRU5URVJfS0VZICAgID0gMTM7XG52YXIgRU1CRURfU0NSSVBUID0ge1wic2NyaXB0XCI6XCJodHRwczovL211bGVzb2Z0LmdpdGh1Yi5pby9hcGktbm90ZWJvb2svc2NyaXB0cy9lbWJlZC5qc1wifS5zY3JpcHQ7XG5cbi8qKlxuICogQ3JlYXRlIGEgY2VudHJhbCBhcHBsaWNhdGlvbiB2aWV3LlxuICpcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqL1xudmFyIEFwcCA9IG1vZHVsZS5leHBvcnRzID0gVmlldy5leHRlbmQoe1xuICBjbGFzc05hbWU6ICdhcHBsaWNhdGlvbidcbn0pO1xuXG4vKipcbiAqIEtlZXAgdHJhY2sgb2YgYWxsIGV2ZW50cyB0aGF0IGNhbiBiZSB0cmlnZ2VyZWQgZnJvbSB0aGUgRE9NLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkFwcC5wcm90b3R5cGUuZXZlbnRzID0ge1xuICAvLyBCbG9jayBjbGlja3Mgb24gYSBkaXNhYmxlZCBidXR0b24uXG4gICdjbGljayAudG9vbGJhci1idXR0b25zIGJ1dHRvbic6IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIG5vZGUgPSBlLnRhcmdldDtcblxuICAgIHdoaWxlIChub2RlLnRhZ05hbWUgIT09ICdCVVRUT04nKSB7XG4gICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIGlmIChub2RlLmNsYXNzTGlzdC5jb250YWlucygnYnRuLWRpc2FibGVkJykpIHtcbiAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICB9LFxuICAnY2xpY2sgLm5vdGVib29rLWhlbHAnOiAgICdzaG93U2hvcnRjdXRzJyxcbiAgJ2NsaWNrIC5ub3RlYm9vay1leGVjJzogICAncnVuTm90ZWJvb2snLFxuICAnY2xpY2sgLm5vdGVib29rLWNsb25lJzogICdjbG9uZU5vdGVib29rJyxcbiAgJ2NsaWNrIC5ub3RlYm9vay1zYXZlJzogICAnc2F2ZU5vdGVib29rJyxcbiAgJ2NsaWNrIC5ub3RlYm9vay1zaGFyZSc6ICAnc2hhcmVOb3RlYm9vaycsXG4gICdjbGljayAudG9nZ2xlLW5vdGVib29rJzogJ3RvZ2dsZVZpZXcnLFxuICAnY2xpY2sgLm5vdGVib29rLW5ldyc6ICAgICduZXdOb3RlYm9vaycsXG4gIC8vIExpc3RlbiBmb3IgYEVudGVyYCBwcmVzc2VzIGFuZCBibHVyIHRoZSBpbnB1dC5cbiAgJ2tleWRvd24gLm5vdGVib29rLXRpdGxlJzogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS53aGljaCAhPT0gRU5URVJfS0VZKSB7IHJldHVybjsgfVxuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGUuc3JjRWxlbWVudC5ibHVyKCk7XG4gIH0sXG4gIC8vIFVwZGF0ZSB0aGUgbm90ZWJvb2sgdGl0bGUgb24gYmx1ciB0byBhdm9pZCBtdWx0aXBsZSBwZXJzaXN0ZW5jZSBhdHRlbXB0cy5cbiAgJ2ZvY3Vzb3V0IC5ub3RlYm9vay10aXRsZSc6IGZ1bmN0aW9uIChlKSB7XG4gICAgcGVyc2lzdGVuY2UuZ2V0KCdub3RlYm9vaycpLmdldCgnbWV0YScpLnNldCgndGl0bGUnLCBlLnRhcmdldC52YWx1ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogUnVucyB3aGVuIHdlIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGUgYXBwbGljYXRpb25zLiBTdGFydHMgbGlzdGVuaW5nIGZvclxuICogcmVsZXZhbnQgZXZlbnRzIHRvIHJlc3BvbmQgdG8uXG4gKi9cbkFwcC5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIHZhciBtb2RlbCA9IHBlcnNpc3RlbmNlLmdldCgnbm90ZWJvb2snKTtcblxuICAvLyBTZXQgYSBzaWRlYmFyIGluc3RhbmNlIHRvIHJlbmRlci5cbiAgdGhpcy5kYXRhLnNldCgnc2lkZWJhcicsIG5ldyBTaWRlYmFyKCkpO1xuICB0aGlzLmRhdGEuc2V0KCdhY3RpdmVWaWV3JywgJ3ZpZXcnKTtcblxuICAvKipcbiAgICogQmxvY2sgYXR0ZW1wdHMgdG8gY2xvc2UgdGhlIHdpbmRvdyB3aGVuIHRoZSBwZXJzaXN0ZW5jZSBzdGF0ZSBpcyBkaXJ0eS5cbiAgICovXG4gIHRoaXMubGlzdGVuVG8oZG9tTGlzdGVuKHdpbmRvdyksICdiZWZvcmV1bmxvYWQnLCBmdW5jdGlvbiAoZSkge1xuICAgIGlmICghY29uZmlnLmdldCgnc2F2YWJsZScpIHx8IHBlcnNpc3RlbmNlLmlzQ3VycmVudFNhdmVkKCkpIHsgcmV0dXJuOyB9XG5cbiAgICByZXR1cm4gKGUgfHwgd2luZG93LmV2ZW50KS5yZXR1cm5WYWx1ZSA9ICdZb3VyIGNoYW5nZXMgd2lsbCBiZSBsb3N0Lic7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZS1yZW5kZXIgdGhlIG5vdGVib29rIHdoZW4gdGhlIG5vdGVib29rIGNoYW5nZXMuXG4gICAqL1xuICB0aGlzLmxpc3RlblRvKHBlcnNpc3RlbmNlLCAnY2hhbmdlTm90ZWJvb2snLCB0aGlzLnJlbmRlclZpZXcpO1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgdXNlciBzdGF0ZSBkYXRhIHdoZW4gdGhlIHVzZXIgY2hhbmdlcy5cbiAgICovXG4gIHRoaXMubGlzdGVuVG8ocGVyc2lzdGVuY2UsICdjaGFuZ2VVc2VyIGNoYW5nZU5vdGVib29rJywgYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FuU2F2ZSA9IGNvbmZpZy5nZXQoJ3NhdmFibGUnKTtcbiAgICB2YXIgaXNPd25lciA9IHBlcnNpc3RlbmNlLmlzQ3VycmVudE93bmVyKCk7XG5cbiAgICB0aGlzLmRhdGEuc2V0KCdvd25lcicsICAgICAgICAgaXNPd25lcik7XG4gICAgdGhpcy5kYXRhLnNldCgnc2F2YWJsZScsICAgICAgIGNhblNhdmUgJiYgaXNPd25lcik7XG4gICAgdGhpcy5kYXRhLnNldCgnYXV0aGVudGljYXRlZCcsIHBlcnNpc3RlbmNlLmlzQXV0aGVudGljYXRlZCgpKTtcbiAgfSwgdGhpcykpO1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHNhdmVkIHZpZXcgc3RhdGUgd2hlbiB0aGUgaWQgY2hhbmdlcy5cbiAgICovXG4gIHRoaXMubGlzdGVuVG8ocGVyc2lzdGVuY2UsICdjaGFuZ2U6bm90ZWJvb2snLCBib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc3RvcExpc3RlbmluZyhtb2RlbCwgJ2NoYW5nZTppZCcpO1xuICAgIHRoaXMuc3RvcExpc3RlbmluZyhtb2RlbC5nZXQoJ21ldGEnKSwgJ2NoYW5nZTp0aXRsZScpO1xuXG4gICAgLy8gVXBkYXRlIG1vZGVsIHJlZmVyZW5jZS5cbiAgICBtb2RlbCA9IHBlcnNpc3RlbmNlLmdldCgnbm90ZWJvb2snKTtcblxuICAgIHRoaXMubGlzdGVuVG8obW9kZWwsICdjaGFuZ2U6aWQnLCBib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNhblNhdmUgPSBjb25maWcuZ2V0KCdzYXZhYmxlJyk7XG4gICAgICB2YXIgaXNOZXcgICA9IHBlcnNpc3RlbmNlLmlzTmV3KG1vZGVsKTtcblxuICAgICAgdGhpcy5kYXRhLnNldCgnc2hhcmVhYmxlJywgIWlzTmV3KTtcbiAgICAgIHRoaXMuZGF0YS5zZXQoJ2Nsb25lYWJsZScsIGNhblNhdmUgJiYgIWlzTmV3KTtcbiAgICB9LCB0aGlzKSk7XG5cbiAgICAvLyBVcGRhdGUgdGhlIHRpdGxlIHdoZW4gdGhlIGN1cnJlbnQgbm90ZWJvb2sgdXBkYXRlcy5cbiAgICB0aGlzLmxpc3RlblRvKG1vZGVsLmdldCgnbWV0YScpLCAnY2hhbmdlOnRpdGxlJywgYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aXRsZSAgID0gbW9kZWwuZ2V0KCdtZXRhJykuZ2V0KCd0aXRsZScpO1xuICAgICAgdmFyIHRpdGxlRWwgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5ub3RlYm9vay10aXRsZScpO1xuXG4gICAgICBpZiAodGl0bGVFbCkge1xuICAgICAgICB0aXRsZUVsLnZhbHVlID0gdGl0bGU7XG4gICAgICB9XG5cbiAgICAgIGRvY3VtZW50LnRpdGxlID0gdGl0bGUgPyB0aXRsZSArICcg4oCiIE5vdGVib29rJyA6ICdOb3RlYm9vayc7XG4gICAgfSwgdGhpcykpO1xuICB9LCB0aGlzKSk7XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBzdGF0ZSB2YXJpYWJsZXMgd2hlbiB0aGUgcGVyc2lzdGVuY2Ugc3RhdGUgY2hhbmdlcy5cbiAgICovXG4gIHRoaXMubGlzdGVuVG8ocGVyc2lzdGVuY2UsICdjaGFuZ2U6c3RhdGUnLCBib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgIHZhciB0aW1lc3RhbXAgICAgPSBuZXcgRGF0ZSgpLnRvTG9jYWxlVGltZVN0cmluZygpO1xuICAgIHZhciBpc05ldyAgICAgICAgPSBwZXJzaXN0ZW5jZS5pc0N1cnJlbnROZXcoKTtcbiAgICB2YXIgY3VycmVudFN0YXRlID0gcGVyc2lzdGVuY2UuZ2V0KCdzdGF0ZScpO1xuICAgIHZhciBjYW5TYXZlICAgICAgPSBjb25maWcuZ2V0KCdzYXZhYmxlJyk7XG5cbiAgICB2YXIgc3RhdGVzID0ge1xuICAgICAgMTogJ1NhdmluZycsXG4gICAgICAyOiAnTG9hZGluZycsXG4gICAgICAzOiAnU2F2ZSBmYWlsZWQnLFxuICAgICAgNDogaXNOZXcgPyAnJyA6ICdTYXZlZCAnICsgdGltZXN0YW1wLFxuICAgICAgNTogJ0xvYWQgRmFpbGVkJyxcbiAgICAgIDY6IGlzTmV3ID8gJycgOiAnTG9hZGVkICcgKyB0aW1lc3RhbXAsXG4gICAgICA3OiBjYW5TYXZlID8gJ1Vuc2F2ZWQgY2hhbmdlcycgOiAnJywgLy8gQXZvaWQgZGlzcGxheWluZyB3aGVuIGltcG9zc2libGUuXG4gICAgICA4OiAnQ2xvbmluZyBub3RlYm9vaydcbiAgICB9O1xuXG4gICAgaWYgKGN1cnJlbnRTdGF0ZSA9PT0gNSkge1xuICAgICAgbWlkZGxld2FyZS50cmlnZ2VyKCd1aTpub3RpZnknLCB7XG4gICAgICAgIHRpdGxlOiAnTG9hZCBmYWlsZWQhJyxcbiAgICAgICAgbWVzc2FnZTogJ0NvdWxkIG5vdCBsb2FkIHRoZSBub3RlYm9vaydcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0YXRlLnNldCgnbG9hZGluZycsICAgICAgIGN1cnJlbnRTdGF0ZSA9PT0gMik7XG4gICAgdGhpcy5kYXRhLnNldCgnc3RhdGVUZXh0Jywgc3RhdGVzW2N1cnJlbnRTdGF0ZV0pO1xuICB9LCB0aGlzKSk7XG5cbiAgLyoqXG4gICAqIEFkZCBvciByZW1vdmUgYSBmb290ZXIgY2xhc3MgZGVwZW5kaW5nIG9uIHZpc2liaWxpdHkuXG4gICAqL1xuICB0aGlzLmxpc3RlblRvKGNvbmZpZywgJ2NoYW5nZTpoZWFkZXInLCBib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgIHZhciBoYXMgPSBjb25maWcuZ2V0KCdoZWFkZXInKTtcbiAgICB0aGlzLmVsLmNsYXNzTGlzdFtoYXMgPyAnYWRkJyA6ICdyZW1vdmUnXSgnYXBwbGljYXRpb24taGFzLWhlYWRlcicpO1xuICB9LCB0aGlzKSk7XG5cbiAgLyoqXG4gICAqIEFkZCBvciByZW1vdmUgYSBmb290ZXIgY2xhc3MgZGVwZW5kaW5nIG9uIHZpc2liaWxpdHkuXG4gICAqL1xuICB0aGlzLmxpc3RlblRvKGNvbmZpZywgJ2NoYW5nZTpmb290ZXInLCBib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgIHZhciBoYXMgPSBjb25maWcuZ2V0KCdmb290ZXInKTtcbiAgICB0aGlzLmVsLmNsYXNzTGlzdFtoYXMgPyAnYWRkJyA6ICdyZW1vdmUnXSgnYXBwbGljYXRpb24taGFzLWZvb3RlcicpO1xuICB9LCB0aGlzKSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFByZWNvbXBpbGUgdGhlIGFwcGxpY3Rpb24gdGVtcGxhdGUuXG4gKlxuICogQHR5cGUge0Z1bmN0aW9ufVxuICovXG5BcHAucHJvdG90eXBlLnRlbXBsYXRlID0gcmVxdWlyZSgnLi4vLi4vdGVtcGxhdGVzL3ZpZXdzL2FwcC5oYnMnKTtcblxuLyoqXG4gKiBSZW5kZXIgdGhlIGN1cnJlbnQgdmlldy5cbiAqL1xuQXBwLnByb3RvdHlwZS5yZW5kZXJWaWV3ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdmlldyAgID0gdGhpcy5kYXRhLmdldCgnYWN0aXZlVmlldycpO1xuICB2YXIgbWV0aG9kID0gKHZpZXcgPT09ICd2aWV3JyA/ICdzaG93Tm90ZWJvb2snIDogJ3Nob3dFZGl0b3InKTtcblxuICByZXR1cm4gdGhpc1ttZXRob2RdKCk7XG59O1xuXG4vKipcbiAqIFJlbmRlciB0aGUgc3RhbmRhcmQgbm90ZWJvb2sgdmlldy5cbiAqL1xuQXBwLnByb3RvdHlwZS5zaG93Tm90ZWJvb2sgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZGF0YS5zZXQoJ25vdGVib29rJywgbmV3IE5vdGVib29rKHtcbiAgICBtb2RlbDogcGVyc2lzdGVuY2UuZ2V0KCdub3RlYm9vaycpXG4gIH0pKTtcblxuICB0aGlzLmRhdGEuc2V0KCdhY3RpdmVWaWV3JywgJ3ZpZXcnKTtcbiAgRE9NQmFycy5WTS5leGVjKF8uYmluZChtZXNzYWdlcy50cmlnZ2VyLCBtZXNzYWdlcywgJ3JlZnJlc2gnKSk7XG59O1xuXG4vKipcbiAqIFJlbmRlciB0aGUgbm90ZWJvb2sgcmF3IHNvdXJjZSBlZGl0b3IuXG4gKi9cbkFwcC5wcm90b3R5cGUuc2hvd0VkaXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5kYXRhLnNldCgnbm90ZWJvb2snLCBuZXcgRWRpdE5vdGVib29rKHtcbiAgICBtb2RlbDogcGVyc2lzdGVuY2UuZ2V0KCdub3RlYm9vaycpXG4gIH0pKTtcblxuICB0aGlzLmRhdGEuc2V0KCdhY3RpdmVWaWV3JywgJ2VkaXQnKTtcbiAgRE9NQmFycy5WTS5leGVjKF8uYmluZChtZXNzYWdlcy50cmlnZ2VyLCBtZXNzYWdlcywgJ3JlZnJlc2gnKSk7XG59O1xuXG4vKipcbiAqIFRvZ2dsZSB0aGUgdmlldyBiZXR3ZWVuIGVkaXQgYW5kIG5vdGVib29rIHZpZXcuXG4gKi9cbkFwcC5wcm90b3R5cGUudG9nZ2xlVmlldyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gU2V0IHRoZSBvcHBvc2l0ZSB2aWV3IHRvIGFjdGl2ZS5cbiAgdmFyIHZpZXcgPSB0aGlzLmRhdGEuZ2V0KCdhY3RpdmVWaWV3Jyk7XG4gIHRoaXMuZGF0YS5zZXQoJ2FjdGl2ZVZpZXcnLCB2aWV3ID09PSAndmlldycgPyAnZWRpdCcgOiAndmlldycpO1xuXG4gIHJldHVybiB0aGlzLnJlbmRlclZpZXcoKTtcbn07XG5cbi8qKlxuICogU2hvd3MgdGhlIHNob3J0Y3V0IG1vZGFsLlxuICovXG5BcHAucHJvdG90eXBlLnNob3dTaG9ydGN1dHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhbGxDb250cm9scyA9IGNvbnRyb2xzLmVkaXRvci5jb25jYXQoY29udHJvbHMuY29kZSkuY29uY2F0KGNvbnRyb2xzLnRleHQpO1xuXG4gIG1pZGRsZXdhcmUudHJpZ2dlcigndWk6bW9kYWwnLCB7XG4gICAgdGl0bGU6ICdLZXlib2FyZCBTaG9ydGN1dHMnLFxuICAgIGNvbnRlbnQ6IFtcbiAgICAgICc8dGFibGUgY2xhc3M9XCJjb250cm9scy10YWJsZVwiPicgK1xuICAgICAgICAnPGNvbGdyb3VwPicgK1xuICAgICAgICAgICc8Y29sIGNsYXNzPVwiY29udHJvbHMtY29sLW1pbmlcIj4nICtcbiAgICAgICAgICAnPGNvbCBjbGFzcz1cImNvbnRyb2xzLWNvbC1sYXJnZVwiPicgK1xuICAgICAgICAnPC9jb2xncm91cD4nICtcbiAgICAgICAgJzx0cj4nICtcbiAgICAgICAgICAnPHRoPktleSBDb21iaW5hdGlvbjwvdGg+JyArXG4gICAgICAgICAgJzx0aD5BY3Rpb248L3RoPicgK1xuICAgICAgICAnPC90cj4nICtcbiAgICAgICAgXy5tYXAoYWxsQ29udHJvbHMsIGZ1bmN0aW9uIChjb250cm9sKSB7XG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICc8dHI+JyxcbiAgICAgICAgICAgICc8dGQ+JyArIChjb250cm9sLmtleUNvZGUgfHwgY29udHJvbC5zaG9ydGN1dCkgKyAnPC90ZD4nLFxuICAgICAgICAgICAgJzx0ZD4nICsgY29udHJvbC5kZXNjcmlwdGlvbiArICc8L3RkPicsXG4gICAgICAgICAgICAnPC90cj4nXG4gICAgICAgICAgXS5qb2luKCdcXG4nKTtcbiAgICAgICAgfSkuam9pbignXFxuJykgK1xuICAgICAgJzwvdGFibGU+J1xuICAgIF0uam9pbignXFxuJylcbiAgfSk7XG59O1xuXG4vKipcbiAqIEFwcGVuZCB0aGUgYXBwbGljYXRpb24gdmlldyB0byBhbiBlbGVtZW50LlxuICpcbiAqIEByZXR1cm4ge0FwcH1cbiAqL1xuQXBwLnByb3RvdHlwZS5hcHBlbmRUbyA9IGZ1bmN0aW9uICgpIHtcbiAgVmlldy5wcm90b3R5cGUuYXBwZW5kVG8uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgdGhpcy5yZW5kZXJWaWV3KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSdW5zIHRoZSBlbnRpcmUgbm90ZWJvb2sgc2VxdWVudGlhbGx5LlxuICovXG5BcHAucHJvdG90eXBlLnJ1bk5vdGVib29rID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5kYXRhLmdldCgnbm90ZWJvb2snKS5leGVjdXRlKCk7XG59O1xuXG4vKipcbiAqIENsb25lIHRoZSBjdXJyZW50IG5vdGVib29rIGluLW1lbW9yeS5cbiAqL1xuQXBwLnByb3RvdHlwZS5jbG9uZU5vdGVib29rID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gcGVyc2lzdGVuY2UuY2xvbmUobm90aWZ5RXJyb3IoJ0NvdWxkIG5vdCBjbG9uZSBub3RlYm9vaycpKTtcbn07XG5cbi8qKlxuICogTWFudWFsbHkgYXR0ZW1wdCB0byBzYXZlIHRoZSBub3RlYm9vay5cbiAqL1xuQXBwLnByb3RvdHlwZS5zYXZlTm90ZWJvb2sgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBwZXJzaXN0ZW5jZS5zYXZlKFxuICAgIHBlcnNpc3RlbmNlLmdldCgnbm90ZWJvb2snKSwgbm90aWZ5RXJyb3IoJ0NvdWxkIG5vdCBzYXZlIG5vdGVib29rJylcbiAgKTtcbn07XG5cbi8qKlxuICogTWFudWFsbHkgY3JlYXRlIGEgbmV3IG5vdGVib29rIGluc3RhbmNlLiBCZWZvcmUgd2UgZGlzY2FyZCBhbnkgY3VycmVudFxuICogY2hhbmdlcywgY2hlY2sgd2l0aCB0aGUgdXNlci5cbiAqL1xuQXBwLnByb3RvdHlwZS5uZXdOb3RlYm9vayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5ld05vdGVib29rID0gZnVuY3Rpb24gKGVyciwgY29uZmlybWVkKSB7XG4gICAgaWYgKGVyciB8fCAhY29uZmlybWVkKSB7IHJldHVybjsgfVxuXG4gICAgcmV0dXJuIHBlcnNpc3RlbmNlLm5ldyhub3RpZnlFcnJvcignQ291bGQgbm90IGNyZWF0ZSBuZXcgbm90ZWJvb2snKSk7XG4gIH07XG5cbiAgLy8gSWYgdGhlIGN1cnJlbnQgbm90ZWJvb2sgaXMgYWxyZWFkeSBzYXZlZCwgaW1tZWRpYXRlbHkgcmVsb2FkLlxuICBpZiAocGVyc2lzdGVuY2UuaXNDdXJyZW50U2F2ZWQoKSkge1xuICAgIHJldHVybiBuZXdOb3RlYm9vayhudWxsLCB0cnVlKTtcbiAgfVxuXG4gIC8vIENvbmZpcm0gd2l0aCB0aGUgdXNlciB0aGF0IHRoaXMgaXMgdGhlIGFjdGlvbiB0aGV5IHdhbnQgdG8gZG8uXG4gIHJldHVybiBtaWRkbGV3YXJlLnRyaWdnZXIoJ3VpOmNvbmZpcm0nLCB7XG4gICAgdGl0bGU6ICdZb3UgaGF2ZSB1bnNhdmVkIGNoYW5nZXMuIEFiYW5kb24gY2hhbmdlcz8nLFxuICAgIGNvbnRlbnQ6ICc8cD4nICtcbiAgICAgICdTYXZlIHlvdXIgd29yayBieSBwcmVzc2luZyBcXCdDYW5jZWxcXCcgYW5kICcgK1xuICAgICAgJ3RoZW4gY2xpY2tpbmcgdGhlIHNhdmUgaWNvbiBpbiB0aGUgdG9vbGJhciBvciB1c2luZyAnICtcbiAgICAgICd0aGUga2V5c3Ryb2tlIENNRCArIFMgKG9yIENUUkwgKyBTKS4nICtcbiAgICAgICc8L3A+JyArXG4gICAgICAnPHA+JyArXG4gICAgICAnUHJlc3MgXFwnT0tcXCcgdG8gYWJhbmRvbiB0aGlzIG5vdGVib29rLiAnICtcbiAgICAgICdZb3VyIGNoYW5nZXMgd2lsbCBiZSBsb3N0LicgK1xuICAgICAgJzwvcD4nXG4gIH0sIG5ld05vdGVib29rKTtcbn07XG5cbi8qKlxuICogU2hhcmUgdGhlIG5vdGVib29rIGluc2lkZSBhIG1vZGFsIGRpc3BsYXkuXG4gKi9cbkFwcC5wcm90b3R5cGUuc2hhcmVOb3RlYm9vayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGlkICAgICAgICAgID0gcGVyc2lzdGVuY2UuZ2V0KCdub3RlYm9vaycpLmdldCgnaWQnKTtcbiAgdmFyIHNoYXJlU2NyaXB0ID0gJzxzY3JpcHQgc3JjPVwiJyArIEVNQkVEX1NDUklQVCArICdcIiBkYXRhLW5vdGVib29rJyArXG4gICAgKGlkID8gJyBkYXRhLWlkPVwiJyArIGlkICsgJ1wiJyA6ICcnKSArICc+PC9zY3JpcHQ+JztcblxuICBtaWRkbGV3YXJlLnRyaWdnZXIoJ3VpOm1vZGFsJywge1xuICAgIHRpdGxlOiAnU2hhcmUgTm90ZWJvb2snLFxuICAgIGNvbnRlbnQ6ICc8cCBjbGFzcz1cIm5vdGVib29rLXNoYXJlLWFib3V0XCI+Q29weSB0aGlzIGNvZGUgdG8gZW1iZWQuPC9wPicgK1xuICAgICAgJzxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCI+JyArXG4gICAgICAnPGlucHV0IGNsYXNzPVwibm90ZWJvb2stc2hhcmUtaW5wdXQgaXRlbS1zaGFyZVwiICcgK1xuICAgICAgJ3ZhbHVlPVwiJyArIF8uZXNjYXBlKHNoYXJlU2NyaXB0KSArICdcIiByZWFkb25seT4nICtcbiAgICAgICc8cCBjbGFzcz1cIm5vdGVib29rLXNoYXJlLWFib3V0XCI+Q29weSB0aGlzIGxpbmsgdG8gc2hhcmUuPC9wPicgK1xuICAgICAgJzxpbnB1dCBjbGFzcz1cIm5vdGVib29rLXNoYXJlLWlucHV0IGl0ZW0tc2hhcmVcIiAnICtcbiAgICAgICd2YWx1ZT1cIicgKyBjb25maWcuZ2V0KCd1cmwnKSArICdcIiByZWFkb25seT4nICtcbiAgICAgICc8L2Rpdj4nLFxuICAgIHNob3c6IGZ1bmN0aW9uIChtb2RhbCkge1xuICAgICAgQmFja2JvbmUuJChtb2RhbC5lbCkub24oJ2NsaWNrJywgJy5ub3RlYm9vay1zaGFyZS1pbnB1dCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUudGFyZ2V0LnNlbGVjdCgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn07XG4iLCJ2YXIgXyAgICAgICAgID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIFZpZXcgICAgICA9IHJlcXVpcmUoJy4vdGVtcGxhdGUnKTtcbnZhciB0ZW1wbGF0ZSAgPSByZXF1aXJlKCcuLi8uLi90ZW1wbGF0ZXMvdmlld3MvY2VsbC1idXR0b25zLmhicycpO1xudmFyIGRvbUxpc3RlbiA9IHJlcXVpcmUoJy4uL2xpYi9kb20tbGlzdGVuJyk7XG5cbi8qKlxuICogRGlzcGxheXMgdGhlIGNlbGwgY29udHJvbHMgb3ZlcmxheSBtZW51LlxuICpcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqL1xudmFyIEJ1dHRvbnNWaWV3ID0gbW9kdWxlLmV4cG9ydHMgPSBWaWV3LmV4dGVuZCh7XG4gIGNsYXNzTmFtZTogJ2NlbGwtYnV0dG9ucycsXG4gIGV2ZW50czoge1xuICAgICdjbGljayAuYWN0aW9uJzogJ29uQ2xpY2snXG4gIH1cbn0pO1xuXG4vKipcbiAqIEtlZXAgYW4gYXJyYXkgb2YgY29udHJvbHMgdG8gZGlzcGxheS5cbiAqXG4gKiBAdHlwZSB7QXJyYXl9XG4gKi9cbkJ1dHRvbnNWaWV3LmNvbnRyb2xzID0gW107XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgYnV0dG9ucyB2aWV3LlxuICovXG5CdXR0b25zVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5saXN0ZW5Ubyhkb21MaXN0ZW4oZG9jdW1lbnQpLCAnbW91c2Vtb3ZlJywgXy50aHJvdHRsZShmdW5jdGlvbiAoZSkge1xuICAgIC8vIEF2b2lkIHJlbW92aW5nIHRoZSBidXR0b25zIHdoZW4gbW92aW5nIHRoZSBtb3VzZSBpbnNpZGUgaXRzZWxmLlxuICAgIGlmICh0aGlzLmVsLmNvbnRhaW5zKGUudGFyZ2V0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnJlbW92ZSgpO1xuICB9LCAxMCkpO1xuXG4gIHJldHVybiBWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIFJlcXVpcmUgdGhlIGJ1dHRvbnMgdGVtcGxhdGUuXG4gKlxuICogQHR5cGUge0Z1bmN0aW9ufVxuICovXG5CdXR0b25zVmlldy5wcm90b3R5cGUudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcblxuLyoqXG4gKiBFdmVudCBoYW5kbGVyIGZvciBjbGlja3Mgb24gY29udHJvbCBidXR0b25zLiBQYXNzIHRocnUgZm9yIGNsaWNrcyBvbiB0aGVcbiAqIHBhcmVudCBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBlIFRoZSBub3JtYWxpemVkIGV2ZW50IG9iamVjdC5cbiAqL1xuQnV0dG9uc1ZpZXcucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgdGhpcy50cmlnZ2VyKCdhY3Rpb24nLCB0aGlzLCBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYWN0aW9uJykpO1xuICB0aGlzLnJlbW92ZSgpO1xufTtcblxuLyoqXG4gKiBQdXNoIHNvbWUgaW5pdGlhbCBjb250cm9scyBpbnRvIHRoZSB2aWV3LlxuICovXG5CdXR0b25zVmlldy5jb250cm9scy5wdXNoKHtcbiAgbGFiZWw6ICdJbnNlcnQgVGV4dCBDZWxsJyxcbiAgY29tbWFuZDogJ25ld1RleHQnXG59LCB7XG4gIGxhYmVsOiAnSW5zZXJ0IENvZGUgQ2VsbCcsXG4gIGNvbW1hbmQ6ICduZXdDb2RlJ1xufSk7XG4iLCJ2YXIgXyAgICAgICAgICA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBWaWV3ICAgICAgID0gcmVxdWlyZSgnLi90ZW1wbGF0ZScpO1xudmFyIHRlbXBsYXRlICAgPSByZXF1aXJlKCcuLi8uLi90ZW1wbGF0ZXMvdmlld3MvY2VsbC1jb250cm9scy5oYnMnKTtcbnZhciBtaWRkbGV3YXJlID0gcmVxdWlyZSgnLi4vc3RhdGUvbWlkZGxld2FyZScpO1xudmFyIGRvbUxpc3RlbiAgPSByZXF1aXJlKCcuLi9saWIvZG9tLWxpc3RlbicpO1xuXG4vKipcbiAqIERpc3BsYXlzIHRoZSBjZWxsIGNvbnRyb2xzIG92ZXJsYXkgbWVudS5cbiAqXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKi9cbnZhciBDb250cm9sc1ZpZXcgPSBtb2R1bGUuZXhwb3J0cyA9IFZpZXcuZXh0ZW5kKHtcbiAgY2xhc3NOYW1lOiAnY2VsbC1jb250cm9scycsXG4gIGV2ZW50czoge1xuICAgICdtb3VzZWRvd24gLmFjdGlvbic6ICAnb25DbGljaycsXG4gICAgJ3RvdWNoc3RhcnQgLmFjdGlvbic6ICdvbkNsaWNrJ1xuICB9XG59KTtcblxuLyoqXG4gKiBDb250cm9scyB2aWV3IHRlbXBsYXRlLlxuICpcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqL1xuQ29udHJvbHNWaWV3LnByb3RvdHlwZS50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuXG4vKipcbiAqIFJlbmRlciB0aGUgY29udHJvbHMgb3ZlcmxheS5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICAgIGNvbnRyb2xzXG4gKiBAcmV0dXJuIHtDb250cm9sc1ZpZXd9XG4gKi9cbkNvbnRyb2xzVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGNvbnRyb2xzKSB7XG4gIC8vIFNldCB0aGUgY29udHJvbHMgdG8gYmUgcmVuZGVyZWQgaW4gdGhlIHRlbXBsYXRlLlxuICB0aGlzLmRhdGEuc2V0KCdjb250cm9scycsIGNvbnRyb2xzIHx8IFtdKTtcblxuICBWaWV3LnByb3RvdHlwZS5yZW5kZXIuY2FsbCh0aGlzKTtcblxuICAvLyBBbnkgZXZlbnRzIG9uIHRoZSBkb2N1bWVudCB2aWV3IHNob3VsZCBjYXVzZSBmb2N1cyB0byBiZSBsb3N0LlxuICB0aGlzLmxpc3RlblRvKGRvbUxpc3Rlbihkb2N1bWVudCksICdtb3VzZWRvd24nLCAgdGhpcy5yZW1vdmUpO1xuICB0aGlzLmxpc3RlblRvKGRvbUxpc3Rlbihkb2N1bWVudCksICd0b3VjaHN0YXJ0JywgdGhpcy5yZW1vdmUpO1xuXG4gIHZhciBrZXlkb3duTWlkZGxld2FyZSA9IG1pZGRsZXdhcmUucmVnaXN0ZXIoXG4gICAgJ2tleWRvd246RXNjJywgXy5iaW5kKGZ1bmN0aW9uIChldmVudCwgbmV4dCwgZG9uZSkge1xuICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgIHJldHVybiBkb25lKCk7XG4gICAgfSwgdGhpcylcbiAgKTtcblxuICB0aGlzLmxpc3RlblRvKHRoaXMsICdyZW1vdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgbWlkZGxld2FyZS5kZXJlZ2lzdGVyKCdrZXlkb3duOkVzYycsIGtleWRvd25NaWRkbGV3YXJlKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEV2ZW50IGhhbmRsZXIgZm9yIGNsaWNrcyBvbiBjb250cm9sIGJ1dHRvbnMuIFBhc3MgdGhydSBmb3IgY2xpY2tzIG9uIHRoZVxuICogcGFyZW50IGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGUgVGhlIG5vcm1hbGl6ZWQgZXZlbnQgb2JqZWN0LlxuICovXG5Db250cm9sc1ZpZXcucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuICB2YXIgbm9kZSA9IGUudGFyZ2V0O1xuXG4gIHdoaWxlICghbm9kZS5oYXNBdHRyaWJ1dGUoJ2RhdGEtYWN0aW9uJykpIHtcbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICB9XG5cbiAgdGhpcy50cmlnZ2VyKCdhY3Rpb24nLCB0aGlzLCBub2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1hY3Rpb24nKSk7XG4gIHJldHVybiB0aGlzLnJlbW92ZSgpO1xufTtcbiIsInZhciBfICAgICAgICAgID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIERPTUJhcnMgICAgPSByZXF1aXJlKCcuLi9saWIvZG9tYmFycycpO1xudmFyIEVkaXRvckNlbGwgPSByZXF1aXJlKCcuL2VkaXRvci1jZWxsJyk7XG52YXIgUmVzdWx0Q2VsbCA9IHJlcXVpcmUoJy4vcmVzdWx0LWNlbGwnKTtcbnZhciBDb21wbGV0aW9uID0gcmVxdWlyZSgnLi4vbGliL2NvbXBsZXRpb24nKTtcbnZhciBleHRyYUtleXMgID0gcmVxdWlyZSgnLi9saWIvZXh0cmEta2V5cycpO1xudmFyIGNvbnRyb2xzICAgPSByZXF1aXJlKCcuLi9saWIvY29udHJvbHMnKS5jb2RlO1xudmFyIGNvbmZpZyAgICAgPSByZXF1aXJlKCcuLi9zdGF0ZS9jb25maWcnKTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGNvZGUgY2VsbCB2aWV3LlxuICpcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqL1xudmFyIENvZGVDZWxsID0gbW9kdWxlLmV4cG9ydHMgPSBFZGl0b3JDZWxsLmV4dGVuZCh7XG4gIGNsYXNzTmFtZTogJ2NlbGwgY2VsbC1jb2RlJ1xufSk7XG5cbi8qKlxuICogUnVucyB3aGVuIHRoZSBjb2RlIGNlbGwgaXMgaW5pdGlhbGl6ZWQuXG4gKi9cbkNvZGVDZWxsLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xuICBFZGl0b3JDZWxsLnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgdGhpcy5saXN0ZW5Ubyhjb25maWcsICdjb2RlUmVhZE9ubHknLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kYXRhLnNldCgncmVhZE9ubHknLCBjb25maWcuZ2V0KCdjb2RlUmVhZE9ubHknKSk7XG4gICAgdGhpcy5yZW5kZXJFZGl0b3IoKTtcbiAgfSk7XG5cbiAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCAnY2hhbmdlOmlzRXJyb3InLCBmdW5jdGlvbiAobW9kZWwsIGlzRXJyb3IpIHtcbiAgICB0aGlzLmVsLmNsYXNzTGlzdFtpc0Vycm9yID8gJ2FkZCcgOiAncmVtb3ZlJ10oJ2NlbGwtY29kZS1lcnJvcicpO1xuICB9KTtcblxuICAvLyBTZXQgYSBzdGF0aWMgcmVzdWx0IGNlbGwgaW5zdGFuY2UuXG4gIHRoaXMucmVzdWx0Q2VsbCA9IG5ldyBSZXN1bHRDZWxsKHsgbW9kZWw6IHRoaXMubW9kZWwgfSk7XG59O1xuXG4vKipcbiAqIERlZmF1bHQgY2VsbCBtb2RlbCBhdHRyaWJ1dGVzLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkNvZGVDZWxsLnByb3RvdHlwZS5jZWxsQXR0cmlidXRlcyA9IHtcbiAgdHlwZTogJ2NvZGUnXG59O1xuXG4vKipcbiAqIE1lcmdlIHRoZSBlZGl0b3IgY2VsbCB0ZW1wbGF0ZSB3aXRoIHRoZSBjb2RlIGNlbGwuXG4gKlxuICogQHR5cGUge0Z1bmN0aW9ufVxuICovXG5Db2RlQ2VsbC5wcm90b3R5cGUudGVtcGxhdGUgPSBET01CYXJzLlV0aWxzLm1lcmdlVGVtcGxhdGVzKFxuICBFZGl0b3JDZWxsLnByb3RvdHlwZS50ZW1wbGF0ZSwgcmVxdWlyZSgnLi4vLi4vdGVtcGxhdGVzL3ZpZXdzL2NvZGUtY2VsbC5oYnMnKVxuKTtcblxuLyoqXG4gKiBFeHRlbmQgdGhlIGVkaXRvciBjZWxsIHdpdGggYW4gZXZlbnQgZm9yIHRyaWdnZXJpbmcgZXhlY3V0ZS5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5Db2RlQ2VsbC5wcm90b3R5cGUuZXZlbnRzID0gXy5leHRlbmQoe1xuICAnY2xpY2sgLmNlbGwtZXhlY3V0ZSc6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5leGVjdXRlKCk7XG4gIH1cbn0sIEVkaXRvckNlbGwucHJvdG90eXBlLmV2ZW50cyk7XG5cbi8qKlxuICogRXh0ZW5kIHRoZSBlZGl0b3IgY2VsbCBjb250cm9scyB3aXRoIGN1c3RvbSBjb250cm9scy5cbiAqXG4gKiBAdHlwZSB7QXJyYXl9XG4gKi9cbkNvZGVDZWxsLnByb3RvdHlwZS5jZWxsQ29udHJvbHMgPSBfLmV4dGVuZChcbiAgW10sIEVkaXRvckNlbGwucHJvdG90eXBlLmNlbGxDb250cm9sc1xuKTtcblxuLy8gUHVzaCB0aGUgZXhlY3V0ZSBjb21tYW5kIGludG8gdGhlIG1lbnUuXG5Db2RlQ2VsbC5wcm90b3R5cGUuY2VsbENvbnRyb2xzLnB1c2goXy5maW5kKGNvbnRyb2xzLCBmdW5jdGlvbiAoY29udHJvbCkge1xuICByZXR1cm4gY29udHJvbC5jb21tYW5kID09PSAnZXhlY3V0ZSc7XG59KSk7XG5cbi8qKlxuICogU2V0cyB0aGUgb3B0aW9ucyB0byBiZSB1c2VkIGJ5IHRoZSBDb2RlTWlycm9yIGluc3RhbmNlIHdoZW4gaW5pdGlhbGl6ZWQuXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuQ29kZUNlbGwucHJvdG90eXBlLmVkaXRvck9wdGlvbnMgPSBfLmV4dGVuZChcbiAge30sIEVkaXRvckNlbGwucHJvdG90eXBlLmVkaXRvck9wdGlvbnMsIHtcbiAgICBtb2RlOiB7XG4gICAgICBuYW1lOiAnamF2YXNjcmlwdCcsXG4gICAgICBnbG9iYWxWYXJzOiB0cnVlXG4gICAgfVxuICB9XG4pO1xuXG4vKipcbiAqIERlZmluZXMgZXh0cmEga2V5cyB0byBiZSB1c2VkIGJ5IHRoZSBlZGl0b3IgZm9yIGNvZGUgY2VsbC5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5Db2RlQ2VsbC5wcm90b3R5cGUuZWRpdG9yT3B0aW9ucy5leHRyYUtleXMgPSBfLmV4dGVuZChcbiAge30sIEVkaXRvckNlbGwucHJvdG90eXBlLmVkaXRvck9wdGlvbnMuZXh0cmFLZXlzLCBleHRyYUtleXMoY29udHJvbHMpXG4pO1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgcmVzdWx0IGNlbGwgaW5kZXggY2FsY3VsYXRpb24uXG4gKlxuICogQHJldHVybiB7Q29kZUNlbGx9XG4gKi9cbkNvZGVDZWxsLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucmVzdWx0Q2VsbC51cGRhdGUoKTtcbiAgcmV0dXJuIEVkaXRvckNlbGwucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlIHRoZSBjb2RlIGNlbGwgY29udGVudHMgYW5kIHJlbmRlciB0aGUgcmVzdWx0LlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAqL1xuQ29kZUNlbGwucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoZG9uZSkge1xuICAvLyBTZXQgdGhlIHZhbHVlIGFzIG91ciBvd24gbW9kZWwgZm9yIGV4ZWN1dGluZy5cbiAgdGhpcy5tb2RlbC5zZXQoJ3ZhbHVlJywgdGhpcy5lZGl0b3IuZ2V0VmFsdWUoKSk7XG5cbiAgLy8gRmlyc3QgcnVuIHByZXZpb3VzIGNlbGxzIGlmIHRoZXkgbmVlZCB0byBiZSBydW4uXG4gIHRoaXMubm90ZWJvb2suZXhlY3V0ZVByZXZpb3VzKHRoaXMsIF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgLy8gQWRkIGEgY2xhc3MgdG8gdGhlIGNlbGwgdG8gZGlzcGxheSBleGVjdXRpb24uXG4gICAgdGhpcy5kYXRhLnNldCgnZXhlY3V0aW5nJywgdHJ1ZSk7XG5cbiAgICB0aGlzLm5vdGVib29rLnNhbmRib3guZXhlY3V0ZSh0aGlzLmdldFZhbHVlKCksIF8uYmluZChmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICB0aGlzLmRhdGEuc2V0KHtcbiAgICAgICAgZXhlY3V0ZWQ6ICB0cnVlLFxuICAgICAgICBleGVjdXRpbmc6IGZhbHNlXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5tb2RlbC5zZXQoe1xuICAgICAgICByZXN1bHQ6ICBkYXRhLnJlc3VsdCxcbiAgICAgICAgaXNFcnJvcjogZGF0YS5pc0Vycm9yXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5jaGFuZ2UoKTtcbiAgICAgIHRoaXMudHJpZ2dlcignZXhlY3V0ZScsIHRoaXMsIGRhdGEpO1xuICAgICAgcmV0dXJuIGRvbmUgJiYgZG9uZShlcnIsIGRhdGEpO1xuICAgIH0sIHRoaXMpKTtcbiAgfSwgdGhpcykpO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIHJlc3VsdCBjZWxsIHJlbmRlcmluZy5cbiAqL1xuQ29kZUNlbGwucHJvdG90eXBlLmNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZXN1bHRDZWxsLmNoYW5nZSgpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgbGluZSBpbiB0aGUgZWRpdG9yLlxuICovXG5Db2RlQ2VsbC5wcm90b3R5cGUubmV3TGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lZGl0b3IuZXhlY0NvbW1hbmQoJ25ld2xpbmVBbmRJbmRlbnQnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHVwIHRoZSBlZGl0b3IgaW5zdGFuY2UgYW5kIGJpbmRpbmdzLlxuICpcbiAqIEByZXR1cm4ge0NvZGVDZWxsfVxuICovXG5Db2RlQ2VsbC5wcm90b3R5cGUuYmluZEVkaXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgRWRpdG9yQ2VsbC5wcm90b3R5cGUuYmluZEVkaXRvci5jYWxsKHRoaXMpO1xuXG4gIC8vIFNldCB1cCB0aGUgYXV0b2NvbXBsZXRpb24gd2lkZ2V0LlxuICB0aGlzLl9jb21wbGV0aW9uID0gbmV3IENvbXBsZXRpb24oXG4gICAgdGhpcy5lZGl0b3IsIHRoaXMubm90ZWJvb2suY29tcGxldGlvbk9wdGlvbnNcbiAgKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBlZGl0b3IgaW5zdGFuY2UgZGF0YS5cbiAqL1xuQ29kZUNlbGwucHJvdG90eXBlLnVuYmluZEVkaXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fY29tcGxldGlvbi5yZW1vdmUoKTtcbiAgZGVsZXRlIHRoaXMuX2NvbXBsZXRpb247XG4gIHJldHVybiBFZGl0b3JDZWxsLnByb3RvdHlwZS51bmJpbmRFZGl0b3IuY2FsbCh0aGlzKTtcbn07XG4iLCJ2YXIgXyAgICAgICAgICA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBWaWV3ICAgICAgID0gcmVxdWlyZSgnLi92aWV3Jyk7XG52YXIgbWVzc2FnZXMgICA9IHJlcXVpcmUoJy4uL3N0YXRlL21lc3NhZ2VzJyk7XG52YXIgQ29kZU1pcnJvciA9IHJlcXVpcmUoJ2NvZGVtaXJyb3InKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgcmF3IG5vdGVib29rIGVkaXRvciBpbnN0YW5jZS5cbiAqXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKi9cbnZhciBFZGl0Tm90ZWJvb2sgPSBtb2R1bGUuZXhwb3J0cyA9IFZpZXcuZXh0ZW5kKHtcbiAgY2xhc3NOYW1lOiAnbm90ZWJvb2stZWRpdCdcbn0pO1xuXG4vKipcbiAqIFJlbmRlciB0aGUgbm90ZWJvb2sgZWRpdG9yLlxuICpcbiAqIEByZXR1cm4ge0VkaXROb3RlYm9va31cbiAqL1xuRWRpdE5vdGVib29rLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZWRpdG9yID0gbmV3IENvZGVNaXJyb3IodGhpcy5lbCwge1xuICAgIG1vZGU6ICAgICAgICAgICAnZ2ZtJyxcbiAgICB2YWx1ZTogICAgICAgICAgdGhpcy5tb2RlbC5nZXQoJ2NvbnRlbnQnKSxcbiAgICB0YWJTaXplOiAgICAgICAgMixcbiAgICBsaW5lTnVtYmVyczogICAgdHJ1ZSxcbiAgICBsaW5lV3JhcHBpbmc6ICAgdHJ1ZSxcbiAgICB2aWV3cG9ydE1hcmdpbjogSW5maW5pdHlcbiAgfSk7XG5cbiAgLy8gVXBkYXRlIHRoZSBwZXJzaXN0ZW5jZSBjb2RlIGV2ZXJ5IHRpbWUgd2UgY2hhbmdlIHRoZSBjb250ZW50LlxuICB0aGlzLmxpc3RlblRvKHRoaXMuZWRpdG9yLCAnY2hhbmdlJywgXy5iaW5kKGZ1bmN0aW9uIChjbSkge1xuICAgIG1lc3NhZ2VzLnRyaWdnZXIoJ3Jlc2l6ZScpO1xuICAgIHRoaXMubW9kZWwuc2V0KCdjb250ZW50JywgY20uZ2V0VmFsdWUoKSk7XG4gIH0sIHRoaXMpKTtcblxuICB0aGlzLmxpc3RlblRvKG1lc3NhZ2VzLCAncmVmcmVzaCcsIF8uYmluZCh0aGlzLmVkaXRvci5yZWZyZXNoLCB0aGlzLmVkaXRvcikpO1xuXG4gIHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbCwgJ2NoYW5nZTpjb250ZW50JywgZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm1vZGVsLmdldCgnY29udGVudCcpID09PSB0aGlzLmVkaXRvci5nZXRWYWx1ZSgpKSB7IHJldHVybjsgfVxuXG4gICAgdGhpcy5lZGl0b3Iuc2V0VmFsdWUodGhpcy5tb2RlbC5nZXQoJ2NvbnRlbnQnKSk7XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcbiIsInZhciBfICAgICAgICAgID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIENvZGVNaXJyb3IgPSByZXF1aXJlKCdjb2RlbWlycm9yJyk7XG5cbnZhciBWaWV3ICAgICAgICAgPSByZXF1aXJlKCcuL3RlbXBsYXRlJyk7XG52YXIgdGVtcGxhdGUgICAgID0gcmVxdWlyZSgnLi4vLi4vdGVtcGxhdGVzL3ZpZXdzL2VkaXRvci1jZWxsLmhicycpO1xudmFyIGV4dHJhS2V5cyAgICA9IHJlcXVpcmUoJy4vbGliL2V4dHJhLWtleXMnKTtcbnZhciBjb250cm9scyAgICAgPSByZXF1aXJlKCcuLi9saWIvY29udHJvbHMnKS5lZGl0b3I7XG52YXIgbWVzc2FnZXMgICAgID0gcmVxdWlyZSgnLi4vc3RhdGUvbWVzc2FnZXMnKTtcbnZhciBkb21MaXN0ZW4gICAgPSByZXF1aXJlKCcuLi9saWIvZG9tLWxpc3RlbicpO1xudmFyIENlbGwgICAgICAgICA9IHJlcXVpcmUoJy4uL21vZGVscy9jZWxsJyk7XG52YXIgQ2VsbEJ1dHRvbnMgID0gcmVxdWlyZSgnLi9jZWxsLWJ1dHRvbnMnKTtcbnZhciBDZWxsQ29udHJvbHMgPSByZXF1aXJlKCcuL2NlbGwtY29udHJvbHMnKTtcbnZhciBlbWJlZFByb3RlY3QgPSByZXF1aXJlKCcuL2xpYi9lbWJlZC1wcm90ZWN0Jyk7XG52YXIgY2VsbENvbnRyb2xzID0gbmV3IENlbGxDb250cm9scygpO1xuXG4vKipcbiAqIFdyYXAgYSBmdW5jdGlvbiBtZXRob2QgYW5kIGVuc3VyZSBpdCBvbmx5IHRyaWdnZXJzIHdoZW4gd2UncmUgYWxsb3dlZCBhY2Nlc3MuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSAgIG9ialxuICogQHBhcmFtICB7U3RyaW5nfSAgIG1ldGhvZFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbnZhciB0cmlnZ2VyU2VsZiA9IGZ1bmN0aW9uIChvYmosIG1ldGhvZCkge1xuICBvYmpbbWV0aG9kXSA9IGVtYmVkUHJvdGVjdChmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy50cmlnZ2VyKG1ldGhvZCwgdGhpcyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBnZW5lcmljIGVkaXRvciBjZWxsIGluc3RhbmNlIHZpZXcuXG4gKlxuICogQHR5cGUge0Z1bmN0aW9ufVxuICovXG52YXIgRWRpdG9yQ2VsbCA9IG1vZHVsZS5leHBvcnRzID0gVmlldy5leHRlbmQoe1xuICBjbGFzc05hbWU6ICdjZWxsIGNlbGwtZWRpdG9yJ1xufSk7XG5cbi8qKlxuICogUnVucyB3aGVuIHdlIGluaXRpYWxpemUgdGhlIGVkaXRvciBjZWxsLlxuICovXG5FZGl0b3JDZWxsLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIC8vIEFsaWFzIHRoZSBub3RlYm9vayBpbnN0YW5jZS5cbiAgdGhpcy5ub3RlYm9vayA9IG9wdGlvbnMgJiYgb3B0aW9ucy5ub3RlYm9vaztcblxuICAvLyBBbGlhcyBtb2RlbCBwcm9wZXJ0aWVzIG9yIGNyZWF0ZSBhIG5ldyBjZWxsIG1vZGVsLlxuICB0aGlzLm1vZGVsICAgICAgPSAob3B0aW9ucyAmJiBvcHRpb25zLm1vZGVsKSB8fCBuZXcgQ2VsbCh0aGlzLmNlbGxBdHRyaWJ1dGVzKTtcbiAgdGhpcy5tb2RlbC52aWV3ID0gdGhpcztcbn07XG5cbi8qKlxuICogRGVmYXVsdCBjZWxsIGF0dHJpYnV0ZXMgZm9yIGluaXRpYWxpemF0aW9uLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkVkaXRvckNlbGwucHJvdG90eXBlLmNlbGxBdHRyaWJ1dGVzID0ge307XG5cbi8qKlxuICogRW1iZWQgdGhlIGVkaXRvciBjZWxsIHRlbXBsYXRlLlxuICpcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqL1xuRWRpdG9yQ2VsbC5wcm90b3R5cGUudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcblxuLyoqXG4gKiBFdmVudCBsaXN0ZW5lcnMgZm9yIGFsbCBlZGl0b3IgY2VsbHMgaW4gdGhlIG5vdGVib29rLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkVkaXRvckNlbGwucHJvdG90eXBlLmV2ZW50cyA9IHtcbiAgJ21vdXNlZG93biAuY2VsbC1tZW51LXRvZ2dsZSc6ICAnc2hvd0NvbnRyb2xzJyxcbiAgJ3RvdWNoc3RhcnQgLmNlbGwtbWVudS10b2dnbGUnOiAnc2hvd0NvbnRyb2xzJ1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGJhc2UgZWRpdG9yIG9wdGlvbnMgdXNlZCBpbiBDb2RlTWlycm9yLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkVkaXRvckNlbGwucHJvdG90eXBlLmVkaXRvck9wdGlvbnMgPSB7XG4gIHRhYlNpemU6ICAgICAgICAyLFxuICBsaW5lTnVtYmVyczogICAgdHJ1ZSxcbiAgbGluZVdyYXBwaW5nOiAgIHRydWUsXG4gIHZpZXdwb3J0TWFyZ2luOiBJbmZpbml0eSxcbiAgZXh0cmFLZXlzOiAgICAgIGV4dHJhS2V5cyhjb250cm9scylcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBlZGl0b3IgY2VsbCBhcyBhIHJlc3VsdCBvZiB1c2VyIGFjdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHtFZGl0b3JDZWxsfVxuICovXG5FZGl0b3JDZWxsLnByb3RvdHlwZS5kZWxldGUgPSBlbWJlZFByb3RlY3QoZnVuY3Rpb24gKCkge1xuICB0aGlzLnRyaWdnZXIoJ2RlbGV0ZScsIHRoaXMpO1xuICB0aGlzLnJlbW92ZSgpO1xuXG4gIHJldHVybiB0aGlzO1xufSk7XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBlZGl0b3IgY2VsbC5cbiAqXG4gKiBAcmV0dXJuIHtFZGl0b3JDZWxsfVxuICovXG5FZGl0b3JDZWxsLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gIFZpZXcucHJvdG90eXBlLnJlbW92ZS5jYWxsKHRoaXMpO1xuICBtZXNzYWdlcy50cmlnZ2VyKCdyZXNpemUnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2xvbmVzIHRoZSBlZGl0b3IgY2VsbCBhbmQgdHJpZ2dlcnMgYSBjbG9uZSBldmVudCB3aXRoIHRoZSBjbG9uZWQgdmlldy5cbiAqXG4gKiBAcmV0dXJuIHtFZGl0b3JDZWxsfSBDbG9uZWQgdmlldy5cbiAqL1xuRWRpdG9yQ2VsbC5wcm90b3R5cGUuY2xvbmUgPSBlbWJlZFByb3RlY3QoZnVuY3Rpb24gKCkge1xuICB2YXIgY2xvbmUgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih7XG4gICAgbW9kZWw6ICAgIHRoaXMubW9kZWwuY2xvbmUoKSxcbiAgICBub3RlYm9vazogdGhpcy5ub3RlYm9va1xuICB9KTtcblxuICB0aGlzLnRyaWdnZXIoJ2Nsb25lJywgdGhpcywgY2xvbmUpO1xuICByZXR1cm4gY2xvbmU7XG59KTtcblxuLyoqXG4gKiBJbnNlcnRzIGEgbmV3IGxpbmUgZGlyZWN0bHkgYmVsb3cgdGhlIGN1cnJlbnQgbGluZS4gS2VlcHMgcHJldmlvdXMgY3Vyc29yXG4gKiBoaXN0b3J5IHNvIHVuZG8gcHV0cyB0aGUgY3Vyc29yIGJhY2sgdG8gdGhlIHNhbWUgcG9zaXRpb24uXG4gKi9cbkVkaXRvckNlbGwucHJvdG90eXBlLm5ld0xpbmVCZWxvdyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxpbmUgPSB0aGlzLmVkaXRvci5nZXRDdXJzb3IoKS5saW5lO1xuXG4gIHRoaXMuZWRpdG9yLmRvYy5yZXBsYWNlUmFuZ2UoJ1xcbicsIHtcbiAgICBjaDogICBJbmZpbml0eSxcbiAgICBsaW5lOiBsaW5lKytcbiAgfSk7XG4gIHRoaXMuZWRpdG9yLmluZGVudExpbmUobGluZSwgbnVsbCwgdHJ1ZSk7XG4gIHRoaXMuZWRpdG9yLmRvYy5zZXRDdXJzb3Ioe1xuICAgIGNtOiAgIEluZmluaXR5LFxuICAgIGxpbmU6IGxpbmVcbiAgfSk7XG59O1xuXG4vKipcbiAqIFRvZ2dsZSBjb21tZW50cyBpbiB0aGUgY3VycmVudCBlZGl0b3IgaW5zdGFuY2UuXG4gKi9cbkVkaXRvckNlbGwucHJvdG90eXBlLnRvZ2dsZUNvbW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZWRpdG9yLmV4ZWNDb21tYW5kKCd0b2dnbGVDb21tZW50Jyk7XG59O1xuXG4vKipcbiAqIEZvY3VzIHRoZSBlZGl0b3IgY2VsbC5cbiAqXG4gKiBAcmV0dXJuIHtFZGl0b3JDZWxsfVxuICovXG5FZGl0b3JDZWxsLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuZWRpdG9yKSB7XG4gICAgdGhpcy5lZGl0b3IuZm9jdXMoKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBjdXJyZW50IGNlbGwgaGFzIGZvY3VzLlxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbkVkaXRvckNlbGwucHJvdG90eXBlLmhhc0ZvY3VzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gISF0aGlzLmVkaXRvciAmJiB0aGlzLmVkaXRvci5oYXNGb2N1cygpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGZpcnN0IGxpbmUgb2YgdGhlIGVkaXRvci5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkVkaXRvckNlbGwucHJvdG90eXBlLmZpcnN0TGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHByZXZWaWV3ID0gdGhpcy5nZXRQcmV2VmlldygpO1xuXG4gIHJldHVybiBwcmV2VmlldyA/IHByZXZWaWV3Lmxhc3RMaW5lKCkgKyAxIDogMTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsYXN0IGxpbmUgb2YgdGhlIGVkaXRvci5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkVkaXRvckNlbGwucHJvdG90eXBlLmxhc3RMaW5lID0gZnVuY3Rpb24gKCkge1xuICAvLyBBdm9pZCB1c2luZyBgdGhpcy5lZGl0b3JgIHRvIGNhbGN1bGF0ZSB0aGUgbGFzdCBsaW5lLlxuICByZXR1cm4gdGhpcy5maXJzdExpbmUoKSArIHRoaXMubGluZUNvdW50KCk7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbnVtYmVyIG9mIGxpbmVzIGluIHRoZSBlZGl0b3IuXG4gKlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5FZGl0b3JDZWxsLnByb3RvdHlwZS5saW5lQ291bnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdldFZhbHVlKCkuc3BsaXQoJ1xcbicpLmxlbmd0aCAtIDE7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgZWRpdG9yIGxpbmUgbnVtYmVycy5cbiAqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBbbGluZV1cbiAqIEByZXR1cm4ge0VkaXRvckNlbGx9XG4gKi9cbkVkaXRvckNlbGwucHJvdG90eXBlLnVwZGF0ZUxpbmVOdW1iZXJzID0gZnVuY3Rpb24gKGxpbmUpIHtcbiAgdmFyIG5leHRWaWV3ID0gdGhpcy5nZXROZXh0VmlldygpO1xuXG4gIC8vIFVwZGF0ZSB0aGUgZmlyc3QgbGluZSBudW1iZXIuIFBhc3MgYSBudW1iZXIgdG8gc2V0IGl0IG1hbnVhbGx5LlxuICBsaW5lID0gbGluZSB8fCB0aGlzLmZpcnN0TGluZSgpO1xuXG4gIC8vIEFsbG93IHRoZSBlZGl0b3IgdG8gdXBkYXRlIHRoZSBsaW5lIG51bWJlci5cbiAgaWYgKHRoaXMuZWRpdG9yKSB7XG4gICAgdGhpcy5lZGl0b3Iuc2V0T3B0aW9uKCdmaXJzdExpbmVOdW1iZXInLCBsaW5lKTtcbiAgfVxuXG4gIHJldHVybiBuZXh0VmlldyAmJiBuZXh0Vmlldy51cGRhdGVMaW5lTnVtYmVycyhsaW5lICsgdGhpcy5saW5lQ291bnQoKSArIDEpO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIGVkaXRvciBpbnN0YW5jZS5cbiAqXG4gKiBAcmV0dXJuIHtFZGl0b3JDZWxsfVxuICovXG5FZGl0b3JDZWxsLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMudXBkYXRlTGluZU51bWJlcnMoKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVmcmVzaCB0aGUgZWRpdG9yIGluc3RhbmNlLlxuICpcbiAqIEByZXR1cm4ge0VkaXRvckNlbGx9XG4gKi9cbkVkaXRvckNlbGwucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmVkaXRvcikge1xuICAgIHRoaXMuZWRpdG9yLnJlZnJlc2goKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgdXAgYmluZGluZ3Mgd2l0aCB0aGUgQ29kZU1pcnJvciBpbnN0YW5jZS5cbiAqXG4gKiBAcmV0dXJuIHtFZGl0b3JDZWxsfVxuICovXG5FZGl0b3JDZWxsLnByb3RvdHlwZS5iaW5kRWRpdG9yID0gZnVuY3Rpb24gKCkge1xuICAvLyBUcmlnZ2VyIGEgZm9jdXMgZXZlbnQgb24gdGhlIHZpZXcgd2hlbiB0aGUgY2VsbCBpcyBmb2N1c2VkLlxuICB0aGlzLmxpc3RlblRvKHRoaXMuZWRpdG9yLCAnZm9jdXMnLCBfLmJpbmQoZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudHJpZ2dlcignZm9jdXMnLCB0aGlzKTtcbiAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICB9LCB0aGlzKSk7XG5cbiAgLy8gVHJpZ2dlciBhIGJsdXIgZXZlbnQgb24gdGhlIHZpZXcgd2hlbiB0aGUgY2VsbCBpcyBibHVycmVkLlxuICB0aGlzLmxpc3RlblRvKHRoaXMuZWRpdG9yLCAnYmx1cicsIF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdibHVyJywgdGhpcyk7XG4gICAgdGhpcy5lbC5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgfSwgdGhpcykpO1xuXG4gIC8vIFNhdmUgdGhlIHZhbHVlIG9mIHRoZSBtb2RlbCBldmVyeSB0aW1lIGEgY2hhbmdlIGhhcHBlbnNcbiAgdGhpcy5saXN0ZW5Ubyh0aGlzLmVkaXRvciwgJ2NoYW5nZScsIF8uYmluZChmdW5jdGlvbiAoY20sIGRhdGEpIHtcbiAgICB0aGlzLm1vZGVsLnNldCgndmFsdWUnLCBjbS5nZXRWYWx1ZSgpKTtcbiAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZScsIHRoaXMsIGRhdGEpO1xuICAgIG1lc3NhZ2VzLnRyaWdnZXIoJ3Jlc2l6ZScpO1xuXG4gICAgaWYgKGRhdGEudGV4dC5sZW5ndGggPiAxIHx8IGRhdGEuZnJvbS5saW5lICE9PSBkYXRhLnRvLmxpbmUpIHtcbiAgICAgIHRoaXMudXBkYXRlTGluZU51bWJlcnMoKTtcbiAgICB9XG4gIH0sIHRoaXMpKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBiaW5kaW5ncyBzZXQgdXAgd2l0aCB0aGUgQ29kZU1pcnJvciBpbnN0YW5jZS5cbiAqXG4gKiBAcmV0dXJuIHtFZGl0b3JDZWxsfVxuICovXG5FZGl0b3JDZWxsLnByb3RvdHlwZS51bmJpbmRFZGl0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc3RvcExpc3RlbmluZyh0aGlzLmVkaXRvcik7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgQ29kZU1pcnJvciB2aWV3IGZyb20gdGhlIERPTS5cbiAqXG4gKiBAcmV0dXJuIHtFZGl0b3JDZWxsfVxuICovXG5FZGl0b3JDZWxsLnByb3RvdHlwZS5yZW1vdmVFZGl0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5lZGl0b3IpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRoaXMuZG9jSGlzdG9yeSA9IHRoaXMuZWRpdG9yLmRvYy5nZXRIaXN0b3J5KCk7XG4gIHRoaXMudW5iaW5kRWRpdG9yKCk7XG5cbiAgLy8gR2V0IHRoZSBlZGl0b3IgZWxlbWVudCBET00gaW5zdGFuY2UgdG8gYmUgcmVtb3ZlZC5cbiAgdmFyIGVkaXRvckVsZW1lbnQgPSB0aGlzLmVkaXRvci5nZXRXcmFwcGVyRWxlbWVudCgpO1xuXG4gIC8vIERlbGV0ZSByZWZlcmVuY2VzIHRvIHRoZSBDb2RlTWlycm9yIGluc3RhbmNlLiBUaGlzIG5lZWRzIHRvIGJlIGRvbmUgYmVmb3JlXG4gIC8vIGl0J3MgcmVtb3ZlZCBmcm9tIHRoZSBET00sIHNpbmNlIGl0J3MgcmVsaWVkIG9uIGluIG90aGVyIFwiYmx1clwiIGV2ZW50cy5cbiAgZGVsZXRlIHRoaXMuZWRpdG9yO1xuXG4gIGlmIChlZGl0b3JFbGVtZW50ICYmIGVkaXRvckVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgIGVkaXRvckVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlZGl0b3JFbGVtZW50KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbnRyb2xzIHRvIGRpc3BsYXkgaW4gdGhlIGNlbGwgbWVudS5cbiAqXG4gKiBAdHlwZSB7QXJyYXl9XG4gKi9cbkVkaXRvckNlbGwucHJvdG90eXBlLmNlbGxDb250cm9scyA9IF8uZmlsdGVyKGNvbnRyb2xzLCBmdW5jdGlvbiAoY29udHJvbCkge1xuICByZXR1cm4ge1xuICAgICdtb3ZlVXAnOiAgICB0cnVlLFxuICAgICdtb3ZlRG93bic6ICB0cnVlLFxuICAgICdzd2l0Y2gnOiAgICB0cnVlLFxuICAgICdjbG9uZSc6ICAgICB0cnVlLFxuICAgICdkZWxldGUnOiAgICB0cnVlLFxuICAgICdhcHBlbmROZXcnOiB0cnVlXG4gIH1bY29udHJvbC5jb21tYW5kXTtcbn0pO1xuXG4vKipcbiAqIFJlbmRlciBhIENvZGVNaXJyb3IgaW5zdGFuY2UgaW5zaWRlIHRoZSB2aWV3LlxuICpcbiAqIEByZXR1cm4ge0VkaXRvckNlbGx9XG4gKi9cbkVkaXRvckNlbGwucHJvdG90eXBlLnJlbmRlckVkaXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gUmVtb3ZlIHRoZSBjdXJyZW50bHkgcmVuZGVyZWQgZWRpdG9yIGZyb20gYWxsIHJlZmVyZW5jZXMuXG4gIHRoaXMucmVtb3ZlRWRpdG9yKCk7XG5cbiAgLy8gSWYgYW4gZWRpdG9yIGFscmVhZHkgZXhpc3RzLCByZXJlbmRlciB0aGUgZWRpdG9yIGtlZXBpbmcgdGhlIHNhbWUgb3B0aW9ucy5cbiAgdGhpcy5lZGl0b3IgPSBuZXcgQ29kZU1pcnJvcihfLmJpbmQoZnVuY3Rpb24gKGVsKSB7XG4gICAgdGhpcy5lbC5pbnNlcnRCZWZvcmUoZWwsIHRoaXMuZWwuZmlyc3RDaGlsZCk7XG4gIH0sIHRoaXMpLCBfLmV4dGVuZCh7XG4gICAgdmlldzogICAgICAgICAgICB0aGlzLFxuICAgIHZhbHVlOiAgICAgICAgICAgdGhpcy5nZXRWYWx1ZSgpLFxuICAgIHJlYWRPbmx5OiAgICAgICAgdGhpcy5pc1JlYWRPbmx5KCksXG4gICAgZmlyc3RMaW5lTnVtYmVyOiB0aGlzLmZpcnN0TGluZSgpXG4gIH0sIHRoaXMuZWRpdG9yT3B0aW9ucykpO1xuXG4gIC8vIEluaXRpYWxpemUgZXZlcnkgZWRpdG9yIHdpdGggdGhlIGN1cnNvciBhdCB0aGUgZW5kLlxuICB0aGlzLm1vdmVDdXJzb3JUb0VuZCgpO1xuXG4gIC8vIEFkZCBhbiBleHRyYSBjc3MgY2xhc3MgZm9yIGhlbHBpbmcgd2l0aCBzdHlsaW5nIHJlYWQtb25seSBlZGl0b3JzLlxuICBpZiAodGhpcy5lZGl0b3IuZ2V0T3B0aW9uKCdyZWFkT25seScpKSB7XG4gICAgdGhpcy5lZGl0b3IuZ2V0V3JhcHBlckVsZW1lbnQoKS5jbGFzc05hbWUgKz0gJyBDb2RlTWlycm9yLXJlYWRPbmx5JztcbiAgfVxuXG4gIC8vIEFsaWFzIHRoZSBjdXJyZW50IHZpZXcgdG8gdGhlIGVkaXRvciwgc2luY2Uga2V5TWFwcyBhcmUgc2hhcmVkIGJldHdlZW5cbiAgLy8gYWxsIGluc3RhbmNlcyBvZiBDb2RlTWlycm9yLlxuICB0aGlzLmVkaXRvci52aWV3ID0gdGhpcztcblxuICAvLyBCaW5kIHRoZSBlZGl0b3IgZXZlbnRzIGF0IHRoZSBlbmQgaW4gY2FzZSBvZiBhbnkgZm9jdXMgaXNzdWVzIHdoZW5cbiAgLy8gY2hhbmdpbmcgZG9jcywgZXRjLlxuICB0aGlzLmJpbmRFZGl0b3IoKTtcblxuICAvLyBDb3B5IG9sZCBoaXN0b3J5IHRvIHVwZGF0ZWQgaW5zdGFuY2UuXG4gIGlmICh0aGlzLmRvY0hpc3RvcnkpIHtcbiAgICB0aGlzLmVkaXRvci5kb2Muc2V0SGlzdG9yeSh0aGlzLmRvY0hpc3RvcnkpO1xuICAgIGRlbGV0ZSB0aGlzLmRvY0hpc3Rvcnk7XG4gIH1cblxuICAvLyBUcmlnZ2VyIGEgcmVzaXplIGV2ZW50IGZvciB0aGUganVzdCBpbnNlcnRlZCBjb2RlIGVkaXRvci5cbiAgbWVzc2FnZXMudHJpZ2dlcigncmVzaXplJyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbmRlciB0aGUgZWRpdG9yIGNlbGwgYW5kIGF0dGFjaCB0aGUgY29udHJvbHMuXG4gKlxuICogQHJldHVybiB7RWRpdG9yQ2VsbH1cbiAqL1xuRWRpdG9yQ2VsbC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICBWaWV3LnByb3RvdHlwZS5yZW5kZXIuY2FsbCh0aGlzKTtcblxuICB0aGlzLnJlbmRlckVkaXRvcigpO1xuICB0aGlzLnVwZGF0ZSgpO1xuICB0aGlzLmxpc3RlblRvKG1lc3NhZ2VzLCAncmVmcmVzaCcsIHRoaXMucmVmcmVzaCk7XG5cbiAgdmFyIHRpbWVvdXQgICAgICAgPSAxMDA7XG4gIHZhciBhYm92ZUxpc3RlbmVyID0gZG9tTGlzdGVuKHRoaXMuZWwucXVlcnlTZWxlY3RvcignLmNlbGwtYm9yZGVyLWFib3ZlJykpO1xuICB2YXIgYmVsb3dMaXN0ZW5lciA9IGRvbUxpc3Rlbih0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5jZWxsLWJvcmRlci1iZWxvdycpKTtcblxuICB2YXIgc2hvd0Fib3ZlVGltZW91dDtcbiAgdmFyIHNob3dCZWxvd1RpbWVvdXQ7XG5cbiAgdGhpcy5saXN0ZW5UbyhhYm92ZUxpc3RlbmVyLCAnbW91c2VlbnRlcicsIGZ1bmN0aW9uICgpIHtcbiAgICBzaG93QWJvdmVUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoXG4gICAgICBfLmJpbmQodGhpcy5zaG93QnV0dG9uc0Fib3ZlLCB0aGlzKSwgdGltZW91dFxuICAgICk7XG4gIH0pO1xuXG4gIHRoaXMubGlzdGVuVG8oYmVsb3dMaXN0ZW5lciwgJ21vdXNlZW50ZXInLCBmdW5jdGlvbiAoKSB7XG4gICAgc2hvd0JlbG93VGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KFxuICAgICAgXy5iaW5kKHRoaXMuc2hvd0J1dHRvbnNCZWxvdywgdGhpcyksIHRpbWVvdXRcbiAgICApO1xuICB9KTtcblxuICB0aGlzLmxpc3RlblRvKGFib3ZlTGlzdGVuZXIsICdtb3VzZWxlYXZlJywgZnVuY3Rpb24gKCkge1xuICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoc2hvd0Fib3ZlVGltZW91dCk7XG4gIH0pO1xuXG4gIHRoaXMubGlzdGVuVG8oYmVsb3dMaXN0ZW5lciwgJ21vdXNlbGVhdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgd2luZG93LmNsZWFyVGltZW91dChzaG93QmVsb3dUaW1lb3V0KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIGNlbGwgY29udHJvbHMgaW5zdGFuY2UgYW5kIGFwcGVuZCB0byB0aGUgZWRpdG9yIGNlbGwuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSAgICAgICBlXG4gKiBAcmV0dXJuIHtDZWxsQ29udHJvbHN9XG4gKi9cbkVkaXRvckNlbGwucHJvdG90eXBlLnNob3dDb250cm9scyA9IGZ1bmN0aW9uIChlKSB7XG4gIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgdmFyIGNvbnRyb2xzID0gY2VsbENvbnRyb2xzLnJlbmRlcih0aGlzLmNlbGxDb250cm9scykuYXBwZW5kVG8odGhpcy5lbCk7XG5cbiAgdGhpcy5saXN0ZW5Ubyhjb250cm9scywgJ3JlbW92ZScsIHRoaXMuc3RvcExpc3RlbmluZyk7XG4gIHRoaXMubGlzdGVuVG8oY29udHJvbHMsICdhY3Rpb24nLCBmdW5jdGlvbiAoXywgYWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXNbYWN0aW9uXSgpO1xuICB9KTtcblxuICByZXR1cm4gY29udHJvbHM7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIGNlbGwgYnV0dG9ucyBpbnN0YW5jZSBhbmQgc2hvdyBpdCBhYm92ZSB0aGUgbm90ZWJvb2sgY2VsbC5cbiAqXG4gKiBAcmV0dXJuIHtDZWxsQnV0dG9uc31cbiAqL1xuRWRpdG9yQ2VsbC5wcm90b3R5cGUuc2hvd0J1dHRvbnNBYm92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuZGF0YS5oYXMoJ2NlbGxCdXR0b25zQWJvdmUnKSkgeyByZXR1cm47IH1cblxuICB2YXIgYnV0dG9ucyA9IG5ldyBDZWxsQnV0dG9ucygpO1xuICB0aGlzLmRhdGEuc2V0KCdjZWxsQnV0dG9uc0Fib3ZlJywgYnV0dG9ucyk7XG5cbiAgdGhpcy5saXN0ZW5UbyhidXR0b25zLCAncmVtb3ZlJywgZnVuY3Rpb24gKHZpZXcpIHtcbiAgICB0aGlzLnN0b3BMaXN0ZW5pbmcodmlldyk7XG4gICAgdGhpcy5kYXRhLnVuc2V0KCdjZWxsQnV0dG9uc0Fib3ZlJyk7XG4gIH0pO1xuXG4gIHRoaXMubGlzdGVuVG8oYnV0dG9ucywgJ2FjdGlvbicsIGZ1bmN0aW9uIChfLCBhY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpc1thY3Rpb24gKyAnQWJvdmUnXSgpO1xuICB9KTtcblxuICByZXR1cm4gYnV0dG9ucztcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgY2VsbCBidXR0b25zIGluc3RhbmNlIGFuZCBzaG93IGl0IGJlbG93IHRoZSBub3RlYm9vayBjZWxsLlxuICpcbiAqIEByZXR1cm4ge0NlbGxCdXR0b25zfVxuICovXG5FZGl0b3JDZWxsLnByb3RvdHlwZS5zaG93QnV0dG9uc0JlbG93ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5kYXRhLmhhcygnY2VsbEJ1dHRvbnNCZWxvdycpKSB7IHJldHVybjsgfVxuXG4gIHZhciBidXR0b25zID0gbmV3IENlbGxCdXR0b25zKCk7XG4gIHRoaXMuZGF0YS5zZXQoJ2NlbGxCdXR0b25zQmVsb3cnLCBidXR0b25zKTtcblxuICB0aGlzLmxpc3RlblRvKGJ1dHRvbnMsICdyZW1vdmUnLCBmdW5jdGlvbiAodmlldykge1xuICAgIHRoaXMuc3RvcExpc3RlbmluZyh2aWV3KTtcbiAgICB0aGlzLmRhdGEudW5zZXQoJ2NlbGxCdXR0b25zQmVsb3cnKTtcbiAgfSk7XG5cbiAgdGhpcy5saXN0ZW5UbyhidXR0b25zLCAnYWN0aW9uJywgZnVuY3Rpb24gKF8sIGFjdGlvbikge1xuICAgIHJldHVybiB0aGlzW2FjdGlvbiArICdCZWxvdyddKCk7XG4gIH0pO1xuXG4gIHJldHVybiBidXR0b25zO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGNlbGwuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5FZGl0b3JDZWxsLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubW9kZWwuZ2V0KCd2YWx1ZScpIHx8ICcnO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUgY3VycmVudCBlZGl0b3IgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSAgICAgdmFsdWVcbiAqIEByZXR1cm4ge0VkaXRvckNlbGx9XG4gKi9cbkVkaXRvckNlbGwucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGlmIChfLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgIGlmICh0aGlzLmVkaXRvcikge1xuICAgICAgdGhpcy5lZGl0b3IuZG9jLnNldFZhbHVlKHZhbHVlKTtcbiAgICAgIHRoaXMuZWRpdG9yLmRvYy5jbGVhckhpc3RvcnkoKTtcbiAgICB9XG5cbiAgICB0aGlzLm1vZGVsLnNldCgndmFsdWUnLCB2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTW92ZXMgdGhlIENvZGVNaXJyb3IgY3Vyc29yIHRvIHRoZSBlbmQgb2YgZG9jdW1lbnQsIG9yIGVuZCBvZiB0aGUgbGluZS5cbiAqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBsaW5lXG4gKiBAcmV0dXJuIHtFZGl0b3JDZWxsfVxuICovXG5FZGl0b3JDZWxsLnByb3RvdHlwZS5tb3ZlQ3Vyc29yVG9FbmQgPSBmdW5jdGlvbiAobGluZSkge1xuICBpZiAoIXRoaXMuZWRpdG9yKSB7IHJldHVybiB0aGlzOyB9XG5cbiAgdGhpcy5lZGl0b3Iuc2V0Q3Vyc29yKFxuICAgIGlzTmFOKGxpbmUpID8gdGhpcy5lZGl0b3IuZG9jLmxhc3RMaW5lKCkgOiBsaW5lLCBJbmZpbml0eVxuICApO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBCcm93c2UgdXAgdG8gdGhlIHByZXZpb3VzIGNvZGUgdmlldyBjb250ZW50cy5cbiAqL1xuRWRpdG9yQ2VsbC5wcm90b3R5cGUuYnJvd3NlVXAgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjdXJMaW5lICAgPSB0aGlzLmVkaXRvci5kb2MuZ2V0Q3Vyc29yKCkubGluZTtcbiAgdmFyIGZpcnN0TGluZSA9IHRoaXMuZWRpdG9yLmRvYy5maXJzdExpbmUoKTtcblxuICBpZiAoY3VyTGluZSA9PT0gZmlyc3RMaW5lKSB7XG4gICAgcmV0dXJuIHRoaXMudHJpZ2dlcignYnJvd3NlVXAnLCB0aGlzKTtcbiAgfVxuXG4gIHRoaXMuZWRpdG9yLmV4ZWNDb21tYW5kKCdnb0xpbmVVcCcpO1xufTtcblxuLyoqXG4gKiBCcm93c2UgZG93biB0byB0aGUgbmV4dCBjb2RlIHZpZXcgY29udGVudHMuXG4gKi9cbkVkaXRvckNlbGwucHJvdG90eXBlLmJyb3dzZURvd24gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjdXJMaW5lICA9IHRoaXMuZWRpdG9yLmRvYy5nZXRDdXJzb3IoKS5saW5lO1xuICB2YXIgbGFzdExpbmUgPSB0aGlzLmVkaXRvci5kb2MubGFzdExpbmUoKTtcblxuICBpZiAoY3VyTGluZSA9PT0gbGFzdExpbmUpIHtcbiAgICByZXR1cm4gdGhpcy50cmlnZ2VyKCdicm93c2VEb3duJywgdGhpcyk7XG4gIH1cblxuICB0aGlzLmVkaXRvci5leGVjQ29tbWFuZCgnZ29MaW5lRG93bicpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwcmV2aW91cyB2aWV3IGluIHRoZSBub3RlYm9vayBjb2xsZWN0aW9uLlxuICpcbiAqIEByZXR1cm4ge0VkaXRvckNlbGx9XG4gKi9cbkVkaXRvckNlbGwucHJvdG90eXBlLmdldFByZXZWaWV3ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5tb2RlbC5jb2xsZWN0aW9uKSB7XG4gICAgcmV0dXJuIF8ucmVzdWx0KHRoaXMubW9kZWwuY29sbGVjdGlvbi5nZXRQcmV2KHRoaXMubW9kZWwpLCAndmlldycpO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG5leHQgdmlldyBpbiB0aGUgbm90ZWJvb2sgY29sbGVjdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHtFZGl0b3JDZWxsfVxuICovXG5FZGl0b3JDZWxsLnByb3RvdHlwZS5nZXROZXh0VmlldyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMubW9kZWwuY29sbGVjdGlvbikge1xuICAgIHJldHVybiBfLnJlc3VsdCh0aGlzLm1vZGVsLmNvbGxlY3Rpb24uZ2V0TmV4dCh0aGlzLm1vZGVsKSwgJ3ZpZXcnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgY3VycmVudCB1c2VyIGlzIHRoZSBjdXJyZW50IG93bmVyIG9mIHRoZSBjZWxsIGFuZCBhYmxlIHRvXG4gKiBlZGl0IGl0LlxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbkVkaXRvckNlbGwucHJvdG90eXBlLmlzUmVhZE9ubHkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmRhdGEuZ2V0KCdyZWFkT25seScpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBmZXcgc2ltcGxlIGJpbmRpbmcgZm9yIGp1c3QgcHJveHlpbmcgZXZlbnRzLlxuICovXG50cmlnZ2VyU2VsZihFZGl0b3JDZWxsLnByb3RvdHlwZSwgJ3N3aXRjaCcpO1xudHJpZ2dlclNlbGYoRWRpdG9yQ2VsbC5wcm90b3R5cGUsICdtb3ZlVXAnKTtcbnRyaWdnZXJTZWxmKEVkaXRvckNlbGwucHJvdG90eXBlLCAnbW92ZURvd24nKTtcbnRyaWdnZXJTZWxmKEVkaXRvckNlbGwucHJvdG90eXBlLCAnbmV3VGV4dEFib3ZlJyk7XG50cmlnZ2VyU2VsZihFZGl0b3JDZWxsLnByb3RvdHlwZSwgJ25ld0NvZGVBYm92ZScpO1xudHJpZ2dlclNlbGYoRWRpdG9yQ2VsbC5wcm90b3R5cGUsICduZXdUZXh0QmVsb3cnKTtcbnRyaWdnZXJTZWxmKEVkaXRvckNlbGwucHJvdG90eXBlLCAnbmV3Q29kZUJlbG93Jyk7XG5cbi8qKlxuICogQWxpYXMgdGhlIGFwcGVuZCBuZXcgY2VsbCBiZWxvdyBmdW5jdGlvbiB0byBjcmVhdGluZyBhIG5ldyBjb2RlIGNlbGwuXG4gKlxuICogQHR5cGUge0Z1bmN0aW9ufVxuICovXG5FZGl0b3JDZWxsLnByb3RvdHlwZS5hcHBlbmROZXcgPSBFZGl0b3JDZWxsLnByb3RvdHlwZS5uZXdDb2RlQmVsb3c7XG4iLCJ2YXIgXyAgICAgICAgID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIHRyaW0gICAgICA9IF8uYmluZChGdW5jdGlvbi5wcm90b3R5cGUuY2FsbCwgU3RyaW5nLnByb3RvdHlwZS50cmltKTtcbnZhciB0eXBlICAgICAgPSByZXF1aXJlKCcuLi9saWIvdHlwZScpO1xudmFyIEluc3BlY3RvciA9IHJlcXVpcmUoJy4vaW5zcGVjdG9yJyk7XG5cbi8qKlxuICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoZSBpbnNwZWN0b3Igc3VpdGVkIGZvciByZW5kZXJpbmcgZXJyb3JzLlxuICpcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqL1xudmFyIEVycm9ySW5zcGVjdG9yID0gbW9kdWxlLmV4cG9ydHMgPSBJbnNwZWN0b3IuZXh0ZW5kKCk7XG5cbi8qKlxuICogUnVucyB3aGVuIGEgbmV3IGVycm9yIGluc3BlY3RvciBpbnN0YW5jZSBpcyBjcmVhdGVkLlxuICovXG5FcnJvckluc3BlY3Rvci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgSW5zcGVjdG9yLnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgLy8gQ2hlY2sgd2hldGhlciB3ZSByZW5kZXJpbmcgYW4gaW5pdGlhbGl6ZWQgZXJyb3IuXG4gIHRoaXMuX2lzRXJyb3IgPSAodHlwZSh0aGlzLmluc3BlY3QpID09PSAnZXJyb3InICYmICdzdGFjaycgaW4gdGhpcy5pbnNwZWN0KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHRoZSBpbnNwZWN0b3Igc2hvdWxkIGJlIGV4cGFuZGFibGUuXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuRXJyb3JJbnNwZWN0b3IucHJvdG90eXBlLmlzRXhwYW5kYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX2lzRXJyb3IpIHtcbiAgICByZXR1cm4gISF0aGlzLmluc3BlY3Quc3RhY2subGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIEluc3BlY3Rvci5wcm90b3R5cGUuaXNFeHBhbmRhYmxlLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHN0cmluZ2lmaWVkIHByZXZpZXcuIEluIHRoaXMgY2FzZSwgaXQgd2lsbCBiZSB0aGUgZXJyb3IgbWVzc2FnZS5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbkVycm9ySW5zcGVjdG9yLnByb3RvdHlwZS5zdHJpbmdpZnlQcmV2aWV3ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5faXNFcnJvcikge1xuICAgIHJldHVybiBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0aGlzLmluc3BlY3QpO1xuICB9XG5cbiAgcmV0dXJuIEluc3BlY3Rvci5wcm90b3R5cGUuc3RyaW5naWZ5UHJldmlldy5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBSZW5kZXIgdGhlIHN0YWNrIHRyYWNlIGFzIHRoZSBjaGlsZC5cbiAqXG4gKiBAcmV0dXJuIHtFcnJvckluc3BlY3Rvcn1cbiAqL1xuRXJyb3JJbnNwZWN0b3IucHJvdG90eXBlLl9yZW5kZXJDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gU3RhY2sgdHJhY2UgcmVuZGVyaW5nIHN1cHBvcnQuXG4gIGlmICh0aGlzLl9pc0Vycm9yKSB7XG4gICAgdmFyIHN0YWNrICAgPSB0aGlzLmluc3BlY3Quc3RhY2s7XG4gICAgdmFyIHRyYWNlRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB2YXIgbWVzc2FnZSA9IEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaXMuaW5zcGVjdCk7XG5cbiAgICAvLyBDaGVjayBmb3IgQ2hyb21lLXN0eWxlIHN0YWNrIHRyYWNlcyB3aGljaCBpbmNsdWRlIHRoZSBlcnJvciBtZXNzYWdlLlxuICAgIGlmIChzdGFjay5zdWJzdHIoMCwgbWVzc2FnZS5sZW5ndGgpID09PSBtZXNzYWdlKSB7XG4gICAgICBzdGFjayA9IF8ubWFwKHN0YWNrLnNwbGl0KCdcXG4nKS5zbGljZSgxKSwgdHJpbSkuam9pbignXFxuJyk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIHVzZWxlc3MgU2FmYXJpIGV2YWwgc3RhY2sgdHJhY2UgbGluZS5cbiAgICBzdGFjayA9IHN0YWNrLnJlcGxhY2UoL15ldmFsIGNvZGVcXG4vLCAnJyk7XG5cbiAgICB0cmFjZUVsLmNsYXNzTmFtZSAgID0gJ2luc3BlY3Rvci10cmFjZSc7XG4gICAgdHJhY2VFbC50ZXh0Q29udGVudCA9IHN0YWNrO1xuXG4gICAgdGhpcy5jaGlsZHJlbkVsLmFwcGVuZENoaWxkKHRyYWNlRWwpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZXR1cm4gSW5zcGVjdG9yLnByb3RvdHlwZS5fcmVuZGVyQ2hpbGRyZW4uY2FsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBzdGFjayB0cmFjZSBmcm9tIGRpc3BsYXkuXG4gKlxuICogQHJldHVybiB7RXJyb3JJbnNwZWN0b3J9XG4gKi9cbkVycm9ySW5zcGVjdG9yLnByb3RvdHlwZS5fcmVtb3ZlQ2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9pc0Vycm9yKSB7XG4gICAgdGhpcy5jaGlsZHJlbkVsLmlubmVySFRNTCA9ICcnO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZXR1cm4gSW5zcGVjdG9yLnByb3RvdHlwZS5fcmVtb3ZlQ2hpbGRyZW4uY2FsbCh0aGlzKTtcbn07XG4iLCJ2YXIgXyAgICAgICAgICA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBWaWV3ICAgICAgID0gcmVxdWlyZSgnLi92aWV3Jyk7XG52YXIgZG9taWZ5ICAgICA9IHJlcXVpcmUoJ2RvbWlmeScpO1xudmFyIHN0cmluZ2lmeSAgPSByZXF1aXJlKCcuLi9saWIvc3RyaW5naWZ5Jyk7XG52YXIgbWVzc2FnZXMgICA9IHJlcXVpcmUoJy4uL3N0YXRlL21lc3NhZ2VzJyk7XG52YXIgbWlkZGxld2FyZSA9IHJlcXVpcmUoJy4uL3N0YXRlL21pZGRsZXdhcmUnKTtcblxuLyoqXG4gKiBNYXRjaCBhbnl0aGluZyB0aGF0IGxvb2tzIGxpa2UgYSB2YWxpZCB1cmkuIFRoaXMgaW5jbHVkZXMgXCJkYXRhOlwiLCBcIm1haWx0bzpcIixcbiAqIFwiaHR0cDovL1wiLCBcImh0dHBzOi8vXCIsIFwiZnRwOi8vXCIgYW5kIGFueXRoaW5nIGVsc2UgdGhhdCBtYXkgZXhpc3QuXG4gKi9cbnZhciBsaW5rUmVnRXhwID0gbmV3IFJlZ0V4cChcbiAgJygnICtcbiAgICAnKD86XFxcXHcrOlxcXFwvezJ9fCg/OmRhdGF8bWFpbHRvKVxcXFw6KScgK1xuICAgICcoPzonICtcbiAgICAgICdbQS1aYS16MC05XFxcXC5cXFxcLV9+Oi9cXFxcPyNcXFxcW1xcXFxdQCFcXFxcJCZcXCdcXFxcKFxcXFwpXFxcXCpcXFxcKyw7PV18JVtBLUZhLWYwLTldezJ9JyArXG4gICAgJykrJyArXG4gICcpJyxcbiAgJ2cnXG4pO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaW5zcGVjdG9yIHZpZXcgaW5zdGFuY2UuXG4gKlxuICogQHR5cGUge0Z1bmN0aW9ufVxuICovXG52YXIgSW5zcGVjdG9yVmlldyA9IG1vZHVsZS5leHBvcnRzID0gVmlldy5leHRlbmQoe1xuICBjbGFzc05hbWU6ICdpbnNwZWN0b3InXG59KTtcblxuLyoqXG4gKiBSdW5zIHdoZW4gYSBuZXcgaW5zdGVjdG9yIGluc3RhbmNlIGlzIGNyZWF0ZWQuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gKi9cbkluc3BlY3RvclZpZXcucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgXy5leHRlbmQodGhpcywgXy5waWNrKFxuICAgIG9wdGlvbnMsIFsncHJvcGVydHknLCAncGFyZW50JywgJ2luc3BlY3QnLCAnaW50ZXJuYWwnLCAnd2luZG93J11cbiAgKSk7XG5cbiAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLnBhcmVudCwgJ2Nsb3NlJywgdGhpcy5jbG9zZSk7XG4gIH1cbn07XG5cbi8qKlxuICogTGlzdGVuIHRvIGV2ZW50cyBpbiB0aGUgdmlldyBhbmQgc3RvcCB0aGVtIGZyb20gcHJvcGFnYXRpbmcgKHNpbmNlIHBhcmVudFxuICogaW5zcGVjdG9yIHZpZXdzIGFyZSBsaXN0ZW5pbmcgdG8gdGhlIHNhbWUgZXZlbnRzKS5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5JbnNwZWN0b3JWaWV3LnByb3RvdHlwZS5ldmVudHMgPSB7XG4gICdjbGljayc6IGZ1bmN0aW9uIChlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB0aGlzLnRvZ2dsZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIE9wZW4gdGhlIGluc3BlY3RvciB0byB2aWV3IHRoZSBjaGlsZHJlbi5cbiAqL1xuSW5zcGVjdG9yVmlldy5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy50cmlnZ2VyKCdvcGVuJywgdGhpcyk7XG4gIHRoaXMuZWwuY2xhc3NMaXN0LmFkZCgnb3BlbicpO1xuICBtZXNzYWdlcy50cmlnZ2VyKCdyZXNpemUnKTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSBpbnNwZWN0b3IgaW5zdGFuY2UgYW5kIGhpZGVzIHRoZSBjaGlsZHJlbi5cbiAqL1xuSW5zcGVjdG9yVmlldy5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMudHJpZ2dlcignY2xvc2UnLCB0aGlzKTtcbiAgdGhpcy5lbC5jbGFzc0xpc3QucmVtb3ZlKCdvcGVuJyk7XG4gIG1lc3NhZ2VzLnRyaWdnZXIoJ3Jlc2l6ZScpO1xufTtcblxuLyoqXG4gKiBUb2dnbGUgdGhlIGRpc3BsYXkgb2YgY2hpbGRyZW4uXG4gKi9cbkluc3BlY3RvclZpZXcucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpc1t0aGlzLmVsLmNsYXNzTGlzdC5jb250YWlucygnb3BlbicpID8gJ2Nsb3NlJyA6ICdvcGVuJ10oKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHRoZSBpbnNwZWN0b3IgaXMgYWN0dWFsbHkgZXhwYW5kYWJsZS5cbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5JbnNwZWN0b3JWaWV3LnByb3RvdHlwZS5pc0V4cGFuZGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBfLmlzT2JqZWN0KHRoaXMuaW5zcGVjdCk7XG59O1xuXG4vKipcbiAqIFN0cmluZ2lmaWVzIHRoZSBpbnNwZWN0ZWQgb2JqZWN0IGZvciBkaXNwbGF5LlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuSW5zcGVjdG9yVmlldy5wcm90b3R5cGUuc3RyaW5naWZ5UHJldmlldyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gSWYgd2UgaGF2ZSBhIHBhcmVudCBvYmplY3QsIHJlbmRlciBpbiB0aGUgc2ltcGxpZmllZCBmb3JtYXQuIEV4Y2VwdCBmb3JcbiAgLy8gZnVuY3Rpb25zLCB3ZSBzdGlsbCB3YW50IHRoZSBmdWxsIG91dHB1dCBmb3IgZnVuY3Rpb25zLlxuICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAvLyBQaGFudG9tSlMgcmVwb3J0cyBgTm9kZUxpc3RgIGluc3RhbmNlcyB0byBiZSBmdW5jdGlvbnMuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0aGlzLmluc3BlY3QpID09PSAnW29iamVjdCBGdW5jdGlvbl0nKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnNwZWN0LnRvU3RyaW5nKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdHJpbmdpZnkuc3RyaW5naWZ5Q2hpbGQodGhpcy5pbnNwZWN0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RyaW5naWZ5KHRoaXMuaW5zcGVjdCk7XG59O1xuXG4vKipcbiAqIFJlbmRlciBhIGNoaWxkIHByb3BlcnR5IHZpZXcuIFBhc3NlcyB0aHJvdWdoIGFsbCBzb3J0cyBvZiBwcm9wZXJ0aWVzIHRvIGhlbHBcbiAqIHdpdGggcmVuZGVyaW5nLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gcHJvcGVydHkgSW5zcGVjdGVkIHByb3BlcnR5IG5hbWUuXG4gKiBAcGFyYW0gIHsqfSAgICAgIGluc3BlY3QgIFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSAge1N0cmluZ30gaW50ZXJuYWwgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBpbnRlcm5hbCBwcm9wZXJ0eS5cbiAqIEByZXR1cm4ge0luc3BlY3RvclZpZXd9XG4gKi9cbkluc3BlY3RvclZpZXcucHJvdG90eXBlLl9yZW5kZXJDaGlsZCA9IGZ1bmN0aW9uIChwcm9wZXJ0eSwgaW5zcGVjdCwgaW50ZXJuYWwpIHtcbiAgdmFyIGluc3BlY3RvciA9IG5ldyBJbnNwZWN0b3JWaWV3KHtcbiAgICBwYXJlbnQ6ICAgdGhpcyxcbiAgICB3aW5kb3c6ICAgdGhpcy53aW5kb3csXG4gICAgaW5zcGVjdDogIGluc3BlY3QsXG4gICAgcHJvcGVydHk6IHByb3BlcnR5LFxuICAgIGludGVybmFsOiBpbnRlcm5hbFxuICB9KTtcbiAgdGhpcy5jaGlsZHJlbltpbnNwZWN0b3IuY2lkXSA9IGluc3BlY3RvcjtcbiAgaW5zcGVjdG9yLnJlbmRlcigpLmFwcGVuZFRvKHRoaXMuY2hpbGRyZW5FbCk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbmRlciBhbGwgY2hpbGQgcHJvcGVydGllcy5cbiAqXG4gKiBAcmV0dXJuIHtJbnNwZWN0b3JWaWV3fVxuICovXG5JbnNwZWN0b3JWaWV3LnByb3RvdHlwZS5yZW5kZXJDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhlIGVsZW1lbnQgbWF5IG5vdCBldmVuIGJlIGV4cGFuZGFibGUuIEluIHdoaWNoIGNhc2UsIHdlIGNhbiBzYWZlbHkgcmV0dXJuXG4gIC8vIGVhcmx5IGJlZm9yZSBkb2luZyBhbnkgcmVuZGVyaW5nLlxuICBpZiAoIXRoaXMuaXNFeHBhbmRhYmxlKHRoaXMuaW5zcGVjdCkpIHsgcmV0dXJuIHRoaXM7IH1cblxuICB0aGlzLl9yZW5kZXJDaGlsZHJlbkVsKCk7XG5cbiAgLy8gSWYgaXQgc2hvdWxkIGJlIGV4cGFuZGVkLCBhZGQgYSBjbGFzcyB0byBzaG93IGl0IGNhbiBiZS5cbiAgdGhpcy5lbC5jbGFzc0xpc3QuYWRkKCdjYW4tZXhwYW5kJyk7XG5cbiAgdGhpcy5saXN0ZW5Ubyh0aGlzLCAnb3BlbicsICB0aGlzLl9yZW5kZXJDaGlsZHJlbik7XG4gIHRoaXMubGlzdGVuVG8odGhpcywgJ2Nsb3NlJywgdGhpcy5fcmVtb3ZlQ2hpbGRyZW4pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW5kZXIgdGhlIGNoaWxkcmVuIGVsZW1lbnQgY29udGFpbmVyLlxuICpcbiAqIEByZXR1cm4ge0luc3BlY3RvclZpZXd9XG4gKi9cbkluc3BlY3RvclZpZXcucHJvdG90eXBlLl9yZW5kZXJDaGlsZHJlbkVsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWwgPSB0aGlzLmNoaWxkcmVuRWwgPSBkb21pZnkoJzxkaXYgY2xhc3M9XCJjaGlsZHJlblwiPjwvZGl2PicpO1xuICB0aGlzLmVsLmFwcGVuZENoaWxkKGVsKTtcbiAgdGhpcy5jaGlsZHJlbiA9IHt9O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVuZGVyIGFsbCBjaGlsZCBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50bHkgaW5zcGVjdGVkIG9iamVjdC5cbiAqXG4gKiBAcmV0dXJuIHtJbnNwZWN0b3JWaWV3fVxuICovXG5JbnNwZWN0b3JWaWV3LnByb3RvdHlwZS5fcmVuZGVyQ2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFdlIG5lZWQgdG8gdXNlIHRoZSBgT2JqZWN0LipgIGZ1bmN0aW9ucyBmcm9tIHRoZSBjb3JyZWN0IHdpbmRvdyBvYmplY3QuXG4gIC8vIEZpcmVmb3ggMjYgcmV0dXJucyBgdW5kZWZpbmVkYCBhcyB0aGUgdmFsdWUgZm9yIGFuIGFycmF5cyBsZW5ndGggcHJvcGVydHlcbiAgLy8gd2hlbiBhY2Nlc3NlZCB1c2luZyB0aGUgd3JvbmcgZnJhbWVzIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYC5cbiAgdmFyIGdldFByb3RvdHlwZU9mICAgICAgICAgICA9IHRoaXMud2luZG93Lk9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIGdldE93blByb3BlcnR5TmFtZXMgICAgICA9IHRoaXMud2luZG93Lk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gdGhpcy53aW5kb3cuT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgdmFyIGFsbFByb3BlcnR5TmFtZXM7XG5cbiAgLy8gV3JhcCBnZXR0aW5nIHByb3BlcnR5IG5hbWVzIGluIGEgYHRyeS4uY2F0Y2hgIHNpbmNlIHRoZSBpbnNwZWN0ZWQgb2JqZWN0XG4gIC8vIGlzIHVua25vd24uIFdlIGFsc28gbmVlZCB0byBnZXQgb25seSB1bmlxdWUgcHJvcGVydHkgbmFtZXMgc2luY2UgQ2hyb21lXG4gIC8vIGhhcyBhIHByZXR0eSBtYWpvciBidWcgd2hlcmUgYWxsIGBkb2N1bWVudGAga2V5cyBhcmUgcmV0dXJuZWQgdHdpY2UuXG4gIHRyeSB7XG4gICAgYWxsUHJvcGVydHlOYW1lcyA9IF8udW5pcShnZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMuaW5zcGVjdCkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBXZSB3YW50IHRvIHNvcnQgdGhlIGtleXMgbnVtZXJpY2FsbHksIGFuZCB0aGVuIGFscGhhYmV0aWNhbGx5LlxuICB2YXIgcHJvcGVydHlOYW1lcyA9IGFsbFByb3BlcnR5TmFtZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciBhTnVtID0gcGFyc2VJbnQoYSwgMTApO1xuICAgIHZhciBiTnVtID0gcGFyc2VJbnQoYiwgMTApO1xuXG4gICAgLy8gT3JkZXIgdHdvIG51bWJlcnMgYnkgdGhlaXIgdmFsdWVzLlxuICAgIGlmICghaXNOYU4oYU51bSkgJiYgIWlzTmFOKGJOdW0pKSB7XG4gICAgICByZXR1cm4gYU51bSAtIGJOdW07XG4gICAgfVxuXG4gICAgLy8gTnVtYmVycyBzaG91bGQgYWx3YXlzIGNvbWUgb3V0IG9uIHRvcC5cbiAgICBpZiAoIWlzTmFOKGFOdW0pKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgaWYgKCFpc05hTihiTnVtKSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgLy8gU3RyaW5ncyBjYW4gYmUgc29ydGVkIGxpa2UgdXN1YWwuXG4gICAgcmV0dXJuIGEgPiBiID8gMSA6IC0xO1xuICB9KTtcblxuICBfLmVhY2gocHJvcGVydHlOYW1lcywgZnVuY3Rpb24gKHByb3ApIHtcbiAgICB2YXIgZGVzY3JpcHRvcjtcblxuICAgIC8vIFdyYXAgdGhlIGNvbGxlY3Rpb24gYW5kIGNoZWNraW5nIG9mIHByb3BlcnR5IG5hbWVzIGluIGEgYHRyeS4uY2F0Y2hgXG4gICAgLy8gc3RhdGVtZW50IHNpbmNlIHRoZSBvcmlnaW4gb2YgdGhlIG9iamVjdCBpcyB1bmtub3duLiBGb3IgZXhhbXBsZSxcbiAgICAvLyBhdHRlbXB0aW5nIHRvIGNoZWNrIGB3aW5kb3cucGFyZW50YCBjcm9zcy1kb21haW4gd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICB0cnkge1xuICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0aGlzLmluc3BlY3QsIHByb3ApO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAvLyBFdmVuIHRob3VnaCB3ZSBhcmUgaXRlcmF0aW5nIG92ZXIgb3VyIG93biBwcm9wZXJ0eSBuYW1lcywgUGhhbnRvbUpTIGlzXG4gICAgLy8gZmluZGluZyBhIHdheSB0byByZXR1cm4gYW4gYHVuZGVmaW5lZGAgcHJvcGVydHkgZGVzY3JpcHRvci5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZChkZXNjcmlwdG9yKSkgeyByZXR1cm47IH1cblxuICAgIC8vIENoZWNrIGZvciB0aGUgZXhpc3RlbmNlIG9mIGdldHRlcnMgYW5kIHNldHRlcnMsIG90aGVyd2lzZSBpdCdzIGEgcmVndWxhclxuICAgIC8vIHByb3BlcnR5LlxuICAgIGlmIChfLmlzRnVuY3Rpb24oZGVzY3JpcHRvci5nZXQpIHx8IF8uaXNGdW5jdGlvbihkZXNjcmlwdG9yLnNldCkpIHtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24oZGVzY3JpcHRvci5nZXQpKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlckNoaWxkKHByb3AsIGRlc2NyaXB0b3IuZ2V0LCAnW1tHZXR0ZXJdXScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKGRlc2NyaXB0b3Iuc2V0KSkge1xuICAgICAgICB0aGlzLl9yZW5kZXJDaGlsZChwcm9wLCBkZXNjcmlwdG9yLnNldCwgJ1tbU2V0dGVyXV0nKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVuZGVyQ2hpbGQocHJvcCwgZGVzY3JpcHRvci52YWx1ZSk7XG4gICAgfVxuICB9LCB0aGlzKTtcblxuICAvLyBSZW5kZXIgdGhlIGludGVybmFsIHByb3RvdHlwZSBwcm9wZXJ0eS5cbiAgdGhpcy5fcmVuZGVyQ2hpbGQobnVsbCwgZ2V0UHJvdG90eXBlT2YodGhpcy5pbnNwZWN0KSwgJ1tbUHJvdG90eXBlXV0nKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCB0aGUgY3VycmVudGx5IHJlbmRlcmVkIGNoaWxkcmVuLlxuICpcbiAqIEByZXR1cm4ge0luc3BlY3RvclZpZXd9XG4gKi9cbkluc3BlY3RvclZpZXcucHJvdG90eXBlLl9yZW1vdmVDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgXy5lYWNoKHRoaXMuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGNoaWxkLnJlbW92ZSgpO1xuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVuZGVyIHRoZSBpbnNwZWN0b3IgcHJldmlldy5cbiAqXG4gKiBAcmV0dXJuIHtJbnNwZWN0b3JWaWV3fVxuICovXG5JbnNwZWN0b3JWaWV3LnByb3RvdHlwZS5yZW5kZXJQcmV2aWV3ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuaW5zcGVjdDtcbiAgdmFyIGRlc2M7XG5cbiAgaWYgKHBhcmVudCAmJiAhdGhpcy5pbnRlcm5hbCkge1xuICAgIGRlc2MgPSB0aGlzLndpbmRvdy5PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHBhcmVudCwgdGhpcy5wcm9wZXJ0eSk7XG4gIH1cblxuICAvLyBSdW4gZmlsdGVyIG1pZGRsZXdhcmUgdG8gY2hlY2sgaWYgdGhlIHByb3BlcnR5IHNob3VsZCBiZSBmaWx0ZXJlZCBmcm9tXG4gIC8vIHRoZSBiYXNpYyBkaXNwbGF5LlxuICBtaWRkbGV3YXJlLnRyaWdnZXIoJ2luc3BlY3RvcjpmaWx0ZXInLCB7XG4gICAgcGFyZW50OiAgICAgcGFyZW50LFxuICAgIHdpbmRvdzogICAgIHRoaXMud2luZG93LFxuICAgIHByb3BlcnR5OiAgIHRoaXMucHJvcGVydHksXG4gICAgaW50ZXJuYWw6ICAgdGhpcy5pbnRlcm5hbCxcbiAgICBkZXNjcmlwdG9yOiBkZXNjXG4gIH0sIF8uYmluZChmdW5jdGlvbiAoZXJyLCBmaWx0ZXIpIHtcbiAgICBpZiAoIWZpbHRlcikgeyByZXR1cm4gdGhpcy5yZW1vdmUoKTsgfVxuXG4gICAgdmFyIGh0bWwgICAgICAgID0gJyc7XG4gICAgdmFyIHByZWZpeCAgICAgID0gJyc7XG4gICAgdmFyIHNwZWNpYWwgICAgID0gISF0aGlzLmludGVybmFsO1xuICAgIHZhciBwcmV2aWV3ICAgICA9IHRoaXMuc3RyaW5naWZ5UHJldmlldyh0aGlzLmluc3BlY3QpO1xuICAgIHZhciBodG1sUHJldmlldyA9ICcnO1xuXG4gICAgaWYgKHR5cGVvZiB0aGlzLmluc3BlY3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgcHJldmlvdXMgPSAwO1xuXG4gICAgICBwcmV2aWV3LnJlcGxhY2UobGlua1JlZ0V4cCwgZnVuY3Rpb24gKG1hdGNoLCB1cmksIGluZGV4KSB7XG4gICAgICAgIHZhciBlc2NhcGVkVXJpID0gXy5lc2NhcGUodXJpKTtcblxuICAgICAgICAvLyBBcHBlbmQgdGhlIGh0bWwgcHJldmlldyBpbiBtdWx0aXBsZSBzdGVwcy5cbiAgICAgICAgaHRtbFByZXZpZXcgKz0gXy5lc2NhcGUocHJldmlldy5zbGljZShwcmV2aW91cywgaW5kZXgpKTtcbiAgICAgICAgaHRtbFByZXZpZXcgKz0gJzxhIGhyZWY9XCInICsgZXNjYXBlZFVyaSArICdcIiB0YXJnZXQ9XCJfYmxhbmtcIj4nO1xuICAgICAgICBodG1sUHJldmlldyArPSBlc2NhcGVkVXJpO1xuICAgICAgICBodG1sUHJldmlldyArPSAnPC9hPic7XG5cbiAgICAgICAgLy8gSW5jcmVtZW50IHRoZSBwcmV2aW91cyBtYXJrZXIgdG8gdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICAgIHByZXZpb3VzID0gaW5kZXggKyBtYXRjaC5sZW5ndGg7XG4gICAgICB9KTtcblxuICAgICAgaHRtbFByZXZpZXcgKz0gXy5lc2NhcGUocHJldmlldy5zdWJzdHIocHJldmlvdXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaHRtbFByZXZpZXcgPSBfLmVzY2FwZShwcmV2aWV3KTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBoYXZlIGEgcHJvcGVydHkgbmFtZSwgdXNlIGl0IGFzIHRoZSBkaXNwbGF5IHByZWZpeC5cbiAgICBpZiAodGhpcy5wcm9wZXJ0eSkge1xuICAgICAgcHJlZml4ID0gdGhpcy5wcm9wZXJ0eTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBoYXZlIGEgcGFyZW50IG9iamVjdCwgZG8gc29tZSBtb3JlIGFkdmFuY2VkIGNoZWNrcyB0byBlc3RhYmxpc2hcbiAgICAvLyBzb21lIG1vcmUgYWR2YW5jZWQgcHJvcGVydGllcyBzdWNoIGFzIHRoZSBwcmVmaXggYW5kIHNwZWNpYWwgZGlzcGxheS5cbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBpZiAodGhpcy5pbnRlcm5hbCkge1xuICAgICAgICAvLyBJbnRlcm5hbCBwcm9wZXJ0aWVzIGFyZSBhbHdheXMgc3BlY2lhbGx5IHJlbmRlcmVkIHByb3BlcnRpZXMuXG4gICAgICAgIHNwZWNpYWwgPSB0cnVlO1xuXG4gICAgICAgIC8vIFNldHRlcnMgYW5kIGdldHRlcnMgc3RpbGwgc2hvdWxkIHN0aWxsIGJlIHJlbmRlcmVkIHdpdGggdGhlaXJcbiAgICAgICAgLy8gcHJvcGVydHkgbmFtZXMuIEV2ZXJ5dGhpbmcgZWxzZSBjYW4ganVzdCBiZSByZW5kZXJlZCB1c2luZyB0aGVcbiAgICAgICAgLy8gaW50ZXJuYWwgcHJvcGVydHkgbm90YXRpb24uXG4gICAgICAgIGlmICh0aGlzLmludGVybmFsID09PSAnW1tHZXR0ZXJdXScpIHtcbiAgICAgICAgICBwcmVmaXggPSAnZ2V0ICcgKyB0aGlzLnByb3BlcnR5O1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaW50ZXJuYWwgPT09ICdbW1NldHRlcl1dJykge1xuICAgICAgICAgIHByZWZpeCA9ICdzZXQgJyArIHRoaXMucHJvcGVydHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJlZml4ID0gdGhpcy5pbnRlcm5hbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3BlY2lhbCA9ICFkZXNjLndyaXRhYmxlIHx8ICFkZXNjLmNvbmZpZ3VyYWJsZSB8fCAhZGVzYy5lbnVtZXJhYmxlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGh0bWwgKz0gJzxkaXYgY2xhc3M9XCJhcnJvd1wiPjwvZGl2Pic7XG4gICAgaHRtbCArPSAnPGRpdiBjbGFzcz1cInByZXZpZXdcIj4nO1xuICAgIGlmIChwcmVmaXgpIHtcbiAgICAgIGh0bWwgKz0gJzxzcGFuIGNsYXNzPVwicHJvcGVydHknICsgKHNwZWNpYWwgPyAnIGlzLXNwZWNpYWwnIDogJycpICsgJ1wiPic7XG4gICAgICBodG1sICs9IF8uZXNjYXBlKCcnICsgcHJlZml4KTtcbiAgICAgIGh0bWwgKz0gJzwvc3Bhbj46ICc7XG4gICAgfVxuICAgIGh0bWwgKz0gJzxzcGFuIGNsYXNzPVwiaW5zcGVjdFwiIHRpdGxlPVwiJyArIF8uZXNjYXBlKHByZXZpZXcpICsgJ1wiPic7XG4gICAgaHRtbCArPSBodG1sUHJldmlldy5zcGxpdCgnXFxuJykuam9pbign4oa1Jyk7XG4gICAgaHRtbCArPSAnPC9zcGFuPic7XG4gICAgaHRtbCArPSAnPC9kaXY+JztcblxuICAgIHRoaXMuZWwuYXBwZW5kQ2hpbGQodGhpcy5wcmV2aWV3RWwgPSBkb21pZnkoaHRtbCkpO1xuICB9LCB0aGlzKSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbmRlcnMgdGhlIGluc3BlY3RvciB2aWV3LlxuICpcbiAqIEByZXR1cm4ge0luc3BlY3RvclZpZXd9XG4gKi9cbkluc3BlY3RvclZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgVmlldy5wcm90b3R5cGUucmVuZGVyLmNhbGwodGhpcyk7XG4gIHRoaXMucmVuZGVyUHJldmlldygpO1xuICB0aGlzLnJlbmRlckNoaWxkcmVuKCk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgaW5zcGVjdG9yIGZyb20gdGhlIGN1cnJlbnQgdmlldy4gQWxzbyByZW1vdmVzIGl0c2VsZiBmcm9tIGl0c1xuICogcGFyZW50IGluc3BlY3RvciB2aWV3LlxuICovXG5JbnNwZWN0b3JWaWV3LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnBhcmVudCkge1xuICAgIGRlbGV0ZSB0aGlzLnBhcmVudC5jaGlsZHJlblt0aGlzLmNpZF07XG4gIH1cblxuICByZXR1cm4gVmlldy5wcm90b3R5cGUucmVtb3ZlLmNhbGwodGhpcyk7XG59O1xuIiwidmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uLy4uL3N0YXRlL2NvbmZpZycpO1xuXG4vKipcbiAqIEV4cG9ydCBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgbWV0aG9kcyBvbiBhbiBpbnN0YW5jZSB3aXRoIGEgcHJvdGVjdGlvbiBhZ2FpbnN0XG4gKiBydW5uaW5nIHdoZW4gbm90IHRoZSBvd25lci5cbiAqXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gbWV0aG9kXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNvbmZpZy5nZXQoJ2VtYmVkZGVkJykpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn07XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcblxuLyoqXG4gKiBBY2NlcHRzIGFuIGFycmF5IG9mIGNvbnRyb2xzIGFuZCByZXR1cm5zIGEga2V5bWFwIGFjY2VwdGVkIGJ5IENvZGVNaXJyb3IuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9ICBjb250cm9sc1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjb250cm9scykge1xuICB2YXIgZXh0cmFLZXlzID0ge307XG5cbiAgXy5lYWNoKGNvbnRyb2xzLCBmdW5jdGlvbiAoY29udHJvbCkge1xuICAgIGlmICghY29udHJvbC5rZXlNYXApIHsgcmV0dXJuOyB9XG5cbiAgICAvLyBBc3NpZ24gdGhlIGtleSBtYXBwaW5nIHRvIHRoZSBleHRyYSBrZXlzIG9iamVjdC5cbiAgICBleHRyYUtleXNbY29udHJvbC5rZXlNYXBdID0gZnVuY3Rpb24gKGNtKSB7XG4gICAgICBjbS52aWV3W2NvbnRyb2wuY29tbWFuZF0oKTtcbiAgICB9O1xuICB9KTtcblxuICByZXR1cm4gZXh0cmFLZXlzO1xufTtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xuXG52YXIgVmlldyAgICAgICA9IHJlcXVpcmUoJy4vdmlldycpO1xudmFyIENvZGVWaWV3ICAgPSByZXF1aXJlKCcuL2NvZGUtY2VsbCcpO1xudmFyIFRleHRWaWV3ICAgPSByZXF1aXJlKCcuL3RleHQtY2VsbCcpO1xudmFyIEVkaXRvclZpZXcgPSByZXF1aXJlKCcuL2VkaXRvci1jZWxsJyk7XG5cbnZhciBDZWxscyAgICAgICA9IHJlcXVpcmUoJy4uL2NvbGxlY3Rpb25zL2NlbGxzJyk7XG52YXIgU2FuZGJveCAgICAgPSByZXF1aXJlKCcuLi9saWIvc2FuZGJveCcpO1xudmFyIGNvbmZpZyAgICAgID0gcmVxdWlyZSgnLi4vc3RhdGUvY29uZmlnJyk7XG52YXIgbWVzc2FnZXMgICAgPSByZXF1aXJlKCcuLi9zdGF0ZS9tZXNzYWdlcycpO1xudmFyIG1pZGRsZXdhcmUgID0gcmVxdWlyZSgnLi4vc3RhdGUvbWlkZGxld2FyZScpO1xudmFyIGluc2VydEFmdGVyID0gcmVxdWlyZSgnLi4vbGliL2Jyb3dzZXIvaW5zZXJ0LWFmdGVyJyk7XG5cbnZhciBjb21wbGV0aW9uTWlkZGxld2FyZSA9IHJlcXVpcmUoJy4uL2xpYi9zYW5kYm94LWNvbXBsZXRpb24nKTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBnZW5lcmljIGZ1bmN0aW9uIGZvciBhcHBlbmRpbmcgbmV3IHZpZXcgaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSAge0JhY2tib25lLlZpZXd9IFZpZXdcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG52YXIgYXBwZW5kTmV3VmlldyA9IGZ1bmN0aW9uIChWaWV3KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZWwsIHZhbHVlKSB7XG4gICAgdmFyIHZpZXcgPSBuZXcgVmlldyh7IG5vdGVib29rOiB0aGlzIH0pO1xuICAgIHRoaXMuYXBwZW5kVmlldyh2aWV3LCBlbCk7XG5cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHZpZXcuc2V0VmFsdWUodmFsdWUpO1xuICAgIH1cblxuICAgIC8vIFRyaWdnZXIgYSBtZXNzYWdlIHRvIGxpc3RlbiB0bywgd2hlbiB3ZSBhcmVuJ3QgcmVuZGVyaW5nIGEgbm90ZWJvb2suXG4gICAgaWYgKCF0aGlzLl9yZW5kZXJpbmcpIHtcbiAgICAgIG1lc3NhZ2VzLnRyaWdnZXIoJ2NlbGw6bmV3Jywgdmlldyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZpZXc7XG4gIH07XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGdlbmVyaWMgZnVuY3Rpb24gZm9yIHByZXBlbmRpbmcgbmV3IHZpZXdzLlxuICpcbiAqIEBwYXJhbSAge0JhY2tib25lLlZpZXd9IFZpZXdcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG52YXIgcHJlcGVuZE5ld1ZpZXcgPSBmdW5jdGlvbiAoVmlldykge1xuICByZXR1cm4gZnVuY3Rpb24gKGVsLCB2YWx1ZSkge1xuICAgIHJldHVybiBhcHBlbmROZXdWaWV3KFZpZXcpLmNhbGwodGhpcywgZnVuY3Rpb24gKHZpZXdFbCkge1xuICAgICAgZWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodmlld0VsLCBlbCk7XG4gICAgfSwgdmFsdWUpO1xuICB9O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgbm90ZWJvb2sgaW5zdGFuY2UuXG4gKlxuICogQHR5cGUge0Z1bmN0aW9ufVxuICovXG52YXIgTm90ZWJvb2sgPSBtb2R1bGUuZXhwb3J0cyA9IFZpZXcuZXh0ZW5kKHtcbiAgY2xhc3NOYW1lOiAnbm90ZWJvb2stdmlldydcbn0pO1xuXG4gLyoqXG4gKiBJbml0aWFsaXplIHRoZSBub3RlYm9vayB2aWV3LlxuICovXG5Ob3RlYm9vay5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jb2xsZWN0aW9uID0gbmV3IENlbGxzKCk7XG5cbiAgcmV0dXJuIFZpZXcucHJvdG90eXBlLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgbm90ZWJvb2sgZnJvbSB0aGUgRE9NLlxuICpcbiAqIEByZXR1cm4ge05vdGVib29rfVxuICovXG5Ob3RlYm9vay5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAvLyBSZW1vdmUgbGluZ2VyaW5nIG5vdGVib29rIHZpZXdzLlxuICBpZiAodGhpcy5zYW5kYm94KSB7XG4gICAgdGhpcy5zYW5kYm94LnJlbW92ZSgpO1xuICAgIGRlbGV0ZSB0aGlzLnNhbmRib3g7XG4gIH1cblxuICAvLyBSZW1vdmUgbm90ZWJvb2sgdmlldyBzcGVjaWZpYyBtaWRkbGV3YXJlLlxuICBtaWRkbGV3YXJlLmRlcmVnaXN0ZXIodGhpcy5fbWlkZGxld2FyZSk7XG4gIGRlbGV0ZSB0aGlzLl9taWRkbGV3YXJlO1xuXG4gIHJldHVybiBWaWV3LnByb3RvdHlwZS5yZW1vdmUuY2FsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogUmVmcmVzaCB0aGUgY29tcGxldGlvbiBjb250ZXh0IG9iamVjdCwgdXNlZCBieSB0aGUgY29tcGxldGlvbiBoZWxwZXIgaW4gY29kZVxuICogY2VsbHMgdG8gZ2V0IGNvbXBsZXRpb24gcmVzdWx0cy5cbiAqXG4gKiBAcmV0dXJuIHtOb3RlYm9va31cbiAqL1xuTm90ZWJvb2sucHJvdG90eXBlLnVwZGF0ZUNvbXBsZXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIC8vIEV4dGVuZHMgdGhlIGNvbnRleHQgd2l0aCBhZGRpdGlvbmFsIGlubGluZSBjb21wbGV0aW9uIHJlc3VsdHMuIFJlcXVpcmVzXG4gIC8vIHVzaW5nIGBPYmplY3QuY3JlYXRlYCBzaW5jZSB5b3UgY2FuJ3QgZXh0ZW5kIGFuIG9iamVjdCB3aXRoIGV2ZXJ5IHByb3BlcnR5XG4gIC8vIG9mIHRoZSBnbG9iYWwgb2JqZWN0LlxuICB2YXIgY29udGV4dCA9IE9iamVjdC5jcmVhdGUodGhpcy5zYW5kYm94LndpbmRvdyk7XG5cbiAgbWlkZGxld2FyZS50cmlnZ2VyKCdzYW5kYm94OmNvbnRleHQnLCBjb250ZXh0LCBfLmJpbmQoZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgIHRoaXMuY29tcGxldGlvbk9wdGlvbnMuY29udGV4dCA9IGRhdGE7XG4gIH0sIHRoaXMpKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVuZGVyIHRoZSBub3RlYm9vayB2aWV3LlxuICpcbiAqIEByZXR1cm4ge05vdGVib29rfVxuICovXG5Ob3RlYm9vay5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICBWaWV3LnByb3RvdHlwZS5yZW5kZXIuY2FsbCh0aGlzKTtcblxuICAvLyBDcmVhdGUgYSBuZXcgc2FuZGJveCBpbnN0YW5jZSBmb3IgZXZlcnkgbm90ZWJvb2sgdmlldy5cbiAgdGhpcy5zYW5kYm94ID0gbmV3IFNhbmRib3goKTtcblxuICAvLyBUaGUgY29tcGxldGlvbiBvcHRpb25zIG9iamVjdCBpcyBzaGFyZWQgYmV0d2VlbiBhbGwgY2VsbHMgYW5kIHVzZWQgZm9yXG4gIC8vIGNvbXBsZXRpb24uIE1ha2Ugc3VyZSB3ZSBzZXQgdGhpcyBjb25uZWN0aW9uIHVwIGJlZm9yZSByZW5kZXJpbmcgYW55IGNlbGxzLlxuICB0aGlzLmNvbXBsZXRpb25PcHRpb25zID0ge1xuICAgIHdpbmRvdzogdGhpcy5zYW5kYm94LndpbmRvd1xuICB9O1xuXG4gIC8vIFJlZ2lzdGVyIGEgbWlkZGxld2FyZSBob29rIGZvciBhdWdtZW50aW5nIHRoZSBzYW5kYm94IGNvbnRleHQuXG4gIHRoaXMuX21pZGRsZXdhcmUgPSB7XG4gICAgJ3NhbmRib3g6Y29udGV4dCc6IF8uYmluZChmdW5jdGlvbiAoY29udGV4dCwgbmV4dCkge1xuICAgICAgXy5lYWNoKHRoaXMuY29sbGVjdGlvbi5maWx0ZXIoZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgIHJldHVybiBtb2RlbC5nZXQoJ3R5cGUnKSA9PT0gJ2NvZGUnO1xuICAgICAgfSksIGZ1bmN0aW9uIChtb2RlbCwgaW5kZXgpIHtcbiAgICAgICAgY29udGV4dFsnJCcgKyBpbmRleF0gPSBtb2RlbC5nZXQoJ3Jlc3VsdCcpO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgfSwgdGhpcylcbiAgfTtcblxuICBfLmV4dGVuZCh0aGlzLl9taWRkbGV3YXJlLCBjb21wbGV0aW9uTWlkZGxld2FyZSh0aGlzLnNhbmRib3gud2luZG93KSk7XG4gIG1pZGRsZXdhcmUucmVnaXN0ZXIodGhpcy5fbWlkZGxld2FyZSk7XG5cbiAgLy8gU2V0IGEgcmVuZGVyaW5nIGZsYWcgd2hpbGUgd2UgYXJlIHJlbmRlcmluZyB0aGUgaW5pdGlhbCBjb2xsZWN0aW9uLlxuICB0aGlzLl9yZW5kZXJpbmcgPSB0cnVlO1xuXG4gIC8vIEl0ZXJhdGUgb3ZlciB0aGUgbm90ZWJvb2sgY2VsbHMgYW5kIGFkZCB0byB0aGUgdmlldy5cbiAgXy5lYWNoKHRoaXMubW9kZWwuZ2V0KCdjZWxscycpLCBmdW5jdGlvbiAoY2VsbCkge1xuICAgIHZhciBhcHBlbmRWaWV3ID0gJ2FwcGVuZENvZGVWaWV3JztcblxuICAgIGlmIChjZWxsLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgYXBwZW5kVmlldyA9ICdhcHBlbmRUZXh0Vmlldyc7XG4gICAgfVxuXG4gICAgdGhpc1thcHBlbmRWaWV3XShudWxsLCBjZWxsLnZhbHVlKTtcbiAgfSwgdGhpcyk7XG5cbiAgLy8gSWYgbm8gY2VsbHMgd2VyZSBhcHBlbmRlZCwgbWFudWFsbHkgYXBwZW5kIGEgc3RhcnRpbmcgY29kZSB2aWV3LlxuICBpZiAoIXRoaXMuY29sbGVjdGlvbi5sZW5ndGgpIHtcbiAgICB0aGlzLmFwcGVuZENvZGVWaWV3KCk7XG4gIH1cblxuICAvLyBSZW1vdmUgdGhlIHJlbmRlcmluZyBmbGFnIG9uY2UgdGhlIGluaXRpYWwgdmlldyBoYXMgYmVlbiBzZXQgdXAuXG4gIGRlbGV0ZSB0aGlzLl9yZW5kZXJpbmc7XG5cbiAgLy8gV2hlbiB3ZSBvbmx5IGhhdmUgb25lIGNlbGwgYW5kIG5vIHZhbHVlIChmcmVzaCBub3RlYm9vayksIHNob3cgdGhlIGZpcnN0XG4gIC8vIGNlbGxzIGJvcmRlciBidXR0b25zLlxuICBpZiAodGhpcy5jb2xsZWN0aW9uLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBtb2RlbCA9IHRoaXMuY29sbGVjdGlvbi5hdCgwKTtcblxuICAgIGlmICghbW9kZWwuZ2V0KCd2YWx1ZScpKSB7XG4gICAgICBtb2RlbC52aWV3LnNob3dCdXR0b25zQWJvdmUoKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLmxpc3RlblRvKHRoaXMuY29sbGVjdGlvbiwgJ3JlbW92ZSBzb3J0JywgdGhpcy51cGRhdGVDb21wbGV0aW9uKTtcblxuICB0aGlzLmxpc3RlblRvKHRoaXMuY29sbGVjdGlvbiwgJ2NoYW5nZSByZW1vdmUgc29ydCcsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLm1vZGVsLnNldCgnY2VsbHMnLCB0aGlzLmNvbGxlY3Rpb24udG9KU09OKCkpO1xuICB9KTtcblxuICB0aGlzLnVwZGF0ZUNvbXBsZXRpb24oKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRXhlY3V0ZSB0aGUgZW50aXJlIG5vdGVib29rIHNlcXVlbnRpYWxseS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gKi9cbk5vdGVib29rLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKGRvbmUpIHtcbiAgaWYgKHRoaXMuX2V4ZWN1dGluZykge1xuICAgIHJldHVybiBkb25lICYmIGRvbmUobmV3IEVycm9yKCdBbHJlYWR5IGV4ZWN1dGluZyBub3RlYm9vaycpKTtcbiAgfVxuXG4gIHZhciB0aGF0ID0gdGhpcztcbiAgdGhpcy5fZXhlY3V0aW5nID0gdHJ1ZTtcblxuICAvLyBUaGlzIGNoYWluaW5nIGlzIGEgbGl0dGxlIGF3a3dhcmQsIGJ1dCBpdCBhbGxvd3MgdGhlIGV4ZWN1dGlvbiB0byB3b3JrIHdpdGhcbiAgLy8gYXN5bmNocm9ub3VzIGNhbGxiYWNrcy5cbiAgKGZ1bmN0aW9uIGV4ZWN1dGlvbiAodmlldykge1xuICAgIC8vIElmIG5vIHZpZXcgaXMgcGFzc2VkIHRocm91Z2gsIHdlIG11c3QgaGF2ZSBoaXQgdGhlIGxhc3Qgdmlldy5cbiAgICBpZiAoIXZpZXcpIHtcbiAgICAgIHRoYXQuX2V4ZWN1dGluZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGRvbmUgJiYgZG9uZSgpO1xuICAgIH1cblxuICAgIC8vIE9ubHkgZXhlY3V0ZSBjb2RlIGNlbGxzLCBza2lwcyBvdGhlciBjZWxsIHR5cGVzLlxuICAgIGlmICh2aWV3Lm1vZGVsLmdldCgndHlwZScpID09PSAnY29kZScpIHtcbiAgICAgIHZpZXcuZXhlY3V0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGV4ZWN1dGlvbih0aGF0LmdldE5leHRWaWV3KHZpZXcpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGVjdXRpb24odGhhdC5nZXROZXh0Vmlldyh2aWV3KSk7XG4gICAgfVxuICB9KSh0aGlzLmNvbGxlY3Rpb24uYXQoMCkudmlldyk7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGUgbm90ZWJvb2sgY2VsbHMgc2VxdWVudGlhbGx5IHVudGlsIGEgY2VydGFpbiB2aWV3LlxuICpcbiAqIEBwYXJhbSB7QmFja2JvbmUuVmlld30gY3VycmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gICAgICBkb25lXG4gKi9cbk5vdGVib29rLnByb3RvdHlwZS5leGVjdXRlUHJldmlvdXMgPSBmdW5jdGlvbiAoY3VycmVudCwgZG9uZSkge1xuICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgLy8gRG9uJ3QgbmVlZCB0byBleGVjdXRlUHJldmlvdXMgaWYgd2UncmUgYWxyZWFkeSBpbiBhIGZ1bGwgZXhlY3V0aW9uLlxuICBpZiAodGhpcy5fZXhlY3V0aW5nKSB7XG4gICAgcmV0dXJuIGRvbmUgJiYgZG9uZSgpO1xuICB9XG5cbiAgdGhpcy5fZXhlY3V0aW5nID0gdHJ1ZTtcblxuICAoZnVuY3Rpb24gZXhlY3V0aW9uICh2aWV3KSB7XG4gICAgLy8gSWYgbm8gdmlldyBpcyBwYXNzZWQgdGhyb3VnaCwgd2UgbXVzdCBoYXZlIGhpdCB0aGUgbGFzdCB2aWV3LlxuICAgIGlmICghdmlldyB8fCBjdXJyZW50ID09PSB2aWV3KSB7XG4gICAgICB0aGF0Ll9leGVjdXRpbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybiBkb25lICYmIGRvbmUoKTtcbiAgICB9XG5cbiAgICAvLyBPbmx5IGV4ZWN1dGUgY29kZSBjZWxscywgc2tpcHMgb3RoZXIgY2VsbCB0eXBlcy5cbiAgICBpZiAodmlldy5tb2RlbC5nZXQoJ3R5cGUnKSA9PT0gJ2NvZGUnICYmICF2aWV3LmRhdGEuZ2V0KCdleGVjdXRlZCcpKSB7XG4gICAgICB2aWV3LmV4ZWN1dGUoZnVuY3Rpb24gKCkge1xuICAgICAgICBleGVjdXRpb24odGhhdC5nZXROZXh0Vmlldyh2aWV3KSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhlY3V0aW9uKHRoYXQuZ2V0TmV4dFZpZXcodmlldykpO1xuICAgIH1cbiAgfSkodGhpcy5jb2xsZWN0aW9uLmF0KDApLnZpZXcpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuZXh0IHZpZXcgaW4gdGhlIG5vdGVib29rLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gdmlld1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5Ob3RlYm9vay5wcm90b3R5cGUuZ2V0TmV4dFZpZXcgPSBmdW5jdGlvbiAodmlldykge1xuICB2YXIgbW9kZWwgPSB0aGlzLmNvbGxlY3Rpb24uZ2V0TmV4dCh2aWV3Lm1vZGVsKTtcbiAgcmV0dXJuIG1vZGVsICYmIG1vZGVsLnZpZXc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHByZXZpb3VzIHZpZXcgaW4gdGhlIG5vdGVib29rLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gdmlld1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5Ob3RlYm9vay5wcm90b3R5cGUuZ2V0UHJldlZpZXcgPSBmdW5jdGlvbiAodmlldykge1xuICB2YXIgbW9kZWwgPSB0aGlzLmNvbGxlY3Rpb24uZ2V0UHJldih2aWV3Lm1vZGVsKTtcbiAgcmV0dXJuIG1vZGVsICYmIG1vZGVsLnZpZXc7XG59O1xuXG4vKipcbiAqIEFwcGVuZCBhbmQgcHJlcGVuZCBuZXcgY2VsbCB2aWV3IGluc3RhbmNlcy5cbiAqL1xuTm90ZWJvb2sucHJvdG90eXBlLmFwcGVuZENvZGVWaWV3ICA9IGFwcGVuZE5ld1ZpZXcoQ29kZVZpZXcpO1xuTm90ZWJvb2sucHJvdG90eXBlLmFwcGVuZFRleHRWaWV3ICA9IGFwcGVuZE5ld1ZpZXcoVGV4dFZpZXcpO1xuTm90ZWJvb2sucHJvdG90eXBlLnByZXBlbmRDb2RlVmlldyA9IHByZXBlbmROZXdWaWV3KENvZGVWaWV3KTtcbk5vdGVib29rLnByb3RvdHlwZS5wcmVwZW5kVGV4dFZpZXcgPSBwcmVwZW5kTmV3VmlldyhUZXh0Vmlldyk7XG5cbi8qKlxuICogQXBwZW5kIGFueSB2aWV3IHRvIHRoZSBub3RlYm9vay4gU2V0cyB1cCBhIGZldyBsaXN0ZW5lcnMgb24gZXZlcnkgdmlld1xuICogaW5zdGFuY2UgYW5kIG1hbmFnZXMgaW50ZXJhY3Rpb25zIGJldHdlZW4gY2VsbHMuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSAgIHZpZXdcbiAqIEBwYXJhbSAge05vZGV9ICAgICBiZWZvcmVcbiAqIEByZXR1cm4ge05vdGVib29rfVxuICovXG5Ob3RlYm9vay5wcm90b3R5cGUuYXBwZW5kVmlldyA9IGZ1bmN0aW9uICh2aWV3LCBiZWZvcmUpIHtcbiAgaWYgKHZpZXcgaW5zdGFuY2VvZiBFZGl0b3JWaWV3KSB7XG4gICAgdGhpcy5saXN0ZW5Ubyh2aWV3LCAnbW92ZVVwJywgZnVuY3Rpb24gKHZpZXcpIHtcbiAgICAgIGlmICghdmlldy5lbC5wcmV2aW91c1NpYmxpbmcpIHsgcmV0dXJuOyB9XG5cbiAgICAgIHZpZXcuZWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodmlldy5lbCwgdmlldy5lbC5wcmV2aW91c1NpYmxpbmcpO1xuICAgICAgdGhpcy5jb2xsZWN0aW9uLnNvcnQoKTtcbiAgICAgIHZpZXcudXBkYXRlKCkuZm9jdXMoKTtcbiAgICB9KTtcblxuICAgIHRoaXMubGlzdGVuVG8odmlldywgJ21vdmVEb3duJywgZnVuY3Rpb24gKHZpZXcpIHtcbiAgICAgIGlmICghdmlldy5lbC5uZXh0U2libGluZykgeyByZXR1cm47IH1cblxuICAgICAgaW5zZXJ0QWZ0ZXIodmlldy5lbCwgdmlldy5lbC5uZXh0U2libGluZyk7XG4gICAgICB2aWV3LmZvY3VzKCk7XG4gICAgICB0aGlzLmNvbGxlY3Rpb24uc29ydCgpO1xuICAgICAgdGhpcy5nZXRQcmV2Vmlldyh2aWV3KS51cGRhdGUoKTtcbiAgICB9KTtcblxuICAgIHRoaXMubGlzdGVuVG8odmlldywgJ25ld1RleHRBYm92ZScsIGZ1bmN0aW9uICh2aWV3KSB7XG4gICAgICB2YXIgbmV3VmlldyA9IHRoaXMucHJlcGVuZFRleHRWaWV3KHZpZXcuZWwpLnJlZnJlc2goKS5mb2N1cygpO1xuXG4gICAgICBuZXdWaWV3LnVwZGF0ZSgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5saXN0ZW5Ubyh2aWV3LCAnbmV3Q29kZUFib3ZlJywgZnVuY3Rpb24gKHZpZXcpIHtcbiAgICAgIHZhciBuZXdWaWV3ID0gdGhpcy5wcmVwZW5kQ29kZVZpZXcodmlldy5lbCkucmVmcmVzaCgpLmZvY3VzKCk7XG5cbiAgICAgIG5ld1ZpZXcudXBkYXRlKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmxpc3RlblRvKHZpZXcsICduZXdUZXh0QmVsb3cnLCBmdW5jdGlvbiAodmlldykge1xuICAgICAgdmFyIG5ld1ZpZXcgPSB0aGlzLmFwcGVuZFRleHRWaWV3KHZpZXcuZWwpLnJlZnJlc2goKS5mb2N1cygpO1xuXG4gICAgICBuZXdWaWV3LnVwZGF0ZSgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5saXN0ZW5Ubyh2aWV3LCAnbmV3Q29kZUJlbG93JywgZnVuY3Rpb24gKHZpZXcpIHtcbiAgICAgIHZhciBuZXdWaWV3ID0gdGhpcy5hcHBlbmRDb2RlVmlldyh2aWV3LmVsKS5yZWZyZXNoKCkuZm9jdXMoKTtcblxuICAgICAgbmV3Vmlldy51cGRhdGUoKTtcbiAgICB9KTtcblxuICAgIC8vIExpc3RlbiB0byBjbG9uZSBldmVudHMgYW5kIGFwcGVuZCB0aGUgbmV3IHZpZXdzIGFmdGVyIHRoZSBjdXJyZW50IHZpZXdcbiAgICB0aGlzLmxpc3RlblRvKHZpZXcsICdjbG9uZScsIGZ1bmN0aW9uICh2aWV3LCBjbG9uZSkge1xuICAgICAgdGhpcy5hcHBlbmRWaWV3KGNsb25lLCB2aWV3LmVsKTtcbiAgICAgIC8vIE5lZWQgdG8gd29yayBhcm91bmQgdGhlIGVkaXRvciBiZWluZyByZW1vdmVkIGFuZCBhZGRlZCB3aXRoIHRleHQgY2VsbHNcbiAgICAgIHZhciBjdXJzb3IgPSB2aWV3LmVkaXRvciAmJiB2aWV3LmVkaXRvci5nZXRDdXJzb3IoKTtcbiAgICAgIGNsb25lLmZvY3VzKCkuZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpO1xuICAgICAgY2xvbmUudXBkYXRlKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmxpc3RlblRvKHZpZXcsICdyZW1vdmUnLCBmdW5jdGlvbiAodmlldykge1xuICAgICAgdmFyIG5leHRWaWV3ID0gdGhpcy5nZXROZXh0Vmlldyh2aWV3KSB8fCB0aGlzLmdldFByZXZWaWV3KHZpZXcpO1xuXG4gICAgICB0aGlzLmNvbGxlY3Rpb24ucmVtb3ZlKHZpZXcubW9kZWwpO1xuICAgICAgbWVzc2FnZXMudHJpZ2dlcignY2VsbDpyZW1vdmUnLCB2aWV3KTtcblxuICAgICAgaWYgKG5leHRWaWV3KSB7XG4gICAgICAgIC8vIEZvY3VzIG9uIHRoZSBuZXcgY2VsbCBpbnN0YW5jZS5cbiAgICAgICAgbmV4dFZpZXcudXBkYXRlKCkuZm9jdXMoKS5tb3ZlQ3Vyc29yVG9FbmQoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMubGlzdGVuVG8odmlldywgJ2RlbGV0ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIElmIGl0J3MgdGhlIGxhc3QgY2VsbCBpbiB0aGUgZG9jdW1lbnQsIGFwcGVuZCBhbiBlbXB0eSBjb2RlIGNlbGwuXG4gICAgICBpZiAodGhpcy5jb2xsZWN0aW9uLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRDb2RlVmlldygpLnJlZnJlc2goKS5mb2N1cygpLnNob3dCdXR0b25zQWJvdmUoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIExpc3RlbiBmb3Igc3dpdGNoIGV2ZW50cywgd2hpY2ggaXNuJ3QgYSByZWFsIHN3aXRjaCBidXQgcmVjcmVhdGVzIHRoZVxuICAgIC8vIHZpZXcgdXNpbmcgdGhlIGRhdGEgaXQgaGFzIGF2YWlsYWJsZS4gVGhpcyByZXN1bHRzIGluIHNvbWUgaXNzdWVzLCBidXRcbiAgICAvLyBhdm9pZHMgYSB3aG9sZSBkaWZmZXJlbnQgc2V0IG9mIGlzc3VlcyB0aGF0IHdvdWxkIGFycmlzZSB0cnlpbmcgdG8gY2hhbmdlXG4gICAgLy8gZXZlcnl0aGluZyBvbiB0aGUgZmx5LlxuICAgIHRoaXMubGlzdGVuVG8odmlldywgJ3N3aXRjaCcsIGZ1bmN0aW9uICh2aWV3KSB7XG4gICAgICB2YXIgbmV3VmlldztcblxuICAgICAgaWYgKHZpZXcgaW5zdGFuY2VvZiBUZXh0Vmlldykge1xuICAgICAgICBuZXdWaWV3ID0gdGhpcy5hcHBlbmRDb2RlVmlldyh2aWV3LmVsLCB2aWV3LmdldFZhbHVlKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3VmlldyA9IHRoaXMuYXBwZW5kVGV4dFZpZXcodmlldy5lbCwgdmlldy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGN1cnNvciA9IHZpZXcuZWRpdG9yICYmIHZpZXcuZWRpdG9yLmdldEN1cnNvcigpO1xuXG4gICAgICB2aWV3LmRlbGV0ZSgpO1xuICAgICAgbmV3Vmlldy51cGRhdGUoKS5yZWZyZXNoKCkuZm9jdXMoKTtcblxuICAgICAgaWYgKGN1cnNvcikge1xuICAgICAgICBuZXdWaWV3LmVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMubGlzdGVuVG8odmlldywgJ2Jyb3dzZVVwJywgZnVuY3Rpb24gKHZpZXcpIHtcbiAgICAgIHZhciBwcmV2VmlldyA9IHRoaXMuZ2V0UHJldlZpZXcodmlldyk7XG5cbiAgICAgIGlmIChwcmV2Vmlldykge1xuICAgICAgICBwcmV2Vmlldy5mb2N1cygpLmVkaXRvci5zZXRDdXJzb3Ioe1xuICAgICAgICAgIGxpbmU6IHByZXZWaWV3LmVkaXRvci5sYXN0TGluZSgpLFxuICAgICAgICAgIGNoOiAgIHZpZXcuZWRpdG9yLmdldEN1cnNvcigpLmNoXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5saXN0ZW5Ubyh2aWV3LCAnYnJvd3NlRG93bicsIGZ1bmN0aW9uICh2aWV3KSB7XG4gICAgICB2YXIgbmV4dFZpZXcgPSB0aGlzLmdldE5leHRWaWV3KHZpZXcpO1xuXG4gICAgICBpZiAobmV4dFZpZXcpIHtcbiAgICAgICAgbmV4dFZpZXcuZm9jdXMoKS5lZGl0b3Iuc2V0Q3Vyc29yKHtcbiAgICAgICAgICBsaW5lOiAwLFxuICAgICAgICAgIGNoOiAgIHZpZXcuZWRpdG9yLmdldEN1cnNvcigpLmNoXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gTGlzdGVuaW5nIHRvIGRpZmZlcmVudCBldmVudHMgZm9yIGB0ZXh0YCBjZWxscy5cbiAgaWYgKHZpZXcgaW5zdGFuY2VvZiBUZXh0Vmlldykge1xuICAgIHRoaXMubGlzdGVuVG8odmlldywgJ2JsdXInLCBmdW5jdGlvbiAodmlldykge1xuICAgICAgaWYgKHRoaXMuZWwubGFzdENoaWxkID09PSB2aWV3LmVsKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kQ29kZVZpZXcoKS5yZWZyZXNoKCkuZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIExpc3RlbmluZyB0byBhbm90aGVyIHNldCBvZiBldmVudHMgZm9yIGBjb2RlYCBjZWxscy5cbiAgaWYgKHZpZXcgaW5zdGFuY2VvZiBDb2RlVmlldykge1xuICAgIC8vIExpc3RlbiB0byBleGVjdXRpb24gZXZlbnRzIGZyb20gdGhlIGNoaWxkIHZpZXdzLCB3aGljaCBtYXkgb3IgbWF5IG5vdFxuICAgIC8vIHJlcXVpcmUgbmV3IHdvcmtpbmcgY2VsbHMgdG8gYmUgYXBwZW5kZWQgdG8gdGhlIG5vdGVib29rLlxuICAgIHRoaXMubGlzdGVuVG8odmlldywgJ2V4ZWN1dGUnLCBmdW5jdGlvbiAodmlldykge1xuICAgICAgLy8gUmVmcmVzaCBhbGwgY29tcGxldGlvbiBkYXRhIHdoZW4gYSBjZWxsIGlzIGV4ZWN1dGVkLlxuICAgICAgdGhpcy51cGRhdGVDb21wbGV0aW9uKCk7XG5cbiAgICAgIC8vIE5lZWQgYSBmbGFnIGhlcmUgc28gd2UgZG9uJ3QgY2F1c2UgYW4gaW5maW5pdGUgbG9vcCB3aGVuIGV4ZWN1dGluZyB0aGVcbiAgICAgIC8vIG5vdGVib29rIGNvbnRlbnRzLiAoRS5nLiBIaXR0aW5nIHRoZSBsYXN0IGNlbGwgYW5kIGFkZGluZyBhIG5ldyBjZWxsKS5cbiAgICAgIGlmICh0aGlzLl9leGVjdXRpbmcgfHwgY29uZmlnLmdldCgnZW1iZWRkZWQnKSkgeyByZXR1cm47IH1cblxuICAgICAgaWYgKHRoaXMuZWwubGFzdENoaWxkID09PSB2aWV3LmVsKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kQ29kZVZpZXcoKS5yZWZyZXNoKCkuZm9jdXMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZ2V0TmV4dFZpZXcodmlldykuZm9jdXMoKS5tb3ZlQ3Vyc29yVG9FbmQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHRoaXMuY29sbGVjdGlvbi5wdXNoKHZpZXcubW9kZWwpO1xuXG4gIC8vIEFwcGVuZCB0aGUgdmlldyB0byB0aGUgZW5kIG9mIHRoZSBub3RlYm9vay5cbiAgdmlldy5yZW5kZXIoKS5hcHBlbmRUbyhfLmJpbmQoZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihiZWZvcmUpKSB7XG4gICAgICByZXR1cm4gYmVmb3JlKGVsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmVmb3JlID8gaW5zZXJ0QWZ0ZXIoZWwsIGJlZm9yZSkgOiB0aGlzLmVsLmFwcGVuZENoaWxkKGVsKTtcbiAgfSwgdGhpcykpO1xuXG4gIC8vIFNvcnQgdGhlIGNvbGxlY3Rpb24gZXZlcnkgdGltZSBhIG5vZGUgaXMgYWRkZWQgaW4gYSBkaWZmZXJlbnQgcG9zaXRpb24gdG9cbiAgLy8ganVzdCBiZWluZyBhcHBlbmRlZCBhdCB0aGUgZW5kLlxuICBpZiAoYmVmb3JlKSB7IHRoaXMuY29sbGVjdGlvbi5zb3J0KCk7IH1cblxuICByZXR1cm4gdGhpcztcbn07XG4iLCJ2YXIgXyAgICAgICAgICA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBWaWV3ICAgICAgID0gcmVxdWlyZSgnLi90ZW1wbGF0ZScpO1xudmFyIG1lc3NhZ2VzICAgPSByZXF1aXJlKCcuLi9zdGF0ZS9tZXNzYWdlcycpO1xudmFyIHRlbXBsYXRlICAgPSByZXF1aXJlKCcuLi8uLi90ZW1wbGF0ZXMvdmlld3MvcmVzdWx0LWNlbGwuaGJzJyk7XG52YXIgbWlkZGxld2FyZSA9IHJlcXVpcmUoJy4uL3N0YXRlL21pZGRsZXdhcmUnKTtcblxuLyoqXG4gKiBSZXR1cm4gYSBuZXcgcmVzdWx0IGNlbGwgaW5zdGFuY2UuXG4gKlxuICogQHR5cGUge0Z1bmN0aW9ufVxuICovXG52YXIgUmVzdWx0Q2VsbCA9IG1vZHVsZS5leHBvcnRzID0gVmlldy5leHRlbmQoe1xuICBjbGFzc05hbWU6ICdjZWxsIGNlbGwtcmVzdWx0IGNlbGwtcmVzdWx0LXBlbmRpbmcnXG59KTtcblxuLyoqXG4gKiBBdXRvbWF0aWNhbGx5IHVwZGF0ZSB0aGUgcmVzdWx0IGJvZHkgb24gY2hhbmdlLlxuICovXG5SZXN1bHRDZWxsLnByb3RvdHlwZS5jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1wdHkoKTtcblxuICBpZiAodGhpcy5tb2RlbC5nZXQoJ2lzRXJyb3InKSkge1xuICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZCgncmVzdWx0LWVycm9yJyk7XG4gIH1cblxuICB2YXIgYXR0YWNoRWxlbWVudCAgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5yZXN1bHQtY29udGVudCcpO1xuICB2YXIgbm90ZWJvb2tXaW5kb3cgPSB0aGlzLm1vZGVsLnZpZXcgP1xuICAgIHRoaXMubW9kZWwudmlldy5ub3RlYm9vay5zYW5kYm94LndpbmRvdyA6IHdpbmRvdztcblxuICBtaWRkbGV3YXJlLnRyaWdnZXIoJ3Jlc3VsdDpyZW5kZXInLCB7XG4gICAgZWw6ICAgICAgYXR0YWNoRWxlbWVudCxcbiAgICB3aW5kb3c6ICBub3RlYm9va1dpbmRvdyxcbiAgICBpbnNwZWN0OiB0aGlzLm1vZGVsLmdldCgncmVzdWx0JyksXG4gICAgaXNFcnJvcjogdGhpcy5tb2RlbC5nZXQoJ2lzRXJyb3InKVxuICB9LCBfLmJpbmQoZnVuY3Rpb24gKGVyciwgcmVtb3ZlKSB7XG4gICAgaWYgKHR5cGVvZiByZW1vdmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuX3JlbW92ZSA9IHJlbW92ZTtcbiAgICB9XG5cbiAgICAvLyBBdm9pZCBhbiBlbXB0eSBlbGVtZW50IHdoZW4gcmVuZGVyaW5nIGZhaWxzLlxuICAgIGlmICghYXR0YWNoRWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgYXR0YWNoRWxlbWVudC5pbm5lckhUTUwgPSAnJm5ic3A7JztcbiAgICB9XG5cbiAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoJ2NlbGwtcmVzdWx0LXBlbmRpbmcnKTtcbiAgICBtZXNzYWdlcy50cmlnZ2VyKCdyZXNpemUnKTtcbiAgfSwgdGhpcykpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBUaGUgcmVzdWx0IGNlbGwgdGVtcGxhdGUuXG4gKlxuICogQHR5cGUge0Z1bmN0aW9ufVxuICovXG5SZXN1bHRDZWxsLnByb3RvdHlwZS50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuXG4vKipcbiAqIFJlZnJlc2hlcyB0aGUgcmVzdWx0IGNlbGwgYmFzZWQgb24gdGhlIHBhcmVudCBjZWxsIHZpZXcuXG4gKi9cblJlc3VsdENlbGwucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMubW9kZWwuY29sbGVjdGlvbikge1xuICAgIHRoaXMuZGF0YS5zZXQoJ2luZGV4JywgdGhpcy5tb2RlbC5jb2xsZWN0aW9uLmNvZGVJbmRleE9mKHRoaXMubW9kZWwpKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFbXB0eSB0aGUgcmVzdWx0IGNlbGwuXG4gKi9cblJlc3VsdENlbGwucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAvLyBBbnkgdmlld3MgbXVzdCBzdWJzY3JpYmUgdG8gdGhpcyBBUEkgc3R5bGUuXG4gIGlmICh0aGlzLl9yZW1vdmUpIHtcbiAgICB0aGlzLl9yZW1vdmUoKTtcbiAgICBkZWxldGUgdGhpcy5fcmVtb3ZlO1xuICB9XG5cbiAgLy8gRm9yY2UgdGhlIGVsZW1lbnQgdG8gYmUgY2xlYXJlZC5cbiAgdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcucmVzdWx0LWNvbnRlbnQnKS5pbm5lckhUTUwgPSAnJztcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRW1wdHkgdGhlIGNlbGwgYmVmb3JlIHJlbW92aW5nLlxuICovXG5SZXN1bHRDZWxsLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1wdHkoKTtcbiAgcmV0dXJuIFZpZXcucHJvdG90eXBlLnJlbW92ZS5jYWxsKHRoaXMpO1xufTtcbiIsInZhciBfICAgICAgICAgICA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBWaWV3ICAgICAgICA9IHJlcXVpcmUoJy4vdGVtcGxhdGUnKTtcbnZhciBib3VuY2UgICAgICA9IHJlcXVpcmUoJy4uL2xpYi9ib3VuY2UnKTtcbnZhciBjb25maWcgICAgICA9IHJlcXVpcmUoJy4uL3N0YXRlL2NvbmZpZycpO1xudmFyIG1pZGRsZXdhcmUgID0gcmVxdWlyZSgnLi4vc3RhdGUvbWlkZGxld2FyZScpO1xudmFyIHBlcnNpc3RlbmNlID0gcmVxdWlyZSgnLi4vc3RhdGUvcGVyc2lzdGVuY2UnKTtcbnZhciBub3RpZnlFcnJvciA9IHJlcXVpcmUoJy4uL2xpYi9ub3RpZnktZXJyb3InKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgc2lkZWJhciB2aWV3IGNsYXNzLlxuICpcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqL1xudmFyIFNpZGViYXJWaWV3ID0gbW9kdWxlLmV4cG9ydHMgPSBWaWV3LmV4dGVuZCh7XG4gIGNsYXNzTmFtZTogJ25vdGVib29rLXNpZGViYXInXG59KTtcblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBzaWRlYmFyIHZpZXcuXG4gKi9cblNpZGViYXJWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xuICBWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdGhlIGN1cnJlbnQgbm90ZWJvb2sgaGFzIGJlZW4gc2F2ZWQuXG4gICAqL1xuICB0aGlzLmxpc3RlblRvKHBlcnNpc3RlbmNlLCAnY2hhbmdlOnN0YXRlJywgYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRhdGEuc2V0KCdzYXZlZCcsIHBlcnNpc3RlbmNlLmlzQ3VycmVudFNhdmVkKCkpO1xuICB9LCB0aGlzKSk7XG59O1xuXG4vKipcbiAqIEFuIG9iamVjdCBvZiBhbGwgZXZlbnRzIHRoYXQgdHJpZ2dlciBvbiB0aGUgc2lkZWJhciB2aWV3LlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblNpZGViYXJWaWV3LnByb3RvdHlwZS5ldmVudHMgPSB7XG4gICdjbGljayBbZGF0YS1kZWxldGVdJzogZnVuY3Rpb24gKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblxuICAgIHRoaXMuZGVsZXRlSWQoZS50YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLWRlbGV0ZScpKTtcbiAgfSxcbiAgJ2NsaWNrIFtkYXRhLWxvYWRdJzogZnVuY3Rpb24gKGUsIHRhcmdldCkge1xuICAgIHZhciBpZCA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbG9hZCcpO1xuXG4gICAgLy8gSWYgdGhlIGN1cnJlbnQgbm90ZWJvb2sgaGFzIG5vdCBiZWVuIHNhdmVkIHlldCwgcHJvbXB0IHRoZSB1c2VyLlxuICAgIGlmICghcGVyc2lzdGVuY2UuaXNDdXJyZW50U2F2ZWQoKSkge1xuICAgICAgcmV0dXJuIG1pZGRsZXdhcmUudHJpZ2dlcigndWk6Y29uZmlybScsIHtcbiAgICAgICAgdGl0bGU6ICdZb3UgaGF2ZSB1bnNhdmVkIGNoYW5nZXMuIEFiYW5kb24gY2hhbmdlcz8nLFxuICAgICAgICBjb250ZW50OiAnPHA+JyArXG4gICAgICAgICAgJ1NhdmUgeW91ciB3b3JrIGJ5IHByZXNzaW5nIFxcJ0NhbmNlbFxcJyBhbmQgJyArXG4gICAgICAgICAgJ3RoZW4gY2xpY2tpbmcgdGhlIHNhdmUgaWNvbiBpbiB0aGUgdG9vbGJhciBvciB1c2luZyAnICtcbiAgICAgICAgICAndGhlIGtleXN0cm9rZSBDTUQgKyBTIChvciBDVFJMICsgUykuJyArXG4gICAgICAgICAgJzwvcD4nICtcbiAgICAgICAgICAnPHA+JyArXG4gICAgICAgICAgJ1ByZXNzIFxcJ09LXFwnIHRvIGFiYW5kb24gdGhpcyBub3RlYm9vay4gJyArXG4gICAgICAgICAgJ1lvdXIgY2hhbmdlcyB3aWxsIGJlIGxvc3QuJyArXG4gICAgICAgICAgJzwvcD4nXG4gICAgICB9LCBfLmJpbmQoZnVuY3Rpb24gKGVyciwgY29uZmlybWVkKSB7XG4gICAgICAgIGlmIChlcnIgfHwgIWNvbmZpcm1lZCkgeyByZXR1cm47IH1cblxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVJZChpZCk7XG4gICAgICB9LCB0aGlzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMudXBkYXRlSWQoaWQpO1xuICB9LFxuICAnY2xpY2sgLnNpZGViYXItdG9nZ2xlJzogZnVuY3Rpb24gKCkge1xuICAgIHZhciBpc09wZW4gPSAhdGhpcy5lbC5jbGFzc0xpc3QuY29udGFpbnMoJ3NpZGViYXItY2xvc2VkJyk7XG5cbiAgICB0aGlzLmVsLmNsYXNzTGlzdFtpc09wZW4gPyAnYWRkJyA6ICdyZW1vdmUnXSgnc2lkZWJhci1jbG9zZWQnKTtcbiAgfSxcbiAgJ2NsaWNrIC5wZXJzaXN0ZW5jZS1hdXRoZW50aWNhdGUnOiAgICdhdXRoZW50aWNhdGUnLFxuICAnY2xpY2sgLnBlcnNpc3RlbmNlLXVuYXV0aGVudGljYXRlJzogJ3VuYXV0aGVudGljYXRlJyxcbiAgJ2NsaWNrIC5zaWRlYmFyLWF1dGhlbnRpY2F0ZSc6IGZ1bmN0aW9uIChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlcXVpcmUgdGhlIHNpZGViYXIgdGVtcGxhdGUuXG4gKlxuICogQHR5cGUge0Z1bmN0aW9ufVxuICovXG5TaWRlYmFyVmlldy5wcm90b3R5cGUudGVtcGxhdGUgPSByZXF1aXJlKCcuLi8uLi90ZW1wbGF0ZXMvdmlld3Mvc2lkZWJhci5oYnMnKTtcblxuLyoqXG4gKiBSZWxvYWQgdGhlIHBlcnNpc3RlbnQgbm90ZWJvb2tzIGxpc3QuXG4gKi9cblNpZGViYXJWaWV3LnByb3RvdHlwZS51cGRhdGVMaXN0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmRhdGEuc2V0KCd1cGRhdGluZycsIHRydWUpO1xuXG4gIHBlcnNpc3RlbmNlLmxpc3QoXy5iaW5kKGZ1bmN0aW9uIChlcnIsIGxpc3QpIHtcbiAgICB0aGlzLmRhdGEuc2V0KCd1cGRhdGluZycsIGZhbHNlKTtcblxuICAgIHJldHVybiB0aGlzLmRhdGEuc2V0KCdsaXN0JywgbGlzdCk7XG4gIH0sIHRoaXMpKTtcbn07XG5cbi8qKlxuICogQWRkIHNvbWUgc2lkZWJhciBoZWxwZXJzLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblNpZGViYXJWaWV3LnByb3RvdHlwZS50ZW1wbGF0ZUhlbHBlcnMgPSB7XG4gIGRhdGVGb3JtYXQ6IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUudG9Mb2NhbGVUaW1lU3RyaW5nKCkgKyAnICcgKyBkYXRlLnRvTG9jYWxlRGF0ZVN0cmluZygpO1xuICB9XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlIHRoZSByZW5kZXIgZnVuY3Rpb24gdG8gbG9hZCB0aGUgaW5pdGlhbCBub3RlYm9vayBsaXN0LlxuICovXG5TaWRlYmFyVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmxpc3RlblRvKHBlcnNpc3RlbmNlLCAnY2hhbmdlOnVzZXJJZCcsIGJvdW5jZSh0aGlzLnVwZGF0ZUxpc3QsIHRoaXMpKTtcblxuICByZXR1cm4gVmlldy5wcm90b3R5cGUucmVuZGVyLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIExvYWQgYW4gaWQgaW50byB0aGUgcGVyc2lzdGVuY2UgbGF5ZXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKi9cblNpZGViYXJWaWV3LnByb3RvdHlwZS51cGRhdGVJZCA9IGZ1bmN0aW9uIChpZCkge1xuICBjb25maWcuc2V0KCdpZCcsIGlkKTtcbiAgdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcuc2lkZWJhci1saXN0Jykuc2Nyb2xsVG9wID0gMDtcbn07XG5cbi8qKlxuICogRGVsZXRlIGFuIGlkIHVzaW5nIHRoZSBwZXJzaXN0ZW5jZSBsYXllci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAqL1xuU2lkZWJhclZpZXcucHJvdG90eXBlLmRlbGV0ZUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gIG1pZGRsZXdhcmUudHJpZ2dlcigndWk6Y29uZmlybScsIHtcbiAgICB0aXRsZTogJ0RlbGV0ZSBOb3RlYm9vaycsXG4gICAgY29udGVudDogJ0FyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBkZWxldGUgdGhpcyBub3RlYm9vaz8nICtcbiAgICAnIERlbGV0ZWQgbm90ZWJvb2tzIGNhbm5vdCBiZSByZXN0b3JlZC4nXG4gIH0sIF8uYmluZChmdW5jdGlvbiAoZXJyLCBjb25maXJtZWQpIHtcbiAgICByZXR1cm4gY29uZmlybWVkICYmIHBlcnNpc3RlbmNlLnJlbW92ZShpZCwgXy5iaW5kKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIG1pZGRsZXdhcmUudHJpZ2dlcigndWk6bm90aWZ5Jywge1xuICAgICAgICAgIHRpdGxlOiAnVW5hYmxlIHRvIGRlbGV0ZSB0aGUgbm90ZWJvb2snLFxuICAgICAgICAgIG1lc3NhZ2U6ICdSZWZyZXNoIGFuZCB0cnkgYWdhaW4nXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocGVyc2lzdGVuY2UuZ2V0KCdub3RlYm9vaycpLmdldCgnaWQnKSA9PT0gaWQpIHtcbiAgICAgICAgdGhpcy51cGRhdGVJZCgnJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBsaXN0SXRlbUVsID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1sb2FkPVwiJyArIGlkICsgJ1wiXScpO1xuICAgICAgcmV0dXJuIGxpc3RJdGVtRWwgJiYgbGlzdEl0ZW1FbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxpc3RJdGVtRWwpO1xuICAgIH0sIHRoaXMpKTtcbiAgfSwgdGhpcykpO1xufTtcblxuLyoqXG4gKiBBdXRoZW50aWNhdGUgdG8gdGhlIG5vdGVib29rIHBlcnNpc3RlbmNlIGxheWVyLlxuICovXG5TaWRlYmFyVmlldy5wcm90b3R5cGUuYXV0aGVudGljYXRlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gcGVyc2lzdGVuY2UuYXV0aGVudGljYXRlKG5vdGlmeUVycm9yKCdMb2dpbiBmYWlsZWQhJykpO1xufTtcblxuLyoqXG4gKiBVbmF1dGhlbnRpY2F0ZSBmcm9tIHRoZSBub3RlYm9vay5cbiAqL1xuU2lkZWJhclZpZXcucHJvdG90eXBlLnVuYXV0aGVudGljYXRlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gcGVyc2lzdGVuY2UudW5hdXRoZW50aWNhdGUobm90aWZ5RXJyb3IoJ0NvdWxkIG5vdCBsb2cgb3V0IScpKTtcbn07XG4iLCJ2YXIgXyAgICA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBWaWV3ID0gcmVxdWlyZSgnLi92aWV3Jyk7XG5cbi8vIFN0YXRlIG1vZHVsZXMgc2hvdWxkIGJlIHByb3ZpZGVkIGFzIHRoZSBkZWZhdWx0IGRhdGEgd2l0aCBldmVyeSB2aWV3LlxudmFyIHN0YXRlICAgICAgID0gcmVxdWlyZSgnLi4vc3RhdGUvc3RhdGUnKTtcbnZhciBjb25maWcgICAgICA9IHJlcXVpcmUoJy4uL3N0YXRlL2NvbmZpZycpO1xudmFyIHBlcnNpc3RlbmNlID0gcmVxdWlyZSgnLi4vc3RhdGUvcGVyc2lzdGVuY2UnKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgdmlldyBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIERPTUJhcnMgdGVtcGxhdGluZyBlbmdpbmUuXG4gKlxuICogQHR5cGUge0Z1bmN0aW9ufVxuICovXG52YXIgVGVtcGxhdGVWaWV3ID0gbW9kdWxlLmV4cG9ydHMgPSBWaWV3LmV4dGVuZCgpO1xuXG4vKipcbiAqIFRoZSB0ZW1wbGF0ZSBwcm9wZXJ0eSBzaG91bGQgYmUgc2V0IG9uIGFueSBleHRlbmRpbmcgdmlld3MsIGFuZCBpcyBleGVjdXRlZFxuICogb24gcmVuZGVyLlxuICpcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqL1xuVGVtcGxhdGVWaWV3LnByb3RvdHlwZS50ZW1wbGF0ZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4vKipcbiAqIEFsbG93IGN1c3RvbSB0ZW1wbGF0ZSBkYXRhIHRvIGJlIHBhc3NlZCBpbnRvIHRoZSB0ZW1wbGF0ZS5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5UZW1wbGF0ZVZpZXcucHJvdG90eXBlLnRlbXBsYXRlRGF0YSA9IHtcbiAgc3RhdGU6ICAgICAgIHN0YXRlLFxuICBjb25maWc6ICAgICAgY29uZmlnLFxuICBwZXJzaXN0ZW5jZTogcGVyc2lzdGVuY2Vcbn07XG5cbi8qKlxuICogQWxsb3cgY3VzdG9tIGhlbHBlcnMgdG8gYmUgcGFzc2VkIGludG8gdGhlIHRlbXBsYXRlIHJlbmRlci5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5UZW1wbGF0ZVZpZXcucHJvdG90eXBlLnRlbXBsYXRlSGVscGVycyA9IHt9O1xuXG4vKipcbiAqIFJlbmRlciB0aGUgdGVtcGxhdGUgdXNpbmcgdGhlIGVsZW1lbnQgdXNpbmcgdGhlIHRlbXBsYXRlIGZ1bmN0aW9uLlxuICpcbiAqIEByZXR1cm4ge3RoaXN9XG4gKi9cblRlbXBsYXRlVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICBWaWV3LnByb3RvdHlwZS5yZW5kZXIuY2FsbCh0aGlzKTtcblxuICB0aGlzLnJlbmRlcmVkID0gdGhpcy50ZW1wbGF0ZSh0aGlzLm1vZGVsLCB7XG4gICAgZGF0YTogXy5leHRlbmQoe1xuICAgICAgdmlldzogdGhpcyxcbiAgICAgIGRhdGE6IHRoaXMuZGF0YVxuICAgIH0sIHRoaXMudGVtcGxhdGVEYXRhKSxcbiAgICBoZWxwZXJzOiB0aGlzLnRlbXBsYXRlSGVscGVyc1xuICB9KTtcblxuICBpZiAodGhpcy5yZW5kZXJlZC52YWx1ZSkge1xuICAgIHRoaXMuZWwuYXBwZW5kQ2hpbGQodGhpcy5yZW5kZXJlZC52YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVW5zdWJzY3JpYmUgdGhlIHRlbXBsYXRlIGxpc3RlbmVycyBiZWZvcmUgcmVtb3ZhbC5cbiAqL1xuVGVtcGxhdGVWaWV3LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnJlbmRlcmVkKSB7XG4gICAgdGhpcy5yZW5kZXJlZC51bnN1YnNjcmliZSgpO1xuICAgIGRlbGV0ZSB0aGlzLnJlbmRlcmVkO1xuICB9XG5cbiAgcmV0dXJuIFZpZXcucHJvdG90eXBlLnJlbW92ZS5jYWxsKHRoaXMpO1xufTtcbiIsInZhciBfICAgICAgICAgICAgPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgbWFya2VkICAgICAgID0gcmVxdWlyZSgnbWFya2VkJyk7XG52YXIgZG9taWZ5ICAgICAgID0gcmVxdWlyZSgnZG9taWZ5Jyk7XG52YXIgRWRpdG9yQ2VsbCAgID0gcmVxdWlyZSgnLi9lZGl0b3ItY2VsbCcpO1xudmFyIGNvbmZpZyAgICAgICA9IHJlcXVpcmUoJy4uL3N0YXRlL2NvbmZpZycpO1xudmFyIG1lc3NhZ2VzICAgICA9IHJlcXVpcmUoJy4uL3N0YXRlL21lc3NhZ2VzJyk7XG52YXIgZW1iZWRQcm90ZWN0ID0gcmVxdWlyZSgnLi9saWIvZW1iZWQtcHJvdGVjdCcpO1xuXG52YXIgYmxvY2tSdWxlcyAgPSBtYXJrZWQuTGV4ZXIucnVsZXM7XG52YXIgaW5saW5lUnVsZXMgPSBtYXJrZWQuSW5saW5lTGV4ZXIucnVsZXM7XG5cbi8qKlxuICogR2V0IGFsbCBwcmV2aW91cyB0ZXh0IHRvIGEgZm9jdXMgbm9kZS5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbnZhciBnZXRQcmV2VGV4dCA9IGZ1bmN0aW9uIChub2RlLCBvZmZzZXQsIGNvbnRhaW5lcikge1xuICB2YXIgdGV4dCA9ICcnO1xuXG4gIGlmICghY29udGFpbmVyLmNvbnRhaW5zKG5vZGUpKSB7XG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cblxuICB0ZXh0ICs9IG5vZGUudGV4dENvbnRlbnQuc3Vic3RyKDAsIG9mZnNldCk7XG5cbiAgd2hpbGUgKG5vZGUgIT09IGNvbnRhaW5lcikge1xuICAgIHZhciB0ZW1wICAgID0gJyc7XG4gICAgdmFyIGN1ck5vZGUgPSBub2RlO1xuICAgIHZhciBzaWJsaW5nID0gKG5vZGUgPSBub2RlLnBhcmVudE5vZGUpLmZpcnN0Q2hpbGQ7XG5cbiAgICB3aGlsZSAoc2libGluZyAhPT0gY3VyTm9kZSkge1xuICAgICAgaWYgKHNpYmxpbmcubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmIHNpYmxpbmcudGFnTmFtZSA9PT0gJ0JSJykge1xuICAgICAgICB0ZW1wICs9ICdcXG4nO1xuICAgICAgfSBlbHNlIGlmIChzaWJsaW5nLm5vZGVUeXBlICE9PSBOb2RlLkNPTU1FTlRfTk9ERSkge1xuICAgICAgICB0ZW1wICs9IHNpYmxpbmcudGV4dENvbnRlbnQ7XG4gICAgICB9XG5cbiAgICAgIHNpYmxpbmcgPSBzaWJsaW5nLm5leHRTaWJsaW5nO1xuICAgIH1cblxuICAgIHRleHQgPSB0ZW1wICsgdGV4dDtcbiAgfVxuXG4gIHJldHVybiB0ZXh0O1xufTtcblxuLyoqXG4gKiBGaW5kIHRoZSB0ZXh0IGVuZCBwb3NpdGlvbiBpbiBhIG1hcmtkb3duIGRvY3VtZW50LlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gdGV4dFxuICogQHBhcmFtICB7U3RyaW5nfSBtYXJrZG93blxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG52YXIgZ2V0VGV4dFBvc2l0aW9uID0gZnVuY3Rpb24gKHRleHQsIG1hcmtkb3duKSB7XG4gIC8vIE1ha2UgYSBjb3B5IG9mIHRoZSBtYXJrZG93biB3aGljaCB3aWxsIGJlIGVkaXRlZCBhcyB3ZSBtb3ZlIGFsb25nLlxuICB2YXIgc291cmNlICAgPSBtYXJrZG93bjtcbiAgdmFyIHBvc2l0aW9uID0gMDtcbiAgdmFyIGluZGV4ICAgID0gMDtcbiAgdmFyIG07XG5cbiAgd2hpbGUgKGluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICBpZiAodGV4dFtpbmRleF0gPT09IHNvdXJjZVswXSkge1xuICAgICAgaW5kZXgrKztcbiAgICAgIHBvc2l0aW9uKys7XG4gICAgICBzb3VyY2UgPSBzb3VyY2Uuc3Vic3RyKDEpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gRGV0ZWN0IGhlYWRpbmdzLlxuICAgIGlmIChtID0gL14oICojezEsNn0gKikoW15cXG5dKz8pICojKiAqKD86XFxuK3wkKS8uZXhlYyhzb3VyY2UpKSB7XG4gICAgICBpZiAoaW5kZXggKyBtWzJdLmxlbmd0aCA+IHRleHQubGVuZ3RoKSB7XG4gICAgICAgIHBvc2l0aW9uICs9IG1bMV0ubGVuZ3RoICsgdGV4dC5sZW5ndGggLSBpbmRleDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGluZGV4ICs9IG1bMl0ubGVuZ3RoICsgMTtcbiAgICAgIHBvc2l0aW9uICs9IG1bMF0ubGVuZ3RoO1xuICAgICAgc291cmNlID0gc291cmNlLnN1YnN0cihtWzBdLmxlbmd0aCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBDb3JyZWN0IGxpbmtzLCBpbWFnZXMsIGF1dG9saW5rcy5cbiAgICBpZiAobSA9IChcbiAgICAgIGlubGluZVJ1bGVzLmxpbmsuZXhlYyhzb3VyY2UpIHx8XG4gICAgICBpbmxpbmVSdWxlcy5yZWZsaW5rLmV4ZWMoc291cmNlKSB8fFxuICAgICAgaW5saW5lUnVsZXMuYXV0b2xpbmsuZXhlYyhzb3VyY2UpXG4gICAgKSkge1xuICAgICAgLy8gSWdub3JlIGltYWdlcyBpbiB0aGUgb3V0cHV0LlxuICAgICAgaWYgKG1bMF0uY2hhckF0KDApID09PSAnIScpIHtcbiAgICAgICAgcG9zaXRpb24gKz0gbVswXS5sZW5ndGg7XG4gICAgICAgIHNvdXJjZSA9IHNvdXJjZS5zdWJzdHIobVswXS5sZW5ndGgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gSGFuZGxlIHRoZSBjbGljayBwb3NpdGlvbiBpbnNpZGUgdGhlIGxpbmsuXG4gICAgICBpZiAoaW5kZXggKyBtWzFdLmxlbmd0aCA+IHRleHQubGVuZ3RoKSB7XG4gICAgICAgIHBvc2l0aW9uICs9IHRleHQubGVuZ3RoIC0gaW5kZXggKyAxO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaW5kZXggKz0gbVsxXS5sZW5ndGg7XG4gICAgICBwb3NpdGlvbiArPSBtWzBdLmxlbmd0aDtcbiAgICAgIHNvdXJjZSA9IHNvdXJjZS5zdWJzdHIobVswXS5sZW5ndGgpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gQ29ycmVjdCBjb2RlIGluZGVudGF0aW9uLlxuICAgIGlmIChtID0gYmxvY2tSdWxlcy5jb2RlLmV4ZWMoc291cmNlKSkge1xuICAgICAgcG9zaXRpb24gKz0gNDtcbiAgICAgIHNvdXJjZSA9IHNvdXJjZS5zdWJzdHIoNCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBTa2lwIG92ZXIgaGVhZGluZyB1bmRlcmxpbmVzLCBkZWZpbml0aW9ucywgYmxvY2sgcXVvdGVzLCBjb2RlIGZlbmNlcyxcbiAgICAvLyBsaXN0cywgZWxlbWVudCB0YWdzLlxuICAgIGlmIChtID0gKFxuICAgICAgLyAqWz1cXC1dezIsfSAqKD86XFxuK3wkKS8uZXhlYyhzb3VyY2UpIHx8XG4gICAgICBibG9ja1J1bGVzLmRlZi5leGVjKHNvdXJjZSkgfHxcbiAgICAgIC9eICo+ICovLmV4ZWMoc291cmNlKSB8fFxuICAgICAgL14gKig/OmB7Myx9fH57Myx9KSAqKD86XFxTKyk/ICpcXG4vLmV4ZWMoc291cmNlKSB8fFxuICAgICAgL14oPzpbKistXXxcXGQrXFwuKSAqLy5leGVjKHNvdXJjZSkgfHxcbiAgICAgIGJsb2NrUnVsZXMuaHIuZXhlYyhzb3VyY2UpIHx8XG4gICAgICBpbmxpbmVSdWxlcy50YWcuZXhlYyhzb3VyY2UpXG4gICAgKSkge1xuICAgICAgcG9zaXRpb24gKz0gbVswXS5sZW5ndGg7XG4gICAgICBzb3VyY2UgPSBzb3VyY2Uuc3Vic3RyKG1bMF0ubGVuZ3RoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIEZpeCBlbSwgc3Ryb25nIGFuZCBjb2RlIGVsZW1lbnRzLiBNYXRjaGVzIHVwIHRvIGZvdXIgdGltZXMgc2luY2VcbiAgICAvLyB0aGUgbWFya2VkIHBhcnNlciBpcyBraW5kIG9mIHJlbGF4ZWQgb24gdGhpcy5cbiAgICBpZiAobSA9IChcbiAgICAgIC9eKFtcXCpfXXsxLDR9KShbXFwqX117MCw0fSkoW1xcc1xcU10rPylcXDJcXDEoPyFcXDEpLy5leGVjKHNvdXJjZSkgfHxcbiAgICAgIC9eKGArKShcXHMqKShbXFxzXFxTXSo/W15gXSlcXHMqXFwxKD8hYCkvLmV4ZWMoc291cmNlKVxuICAgICkpIHtcbiAgICAgIGlmIChpbmRleCArIG1bM10ubGVuZ3RoID4gdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgcG9zaXRpb24gKz0gdGV4dC5sZW5ndGggLSBpbmRleCArIG1bMV0ubGVuZ3RoICsgbVsyXS5sZW5ndGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpbmRleCArPSBtWzNdLmxlbmd0aDtcbiAgICAgIHBvc2l0aW9uICs9IG1bMF0ubGVuZ3RoO1xuICAgICAgc291cmNlID0gc291cmNlLnN1YnN0cihtWzBdLmxlbmd0aCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBTa2lwIG92ZXIgZXNjYXBlIGNoYXJhY3RlcnMuXG4gICAgaWYgKG0gPSBpbmxpbmVSdWxlcy5lc2NhcGUuZXhlYyhzb3VyY2UpKSB7XG4gICAgICBwb3NpdGlvbiArPSAxO1xuICAgICAgc291cmNlID0gc291cmNlLnN1YnN0cigxKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIEZpeCB0cmFpbGluZyBzcGFjZXMgYXQgZW5kIG9mIGxpbmVzIGluIG1hcmtkb3duLlxuICAgIGlmIChtID0gLyggKykoPzpcXG58JCkvLmV4ZWMoc291cmNlKSkge1xuICAgICAgc291cmNlID0gc291cmNlLnN1YnN0cihtWzFdLmxlbmd0aCk7XG4gICAgICBwb3NpdGlvbiArPSBtWzFdLmxlbmd0aDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIEZpeCBzcGFjaW5nIGJldHdlZW4gZWxlbWVudHMgaW4gcGFyc2VkIG1hcmtkb3duIG91dHB1dC5cbiAgICBpZiAodGV4dC5jaGFyQXQoaW5kZXgpID09PSAnXFxuJykge1xuICAgICAgaW5kZXggKz0gMTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGJyZWFrO1xuICB9XG5cbiAgdmFyIGxpbmUgPSAwO1xuXG4gIHZhciBjaCA9IG1hcmtkb3duLnN1YnN0cigwLCBwb3NpdGlvbikucmVwbGFjZSgvLipcXHI/XFxuL2csIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbGluZSsrLCAnJztcbiAgfSkubGVuZ3RoO1xuXG4gIHJldHVybiB7XG4gICAgY2g6ICAgY2gsXG4gICAgbGluZTogbGluZVxuICB9O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgdGV4dCBjZWxsIGluc3RhbmNlLlxuICpcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqL1xudmFyIFRleHRDZWxsID0gbW9kdWxlLmV4cG9ydHMgPSBFZGl0b3JDZWxsLmV4dGVuZCh7XG4gIGNsYXNzTmFtZTogJ2NlbGwgY2VsbC10ZXh0J1xufSk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgdGV4dCBjZWxsIGFuZCBzZXQgZGVmYXVsdCBvcHRpb25zLlxuICovXG5UZXh0Q2VsbC5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgRWRpdG9yQ2VsbC5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIHRoaXMubGlzdGVuVG8oY29uZmlnLCAndGV4dFJlYWRPbmx5JywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGF0YS5zZXQoJ3JlYWRPbmx5JywgIWNvbmZpZy5nZXQoJ3RleHRSZWFkT25seScpKTtcbiAgICB0aGlzLnJlbmRlckVkaXRvcigpO1xuICB9KTtcbn07XG5cbi8qKlxuICogRGVmYXVsdCBjZWxsIG1vZGVsIGF0dHJpYnV0ZXMuXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuVGV4dENlbGwucHJvdG90eXBlLmNlbGxBdHRyaWJ1dGVzID0ge1xuICB0eXBlOiAndGV4dCdcbn07XG5cbi8qKlxuICogTGlzdGVuIGZvciBldmVudHMgb24gdGV4dCBjZWxsIGluc3RhbmNlcy5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5UZXh0Q2VsbC5wcm90b3R5cGUuZXZlbnRzID0gXy5leHRlbmQoe1xuICAnY2xpY2sgLm1hcmtkb3duJzogZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAodGhpcy5oYXNGb2N1cygpIHx8IF8uY29udGFpbnMoWydBJywgJ0JVVFRPTiddLCBlLnRhcmdldC50YWdOYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgdmFyIHBvc2l0aW9ucyA9IHRoaXMuZ2V0UG9zaXRpb25zKHNlbGVjdGlvbiwgdGhpcy5tb2RlbC5nZXQoJ3ZhbHVlJykpO1xuXG4gICAgcmV0dXJuIHRoaXMuZm9jdXMocG9zaXRpb25zKTtcbiAgfVxufSwgRWRpdG9yQ2VsbC5wcm90b3R5cGUuZXZlbnRzKTtcblxuLyoqXG4gKiBPcHRpb25zIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIENvZGVNaXJyb3IgaW5zdGFuY2UuXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuVGV4dENlbGwucHJvdG90eXBlLmVkaXRvck9wdGlvbnMgPSBfLmV4dGVuZChcbiAge30sXG4gIEVkaXRvckNlbGwucHJvdG90eXBlLmVkaXRvck9wdGlvbnMsXG4gIHtcbiAgICBtb2RlOiAnZ2ZtJyxcbiAgICB0aGVtZTogJ3RleHQtY2VsbCdcbiAgfVxuKTtcblxuLyoqXG4gKiBCaW5kcyB0aGUgQ29kZU1pcnJvciBpbnN0YW5jZSB3aXRoIGFueSBsaXN0ZW5lcnMuXG4gKlxuICogQHJldHVybiB7VGV4dENlbGx9XG4gKi9cblRleHRDZWxsLnByb3RvdHlwZS5iaW5kRWRpdG9yID0gZnVuY3Rpb24gKCkge1xuICBFZGl0b3JDZWxsLnByb3RvdHlwZS5iaW5kRWRpdG9yLmNhbGwodGhpcyk7XG5cbiAgLy8gTGlzdGVuIHRvIGl0c2VsZiBzaW5jZSBlZGl0b3IgY2VsbHMgaGF2ZSBhIGJ1aWx0IGluIHByb3RlY3Rpb24gaGVyZS5cbiAgdGhpcy5saXN0ZW5Ubyh0aGlzLCAnYmx1cicsIHRoaXMucmVuZGVyRWRpdG9yKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRm9jdXMgdGhlIHRleHQgY2VsbCBpbnN0YW5jZS4gUmVuZGVyIHRoZSBDb2RlTWlycm9yIGluc3RhbmNlLlxuICpcbiAqIEByZXR1cm4ge1RleHRDZWxsfVxuICovXG5UZXh0Q2VsbC5wcm90b3R5cGUuZm9jdXMgPSBlbWJlZFByb3RlY3QoZnVuY3Rpb24gKGN1cnNvcikge1xuICBFZGl0b3JDZWxsLnByb3RvdHlwZS5yZW5kZXJFZGl0b3IuY2FsbCh0aGlzKTtcbiAgdGhpcy5lZGl0b3IuZm9jdXMoKTtcblxuICAvLyBTZXQgdGhlIGNsb3Nlc3QgY3Vyc29yIHBvc2l0aW9ucy5cbiAgaWYgKGN1cnNvcikge1xuICAgIHRoaXMuZWRpdG9yLmRvYy5zZXRTZWxlY3Rpb24oY3Vyc29yLnN0YXJ0LCBjdXJzb3IuZW5kKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufSk7XG5cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHBvc2l0aW9ucyBvZiBhIHNlbGVjdGlvbiBub2RlIHJlbGF0aXZlIHRvIG1hcmtkb3duIHRleHQuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5UZXh0Q2VsbC5wcm90b3R5cGUuZ2V0UG9zaXRpb25zID0gZnVuY3Rpb24gKHNlbGVjdGlvbikge1xuICB2YXIgZm9jdXNUZXh0LCBhbmNob3JUZXh0O1xuXG4gIHZhciBwb3NpdGlvbnMgICAgPSB7fTtcbiAgdmFyIGFuY2hvck5vZGUgICA9IHNlbGVjdGlvbi5hbmNob3JOb2RlO1xuICB2YXIgZm9jdXNOb2RlICAgID0gc2VsZWN0aW9uLmZvY3VzTm9kZTtcbiAgdmFyIGFuY2hvck9mZnNldCA9IHNlbGVjdGlvbi5hbmNob3JPZmZzZXQ7XG4gIHZhciBmb2N1c09mZnNldCAgPSBzZWxlY3Rpb24uZm9jdXNPZmZzZXQ7XG5cbiAgLy8gR2V0IHRoZSB0ZXh0IGxlYWRpbmcgdXAgdG8gdGhlIGZvY3VzIG5vZGUuXG4gIGZvY3VzVGV4dCA9IGdldFByZXZUZXh0KGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQsIHRoaXMubWFya2Rvd25FbGVtZW50KTtcbiAgcG9zaXRpb25zLmVuZCA9IGdldFRleHRQb3NpdGlvbihmb2N1c1RleHQsIHRoaXMuZ2V0VmFsdWUoKSk7XG5cbiAgaWYgKGFuY2hvck5vZGUgPT09IGZvY3VzTm9kZSAmJiBhbmNob3JPZmZzZXQgPT09IGZvY3VzT2Zmc2V0KSB7XG4gICAgYW5jaG9yVGV4dCA9IGZvY3VzVGV4dDtcbiAgICBwb3NpdGlvbnMuc3RhcnQgPSBwb3NpdGlvbnMuZW5kO1xuICB9IGVsc2Uge1xuICAgIGFuY2hvclRleHQgPSBnZXRQcmV2VGV4dChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIHRoaXMubWFya2Rvd25FbGVtZW50KTtcbiAgICBwb3NpdGlvbnMuc3RhcnQgPSBnZXRUZXh0UG9zaXRpb24oYW5jaG9yVGV4dCwgdGhpcy5nZXRWYWx1ZSgpKTtcbiAgfVxuXG4gIHJldHVybiBwb3NpdGlvbnM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgdmFsdWUgb2YgdGhlIHRleHQgY2VsbC4gU3dpdGNoZXMgYmV0d2VlbiB1cGRhdGluZyB0aGUgQ29kZU1pcnJvciB2aWV3XG4gKiBhbmQgdGhlIE1hcmtkb3duIHJlbmRlcmVkIHByZXZpZXcuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSAgIHZhbHVlXG4gKiBAcmV0dXJuIHtUZXh0Q2VsbH1cbiAqL1xuVGV4dENlbGwucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIEVkaXRvckNlbGwucHJvdG90eXBlLnNldFZhbHVlLmNhbGwodGhpcywgdmFsdWUpO1xuXG4gIHJldHVybiB0aGlzLnJlbmRlckVkaXRvcigpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIHJlbmRlcmVkIE1hcmtkb3duIGNlbGwgYW5kIHBvdGVudGlhbCBlZGl0b3IgaW5zdGFuY2UuXG4gKlxuICogQHJldHVybiB7VGV4dENlbGx9XG4gKi9cblRleHRDZWxsLnByb3RvdHlwZS5yZW1vdmVFZGl0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLm1hcmtkb3duRWxlbWVudCkge1xuICAgIHRoaXMubWFya2Rvd25FbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5tYXJrZG93bkVsZW1lbnQpO1xuICAgIGRlbGV0ZSB0aGlzLm1hcmtkb3duRWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiBFZGl0b3JDZWxsLnByb3RvdHlwZS5yZW1vdmVFZGl0b3IuY2FsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgdGhlIGVkaXRvciB3aXRoIGEgbWFya2Rvd24gdmlld2VyLlxuICpcbiAqIEByZXR1cm4ge1RleHRDZWxsfVxuICovXG5UZXh0Q2VsbC5wcm90b3R5cGUucmVuZGVyRWRpdG9yID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJlbW92ZUVkaXRvcigpO1xuXG4gIHRoaXMubWFya2Rvd25FbGVtZW50ID0gdGhpcy5lbC5pbnNlcnRCZWZvcmUoXG4gICAgZG9taWZ5KCc8ZGl2IGNsYXNzPVwibWFya2Rvd25cIj48L2Rpdj4nKSwgdGhpcy5lbC5maXJzdENoaWxkXG4gICk7XG5cbiAgbWFya2VkKHRoaXMuZ2V0VmFsdWUoKSwge1xuICAgIGdmbTogdHJ1ZSxcbiAgICAvLyBoaWdobGlnaHQ6IGZ1bmN0aW9uICgpIHt9LFxuICAgIHRhYmxlczogdHJ1ZSxcbiAgICBicmVha3M6IHRydWUsXG4gICAgcGVkYW50aWM6IGZhbHNlLFxuICAgIHNhbml0aXplOiBmYWxzZSxcbiAgICBzbWFydExpc3RzOiB0cnVlLFxuICAgIHNtYXJ0eXBhbnRzOiBmYWxzZSxcbiAgICBsYW5nUHJlZml4OiAnbGFuZy0nXG4gIH0sIF8uYmluZChmdW5jdGlvbiAoZXJyLCBodG1sKSB7XG4gICAgdGhpcy5tYXJrZG93bkVsZW1lbnQuaW5uZXJIVE1MID0gaHRtbDtcbiAgfSwgdGhpcykpO1xuXG4gIG1lc3NhZ2VzLnRyaWdnZXIoJ3Jlc2l6ZScpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcbiIsInZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHZpZXcgaW5zdGFuY2UuIFRoaXMgaXMgdGhlIGJhc2UgdmlldyBpbnN0YW5jZSBzbyBhbnkgZ2VuZXJpY1xuICogdmlldyBtZXRob2RzIG9yIGZ1bmN0aW9uYWxpdHkgc2hvdWxkIGJlIGFkZGVkIGhlcmUuXG4gKlxuICogQHR5cGUge0Z1bmN0aW9ufVxuICovXG52YXIgVmlldyA9IG1vZHVsZS5leHBvcnRzID0gQmFja2JvbmUuVmlldy5leHRlbmQoKTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGV2ZXJ5IHZpZXcgd2l0aCBhIHByaXZhdGUgZGF0YSBjb2xsZWN0aW9uLiBUaGlzIGFsbG93cyB2aWV3cyB0b1xuICogaG9sZCB2aWV3IHNwZWNpZmljIGxvZ2ljIHRoYXQgZG9lc24ndCBiZWxvbmcgd2l0aCBhIG1vZGVsLlxuICovXG5WaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmRhdGEgPSBuZXcgQmFja2JvbmUuTW9kZWwoe1xuICAgIHJlbmRlcmVkOiBmYWxzZVxuICB9KTtcbn07XG5cbi8qKlxuICogUmVuZGVyIHRoZSB2aWV3IGluc3RhbmNlLlxuICpcbiAqIEByZXR1cm4ge3RoaXN9XG4gKi9cblZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbC5pbm5lckhUTUwgPSAnJztcbiAgdGhpcy5kZWxlZ2F0ZUV2ZW50cygpO1xuICB0aGlzLmRhdGEuc2V0KCdyZW5kZXJlZCcsIHRydWUpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSB2aWV3IGluc3RhbmNlIGZyb20gdGhlIERPTS5cbiAqXG4gKiBAcmV0dXJuIHt0aGlzfVxuICovXG5WaWV3LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRyaWdnZXIgdGhlIGByZW1vdmVgIGV2ZW50IGJlZm9yZSBhY3R1YWxseSByZW1vdmluZyB0aGUgdmlldyBzaW5jZSB3ZSBtYXlcbiAgLy8gbmVlZCB0byBhcHBlbmQgYSBuZXcgZWxlbWVudCBhZnRlcndhcmQsIGV0Yy5cbiAgdGhpcy50cmlnZ2VyKCdyZW1vdmUnLCB0aGlzKTtcbiAgQmFja2JvbmUuVmlldy5wcm90b3R5cGUucmVtb3ZlLmNhbGwodGhpcyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBJbnNlcnQgYW4gZWxlbWVudCBsYXN0IGluIHRoZSBsaXN0IG9mIGNoaWxkIG5vZGVzIG9mIHRoaXMgdmlldy5cbiAqXG4gKiBAcGFyYW0gIHtOb2RlfSBlbCBUaGUgZWxlbWVudCB0byBhcHBlbmQgdGhpcyB2aWV3IHRvLlxuICogQHJldHVybiB7dGhpc31cbiAqL1xuVmlldy5wcm90b3R5cGUuYXBwZW5kVG8gPSBmdW5jdGlvbiAoZWwpIHtcbiAgaWYgKHR5cGVvZiBlbC5hcHBlbmRDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGVsLmFwcGVuZENoaWxkKHRoaXMuZWwpO1xuICB9IGVsc2Uge1xuICAgIGVsLmNhbGwodGhpcywgdGhpcy5lbCk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEluc2VydCBhbiBlbGVtZW50IGZpcnN0IGluIHRoZSBsaXN0IG9mIGNoaWxkIG5vZGVzIG9mIHRoaXMgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gIHtOb2RlfSBlbCBUaGUgZWxlbWVudCB0byBwcmVwZW5kIHRoaXMgdmlldyB0by5cbiAqIEByZXR1cm4ge3RoaXN9XG4gKi9cblZpZXcucHJvdG90eXBlLnByZXBlbmRUbyA9IGZ1bmN0aW9uIChlbCkge1xuICByZXR1cm4gdGhpcy5hcHBlbmRUby5jYWxsKHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICBlbC5pbnNlcnRCZWZvcmUodGhpcy5lbCwgZWwuZmlyc3RDaGlsZCk7XG4gIH0pO1xufTtcbiIsIi8vIERPTUJhcnNpZnkgY29tcGlsZWQgdGVtcGxhdGVcbnZhciBET01CYXJzID0gcmVxdWlyZShcImRvbWJhcnMvcnVudGltZVwiKTtcbm1vZHVsZS5leHBvcnRzID0gRE9NQmFycy50ZW1wbGF0ZShmdW5jdGlvbiAoSGFuZGxlYmFycyxkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gIHRoaXMuY29tcGlsZXJJbmZvID0gWzQsJz49IDEuMC4wJ107XG5oZWxwZXJzID0gdGhpcy5tZXJnZShoZWxwZXJzLCBIYW5kbGViYXJzLmhlbHBlcnMpOyBkYXRhID0gZGF0YSB8fCB7fTtcbiAgdmFyIGJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgc3RhY2sxLCBzdGFjazIsIGVsZW1lbnQxLCBnZXQ9dGhpcy5nZXQsIGZ1bmN0aW9uVHlwZT1cImZ1bmN0aW9uXCIsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uLCBhcHBlbmRDaGlsZD10aGlzLmFwcGVuZENoaWxkLCBzZWxmPXRoaXMsIHBhcnRpYWw9dGhpcy5wYXJ0aWFsLCBjcmVhdGVFbGVtZW50PXRoaXMuY3JlYXRlRWxlbWVudCwgc2V0QXR0cmlidXRlPXRoaXMuc2V0QXR0cmlidXRlLCBjcmVhdGVUZXh0PXRoaXMuY3JlYXRlVGV4dCwgd3JhcFByb2dyYW09dGhpcy53cmFwUHJvZ3JhbSwgY3JlYXRlRE9NPXRoaXMuY3JlYXRlRE9NLCBoZWxwZXJNaXNzaW5nPWhlbHBlcnMuaGVscGVyTWlzc2luZztcblxuZnVuY3Rpb24gcHJvZ3JhbTEoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIHN0YWNrMSwgZWxlbWVudDEsIGVsZW1lbnQyO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICBcIikpO1xuICBzdGFjazEgPSBlbGVtZW50MSA9IGNyZWF0ZUVsZW1lbnQocGFydGlhbChzZWxmLnByb2dyYW0oMiwgcHJvZ3JhbTIsIGRhdGEpLCBkZXB0aDApLCBmdW5jdGlvbiAoZWwpIHsgZWxlbWVudDEgPSBlbDsgfSk7XG4gIHNldEF0dHJpYnV0ZShmdW5jdGlvbiAoKSB7IHJldHVybiBlbGVtZW50MTsgfSwgcGFydGlhbChzZWxmLnByb2dyYW0oNCwgcHJvZ3JhbTQsIGRhdGEpLCBkZXB0aDApLCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSg2LCBwcm9ncmFtNiwgZGF0YSksIGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChlbGVtZW50MSwgc2VsZi5wcm9ncmFtKDgsIHByb2dyYW04LCBkYXRhKShkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBzdGFjazEpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuXFxuICBcIikpO1xuICBzdGFjazEgPSBlbGVtZW50MiA9IGNyZWF0ZUVsZW1lbnQocGFydGlhbChzZWxmLnByb2dyYW0oMjMsIHByb2dyYW0yMywgZGF0YSksIGRlcHRoMCksIGZ1bmN0aW9uIChlbCkgeyBlbGVtZW50MiA9IGVsOyB9KTtcbiAgc2V0QXR0cmlidXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVsZW1lbnQyOyB9LCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSg0LCBwcm9ncmFtNCwgZGF0YSksIGRlcHRoMCksIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDI1LCBwcm9ncmFtMjUsIGRhdGEpLCBkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoZWxlbWVudDIsIHNlbGYucHJvZ3JhbSgyNywgcHJvZ3JhbTI3LCBkYXRhKShkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBzdGFjazEpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuXCIpKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuZnVuY3Rpb24gcHJvZ3JhbTIoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJoZWFkZXJcIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtNChkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcImNsYXNzXCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTYoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJub3RlYm9vay1oZWFkZXIgY2xlYXJmaXhcIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtOChkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgc3RhY2sxLCBlbGVtZW50MTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICBcIikpO1xuICBzdGFjazEgPSBlbGVtZW50MSA9IGNyZWF0ZUVsZW1lbnQocGFydGlhbChzZWxmLnByb2dyYW0oOSwgcHJvZ3JhbTksIGRhdGEpLCBkZXB0aDApLCBmdW5jdGlvbiAoZWwpIHsgZWxlbWVudDEgPSBlbDsgfSk7XG4gIHNldEF0dHJpYnV0ZShmdW5jdGlvbiAoKSB7IHJldHVybiBlbGVtZW50MTsgfSwgcGFydGlhbChzZWxmLnByb2dyYW0oNCwgcHJvZ3JhbTQsIGRhdGEpLCBkZXB0aDApLCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSgxMSwgcHJvZ3JhbTExLCBkYXRhKSwgZGVwdGgwKSk7XG4gIHNldEF0dHJpYnV0ZShmdW5jdGlvbiAoKSB7IHJldHVybiBlbGVtZW50MTsgfSwgcGFydGlhbChzZWxmLnByb2dyYW0oMTMsIHByb2dyYW0xMywgZGF0YSksIGRlcHRoMCksIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDE1LCBwcm9ncmFtMTUsIGRhdGEpLCBkZXB0aDApKTtcbiAgc2V0QXR0cmlidXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVsZW1lbnQxOyB9LCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSgxNywgcHJvZ3JhbTE3LCBkYXRhKSwgZGVwdGgwKSwgcGFydGlhbChzZWxmLnByb2dyYW0oMTksIHByb2dyYW0xOSwgZGF0YSksIGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChlbGVtZW50MSwgc2VsZi5wcm9ncmFtKDIxLCBwcm9ncmFtMjEsIGRhdGEpKGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIHN0YWNrMSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gIFwiKSk7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cbmZ1bmN0aW9uIHByb2dyYW05KGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwiaW5wdXRcIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtMTEoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJub3RlYm9vay10aXRsZVwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW0xMyhkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcImF1dG9jb21wbGV0ZVwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW0xNShkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcIm9mZlwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW0xNyhkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcInZhbHVlXCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTE5KGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgc3RhY2sxO1xuICByZXR1cm4gZXNjYXBlRXhwcmVzc2lvbigoKHN0YWNrMSA9ICgoc3RhY2sxID0gKChzdGFjazEgPSAoKHN0YWNrMSA9IChkYXRhID09IG51bGwgfHwgZGF0YSA9PT0gZmFsc2UgPyBkYXRhIDogZ2V0KGRhdGEsIFwicGVyc2lzdGVuY2VcIiwgXCJkYXRhXCIpKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IGdldChzdGFjazEsIFwibm90ZWJvb2tcIiwgXCJzdGFjazFcIikpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogZ2V0KHN0YWNrMSwgXCJtZXRhXCIsIFwic3RhY2sxXCIpKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IGdldChzdGFjazEsIFwidGl0bGVcIiwgXCJzdGFjazFcIikpKSx0eXBlb2Ygc3RhY2sxID09PSBmdW5jdGlvblR5cGUgPyBzdGFjazEuYXBwbHkoZGVwdGgwKSA6IHN0YWNrMSkpO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW0yMShkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtMjMoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJkaXZcIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtMjUoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBcIlwiLCBzdGFjazE7XG4gIGJ1ZmZlciArPSBcIm5vdGVib29rLXRvb2xiYXIgY2xlYXJmaXggbm90ZWJvb2stXCJcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChzdGFjazEgPSAoKHN0YWNrMSA9IChkYXRhID09IG51bGwgfHwgZGF0YSA9PT0gZmFsc2UgPyBkYXRhIDogZ2V0KGRhdGEsIFwiZGF0YVwiLCBcImRhdGFcIikpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogZ2V0KHN0YWNrMSwgXCJhY3RpdmVWaWV3XCIsIFwic3RhY2sxXCIpKSksdHlwZW9mIHN0YWNrMSA9PT0gZnVuY3Rpb25UeXBlID8gc3RhY2sxLmFwcGx5KGRlcHRoMCkgOiBzdGFjazEpKVxuICAgICsgXCItYWN0aXZlXCI7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTI3KGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBzdGFjazEsIGVsZW1lbnQxLCBlbGVtZW50MjtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICBcIikpO1xuICBzdGFjazEgPSBlbGVtZW50MSA9IGNyZWF0ZUVsZW1lbnQocGFydGlhbChzZWxmLnByb2dyYW0oMjMsIHByb2dyYW0yMywgZGF0YSksIGRlcHRoMCksIGZ1bmN0aW9uIChlbCkgeyBlbGVtZW50MSA9IGVsOyB9KTtcbiAgc2V0QXR0cmlidXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVsZW1lbnQxOyB9LCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSg0LCBwcm9ncmFtNCwgZGF0YSksIGRlcHRoMCksIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDI4LCBwcm9ncmFtMjgsIGRhdGEpLCBkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoZWxlbWVudDEsIHNlbGYucHJvZ3JhbSgzMCwgcHJvZ3JhbTMwLCBkYXRhKShkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBzdGFjazEpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuXFxuICAgIFwiKSk7XG4gIHN0YWNrMSA9IGVsZW1lbnQyID0gY3JlYXRlRWxlbWVudChwYXJ0aWFsKHNlbGYucHJvZ3JhbSgyMywgcHJvZ3JhbTIzLCBkYXRhKSwgZGVwdGgwKSwgZnVuY3Rpb24gKGVsKSB7IGVsZW1lbnQyID0gZWw7IH0pO1xuICBzZXRBdHRyaWJ1dGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZWxlbWVudDI7IH0sIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDQsIHByb2dyYW00LCBkYXRhKSwgZGVwdGgwKSwgcGFydGlhbChzZWxmLnByb2dyYW0oNDQsIHByb2dyYW00NCwgZGF0YSksIGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChlbGVtZW50Miwgc2VsZi5wcm9ncmFtKDQ2LCBwcm9ncmFtNDYsIGRhdGEpKGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIHN0YWNrMSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gIFwiKSk7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cbmZ1bmN0aW9uIHByb2dyYW0yOChkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcInRvb2xiYXItZW5kXCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTMwKGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBzdGFjazEsIGVsZW1lbnQxO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgXCIpKTtcbiAgc3RhY2sxID0gZWxlbWVudDEgPSBjcmVhdGVFbGVtZW50KHBhcnRpYWwoc2VsZi5wcm9ncmFtKDMxLCBwcm9ncmFtMzEsIGRhdGEpLCBkZXB0aDApLCBmdW5jdGlvbiAoZWwpIHsgZWxlbWVudDEgPSBlbDsgfSk7XG4gIHNldEF0dHJpYnV0ZShmdW5jdGlvbiAoKSB7IHJldHVybiBlbGVtZW50MTsgfSwgcGFydGlhbChzZWxmLnByb2dyYW0oNCwgcHJvZ3JhbTQsIGRhdGEpLCBkZXB0aDApLCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSgzMywgcHJvZ3JhbTMzLCBkYXRhKSwgZGVwdGgwKSk7XG4gIHNldEF0dHJpYnV0ZShmdW5jdGlvbiAoKSB7IHJldHVybiBlbGVtZW50MTsgfSwgcGFydGlhbChzZWxmLnByb2dyYW0oMzUsIHByb2dyYW0zNSwgZGF0YSksIGRlcHRoMCksIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDM3LCBwcm9ncmFtMzcsIGRhdGEpLCBkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoZWxlbWVudDEsIHNlbGYucHJvZ3JhbSgzOSwgcHJvZ3JhbTM5LCBkYXRhKShkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBzdGFjazEpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgIFwiKSk7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cbmZ1bmN0aW9uIHByb2dyYW0zMShkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcImJ1dHRvblwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW0zMyhkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcImVkaXQtc291cmNlIHRvZ2dsZS1ub3RlYm9vayBoaW50LS1ib3R0b21cIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtMzUoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJkYXRhLWhpbnRcIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtMzcoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJFZGl0IHNvdXJjZVwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW0zOShkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgc3RhY2sxLCBlbGVtZW50MTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICAgICAgXCIpKTtcbiAgc3RhY2sxID0gZWxlbWVudDEgPSBjcmVhdGVFbGVtZW50KHBhcnRpYWwoc2VsZi5wcm9ncmFtKDQwLCBwcm9ncmFtNDAsIGRhdGEpLCBkZXB0aDApLCBmdW5jdGlvbiAoZWwpIHsgZWxlbWVudDEgPSBlbDsgfSk7XG4gIHNldEF0dHJpYnV0ZShmdW5jdGlvbiAoKSB7IHJldHVybiBlbGVtZW50MTsgfSwgcGFydGlhbChzZWxmLnByb2dyYW0oNCwgcHJvZ3JhbTQsIGRhdGEpLCBkZXB0aDApLCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSg0MiwgcHJvZ3JhbTQyLCBkYXRhKSwgZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGVsZW1lbnQxLCBzZWxmLnByb2dyYW0oMjEsIHByb2dyYW0yMSwgZGF0YSkoZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgc3RhY2sxKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICAgIFwiKSk7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cbmZ1bmN0aW9uIHByb2dyYW00MChkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcImlcIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtNDIoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJpY29uXCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTQ0KGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwidG9vbGJhci1pbm5lclwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW00NihkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgc3RhY2sxLCBzdGFjazIsIGVsZW1lbnQxO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgXCIpKTtcbiAgc3RhY2sxID0gZnVuY3Rpb24gKCkge1xuICBzdGFjazIgPSBoZWxwZXJzWydpZiddLmNhbGwoZGVwdGgwLCAoKHN0YWNrMSA9IChkYXRhID09IG51bGwgfHwgZGF0YSA9PT0gZmFsc2UgPyBkYXRhIDogZ2V0KGRhdGEsIFwiZGF0YVwiLCBcImRhdGFcIikpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogZ2V0KHN0YWNrMSwgXCJzdGF0ZVRleHRcIiwgXCJzdGFjazFcIikpLCB7aGFzaDp7fSxpbnZlcnNlOndyYXBQcm9ncmFtKHNlbGYubm9vcCksZm46d3JhcFByb2dyYW0oc2VsZi5wcm9ncmFtKDQ3LCBwcm9ncmFtNDcsIGRhdGEpKSxkYXRhOmRhdGEsYXR0cmlidXRlOmZhbHNlLHVwZGF0ZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVwZGF0ZSx1bnN1YnNjcmliZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVuc3Vic2NyaXB0aW9ufSk7XG4gIHJldHVybiBzdGFjazI7XG4gIH07XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgY3JlYXRlRE9NKHN0YWNrMSkpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgXCIpKTtcbiAgc3RhY2sxID0gZWxlbWVudDEgPSBjcmVhdGVFbGVtZW50KHBhcnRpYWwoc2VsZi5wcm9ncmFtKDIzLCBwcm9ncmFtMjMsIGRhdGEpLCBkZXB0aDApLCBmdW5jdGlvbiAoZWwpIHsgZWxlbWVudDEgPSBlbDsgfSk7XG4gIHNldEF0dHJpYnV0ZShmdW5jdGlvbiAoKSB7IHJldHVybiBlbGVtZW50MTsgfSwgcGFydGlhbChzZWxmLnByb2dyYW0oNCwgcHJvZ3JhbTQsIGRhdGEpLCBkZXB0aDApLCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSg1MiwgcHJvZ3JhbTUyLCBkYXRhKSwgZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGVsZW1lbnQxLCBzZWxmLnByb2dyYW0oNTQsIHByb2dyYW01NCwgZGF0YSkoZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgc3RhY2sxKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICBcIikpO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5mdW5jdGlvbiBwcm9ncmFtNDcoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIHN0YWNrMSwgZWxlbWVudDE7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgICAgIFwiKSk7XG4gIHN0YWNrMSA9IGVsZW1lbnQxID0gY3JlYXRlRWxlbWVudChwYXJ0aWFsKHNlbGYucHJvZ3JhbSgyMywgcHJvZ3JhbTIzLCBkYXRhKSwgZGVwdGgwKSwgZnVuY3Rpb24gKGVsKSB7IGVsZW1lbnQxID0gZWw7IH0pO1xuICBzZXRBdHRyaWJ1dGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZWxlbWVudDE7IH0sIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDQsIHByb2dyYW00LCBkYXRhKSwgZGVwdGgwKSwgcGFydGlhbChzZWxmLnByb2dyYW0oNDgsIHByb2dyYW00OCwgZGF0YSksIGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChlbGVtZW50MSwgc2VsZi5wcm9ncmFtKDUwLCBwcm9ncmFtNTAsIGRhdGEpKGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIHN0YWNrMSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgICBcIikpO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5mdW5jdGlvbiBwcm9ncmFtNDgoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJwZXJzaXN0ZW5jZS1zdGF0dXNcIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtNTAoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIHN0YWNrMSwgc3RhY2syO1xuICBzdGFjazEgPSBmdW5jdGlvbiAoKSB7XG4gIHN0YWNrMiA9ICgoc3RhY2sxID0gKChzdGFjazEgPSAoZGF0YSA9PSBudWxsIHx8IGRhdGEgPT09IGZhbHNlID8gZGF0YSA6IGdldChkYXRhLCBcImRhdGFcIiwgXCJkYXRhXCIpKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IGdldChzdGFjazEsIFwic3RhdGVUZXh0XCIsIFwic3RhY2sxXCIpKSksdHlwZW9mIHN0YWNrMSA9PT0gZnVuY3Rpb25UeXBlID8gc3RhY2sxLmFwcGx5KGRlcHRoMCkgOiBzdGFjazEpO1xuICByZXR1cm4gc3RhY2syO1xuICB9O1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGNyZWF0ZVRleHQoc3RhY2sxKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCIuXCIpKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtNTIoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJ0b29sYmFyLWJ1dHRvbnNcIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtNTQoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIHN0YWNrMSwgZWxlbWVudDEsIGVsZW1lbnQyO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgICBcIikpO1xuICBzdGFjazEgPSBlbGVtZW50MSA9IGNyZWF0ZUVsZW1lbnQocGFydGlhbChzZWxmLnByb2dyYW0oNTUsIHByb2dyYW01NSwgZGF0YSksIGRlcHRoMCksIGZ1bmN0aW9uIChlbCkgeyBlbGVtZW50MSA9IGVsOyB9KTtcbiAgc2V0QXR0cmlidXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVsZW1lbnQxOyB9LCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSg0LCBwcm9ncmFtNCwgZGF0YSksIGRlcHRoMCksIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDU3LCBwcm9ncmFtNTcsIGRhdGEpLCBkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoZWxlbWVudDEsIHNlbGYucHJvZ3JhbSg1OSwgcHJvZ3JhbTU5LCBkYXRhKShkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBzdGFjazEpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgICBcIikpO1xuICBzdGFjazEgPSBlbGVtZW50MiA9IGNyZWF0ZUVsZW1lbnQocGFydGlhbChzZWxmLnByb2dyYW0oNTUsIHByb2dyYW01NSwgZGF0YSksIGRlcHRoMCksIGZ1bmN0aW9uIChlbCkgeyBlbGVtZW50MiA9IGVsOyB9KTtcbiAgc2V0QXR0cmlidXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVsZW1lbnQyOyB9LCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSg0LCBwcm9ncmFtNCwgZGF0YSksIGRlcHRoMCksIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDY0LCBwcm9ncmFtNjQsIGRhdGEpLCBkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoZWxlbWVudDIsIHNlbGYucHJvZ3JhbSg2NiwgcHJvZ3JhbTY2LCBkYXRhKShkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBzdGFjazEpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgXCIpKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuZnVuY3Rpb24gcHJvZ3JhbTU1KGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwic3BhblwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW01NyhkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcImJ0bi1lZGl0XCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTU5KGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBzdGFjazEsIGVsZW1lbnQxO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgICAgIFwiKSk7XG4gIHN0YWNrMSA9IGVsZW1lbnQxID0gY3JlYXRlRWxlbWVudChwYXJ0aWFsKHNlbGYucHJvZ3JhbSgzMSwgcHJvZ3JhbTMxLCBkYXRhKSwgZGVwdGgwKSwgZnVuY3Rpb24gKGVsKSB7IGVsZW1lbnQxID0gZWw7IH0pO1xuICBzZXRBdHRyaWJ1dGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZWxlbWVudDE7IH0sIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDQsIHByb2dyYW00LCBkYXRhKSwgZGVwdGgwKSwgcGFydGlhbChzZWxmLnByb2dyYW0oNjAsIHByb2dyYW02MCwgZGF0YSksIGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChlbGVtZW50MSwgc2VsZi5wcm9ncmFtKDYyLCBwcm9ncmFtNjIsIGRhdGEpKGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIHN0YWNrMSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgICAgIFwiKSk7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cbmZ1bmN0aW9uIHByb2dyYW02MChkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcImJ0bi10ZXh0IHRvZ2dsZS1ub3RlYm9va1wiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW02MihkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlJldHVybiB0byBub3RlYm9vayB2aWV3XCIpO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW02NChkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcImJ0bi12aWV3XCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTY2KGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBzdGFjazEsIGVsZW1lbnQxLCBlbGVtZW50MjtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICAgICAgICBcIikpO1xuICBzdGFjazEgPSBlbGVtZW50MSA9IGNyZWF0ZUVsZW1lbnQocGFydGlhbChzZWxmLnByb2dyYW0oNTUsIHByb2dyYW01NSwgZGF0YSksIGRlcHRoMCksIGZ1bmN0aW9uIChlbCkgeyBlbGVtZW50MSA9IGVsOyB9KTtcbiAgc2V0QXR0cmlidXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVsZW1lbnQxOyB9LCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSg0LCBwcm9ncmFtNCwgZGF0YSksIGRlcHRoMCksIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDY3LCBwcm9ncmFtNjcsIGRhdGEpLCBkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoZWxlbWVudDEsIHNlbGYucHJvZ3JhbSg2OSwgcHJvZ3JhbTY5LCBkYXRhKShkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBzdGFjazEpO1xuICBzdGFjazEgPSBlbGVtZW50MiA9IGNyZWF0ZUVsZW1lbnQocGFydGlhbChzZWxmLnByb2dyYW0oNTUsIHByb2dyYW01NSwgZGF0YSksIGRlcHRoMCksIGZ1bmN0aW9uIChlbCkgeyBlbGVtZW50MiA9IGVsOyB9KTtcbiAgc2V0QXR0cmlidXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVsZW1lbnQyOyB9LCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSg0LCBwcm9ncmFtNCwgZGF0YSksIGRlcHRoMCksIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDY3LCBwcm9ncmFtNjcsIGRhdGEpLCBkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoZWxlbWVudDIsIHNlbGYucHJvZ3JhbSgxMDcsIHByb2dyYW0xMDcsIGRhdGEpKGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIHN0YWNrMSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgICAgIFwiKSk7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cbmZ1bmN0aW9uIHByb2dyYW02NyhkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcImJ0bi1ncm91cFwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW02OShkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgc3RhY2sxLCBzdGFjazIsIGVsZW1lbnQxLCBlbGVtZW50MjtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICAgICAgICAgIFwiKSk7XG4gIHN0YWNrMSA9IGVsZW1lbnQxID0gY3JlYXRlRWxlbWVudChwYXJ0aWFsKHNlbGYucHJvZ3JhbSgzMSwgcHJvZ3JhbTMxLCBkYXRhKSwgZGVwdGgwKSwgZnVuY3Rpb24gKGVsKSB7IGVsZW1lbnQxID0gZWw7IH0pO1xuICBzZXRBdHRyaWJ1dGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZWxlbWVudDE7IH0sIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDQsIHByb2dyYW00LCBkYXRhKSwgZGVwdGgwKSwgcGFydGlhbChzZWxmLnByb2dyYW0oNzAsIHByb2dyYW03MCwgZGF0YSksIGRlcHRoMCkpO1xuICBzZXRBdHRyaWJ1dGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZWxlbWVudDE7IH0sIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDM1LCBwcm9ncmFtMzUsIGRhdGEpLCBkZXB0aDApLCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSg3MiwgcHJvZ3JhbTcyLCBkYXRhKSwgZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGVsZW1lbnQxLCBzZWxmLnByb2dyYW0oNzQsIHByb2dyYW03NCwgZGF0YSkoZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgc3RhY2sxKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICAgICAgICAgIFwiKSk7XG4gIHN0YWNrMSA9IGZ1bmN0aW9uICgpIHtcbiAgc3RhY2syID0gaGVscGVyc1snaWYnXS5jYWxsKGRlcHRoMCwgKChzdGFjazEgPSAoZGF0YSA9PSBudWxsIHx8IGRhdGEgPT09IGZhbHNlID8gZGF0YSA6IGdldChkYXRhLCBcImNvbmZpZ1wiLCBcImRhdGFcIikpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogZ2V0KHN0YWNrMSwgXCJzYXZhYmxlXCIsIFwic3RhY2sxXCIpKSwge2hhc2g6e30saW52ZXJzZTp3cmFwUHJvZ3JhbShzZWxmLm5vb3ApLGZuOndyYXBQcm9ncmFtKHNlbGYucHJvZ3JhbSg3NywgcHJvZ3JhbTc3LCBkYXRhKSksZGF0YTpkYXRhLGF0dHJpYnV0ZTpmYWxzZSx1cGRhdGU6c2VsZi5zdWJzY3JpcHRpb24uYm91bmRVcGRhdGUsdW5zdWJzY3JpYmU6c2VsZi5zdWJzY3JpcHRpb24uYm91bmRVbnN1YnNjcmlwdGlvbn0pO1xuICByZXR1cm4gc3RhY2syO1xuICB9O1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGNyZWF0ZURPTShzdGFjazEpKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICAgICAgICAgIFwiKSk7XG4gIHN0YWNrMSA9IGVsZW1lbnQyID0gY3JlYXRlRWxlbWVudChwYXJ0aWFsKHNlbGYucHJvZ3JhbSgzMSwgcHJvZ3JhbTMxLCBkYXRhKSwgZGVwdGgwKSwgZnVuY3Rpb24gKGVsKSB7IGVsZW1lbnQyID0gZWw7IH0pO1xuICBzZXRBdHRyaWJ1dGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZWxlbWVudDI7IH0sIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDQsIHByb2dyYW00LCBkYXRhKSwgZGVwdGgwKSwgcGFydGlhbChzZWxmLnByb2dyYW0oOTksIHByb2dyYW05OSwgZGF0YSksIGRlcHRoMCkpO1xuICBzZXRBdHRyaWJ1dGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZWxlbWVudDI7IH0sIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDM1LCBwcm9ncmFtMzUsIGRhdGEpLCBkZXB0aDApLCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSgxMDEsIHByb2dyYW0xMDEsIGRhdGEpLCBkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoZWxlbWVudDIsIHNlbGYucHJvZ3JhbSgxMDQsIHByb2dyYW0xMDQsIGRhdGEpKGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIHN0YWNrMSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgICAgICAgXCIpKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuZnVuY3Rpb24gcHJvZ3JhbTcwKGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwiYnRuLXJvdW5kIG5vdGVib29rLW5ldyBoaW50LS1ib3R0b21cIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtNzIoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJOZXcgbm90ZWJvb2tcIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtNzQoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIHN0YWNrMSwgZWxlbWVudDE7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgICAgICAgICAgIFwiKSk7XG4gIHN0YWNrMSA9IGVsZW1lbnQxID0gY3JlYXRlRWxlbWVudChwYXJ0aWFsKHNlbGYucHJvZ3JhbSg0MCwgcHJvZ3JhbTQwLCBkYXRhKSwgZGVwdGgwKSwgZnVuY3Rpb24gKGVsKSB7IGVsZW1lbnQxID0gZWw7IH0pO1xuICBzZXRBdHRyaWJ1dGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZWxlbWVudDE7IH0sIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDQsIHByb2dyYW00LCBkYXRhKSwgZGVwdGgwKSwgcGFydGlhbChzZWxmLnByb2dyYW0oNzUsIHByb2dyYW03NSwgZGF0YSksIGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChlbGVtZW50MSwgc2VsZi5wcm9ncmFtKDIxLCBwcm9ncmFtMjEsIGRhdGEpKGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIHN0YWNrMSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgICAgICAgICBcIikpO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5mdW5jdGlvbiBwcm9ncmFtNzUoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJpY29uLWRvY1wiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW03NyhkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgc3RhY2sxLCBlbGVtZW50MSwgZWxlbWVudDI7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgICAgICAgICBcIikpO1xuICBzdGFjazEgPSBlbGVtZW50MSA9IGNyZWF0ZUVsZW1lbnQocGFydGlhbChzZWxmLnByb2dyYW0oMzEsIHByb2dyYW0zMSwgZGF0YSksIGRlcHRoMCksIGZ1bmN0aW9uIChlbCkgeyBlbGVtZW50MSA9IGVsOyB9KTtcbiAgc2V0QXR0cmlidXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVsZW1lbnQxOyB9LCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSg0LCBwcm9ncmFtNCwgZGF0YSksIGRlcHRoMCksIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDc4LCBwcm9ncmFtNzgsIGRhdGEpLCBkZXB0aDApKTtcbiAgc2V0QXR0cmlidXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVsZW1lbnQxOyB9LCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSgzNSwgcHJvZ3JhbTM1LCBkYXRhKSwgZGVwdGgwKSwgcGFydGlhbChzZWxmLnByb2dyYW0oODEsIHByb2dyYW04MSwgZGF0YSksIGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChlbGVtZW50MSwgc2VsZi5wcm9ncmFtKDg2LCBwcm9ncmFtODYsIGRhdGEpKGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIHN0YWNrMSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgICAgICAgICBcIikpO1xuICBzdGFjazEgPSBlbGVtZW50MiA9IGNyZWF0ZUVsZW1lbnQocGFydGlhbChzZWxmLnByb2dyYW0oMzEsIHByb2dyYW0zMSwgZGF0YSksIGRlcHRoMCksIGZ1bmN0aW9uIChlbCkgeyBlbGVtZW50MiA9IGVsOyB9KTtcbiAgc2V0QXR0cmlidXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVsZW1lbnQyOyB9LCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSg0LCBwcm9ncmFtNCwgZGF0YSksIGRlcHRoMCksIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDg5LCBwcm9ncmFtODksIGRhdGEpLCBkZXB0aDApKTtcbiAgc2V0QXR0cmlidXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVsZW1lbnQyOyB9LCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSgzNSwgcHJvZ3JhbTM1LCBkYXRhKSwgZGVwdGgwKSwgcGFydGlhbChzZWxmLnByb2dyYW0oOTEsIHByb2dyYW05MSwgZGF0YSksIGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChlbGVtZW50Miwgc2VsZi5wcm9ncmFtKDk2LCBwcm9ncmFtOTYsIGRhdGEpKGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIHN0YWNrMSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgICAgICAgICBcIikpO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5mdW5jdGlvbiBwcm9ncmFtNzgoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBcIlwiLCBzdGFjazE7XG4gIGJ1ZmZlciArPSBcImJ0bi1yb3VuZCBub3RlYm9vay1zYXZlIGhpbnQtLWJvdHRvbSBcIjtcbiAgc3RhY2sxID0gaGVscGVycy51bmxlc3MuY2FsbChkZXB0aDAsICgoc3RhY2sxID0gKGRhdGEgPT0gbnVsbCB8fCBkYXRhID09PSBmYWxzZSA/IGRhdGEgOiBnZXQoZGF0YSwgXCJkYXRhXCIsIFwiZGF0YVwiKSkpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBnZXQoc3RhY2sxLCBcInNhdmFibGVcIiwgXCJzdGFjazFcIikpLCB7aGFzaDp7fSxpbnZlcnNlOndyYXBQcm9ncmFtKHNlbGYubm9vcCksZm46d3JhcFByb2dyYW0oc2VsZi5wcm9ncmFtKDc5LCBwcm9ncmFtNzksIGRhdGEpKSxkYXRhOmRhdGEsYXR0cmlidXRlOnRydWUsdXBkYXRlOnNlbGYuc3Vic2NyaXB0aW9uLmJvdW5kVXBkYXRlLHVuc3Vic2NyaWJlOnNlbGYuc3Vic2NyaXB0aW9uLmJvdW5kVW5zdWJzY3JpcHRpb259KTtcbiAgYnVmZmVyICs9IHN0YWNrMTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuZnVuY3Rpb24gcHJvZ3JhbTc5KGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwiYnRuLWRpc2FibGVkXCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTgxKGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgc3RhY2sxO1xuICBzdGFjazEgPSBoZWxwZXJzWydpZiddLmNhbGwoZGVwdGgwLCAoKHN0YWNrMSA9IChkYXRhID09IG51bGwgfHwgZGF0YSA9PT0gZmFsc2UgPyBkYXRhIDogZ2V0KGRhdGEsIFwiZGF0YVwiLCBcImRhdGFcIikpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogZ2V0KHN0YWNrMSwgXCJzYXZhYmxlXCIsIFwic3RhY2sxXCIpKSwge2hhc2g6e30saW52ZXJzZTp3cmFwUHJvZ3JhbShzZWxmLnByb2dyYW0oODQsIHByb2dyYW04NCwgZGF0YSkpLGZuOndyYXBQcm9ncmFtKHNlbGYucHJvZ3JhbSg4MiwgcHJvZ3JhbTgyLCBkYXRhKSksZGF0YTpkYXRhLGF0dHJpYnV0ZTp0cnVlLHVwZGF0ZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVwZGF0ZSx1bnN1YnNjcmliZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVuc3Vic2NyaXB0aW9ufSk7XG4gIHJldHVybiBzdGFjazE7XG4gIH1cbmZ1bmN0aW9uIHByb2dyYW04MihkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcIlNhdmUgbm90ZWJvb2tcIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtODQoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJDbG9uZSB0aGUgbm90ZWJvb2sgdG8gc2F2ZVwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW04NihkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgc3RhY2sxLCBlbGVtZW50MTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICAgICAgICAgICAgXCIpKTtcbiAgc3RhY2sxID0gZWxlbWVudDEgPSBjcmVhdGVFbGVtZW50KHBhcnRpYWwoc2VsZi5wcm9ncmFtKDQwLCBwcm9ncmFtNDAsIGRhdGEpLCBkZXB0aDApLCBmdW5jdGlvbiAoZWwpIHsgZWxlbWVudDEgPSBlbDsgfSk7XG4gIHNldEF0dHJpYnV0ZShmdW5jdGlvbiAoKSB7IHJldHVybiBlbGVtZW50MTsgfSwgcGFydGlhbChzZWxmLnByb2dyYW0oNCwgcHJvZ3JhbTQsIGRhdGEpLCBkZXB0aDApLCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSg4NywgcHJvZ3JhbTg3LCBkYXRhKSwgZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGVsZW1lbnQxLCBzZWxmLnByb2dyYW0oMjEsIHByb2dyYW0yMSwgZGF0YSkoZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgc3RhY2sxKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICAgICAgICAgIFwiKSk7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cbmZ1bmN0aW9uIHByb2dyYW04NyhkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcImljb24tZmxvcHB5XCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTg5KGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gXCJcIiwgc3RhY2sxO1xuICBidWZmZXIgKz0gXCJidG4tcm91bmQgbm90ZWJvb2stY2xvbmUgaGludC0tYm90dG9tIFwiO1xuICBzdGFjazEgPSBoZWxwZXJzLnVubGVzcy5jYWxsKGRlcHRoMCwgKChzdGFjazEgPSAoZGF0YSA9PSBudWxsIHx8IGRhdGEgPT09IGZhbHNlID8gZGF0YSA6IGdldChkYXRhLCBcImRhdGFcIiwgXCJkYXRhXCIpKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IGdldChzdGFjazEsIFwiY2xvbmVhYmxlXCIsIFwic3RhY2sxXCIpKSwge2hhc2g6e30saW52ZXJzZTp3cmFwUHJvZ3JhbShzZWxmLm5vb3ApLGZuOndyYXBQcm9ncmFtKHNlbGYucHJvZ3JhbSg3OSwgcHJvZ3JhbTc5LCBkYXRhKSksZGF0YTpkYXRhLGF0dHJpYnV0ZTp0cnVlLHVwZGF0ZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVwZGF0ZSx1bnN1YnNjcmliZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVuc3Vic2NyaXB0aW9ufSk7XG4gIGJ1ZmZlciArPSBzdGFjazE7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTkxKGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgc3RhY2sxO1xuICBzdGFjazEgPSBoZWxwZXJzWydpZiddLmNhbGwoZGVwdGgwLCAoKHN0YWNrMSA9IChkYXRhID09IG51bGwgfHwgZGF0YSA9PT0gZmFsc2UgPyBkYXRhIDogZ2V0KGRhdGEsIFwiZGF0YVwiLCBcImRhdGFcIikpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogZ2V0KHN0YWNrMSwgXCJjbG9uZWFibGVcIiwgXCJzdGFjazFcIikpLCB7aGFzaDp7fSxpbnZlcnNlOndyYXBQcm9ncmFtKHNlbGYucHJvZ3JhbSg5NCwgcHJvZ3JhbTk0LCBkYXRhKSksZm46d3JhcFByb2dyYW0oc2VsZi5wcm9ncmFtKDkyLCBwcm9ncmFtOTIsIGRhdGEpKSxkYXRhOmRhdGEsYXR0cmlidXRlOnRydWUsdXBkYXRlOnNlbGYuc3Vic2NyaXB0aW9uLmJvdW5kVXBkYXRlLHVuc3Vic2NyaWJlOnNlbGYuc3Vic2NyaXB0aW9uLmJvdW5kVW5zdWJzY3JpcHRpb259KTtcbiAgcmV0dXJuIHN0YWNrMTtcbiAgfVxuZnVuY3Rpb24gcHJvZ3JhbTkyKGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwiQ2xvbmUgbm90ZWJvb2tcIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtOTQoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJTYXZlIG5vdGVib29rIHRvIGZvcmtcIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtOTYoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIHN0YWNrMSwgZWxlbWVudDE7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgICAgICAgICAgIFwiKSk7XG4gIHN0YWNrMSA9IGVsZW1lbnQxID0gY3JlYXRlRWxlbWVudChwYXJ0aWFsKHNlbGYucHJvZ3JhbSg0MCwgcHJvZ3JhbTQwLCBkYXRhKSwgZGVwdGgwKSwgZnVuY3Rpb24gKGVsKSB7IGVsZW1lbnQxID0gZWw7IH0pO1xuICBzZXRBdHRyaWJ1dGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZWxlbWVudDE7IH0sIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDQsIHByb2dyYW00LCBkYXRhKSwgZGVwdGgwKSwgcGFydGlhbChzZWxmLnByb2dyYW0oOTcsIHByb2dyYW05NywgZGF0YSksIGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChlbGVtZW50MSwgc2VsZi5wcm9ncmFtKDIxLCBwcm9ncmFtMjEsIGRhdGEpKGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIHN0YWNrMSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgICAgICAgICBcIikpO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5mdW5jdGlvbiBwcm9ncmFtOTcoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJpY29uLWZvcmtcIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtOTkoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJidG4tcm91bmQgbm90ZWJvb2stc2hhcmUgaGludC0tYm90dG9tXCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTEwMShkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IFwiXCIsIHN0YWNrMTtcbiAgYnVmZmVyICs9IFwiU2hhcmUgXCI7XG4gIHN0YWNrMSA9IGhlbHBlcnNbJ2lmJ10uY2FsbChkZXB0aDAsICgoc3RhY2sxID0gKGRhdGEgPT0gbnVsbCB8fCBkYXRhID09PSBmYWxzZSA/IGRhdGEgOiBnZXQoZGF0YSwgXCJkYXRhXCIsIFwiZGF0YVwiKSkpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBnZXQoc3RhY2sxLCBcInNoYXJlYWJsZVwiLCBcInN0YWNrMVwiKSksIHtoYXNoOnt9LGludmVyc2U6d3JhcFByb2dyYW0oc2VsZi5ub29wKSxmbjp3cmFwUHJvZ3JhbShzZWxmLnByb2dyYW0oMTAyLCBwcm9ncmFtMTAyLCBkYXRhKSksZGF0YTpkYXRhLGF0dHJpYnV0ZTp0cnVlLHVwZGF0ZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVwZGF0ZSx1bnN1YnNjcmliZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVuc3Vic2NyaXB0aW9ufSk7XG4gIGJ1ZmZlciArPSBzdGFjazFcbiAgICArIFwiIG5vdGVib29rXCI7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cbmZ1bmN0aW9uIHByb2dyYW0xMDIoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJjdXJyZW50XCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTEwNChkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgc3RhY2sxLCBlbGVtZW50MTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICAgICAgICAgICAgXCIpKTtcbiAgc3RhY2sxID0gZWxlbWVudDEgPSBjcmVhdGVFbGVtZW50KHBhcnRpYWwoc2VsZi5wcm9ncmFtKDQwLCBwcm9ncmFtNDAsIGRhdGEpLCBkZXB0aDApLCBmdW5jdGlvbiAoZWwpIHsgZWxlbWVudDEgPSBlbDsgfSk7XG4gIHNldEF0dHJpYnV0ZShmdW5jdGlvbiAoKSB7IHJldHVybiBlbGVtZW50MTsgfSwgcGFydGlhbChzZWxmLnByb2dyYW0oNCwgcHJvZ3JhbTQsIGRhdGEpLCBkZXB0aDApLCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSgxMDUsIHByb2dyYW0xMDUsIGRhdGEpLCBkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoZWxlbWVudDEsIHNlbGYucHJvZ3JhbSgyMSwgcHJvZ3JhbTIxLCBkYXRhKShkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBzdGFjazEpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgICAgICAgXCIpKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuZnVuY3Rpb24gcHJvZ3JhbTEwNShkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcImljb24tc2hhcmVcIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtMTA3KGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBzdGFjazEsIGVsZW1lbnQxLCBlbGVtZW50MjtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICAgICAgICAgIFwiKSk7XG4gIHN0YWNrMSA9IGVsZW1lbnQxID0gY3JlYXRlRWxlbWVudChwYXJ0aWFsKHNlbGYucHJvZ3JhbSgzMSwgcHJvZ3JhbTMxLCBkYXRhKSwgZGVwdGgwKSwgZnVuY3Rpb24gKGVsKSB7IGVsZW1lbnQxID0gZWw7IH0pO1xuICBzZXRBdHRyaWJ1dGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZWxlbWVudDE7IH0sIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDQsIHByb2dyYW00LCBkYXRhKSwgZGVwdGgwKSwgcGFydGlhbChzZWxmLnByb2dyYW0oMTA4LCBwcm9ncmFtMTA4LCBkYXRhKSwgZGVwdGgwKSk7XG4gIHNldEF0dHJpYnV0ZShmdW5jdGlvbiAoKSB7IHJldHVybiBlbGVtZW50MTsgfSwgcGFydGlhbChzZWxmLnByb2dyYW0oMzUsIHByb2dyYW0zNSwgZGF0YSksIGRlcHRoMCksIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDExMCwgcHJvZ3JhbTExMCwgZGF0YSksIGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChlbGVtZW50MSwgc2VsZi5wcm9ncmFtKDExMiwgcHJvZ3JhbTExMiwgZGF0YSkoZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgc3RhY2sxKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICAgICAgICAgIFwiKSk7XG4gIHN0YWNrMSA9IGVsZW1lbnQyID0gY3JlYXRlRWxlbWVudChwYXJ0aWFsKHNlbGYucHJvZ3JhbSgzMSwgcHJvZ3JhbTMxLCBkYXRhKSwgZGVwdGgwKSwgZnVuY3Rpb24gKGVsKSB7IGVsZW1lbnQyID0gZWw7IH0pO1xuICBzZXRBdHRyaWJ1dGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZWxlbWVudDI7IH0sIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDQsIHByb2dyYW00LCBkYXRhKSwgZGVwdGgwKSwgcGFydGlhbChzZWxmLnByb2dyYW0oMTE1LCBwcm9ncmFtMTE1LCBkYXRhKSwgZGVwdGgwKSk7XG4gIHNldEF0dHJpYnV0ZShmdW5jdGlvbiAoKSB7IHJldHVybiBlbGVtZW50MjsgfSwgcGFydGlhbChzZWxmLnByb2dyYW0oMzUsIHByb2dyYW0zNSwgZGF0YSksIGRlcHRoMCksIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDExNywgcHJvZ3JhbTExNywgZGF0YSksIGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChlbGVtZW50Miwgc2VsZi5wcm9ncmFtKDExOSwgcHJvZ3JhbTExOSwgZGF0YSkoZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgc3RhY2sxKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICAgICAgICBcIikpO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5mdW5jdGlvbiBwcm9ncmFtMTA4KGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwiYnRuLXJvdW5kIG5vdGVib29rLWV4ZWMgaGludC0tYm90dG9tXCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTExMChkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcIlBsYXkgbm90ZWJvb2tcIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtMTEyKGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBzdGFjazEsIGVsZW1lbnQxO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgICAgICAgICBcIikpO1xuICBzdGFjazEgPSBlbGVtZW50MSA9IGNyZWF0ZUVsZW1lbnQocGFydGlhbChzZWxmLnByb2dyYW0oNDAsIHByb2dyYW00MCwgZGF0YSksIGRlcHRoMCksIGZ1bmN0aW9uIChlbCkgeyBlbGVtZW50MSA9IGVsOyB9KTtcbiAgc2V0QXR0cmlidXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVsZW1lbnQxOyB9LCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSg0LCBwcm9ncmFtNCwgZGF0YSksIGRlcHRoMCksIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDExMywgcHJvZ3JhbTExMywgZGF0YSksIGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChlbGVtZW50MSwgc2VsZi5wcm9ncmFtKDIxLCBwcm9ncmFtMjEsIGRhdGEpKGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIHN0YWNrMSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgICAgICAgICBcIikpO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5mdW5jdGlvbiBwcm9ncmFtMTEzKGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwiaWNvbi1wbGF5XCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTExNShkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcImJ0bi1yb3VuZCBub3RlYm9vay1oZWxwIGhpbnQtLWJvdHRvbVwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW0xMTcoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJTaG9ydGN1dHNcIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtMTE5KGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBzdGFjazEsIGVsZW1lbnQxO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgICAgICAgICBcIikpO1xuICBzdGFjazEgPSBlbGVtZW50MSA9IGNyZWF0ZUVsZW1lbnQocGFydGlhbChzZWxmLnByb2dyYW0oNDAsIHByb2dyYW00MCwgZGF0YSksIGRlcHRoMCksIGZ1bmN0aW9uIChlbCkgeyBlbGVtZW50MSA9IGVsOyB9KTtcbiAgc2V0QXR0cmlidXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVsZW1lbnQxOyB9LCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSg0LCBwcm9ncmFtNCwgZGF0YSksIGRlcHRoMCksIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDQyLCBwcm9ncmFtNDIsIGRhdGEpLCBkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoZWxlbWVudDEsIHNlbGYucHJvZ3JhbSgyMSwgcHJvZ3JhbTIxLCBkYXRhKShkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBzdGFjazEpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgICAgICAgXCIpKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtMTIxKGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwibm90ZWJvb2tcIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtMTIzKGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBzdGFjazEsIHN0YWNrMiwgZWxlbWVudDE7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gIFwiKSk7XG4gIHN0YWNrMSA9IGZ1bmN0aW9uICgpIHtcbiAgc3RhY2syID0gaGVscGVyc1snaWYnXS5jYWxsKGRlcHRoMCwgKChzdGFjazEgPSAoZGF0YSA9PSBudWxsIHx8IGRhdGEgPT09IGZhbHNlID8gZGF0YSA6IGdldChkYXRhLCBcImNvbmZpZ1wiLCBcImRhdGFcIikpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogZ2V0KHN0YWNrMSwgXCJzaWRlYmFyXCIsIFwic3RhY2sxXCIpKSwge2hhc2g6e30saW52ZXJzZTp3cmFwUHJvZ3JhbShzZWxmLm5vb3ApLGZuOndyYXBQcm9ncmFtKHNlbGYucHJvZ3JhbSgxMjQsIHByb2dyYW0xMjQsIGRhdGEpKSxkYXRhOmRhdGEsYXR0cmlidXRlOmZhbHNlLHVwZGF0ZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVwZGF0ZSx1bnN1YnNjcmliZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVuc3Vic2NyaXB0aW9ufSk7XG4gIHJldHVybiBzdGFjazI7XG4gIH07XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgY3JlYXRlRE9NKHN0YWNrMSkpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuXFxuICBcIikpO1xuICBzdGFjazEgPSBlbGVtZW50MSA9IGNyZWF0ZUVsZW1lbnQocGFydGlhbChzZWxmLnByb2dyYW0oMjMsIHByb2dyYW0yMywgZGF0YSksIGRlcHRoMCksIGZ1bmN0aW9uIChlbCkgeyBlbGVtZW50MSA9IGVsOyB9KTtcbiAgc2V0QXR0cmlidXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVsZW1lbnQxOyB9LCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSg0LCBwcm9ncmFtNCwgZGF0YSksIGRlcHRoMCksIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDEyNiwgcHJvZ3JhbTEyNiwgZGF0YSksIGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChlbGVtZW50MSwgc2VsZi5wcm9ncmFtKDEyOCwgcHJvZ3JhbTEyOCwgZGF0YSkoZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgc3RhY2sxKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcblwiKSk7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cbmZ1bmN0aW9uIHByb2dyYW0xMjQoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIHN0YWNrMSwgc3RhY2syLCBoZWxwZXIsIG9wdGlvbnM7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgXCIpKTtcbiAgc3RhY2sxID0gZnVuY3Rpb24gKCkge1xuICBzdGFjazIgPSAoaGVscGVyID0gaGVscGVycy52aWV3IHx8IGdldChkZXB0aDAsIFwidmlld1wiLCBcImRlcHRoMFwiKSxvcHRpb25zPXtoYXNoOnt9LGRhdGE6ZGF0YSxhdHRyaWJ1dGU6ZmFsc2UsdXBkYXRlOnNlbGYuc3Vic2NyaXB0aW9uLmJvdW5kVXBkYXRlLHVuc3Vic2NyaWJlOnNlbGYuc3Vic2NyaXB0aW9uLmJvdW5kVW5zdWJzY3JpcHRpb259LGhlbHBlciA/IGhlbHBlci5jYWxsKGRlcHRoMCwgKChzdGFjazEgPSAoZGF0YSA9PSBudWxsIHx8IGRhdGEgPT09IGZhbHNlID8gZGF0YSA6IGdldChkYXRhLCBcImRhdGFcIiwgXCJkYXRhXCIpKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IGdldChzdGFjazEsIFwic2lkZWJhclwiLCBcInN0YWNrMVwiKSksIG9wdGlvbnMpIDogaGVscGVyTWlzc2luZy5jYWxsKGRlcHRoMCwgXCJ2aWV3XCIsICgoc3RhY2sxID0gKGRhdGEgPT0gbnVsbCB8fCBkYXRhID09PSBmYWxzZSA/IGRhdGEgOiBnZXQoZGF0YSwgXCJkYXRhXCIsIFwiZGF0YVwiKSkpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBnZXQoc3RhY2sxLCBcInNpZGViYXJcIiwgXCJzdGFjazFcIikpLCBvcHRpb25zKSk7XG4gIHJldHVybiBzdGFjazI7XG4gIH07XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgY3JlYXRlRE9NKHN0YWNrMSkpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICBcIikpO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW0xMjYoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJub3RlYm9vay1jb250ZW50XCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTEyOChkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgc3RhY2sxLCBzdGFjazIsIGhlbHBlciwgb3B0aW9ucztcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICBcIikpO1xuICBzdGFjazEgPSBmdW5jdGlvbiAoKSB7XG4gIHN0YWNrMiA9IChoZWxwZXIgPSBoZWxwZXJzLnZpZXcgfHwgZ2V0KGRlcHRoMCwgXCJ2aWV3XCIsIFwiZGVwdGgwXCIpLG9wdGlvbnM9e2hhc2g6e30sZGF0YTpkYXRhLGF0dHJpYnV0ZTpmYWxzZSx1cGRhdGU6c2VsZi5zdWJzY3JpcHRpb24uYm91bmRVcGRhdGUsdW5zdWJzY3JpYmU6c2VsZi5zdWJzY3JpcHRpb24uYm91bmRVbnN1YnNjcmlwdGlvbn0saGVscGVyID8gaGVscGVyLmNhbGwoZGVwdGgwLCAoKHN0YWNrMSA9IChkYXRhID09IG51bGwgfHwgZGF0YSA9PT0gZmFsc2UgPyBkYXRhIDogZ2V0KGRhdGEsIFwiZGF0YVwiLCBcImRhdGFcIikpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogZ2V0KHN0YWNrMSwgXCJub3RlYm9va1wiLCBcInN0YWNrMVwiKSksIG9wdGlvbnMpIDogaGVscGVyTWlzc2luZy5jYWxsKGRlcHRoMCwgXCJ2aWV3XCIsICgoc3RhY2sxID0gKGRhdGEgPT0gbnVsbCB8fCBkYXRhID09PSBmYWxzZSA/IGRhdGEgOiBnZXQoZGF0YSwgXCJkYXRhXCIsIFwiZGF0YVwiKSkpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBnZXQoc3RhY2sxLCBcIm5vdGVib29rXCIsIFwic3RhY2sxXCIpKSwgb3B0aW9ucykpO1xuICByZXR1cm4gc3RhY2syO1xuICB9O1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGNyZWF0ZURPTShzdGFjazEpKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcblxcbiAgICBcIikpO1xuICBzdGFjazEgPSBmdW5jdGlvbiAoKSB7XG4gIHN0YWNrMiA9IGhlbHBlcnMudW5sZXNzLmNhbGwoZGVwdGgwLCAoKHN0YWNrMSA9IChkYXRhID09IG51bGwgfHwgZGF0YSA9PT0gZmFsc2UgPyBkYXRhIDogZ2V0KGRhdGEsIFwiY29uZmlnXCIsIFwiZGF0YVwiKSkpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBnZXQoc3RhY2sxLCBcImVtYmVkZGVkXCIsIFwic3RhY2sxXCIpKSwge2hhc2g6e30saW52ZXJzZTp3cmFwUHJvZ3JhbShzZWxmLm5vb3ApLGZuOndyYXBQcm9ncmFtKHNlbGYucHJvZ3JhbSgxMjksIHByb2dyYW0xMjksIGRhdGEpKSxkYXRhOmRhdGEsYXR0cmlidXRlOmZhbHNlLHVwZGF0ZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVwZGF0ZSx1bnN1YnNjcmliZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVuc3Vic2NyaXB0aW9ufSk7XG4gIHJldHVybiBzdGFjazI7XG4gIH07XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgY3JlYXRlRE9NKHN0YWNrMSkpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICBcIikpO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5mdW5jdGlvbiBwcm9ncmFtMTI5KGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBzdGFjazEsIGVsZW1lbnQxO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgXCIpKTtcbiAgc3RhY2sxID0gZWxlbWVudDEgPSBjcmVhdGVFbGVtZW50KHBhcnRpYWwoc2VsZi5wcm9ncmFtKDEzMCwgcHJvZ3JhbTEzMCwgZGF0YSksIGRlcHRoMCksIGZ1bmN0aW9uIChlbCkgeyBlbGVtZW50MSA9IGVsOyB9KTtcbiAgc2V0QXR0cmlidXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVsZW1lbnQxOyB9LCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSgxMzIsIHByb2dyYW0xMzIsIGRhdGEpLCBkZXB0aDApLCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSgxMzQsIHByb2dyYW0xMzQsIGRhdGEpLCBkZXB0aDApKTtcbiAgc2V0QXR0cmlidXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVsZW1lbnQxOyB9LCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSg0LCBwcm9ncmFtNCwgZGF0YSksIGRlcHRoMCksIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDEzNiwgcHJvZ3JhbTEzNiwgZGF0YSksIGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChlbGVtZW50MSwgc2VsZi5wcm9ncmFtKDEzOCwgcHJvZ3JhbTEzOCwgZGF0YSkoZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgc3RhY2sxKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICBcIikpO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5mdW5jdGlvbiBwcm9ncmFtMTMwKGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwiYVwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW0xMzIoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJocmVmXCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTEzNChkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcImh0dHA6Ly9tdWxlc29mdC5jb21cIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtMTM2KGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwiaXIgcG93ZXJlZC1ieS1sb2dvXCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTEzOChkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIk11bGVzb2Z0XCIpO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW0xNDAoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIHN0YWNrMSwgZWxlbWVudDE7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gIFwiKSk7XG4gIHN0YWNrMSA9IGVsZW1lbnQxID0gY3JlYXRlRWxlbWVudChwYXJ0aWFsKHNlbGYucHJvZ3JhbSgyMywgcHJvZ3JhbTIzLCBkYXRhKSwgZGVwdGgwKSwgZnVuY3Rpb24gKGVsKSB7IGVsZW1lbnQxID0gZWw7IH0pO1xuICBzZXRBdHRyaWJ1dGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZWxlbWVudDE7IH0sIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDQsIHByb2dyYW00LCBkYXRhKSwgZGVwdGgwKSwgcGFydGlhbChzZWxmLnByb2dyYW0oMTQxLCBwcm9ncmFtMTQxLCBkYXRhKSwgZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGVsZW1lbnQxLCBzZWxmLnByb2dyYW0oMTQzLCBwcm9ncmFtMTQzLCBkYXRhKShkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBzdGFjazEpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuXCIpKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuZnVuY3Rpb24gcHJvZ3JhbTE0MShkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcIm1vZGFsIHVpLWxvYWRpbmdcIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtMTQzKGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBzdGFjazEsIGVsZW1lbnQxO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgIFwiKSk7XG4gIHN0YWNrMSA9IGVsZW1lbnQxID0gY3JlYXRlRWxlbWVudChwYXJ0aWFsKHNlbGYucHJvZ3JhbSg0MCwgcHJvZ3JhbTQwLCBkYXRhKSwgZGVwdGgwKSwgZnVuY3Rpb24gKGVsKSB7IGVsZW1lbnQxID0gZWw7IH0pO1xuICBzZXRBdHRyaWJ1dGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZWxlbWVudDE7IH0sIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDQsIHByb2dyYW00LCBkYXRhKSwgZGVwdGgwKSwgcGFydGlhbChzZWxmLnByb2dyYW0oMTQ0LCBwcm9ncmFtMTQ0LCBkYXRhKSwgZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGVsZW1lbnQxLCBzZWxmLnByb2dyYW0oMjEsIHByb2dyYW0yMSwgZGF0YSkoZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgc3RhY2sxKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgXCIpKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuZnVuY3Rpb24gcHJvZ3JhbTE0NChkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcInVpLWxvYWRpbmctaWNvbiBpY29uLWFycm93cy1jdyBhbmltYXRlLXNwaW5cIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtMTQ2KGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBzdGFjazEsIGVsZW1lbnQxO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICBcIikpO1xuICBzdGFjazEgPSBlbGVtZW50MSA9IGNyZWF0ZUVsZW1lbnQocGFydGlhbChzZWxmLnByb2dyYW0oMjMsIHByb2dyYW0yMywgZGF0YSksIGRlcHRoMCksIGZ1bmN0aW9uIChlbCkgeyBlbGVtZW50MSA9IGVsOyB9KTtcbiAgc2V0QXR0cmlidXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVsZW1lbnQxOyB9LCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSg0LCBwcm9ncmFtNCwgZGF0YSksIGRlcHRoMCksIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDE0NywgcHJvZ3JhbTE0NywgZGF0YSksIGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChlbGVtZW50MSwgc2VsZi5wcm9ncmFtKDE0OSwgcHJvZ3JhbTE0OSwgZGF0YSkoZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgc3RhY2sxKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcblwiKSk7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cbmZ1bmN0aW9uIHByb2dyYW0xNDcoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJub3RlYm9vay1mb290ZXIgY2xlYXJmaXhcIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtMTQ5KGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBzdGFjazEsIGVsZW1lbnQxLCBlbGVtZW50MjtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICBcIikpO1xuICBzdGFjazEgPSBlbGVtZW50MSA9IGNyZWF0ZUVsZW1lbnQocGFydGlhbChzZWxmLnByb2dyYW0oMjMsIHByb2dyYW0yMywgZGF0YSksIGRlcHRoMCksIGZ1bmN0aW9uIChlbCkgeyBlbGVtZW50MSA9IGVsOyB9KTtcbiAgc2V0QXR0cmlidXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVsZW1lbnQxOyB9LCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSg0LCBwcm9ncmFtNCwgZGF0YSksIGRlcHRoMCksIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDE1MCwgcHJvZ3JhbTE1MCwgZGF0YSksIGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChlbGVtZW50MSwgc2VsZi5wcm9ncmFtKDE1MiwgcHJvZ3JhbTE1MiwgZGF0YSkoZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgc3RhY2sxKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcblxcbiAgICBcIikpO1xuICBzdGFjazEgPSBlbGVtZW50MiA9IGNyZWF0ZUVsZW1lbnQocGFydGlhbChzZWxmLnByb2dyYW0oMjMsIHByb2dyYW0yMywgZGF0YSksIGRlcHRoMCksIGZ1bmN0aW9uIChlbCkgeyBlbGVtZW50MiA9IGVsOyB9KTtcbiAgc2V0QXR0cmlidXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVsZW1lbnQyOyB9LCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSg0LCBwcm9ncmFtNCwgZGF0YSksIGRlcHRoMCksIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDE2OCwgcHJvZ3JhbTE2OCwgZGF0YSksIGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChlbGVtZW50Miwgc2VsZi5wcm9ncmFtKDE3MCwgcHJvZ3JhbTE3MCwgZGF0YSkoZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgc3RhY2sxKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgXCIpKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuZnVuY3Rpb24gcHJvZ3JhbTE1MChkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcImZvb3Rlci1lbmRcIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtMTUyKGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBzdGFjazEsIHN0YWNrMiwgZWxlbWVudDEsIGhlbHBlciwgb3B0aW9ucztcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICAgIFwiKSk7XG4gIHN0YWNrMSA9IGVsZW1lbnQxID0gY3JlYXRlRWxlbWVudChwYXJ0aWFsKHNlbGYucHJvZ3JhbSgzMSwgcHJvZ3JhbTMxLCBkYXRhKSwgZGVwdGgwKSwgZnVuY3Rpb24gKGVsKSB7IGVsZW1lbnQxID0gZWw7IH0pO1xuICBzZXRBdHRyaWJ1dGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZWxlbWVudDE7IH0sIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDQsIHByb2dyYW00LCBkYXRhKSwgZGVwdGgwKSwgcGFydGlhbChzZWxmLnByb2dyYW0oMTUzLCBwcm9ncmFtMTUzLCBkYXRhKSwgZGVwdGgwKSk7XG4gIHNldEF0dHJpYnV0ZShmdW5jdGlvbiAoKSB7IHJldHVybiBlbGVtZW50MTsgfSwgcGFydGlhbChzZWxmLnByb2dyYW0oMzUsIHByb2dyYW0zNSwgZGF0YSksIGRlcHRoMCksIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDE1NSwgcHJvZ3JhbTE1NSwgZGF0YSksIGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChlbGVtZW50MSwgc2VsZi5wcm9ncmFtKDE1NywgcHJvZ3JhbTE1NywgZGF0YSkoZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgc3RhY2sxKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICAgIFwiKSk7XG4gIHN0YWNrMSA9IGZ1bmN0aW9uICgpIHtcbiAgc3RhY2syID0gKGhlbHBlciA9IGhlbHBlcnMudW5sZXNzRXF1YWwgfHwgZ2V0KGRlcHRoMCwgXCJ1bmxlc3NFcXVhbFwiLCBcImRlcHRoMFwiKSxvcHRpb25zPXtoYXNoOnt9LGludmVyc2U6d3JhcFByb2dyYW0oc2VsZi5ub29wKSxmbjp3cmFwUHJvZ3JhbShzZWxmLnByb2dyYW0oMTU5LCBwcm9ncmFtMTU5LCBkYXRhKSksZGF0YTpkYXRhLGF0dHJpYnV0ZTpmYWxzZSx1cGRhdGU6c2VsZi5zdWJzY3JpcHRpb24uYm91bmRVcGRhdGUsdW5zdWJzY3JpYmU6c2VsZi5zdWJzY3JpcHRpb24uYm91bmRVbnN1YnNjcmlwdGlvbn0saGVscGVyID8gaGVscGVyLmNhbGwoZGVwdGgwLCAoKHN0YWNrMSA9IChkYXRhID09IG51bGwgfHwgZGF0YSA9PT0gZmFsc2UgPyBkYXRhIDogZ2V0KGRhdGEsIFwiY29uZmlnXCIsIFwiZGF0YVwiKSkpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBnZXQoc3RhY2sxLCBcImZ1bGxVcmxcIiwgXCJzdGFjazFcIikpLCAoKHN0YWNrMSA9IChkYXRhID09IG51bGwgfHwgZGF0YSA9PT0gZmFsc2UgPyBkYXRhIDogZ2V0KGRhdGEsIFwiY29uZmlnXCIsIFwiZGF0YVwiKSkpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBnZXQoc3RhY2sxLCBcInNpdGVVcmxcIiwgXCJzdGFjazFcIikpLCBvcHRpb25zKSA6IGhlbHBlck1pc3NpbmcuY2FsbChkZXB0aDAsIFwidW5sZXNzRXF1YWxcIiwgKChzdGFjazEgPSAoZGF0YSA9PSBudWxsIHx8IGRhdGEgPT09IGZhbHNlID8gZGF0YSA6IGdldChkYXRhLCBcImNvbmZpZ1wiLCBcImRhdGFcIikpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogZ2V0KHN0YWNrMSwgXCJmdWxsVXJsXCIsIFwic3RhY2sxXCIpKSwgKChzdGFjazEgPSAoZGF0YSA9PSBudWxsIHx8IGRhdGEgPT09IGZhbHNlID8gZGF0YSA6IGdldChkYXRhLCBcImNvbmZpZ1wiLCBcImRhdGFcIikpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogZ2V0KHN0YWNrMSwgXCJzaXRlVXJsXCIsIFwic3RhY2sxXCIpKSwgb3B0aW9ucykpO1xuICByZXR1cm4gc3RhY2syO1xuICB9O1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGNyZWF0ZURPTShzdGFjazEpKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICBcIikpO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5mdW5jdGlvbiBwcm9ncmFtMTUzKGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwiYnRuLWZvb3RlciBub3RlYm9vay1leGVjIGhpbnQtLXRvcFwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW0xNTUoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJFeGVjdXRlIGFsbCBjZWxsc1wiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW0xNTcoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIHN0YWNrMSwgZWxlbWVudDE7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgICAgIFBsYXkgbm90ZWJvb2tcIikpO1xuICBzdGFjazEgPSBlbGVtZW50MSA9IGNyZWF0ZUVsZW1lbnQocGFydGlhbChzZWxmLnByb2dyYW0oNDAsIHByb2dyYW00MCwgZGF0YSksIGRlcHRoMCksIGZ1bmN0aW9uIChlbCkgeyBlbGVtZW50MSA9IGVsOyB9KTtcbiAgc2V0QXR0cmlidXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVsZW1lbnQxOyB9LCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSg0LCBwcm9ncmFtNCwgZGF0YSksIGRlcHRoMCksIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDExMywgcHJvZ3JhbTExMywgZGF0YSksIGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChlbGVtZW50MSwgc2VsZi5wcm9ncmFtKDIxLCBwcm9ncmFtMjEsIGRhdGEpKGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIHN0YWNrMSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgICBcIikpO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW0xNTkoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIHN0YWNrMSwgZWxlbWVudDE7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgICAgIFwiKSk7XG4gIHN0YWNrMSA9IGVsZW1lbnQxID0gY3JlYXRlRWxlbWVudChwYXJ0aWFsKHNlbGYucHJvZ3JhbSgxMzAsIHByb2dyYW0xMzAsIGRhdGEpLCBkZXB0aDApLCBmdW5jdGlvbiAoZWwpIHsgZWxlbWVudDEgPSBlbDsgfSk7XG4gIHNldEF0dHJpYnV0ZShmdW5jdGlvbiAoKSB7IHJldHVybiBlbGVtZW50MTsgfSwgcGFydGlhbChzZWxmLnByb2dyYW0oMTMyLCBwcm9ncmFtMTMyLCBkYXRhKSwgZGVwdGgwKSwgcGFydGlhbChzZWxmLnByb2dyYW0oMTYwLCBwcm9ncmFtMTYwLCBkYXRhKSwgZGVwdGgwKSk7XG4gIHNldEF0dHJpYnV0ZShmdW5jdGlvbiAoKSB7IHJldHVybiBlbGVtZW50MTsgfSwgcGFydGlhbChzZWxmLnByb2dyYW0oNCwgcHJvZ3JhbTQsIGRhdGEpLCBkZXB0aDApLCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSgxNjIsIHByb2dyYW0xNjIsIGRhdGEpLCBkZXB0aDApKTtcbiAgc2V0QXR0cmlidXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVsZW1lbnQxOyB9LCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSgzNSwgcHJvZ3JhbTM1LCBkYXRhKSwgZGVwdGgwKSwgcGFydGlhbChzZWxmLnByb2dyYW0oMTY0LCBwcm9ncmFtMTY0LCBkYXRhKSwgZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGVsZW1lbnQxLCBzZWxmLnByb2dyYW0oMTY2LCBwcm9ncmFtMTY2LCBkYXRhKShkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBzdGFjazEpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgXCIpKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuZnVuY3Rpb24gcHJvZ3JhbTE2MChkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIHN0YWNrMTtcbiAgcmV0dXJuIGVzY2FwZUV4cHJlc3Npb24oKChzdGFjazEgPSAoKHN0YWNrMSA9IChkYXRhID09IG51bGwgfHwgZGF0YSA9PT0gZmFsc2UgPyBkYXRhIDogZ2V0KGRhdGEsIFwiY29uZmlnXCIsIFwiZGF0YVwiKSkpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBnZXQoc3RhY2sxLCBcImZ1bGxVcmxcIiwgXCJzdGFjazFcIikpKSx0eXBlb2Ygc3RhY2sxID09PSBmdW5jdGlvblR5cGUgPyBzdGFjazEuYXBwbHkoZGVwdGgwKSA6IHN0YWNrMSkpO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW0xNjIoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJidG4tZm9vdGVyIGhpbnQtLXRvcFwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW0xNjQoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJNYWtlIHlvdXIgb3duIGNvcHkgb2YgdGhpcyBub3RlYm9va1wiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW0xNjYoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIHN0YWNrMSwgZWxlbWVudDE7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgICAgICAgQ2xvbmUgbm90ZWJvb2tcIikpO1xuICBzdGFjazEgPSBlbGVtZW50MSA9IGNyZWF0ZUVsZW1lbnQocGFydGlhbChzZWxmLnByb2dyYW0oNDAsIHByb2dyYW00MCwgZGF0YSksIGRlcHRoMCksIGZ1bmN0aW9uIChlbCkgeyBlbGVtZW50MSA9IGVsOyB9KTtcbiAgc2V0QXR0cmlidXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVsZW1lbnQxOyB9LCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSg0LCBwcm9ncmFtNCwgZGF0YSksIGRlcHRoMCksIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDk3LCBwcm9ncmFtOTcsIGRhdGEpLCBkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoZWxlbWVudDEsIHNlbGYucHJvZ3JhbSgyMSwgcHJvZ3JhbTIxLCBkYXRhKShkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBzdGFjazEpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgICBcIikpO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW0xNjgoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJmb290ZXItaW5uZXJcIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtMTcwKGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBzdGFjazEsIHN0YWNrMjtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICAgIFwiKSk7XG4gIHN0YWNrMSA9IGZ1bmN0aW9uICgpIHtcbiAgc3RhY2syID0gaGVscGVyc1snaWYnXS5jYWxsKGRlcHRoMCwgKChzdGFjazEgPSAoZGF0YSA9PSBudWxsIHx8IGRhdGEgPT09IGZhbHNlID8gZGF0YSA6IGdldChkYXRhLCBcImRhdGFcIiwgXCJkYXRhXCIpKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IGdldChzdGFjazEsIFwic2hhcmVhYmxlXCIsIFwic3RhY2sxXCIpKSwge2hhc2g6e30saW52ZXJzZTp3cmFwUHJvZ3JhbShzZWxmLnByb2dyYW0oMTc4LCBwcm9ncmFtMTc4LCBkYXRhKSksZm46d3JhcFByb2dyYW0oc2VsZi5wcm9ncmFtKDE3MSwgcHJvZ3JhbTE3MSwgZGF0YSkpLGRhdGE6ZGF0YSxhdHRyaWJ1dGU6ZmFsc2UsdXBkYXRlOnNlbGYuc3Vic2NyaXB0aW9uLmJvdW5kVXBkYXRlLHVuc3Vic2NyaWJlOnNlbGYuc3Vic2NyaXB0aW9uLmJvdW5kVW5zdWJzY3JpcHRpb259KTtcbiAgcmV0dXJuIHN0YWNrMjtcbiAgfTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBjcmVhdGVET00oc3RhY2sxKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgXCIpKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuZnVuY3Rpb24gcHJvZ3JhbTE3MShkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgc3RhY2sxLCBlbGVtZW50MSwgZWxlbWVudDI7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgICAgIFwiKSk7XG4gIHN0YWNrMSA9IGVsZW1lbnQxID0gY3JlYXRlRWxlbWVudChwYXJ0aWFsKHNlbGYucHJvZ3JhbSgxMzAsIHByb2dyYW0xMzAsIGRhdGEpLCBkZXB0aDApLCBmdW5jdGlvbiAoZWwpIHsgZWxlbWVudDEgPSBlbDsgfSk7XG4gIHNldEF0dHJpYnV0ZShmdW5jdGlvbiAoKSB7IHJldHVybiBlbGVtZW50MTsgfSwgcGFydGlhbChzZWxmLnByb2dyYW0oMTMyLCBwcm9ncmFtMTMyLCBkYXRhKSwgZGVwdGgwKSwgcGFydGlhbChzZWxmLnByb2dyYW0oMTYwLCBwcm9ncmFtMTYwLCBkYXRhKSwgZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGVsZW1lbnQxLCBzZWxmLnByb2dyYW0oMTcyLCBwcm9ncmFtMTcyLCBkYXRhKShkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBzdGFjazEpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiIGhvc3RlZCBieSBcIikpO1xuICBzdGFjazEgPSBlbGVtZW50MiA9IGNyZWF0ZUVsZW1lbnQocGFydGlhbChzZWxmLnByb2dyYW0oMTMwLCBwcm9ncmFtMTMwLCBkYXRhKSwgZGVwdGgwKSwgZnVuY3Rpb24gKGVsKSB7IGVsZW1lbnQyID0gZWw7IH0pO1xuICBzZXRBdHRyaWJ1dGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZWxlbWVudDI7IH0sIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDEzMiwgcHJvZ3JhbTEzMiwgZGF0YSksIGRlcHRoMCksIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDE3NCwgcHJvZ3JhbTE3NCwgZGF0YSksIGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChlbGVtZW50Miwgc2VsZi5wcm9ncmFtKDE3NiwgcHJvZ3JhbTE3NiwgZGF0YSkoZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgc3RhY2sxKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICAgIFwiKSk7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cbmZ1bmN0aW9uIHByb2dyYW0xNzIoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBzdGFjazEsIHN0YWNrMjtcbiAgc3RhY2sxID0gZnVuY3Rpb24gKCkge1xuICBzdGFjazIgPSAoKHN0YWNrMSA9ICgoc3RhY2sxID0gKChzdGFjazEgPSAoKHN0YWNrMSA9IChkYXRhID09IG51bGwgfHwgZGF0YSA9PT0gZmFsc2UgPyBkYXRhIDogZ2V0KGRhdGEsIFwicGVyc2lzdGVuY2VcIiwgXCJkYXRhXCIpKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IGdldChzdGFjazEsIFwibm90ZWJvb2tcIiwgXCJzdGFjazFcIikpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogZ2V0KHN0YWNrMSwgXCJtZXRhXCIsIFwic3RhY2sxXCIpKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IGdldChzdGFjazEsIFwidGl0bGVcIiwgXCJzdGFjazFcIikpKSx0eXBlb2Ygc3RhY2sxID09PSBmdW5jdGlvblR5cGUgPyBzdGFjazEuYXBwbHkoZGVwdGgwKSA6IHN0YWNrMSk7XG4gIHJldHVybiBzdGFjazI7XG4gIH07XG4gIHJldHVybiBjcmVhdGVUZXh0KHN0YWNrMSk7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTE3NChkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIHN0YWNrMTtcbiAgcmV0dXJuIGVzY2FwZUV4cHJlc3Npb24oKChzdGFjazEgPSAoKHN0YWNrMSA9IChkYXRhID09IG51bGwgfHwgZGF0YSA9PT0gZmFsc2UgPyBkYXRhIDogZ2V0KGRhdGEsIFwiY29uZmlnXCIsIFwiZGF0YVwiKSkpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBnZXQoc3RhY2sxLCBcInNpdGVVcmxcIiwgXCJzdGFjazFcIikpKSx0eXBlb2Ygc3RhY2sxID09PSBmdW5jdGlvblR5cGUgPyBzdGFjazEuYXBwbHkoZGVwdGgwKSA6IHN0YWNrMSkpO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW0xNzYoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBzdGFjazEsIHN0YWNrMjtcbiAgc3RhY2sxID0gZnVuY3Rpb24gKCkge1xuICBzdGFjazIgPSAoKHN0YWNrMSA9ICgoc3RhY2sxID0gKGRhdGEgPT0gbnVsbCB8fCBkYXRhID09PSBmYWxzZSA/IGRhdGEgOiBnZXQoZGF0YSwgXCJjb25maWdcIiwgXCJkYXRhXCIpKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IGdldChzdGFjazEsIFwic2l0ZVRpdGxlXCIsIFwic3RhY2sxXCIpKSksdHlwZW9mIHN0YWNrMSA9PT0gZnVuY3Rpb25UeXBlID8gc3RhY2sxLmFwcGx5KGRlcHRoMCkgOiBzdGFjazEpO1xuICByZXR1cm4gc3RhY2syO1xuICB9O1xuICByZXR1cm4gY3JlYXRlVGV4dChzdGFjazEpO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW0xNzgoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIHN0YWNrMSwgZWxlbWVudDE7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgICAgIEhvc3RlZCBieSBcIikpO1xuICBzdGFjazEgPSBlbGVtZW50MSA9IGNyZWF0ZUVsZW1lbnQocGFydGlhbChzZWxmLnByb2dyYW0oMTMwLCBwcm9ncmFtMTMwLCBkYXRhKSwgZGVwdGgwKSwgZnVuY3Rpb24gKGVsKSB7IGVsZW1lbnQxID0gZWw7IH0pO1xuICBzZXRBdHRyaWJ1dGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZWxlbWVudDE7IH0sIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDEzMiwgcHJvZ3JhbTEzMiwgZGF0YSksIGRlcHRoMCksIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDE3NCwgcHJvZ3JhbTE3NCwgZGF0YSksIGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChlbGVtZW50MSwgc2VsZi5wcm9ncmFtKDE3NiwgcHJvZ3JhbTE3NiwgZGF0YSkoZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgc3RhY2sxKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICAgIFwiKSk7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cblxuICBzdGFjazEgPSBmdW5jdGlvbiAoKSB7XG4gIHN0YWNrMiA9IGhlbHBlcnNbJ2lmJ10uY2FsbChkZXB0aDAsICgoc3RhY2sxID0gKGRhdGEgPT0gbnVsbCB8fCBkYXRhID09PSBmYWxzZSA/IGRhdGEgOiBnZXQoZGF0YSwgXCJjb25maWdcIiwgXCJkYXRhXCIpKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IGdldChzdGFjazEsIFwiaGVhZGVyXCIsIFwic3RhY2sxXCIpKSwge2hhc2g6e30saW52ZXJzZTp3cmFwUHJvZ3JhbShzZWxmLm5vb3ApLGZuOndyYXBQcm9ncmFtKHNlbGYucHJvZ3JhbSgxLCBwcm9ncmFtMSwgZGF0YSkpLGRhdGE6ZGF0YSxhdHRyaWJ1dGU6ZmFsc2UsdXBkYXRlOnNlbGYuc3Vic2NyaXB0aW9uLmJvdW5kVXBkYXRlLHVuc3Vic2NyaWJlOnNlbGYuc3Vic2NyaXB0aW9uLmJvdW5kVW5zdWJzY3JpcHRpb259KTtcbiAgcmV0dXJuIHN0YWNrMjtcbiAgfTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBjcmVhdGVET00oc3RhY2sxKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG5cXG5cIikpO1xuICBzdGFjazEgPSBlbGVtZW50MSA9IGNyZWF0ZUVsZW1lbnQocGFydGlhbChzZWxmLnByb2dyYW0oMjMsIHByb2dyYW0yMywgZGF0YSksIGRlcHRoMCksIGZ1bmN0aW9uIChlbCkgeyBlbGVtZW50MSA9IGVsOyB9KTtcbiAgc2V0QXR0cmlidXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVsZW1lbnQxOyB9LCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSg0LCBwcm9ncmFtNCwgZGF0YSksIGRlcHRoMCksIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDEyMSwgcHJvZ3JhbTEyMSwgZGF0YSksIGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChlbGVtZW50MSwgc2VsZi5wcm9ncmFtKDEyMywgcHJvZ3JhbTEyMywgZGF0YSkoZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgc3RhY2sxKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcblxcblwiKSk7XG4gIHN0YWNrMSA9IGZ1bmN0aW9uICgpIHtcbiAgc3RhY2syID0gaGVscGVyc1snaWYnXS5jYWxsKGRlcHRoMCwgKChzdGFjazEgPSAoZGF0YSA9PSBudWxsIHx8IGRhdGEgPT09IGZhbHNlID8gZGF0YSA6IGdldChkYXRhLCBcInN0YXRlXCIsIFwiZGF0YVwiKSkpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBnZXQoc3RhY2sxLCBcImxvYWRpbmdcIiwgXCJzdGFjazFcIikpLCB7aGFzaDp7fSxpbnZlcnNlOndyYXBQcm9ncmFtKHNlbGYubm9vcCksZm46d3JhcFByb2dyYW0oc2VsZi5wcm9ncmFtKDE0MCwgcHJvZ3JhbTE0MCwgZGF0YSkpLGRhdGE6ZGF0YSxhdHRyaWJ1dGU6ZmFsc2UsdXBkYXRlOnNlbGYuc3Vic2NyaXB0aW9uLmJvdW5kVXBkYXRlLHVuc3Vic2NyaWJlOnNlbGYuc3Vic2NyaXB0aW9uLmJvdW5kVW5zdWJzY3JpcHRpb259KTtcbiAgcmV0dXJuIHN0YWNrMjtcbiAgfTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBjcmVhdGVET00oc3RhY2sxKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG5cXG5cIikpO1xuICBzdGFjazEgPSBmdW5jdGlvbiAoKSB7XG4gIHN0YWNrMiA9IGhlbHBlcnNbJ2lmJ10uY2FsbChkZXB0aDAsICgoc3RhY2sxID0gKGRhdGEgPT0gbnVsbCB8fCBkYXRhID09PSBmYWxzZSA/IGRhdGEgOiBnZXQoZGF0YSwgXCJjb25maWdcIiwgXCJkYXRhXCIpKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IGdldChzdGFjazEsIFwiZm9vdGVyXCIsIFwic3RhY2sxXCIpKSwge2hhc2g6e30saW52ZXJzZTp3cmFwUHJvZ3JhbShzZWxmLm5vb3ApLGZuOndyYXBQcm9ncmFtKHNlbGYucHJvZ3JhbSgxNDYsIHByb2dyYW0xNDYsIGRhdGEpKSxkYXRhOmRhdGEsYXR0cmlidXRlOmZhbHNlLHVwZGF0ZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVwZGF0ZSx1bnN1YnNjcmliZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVuc3Vic2NyaXB0aW9ufSk7XG4gIHJldHVybiBzdGFjazI7XG4gIH07XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgY3JlYXRlRE9NKHN0YWNrMSkpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuXCIpKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfSk7IiwiLy8gRE9NQmFyc2lmeSBjb21waWxlZCB0ZW1wbGF0ZVxudmFyIERPTUJhcnMgPSByZXF1aXJlKFwiZG9tYmFycy9ydW50aW1lXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBET01CYXJzLnRlbXBsYXRlKGZ1bmN0aW9uIChIYW5kbGViYXJzLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgdGhpcy5jb21waWxlckluZm8gPSBbNCwnPj0gMS4wLjAnXTtcbmhlbHBlcnMgPSB0aGlzLm1lcmdlKGhlbHBlcnMsIEhhbmRsZWJhcnMuaGVscGVycyk7IGRhdGEgPSBkYXRhIHx8IHt9O1xuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBzdGFjazEsIGVsZW1lbnQxLCBmdW5jdGlvblR5cGU9XCJmdW5jdGlvblwiLCBzZWxmPXRoaXMsIGdldD10aGlzLmdldCwgZXNjYXBlRXhwcmVzc2lvbj10aGlzLmVzY2FwZUV4cHJlc3Npb24sIGNyZWF0ZVRleHQ9dGhpcy5jcmVhdGVUZXh0LCBhcHBlbmRDaGlsZD10aGlzLmFwcGVuZENoaWxkLCBwYXJ0aWFsPXRoaXMucGFydGlhbCwgY3JlYXRlRWxlbWVudD10aGlzLmNyZWF0ZUVsZW1lbnQsIHNldEF0dHJpYnV0ZT10aGlzLnNldEF0dHJpYnV0ZSwgd3JhcFByb2dyYW09dGhpcy53cmFwUHJvZ3JhbSwgY3JlYXRlRE9NPXRoaXMuY3JlYXRlRE9NO1xuXG5mdW5jdGlvbiBwcm9ncmFtMShkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcImRpdlwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW0zKGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwiY2xhc3NcIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtNShkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcImNlbGwtYnV0dG9ucy1jb250YWluZXJcIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtNyhkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgc3RhY2sxLCBzdGFjazI7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gIFwiKSk7XG4gIHN0YWNrMSA9IGZ1bmN0aW9uICgpIHtcbiAgc3RhY2syID0gaGVscGVycy5lYWNoLmNhbGwoZGVwdGgwLCAoKHN0YWNrMSA9ICgoc3RhY2sxID0gKGRhdGEgPT0gbnVsbCB8fCBkYXRhID09PSBmYWxzZSA/IGRhdGEgOiBnZXQoZGF0YSwgXCJ2aWV3XCIsIFwiZGF0YVwiKSkpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBnZXQoc3RhY2sxLCBcImNvbnN0cnVjdG9yXCIsIFwic3RhY2sxXCIpKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IGdldChzdGFjazEsIFwiY29udHJvbHNcIiwgXCJzdGFjazFcIikpLCB7aGFzaDp7fSxpbnZlcnNlOndyYXBQcm9ncmFtKHNlbGYubm9vcCksZm46d3JhcFByb2dyYW0oc2VsZi5wcm9ncmFtKDgsIHByb2dyYW04LCBkYXRhKSksZGF0YTpkYXRhLGF0dHJpYnV0ZTpmYWxzZSx1cGRhdGU6c2VsZi5zdWJzY3JpcHRpb24uYm91bmRVcGRhdGUsdW5zdWJzY3JpYmU6c2VsZi5zdWJzY3JpcHRpb24uYm91bmRVbnN1YnNjcmlwdGlvbn0pO1xuICByZXR1cm4gc3RhY2syO1xuICB9O1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGNyZWF0ZURPTShzdGFjazEpKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcblwiKSk7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cbmZ1bmN0aW9uIHByb2dyYW04KGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBzdGFjazEsIGVsZW1lbnQxO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICBcIikpO1xuICBzdGFjazEgPSBlbGVtZW50MSA9IGNyZWF0ZUVsZW1lbnQocGFydGlhbChzZWxmLnByb2dyYW0oOSwgcHJvZ3JhbTksIGRhdGEpLCBkZXB0aDApLCBmdW5jdGlvbiAoZWwpIHsgZWxlbWVudDEgPSBlbDsgfSk7XG4gIHNldEF0dHJpYnV0ZShmdW5jdGlvbiAoKSB7IHJldHVybiBlbGVtZW50MTsgfSwgcGFydGlhbChzZWxmLnByb2dyYW0oMywgcHJvZ3JhbTMsIGRhdGEpLCBkZXB0aDApLCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSgxMSwgcHJvZ3JhbTExLCBkYXRhKSwgZGVwdGgwKSk7XG4gIHNldEF0dHJpYnV0ZShmdW5jdGlvbiAoKSB7IHJldHVybiBlbGVtZW50MTsgfSwgcGFydGlhbChzZWxmLnByb2dyYW0oMTMsIHByb2dyYW0xMywgZGF0YSksIGRlcHRoMCksIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDE1LCBwcm9ncmFtMTUsIGRhdGEpLCBkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoZWxlbWVudDEsIHNlbGYucHJvZ3JhbSgxNywgcHJvZ3JhbTE3LCBkYXRhKShkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBzdGFjazEpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICBcIikpO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5mdW5jdGlvbiBwcm9ncmFtOShkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcImJ1dHRvblwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW0xMShkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcImFjdGlvblwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW0xMyhkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcImRhdGEtYWN0aW9uXCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTE1KGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgc3RhY2sxLCBoZWxwZXI7XG4gIGlmIChoZWxwZXIgPSBoZWxwZXJzLmNvbW1hbmQpIHsgc3RhY2sxID0gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGEsYXR0cmlidXRlOnRydWUsdXBkYXRlOnNlbGYuc3Vic2NyaXB0aW9uLmJvdW5kVXBkYXRlLHVuc3Vic2NyaWJlOnNlbGYuc3Vic2NyaXB0aW9uLmJvdW5kVW5zdWJzY3JpcHRpb259KTsgfVxuICBlbHNlIHsgaGVscGVyID0gZ2V0KGRlcHRoMCwgXCJjb21tYW5kXCIsIFwiZGVwdGgwXCIpOyBzdGFjazEgPSB0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YSxhdHRyaWJ1dGU6dHJ1ZSx1cGRhdGU6c2VsZi5zdWJzY3JpcHRpb24uYm91bmRVcGRhdGUsdW5zdWJzY3JpYmU6c2VsZi5zdWJzY3JpcHRpb24uYm91bmRVbnN1YnNjcmlwdGlvbn0pIDogaGVscGVyOyB9XG4gIHJldHVybiBlc2NhcGVFeHByZXNzaW9uKHN0YWNrMSk7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTE3KGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgc3RhY2sxLCBzdGFjazIsIGhlbHBlcjtcbiAgc3RhY2sxID0gZnVuY3Rpb24gKCkge1xuICBpZiAoaGVscGVyID0gaGVscGVycy5sYWJlbCkgeyBzdGFjazIgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YSxhdHRyaWJ1dGU6ZmFsc2UsdXBkYXRlOnNlbGYuc3Vic2NyaXB0aW9uLmJvdW5kVXBkYXRlLHVuc3Vic2NyaWJlOnNlbGYuc3Vic2NyaXB0aW9uLmJvdW5kVW5zdWJzY3JpcHRpb259KTsgfVxuICBlbHNlIHsgaGVscGVyID0gZ2V0KGRlcHRoMCwgXCJsYWJlbFwiLCBcImRlcHRoMFwiKTsgc3RhY2syID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGEsYXR0cmlidXRlOmZhbHNlLHVwZGF0ZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVwZGF0ZSx1bnN1YnNjcmliZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVuc3Vic2NyaXB0aW9ufSkgOiBoZWxwZXI7IH1cbiAgcmV0dXJuIHN0YWNrMjtcbiAgfTtcbiAgcmV0dXJuIGNyZWF0ZVRleHQoc3RhY2sxKTtcbiAgfVxuXG4gIHN0YWNrMSA9IGVsZW1lbnQxID0gY3JlYXRlRWxlbWVudChwYXJ0aWFsKHNlbGYucHJvZ3JhbSgxLCBwcm9ncmFtMSwgZGF0YSksIGRlcHRoMCksIGZ1bmN0aW9uIChlbCkgeyBlbGVtZW50MSA9IGVsOyB9KTtcbiAgc2V0QXR0cmlidXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVsZW1lbnQxOyB9LCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSgzLCBwcm9ncmFtMywgZGF0YSksIGRlcHRoMCksIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDUsIHByb2dyYW01LCBkYXRhKSwgZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGVsZW1lbnQxLCBzZWxmLnByb2dyYW0oNywgcHJvZ3JhbTcsIGRhdGEpKGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIHN0YWNrMSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG5cIikpO1xuICByZXR1cm4gYnVmZmVyO1xuICB9KTsiLCIvLyBET01CYXJzaWZ5IGNvbXBpbGVkIHRlbXBsYXRlXG52YXIgRE9NQmFycyA9IHJlcXVpcmUoXCJkb21iYXJzL3J1bnRpbWVcIik7XG5tb2R1bGUuZXhwb3J0cyA9IERPTUJhcnMudGVtcGxhdGUoZnVuY3Rpb24gKEhhbmRsZWJhcnMsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICB0aGlzLmNvbXBpbGVySW5mbyA9IFs0LCc+PSAxLjAuMCddO1xuaGVscGVycyA9IHRoaXMubWVyZ2UoaGVscGVycywgSGFuZGxlYmFycy5oZWxwZXJzKTsgZGF0YSA9IGRhdGEgfHwge307XG4gIHZhciBidWZmZXIgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIHN0YWNrMSwgc3RhY2syLCBmdW5jdGlvblR5cGU9XCJmdW5jdGlvblwiLCBzZWxmPXRoaXMsIGdldD10aGlzLmdldCwgZXNjYXBlRXhwcmVzc2lvbj10aGlzLmVzY2FwZUV4cHJlc3Npb24sIGNyZWF0ZVRleHQ9dGhpcy5jcmVhdGVUZXh0LCBhcHBlbmRDaGlsZD10aGlzLmFwcGVuZENoaWxkLCBwYXJ0aWFsPXRoaXMucGFydGlhbCwgY3JlYXRlRWxlbWVudD10aGlzLmNyZWF0ZUVsZW1lbnQsIHdyYXBQcm9ncmFtPXRoaXMud3JhcFByb2dyYW0sIGNyZWF0ZURPTT10aGlzLmNyZWF0ZURPTSwgc2V0QXR0cmlidXRlPXRoaXMuc2V0QXR0cmlidXRlO1xuXG5mdW5jdGlvbiBwcm9ncmFtMShkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgc3RhY2sxLCBlbGVtZW50MTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcblwiKSk7XG4gIHN0YWNrMSA9IGVsZW1lbnQxID0gY3JlYXRlRWxlbWVudChwYXJ0aWFsKHNlbGYucHJvZ3JhbSgyLCBwcm9ncmFtMiwgZGF0YSksIGRlcHRoMCksIGZ1bmN0aW9uIChlbCkgeyBlbGVtZW50MSA9IGVsOyB9KTtcbiAgc2V0QXR0cmlidXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVsZW1lbnQxOyB9LCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSg0LCBwcm9ncmFtNCwgZGF0YSksIGRlcHRoMCksIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDYsIHByb2dyYW02LCBkYXRhKSwgZGVwdGgwKSk7XG4gIHNldEF0dHJpYnV0ZShmdW5jdGlvbiAoKSB7IHJldHVybiBlbGVtZW50MTsgfSwgcGFydGlhbChzZWxmLnByb2dyYW0oOCwgcHJvZ3JhbTgsIGRhdGEpLCBkZXB0aDApLCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSgxMCwgcHJvZ3JhbTEwLCBkYXRhKSwgZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGVsZW1lbnQxLCBzZWxmLnByb2dyYW0oMTIsIHByb2dyYW0xMiwgZGF0YSkoZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgc3RhY2sxKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcblwiKSk7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cbmZ1bmN0aW9uIHByb2dyYW0yKGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwiYnV0dG9uXCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTQoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJjbGFzc1wiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW02KGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwiYWN0aW9uXCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTgoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJkYXRhLWFjdGlvblwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW0xMChkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIHN0YWNrMSwgaGVscGVyO1xuICBpZiAoaGVscGVyID0gaGVscGVycy5jb21tYW5kKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhLGF0dHJpYnV0ZTp0cnVlLHVwZGF0ZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVwZGF0ZSx1bnN1YnNjcmliZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVuc3Vic2NyaXB0aW9ufSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IGdldChkZXB0aDAsIFwiY29tbWFuZFwiLCBcImRlcHRoMFwiKTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGEsYXR0cmlidXRlOnRydWUsdXBkYXRlOnNlbGYuc3Vic2NyaXB0aW9uLmJvdW5kVXBkYXRlLHVuc3Vic2NyaWJlOnNlbGYuc3Vic2NyaXB0aW9uLmJvdW5kVW5zdWJzY3JpcHRpb259KSA6IGhlbHBlcjsgfVxuICByZXR1cm4gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW0xMihkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgc3RhY2sxLCBzdGFjazIsIGhlbHBlcjtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgXCIpKTtcbiAgc3RhY2sxID0gZnVuY3Rpb24gKCkge1xuICBpZiAoaGVscGVyID0gaGVscGVycy5sYWJlbCkgeyBzdGFjazIgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YSxhdHRyaWJ1dGU6ZmFsc2UsdXBkYXRlOnNlbGYuc3Vic2NyaXB0aW9uLmJvdW5kVXBkYXRlLHVuc3Vic2NyaWJlOnNlbGYuc3Vic2NyaXB0aW9uLmJvdW5kVW5zdWJzY3JpcHRpb259KTsgfVxuICBlbHNlIHsgaGVscGVyID0gZ2V0KGRlcHRoMCwgXCJsYWJlbFwiLCBcImRlcHRoMFwiKTsgc3RhY2syID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGEsYXR0cmlidXRlOmZhbHNlLHVwZGF0ZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVwZGF0ZSx1bnN1YnNjcmliZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVuc3Vic2NyaXB0aW9ufSkgOiBoZWxwZXI7IH1cbiAgcmV0dXJuIHN0YWNrMjtcbiAgfTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBjcmVhdGVUZXh0KHN0YWNrMSkpO1xuICBzdGFjazEgPSBmdW5jdGlvbiAoKSB7XG4gIHN0YWNrMiA9IGhlbHBlcnNbJ2lmJ10uY2FsbChkZXB0aDAsIGdldChkZXB0aDAsIFwia2V5Q29kZVwiLCBcImRlcHRoMFwiKSwge2hhc2g6e30saW52ZXJzZTp3cmFwUHJvZ3JhbShzZWxmLm5vb3ApLGZuOndyYXBQcm9ncmFtKHNlbGYucHJvZ3JhbSgxMywgcHJvZ3JhbTEzLCBkYXRhKSksZGF0YTpkYXRhLGF0dHJpYnV0ZTpmYWxzZSx1cGRhdGU6c2VsZi5zdWJzY3JpcHRpb24uYm91bmRVcGRhdGUsdW5zdWJzY3JpYmU6c2VsZi5zdWJzY3JpcHRpb24uYm91bmRVbnN1YnNjcmlwdGlvbn0pO1xuICByZXR1cm4gc3RhY2syO1xuICB9O1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGNyZWF0ZURPTShzdGFjazEpKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcblwiKSk7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cbmZ1bmN0aW9uIHByb2dyYW0xMyhkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgc3RhY2sxLCBlbGVtZW50MTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIiBcIikpO1xuICBzdGFjazEgPSBlbGVtZW50MSA9IGNyZWF0ZUVsZW1lbnQocGFydGlhbChzZWxmLnByb2dyYW0oMTQsIHByb2dyYW0xNCwgZGF0YSksIGRlcHRoMCksIGZ1bmN0aW9uIChlbCkgeyBlbGVtZW50MSA9IGVsOyB9KTtcbiAgYXBwZW5kQ2hpbGQoZWxlbWVudDEsIHNlbGYucHJvZ3JhbSgxNiwgcHJvZ3JhbTE2LCBkYXRhKShkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBzdGFjazEpO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5mdW5jdGlvbiBwcm9ncmFtMTQoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJzcGFuXCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTE2KGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgc3RhY2sxLCBzdGFjazIsIGhlbHBlcjtcbiAgc3RhY2sxID0gZnVuY3Rpb24gKCkge1xuICBpZiAoaGVscGVyID0gaGVscGVycy5rZXlDb2RlKSB7IHN0YWNrMiA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhLGF0dHJpYnV0ZTpmYWxzZSx1cGRhdGU6c2VsZi5zdWJzY3JpcHRpb24uYm91bmRVcGRhdGUsdW5zdWJzY3JpYmU6c2VsZi5zdWJzY3JpcHRpb24uYm91bmRVbnN1YnNjcmlwdGlvbn0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSBnZXQoZGVwdGgwLCBcImtleUNvZGVcIiwgXCJkZXB0aDBcIik7IHN0YWNrMiA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhLGF0dHJpYnV0ZTpmYWxzZSx1cGRhdGU6c2VsZi5zdWJzY3JpcHRpb24uYm91bmRVcGRhdGUsdW5zdWJzY3JpYmU6c2VsZi5zdWJzY3JpcHRpb24uYm91bmRVbnN1YnNjcmlwdGlvbn0pIDogaGVscGVyOyB9XG4gIHJldHVybiBzdGFjazI7XG4gIH07XG4gIHJldHVybiBjcmVhdGVUZXh0KHN0YWNrMSk7XG4gIH1cblxuICBzdGFjazEgPSBmdW5jdGlvbiAoKSB7XG4gIHN0YWNrMiA9IGhlbHBlcnMuZWFjaC5jYWxsKGRlcHRoMCwgKChzdGFjazEgPSAoZGF0YSA9PSBudWxsIHx8IGRhdGEgPT09IGZhbHNlID8gZGF0YSA6IGdldChkYXRhLCBcImRhdGFcIiwgXCJkYXRhXCIpKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IGdldChzdGFjazEsIFwiY29udHJvbHNcIiwgXCJzdGFjazFcIikpLCB7aGFzaDp7fSxpbnZlcnNlOndyYXBQcm9ncmFtKHNlbGYubm9vcCksZm46d3JhcFByb2dyYW0oc2VsZi5wcm9ncmFtKDEsIHByb2dyYW0xLCBkYXRhKSksZGF0YTpkYXRhLGF0dHJpYnV0ZTpmYWxzZSx1cGRhdGU6c2VsZi5zdWJzY3JpcHRpb24uYm91bmRVcGRhdGUsdW5zdWJzY3JpYmU6c2VsZi5zdWJzY3JpcHRpb24uYm91bmRVbnN1YnNjcmlwdGlvbn0pO1xuICByZXR1cm4gc3RhY2syO1xuICB9O1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGNyZWF0ZURPTShzdGFjazEpKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcblwiKSk7XG4gIHJldHVybiBidWZmZXI7XG4gIH0pOyIsIi8vIERPTUJhcnNpZnkgY29tcGlsZWQgdGVtcGxhdGVcbnZhciBET01CYXJzID0gcmVxdWlyZShcImRvbWJhcnMvcnVudGltZVwiKTtcbm1vZHVsZS5leHBvcnRzID0gRE9NQmFycy50ZW1wbGF0ZShmdW5jdGlvbiAoSGFuZGxlYmFycyxkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gIHRoaXMuY29tcGlsZXJJbmZvID0gWzQsJz49IDEuMC4wJ107XG5oZWxwZXJzID0gdGhpcy5tZXJnZShoZWxwZXJzLCBIYW5kbGViYXJzLmhlbHBlcnMpOyBkYXRhID0gZGF0YSB8fCB7fTtcbiAgdmFyIGJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgc3RhY2sxLCBzdGFjazIsIGhlbHBlciwgb3B0aW9ucywgYXBwZW5kQ2hpbGQ9dGhpcy5hcHBlbmRDaGlsZCwgc2VsZj10aGlzLCBwYXJ0aWFsPXRoaXMucGFydGlhbCwgY3JlYXRlRWxlbWVudD10aGlzLmNyZWF0ZUVsZW1lbnQsIHNldEF0dHJpYnV0ZT10aGlzLnNldEF0dHJpYnV0ZSwgZ2V0PXRoaXMuZ2V0LCB3cmFwUHJvZ3JhbT10aGlzLndyYXBQcm9ncmFtLCBjcmVhdGVET009dGhpcy5jcmVhdGVET00sIGhlbHBlck1pc3Npbmc9aGVscGVycy5oZWxwZXJNaXNzaW5nO1xuXG5mdW5jdGlvbiBwcm9ncmFtMShkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgc3RhY2sxLCBlbGVtZW50MTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgXCIpKTtcbiAgc3RhY2sxID0gZWxlbWVudDEgPSBjcmVhdGVFbGVtZW50KHBhcnRpYWwoc2VsZi5wcm9ncmFtKDIsIHByb2dyYW0yLCBkYXRhKSwgZGVwdGgwKSwgZnVuY3Rpb24gKGVsKSB7IGVsZW1lbnQxID0gZWw7IH0pO1xuICBzZXRBdHRyaWJ1dGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZWxlbWVudDE7IH0sIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDQsIHByb2dyYW00LCBkYXRhKSwgZGVwdGgwKSwgcGFydGlhbChzZWxmLnByb2dyYW0oNiwgcHJvZ3JhbTYsIGRhdGEpLCBkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoZWxlbWVudDEsIHNlbGYucHJvZ3JhbSg4LCBwcm9ncmFtOCwgZGF0YSkoZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgc3RhY2sxKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcblwiKSk7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cbmZ1bmN0aW9uIHByb2dyYW0yKGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwiYnV0dG9uXCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTQoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJjbGFzc1wiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW02KGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwiYnRuIGNlbGwtY29udHJvbHMtYnRuIGNlbGwtZXhlY3V0ZVwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW04KGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBzdGFjazEsIGVsZW1lbnQxO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgIFwiKSk7XG4gIHN0YWNrMSA9IGVsZW1lbnQxID0gY3JlYXRlRWxlbWVudChwYXJ0aWFsKHNlbGYucHJvZ3JhbSg5LCBwcm9ncmFtOSwgZGF0YSksIGRlcHRoMCksIGZ1bmN0aW9uIChlbCkgeyBlbGVtZW50MSA9IGVsOyB9KTtcbiAgc2V0QXR0cmlidXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVsZW1lbnQxOyB9LCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSg0LCBwcm9ncmFtNCwgZGF0YSksIGRlcHRoMCksIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDExLCBwcm9ncmFtMTEsIGRhdGEpLCBkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoZWxlbWVudDEsIHNlbGYucHJvZ3JhbSgxMywgcHJvZ3JhbTEzLCBkYXRhKShkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBzdGFjazEpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICBcIikpO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5mdW5jdGlvbiBwcm9ncmFtOShkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcImlcIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtMTEoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJpY29uLXBsYXlcIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtMTMoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTE1KGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBzdGFjazEsIGVsZW1lbnQxO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICBcIikpO1xuICBzdGFjazEgPSBlbGVtZW50MSA9IGNyZWF0ZUVsZW1lbnQocGFydGlhbChzZWxmLnByb2dyYW0oOSwgcHJvZ3JhbTksIGRhdGEpLCBkZXB0aDApLCBmdW5jdGlvbiAoZWwpIHsgZWxlbWVudDEgPSBlbDsgfSk7XG4gIHNldEF0dHJpYnV0ZShmdW5jdGlvbiAoKSB7IHJldHVybiBlbGVtZW50MTsgfSwgcGFydGlhbChzZWxmLnByb2dyYW0oNCwgcHJvZ3JhbTQsIGRhdGEpLCBkZXB0aDApLCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSgxNiwgcHJvZ3JhbTE2LCBkYXRhKSwgZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGVsZW1lbnQxLCBzZWxmLnByb2dyYW0oMTMsIHByb2dyYW0xMywgZGF0YSkoZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgc3RhY2sxKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcblwiKSk7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cbmZ1bmN0aW9uIHByb2dyYW0xNihkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcImNlbGwtdWktZXhlY3V0ZSBpY29uLWFycm93cy1jdyBhbmltYXRlLXNwaW5cIjtcbiAgfVxuXG4gIHN0YWNrMSA9IGZ1bmN0aW9uICgpIHtcbiAgc3RhY2syID0gaGVscGVyc1snaWYnXS5jYWxsKGRlcHRoMCwgKChzdGFjazEgPSAoZGF0YSA9PSBudWxsIHx8IGRhdGEgPT09IGZhbHNlID8gZGF0YSA6IGdldChkYXRhLCBcImNvbmZpZ1wiLCBcImRhdGFcIikpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogZ2V0KHN0YWNrMSwgXCJlbWJlZGRlZFwiLCBcInN0YWNrMVwiKSksIHtoYXNoOnt9LGludmVyc2U6d3JhcFByb2dyYW0oc2VsZi5ub29wKSxmbjp3cmFwUHJvZ3JhbShzZWxmLnByb2dyYW0oMSwgcHJvZ3JhbTEsIGRhdGEpKSxkYXRhOmRhdGEsYXR0cmlidXRlOmZhbHNlLHVwZGF0ZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVwZGF0ZSx1bnN1YnNjcmliZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVuc3Vic2NyaXB0aW9ufSk7XG4gIHJldHVybiBzdGFjazI7XG4gIH07XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgY3JlYXRlRE9NKHN0YWNrMSkpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuXFxuXCIpKTtcbiAgc3RhY2sxID0gZnVuY3Rpb24gKCkge1xuICBzdGFjazIgPSBoZWxwZXJzWydpZiddLmNhbGwoZGVwdGgwLCAoKHN0YWNrMSA9IChkYXRhID09IG51bGwgfHwgZGF0YSA9PT0gZmFsc2UgPyBkYXRhIDogZ2V0KGRhdGEsIFwiZGF0YVwiLCBcImRhdGFcIikpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogZ2V0KHN0YWNrMSwgXCJleGVjdXRpbmdcIiwgXCJzdGFjazFcIikpLCB7aGFzaDp7fSxpbnZlcnNlOndyYXBQcm9ncmFtKHNlbGYubm9vcCksZm46d3JhcFByb2dyYW0oc2VsZi5wcm9ncmFtKDE1LCBwcm9ncmFtMTUsIGRhdGEpKSxkYXRhOmRhdGEsYXR0cmlidXRlOmZhbHNlLHVwZGF0ZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVwZGF0ZSx1bnN1YnNjcmliZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVuc3Vic2NyaXB0aW9ufSk7XG4gIHJldHVybiBzdGFjazI7XG4gIH07XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgY3JlYXRlRE9NKHN0YWNrMSkpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuXFxuXCIpKTtcbiAgc3RhY2sxID0gZnVuY3Rpb24gKCkge1xuICBzdGFjazIgPSAoaGVscGVyID0gaGVscGVycy52aWV3IHx8IGdldChkZXB0aDAsIFwidmlld1wiLCBcImRlcHRoMFwiKSxvcHRpb25zPXtoYXNoOnt9LGRhdGE6ZGF0YSxhdHRyaWJ1dGU6ZmFsc2UsdXBkYXRlOnNlbGYuc3Vic2NyaXB0aW9uLmJvdW5kVXBkYXRlLHVuc3Vic2NyaWJlOnNlbGYuc3Vic2NyaXB0aW9uLmJvdW5kVW5zdWJzY3JpcHRpb259LGhlbHBlciA/IGhlbHBlci5jYWxsKGRlcHRoMCwgKChzdGFjazEgPSAoZGF0YSA9PSBudWxsIHx8IGRhdGEgPT09IGZhbHNlID8gZGF0YSA6IGdldChkYXRhLCBcInZpZXdcIiwgXCJkYXRhXCIpKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IGdldChzdGFjazEsIFwicmVzdWx0Q2VsbFwiLCBcInN0YWNrMVwiKSksIG9wdGlvbnMpIDogaGVscGVyTWlzc2luZy5jYWxsKGRlcHRoMCwgXCJ2aWV3XCIsICgoc3RhY2sxID0gKGRhdGEgPT0gbnVsbCB8fCBkYXRhID09PSBmYWxzZSA/IGRhdGEgOiBnZXQoZGF0YSwgXCJ2aWV3XCIsIFwiZGF0YVwiKSkpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBnZXQoc3RhY2sxLCBcInJlc3VsdENlbGxcIiwgXCJzdGFjazFcIikpLCBvcHRpb25zKSk7XG4gIHJldHVybiBzdGFjazI7XG4gIH07XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgY3JlYXRlRE9NKHN0YWNrMSkpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuXCIpKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfSk7IiwiLy8gRE9NQmFyc2lmeSBjb21waWxlZCB0ZW1wbGF0ZVxudmFyIERPTUJhcnMgPSByZXF1aXJlKFwiZG9tYmFycy9ydW50aW1lXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBET01CYXJzLnRlbXBsYXRlKGZ1bmN0aW9uIChIYW5kbGViYXJzLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgdGhpcy5jb21waWxlckluZm8gPSBbNCwnPj0gMS4wLjAnXTtcbmhlbHBlcnMgPSB0aGlzLm1lcmdlKGhlbHBlcnMsIEhhbmRsZWJhcnMuaGVscGVycyk7IGRhdGEgPSBkYXRhIHx8IHt9O1xuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBzdGFjazEsIHN0YWNrMiwgYXBwZW5kQ2hpbGQ9dGhpcy5hcHBlbmRDaGlsZCwgZ2V0PXRoaXMuZ2V0LCBoZWxwZXJNaXNzaW5nPWhlbHBlcnMuaGVscGVyTWlzc2luZywgc2VsZj10aGlzLCBjcmVhdGVET009dGhpcy5jcmVhdGVET00sIHBhcnRpYWw9dGhpcy5wYXJ0aWFsLCBjcmVhdGVFbGVtZW50PXRoaXMuY3JlYXRlRWxlbWVudCwgc2V0QXR0cmlidXRlPXRoaXMuc2V0QXR0cmlidXRlLCB3cmFwUHJvZ3JhbT10aGlzLndyYXBQcm9ncmFtO1xuXG5mdW5jdGlvbiBwcm9ncmFtMShkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgc3RhY2sxLCBlbGVtZW50MSwgZWxlbWVudDIsIGVsZW1lbnQzO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICBcIikpO1xuICBzdGFjazEgPSBlbGVtZW50MSA9IGNyZWF0ZUVsZW1lbnQocGFydGlhbChzZWxmLnByb2dyYW0oMiwgcHJvZ3JhbTIsIGRhdGEpLCBkZXB0aDApLCBmdW5jdGlvbiAoZWwpIHsgZWxlbWVudDEgPSBlbDsgfSk7XG4gIHNldEF0dHJpYnV0ZShmdW5jdGlvbiAoKSB7IHJldHVybiBlbGVtZW50MTsgfSwgcGFydGlhbChzZWxmLnByb2dyYW0oNCwgcHJvZ3JhbTQsIGRhdGEpLCBkZXB0aDApLCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSg2LCBwcm9ncmFtNiwgZGF0YSksIGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChlbGVtZW50MSwgc2VsZi5wcm9ncmFtKDgsIHByb2dyYW04LCBkYXRhKShkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBzdGFjazEpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuXFxuICBcIikpO1xuICBzdGFjazEgPSBlbGVtZW50MiA9IGNyZWF0ZUVsZW1lbnQocGFydGlhbChzZWxmLnByb2dyYW0oMTAsIHByb2dyYW0xMCwgZGF0YSksIGRlcHRoMCksIGZ1bmN0aW9uIChlbCkgeyBlbGVtZW50MiA9IGVsOyB9KTtcbiAgc2V0QXR0cmlidXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVsZW1lbnQyOyB9LCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSg0LCBwcm9ncmFtNCwgZGF0YSksIGRlcHRoMCksIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDEyLCBwcm9ncmFtMTIsIGRhdGEpLCBkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoZWxlbWVudDIsIHNlbGYucHJvZ3JhbSgxNCwgcHJvZ3JhbTE0LCBkYXRhKShkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBzdGFjazEpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuXFxuICBcIikpO1xuICBzdGFjazEgPSBlbGVtZW50MyA9IGNyZWF0ZUVsZW1lbnQocGFydGlhbChzZWxmLnByb2dyYW0oMTAsIHByb2dyYW0xMCwgZGF0YSksIGRlcHRoMCksIGZ1bmN0aW9uIChlbCkgeyBlbGVtZW50MyA9IGVsOyB9KTtcbiAgc2V0QXR0cmlidXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVsZW1lbnQzOyB9LCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSg0LCBwcm9ncmFtNCwgZGF0YSksIGRlcHRoMCksIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDI3LCBwcm9ncmFtMjcsIGRhdGEpLCBkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoZWxlbWVudDMsIHNlbGYucHJvZ3JhbSgyOSwgcHJvZ3JhbTI5LCBkYXRhKShkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBzdGFjazEpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuXCIpKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuZnVuY3Rpb24gcHJvZ3JhbTIoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJidXR0b25cIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtNChkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcImNsYXNzXCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTYoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJidG4gY2VsbC1jb250cm9scy1idG4gY2VsbC1tZW51LXRvZ2dsZVwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW04KGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwi4omhXCIpO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW0xMChkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcImRpdlwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW0xMihkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcImNlbGwtYm9yZGVyIGNlbGwtYm9yZGVyLWFib3ZlXCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTE0KGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBzdGFjazEsIHN0YWNrMiwgZWxlbWVudDEsIGVsZW1lbnQyO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgIFwiKSk7XG4gIHN0YWNrMSA9IGVsZW1lbnQxID0gY3JlYXRlRWxlbWVudChwYXJ0aWFsKHNlbGYucHJvZ3JhbSgxNSwgcHJvZ3JhbTE1LCBkYXRhKSwgZGVwdGgwKSwgZnVuY3Rpb24gKGVsKSB7IGVsZW1lbnQxID0gZWw7IH0pO1xuICBzZXRBdHRyaWJ1dGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZWxlbWVudDE7IH0sIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDQsIHByb2dyYW00LCBkYXRhKSwgZGVwdGgwKSwgcGFydGlhbChzZWxmLnByb2dyYW0oMTcsIHByb2dyYW0xNywgZGF0YSksIGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChlbGVtZW50MSwgc2VsZi5wcm9ncmFtKDE5LCBwcm9ncmFtMTksIGRhdGEpKGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIHN0YWNrMSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgXCIpKTtcbiAgc3RhY2sxID0gZWxlbWVudDIgPSBjcmVhdGVFbGVtZW50KHBhcnRpYWwoc2VsZi5wcm9ncmFtKDIxLCBwcm9ncmFtMjEsIGRhdGEpLCBkZXB0aDApLCBmdW5jdGlvbiAoZWwpIHsgZWxlbWVudDIgPSBlbDsgfSk7XG4gIHNldEF0dHJpYnV0ZShmdW5jdGlvbiAoKSB7IHJldHVybiBlbGVtZW50MjsgfSwgcGFydGlhbChzZWxmLnByb2dyYW0oNCwgcHJvZ3JhbTQsIGRhdGEpLCBkZXB0aDApLCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSgyMywgcHJvZ3JhbTIzLCBkYXRhKSwgZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGVsZW1lbnQyLCBzZWxmLnByb2dyYW0oMTksIHByb2dyYW0xOSwgZGF0YSkoZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgc3RhY2sxKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICBcIikpO1xuICBzdGFjazEgPSBmdW5jdGlvbiAoKSB7XG4gIHN0YWNrMiA9IGhlbHBlcnNbJ2lmJ10uY2FsbChkZXB0aDAsICgoc3RhY2sxID0gKGRhdGEgPT0gbnVsbCB8fCBkYXRhID09PSBmYWxzZSA/IGRhdGEgOiBnZXQoZGF0YSwgXCJkYXRhXCIsIFwiZGF0YVwiKSkpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBnZXQoc3RhY2sxLCBcImNlbGxCdXR0b25zQWJvdmVcIiwgXCJzdGFjazFcIikpLCB7aGFzaDp7fSxpbnZlcnNlOndyYXBQcm9ncmFtKHNlbGYubm9vcCksZm46d3JhcFByb2dyYW0oc2VsZi5wcm9ncmFtKDI1LCBwcm9ncmFtMjUsIGRhdGEpKSxkYXRhOmRhdGEsYXR0cmlidXRlOmZhbHNlLHVwZGF0ZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVwZGF0ZSx1bnN1YnNjcmliZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVuc3Vic2NyaXB0aW9ufSk7XG4gIHJldHVybiBzdGFjazI7XG4gIH07XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgY3JlYXRlRE9NKHN0YWNrMSkpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICBcIikpO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5mdW5jdGlvbiBwcm9ncmFtMTUoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJzcGFuXCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTE3KGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwiY2VsbC1ib3JkZXItbGluZVwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW0xOShkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtMjEoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJpXCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTIzKGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwiY2VsbC1ib3JkZXItYnRuIGljb24tcGx1cy1jaXJjbGVkXCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTI1KGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBzdGFjazEsIHN0YWNrMiwgaGVscGVyLCBvcHRpb25zO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgXCIpKTtcbiAgc3RhY2sxID0gZnVuY3Rpb24gKCkge1xuICBzdGFjazIgPSAoaGVscGVyID0gaGVscGVycy52aWV3IHx8IGdldChkZXB0aDAsIFwidmlld1wiLCBcImRlcHRoMFwiKSxvcHRpb25zPXtoYXNoOnt9LGRhdGE6ZGF0YSxhdHRyaWJ1dGU6ZmFsc2UsdXBkYXRlOnNlbGYuc3Vic2NyaXB0aW9uLmJvdW5kVXBkYXRlLHVuc3Vic2NyaWJlOnNlbGYuc3Vic2NyaXB0aW9uLmJvdW5kVW5zdWJzY3JpcHRpb259LGhlbHBlciA/IGhlbHBlci5jYWxsKGRlcHRoMCwgKChzdGFjazEgPSAoZGF0YSA9PSBudWxsIHx8IGRhdGEgPT09IGZhbHNlID8gZGF0YSA6IGdldChkYXRhLCBcImRhdGFcIiwgXCJkYXRhXCIpKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IGdldChzdGFjazEsIFwiY2VsbEJ1dHRvbnNBYm92ZVwiLCBcInN0YWNrMVwiKSksIG9wdGlvbnMpIDogaGVscGVyTWlzc2luZy5jYWxsKGRlcHRoMCwgXCJ2aWV3XCIsICgoc3RhY2sxID0gKGRhdGEgPT0gbnVsbCB8fCBkYXRhID09PSBmYWxzZSA/IGRhdGEgOiBnZXQoZGF0YSwgXCJkYXRhXCIsIFwiZGF0YVwiKSkpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBnZXQoc3RhY2sxLCBcImNlbGxCdXR0b25zQWJvdmVcIiwgXCJzdGFjazFcIikpLCBvcHRpb25zKSk7XG4gIHJldHVybiBzdGFjazI7XG4gIH07XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgY3JlYXRlRE9NKHN0YWNrMSkpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgIFwiKSk7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTI3KGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwiY2VsbC1ib3JkZXIgY2VsbC1ib3JkZXItYmVsb3dcIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtMjkoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIHN0YWNrMSwgc3RhY2syLCBlbGVtZW50MSwgZWxlbWVudDI7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgXCIpKTtcbiAgc3RhY2sxID0gZWxlbWVudDEgPSBjcmVhdGVFbGVtZW50KHBhcnRpYWwoc2VsZi5wcm9ncmFtKDE1LCBwcm9ncmFtMTUsIGRhdGEpLCBkZXB0aDApLCBmdW5jdGlvbiAoZWwpIHsgZWxlbWVudDEgPSBlbDsgfSk7XG4gIHNldEF0dHJpYnV0ZShmdW5jdGlvbiAoKSB7IHJldHVybiBlbGVtZW50MTsgfSwgcGFydGlhbChzZWxmLnByb2dyYW0oNCwgcHJvZ3JhbTQsIGRhdGEpLCBkZXB0aDApLCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSgxNywgcHJvZ3JhbTE3LCBkYXRhKSwgZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGVsZW1lbnQxLCBzZWxmLnByb2dyYW0oMTksIHByb2dyYW0xOSwgZGF0YSkoZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgc3RhY2sxKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICBcIikpO1xuICBzdGFjazEgPSBlbGVtZW50MiA9IGNyZWF0ZUVsZW1lbnQocGFydGlhbChzZWxmLnByb2dyYW0oMjEsIHByb2dyYW0yMSwgZGF0YSksIGRlcHRoMCksIGZ1bmN0aW9uIChlbCkgeyBlbGVtZW50MiA9IGVsOyB9KTtcbiAgc2V0QXR0cmlidXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVsZW1lbnQyOyB9LCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSg0LCBwcm9ncmFtNCwgZGF0YSksIGRlcHRoMCksIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDIzLCBwcm9ncmFtMjMsIGRhdGEpLCBkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoZWxlbWVudDIsIHNlbGYucHJvZ3JhbSgxOSwgcHJvZ3JhbTE5LCBkYXRhKShkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBzdGFjazEpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgIFwiKSk7XG4gIHN0YWNrMSA9IGZ1bmN0aW9uICgpIHtcbiAgc3RhY2syID0gaGVscGVyc1snaWYnXS5jYWxsKGRlcHRoMCwgKChzdGFjazEgPSAoZGF0YSA9PSBudWxsIHx8IGRhdGEgPT09IGZhbHNlID8gZGF0YSA6IGdldChkYXRhLCBcImRhdGFcIiwgXCJkYXRhXCIpKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IGdldChzdGFjazEsIFwiY2VsbEJ1dHRvbnNCZWxvd1wiLCBcInN0YWNrMVwiKSksIHtoYXNoOnt9LGludmVyc2U6d3JhcFByb2dyYW0oc2VsZi5ub29wKSxmbjp3cmFwUHJvZ3JhbShzZWxmLnByb2dyYW0oMzAsIHByb2dyYW0zMCwgZGF0YSkpLGRhdGE6ZGF0YSxhdHRyaWJ1dGU6ZmFsc2UsdXBkYXRlOnNlbGYuc3Vic2NyaXB0aW9uLmJvdW5kVXBkYXRlLHVuc3Vic2NyaWJlOnNlbGYuc3Vic2NyaXB0aW9uLmJvdW5kVW5zdWJzY3JpcHRpb259KTtcbiAgcmV0dXJuIHN0YWNrMjtcbiAgfTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBjcmVhdGVET00oc3RhY2sxKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gIFwiKSk7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cbmZ1bmN0aW9uIHByb2dyYW0zMChkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgc3RhY2sxLCBzdGFjazIsIGhlbHBlciwgb3B0aW9ucztcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICAgIFwiKSk7XG4gIHN0YWNrMSA9IGZ1bmN0aW9uICgpIHtcbiAgc3RhY2syID0gKGhlbHBlciA9IGhlbHBlcnMudmlldyB8fCBnZXQoZGVwdGgwLCBcInZpZXdcIiwgXCJkZXB0aDBcIiksb3B0aW9ucz17aGFzaDp7fSxkYXRhOmRhdGEsYXR0cmlidXRlOmZhbHNlLHVwZGF0ZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVwZGF0ZSx1bnN1YnNjcmliZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVuc3Vic2NyaXB0aW9ufSxoZWxwZXIgPyBoZWxwZXIuY2FsbChkZXB0aDAsICgoc3RhY2sxID0gKGRhdGEgPT0gbnVsbCB8fCBkYXRhID09PSBmYWxzZSA/IGRhdGEgOiBnZXQoZGF0YSwgXCJkYXRhXCIsIFwiZGF0YVwiKSkpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBnZXQoc3RhY2sxLCBcImNlbGxCdXR0b25zQmVsb3dcIiwgXCJzdGFjazFcIikpLCBvcHRpb25zKSA6IGhlbHBlck1pc3NpbmcuY2FsbChkZXB0aDAsIFwidmlld1wiLCAoKHN0YWNrMSA9IChkYXRhID09IG51bGwgfHwgZGF0YSA9PT0gZmFsc2UgPyBkYXRhIDogZ2V0KGRhdGEsIFwiZGF0YVwiLCBcImRhdGFcIikpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogZ2V0KHN0YWNrMSwgXCJjZWxsQnV0dG9uc0JlbG93XCIsIFwic3RhY2sxXCIpKSwgb3B0aW9ucykpO1xuICByZXR1cm4gc3RhY2syO1xuICB9O1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGNyZWF0ZURPTShzdGFjazEpKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICBcIikpO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5cbiAgc3RhY2sxID0gZnVuY3Rpb24gKCkge1xuICBzdGFjazIgPSBoZWxwZXJzLnVubGVzcy5jYWxsKGRlcHRoMCwgKChzdGFjazEgPSAoZGF0YSA9PSBudWxsIHx8IGRhdGEgPT09IGZhbHNlID8gZGF0YSA6IGdldChkYXRhLCBcImNvbmZpZ1wiLCBcImRhdGFcIikpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogZ2V0KHN0YWNrMSwgXCJlbWJlZGRlZFwiLCBcInN0YWNrMVwiKSksIHtoYXNoOnt9LGludmVyc2U6d3JhcFByb2dyYW0oc2VsZi5ub29wKSxmbjp3cmFwUHJvZ3JhbShzZWxmLnByb2dyYW0oMSwgcHJvZ3JhbTEsIGRhdGEpKSxkYXRhOmRhdGEsYXR0cmlidXRlOmZhbHNlLHVwZGF0ZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVwZGF0ZSx1bnN1YnNjcmliZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVuc3Vic2NyaXB0aW9ufSk7XG4gIHJldHVybiBzdGFjazI7XG4gIH07XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgY3JlYXRlRE9NKHN0YWNrMSkpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuXCIpKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfSk7IiwiLy8gRE9NQmFyc2lmeSBjb21waWxlZCB0ZW1wbGF0ZVxudmFyIERPTUJhcnMgPSByZXF1aXJlKFwiZG9tYmFycy9ydW50aW1lXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBET01CYXJzLnRlbXBsYXRlKGZ1bmN0aW9uIChIYW5kbGViYXJzLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgdGhpcy5jb21waWxlckluZm8gPSBbNCwnPj0gMS4wLjAnXTtcbmhlbHBlcnMgPSB0aGlzLm1lcmdlKGhlbHBlcnMsIEhhbmRsZWJhcnMuaGVscGVycyk7IGRhdGEgPSBkYXRhIHx8IHt9O1xuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBzdGFjazEsIGVsZW1lbnQxLCBlbGVtZW50MiwgYXBwZW5kQ2hpbGQ9dGhpcy5hcHBlbmRDaGlsZCwgZ2V0PXRoaXMuZ2V0LCBmdW5jdGlvblR5cGU9XCJmdW5jdGlvblwiLCBjcmVhdGVUZXh0PXRoaXMuY3JlYXRlVGV4dCwgc2VsZj10aGlzLCBwYXJ0aWFsPXRoaXMucGFydGlhbCwgY3JlYXRlRWxlbWVudD10aGlzLmNyZWF0ZUVsZW1lbnQsIHNldEF0dHJpYnV0ZT10aGlzLnNldEF0dHJpYnV0ZTtcblxuZnVuY3Rpb24gcHJvZ3JhbTEoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJkaXZcIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtMyhkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcImNsYXNzXCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTUoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJyZXN1bHQtbGFiZWxcIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtNyhkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgc3RhY2sxLCBzdGFjazI7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCIkXCIpKTtcbiAgc3RhY2sxID0gZnVuY3Rpb24gKCkge1xuICBzdGFjazIgPSAoKHN0YWNrMSA9ICgoc3RhY2sxID0gKGRhdGEgPT0gbnVsbCB8fCBkYXRhID09PSBmYWxzZSA/IGRhdGEgOiBnZXQoZGF0YSwgXCJkYXRhXCIsIFwiZGF0YVwiKSkpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBnZXQoc3RhY2sxLCBcImluZGV4XCIsIFwic3RhY2sxXCIpKSksdHlwZW9mIHN0YWNrMSA9PT0gZnVuY3Rpb25UeXBlID8gc3RhY2sxLmFwcGx5KGRlcHRoMCkgOiBzdGFjazEpO1xuICByZXR1cm4gc3RhY2syO1xuICB9O1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGNyZWF0ZVRleHQoc3RhY2sxKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCI9XCIpKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtOShkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcInJlc3VsdC1jb250ZW50XCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTExKGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5cbiAgc3RhY2sxID0gZWxlbWVudDEgPSBjcmVhdGVFbGVtZW50KHBhcnRpYWwoc2VsZi5wcm9ncmFtKDEsIHByb2dyYW0xLCBkYXRhKSwgZGVwdGgwKSwgZnVuY3Rpb24gKGVsKSB7IGVsZW1lbnQxID0gZWw7IH0pO1xuICBzZXRBdHRyaWJ1dGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZWxlbWVudDE7IH0sIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDMsIHByb2dyYW0zLCBkYXRhKSwgZGVwdGgwKSwgcGFydGlhbChzZWxmLnByb2dyYW0oNSwgcHJvZ3JhbTUsIGRhdGEpLCBkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoZWxlbWVudDEsIHNlbGYucHJvZ3JhbSg3LCBwcm9ncmFtNywgZGF0YSkoZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgc3RhY2sxKTtcbiAgc3RhY2sxID0gZWxlbWVudDIgPSBjcmVhdGVFbGVtZW50KHBhcnRpYWwoc2VsZi5wcm9ncmFtKDEsIHByb2dyYW0xLCBkYXRhKSwgZGVwdGgwKSwgZnVuY3Rpb24gKGVsKSB7IGVsZW1lbnQyID0gZWw7IH0pO1xuICBzZXRBdHRyaWJ1dGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZWxlbWVudDI7IH0sIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDMsIHByb2dyYW0zLCBkYXRhKSwgZGVwdGgwKSwgcGFydGlhbChzZWxmLnByb2dyYW0oOSwgcHJvZ3JhbTksIGRhdGEpLCBkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoZWxlbWVudDIsIHNlbGYucHJvZ3JhbSgxMSwgcHJvZ3JhbTExLCBkYXRhKShkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBzdGFjazEpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuXCIpKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfSk7IiwiLy8gRE9NQmFyc2lmeSBjb21waWxlZCB0ZW1wbGF0ZVxudmFyIERPTUJhcnMgPSByZXF1aXJlKFwiZG9tYmFycy9ydW50aW1lXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBET01CYXJzLnRlbXBsYXRlKGZ1bmN0aW9uIChIYW5kbGViYXJzLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgdGhpcy5jb21waWxlckluZm8gPSBbNCwnPj0gMS4wLjAnXTtcbmhlbHBlcnMgPSB0aGlzLm1lcmdlKGhlbHBlcnMsIEhhbmRsZWJhcnMuaGVscGVycyk7IGRhdGEgPSBkYXRhIHx8IHt9O1xuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBzdGFjazEsIGVsZW1lbnQxLCBlbGVtZW50MiwgYXBwZW5kQ2hpbGQ9dGhpcy5hcHBlbmRDaGlsZCwgc2VsZj10aGlzLCBwYXJ0aWFsPXRoaXMucGFydGlhbCwgY3JlYXRlRWxlbWVudD10aGlzLmNyZWF0ZUVsZW1lbnQsIHNldEF0dHJpYnV0ZT10aGlzLnNldEF0dHJpYnV0ZSwgZ2V0PXRoaXMuZ2V0LCBmdW5jdGlvblR5cGU9XCJmdW5jdGlvblwiLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbiwgY3JlYXRlVGV4dD10aGlzLmNyZWF0ZVRleHQsIHdyYXBQcm9ncmFtPXRoaXMud3JhcFByb2dyYW0sIGNyZWF0ZURPTT10aGlzLmNyZWF0ZURPTSwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3Npbmc7XG5cbmZ1bmN0aW9uIHByb2dyYW0xKGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwiZGl2XCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTMoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJjbGFzc1wiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW01KGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwic2lkZWJhci10b2dnbGVcIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtNyhkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgc3RhY2sxLCBlbGVtZW50MTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgXCIpKTtcbiAgc3RhY2sxID0gZWxlbWVudDEgPSBjcmVhdGVFbGVtZW50KHBhcnRpYWwoc2VsZi5wcm9ncmFtKDgsIHByb2dyYW04LCBkYXRhKSwgZGVwdGgwKSwgZnVuY3Rpb24gKGVsKSB7IGVsZW1lbnQxID0gZWw7IH0pO1xuICBzZXRBdHRyaWJ1dGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZWxlbWVudDE7IH0sIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDMsIHByb2dyYW0zLCBkYXRhKSwgZGVwdGgwKSwgcGFydGlhbChzZWxmLnByb2dyYW0oMTAsIHByb2dyYW0xMCwgZGF0YSksIGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChlbGVtZW50MSwgc2VsZi5wcm9ncmFtKDEyLCBwcm9ncmFtMTIsIGRhdGEpKGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIHN0YWNrMSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG5cIikpO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5mdW5jdGlvbiBwcm9ncmFtOChkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcImlcIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtMTAoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJpY29uXCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTEyKGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW0xNChkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcInNpZGViYXItY29udGVudFwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW0xNihkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgc3RhY2sxLCBlbGVtZW50MSwgZWxlbWVudDI7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gIFwiKSk7XG4gIHN0YWNrMSA9IGVsZW1lbnQxID0gY3JlYXRlRWxlbWVudChwYXJ0aWFsKHNlbGYucHJvZ3JhbSgxLCBwcm9ncmFtMSwgZGF0YSksIGRlcHRoMCksIGZ1bmN0aW9uIChlbCkgeyBlbGVtZW50MSA9IGVsOyB9KTtcbiAgc2V0QXR0cmlidXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVsZW1lbnQxOyB9LCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSgzLCBwcm9ncmFtMywgZGF0YSksIGRlcHRoMCksIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDE3LCBwcm9ncmFtMTcsIGRhdGEpLCBkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoZWxlbWVudDEsIHNlbGYucHJvZ3JhbSgxOSwgcHJvZ3JhbTE5LCBkYXRhKShkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBzdGFjazEpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuXFxuICBcIikpO1xuICBzdGFjazEgPSBlbGVtZW50MiA9IGNyZWF0ZUVsZW1lbnQocGFydGlhbChzZWxmLnByb2dyYW0oMSwgcHJvZ3JhbTEsIGRhdGEpLCBkZXB0aDApLCBmdW5jdGlvbiAoZWwpIHsgZWxlbWVudDIgPSBlbDsgfSk7XG4gIHNldEF0dHJpYnV0ZShmdW5jdGlvbiAoKSB7IHJldHVybiBlbGVtZW50MjsgfSwgcGFydGlhbChzZWxmLnByb2dyYW0oMywgcHJvZ3JhbTMsIGRhdGEpLCBkZXB0aDApLCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSg1MSwgcHJvZ3JhbTUxLCBkYXRhKSwgZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGVsZW1lbnQyLCBzZWxmLnByb2dyYW0oNTMsIHByb2dyYW01MywgZGF0YSkoZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgc3RhY2sxKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcblwiKSk7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cbmZ1bmN0aW9uIHByb2dyYW0xNyhkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcInNpZGViYXItdXNlclwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW0xOShkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgc3RhY2sxLCBzdGFjazIsIGVsZW1lbnQxO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgIFwiKSk7XG4gIHN0YWNrMSA9IGZ1bmN0aW9uICgpIHtcbiAgc3RhY2syID0gaGVscGVyc1snaWYnXS5jYWxsKGRlcHRoMCwgKChzdGFjazEgPSAoZGF0YSA9PSBudWxsIHx8IGRhdGEgPT09IGZhbHNlID8gZGF0YSA6IGdldChkYXRhLCBcInBlcnNpc3RlbmNlXCIsIFwiZGF0YVwiKSkpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBnZXQoc3RhY2sxLCBcInVzZXJJZFwiLCBcInN0YWNrMVwiKSksIHtoYXNoOnt9LGludmVyc2U6d3JhcFByb2dyYW0oc2VsZi5ub29wKSxmbjp3cmFwUHJvZ3JhbShzZWxmLnByb2dyYW0oMjAsIHByb2dyYW0yMCwgZGF0YSkpLGRhdGE6ZGF0YSxhdHRyaWJ1dGU6ZmFsc2UsdXBkYXRlOnNlbGYuc3Vic2NyaXB0aW9uLmJvdW5kVXBkYXRlLHVuc3Vic2NyaWJlOnNlbGYuc3Vic2NyaXB0aW9uLmJvdW5kVW5zdWJzY3JpcHRpb259KTtcbiAgcmV0dXJuIHN0YWNrMjtcbiAgfTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBjcmVhdGVET00oc3RhY2sxKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgXCIpKTtcbiAgc3RhY2sxID0gZWxlbWVudDEgPSBjcmVhdGVFbGVtZW50KHBhcnRpYWwoc2VsZi5wcm9ncmFtKDEsIHByb2dyYW0xLCBkYXRhKSwgZGVwdGgwKSwgZnVuY3Rpb24gKGVsKSB7IGVsZW1lbnQxID0gZWw7IH0pO1xuICBzZXRBdHRyaWJ1dGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZWxlbWVudDE7IH0sIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDMsIHByb2dyYW0zLCBkYXRhKSwgZGVwdGgwKSwgcGFydGlhbChzZWxmLnByb2dyYW0oMjMsIHByb2dyYW0yMywgZGF0YSksIGRlcHRoMCkpO1xuICBzZXRBdHRyaWJ1dGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZWxlbWVudDE7IH0sIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDI1LCBwcm9ncmFtMjUsIGRhdGEpLCBkZXB0aDApLCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSgyNywgcHJvZ3JhbTI3LCBkYXRhKSwgZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGVsZW1lbnQxLCBzZWxmLnByb2dyYW0oMjksIHByb2dyYW0yOSwgZGF0YSkoZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgc3RhY2sxKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgXCIpKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuZnVuY3Rpb24gcHJvZ3JhbTIwKGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBzdGFjazEsIGVsZW1lbnQxO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgXCIpKTtcbiAgc3RhY2sxID0gZWxlbWVudDEgPSBjcmVhdGVFbGVtZW50KHBhcnRpYWwoc2VsZi5wcm9ncmFtKDgsIHByb2dyYW04LCBkYXRhKSwgZGVwdGgwKSwgZnVuY3Rpb24gKGVsKSB7IGVsZW1lbnQxID0gZWw7IH0pO1xuICBzZXRBdHRyaWJ1dGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZWxlbWVudDE7IH0sIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDMsIHByb2dyYW0zLCBkYXRhKSwgZGVwdGgwKSwgcGFydGlhbChzZWxmLnByb2dyYW0oMjEsIHByb2dyYW0yMSwgZGF0YSksIGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChlbGVtZW50MSwgc2VsZi5wcm9ncmFtKDEyLCBwcm9ncmFtMTIsIGRhdGEpKGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIHN0YWNrMSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgXCIpKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuZnVuY3Rpb24gcHJvZ3JhbTIxKGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwic2lkZWJhci11c2VyLWljb24gaWNvbi1mb2xkZXItb3Blbi1lbXB0eVwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW0yMyhkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcInNpZGViYXItdXNlci10aXRsZVwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW0yNShkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcInRpdGxlXCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTI3KGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgc3RhY2sxO1xuICByZXR1cm4gZXNjYXBlRXhwcmVzc2lvbigoKHN0YWNrMSA9ICgoc3RhY2sxID0gKGRhdGEgPT0gbnVsbCB8fCBkYXRhID09PSBmYWxzZSA/IGRhdGEgOiBnZXQoZGF0YSwgXCJwZXJzaXN0ZW5jZVwiLCBcImRhdGFcIikpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogZ2V0KHN0YWNrMSwgXCJ1c2VyVGl0bGVcIiwgXCJzdGFjazFcIikpKSx0eXBlb2Ygc3RhY2sxID09PSBmdW5jdGlvblR5cGUgPyBzdGFjazEuYXBwbHkoZGVwdGgwKSA6IHN0YWNrMSkpO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW0yOShkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgc3RhY2sxLCBzdGFjazIsIGVsZW1lbnQxO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgXCIpKTtcbiAgc3RhY2sxID0gZnVuY3Rpb24gKCkge1xuICBzdGFjazIgPSBoZWxwZXJzWydpZiddLmNhbGwoZGVwdGgwLCAoKHN0YWNrMSA9IChkYXRhID09IG51bGwgfHwgZGF0YSA9PT0gZmFsc2UgPyBkYXRhIDogZ2V0KGRhdGEsIFwicGVyc2lzdGVuY2VcIiwgXCJkYXRhXCIpKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IGdldChzdGFjazEsIFwidXNlcklkXCIsIFwic3RhY2sxXCIpKSwge2hhc2g6e30saW52ZXJzZTp3cmFwUHJvZ3JhbShzZWxmLnByb2dyYW0oMzIsIHByb2dyYW0zMiwgZGF0YSkpLGZuOndyYXBQcm9ncmFtKHNlbGYucHJvZ3JhbSgzMCwgcHJvZ3JhbTMwLCBkYXRhKSksZGF0YTpkYXRhLGF0dHJpYnV0ZTpmYWxzZSx1cGRhdGU6c2VsZi5zdWJzY3JpcHRpb24uYm91bmRVcGRhdGUsdW5zdWJzY3JpYmU6c2VsZi5zdWJzY3JpcHRpb24uYm91bmRVbnN1YnNjcmlwdGlvbn0pO1xuICByZXR1cm4gc3RhY2syO1xuICB9O1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGNyZWF0ZURPTShzdGFjazEpKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcblxcbiAgICAgIFwiKSk7XG4gIHN0YWNrMSA9IGVsZW1lbnQxID0gY3JlYXRlRWxlbWVudChwYXJ0aWFsKHNlbGYucHJvZ3JhbSgzNCwgcHJvZ3JhbTM0LCBkYXRhKSwgZGVwdGgwKSwgZnVuY3Rpb24gKGVsKSB7IGVsZW1lbnQxID0gZWw7IH0pO1xuICBzZXRBdHRyaWJ1dGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZWxlbWVudDE7IH0sIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDMsIHByb2dyYW0zLCBkYXRhKSwgZGVwdGgwKSwgcGFydGlhbChzZWxmLnByb2dyYW0oMzYsIHByb2dyYW0zNiwgZGF0YSksIGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChlbGVtZW50MSwgc2VsZi5wcm9ncmFtKDM5LCBwcm9ncmFtMzksIGRhdGEpKGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIHN0YWNrMSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgXCIpKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuZnVuY3Rpb24gcHJvZ3JhbTMwKGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBzdGFjazEsIHN0YWNrMjtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICAgICAgXCIpKTtcbiAgc3RhY2sxID0gZnVuY3Rpb24gKCkge1xuICBzdGFjazIgPSAoKHN0YWNrMSA9ICgoc3RhY2sxID0gKGRhdGEgPT0gbnVsbCB8fCBkYXRhID09PSBmYWxzZSA/IGRhdGEgOiBnZXQoZGF0YSwgXCJwZXJzaXN0ZW5jZVwiLCBcImRhdGFcIikpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogZ2V0KHN0YWNrMSwgXCJ1c2VyVGl0bGVcIiwgXCJzdGFjazFcIikpKSx0eXBlb2Ygc3RhY2sxID09PSBmdW5jdGlvblR5cGUgPyBzdGFjazEuYXBwbHkoZGVwdGgwKSA6IHN0YWNrMSk7XG4gIHJldHVybiBzdGFjazI7XG4gIH07XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgY3JlYXRlVGV4dChzdGFjazEpKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICAgIFwiKSk7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTMyKGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgICBVbmF1dGhlbnRpY2F0ZWRcXG4gICAgICBcIik7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTM0KGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwicFwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW0zNihkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IFwiXCIsIHN0YWNrMTtcbiAgYnVmZmVyICs9IFwic2lkZWJhci1hdXRoZW50aWNhdGUgdGV4dC1zbWFsbCBwZXJzaXN0ZW5jZS1cIjtcbiAgc3RhY2sxID0gaGVscGVyc1snaWYnXS5jYWxsKGRlcHRoMCwgKChzdGFjazEgPSAoZGF0YSA9PSBudWxsIHx8IGRhdGEgPT09IGZhbHNlID8gZGF0YSA6IGdldChkYXRhLCBcInBlcnNpc3RlbmNlXCIsIFwiZGF0YVwiKSkpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBnZXQoc3RhY2sxLCBcInVzZXJJZFwiLCBcInN0YWNrMVwiKSksIHtoYXNoOnt9LGludmVyc2U6d3JhcFByb2dyYW0oc2VsZi5ub29wKSxmbjp3cmFwUHJvZ3JhbShzZWxmLnByb2dyYW0oMzcsIHByb2dyYW0zNywgZGF0YSkpLGRhdGE6ZGF0YSxhdHRyaWJ1dGU6dHJ1ZSx1cGRhdGU6c2VsZi5zdWJzY3JpcHRpb24uYm91bmRVcGRhdGUsdW5zdWJzY3JpYmU6c2VsZi5zdWJzY3JpcHRpb24uYm91bmRVbnN1YnNjcmlwdGlvbn0pO1xuICBidWZmZXIgKz0gc3RhY2sxXG4gICAgKyBcImF1dGhlbnRpY2F0ZVwiO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5mdW5jdGlvbiBwcm9ncmFtMzcoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJ1blwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW0zOShkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgc3RhY2sxLCBlbGVtZW50MTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICAgICAgXCIpKTtcbiAgc3RhY2sxID0gZWxlbWVudDEgPSBjcmVhdGVFbGVtZW50KHBhcnRpYWwoc2VsZi5wcm9ncmFtKDQwLCBwcm9ncmFtNDAsIGRhdGEpLCBkZXB0aDApLCBmdW5jdGlvbiAoZWwpIHsgZWxlbWVudDEgPSBlbDsgfSk7XG4gIHNldEF0dHJpYnV0ZShmdW5jdGlvbiAoKSB7IHJldHVybiBlbGVtZW50MTsgfSwgcGFydGlhbChzZWxmLnByb2dyYW0oNDIsIHByb2dyYW00MiwgZGF0YSksIGRlcHRoMCksIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDQ0LCBwcm9ncmFtNDQsIGRhdGEpLCBkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoZWxlbWVudDEsIHNlbGYucHJvZ3JhbSg0NiwgcHJvZ3JhbTQ2LCBkYXRhKShkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBzdGFjazEpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgXCIpKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuZnVuY3Rpb24gcHJvZ3JhbTQwKGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwiYVwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW00MihkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcImhyZWZcIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtNDQoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCIjXCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTQ2KGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBzdGFjazEsIHN0YWNrMjtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICAgICAgICBcIikpO1xuICBzdGFjazEgPSBmdW5jdGlvbiAoKSB7XG4gIHN0YWNrMiA9IGhlbHBlcnNbJ2lmJ10uY2FsbChkZXB0aDAsICgoc3RhY2sxID0gKGRhdGEgPT0gbnVsbCB8fCBkYXRhID09PSBmYWxzZSA/IGRhdGEgOiBnZXQoZGF0YSwgXCJwZXJzaXN0ZW5jZVwiLCBcImRhdGFcIikpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogZ2V0KHN0YWNrMSwgXCJ1c2VySWRcIiwgXCJzdGFjazFcIikpLCB7aGFzaDp7fSxpbnZlcnNlOndyYXBQcm9ncmFtKHNlbGYucHJvZ3JhbSg0OSwgcHJvZ3JhbTQ5LCBkYXRhKSksZm46d3JhcFByb2dyYW0oc2VsZi5wcm9ncmFtKDQ3LCBwcm9ncmFtNDcsIGRhdGEpKSxkYXRhOmRhdGEsYXR0cmlidXRlOmZhbHNlLHVwZGF0ZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVwZGF0ZSx1bnN1YnNjcmliZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVuc3Vic2NyaXB0aW9ufSk7XG4gIHJldHVybiBzdGFjazI7XG4gIH07XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgY3JlYXRlRE9NKHN0YWNrMSkpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgICBcIikpO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5mdW5jdGlvbiBwcm9ncmFtNDcoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIHN0YWNrMSwgc3RhY2syO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgICAgICAgXCIpKTtcbiAgc3RhY2sxID0gZnVuY3Rpb24gKCkge1xuICBzdGFjazIgPSAoKHN0YWNrMSA9ICgoc3RhY2sxID0gKGRhdGEgPT0gbnVsbCB8fCBkYXRhID09PSBmYWxzZSA/IGRhdGEgOiBnZXQoZGF0YSwgXCJjb25maWdcIiwgXCJkYXRhXCIpKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IGdldChzdGFjazEsIFwidW5hdXRoZW50aWNhdGVUZXh0XCIsIFwic3RhY2sxXCIpKSksdHlwZW9mIHN0YWNrMSA9PT0gZnVuY3Rpb25UeXBlID8gc3RhY2sxLmFwcGx5KGRlcHRoMCkgOiBzdGFjazEpO1xuICByZXR1cm4gc3RhY2syO1xuICB9O1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGNyZWF0ZVRleHQoc3RhY2sxKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgICAgICAgXCIpKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtNDkoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIHN0YWNrMSwgc3RhY2syO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgICAgICAgXCIpKTtcbiAgc3RhY2sxID0gZnVuY3Rpb24gKCkge1xuICBzdGFjazIgPSAoKHN0YWNrMSA9ICgoc3RhY2sxID0gKGRhdGEgPT0gbnVsbCB8fCBkYXRhID09PSBmYWxzZSA/IGRhdGEgOiBnZXQoZGF0YSwgXCJjb25maWdcIiwgXCJkYXRhXCIpKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IGdldChzdGFjazEsIFwiYXV0aGVudGljYXRlVGV4dFwiLCBcInN0YWNrMVwiKSkpLHR5cGVvZiBzdGFjazEgPT09IGZ1bmN0aW9uVHlwZSA/IHN0YWNrMS5hcHBseShkZXB0aDApIDogc3RhY2sxKTtcbiAgcmV0dXJuIHN0YWNrMjtcbiAgfTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBjcmVhdGVUZXh0KHN0YWNrMSkpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgICAgIFwiKSk7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTUxKGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwic2lkZWJhci1saXN0XCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTUzKGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBzdGFjazEsIHN0YWNrMiwgZWxlbWVudDE7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgXCIpKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICBcIikpO1xuICBzdGFjazEgPSBlbGVtZW50MSA9IGNyZWF0ZUVsZW1lbnQocGFydGlhbChzZWxmLnByb2dyYW0oMSwgcHJvZ3JhbTEsIGRhdGEpLCBkZXB0aDApLCBmdW5jdGlvbiAoZWwpIHsgZWxlbWVudDEgPSBlbDsgfSk7XG4gIHNldEF0dHJpYnV0ZShmdW5jdGlvbiAoKSB7IHJldHVybiBlbGVtZW50MTsgfSwgcGFydGlhbChzZWxmLnByb2dyYW0oMywgcHJvZ3JhbTMsIGRhdGEpLCBkZXB0aDApLCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSg1NCwgcHJvZ3JhbTU0LCBkYXRhKSwgZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGVsZW1lbnQxLCBzZWxmLnByb2dyYW0oNTcsIHByb2dyYW01NywgZGF0YSkoZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgc3RhY2sxKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcblxcbiAgICBcIikpO1xuICBzdGFjazEgPSBmdW5jdGlvbiAoKSB7XG4gIHN0YWNrMiA9IGhlbHBlcnNbJ2lmJ10uY2FsbChkZXB0aDAsICgoc3RhY2sxID0gKGRhdGEgPT0gbnVsbCB8fCBkYXRhID09PSBmYWxzZSA/IGRhdGEgOiBnZXQoZGF0YSwgXCJkYXRhXCIsIFwiZGF0YVwiKSkpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBnZXQoc3RhY2sxLCBcInVwZGF0aW5nXCIsIFwic3RhY2sxXCIpKSwge2hhc2g6e30saW52ZXJzZTp3cmFwUHJvZ3JhbShzZWxmLnByb2dyYW0oOTAsIHByb2dyYW05MCwgZGF0YSkpLGZuOndyYXBQcm9ncmFtKHNlbGYucHJvZ3JhbSg4NCwgcHJvZ3JhbTg0LCBkYXRhKSksZGF0YTpkYXRhLGF0dHJpYnV0ZTpmYWxzZSx1cGRhdGU6c2VsZi5zdWJzY3JpcHRpb24uYm91bmRVcGRhdGUsdW5zdWJzY3JpYmU6c2VsZi5zdWJzY3JpcHRpb24uYm91bmRVbnN1YnNjcmlwdGlvbn0pO1xuICByZXR1cm4gc3RhY2syO1xuICB9O1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGNyZWF0ZURPTShzdGFjazEpKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgXCIpKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuZnVuY3Rpb24gcHJvZ3JhbTU0KGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gXCJcIiwgc3RhY2sxO1xuICBidWZmZXIgKz0gXCJsaXN0LWl0ZW0gaXRlbSBpdGVtLWFjdGl2ZSBcIjtcbiAgc3RhY2sxID0gaGVscGVycy51bmxlc3MuY2FsbChkZXB0aDAsICgoc3RhY2sxID0gKGRhdGEgPT0gbnVsbCB8fCBkYXRhID09PSBmYWxzZSA/IGRhdGEgOiBnZXQoZGF0YSwgXCJkYXRhXCIsIFwiZGF0YVwiKSkpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBnZXQoc3RhY2sxLCBcInNhdmVkXCIsIFwic3RhY2sxXCIpKSwge2hhc2g6e30saW52ZXJzZTp3cmFwUHJvZ3JhbShzZWxmLm5vb3ApLGZuOndyYXBQcm9ncmFtKHNlbGYucHJvZ3JhbSg1NSwgcHJvZ3JhbTU1LCBkYXRhKSksZGF0YTpkYXRhLGF0dHJpYnV0ZTp0cnVlLHVwZGF0ZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVwZGF0ZSx1bnN1YnNjcmliZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVuc3Vic2NyaXB0aW9ufSk7XG4gIGJ1ZmZlciArPSBzdGFjazE7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cbmZ1bmN0aW9uIHByb2dyYW01NShkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcIml0ZW0tdW5zYXZlZFwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW01NyhkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgc3RhY2sxLCBzdGFjazI7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgXCIpKTtcbiAgc3RhY2sxID0gZnVuY3Rpb24gKCkge1xuICBzdGFjazIgPSBoZWxwZXJzWyd3aXRoJ10uY2FsbChkZXB0aDAsICgoc3RhY2sxID0gKGRhdGEgPT0gbnVsbCB8fCBkYXRhID09PSBmYWxzZSA/IGRhdGEgOiBnZXQoZGF0YSwgXCJwZXJzaXN0ZW5jZVwiLCBcImRhdGFcIikpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogZ2V0KHN0YWNrMSwgXCJub3RlYm9va1wiLCBcInN0YWNrMVwiKSksIHtoYXNoOnt9LGludmVyc2U6d3JhcFByb2dyYW0oc2VsZi5ub29wKSxmbjp3cmFwUHJvZ3JhbShzZWxmLnByb2dyYW0oNTgsIHByb2dyYW01OCwgZGF0YSkpLGRhdGE6ZGF0YSxhdHRyaWJ1dGU6ZmFsc2UsdXBkYXRlOnNlbGYuc3Vic2NyaXB0aW9uLmJvdW5kVXBkYXRlLHVuc3Vic2NyaWJlOnNlbGYuc3Vic2NyaXB0aW9uLmJvdW5kVW5zdWJzY3JpcHRpb259KTtcbiAgcmV0dXJuIHN0YWNrMjtcbiAgfTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBjcmVhdGVET00oc3RhY2sxKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgXCIpKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuZnVuY3Rpb24gcHJvZ3JhbTU4KGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBzdGFjazEsIHN0YWNrMiwgZWxlbWVudDE7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgICBcIikpO1xuICBzdGFjazEgPSBmdW5jdGlvbiAoKSB7XG4gIHN0YWNrMiA9IGhlbHBlcnNbJ2lmJ10uY2FsbChkZXB0aDAsIGdldChkZXB0aDAsIFwiaWRcIiwgXCJkZXB0aDBcIiksIHtoYXNoOnt9LGludmVyc2U6d3JhcFByb2dyYW0oc2VsZi5ub29wKSxmbjp3cmFwUHJvZ3JhbShzZWxmLnByb2dyYW0oNTksIHByb2dyYW01OSwgZGF0YSkpLGRhdGE6ZGF0YSxhdHRyaWJ1dGU6ZmFsc2UsdXBkYXRlOnNlbGYuc3Vic2NyaXB0aW9uLmJvdW5kVXBkYXRlLHVuc3Vic2NyaWJlOnNlbGYuc3Vic2NyaXB0aW9uLmJvdW5kVW5zdWJzY3JpcHRpb259KTtcbiAgcmV0dXJuIHN0YWNrMjtcbiAgfTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBjcmVhdGVET00oc3RhY2sxKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG5cXG4gICAgICBcIikpO1xuICBzdGFjazEgPSBlbGVtZW50MSA9IGNyZWF0ZUVsZW1lbnQocGFydGlhbChzZWxmLnByb2dyYW0oMSwgcHJvZ3JhbTEsIGRhdGEpLCBkZXB0aDApLCBmdW5jdGlvbiAoZWwpIHsgZWxlbWVudDEgPSBlbDsgfSk7XG4gIHNldEF0dHJpYnV0ZShmdW5jdGlvbiAoKSB7IHJldHVybiBlbGVtZW50MTsgfSwgcGFydGlhbChzZWxmLnByb2dyYW0oMywgcHJvZ3JhbTMsIGRhdGEpLCBkZXB0aDApLCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSg2NywgcHJvZ3JhbTY3LCBkYXRhKSwgZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGVsZW1lbnQxLCBzZWxmLnByb2dyYW0oNjksIHByb2dyYW02OSwgZGF0YSkoZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgc3RhY2sxKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICBcIikpO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5mdW5jdGlvbiBwcm9ncmFtNTkoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIHN0YWNrMSwgc3RhY2syLCBoZWxwZXIsIG9wdGlvbnM7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgICAgIFwiKSk7XG4gIHN0YWNrMSA9IGZ1bmN0aW9uICgpIHtcbiAgc3RhY2syID0gKGhlbHBlciA9IGhlbHBlcnMuZXF1YWwgfHwgZ2V0KGRlcHRoMCwgXCJlcXVhbFwiLCBcImRlcHRoMFwiKSxvcHRpb25zPXtoYXNoOnt9LGludmVyc2U6d3JhcFByb2dyYW0oc2VsZi5ub29wKSxmbjp3cmFwUHJvZ3JhbShzZWxmLnByb2dyYW0oNjAsIHByb2dyYW02MCwgZGF0YSkpLGRhdGE6ZGF0YSxhdHRyaWJ1dGU6ZmFsc2UsdXBkYXRlOnNlbGYuc3Vic2NyaXB0aW9uLmJvdW5kVXBkYXRlLHVuc3Vic2NyaWJlOnNlbGYuc3Vic2NyaXB0aW9uLmJvdW5kVW5zdWJzY3JpcHRpb259LGhlbHBlciA/IGhlbHBlci5jYWxsKGRlcHRoMCwgKChzdGFjazEgPSAoZGF0YSA9PSBudWxsIHx8IGRhdGEgPT09IGZhbHNlID8gZGF0YSA6IGdldChkYXRhLCBcInBlcnNpc3RlbmNlXCIsIFwiZGF0YVwiKSkpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBnZXQoc3RhY2sxLCBcInVzZXJJZFwiLCBcInN0YWNrMVwiKSksIGdldChkZXB0aDAsIFwib3duZXJJZFwiLCBcImRlcHRoMFwiKSwgb3B0aW9ucykgOiBoZWxwZXJNaXNzaW5nLmNhbGwoZGVwdGgwLCBcImVxdWFsXCIsICgoc3RhY2sxID0gKGRhdGEgPT0gbnVsbCB8fCBkYXRhID09PSBmYWxzZSA/IGRhdGEgOiBnZXQoZGF0YSwgXCJwZXJzaXN0ZW5jZVwiLCBcImRhdGFcIikpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogZ2V0KHN0YWNrMSwgXCJ1c2VySWRcIiwgXCJzdGFjazFcIikpLCBnZXQoZGVwdGgwLCBcIm93bmVySWRcIiwgXCJkZXB0aDBcIiksIG9wdGlvbnMpKTtcbiAgcmV0dXJuIHN0YWNrMjtcbiAgfTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBjcmVhdGVET00oc3RhY2sxKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgICBcIikpO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5mdW5jdGlvbiBwcm9ncmFtNjAoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIHN0YWNrMSwgZWxlbWVudDE7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgICAgICAgXCIpKTtcbiAgc3RhY2sxID0gZWxlbWVudDEgPSBjcmVhdGVFbGVtZW50KHBhcnRpYWwoc2VsZi5wcm9ncmFtKDgsIHByb2dyYW04LCBkYXRhKSwgZGVwdGgwKSwgZnVuY3Rpb24gKGVsKSB7IGVsZW1lbnQxID0gZWw7IH0pO1xuICBzZXRBdHRyaWJ1dGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZWxlbWVudDE7IH0sIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDMsIHByb2dyYW0zLCBkYXRhKSwgZGVwdGgwKSwgcGFydGlhbChzZWxmLnByb2dyYW0oNjEsIHByb2dyYW02MSwgZGF0YSksIGRlcHRoMCkpO1xuICBzZXRBdHRyaWJ1dGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZWxlbWVudDE7IH0sIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDYzLCBwcm9ncmFtNjMsIGRhdGEpLCBkZXB0aDApLCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSg2NSwgcHJvZ3JhbTY1LCBkYXRhKSwgZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGVsZW1lbnQxLCBzZWxmLnByb2dyYW0oMTIsIHByb2dyYW0xMiwgZGF0YSkoZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgc3RhY2sxKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICAgICAgXCIpKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuZnVuY3Rpb24gcHJvZ3JhbTYxKGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwiaWNvbi1jYW5jZWwtY2lyY2xlZFwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW02MyhkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcImRhdGEtZGVsZXRlXCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTY1KGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgc3RhY2sxLCBoZWxwZXI7XG4gIGlmIChoZWxwZXIgPSBoZWxwZXJzLmlkKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhLGF0dHJpYnV0ZTp0cnVlLHVwZGF0ZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVwZGF0ZSx1bnN1YnNjcmliZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVuc3Vic2NyaXB0aW9ufSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IGdldChkZXB0aDAsIFwiaWRcIiwgXCJkZXB0aDBcIik7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhLGF0dHJpYnV0ZTp0cnVlLHVwZGF0ZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVwZGF0ZSx1bnN1YnNjcmliZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVuc3Vic2NyaXB0aW9ufSkgOiBoZWxwZXI7IH1cbiAgcmV0dXJuIGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKTtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtNjcoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJpdGVtLWRlc2NyaXB0aW9uXCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTY5KGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBzdGFjazEsIGVsZW1lbnQxLCBlbGVtZW50MjtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICAgICAgXCIpKTtcbiAgc3RhY2sxID0gZWxlbWVudDEgPSBjcmVhdGVFbGVtZW50KHBhcnRpYWwoc2VsZi5wcm9ncmFtKDEsIHByb2dyYW0xLCBkYXRhKSwgZGVwdGgwKSwgZnVuY3Rpb24gKGVsKSB7IGVsZW1lbnQxID0gZWw7IH0pO1xuICBzZXRBdHRyaWJ1dGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZWxlbWVudDE7IH0sIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDMsIHByb2dyYW0zLCBkYXRhKSwgZGVwdGgwKSwgcGFydGlhbChzZWxmLnByb2dyYW0oNzAsIHByb2dyYW03MCwgZGF0YSksIGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChlbGVtZW50MSwgc2VsZi5wcm9ncmFtKDcyLCBwcm9ncmFtNzIsIGRhdGEpKGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIHN0YWNrMSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG5cXG4gICAgICAgIFwiKSk7XG4gIHN0YWNrMSA9IGVsZW1lbnQyID0gY3JlYXRlRWxlbWVudChwYXJ0aWFsKHNlbGYucHJvZ3JhbSgxLCBwcm9ncmFtMSwgZGF0YSksIGRlcHRoMCksIGZ1bmN0aW9uIChlbCkgeyBlbGVtZW50MiA9IGVsOyB9KTtcbiAgc2V0QXR0cmlidXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVsZW1lbnQyOyB9LCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSgzLCBwcm9ncmFtMywgZGF0YSksIGRlcHRoMCksIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDc3LCBwcm9ncmFtNzcsIGRhdGEpLCBkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoZWxlbWVudDIsIHNlbGYucHJvZ3JhbSg3OSwgcHJvZ3JhbTc5LCBkYXRhKShkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBzdGFjazEpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgXCIpKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuZnVuY3Rpb24gcHJvZ3JhbTcwKGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwiaXRlbS10aXRsZVwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW03MihkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgc3RhY2sxLCBzdGFjazI7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgICAgICAgXCIpKTtcbiAgc3RhY2sxID0gZnVuY3Rpb24gKCkge1xuICBzdGFjazIgPSBoZWxwZXJzWydpZiddLmNhbGwoZGVwdGgwLCAoKHN0YWNrMSA9IGdldChkZXB0aDAsIFwibWV0YVwiLCBcImRlcHRoMFwiKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IGdldChzdGFjazEsIFwidGl0bGVcIiwgXCJzdGFjazFcIikpLCB7aGFzaDp7fSxpbnZlcnNlOndyYXBQcm9ncmFtKHNlbGYucHJvZ3JhbSg3NSwgcHJvZ3JhbTc1LCBkYXRhKSksZm46d3JhcFByb2dyYW0oc2VsZi5wcm9ncmFtKDczLCBwcm9ncmFtNzMsIGRhdGEpKSxkYXRhOmRhdGEsYXR0cmlidXRlOmZhbHNlLHVwZGF0ZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVwZGF0ZSx1bnN1YnNjcmliZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVuc3Vic2NyaXB0aW9ufSk7XG4gIHJldHVybiBzdGFjazI7XG4gIH07XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgY3JlYXRlRE9NKHN0YWNrMSkpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgICBcIikpO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5mdW5jdGlvbiBwcm9ncmFtNzMoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIHN0YWNrMSwgc3RhY2syO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgICAgICAgXCIpKTtcbiAgc3RhY2sxID0gZnVuY3Rpb24gKCkge1xuICBzdGFjazIgPSAoKHN0YWNrMSA9ICgoc3RhY2sxID0gZ2V0KGRlcHRoMCwgXCJtZXRhXCIsIFwiZGVwdGgwXCIpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogZ2V0KHN0YWNrMSwgXCJ0aXRsZVwiLCBcInN0YWNrMVwiKSkpLHR5cGVvZiBzdGFjazEgPT09IGZ1bmN0aW9uVHlwZSA/IHN0YWNrMS5hcHBseShkZXB0aDApIDogc3RhY2sxKTtcbiAgcmV0dXJuIHN0YWNrMjtcbiAgfTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBjcmVhdGVUZXh0KHN0YWNrMSkpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgICAgIFwiKSk7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTc1KGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgICAgICAgXCIpKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIsKgXCIpKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICAgICAgICBcIikpO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW03NyhkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcIml0ZW0tdGltZXN0YW1wXCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTc5KGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBzdGFjazEsIHN0YWNrMjtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICAgICAgICBcIikpO1xuICBzdGFjazEgPSBmdW5jdGlvbiAoKSB7XG4gIHN0YWNrMiA9IGhlbHBlcnNbJ2lmJ10uY2FsbChkZXB0aDAsIGdldChkZXB0aDAsIFwidXBkYXRlZEF0XCIsIFwiZGVwdGgwXCIpLCB7aGFzaDp7fSxpbnZlcnNlOndyYXBQcm9ncmFtKHNlbGYucHJvZ3JhbSg4MiwgcHJvZ3JhbTgyLCBkYXRhKSksZm46d3JhcFByb2dyYW0oc2VsZi5wcm9ncmFtKDgwLCBwcm9ncmFtODAsIGRhdGEpKSxkYXRhOmRhdGEsYXR0cmlidXRlOmZhbHNlLHVwZGF0ZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVwZGF0ZSx1bnN1YnNjcmliZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVuc3Vic2NyaXB0aW9ufSk7XG4gIHJldHVybiBzdGFjazI7XG4gIH07XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgY3JlYXRlRE9NKHN0YWNrMSkpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgICBcIikpO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5mdW5jdGlvbiBwcm9ncmFtODAoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIHN0YWNrMSwgc3RhY2syLCBoZWxwZXIsIG9wdGlvbnM7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgICAgICAgICBcIikpO1xuICBzdGFjazEgPSBmdW5jdGlvbiAoKSB7XG4gIHN0YWNrMiA9IChoZWxwZXIgPSBoZWxwZXJzLmRhdGVGb3JtYXQgfHwgZ2V0KGRlcHRoMCwgXCJkYXRlRm9ybWF0XCIsIFwiZGVwdGgwXCIpLG9wdGlvbnM9e2hhc2g6e30sZGF0YTpkYXRhLGF0dHJpYnV0ZTpmYWxzZSx1cGRhdGU6c2VsZi5zdWJzY3JpcHRpb24uYm91bmRVcGRhdGUsdW5zdWJzY3JpYmU6c2VsZi5zdWJzY3JpcHRpb24uYm91bmRVbnN1YnNjcmlwdGlvbn0saGVscGVyID8gaGVscGVyLmNhbGwoZGVwdGgwLCBnZXQoZGVwdGgwLCBcInVwZGF0ZWRBdFwiLCBcImRlcHRoMFwiKSwgb3B0aW9ucykgOiBoZWxwZXJNaXNzaW5nLmNhbGwoZGVwdGgwLCBcImRhdGVGb3JtYXRcIiwgZ2V0KGRlcHRoMCwgXCJ1cGRhdGVkQXRcIiwgXCJkZXB0aDBcIiksIG9wdGlvbnMpKTtcbiAgcmV0dXJuIHN0YWNrMjtcbiAgfTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBjcmVhdGVUZXh0KHN0YWNrMSkpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgICAgIFwiKSk7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTgyKGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgICAgICAgVW5zYXZlZFxcbiAgICAgICAgICBcIik7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTg0KGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBzdGFjazEsIGVsZW1lbnQxO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgXCIpKTtcbiAgc3RhY2sxID0gZWxlbWVudDEgPSBjcmVhdGVFbGVtZW50KHBhcnRpYWwoc2VsZi5wcm9ncmFtKDEsIHByb2dyYW0xLCBkYXRhKSwgZGVwdGgwKSwgZnVuY3Rpb24gKGVsKSB7IGVsZW1lbnQxID0gZWw7IH0pO1xuICBzZXRBdHRyaWJ1dGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZWxlbWVudDE7IH0sIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDMsIHByb2dyYW0zLCBkYXRhKSwgZGVwdGgwKSwgcGFydGlhbChzZWxmLnByb2dyYW0oODUsIHByb2dyYW04NSwgZGF0YSksIGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChlbGVtZW50MSwgc2VsZi5wcm9ncmFtKDg3LCBwcm9ncmFtODcsIGRhdGEpKGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIHN0YWNrMSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgXCIpKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuZnVuY3Rpb24gcHJvZ3JhbTg1KGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwibGlzdC1pdGVtIHNpZGViYXItdXBkYXRpbmcgdGV4dC1jZW50ZXJcIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtODcoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIHN0YWNrMSwgZWxlbWVudDE7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgICAgIFwiKSk7XG4gIHN0YWNrMSA9IGVsZW1lbnQxID0gY3JlYXRlRWxlbWVudChwYXJ0aWFsKHNlbGYucHJvZ3JhbSg4LCBwcm9ncmFtOCwgZGF0YSksIGRlcHRoMCksIGZ1bmN0aW9uIChlbCkgeyBlbGVtZW50MSA9IGVsOyB9KTtcbiAgc2V0QXR0cmlidXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVsZW1lbnQxOyB9LCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSgzLCBwcm9ncmFtMywgZGF0YSksIGRlcHRoMCksIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDg4LCBwcm9ncmFtODgsIGRhdGEpLCBkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoZWxlbWVudDEsIHNlbGYucHJvZ3JhbSgxMiwgcHJvZ3JhbTEyLCBkYXRhKShkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBzdGFjazEpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgXCIpKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuZnVuY3Rpb24gcHJvZ3JhbTg4KGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwiaWNvbi1hcnJvd3MtY3cgYW5pbWF0ZS1zcGluXCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTkwKGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBzdGFjazEsIHN0YWNrMiwgaGVscGVyLCBvcHRpb25zO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgXCIpKTtcbiAgc3RhY2sxID0gZnVuY3Rpb24gKCkge1xuICBzdGFjazIgPSAoaGVscGVyID0gaGVscGVycy5jb2xsZWN0aW9uIHx8IGdldChkZXB0aDAsIFwiY29sbGVjdGlvblwiLCBcImRlcHRoMFwiKSxvcHRpb25zPXtoYXNoOnt9LGludmVyc2U6d3JhcFByb2dyYW0oc2VsZi5ub29wKSxmbjp3cmFwUHJvZ3JhbShzZWxmLnByb2dyYW0oOTEsIHByb2dyYW05MSwgZGF0YSkpLGRhdGE6ZGF0YSxhdHRyaWJ1dGU6ZmFsc2UsdXBkYXRlOnNlbGYuc3Vic2NyaXB0aW9uLmJvdW5kVXBkYXRlLHVuc3Vic2NyaWJlOnNlbGYuc3Vic2NyaXB0aW9uLmJvdW5kVW5zdWJzY3JpcHRpb259LGhlbHBlciA/IGhlbHBlci5jYWxsKGRlcHRoMCwgKChzdGFjazEgPSAoZGF0YSA9PSBudWxsIHx8IGRhdGEgPT09IGZhbHNlID8gZGF0YSA6IGdldChkYXRhLCBcInBlcnNpc3RlbmNlXCIsIFwiZGF0YVwiKSkpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBnZXQoc3RhY2sxLCBcIml0ZW1zXCIsIFwic3RhY2sxXCIpKSwgb3B0aW9ucykgOiBoZWxwZXJNaXNzaW5nLmNhbGwoZGVwdGgwLCBcImNvbGxlY3Rpb25cIiwgKChzdGFjazEgPSAoZGF0YSA9PSBudWxsIHx8IGRhdGEgPT09IGZhbHNlID8gZGF0YSA6IGdldChkYXRhLCBcInBlcnNpc3RlbmNlXCIsIFwiZGF0YVwiKSkpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBnZXQoc3RhY2sxLCBcIml0ZW1zXCIsIFwic3RhY2sxXCIpKSwgb3B0aW9ucykpO1xuICByZXR1cm4gc3RhY2syO1xuICB9O1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGNyZWF0ZURPTShzdGFjazEpKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICBcIikpO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5mdW5jdGlvbiBwcm9ncmFtOTEoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIHN0YWNrMSwgZWxlbWVudDE7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgICAgIFwiKSk7XG4gIHN0YWNrMSA9IGVsZW1lbnQxID0gY3JlYXRlRWxlbWVudChwYXJ0aWFsKHNlbGYucHJvZ3JhbSgxLCBwcm9ncmFtMSwgZGF0YSksIGRlcHRoMCksIGZ1bmN0aW9uIChlbCkgeyBlbGVtZW50MSA9IGVsOyB9KTtcbiAgc2V0QXR0cmlidXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVsZW1lbnQxOyB9LCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSgzLCBwcm9ncmFtMywgZGF0YSksIGRlcHRoMCksIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDkyLCBwcm9ncmFtOTIsIGRhdGEpLCBkZXB0aDApKTtcbiAgc2V0QXR0cmlidXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVsZW1lbnQxOyB9LCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSg5NSwgcHJvZ3JhbTk1LCBkYXRhKSwgZGVwdGgwKSwgcGFydGlhbChzZWxmLnByb2dyYW0oNjUsIHByb2dyYW02NSwgZGF0YSksIGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChlbGVtZW50MSwgc2VsZi5wcm9ncmFtKDk3LCBwcm9ncmFtOTcsIGRhdGEpKGRlcHRoMCkpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIHN0YWNrMSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgICBcIikpO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5mdW5jdGlvbiBwcm9ncmFtOTIoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBcIlwiLCBzdGFjazEsIGhlbHBlciwgb3B0aW9ucztcbiAgYnVmZmVyICs9IFwibGlzdC1pdGVtIGl0ZW0gXCI7XG4gIHN0YWNrMSA9IChoZWxwZXIgPSBoZWxwZXJzLmVxdWFsIHx8IGdldChkZXB0aDAsIFwiZXF1YWxcIiwgXCJkZXB0aDBcIiksb3B0aW9ucz17aGFzaDp7fSxpbnZlcnNlOndyYXBQcm9ncmFtKHNlbGYubm9vcCksZm46d3JhcFByb2dyYW0oc2VsZi5wcm9ncmFtKDkzLCBwcm9ncmFtOTMsIGRhdGEpKSxkYXRhOmRhdGEsYXR0cmlidXRlOnRydWUsdXBkYXRlOnNlbGYuc3Vic2NyaXB0aW9uLmJvdW5kVXBkYXRlLHVuc3Vic2NyaWJlOnNlbGYuc3Vic2NyaXB0aW9uLmJvdW5kVW5zdWJzY3JpcHRpb259LGhlbHBlciA/IGhlbHBlci5jYWxsKGRlcHRoMCwgZ2V0KGRlcHRoMCwgXCJpZFwiLCBcImRlcHRoMFwiKSwgKChzdGFjazEgPSAoKHN0YWNrMSA9IChkYXRhID09IG51bGwgfHwgZGF0YSA9PT0gZmFsc2UgPyBkYXRhIDogZ2V0KGRhdGEsIFwicGVyc2lzdGVuY2VcIiwgXCJkYXRhXCIpKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IGdldChzdGFjazEsIFwibm90ZWJvb2tcIiwgXCJzdGFjazFcIikpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogZ2V0KHN0YWNrMSwgXCJpZFwiLCBcInN0YWNrMVwiKSksIG9wdGlvbnMpIDogaGVscGVyTWlzc2luZy5jYWxsKGRlcHRoMCwgXCJlcXVhbFwiLCBnZXQoZGVwdGgwLCBcImlkXCIsIFwiZGVwdGgwXCIpLCAoKHN0YWNrMSA9ICgoc3RhY2sxID0gKGRhdGEgPT0gbnVsbCB8fCBkYXRhID09PSBmYWxzZSA/IGRhdGEgOiBnZXQoZGF0YSwgXCJwZXJzaXN0ZW5jZVwiLCBcImRhdGFcIikpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogZ2V0KHN0YWNrMSwgXCJub3RlYm9va1wiLCBcInN0YWNrMVwiKSkpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBnZXQoc3RhY2sxLCBcImlkXCIsIFwic3RhY2sxXCIpKSwgb3B0aW9ucykpO1xuICBidWZmZXIgKz0gc3RhY2sxO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5mdW5jdGlvbiBwcm9ncmFtOTMoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJpdGVtLWhpZGRlblwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW05NShkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcImRhdGEtbG9hZFwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW05NyhkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgc3RhY2sxLCBlbGVtZW50MSwgZWxlbWVudDI7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgICAgICAgXCIpKTtcbiAgc3RhY2sxID0gZWxlbWVudDEgPSBjcmVhdGVFbGVtZW50KHBhcnRpYWwoc2VsZi5wcm9ncmFtKDgsIHByb2dyYW04LCBkYXRhKSwgZGVwdGgwKSwgZnVuY3Rpb24gKGVsKSB7IGVsZW1lbnQxID0gZWw7IH0pO1xuICBzZXRBdHRyaWJ1dGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZWxlbWVudDE7IH0sIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDMsIHByb2dyYW0zLCBkYXRhKSwgZGVwdGgwKSwgcGFydGlhbChzZWxmLnByb2dyYW0oNjEsIHByb2dyYW02MSwgZGF0YSksIGRlcHRoMCkpO1xuICBzZXRBdHRyaWJ1dGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZWxlbWVudDE7IH0sIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDYzLCBwcm9ncmFtNjMsIGRhdGEpLCBkZXB0aDApLCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSg2NSwgcHJvZ3JhbTY1LCBkYXRhKSwgZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGVsZW1lbnQxLCBzZWxmLnByb2dyYW0oMTIsIHByb2dyYW0xMiwgZGF0YSkoZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgc3RhY2sxKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcblxcbiAgICAgICAgICBcIikpO1xuICBzdGFjazEgPSBlbGVtZW50MiA9IGNyZWF0ZUVsZW1lbnQocGFydGlhbChzZWxmLnByb2dyYW0oMSwgcHJvZ3JhbTEsIGRhdGEpLCBkZXB0aDApLCBmdW5jdGlvbiAoZWwpIHsgZWxlbWVudDIgPSBlbDsgfSk7XG4gIHNldEF0dHJpYnV0ZShmdW5jdGlvbiAoKSB7IHJldHVybiBlbGVtZW50MjsgfSwgcGFydGlhbChzZWxmLnByb2dyYW0oMywgcHJvZ3JhbTMsIGRhdGEpLCBkZXB0aDApLCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSg2NywgcHJvZ3JhbTY3LCBkYXRhKSwgZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGVsZW1lbnQyLCBzZWxmLnByb2dyYW0oOTgsIHByb2dyYW05OCwgZGF0YSkoZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgc3RhY2sxKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICAgICAgXCIpKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuZnVuY3Rpb24gcHJvZ3JhbTk4KGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBzdGFjazEsIHN0YWNrMiwgZWxlbWVudDE7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgICAgICAgICBcIikpO1xuICBzdGFjazEgPSBlbGVtZW50MSA9IGNyZWF0ZUVsZW1lbnQocGFydGlhbChzZWxmLnByb2dyYW0oMSwgcHJvZ3JhbTEsIGRhdGEpLCBkZXB0aDApLCBmdW5jdGlvbiAoZWwpIHsgZWxlbWVudDEgPSBlbDsgfSk7XG4gIHNldEF0dHJpYnV0ZShmdW5jdGlvbiAoKSB7IHJldHVybiBlbGVtZW50MTsgfSwgcGFydGlhbChzZWxmLnByb2dyYW0oMywgcHJvZ3JhbTMsIGRhdGEpLCBkZXB0aDApLCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSg3MCwgcHJvZ3JhbTcwLCBkYXRhKSwgZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGVsZW1lbnQxLCBzZWxmLnByb2dyYW0oOTksIHByb2dyYW05OSwgZGF0YSkoZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgc3RhY2sxKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcblxcbiAgICAgICAgICAgIFwiKSk7XG4gIHN0YWNrMSA9IGZ1bmN0aW9uICgpIHtcbiAgc3RhY2syID0gaGVscGVyc1snaWYnXS5jYWxsKGRlcHRoMCwgZ2V0KGRlcHRoMCwgXCJ1cGRhdGVkQXRcIiwgXCJkZXB0aDBcIiksIHtoYXNoOnt9LGludmVyc2U6d3JhcFByb2dyYW0oc2VsZi5ub29wKSxmbjp3cmFwUHJvZ3JhbShzZWxmLnByb2dyYW0oMTA0LCBwcm9ncmFtMTA0LCBkYXRhKSksZGF0YTpkYXRhLGF0dHJpYnV0ZTpmYWxzZSx1cGRhdGU6c2VsZi5zdWJzY3JpcHRpb24uYm91bmRVcGRhdGUsdW5zdWJzY3JpYmU6c2VsZi5zdWJzY3JpcHRpb24uYm91bmRVbnN1YnNjcmlwdGlvbn0pO1xuICByZXR1cm4gc3RhY2syO1xuICB9O1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGNyZWF0ZURPTShzdGFjazEpKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcbiAgICAgICAgICBcIikpO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5mdW5jdGlvbiBwcm9ncmFtOTkoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBzdGFjazEsIHN0YWNrMjtcbiAgc3RhY2sxID0gZnVuY3Rpb24gKCkge1xuICBzdGFjazIgPSBoZWxwZXJzWydpZiddLmNhbGwoZGVwdGgwLCAoKHN0YWNrMSA9IGdldChkZXB0aDAsIFwibWV0YVwiLCBcImRlcHRoMFwiKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IGdldChzdGFjazEsIFwidGl0bGVcIiwgXCJzdGFjazFcIikpLCB7aGFzaDp7fSxpbnZlcnNlOndyYXBQcm9ncmFtKHNlbGYucHJvZ3JhbSgxMDIsIHByb2dyYW0xMDIsIGRhdGEpKSxmbjp3cmFwUHJvZ3JhbShzZWxmLnByb2dyYW0oMTAwLCBwcm9ncmFtMTAwLCBkYXRhKSksZGF0YTpkYXRhLGF0dHJpYnV0ZTpmYWxzZSx1cGRhdGU6c2VsZi5zdWJzY3JpcHRpb24uYm91bmRVcGRhdGUsdW5zdWJzY3JpYmU6c2VsZi5zdWJzY3JpcHRpb24uYm91bmRVbnN1YnNjcmlwdGlvbn0pO1xuICByZXR1cm4gc3RhY2syO1xuICB9O1xuICByZXR1cm4gY3JlYXRlRE9NKHN0YWNrMSk7XG4gIH1cbmZ1bmN0aW9uIHByb2dyYW0xMDAoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBzdGFjazEsIHN0YWNrMjtcbiAgc3RhY2sxID0gZnVuY3Rpb24gKCkge1xuICBzdGFjazIgPSAoKHN0YWNrMSA9ICgoc3RhY2sxID0gZ2V0KGRlcHRoMCwgXCJtZXRhXCIsIFwiZGVwdGgwXCIpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogZ2V0KHN0YWNrMSwgXCJ0aXRsZVwiLCBcInN0YWNrMVwiKSkpLHR5cGVvZiBzdGFjazEgPT09IGZ1bmN0aW9uVHlwZSA/IHN0YWNrMS5hcHBseShkZXB0aDApIDogc3RhY2sxKTtcbiAgcmV0dXJuIHN0YWNrMjtcbiAgfTtcbiAgcmV0dXJuIGNyZWF0ZVRleHQoc3RhY2sxKTtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtMTAyKGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgc3RhY2sxLCBzdGFjazIsIGhlbHBlcjtcbiAgc3RhY2sxID0gZnVuY3Rpb24gKCkge1xuICBpZiAoaGVscGVyID0gaGVscGVycy5pZCkgeyBzdGFjazIgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YSxhdHRyaWJ1dGU6ZmFsc2UsdXBkYXRlOnNlbGYuc3Vic2NyaXB0aW9uLmJvdW5kVXBkYXRlLHVuc3Vic2NyaWJlOnNlbGYuc3Vic2NyaXB0aW9uLmJvdW5kVW5zdWJzY3JpcHRpb259KTsgfVxuICBlbHNlIHsgaGVscGVyID0gZ2V0KGRlcHRoMCwgXCJpZFwiLCBcImRlcHRoMFwiKTsgc3RhY2syID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGEsYXR0cmlidXRlOmZhbHNlLHVwZGF0ZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVwZGF0ZSx1bnN1YnNjcmliZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVuc3Vic2NyaXB0aW9ufSkgOiBoZWxwZXI7IH1cbiAgcmV0dXJuIHN0YWNrMjtcbiAgfTtcbiAgcmV0dXJuIGNyZWF0ZVRleHQoc3RhY2sxKTtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtMTA0KGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBzdGFjazEsIGVsZW1lbnQxO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgICAgICAgICBcIikpO1xuICBzdGFjazEgPSBlbGVtZW50MSA9IGNyZWF0ZUVsZW1lbnQocGFydGlhbChzZWxmLnByb2dyYW0oMSwgcHJvZ3JhbTEsIGRhdGEpLCBkZXB0aDApLCBmdW5jdGlvbiAoZWwpIHsgZWxlbWVudDEgPSBlbDsgfSk7XG4gIHNldEF0dHJpYnV0ZShmdW5jdGlvbiAoKSB7IHJldHVybiBlbGVtZW50MTsgfSwgcGFydGlhbChzZWxmLnByb2dyYW0oMywgcHJvZ3JhbTMsIGRhdGEpLCBkZXB0aDApLCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSg3NywgcHJvZ3JhbTc3LCBkYXRhKSwgZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGVsZW1lbnQxLCBzZWxmLnByb2dyYW0oMTA1LCBwcm9ncmFtMTA1LCBkYXRhKShkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBzdGFjazEpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgICAgICAgXCIpKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuZnVuY3Rpb24gcHJvZ3JhbTEwNShkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIHN0YWNrMSwgc3RhY2syLCBoZWxwZXIsIG9wdGlvbnM7XG4gIHN0YWNrMSA9IGZ1bmN0aW9uICgpIHtcbiAgc3RhY2syID0gKGhlbHBlciA9IGhlbHBlcnMuZGF0ZUZvcm1hdCB8fCBnZXQoZGVwdGgwLCBcImRhdGVGb3JtYXRcIiwgXCJkZXB0aDBcIiksb3B0aW9ucz17aGFzaDp7fSxkYXRhOmRhdGEsYXR0cmlidXRlOmZhbHNlLHVwZGF0ZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVwZGF0ZSx1bnN1YnNjcmliZTpzZWxmLnN1YnNjcmlwdGlvbi5ib3VuZFVuc3Vic2NyaXB0aW9ufSxoZWxwZXIgPyBoZWxwZXIuY2FsbChkZXB0aDAsIGdldChkZXB0aDAsIFwidXBkYXRlZEF0XCIsIFwiZGVwdGgwXCIpLCBvcHRpb25zKSA6IGhlbHBlck1pc3NpbmcuY2FsbChkZXB0aDAsIFwiZGF0ZUZvcm1hdFwiLCBnZXQoZGVwdGgwLCBcInVwZGF0ZWRBdFwiLCBcImRlcHRoMFwiKSwgb3B0aW9ucykpO1xuICByZXR1cm4gc3RhY2syO1xuICB9O1xuICByZXR1cm4gY3JlYXRlVGV4dChzdGFjazEpO1xuICB9XG5cbiAgc3RhY2sxID0gZWxlbWVudDEgPSBjcmVhdGVFbGVtZW50KHBhcnRpYWwoc2VsZi5wcm9ncmFtKDEsIHByb2dyYW0xLCBkYXRhKSwgZGVwdGgwKSwgZnVuY3Rpb24gKGVsKSB7IGVsZW1lbnQxID0gZWw7IH0pO1xuICBzZXRBdHRyaWJ1dGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZWxlbWVudDE7IH0sIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDMsIHByb2dyYW0zLCBkYXRhKSwgZGVwdGgwKSwgcGFydGlhbChzZWxmLnByb2dyYW0oNSwgcHJvZ3JhbTUsIGRhdGEpLCBkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoZWxlbWVudDEsIHNlbGYucHJvZ3JhbSg3LCBwcm9ncmFtNywgZGF0YSkoZGVwdGgwKSk7XG4gIGFwcGVuZENoaWxkKGJ1ZmZlciwgc3RhY2sxKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcblxcblwiKSk7XG4gIHN0YWNrMSA9IGVsZW1lbnQyID0gY3JlYXRlRWxlbWVudChwYXJ0aWFsKHNlbGYucHJvZ3JhbSgxLCBwcm9ncmFtMSwgZGF0YSksIGRlcHRoMCksIGZ1bmN0aW9uIChlbCkgeyBlbGVtZW50MiA9IGVsOyB9KTtcbiAgc2V0QXR0cmlidXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVsZW1lbnQyOyB9LCBwYXJ0aWFsKHNlbGYucHJvZ3JhbSgzLCBwcm9ncmFtMywgZGF0YSksIGRlcHRoMCksIHBhcnRpYWwoc2VsZi5wcm9ncmFtKDE0LCBwcm9ncmFtMTQsIGRhdGEpLCBkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoZWxlbWVudDIsIHNlbGYucHJvZ3JhbSgxNiwgcHJvZ3JhbTE2LCBkYXRhKShkZXB0aDApKTtcbiAgYXBwZW5kQ2hpbGQoYnVmZmVyLCBzdGFjazEpO1xuICBhcHBlbmRDaGlsZChidWZmZXIsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuXCIpKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfSk7Il19
